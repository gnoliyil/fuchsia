library test.protocols;

using zx;

closed protocol WithAndWithoutRequestResponse {
    strict NoRequestNoResponse();
    strict NoRequestEmptyResponse() -> ();
    strict NoRequestWithResponse() -> (struct {
        ret string;
    });
    strict WithRequestNoResponse(struct {
        arg string;
    });
    strict WithRequestEmptyResponse(struct {
        arg string;
    }) -> ();
    strict WithRequestWithResponse(struct {
        arg string;
    }) -> (struct {
        ret string;
    });
    strict -> OnEmptyResponse();
    strict -> OnWithResponse(struct {
        ret string;
    });
};

type ErrorEnum = strict enum {
    ERR_FOO = 1;
    ERR_BAR = 2;
};

closed protocol WithErrorSyntax {
    strict ResponseAsStruct() -> (struct {
        a int64;
        b int64;
        c int64;
    }) error uint32;
    strict ErrorAsPrimitive() -> () error uint32;
    strict ErrorAsEnum() -> () error ErrorEnum;
    strict HandleInResult() -> (resource struct {
        h zx.handle;
    }) error uint32;
};

@transport("Channel")
closed protocol ChannelProtocol {
    strict MethodA(struct {
        a int64;
        b int64;
    });
    strict -> EventA(struct {
        a int64;
        b int64;
    });
    strict MethodB(struct {
        a int64;
        b int64;
    }) -> (struct {
        result int64;
    });
    strict TakeHandle(resource struct {
        h zx.handle;
    }) -> ();
    strict MutateSocket(resource struct {
        a zx.handle:SOCKET;
    }) -> (resource struct {
        b zx.handle:SOCKET;
    });
};

@transport("Syscall")
closed protocol SyscallProtocol {
    strict MethodC(struct {
        a int64;
        b int64;
    });
};

closed protocol Transitional {
    @transitional
    strict Request(struct {
        x int64;
    }) -> (struct {
        y int64;
    });

    @transitional
    strict OneWay(struct {
        x int64;
    });

    @transitional
    strict -> Event(struct {
        x int64;
    });
};

@discoverable
closed protocol DiscoverableProtocol {
    strict Method();
};

@discoverable("fake.library.FakeProtocol")
closed protocol AnotherDiscoverableProtocol {};

closed protocol HandleRightsProtocol {
    strict NoResponseMethod(resource struct {
        h zx.handle:<SOCKET, zx.rights.TRANSFER | zx.rights.DUPLICATE>;
    });
    strict ResponseMethod(resource struct {
        h zx.handle:<SOCKET, zx.rights.TRANSFER | zx.rights.DUPLICATE>;
    }) -> (resource struct {
        h zx.handle:<SOCKET, zx.rights.TRANSFER>;
    });
    strict -> AnEvent(resource struct {
        h zx.handle:<SOCKET, zx.rights.TRANSFER | zx.rights.DUPLICATE>;
    });
};

type ProtocolEnds = resource struct {
    client client_end:DiscoverableProtocol;
    server server_end:DiscoverableProtocol;
    client_opt client_end:<DiscoverableProtocol, optional>;
    server_opt server_end:<DiscoverableProtocol, optional>;
};

closed protocol WithProtocolEnds {
    strict ClientEnds(resource struct {
        in client_end:DiscoverableProtocol;
    }) -> (resource struct {
        out client_end:<DiscoverableProtocol, optional>;
    });
    strict ServerEnds(resource struct {
        in server_end:<DiscoverableProtocol, optional>;
    }) -> (resource struct {
        out server_end:DiscoverableProtocol;
    });
    strict StructContainingEnds(resource struct {
        in ProtocolEnds;
    }) -> (resource struct {
        out ProtocolEnds;
    });
};

closed protocol ManyParameters {
    // TODO(fxbug.dev/76655): Support an arbitrary number of parameters in Rust.
    @bindings_denylist("rust")
    strict Fifteen(struct {
        p1 bool;
        p2 bool;
        p3 bool;
        p4 bool;
        p5 bool;
        p6 bool;
        p7 bool;
        p8 bool;
        p9 bool;
        p10 bool;
        p11 bool;
        p12 bool;
        p13 bool;
        p14 bool;
        p15 bool;
    });
};

type TheUnion = flexible union {
    1: v uint32;
};

closed protocol MethodWithUnion {
    strict UnionMethod(struct {
        u TheUnion;
    }) -> (struct {
        u TheUnion:optional;
    });
};
