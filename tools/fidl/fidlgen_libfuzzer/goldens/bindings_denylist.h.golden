// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

#pragma once

#include <test/bindingsdenylist/cpp/fidl.h>
#include <test/dependent/cpp/libfuzzer.h>

#include "lib/fidl/cpp/fuzzing/traits.h"
#include "lib/fidl/cpp/internal/header.h"
// For ::std::max_element().
#include <algorithm>
// For uint64_t.
#include <stdint.h>

namespace fuzzing {

using DenyEachBindingOnlyDenyDartRequest = ::test::bindingsdenylist::DenyEachBindingOnlyDenyDartRequest;
using DenyEachBinding_OnlyDenyDart_Response = ::test::bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response;
using DenyEachBinding_OnlyDenyDart_Result = ::test::bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result;
using DenyEachBindingOnlyDenyDartTopResponse = ::test::bindingsdenylist::DenyEachBindingOnlyDenyDartTopResponse;
using DenyEachBindingOnlyDenyGoRequest = ::test::bindingsdenylist::DenyEachBindingOnlyDenyGoRequest;
using DenyEachBinding_OnlyDenyGo_Response = ::test::bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response;
using DenyEachBinding_OnlyDenyGo_Result = ::test::bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result;
using DenyEachBindingOnlyDenyGoTopResponse = ::test::bindingsdenylist::DenyEachBindingOnlyDenyGoTopResponse;
using DenyEachBindingOnlyDenyRustRequest = ::test::bindingsdenylist::DenyEachBindingOnlyDenyRustRequest;
using DenyEachBinding_OnlyDenyRust_Response = ::test::bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response;
using DenyEachBinding_OnlyDenyRust_Result = ::test::bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result;
using DenyEachBindingOnlyDenyRustTopResponse = ::test::bindingsdenylist::DenyEachBindingOnlyDenyRustTopResponse;
using DenyEachBindingOnlyDenySyzkallerRequest = ::test::bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest;
using DenyEachBinding_OnlyDenySyzkaller_Response = ::test::bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response;
using DenyEachBinding_OnlyDenySyzkaller_Result = ::test::bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result;
using DenyEachBindingOnlyDenySyzkallerTopResponse = ::test::bindingsdenylist::DenyEachBindingOnlyDenySyzkallerTopResponse;
using MemberOnlyAppearsInImportingLibrary = ::test::bindingsdenylist::MemberOnlyAppearsInImportingLibrary;
using OnlyAppearsInImportingLibrary = ::test::bindingsdenylist::OnlyAppearsInImportingLibrary;

template <>
struct MinSize<DenyEachBindingOnlyDenyDartRequest> {
  operator size_t() {
    return MinSize<bool>();
  }
};
template <>
struct Allocate<DenyEachBindingOnlyDenyDartRequest> {
  DenyEachBindingOnlyDenyDartRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBindingOnlyDenyDartRequest>());
    DenyEachBindingOnlyDenyDartRequest out;
    const size_t slack_per_member = (*size - MinSize<DenyEachBindingOnlyDenyDartRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.a = Allocate<bool>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyDart_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyDart_Response> {
  DenyEachBinding_OnlyDenyDart_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyDart_Response>());
    DenyEachBinding_OnlyDenyDart_Response out;
    const size_t slack_per_member = (*size - MinSize<DenyEachBinding_OnlyDenyDart_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyDart_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response>(), MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyDart_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenyDart_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyDart_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenyDart_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<DenyEachBindingOnlyDenyDartTopResponse> {
  operator size_t() {
    return MinSize<::test::bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result>();
  }
};
template <>
struct Allocate<DenyEachBindingOnlyDenyDartTopResponse> {
  DenyEachBindingOnlyDenyDartTopResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBindingOnlyDenyDartTopResponse>());
    DenyEachBindingOnlyDenyDartTopResponse out;
    const size_t slack_per_member = (*size - MinSize<DenyEachBindingOnlyDenyDartTopResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result>() + slack_per_member;
    out.result = Allocate<::test::bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBindingOnlyDenyGoRequest> {
  operator size_t() {
    return MinSize<bool>();
  }
};
template <>
struct Allocate<DenyEachBindingOnlyDenyGoRequest> {
  DenyEachBindingOnlyDenyGoRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBindingOnlyDenyGoRequest>());
    DenyEachBindingOnlyDenyGoRequest out;
    const size_t slack_per_member = (*size - MinSize<DenyEachBindingOnlyDenyGoRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.a = Allocate<bool>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyGo_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyGo_Response> {
  DenyEachBinding_OnlyDenyGo_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyGo_Response>());
    DenyEachBinding_OnlyDenyGo_Response out;
    const size_t slack_per_member = (*size - MinSize<DenyEachBinding_OnlyDenyGo_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyGo_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response>(), MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyGo_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenyGo_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyGo_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenyGo_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<DenyEachBindingOnlyDenyGoTopResponse> {
  operator size_t() {
    return MinSize<::test::bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result>();
  }
};
template <>
struct Allocate<DenyEachBindingOnlyDenyGoTopResponse> {
  DenyEachBindingOnlyDenyGoTopResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBindingOnlyDenyGoTopResponse>());
    DenyEachBindingOnlyDenyGoTopResponse out;
    const size_t slack_per_member = (*size - MinSize<DenyEachBindingOnlyDenyGoTopResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result>() + slack_per_member;
    out.result = Allocate<::test::bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBindingOnlyDenyRustRequest> {
  operator size_t() {
    return MinSize<bool>();
  }
};
template <>
struct Allocate<DenyEachBindingOnlyDenyRustRequest> {
  DenyEachBindingOnlyDenyRustRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBindingOnlyDenyRustRequest>());
    DenyEachBindingOnlyDenyRustRequest out;
    const size_t slack_per_member = (*size - MinSize<DenyEachBindingOnlyDenyRustRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.a = Allocate<bool>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyRust_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyRust_Response> {
  DenyEachBinding_OnlyDenyRust_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyRust_Response>());
    DenyEachBinding_OnlyDenyRust_Response out;
    const size_t slack_per_member = (*size - MinSize<DenyEachBinding_OnlyDenyRust_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyRust_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response>(), MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyRust_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenyRust_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyRust_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenyRust_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<DenyEachBindingOnlyDenyRustTopResponse> {
  operator size_t() {
    return MinSize<::test::bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result>();
  }
};
template <>
struct Allocate<DenyEachBindingOnlyDenyRustTopResponse> {
  DenyEachBindingOnlyDenyRustTopResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBindingOnlyDenyRustTopResponse>());
    DenyEachBindingOnlyDenyRustTopResponse out;
    const size_t slack_per_member = (*size - MinSize<DenyEachBindingOnlyDenyRustTopResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result>() + slack_per_member;
    out.result = Allocate<::test::bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBindingOnlyDenySyzkallerRequest> {
  operator size_t() {
    return MinSize<bool>();
  }
};
template <>
struct Allocate<DenyEachBindingOnlyDenySyzkallerRequest> {
  DenyEachBindingOnlyDenySyzkallerRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBindingOnlyDenySyzkallerRequest>());
    DenyEachBindingOnlyDenySyzkallerRequest out;
    const size_t slack_per_member = (*size - MinSize<DenyEachBindingOnlyDenySyzkallerRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.a = Allocate<bool>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenySyzkaller_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenySyzkaller_Response> {
  DenyEachBinding_OnlyDenySyzkaller_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenySyzkaller_Response>());
    DenyEachBinding_OnlyDenySyzkaller_Response out;
    const size_t slack_per_member = (*size - MinSize<DenyEachBinding_OnlyDenySyzkaller_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenySyzkaller_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response>(), MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenySyzkaller_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenySyzkaller_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenySyzkaller_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenySyzkaller_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<DenyEachBindingOnlyDenySyzkallerTopResponse> {
  operator size_t() {
    return MinSize<::test::bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result>();
  }
};
template <>
struct Allocate<DenyEachBindingOnlyDenySyzkallerTopResponse> {
  DenyEachBindingOnlyDenySyzkallerTopResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBindingOnlyDenySyzkallerTopResponse>());
    DenyEachBindingOnlyDenySyzkallerTopResponse out;
    const size_t slack_per_member = (*size - MinSize<DenyEachBindingOnlyDenySyzkallerTopResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result>() + slack_per_member;
    out.result = Allocate<::test::bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<MemberOnlyAppearsInImportingLibrary> {
  operator size_t() {
    return MinSize<bool>();
  }
};
template <>
struct Allocate<MemberOnlyAppearsInImportingLibrary> {
  MemberOnlyAppearsInImportingLibrary operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<MemberOnlyAppearsInImportingLibrary>());
    MemberOnlyAppearsInImportingLibrary out;
    const size_t slack_per_member = (*size - MinSize<MemberOnlyAppearsInImportingLibrary>()) / 1;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.a = Allocate<bool>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<OnlyAppearsInImportingLibrary> {
  operator size_t() {
    return MinSize<::test::bindingsdenylist::MemberOnlyAppearsInImportingLibrary>();
  }
};
template <>
struct Allocate<OnlyAppearsInImportingLibrary> {
  OnlyAppearsInImportingLibrary operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<OnlyAppearsInImportingLibrary>());
    OnlyAppearsInImportingLibrary out;
    const size_t slack_per_member = (*size - MinSize<OnlyAppearsInImportingLibrary>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::bindingsdenylist::MemberOnlyAppearsInImportingLibrary>() + slack_per_member;
    out.member_only_appears_in_importing_library = Allocate<::test::bindingsdenylist::MemberOnlyAppearsInImportingLibrary>{}(src, &out_size);
    return out;
  }
};

}  // namespace fuzzing
