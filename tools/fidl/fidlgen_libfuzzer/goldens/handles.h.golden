// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

#pragma once

#include <fdf/cpp/libfuzzer.h>
#include <test/handles/cpp/fidl.h>

#include "lib/fidl/cpp/fuzzing/traits.h"
#include "lib/fidl/cpp/internal/header.h"
// For ::std::max_element().
#include <algorithm>
// For uint64_t.
#include <stdint.h>

namespace fuzzing {

using Handles = ::test::handles::Handles;
using FdfHandles = ::test::handles::FdfHandles;

template <>
struct MinSize<Handles> {
  operator size_t() {
    return MinSize<::zx::handle>() + MinSize<::zx::bti>() + MinSize<::zx::channel>() + MinSize<::zx::clock>() + MinSize<::zx::debuglog>() + MinSize<::zx::event>() + MinSize<::zx::eventpair>() + MinSize<::zx::exception>() + MinSize<::zx::fifo>() + MinSize<::zx::guest>() + MinSize<::zx::interrupt>() + MinSize<::zx::iommu>() + MinSize<::zx::job>() + MinSize<::zx::msi>() + MinSize<::zx::pager>() + MinSize<::zx::pmt>() + MinSize<::zx::port>() + MinSize<::zx::process>() + MinSize<::zx::profile>() + MinSize<::zx::resource>() + MinSize<::zx::socket>() + MinSize<::zx::stream>() + MinSize<::zx::suspend_token>() + MinSize<::zx::thread>() + MinSize<::zx::timer>() + MinSize<::zx::vcpu>() + MinSize<::zx::vmar>() + MinSize<::zx::vmo>() + MinSize<::zx::vmo>() + MinSize<::zx::handle>() + MinSize<::zx::vmo>() + MinSize<::zx::vmo>() + MinSize<::fidl::InterfaceHandle<::test::handles::SomeProtocol>>() + MinSize<::fidl::InterfaceRequest<::test::handles::SomeProtocol>>();
  }
};
template <>
struct Allocate<Handles> {
  Handles operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Handles>());
    Handles out;
    const size_t slack_per_member = (*size - MinSize<Handles>()) / 34;
    size_t out_size;
    out_size = MinSize<::zx::handle>() + slack_per_member;
    out.plain_handle = Allocate<::zx::handle>{}(src, &out_size);
    out_size = MinSize<::zx::bti>() + slack_per_member;
    out.bti_handle = Allocate<::zx::bti>{}(src, &out_size);
    out_size = MinSize<::zx::channel>() + slack_per_member;
    out.channel_handle = Allocate<::zx::channel>{}(src, &out_size);
    out_size = MinSize<::zx::clock>() + slack_per_member;
    out.clock_handle = Allocate<::zx::clock>{}(src, &out_size);
    out_size = MinSize<::zx::debuglog>() + slack_per_member;
    out.debuglog_handle = Allocate<::zx::debuglog>{}(src, &out_size);
    out_size = MinSize<::zx::event>() + slack_per_member;
    out.event_handle = Allocate<::zx::event>{}(src, &out_size);
    out_size = MinSize<::zx::eventpair>() + slack_per_member;
    out.eventpair_handle = Allocate<::zx::eventpair>{}(src, &out_size);
    out_size = MinSize<::zx::exception>() + slack_per_member;
    out.exception_handle = Allocate<::zx::exception>{}(src, &out_size);
    out_size = MinSize<::zx::fifo>() + slack_per_member;
    out.fifo_handle = Allocate<::zx::fifo>{}(src, &out_size);
    out_size = MinSize<::zx::guest>() + slack_per_member;
    out.guest_handle = Allocate<::zx::guest>{}(src, &out_size);
    out_size = MinSize<::zx::interrupt>() + slack_per_member;
    out.interrupt_handle = Allocate<::zx::interrupt>{}(src, &out_size);
    out_size = MinSize<::zx::iommu>() + slack_per_member;
    out.iommu_handle = Allocate<::zx::iommu>{}(src, &out_size);
    out_size = MinSize<::zx::job>() + slack_per_member;
    out.job_handle = Allocate<::zx::job>{}(src, &out_size);
    out_size = MinSize<::zx::msi>() + slack_per_member;
    out.msi_handle = Allocate<::zx::msi>{}(src, &out_size);
    out_size = MinSize<::zx::pager>() + slack_per_member;
    out.pager_handle = Allocate<::zx::pager>{}(src, &out_size);
    out_size = MinSize<::zx::pmt>() + slack_per_member;
    out.pmt_handle = Allocate<::zx::pmt>{}(src, &out_size);
    out_size = MinSize<::zx::port>() + slack_per_member;
    out.port_handle = Allocate<::zx::port>{}(src, &out_size);
    out_size = MinSize<::zx::process>() + slack_per_member;
    out.process_handle = Allocate<::zx::process>{}(src, &out_size);
    out_size = MinSize<::zx::profile>() + slack_per_member;
    out.profile_handle = Allocate<::zx::profile>{}(src, &out_size);
    out_size = MinSize<::zx::resource>() + slack_per_member;
    out.resource_handle = Allocate<::zx::resource>{}(src, &out_size);
    out_size = MinSize<::zx::socket>() + slack_per_member;
    out.socket_handle = Allocate<::zx::socket>{}(src, &out_size);
    out_size = MinSize<::zx::stream>() + slack_per_member;
    out.stream_handle = Allocate<::zx::stream>{}(src, &out_size);
    out_size = MinSize<::zx::suspend_token>() + slack_per_member;
    out.suspendtoken_handle = Allocate<::zx::suspend_token>{}(src, &out_size);
    out_size = MinSize<::zx::thread>() + slack_per_member;
    out.thread_handle = Allocate<::zx::thread>{}(src, &out_size);
    out_size = MinSize<::zx::timer>() + slack_per_member;
    out.timer_handle = Allocate<::zx::timer>{}(src, &out_size);
    out_size = MinSize<::zx::vcpu>() + slack_per_member;
    out.vcpu_handle = Allocate<::zx::vcpu>{}(src, &out_size);
    out_size = MinSize<::zx::vmar>() + slack_per_member;
    out.vmar_handle = Allocate<::zx::vmar>{}(src, &out_size);
    out_size = MinSize<::zx::vmo>() + slack_per_member;
    out.vmo_handle = Allocate<::zx::vmo>{}(src, &out_size);
    out_size = MinSize<::zx::vmo>() + slack_per_member;
    out.rights_handle = Allocate<::zx::vmo>{}(src, &out_size);
    out_size = MinSize<::zx::handle>() + slack_per_member;
    out.aliased_plain_handle_field = Allocate<::zx::handle>{}(src, &out_size);
    out_size = MinSize<::zx::vmo>() + slack_per_member;
    out.aliased_subtype_handle_field = Allocate<::zx::vmo>{}(src, &out_size);
    out_size = MinSize<::zx::vmo>() + slack_per_member;
    out.aliased_rights_handle_field = Allocate<::zx::vmo>{}(src, &out_size);
    out_size = MinSize<::fidl::InterfaceHandle<::test::handles::SomeProtocol>>() + slack_per_member;
    out.some_protocol = Allocate<::fidl::InterfaceHandle<::test::handles::SomeProtocol>>{}(src, &out_size);
    out_size = MinSize<::fidl::InterfaceRequest<::test::handles::SomeProtocol>>() + slack_per_member;
    out.request_some_protocol = Allocate<::fidl::InterfaceRequest<::test::handles::SomeProtocol>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<FdfHandles> {
  operator size_t() {
    return MinSize<::fdf::Channel>() + MinSize<::fidl::InterfaceHandle<::test::handles::DriverProtocol>>() + MinSize<::fidl::InterfaceRequest<::test::handles::DriverProtocol>>();
  }
};
template <>
struct Allocate<FdfHandles> {
  FdfHandles operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<FdfHandles>());
    FdfHandles out;
    const size_t slack_per_member = (*size - MinSize<FdfHandles>()) / 3;
    size_t out_size;
    out_size = MinSize<::fdf::Channel>() + slack_per_member;
    out.fdf_channel_handle = Allocate<::fdf::Channel>{}(src, &out_size);
    out_size = MinSize<::fidl::InterfaceHandle<::test::handles::DriverProtocol>>() + slack_per_member;
    out.client_end_driver = Allocate<::fidl::InterfaceHandle<::test::handles::DriverProtocol>>{}(src, &out_size);
    out_size = MinSize<::fidl::InterfaceRequest<::test::handles::DriverProtocol>>() + slack_per_member;
    out.server_end_driver = Allocate<::fidl::InterfaceRequest<::test::handles::DriverProtocol>>{}(src, &out_size);
    return out;
  }
};

}  // namespace fuzzing
