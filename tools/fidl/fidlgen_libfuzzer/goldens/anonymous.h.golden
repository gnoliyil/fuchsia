// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include <test/anonymous/cpp/fidl.h>

#include "lib/fidl/cpp/fuzzing/traits.h"
#include "lib/fidl/cpp/internal/header.h"
// For ::std::max_element().
#include <algorithm>
// For uint64_t.
#include <stdint.h>

namespace fuzzing {

using Op = ::test::anonymous::Op;
using OverrideTest = ::test::anonymous::OverrideTest;
using Flags = ::test::anonymous::Flags;
using FunctionApplication = ::test::anonymous::FunctionApplication;
using Expression = ::test::anonymous::Expression;
using UnionMember = ::test::anonymous::UnionMember;
using TableData = ::test::anonymous::TableData;
using TableMember = ::test::anonymous::TableMember;
using SomeProtocolSomeMethodRequest = ::test::anonymous::SomeProtocolSomeMethodRequest;
using BitsMember = ::test::anonymous::BitsMember;
using SomeProtocol_SomeMethod_Response = ::test::anonymous::SomeProtocol_SomeMethod_Response;
using SomeProtocol_SomeMethod_Error = ::test::anonymous::SomeProtocol_SomeMethod_Error;
using SomeProtocol_SomeMethod_Result = ::test::anonymous::SomeProtocol_SomeMethod_Result;
using SomeProtocolSomeMethodTopResponse = ::test::anonymous::SomeProtocolSomeMethodTopResponse;

template <>
struct MinSize<Op> {
  operator size_t() { return sizeof(uint64_t); }
};
template <>
struct Allocate<Op> {
  Op operator()(FuzzInput* src, size_t* size) {
    Op out;
    uint64_t selector;
    ZX_ASSERT(*size >= sizeof(uint64_t));
    ZX_ASSERT(src->CopyObject(&selector));
    *size = sizeof(uint64_t);

    switch (selector % 3) {
      case 0:
        out = Op::ADD;
        break;
      case 1:
        out = Op::MUL;
        break;
      case 2:
        out = Op::DIV;
        break;
    }

    return out;
  }
};
template <>
struct MinSize<OverrideTest> {
  operator size_t() {
    return MinSize<::test::anonymous::Op>() + MinSize<::std::unique_ptr<::test::anonymous::Expression>>() + MinSize<::std::unique_ptr<::test::anonymous::Expression>>();
  }
};
template <>
struct Allocate<OverrideTest> {
  OverrideTest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<OverrideTest>());
    OverrideTest out;
    const size_t slack_per_member = (*size - MinSize<OverrideTest>()) / 3;
    size_t out_size;
    out_size = MinSize<::test::anonymous::Op>() + slack_per_member;
    out.op = Allocate<::test::anonymous::Op>{}(src, &out_size);
    out_size = MinSize<::std::unique_ptr<::test::anonymous::Expression>>() + slack_per_member;
    out.left = Allocate<::std::unique_ptr<::test::anonymous::Expression>>{}(src, &out_size);
    out_size = MinSize<::std::unique_ptr<::test::anonymous::Expression>>() + slack_per_member;
    out.right = Allocate<::std::unique_ptr<::test::anonymous::Expression>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<Flags> {
  operator size_t() { return sizeof(uint16_t); }
};
template <>
struct Allocate<Flags> {
  Flags operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= sizeof(uint16_t));
    return Flags(*reinterpret_cast<const uint16_t*>(src->TakeBytes(sizeof(uint16_t))));
  }
};
template <>
struct MinSize<FunctionApplication> {
  operator size_t() {
    return MinSize<::std::string>() + MinSize<::std::vector<::std::unique_ptr<::test::anonymous::Expression>>>() + MinSize<::test::anonymous::Flags>();
  }
};
template <>
struct Allocate<FunctionApplication> {
  FunctionApplication operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<FunctionApplication>());
    FunctionApplication out;
    const size_t slack_per_member = (*size - MinSize<FunctionApplication>()) / 3;
    size_t out_size;
    out_size = MinSize<::std::string>() + slack_per_member;
    out.set_func(Allocate<::std::string>{}(src, &out_size));
    out_size = MinSize<::std::vector<::std::unique_ptr<::test::anonymous::Expression>>>() + slack_per_member;
    out.set_args(Allocate<::std::vector<::std::unique_ptr<::test::anonymous::Expression>>>{}(src, &out_size));
    out_size = MinSize<::test::anonymous::Flags>() + slack_per_member;
    out.set_flags(Allocate<::test::anonymous::Flags>{}(src, &out_size));
    return out;
  }
};
template <>
struct MinSize<Expression> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<uint64_t>(), MinSize<::test::anonymous::OverrideTest>(), MinSize<::test::anonymous::FunctionApplication>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template <>
struct Allocate<Expression> {
  static_assert(3 > 0, "xunion must have at least one member");

  Expression operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Expression>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    Expression out;
    switch (selector % 3) {
      case 0: {
        out.set_value(Allocate<uint64_t>{}(src, size));
        break;
      }
      case 1: {
        out.set_bin_op(Allocate<::test::anonymous::OverrideTest>{}(src, size));
        break;
      }
      case 2: {
        out.set_function_application(Allocate<::test::anonymous::FunctionApplication>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<UnionMember> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<uint8_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template <>
struct Allocate<UnionMember> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnionMember operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnionMember>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnionMember out;
    switch (selector % 1) {
      case 0: {
        out.set_union_data(Allocate<uint8_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<TableData> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template <>
struct Allocate<TableData> {
  TableData operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<TableData>());
    TableData out;
    const size_t slack_per_member = (*size - MinSize<TableData>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.data = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<TableMember> {
  operator size_t() {
    return MinSize<::std::vector<::test::anonymous::TableData>>();
  }
};
template <>
struct Allocate<TableMember> {
  TableMember operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<TableMember>());
    TableMember out;
    const size_t slack_per_member = (*size - MinSize<TableMember>()) / 1;
    size_t out_size;
    out_size = MinSize<::std::vector<::test::anonymous::TableData>>() + slack_per_member;
    out.set_table_data(Allocate<::std::vector<::test::anonymous::TableData>>{}(src, &out_size));
    return out;
  }
};
template <>
struct MinSize<SomeProtocolSomeMethodRequest> {
  operator size_t() {
    return MinSize<::test::anonymous::UnionMember>() + MinSize<::test::anonymous::TableMember>();
  }
};
template <>
struct Allocate<SomeProtocolSomeMethodRequest> {
  SomeProtocolSomeMethodRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<SomeProtocolSomeMethodRequest>());
    SomeProtocolSomeMethodRequest out;
    const size_t slack_per_member = (*size - MinSize<SomeProtocolSomeMethodRequest>()) / 2;
    size_t out_size;
    out_size = MinSize<::test::anonymous::UnionMember>() + slack_per_member;
    out.union_member = Allocate<::test::anonymous::UnionMember>{}(src, &out_size);
    out_size = MinSize<::test::anonymous::TableMember>() + slack_per_member;
    out.table_member = Allocate<::test::anonymous::TableMember>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<BitsMember> {
  operator size_t() { return sizeof(uint32_t); }
};
template <>
struct Allocate<BitsMember> {
  BitsMember operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= sizeof(uint32_t));
    return BitsMember(*reinterpret_cast<const uint32_t*>(src->TakeBytes(sizeof(uint32_t))));
  }
};
template <>
struct MinSize<SomeProtocol_SomeMethod_Response> {
  operator size_t() {
    return MinSize<::test::anonymous::BitsMember>();
  }
};
template <>
struct Allocate<SomeProtocol_SomeMethod_Response> {
  SomeProtocol_SomeMethod_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<SomeProtocol_SomeMethod_Response>());
    SomeProtocol_SomeMethod_Response out;
    const size_t slack_per_member = (*size - MinSize<SomeProtocol_SomeMethod_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::anonymous::BitsMember>() + slack_per_member;
    out.bits_member = Allocate<::test::anonymous::BitsMember>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<SomeProtocol_SomeMethod_Error> {
  operator size_t() { return sizeof(uint64_t); }
};
template <>
struct Allocate<SomeProtocol_SomeMethod_Error> {
  SomeProtocol_SomeMethod_Error operator()(FuzzInput* src, size_t* size) {
    SomeProtocol_SomeMethod_Error out;
    uint64_t selector;
    ZX_ASSERT(*size >= sizeof(uint64_t));
    ZX_ASSERT(src->CopyObject(&selector));
    *size = sizeof(uint64_t);

    switch (selector % 2) {
      case 0:
        out = SomeProtocol_SomeMethod_Error::ERROR_ONE;
        break;
      case 1:
        out = SomeProtocol_SomeMethod_Error::ERROR_TWO;
        break;
    }

    return out;
  }
};
template <>
struct MinSize<SomeProtocol_SomeMethod_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::anonymous::SomeProtocol_SomeMethod_Response>(), MinSize<::test::anonymous::SomeProtocol_SomeMethod_Error>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<SomeProtocol_SomeMethod_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  SomeProtocol_SomeMethod_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<SomeProtocol_SomeMethod_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    SomeProtocol_SomeMethod_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::anonymous::SomeProtocol_SomeMethod_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<::test::anonymous::SomeProtocol_SomeMethod_Error>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<SomeProtocolSomeMethodTopResponse> {
  operator size_t() {
    return MinSize<::test::anonymous::SomeProtocol_SomeMethod_Result>();
  }
};
template <>
struct Allocate<SomeProtocolSomeMethodTopResponse> {
  SomeProtocolSomeMethodTopResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<SomeProtocolSomeMethodTopResponse>());
    SomeProtocolSomeMethodTopResponse out;
    const size_t slack_per_member = (*size - MinSize<SomeProtocolSomeMethodTopResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<::test::anonymous::SomeProtocol_SomeMethod_Result>() + slack_per_member;
    out.result = Allocate<::test::anonymous::SomeProtocol_SomeMethod_Result>{}(src, &out_size);
    return out;
  }
};

}  // namespace fuzzing
