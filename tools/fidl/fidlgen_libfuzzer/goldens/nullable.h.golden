// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

#pragma once

#include <test/nullable/cpp/fidl.h>

#include "lib/fidl/cpp/fuzzing/traits.h"
#include "lib/fidl/cpp/internal/header.h"
// For ::std::max_element().
#include <algorithm>
// For uint64_t.
#include <stdint.h>

namespace fuzzing {

using StructWithNullableString = ::test::nullable::StructWithNullableString;
using StructWithNullableVector = ::test::nullable::StructWithNullableVector;
using StructWithNullableHandle = ::test::nullable::StructWithNullableHandle;
using SimpleProtocolAddRequest = ::test::nullable::SimpleProtocolAddRequest;
using SimpleProtocolAddResponse = ::test::nullable::SimpleProtocolAddResponse;
using StructWithNullableProtocol = ::test::nullable::StructWithNullableProtocol;
using StructWithNullableRequest = ::test::nullable::StructWithNullableRequest;
using Int32Wrapper = ::test::nullable::Int32Wrapper;
using StructWithNullableStruct = ::test::nullable::StructWithNullableStruct;
using SimpleUnion = ::test::nullable::SimpleUnion;
using StructWithNullableUnion = ::test::nullable::StructWithNullableUnion;

template <>
struct MinSize<StructWithNullableString> {
  operator size_t() {
    return MinSize<::fidl::StringPtr>();
  }
};
template <>
struct Allocate<StructWithNullableString> {
  StructWithNullableString operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StructWithNullableString>());
    StructWithNullableString out;
    const size_t slack_per_member = (*size - MinSize<StructWithNullableString>()) / 1;
    size_t out_size;
    out_size = MinSize<::fidl::StringPtr>() + slack_per_member;
    out.val = Allocate<::fidl::StringPtr>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<StructWithNullableVector> {
  operator size_t() {
    return MinSize<::fidl::VectorPtr<int32_t>>();
  }
};
template <>
struct Allocate<StructWithNullableVector> {
  StructWithNullableVector operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StructWithNullableVector>());
    StructWithNullableVector out;
    const size_t slack_per_member = (*size - MinSize<StructWithNullableVector>()) / 1;
    size_t out_size;
    out_size = MinSize<::fidl::VectorPtr<int32_t>>() + slack_per_member;
    out.val = Allocate<::fidl::VectorPtr<int32_t>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<StructWithNullableHandle> {
  operator size_t() {
    return MinSize<::zx::vmo>();
  }
};
template <>
struct Allocate<StructWithNullableHandle> {
  StructWithNullableHandle operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StructWithNullableHandle>());
    StructWithNullableHandle out;
    const size_t slack_per_member = (*size - MinSize<StructWithNullableHandle>()) / 1;
    size_t out_size;
    out_size = MinSize<::zx::vmo>() + slack_per_member;
    out.val = Allocate<::zx::vmo>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<SimpleProtocolAddRequest> {
  operator size_t() {
    return MinSize<int32_t>() + MinSize<int32_t>();
  }
};
template <>
struct Allocate<SimpleProtocolAddRequest> {
  SimpleProtocolAddRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<SimpleProtocolAddRequest>());
    SimpleProtocolAddRequest out;
    const size_t slack_per_member = (*size - MinSize<SimpleProtocolAddRequest>()) / 2;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.a = Allocate<int32_t>{}(src, &out_size);
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<SimpleProtocolAddResponse> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template <>
struct Allocate<SimpleProtocolAddResponse> {
  SimpleProtocolAddResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<SimpleProtocolAddResponse>());
    SimpleProtocolAddResponse out;
    const size_t slack_per_member = (*size - MinSize<SimpleProtocolAddResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.sum = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<StructWithNullableProtocol> {
  operator size_t() {
    return MinSize<::fidl::InterfaceHandle<::test::nullable::SimpleProtocol>>();
  }
};
template <>
struct Allocate<StructWithNullableProtocol> {
  StructWithNullableProtocol operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StructWithNullableProtocol>());
    StructWithNullableProtocol out;
    const size_t slack_per_member = (*size - MinSize<StructWithNullableProtocol>()) / 1;
    size_t out_size;
    out_size = MinSize<::fidl::InterfaceHandle<::test::nullable::SimpleProtocol>>() + slack_per_member;
    out.val = Allocate<::fidl::InterfaceHandle<::test::nullable::SimpleProtocol>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<StructWithNullableRequest> {
  operator size_t() {
    return MinSize<::fidl::InterfaceRequest<::test::nullable::SimpleProtocol>>();
  }
};
template <>
struct Allocate<StructWithNullableRequest> {
  StructWithNullableRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StructWithNullableRequest>());
    StructWithNullableRequest out;
    const size_t slack_per_member = (*size - MinSize<StructWithNullableRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<::fidl::InterfaceRequest<::test::nullable::SimpleProtocol>>() + slack_per_member;
    out.val = Allocate<::fidl::InterfaceRequest<::test::nullable::SimpleProtocol>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<Int32Wrapper> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template <>
struct Allocate<Int32Wrapper> {
  Int32Wrapper operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Int32Wrapper>());
    Int32Wrapper out;
    const size_t slack_per_member = (*size - MinSize<Int32Wrapper>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.val = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<StructWithNullableStruct> {
  operator size_t() {
    return MinSize<::std::unique_ptr<::test::nullable::Int32Wrapper>>();
  }
};
template <>
struct Allocate<StructWithNullableStruct> {
  StructWithNullableStruct operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StructWithNullableStruct>());
    StructWithNullableStruct out;
    const size_t slack_per_member = (*size - MinSize<StructWithNullableStruct>()) / 1;
    size_t out_size;
    out_size = MinSize<::std::unique_ptr<::test::nullable::Int32Wrapper>>() + slack_per_member;
    out.val = Allocate<::std::unique_ptr<::test::nullable::Int32Wrapper>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<SimpleUnion> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>(), MinSize<float>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<SimpleUnion> {
  static_assert(2 > 0, "xunion must have at least one member");

  SimpleUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<SimpleUnion>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    SimpleUnion out;
    switch (selector % 2) {
      case 0: {
        out.set_a(Allocate<int32_t>{}(src, size));
        break;
      }
      case 1: {
        out.set_b(Allocate<float>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<StructWithNullableUnion> {
  operator size_t() {
    return MinSize<::std::unique_ptr<::test::nullable::SimpleUnion>>();
  }
};
template <>
struct Allocate<StructWithNullableUnion> {
  StructWithNullableUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StructWithNullableUnion>());
    StructWithNullableUnion out;
    const size_t slack_per_member = (*size - MinSize<StructWithNullableUnion>()) / 1;
    size_t out_size;
    out_size = MinSize<::std::unique_ptr<::test::nullable::SimpleUnion>>() + slack_per_member;
    out.val = Allocate<::std::unique_ptr<::test::nullable::SimpleUnion>>{}(src, &out_size);
    return out;
  }
};

}  // namespace fuzzing
