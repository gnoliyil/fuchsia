// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = zx_select_case_sensitivity

#pragma once

#include <test/encapsulatedstructs/cpp/fidl.h>

#include "lib/fidl/cpp/fuzzing/traits.h"
#include "lib/fidl/cpp/internal/header.h"
// For ::std::max_element().
#include <algorithm>
// For uint64_t.
#include <stdint.h>

namespace fuzzing {

using Int8Int32 = ::test::encapsulatedstructs::Int8Int32;
using Int16Int8 = ::test::encapsulatedstructs::Int16Int8;
using ArrayInt16Int8 = ::test::encapsulatedstructs::ArrayInt16Int8;
using StructPaddingTestStruct = ::test::encapsulatedstructs::StructPaddingTestStruct;
using NonInlineStructTestStruct = ::test::encapsulatedstructs::NonInlineStructTestStruct;
using TopLevelStruct = ::test::encapsulatedstructs::TopLevelStruct;

template <>
struct MinSize<Int8Int32> {
  operator size_t() {
    return MinSize<int8_t>() + MinSize<int32_t>();
  }
};
template <>
struct Allocate<Int8Int32> {
  Int8Int32 operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Int8Int32>());
    Int8Int32 out;
    const size_t slack_per_member = (*size - MinSize<Int8Int32>()) / 2;
    size_t out_size;
    out_size = MinSize<int8_t>() + slack_per_member;
    out.a = Allocate<int8_t>{}(src, &out_size);
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<Int16Int8> {
  operator size_t() {
    return MinSize<int16_t>() + MinSize<int8_t>();
  }
};
template <>
struct Allocate<Int16Int8> {
  Int16Int8 operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Int16Int8>());
    Int16Int8 out;
    const size_t slack_per_member = (*size - MinSize<Int16Int8>()) / 2;
    size_t out_size;
    out_size = MinSize<int16_t>() + slack_per_member;
    out.a = Allocate<int16_t>{}(src, &out_size);
    out_size = MinSize<int8_t>() + slack_per_member;
    out.b = Allocate<int8_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ArrayInt16Int8> {
  operator size_t() {
    return MinSize<::std::array<::test::encapsulatedstructs::Int16Int8, 3>>();
  }
};
template <>
struct Allocate<ArrayInt16Int8> {
  ArrayInt16Int8 operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ArrayInt16Int8>());
    ArrayInt16Int8 out;
    const size_t slack_per_member = (*size - MinSize<ArrayInt16Int8>()) / 1;
    size_t out_size;
    out_size = MinSize<::std::array<::test::encapsulatedstructs::Int16Int8, 3>>() + slack_per_member;
    out.arr = Allocate<::std::array<::test::encapsulatedstructs::Int16Int8, 3>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<StructPaddingTestStruct> {
  operator size_t() {
    return MinSize<::test::encapsulatedstructs::Int16Int8>() + MinSize<::test::encapsulatedstructs::Int8Int32>() + MinSize<::test::encapsulatedstructs::ArrayInt16Int8>();
  }
};
template <>
struct Allocate<StructPaddingTestStruct> {
  StructPaddingTestStruct operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<StructPaddingTestStruct>());
    StructPaddingTestStruct out;
    const size_t slack_per_member = (*size - MinSize<StructPaddingTestStruct>()) / 3;
    size_t out_size;
    out_size = MinSize<::test::encapsulatedstructs::Int16Int8>() + slack_per_member;
    out.trailing = Allocate<::test::encapsulatedstructs::Int16Int8>{}(src, &out_size);
    out_size = MinSize<::test::encapsulatedstructs::Int8Int32>() + slack_per_member;
    out.inner = Allocate<::test::encapsulatedstructs::Int8Int32>{}(src, &out_size);
    out_size = MinSize<::test::encapsulatedstructs::ArrayInt16Int8>() + slack_per_member;
    out.array = Allocate<::test::encapsulatedstructs::ArrayInt16Int8>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<NonInlineStructTestStruct> {
  operator size_t() {
    return MinSize<::std::unique_ptr<::test::encapsulatedstructs::Int16Int8>>() + MinSize<::zx::handle>();
  }
};
template <>
struct Allocate<NonInlineStructTestStruct> {
  NonInlineStructTestStruct operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<NonInlineStructTestStruct>());
    NonInlineStructTestStruct out;
    const size_t slack_per_member = (*size - MinSize<NonInlineStructTestStruct>()) / 2;
    size_t out_size;
    out_size = MinSize<::std::unique_ptr<::test::encapsulatedstructs::Int16Int8>>() + slack_per_member;
    out.element = Allocate<::std::unique_ptr<::test::encapsulatedstructs::Int16Int8>>{}(src, &out_size);
    out_size = MinSize<::zx::handle>() + slack_per_member;
    out.h = Allocate<::zx::handle>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<TopLevelStruct> {
  operator size_t() {
    return MinSize<::test::encapsulatedstructs::StructPaddingTestStruct>() + MinSize<::test::encapsulatedstructs::NonInlineStructTestStruct>();
  }
};
template <>
struct Allocate<TopLevelStruct> {
  TopLevelStruct operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<TopLevelStruct>());
    TopLevelStruct out;
    const size_t slack_per_member = (*size - MinSize<TopLevelStruct>()) / 2;
    size_t out_size;
    out_size = MinSize<::test::encapsulatedstructs::StructPaddingTestStruct>() + slack_per_member;
    out.a = Allocate<::test::encapsulatedstructs::StructPaddingTestStruct>{}(src, &out_size);
    out_size = MinSize<::test::encapsulatedstructs::NonInlineStructTestStruct>() + slack_per_member;
    out.b = Allocate<::test::encapsulatedstructs::NonInlineStructTestStruct>{}(src, &out_size);
    return out;
  }
};

}  // namespace fuzzing
