// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

#include <lib/async-loop/cpp/loop.h>
#include <lib/async-loop/default.h>
#include <lib/fidl/cpp/fuzzing/fuzzer.h>
#include <lib/fidl/cpp/interface_ptr.h>
#include <lib/zx/channel.h>
#include <test/protocollayoutssamelibrary/cpp/libfuzzer.h>
#include <zircon/errors.h>
#include <zircon/syscalls.h>
#include <zircon/types.h>

using namespace ::fuzzing;
using namespace ::test::protocollayoutssamelibrary;

// Add //build/fuzzing:fuzzing_verbose_logging to a GN target's configs to enable.
#if FUZZING_VERBOSE_LOGGING
#include <stdio.h>
#define xprintf(fmt...) printf(fmt)
#else
#define xprintf(fmt...) \
  do {                  \
  } while (0)
#endif

extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data_, size_t size_) {
  static ::async::Loop* loop_ = nullptr;

  if (loop_ == nullptr) {
    xprintf("Starting client async loop\n");
    loop_ = new ::async::Loop(&kAsyncLoopConfigAttachToCurrentThread);
  }

  // Must fuzz some protocol; first two bytes used to select protocol and method.
  if (size_ < 2) {
    xprintf("Early exit: Input too small: %zu\n", size_);
    return 0;
  }
  size_ -= 2;

  uint8_t protocol_selector_ = data_[0];
  uint8_t protocol_selection_ = protocol_selector_ % 2;

  xprintf("Starting fuzzer with %zu bytes of data\n", size_);

  // Hardcode mutually-exclusive if blocks that selects exactly one protocol.
  [[maybe_unused]] zx_status_t status_;
  if (protocol_selection_ == 0) {
#if !(defined(GOLDEN_FUZZER) || defined(PROTOCOL_test_protocollayoutssamelibrary_ComposedProtocol))
    // Selected protocol from FIDL file that is not part of this fuzzer.
    xprintf("Early exit: Chose disabled protocol: test_protocollayoutssamelibrary_ComposedProtocol\n");
    return 0;
#else

    ::fidl::InterfacePtr< ::test::protocollayoutssamelibrary::ComposedProtocol> protocol_;

    xprintf("Starting test_protocollayoutssamelibrary_ComposedProtocol service\n");
    ::fidl::fuzzing::Fuzzer< ::test::protocollayoutssamelibrary::ComposedProtocol> fuzzer_(loop_->dispatcher());
    if ((status_ = fuzzer_.Init()) != ZX_OK) {
      xprintf("Early exit: fuzzer.Init returned bad status: %d\n", status_);
      return 0;
    }

    if ((status_ = fuzzer_.BindService()) != ZX_OK) {
      xprintf("Early exit: fuzzer.BindService returned bad status: %d\n", status_);
      return 0;
    }

    if ((status_ = fuzzer_.BindClient(&protocol_, loop_->dispatcher())) != ZX_OK) {
      xprintf("Early exit: fuzzer.BindClient returned bad status: %d\n", status_);
      return 0;
    }

    FuzzInput src_(data_, size_);

    uint8_t method_selector_ = data_[1];
    uint8_t method_selection_ = method_selector_ % 6;
    if (method_selection_ == 0) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayAnonComposed))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayAnonComposed\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest ComposedProtocolOneWayAnonComposedRequest\n", param_size_);
      ::test::protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest ComposedProtocolOneWayAnonComposedRequest = Allocate< ::test::protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_ComposedProtocol.OneWayAnonComposed\n");
      protocol_->OneWayAnonComposed(std::move(ComposedProtocolOneWayAnonComposedRequest));
#endif
    }
    if (method_selection_ == 1) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayAnonComposed))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayAnonComposed\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest ComposedProtocolTwoWayAnonComposedRequest\n", param_size_);
      ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest ComposedProtocolTwoWayAnonComposedRequest = Allocate< ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_ComposedProtocol.TwoWayAnonComposed\n");
      protocol_->TwoWayAnonComposed(std::move(ComposedProtocolTwoWayAnonComposedRequest), [signaller = fuzzer_.NewCallbackSignaller()](::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedResponse ComposedProtocolTwoWayAnonComposedResponse) {
        xprintf("Invoked test_protocollayoutssamelibrary_ComposedProtocol.TwoWayAnonComposed\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 2) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayAnonComposedWithError))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayAnonComposedWithError\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest ComposedProtocolTwoWayAnonComposedWithErrorRequest\n", param_size_);
      ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest ComposedProtocolTwoWayAnonComposedWithErrorRequest = Allocate< ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_ComposedProtocol.TwoWayAnonComposedWithError\n");
      protocol_->TwoWayAnonComposedWithError(std::move(ComposedProtocolTwoWayAnonComposedWithErrorRequest), [signaller = fuzzer_.NewCallbackSignaller()](::test::protocollayoutssamelibrary::ComposedProtocol_TwoWayAnonComposedWithError_Result ComposedProtocol_TwoWayAnonComposedWithError_Result) {
        xprintf("Invoked test_protocollayoutssamelibrary_ComposedProtocol.TwoWayAnonComposedWithError\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 3) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayNamedComposed))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayNamedComposed\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::TablePayload>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::TablePayload>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::TablePayload TablePayload\n", param_size_);
      ::test::protocollayoutssamelibrary::TablePayload TablePayload = Allocate< ::test::protocollayoutssamelibrary::TablePayload>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_ComposedProtocol.OneWayNamedComposed\n");
      protocol_->OneWayNamedComposed(std::move(TablePayload));
#endif
    }
    if (method_selection_ == 4) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayNamedComposed))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayNamedComposed\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::UnionPayload>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::UnionPayload>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::UnionPayload UnionPayload\n", param_size_);
      ::test::protocollayoutssamelibrary::UnionPayload UnionPayload = Allocate< ::test::protocollayoutssamelibrary::UnionPayload>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_ComposedProtocol.TwoWayNamedComposed\n");
      protocol_->TwoWayNamedComposed(std::move(UnionPayload), [signaller = fuzzer_.NewCallbackSignaller()](::test::protocollayoutssamelibrary::TablePayload TablePayload) {
        xprintf("Invoked test_protocollayoutssamelibrary_ComposedProtocol.TwoWayNamedComposed\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 5) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayNamedComposedWithError))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayNamedComposedWithError\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::TablePayload>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::TablePayload>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::TablePayload TablePayload\n", param_size_);
      ::test::protocollayoutssamelibrary::TablePayload TablePayload = Allocate< ::test::protocollayoutssamelibrary::TablePayload>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_ComposedProtocol.TwoWayNamedComposedWithError\n");
      protocol_->TwoWayNamedComposedWithError(std::move(TablePayload), [signaller = fuzzer_.NewCallbackSignaller()](::test::protocollayoutssamelibrary::ComposedProtocol_TwoWayNamedComposedWithError_Result ComposedProtocol_TwoWayNamedComposedWithError_Result) {
        xprintf("Invoked test_protocollayoutssamelibrary_ComposedProtocol.TwoWayNamedComposedWithError\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }

    loop_->RunUntilIdle();

    if ((status_ = fuzzer_.WaitForCallback()) != ZX_OK) {
      xprintf("fuzzer.WaitForCallback returned bad status: %d\n", status_);
    }

    protocol_.Unbind();
#endif
  }
  if (protocol_selection_ == 1) {
#if !(defined(GOLDEN_FUZZER) || defined(PROTOCOL_test_protocollayoutssamelibrary_MainProtocol))
    // Selected protocol from FIDL file that is not part of this fuzzer.
    xprintf("Early exit: Chose disabled protocol: test_protocollayoutssamelibrary_MainProtocol\n");
    return 0;
#else

    ::fidl::InterfacePtr< ::test::protocollayoutssamelibrary::MainProtocol> protocol_;

    xprintf("Starting test_protocollayoutssamelibrary_MainProtocol service\n");
    ::fidl::fuzzing::Fuzzer< ::test::protocollayoutssamelibrary::MainProtocol> fuzzer_(loop_->dispatcher());
    if ((status_ = fuzzer_.Init()) != ZX_OK) {
      xprintf("Early exit: fuzzer.Init returned bad status: %d\n", status_);
      return 0;
    }

    if ((status_ = fuzzer_.BindService()) != ZX_OK) {
      xprintf("Early exit: fuzzer.BindService returned bad status: %d\n", status_);
      return 0;
    }

    if ((status_ = fuzzer_.BindClient(&protocol_, loop_->dispatcher())) != ZX_OK) {
      xprintf("Early exit: fuzzer.BindClient returned bad status: %d\n", status_);
      return 0;
    }

    FuzzInput src_(data_, size_);

    uint8_t method_selector_ = data_[1];
    uint8_t method_selection_ = method_selector_ % 12;
    if (method_selection_ == 0) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayAnonComposed))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayAnonComposed\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest ComposedProtocolOneWayAnonComposedRequest\n", param_size_);
      ::test::protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest ComposedProtocolOneWayAnonComposedRequest = Allocate< ::test::protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_MainProtocol.OneWayAnonComposed\n");
      protocol_->OneWayAnonComposed(std::move(ComposedProtocolOneWayAnonComposedRequest));
#endif
    }
    if (method_selection_ == 1) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayAnonComposed))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayAnonComposed\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest ComposedProtocolTwoWayAnonComposedRequest\n", param_size_);
      ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest ComposedProtocolTwoWayAnonComposedRequest = Allocate< ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_MainProtocol.TwoWayAnonComposed\n");
      protocol_->TwoWayAnonComposed(std::move(ComposedProtocolTwoWayAnonComposedRequest), [signaller = fuzzer_.NewCallbackSignaller()](::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedResponse ComposedProtocolTwoWayAnonComposedResponse) {
        xprintf("Invoked test_protocollayoutssamelibrary_MainProtocol.TwoWayAnonComposed\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 2) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayAnonComposedWithError))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayAnonComposedWithError\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest ComposedProtocolTwoWayAnonComposedWithErrorRequest\n", param_size_);
      ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest ComposedProtocolTwoWayAnonComposedWithErrorRequest = Allocate< ::test::protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_MainProtocol.TwoWayAnonComposedWithError\n");
      protocol_->TwoWayAnonComposedWithError(std::move(ComposedProtocolTwoWayAnonComposedWithErrorRequest), [signaller = fuzzer_.NewCallbackSignaller()](::test::protocollayoutssamelibrary::ComposedProtocol_TwoWayAnonComposedWithError_Result ComposedProtocol_TwoWayAnonComposedWithError_Result) {
        xprintf("Invoked test_protocollayoutssamelibrary_MainProtocol.TwoWayAnonComposedWithError\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 3) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayNamedComposed))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayNamedComposed\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::TablePayload>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::TablePayload>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::TablePayload TablePayload\n", param_size_);
      ::test::protocollayoutssamelibrary::TablePayload TablePayload = Allocate< ::test::protocollayoutssamelibrary::TablePayload>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_MainProtocol.OneWayNamedComposed\n");
      protocol_->OneWayNamedComposed(std::move(TablePayload));
#endif
    }
    if (method_selection_ == 4) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayNamedComposed))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayNamedComposed\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::UnionPayload>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::UnionPayload>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::UnionPayload UnionPayload\n", param_size_);
      ::test::protocollayoutssamelibrary::UnionPayload UnionPayload = Allocate< ::test::protocollayoutssamelibrary::UnionPayload>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_MainProtocol.TwoWayNamedComposed\n");
      protocol_->TwoWayNamedComposed(std::move(UnionPayload), [signaller = fuzzer_.NewCallbackSignaller()](::test::protocollayoutssamelibrary::TablePayload TablePayload) {
        xprintf("Invoked test_protocollayoutssamelibrary_MainProtocol.TwoWayNamedComposed\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 5) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayNamedComposedWithError))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayNamedComposedWithError\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::TablePayload>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::TablePayload>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::TablePayload TablePayload\n", param_size_);
      ::test::protocollayoutssamelibrary::TablePayload TablePayload = Allocate< ::test::protocollayoutssamelibrary::TablePayload>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_MainProtocol.TwoWayNamedComposedWithError\n");
      protocol_->TwoWayNamedComposedWithError(std::move(TablePayload), [signaller = fuzzer_.NewCallbackSignaller()](::test::protocollayoutssamelibrary::ComposedProtocol_TwoWayNamedComposedWithError_Result ComposedProtocol_TwoWayNamedComposedWithError_Result) {
        xprintf("Invoked test_protocollayoutssamelibrary_MainProtocol.TwoWayNamedComposedWithError\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 6) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayLocal))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayLocal\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::TablePayload>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::TablePayload>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::TablePayload TablePayload\n", param_size_);
      ::test::protocollayoutssamelibrary::TablePayload TablePayload = Allocate< ::test::protocollayoutssamelibrary::TablePayload>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_MainProtocol.OneWayLocal\n");
      protocol_->OneWayLocal(std::move(TablePayload));
#endif
    }
    if (method_selection_ == 7) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayLocal))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayLocal\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::UnionPayload>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::UnionPayload>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::UnionPayload UnionPayload\n", param_size_);
      ::test::protocollayoutssamelibrary::UnionPayload UnionPayload = Allocate< ::test::protocollayoutssamelibrary::UnionPayload>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_MainProtocol.TwoWayLocal\n");
      protocol_->TwoWayLocal(std::move(UnionPayload), [signaller = fuzzer_.NewCallbackSignaller()](::test::protocollayoutssamelibrary::TablePayload TablePayload) {
        xprintf("Invoked test_protocollayoutssamelibrary_MainProtocol.TwoWayLocal\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 8) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayLocalWithError))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayLocalWithError\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::TablePayload>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::TablePayload>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::TablePayload TablePayload\n", param_size_);
      ::test::protocollayoutssamelibrary::TablePayload TablePayload = Allocate< ::test::protocollayoutssamelibrary::TablePayload>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_MainProtocol.TwoWayLocalWithError\n");
      protocol_->TwoWayLocalWithError(std::move(TablePayload), [signaller = fuzzer_.NewCallbackSignaller()](::test::protocollayoutssamelibrary::MainProtocol_TwoWayLocalWithError_Result MainProtocol_TwoWayLocalWithError_Result) {
        xprintf("Invoked test_protocollayoutssamelibrary_MainProtocol.TwoWayLocalWithError\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 9) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayAnon))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayAnon\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::MainProtocolOneWayAnonRequest>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::MainProtocolOneWayAnonRequest>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::MainProtocolOneWayAnonRequest MainProtocolOneWayAnonRequest\n", param_size_);
      ::test::protocollayoutssamelibrary::MainProtocolOneWayAnonRequest MainProtocolOneWayAnonRequest = Allocate< ::test::protocollayoutssamelibrary::MainProtocolOneWayAnonRequest>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_MainProtocol.OneWayAnon\n");
      protocol_->OneWayAnon(std::move(MainProtocolOneWayAnonRequest));
#endif
    }
    if (method_selection_ == 10) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayAnon))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayAnon\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest MainProtocolTwoWayAnonRequest\n", param_size_);
      ::test::protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest MainProtocolTwoWayAnonRequest = Allocate< ::test::protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_MainProtocol.TwoWayAnon\n");
      protocol_->TwoWayAnon(std::move(MainProtocolTwoWayAnonRequest), [signaller = fuzzer_.NewCallbackSignaller()](::test::protocollayoutssamelibrary::MainProtocolTwoWayAnonResponse MainProtocolTwoWayAnonResponse) {
        xprintf("Invoked test_protocollayoutssamelibrary_MainProtocol.TwoWayAnon\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 11) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayAnonWithError))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayAnonWithError\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 1;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest MainProtocolTwoWayAnonWithErrorRequest\n", param_size_);
      ::test::protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest MainProtocolTwoWayAnonWithErrorRequest = Allocate< ::test::protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest>{}(&src_, &param_size_);

      xprintf("Invoking method test_protocollayoutssamelibrary_MainProtocol.TwoWayAnonWithError\n");
      protocol_->TwoWayAnonWithError(std::move(MainProtocolTwoWayAnonWithErrorRequest), [signaller = fuzzer_.NewCallbackSignaller()](::test::protocollayoutssamelibrary::MainProtocol_TwoWayAnonWithError_Result MainProtocol_TwoWayAnonWithError_Result) {
        xprintf("Invoked test_protocollayoutssamelibrary_MainProtocol.TwoWayAnonWithError\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }

    loop_->RunUntilIdle();

    if ((status_ = fuzzer_.WaitForCallback()) != ZX_OK) {
      xprintf("fuzzer.WaitForCallback returned bad status: %d\n", status_);
    }

    protocol_.Unbind();
#endif
  }

  xprintf("Fuzzer stopped!\n");

  return 0;
}
