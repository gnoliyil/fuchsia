// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

#include <lib/async-loop/cpp/loop.h>
#include <lib/async-loop/default.h>
#include <lib/fidl/cpp/fuzzing/fuzzer.h>
#include <lib/fidl/cpp/interface_ptr.h>
#include <lib/zx/channel.h>
#include <test/typesinprotocols/cpp/libfuzzer.h>
#include <zircon/errors.h>
#include <zircon/syscalls.h>
#include <zircon/types.h>

using namespace ::fuzzing;
using namespace ::test::typesinprotocols;

// Add //build/fuzzing:fuzzing_verbose_logging to a GN target's configs to enable.
#if FUZZING_VERBOSE_LOGGING
#include <stdio.h>
#define xprintf(fmt...) printf(fmt)
#else
#define xprintf(fmt...) \
  do {                  \
  } while (0)
#endif

extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data_, size_t size_) {
  static ::async::Loop* loop_ = nullptr;

  if (loop_ == nullptr) {
    xprintf("Starting client async loop\n");
    loop_ = new ::async::Loop(&kAsyncLoopConfigAttachToCurrentThread);
  }

  // Must fuzz some protocol; first two bytes used to select protocol and method.
  if (size_ < 2) {
    xprintf("Early exit: Input too small: %zu\n", size_);
    return 0;
  }
  size_ -= 2;

  uint8_t protocol_selector_ = data_[0];
  uint8_t protocol_selection_ = protocol_selector_ % 1;

  xprintf("Starting fuzzer with %zu bytes of data\n", size_);

  // Hardcode mutually-exclusive if blocks that selects exactly one protocol.
  [[maybe_unused]] zx_status_t status_;
  if (protocol_selection_ == 0) {
#if !(defined(GOLDEN_FUZZER) || defined(PROTOCOL_test_typesinprotocols_Protocol))
    // Selected protocol from FIDL file that is not part of this fuzzer.
    xprintf("Early exit: Chose disabled protocol: test_typesinprotocols_Protocol\n");
    return 0;
#else

    ::fidl::InterfacePtr< ::test::typesinprotocols::Protocol> protocol_;

    xprintf("Starting test_typesinprotocols_Protocol service\n");
    ::fidl::fuzzing::Fuzzer< ::test::typesinprotocols::Protocol> fuzzer_(loop_->dispatcher());
    if ((status_ = fuzzer_.Init()) != ZX_OK) {
      xprintf("Early exit: fuzzer.Init returned bad status: %d\n", status_);
      return 0;
    }

    if ((status_ = fuzzer_.BindService()) != ZX_OK) {
      xprintf("Early exit: fuzzer.BindService returned bad status: %d\n", status_);
      return 0;
    }

    if ((status_ = fuzzer_.BindClient(&protocol_, loop_->dispatcher())) != ZX_OK) {
      xprintf("Early exit: fuzzer.BindClient returned bad status: %d\n", status_);
      return 0;
    }

    FuzzInput src_(data_, size_);

    uint8_t method_selector_ = data_[1];
    uint8_t method_selection_ = method_selector_ % 18;
    if (method_selection_ == 0) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayBasic))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayBasic\n");
      return 0;
#else
      const size_t min_size_ = MinSize<uint8_t>() + MinSize<uint16_t>() + MinSize<uint32_t>() + MinSize<uint64_t>() + MinSize<int8_t>() + MinSize<int16_t>() + MinSize<int32_t>() + MinSize<int64_t>() + MinSize<float>() + MinSize<double>() + MinSize< ::std::string>() + MinSize< ::fidl::StringPtr>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 12;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize<uint8_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for uint8_t uint8\n", param_size_);
      uint8_t uint8 = Allocate<uint8_t>{}(&src_, &param_size_);
      param_size_ = MinSize<uint16_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for uint16_t uint16\n", param_size_);
      uint16_t uint16 = Allocate<uint16_t>{}(&src_, &param_size_);
      param_size_ = MinSize<uint32_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for uint32_t uint32\n", param_size_);
      uint32_t uint32 = Allocate<uint32_t>{}(&src_, &param_size_);
      param_size_ = MinSize<uint64_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for uint64_t uint64\n", param_size_);
      uint64_t uint64 = Allocate<uint64_t>{}(&src_, &param_size_);
      param_size_ = MinSize<int8_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for int8_t int8\n", param_size_);
      int8_t int8 = Allocate<int8_t>{}(&src_, &param_size_);
      param_size_ = MinSize<int16_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for int16_t int16\n", param_size_);
      int16_t int16 = Allocate<int16_t>{}(&src_, &param_size_);
      param_size_ = MinSize<int32_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for int32_t int32\n", param_size_);
      int32_t int32 = Allocate<int32_t>{}(&src_, &param_size_);
      param_size_ = MinSize<int64_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for int64_t int64\n", param_size_);
      int64_t int64 = Allocate<int64_t>{}(&src_, &param_size_);
      param_size_ = MinSize<float>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for float float32\n", param_size_);
      float float32 = Allocate<float>{}(&src_, &param_size_);
      param_size_ = MinSize<double>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for double float64\n", param_size_);
      double float64 = Allocate<double>{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::string>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::string string\n", param_size_);
      ::std::string string = Allocate< ::std::string>{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::StringPtr>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::StringPtr opt_string\n", param_size_);
      ::fidl::StringPtr opt_string = Allocate< ::fidl::StringPtr>{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.OneWayBasic\n");
      protocol_->OneWayBasic(std::move(uint8), std::move(uint16), std::move(uint32), std::move(uint64), std::move(int8), std::move(int16), std::move(int32), std::move(int64), std::move(float32), std::move(float64), std::move(string), std::move(opt_string));
#endif
    }
    if (method_selection_ == 1) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayBasic))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayBasic\n");
      return 0;
#else
      const size_t min_size_ = MinSize<uint8_t>() + MinSize<uint16_t>() + MinSize<uint32_t>() + MinSize<uint64_t>() + MinSize<int8_t>() + MinSize<int16_t>() + MinSize<int32_t>() + MinSize<int64_t>() + MinSize<float>() + MinSize<double>() + MinSize< ::std::string>() + MinSize< ::fidl::StringPtr>();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 12;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize<uint8_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for uint8_t uint8\n", param_size_);
      uint8_t uint8 = Allocate<uint8_t>{}(&src_, &param_size_);
      param_size_ = MinSize<uint16_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for uint16_t uint16\n", param_size_);
      uint16_t uint16 = Allocate<uint16_t>{}(&src_, &param_size_);
      param_size_ = MinSize<uint32_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for uint32_t uint32\n", param_size_);
      uint32_t uint32 = Allocate<uint32_t>{}(&src_, &param_size_);
      param_size_ = MinSize<uint64_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for uint64_t uint64\n", param_size_);
      uint64_t uint64 = Allocate<uint64_t>{}(&src_, &param_size_);
      param_size_ = MinSize<int8_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for int8_t int8\n", param_size_);
      int8_t int8 = Allocate<int8_t>{}(&src_, &param_size_);
      param_size_ = MinSize<int16_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for int16_t int16\n", param_size_);
      int16_t int16 = Allocate<int16_t>{}(&src_, &param_size_);
      param_size_ = MinSize<int32_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for int32_t int32\n", param_size_);
      int32_t int32 = Allocate<int32_t>{}(&src_, &param_size_);
      param_size_ = MinSize<int64_t>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for int64_t int64\n", param_size_);
      int64_t int64 = Allocate<int64_t>{}(&src_, &param_size_);
      param_size_ = MinSize<float>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for float float32\n", param_size_);
      float float32 = Allocate<float>{}(&src_, &param_size_);
      param_size_ = MinSize<double>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for double float64\n", param_size_);
      double float64 = Allocate<double>{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::string>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::string string\n", param_size_);
      ::std::string string = Allocate< ::std::string>{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::StringPtr>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::StringPtr opt_string\n", param_size_);
      ::fidl::StringPtr opt_string = Allocate< ::fidl::StringPtr>{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.TwoWayBasic\n");
      protocol_->TwoWayBasic(std::move(uint8), std::move(uint16), std::move(uint32), std::move(uint64), std::move(int8), std::move(int16), std::move(int32), std::move(int64), std::move(float32), std::move(float64), std::move(string), std::move(opt_string), [signaller = fuzzer_.NewCallbackSignaller()](uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) {
        xprintf("Invoked test_typesinprotocols_Protocol.TwoWayBasic\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 2) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayCompound))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayCompound\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::typesinprotocols::Bits>() + MinSize< ::test::typesinprotocols::Enum>() + MinSize< ::test::typesinprotocols::Struct>() + MinSize< ::test::typesinprotocols::Table>() + MinSize< ::test::typesinprotocols::Union>() + MinSize< ::std::unique_ptr< ::test::typesinprotocols::Struct> >() + MinSize< ::std::unique_ptr< ::test::typesinprotocols::Union> >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 7;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::typesinprotocols::Bits>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::Bits bits\n", param_size_);
      ::test::typesinprotocols::Bits bits = Allocate< ::test::typesinprotocols::Bits>{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::Enum>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::Enum enum_\n", param_size_);
      ::test::typesinprotocols::Enum enum_ = Allocate< ::test::typesinprotocols::Enum>{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::Struct>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::Struct struct_\n", param_size_);
      ::test::typesinprotocols::Struct struct_ = Allocate< ::test::typesinprotocols::Struct>{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::Table>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::Table table\n", param_size_);
      ::test::typesinprotocols::Table table = Allocate< ::test::typesinprotocols::Table>{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::Union>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::Union union_\n", param_size_);
      ::test::typesinprotocols::Union union_ = Allocate< ::test::typesinprotocols::Union>{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::unique_ptr< ::test::typesinprotocols::Struct> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct\n", param_size_);
      ::std::unique_ptr< ::test::typesinprotocols::Struct> opt_struct = Allocate< ::std::unique_ptr< ::test::typesinprotocols::Struct> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::unique_ptr< ::test::typesinprotocols::Union> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::unique_ptr<::test::typesinprotocols::Union> opt_union\n", param_size_);
      ::std::unique_ptr< ::test::typesinprotocols::Union> opt_union = Allocate< ::std::unique_ptr< ::test::typesinprotocols::Union> >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.OneWayCompound\n");
      protocol_->OneWayCompound(std::move(bits), std::move(enum_), std::move(struct_), std::move(table), std::move(union_), std::move(opt_struct), std::move(opt_union));
#endif
    }
    if (method_selection_ == 3) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayCompound))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayCompound\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::test::typesinprotocols::Bits>() + MinSize< ::test::typesinprotocols::Enum>() + MinSize< ::test::typesinprotocols::Struct>() + MinSize< ::test::typesinprotocols::Table>() + MinSize< ::test::typesinprotocols::Union>() + MinSize< ::std::unique_ptr< ::test::typesinprotocols::Struct> >() + MinSize< ::std::unique_ptr< ::test::typesinprotocols::Union> >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 7;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::test::typesinprotocols::Bits>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::Bits bits\n", param_size_);
      ::test::typesinprotocols::Bits bits = Allocate< ::test::typesinprotocols::Bits>{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::Enum>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::Enum enum_\n", param_size_);
      ::test::typesinprotocols::Enum enum_ = Allocate< ::test::typesinprotocols::Enum>{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::Struct>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::Struct struct_\n", param_size_);
      ::test::typesinprotocols::Struct struct_ = Allocate< ::test::typesinprotocols::Struct>{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::Table>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::Table table\n", param_size_);
      ::test::typesinprotocols::Table table = Allocate< ::test::typesinprotocols::Table>{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::Union>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::Union union_\n", param_size_);
      ::test::typesinprotocols::Union union_ = Allocate< ::test::typesinprotocols::Union>{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::unique_ptr< ::test::typesinprotocols::Struct> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct\n", param_size_);
      ::std::unique_ptr< ::test::typesinprotocols::Struct> opt_struct = Allocate< ::std::unique_ptr< ::test::typesinprotocols::Struct> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::unique_ptr< ::test::typesinprotocols::Union> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::unique_ptr<::test::typesinprotocols::Union> opt_union\n", param_size_);
      ::std::unique_ptr< ::test::typesinprotocols::Union> opt_union = Allocate< ::std::unique_ptr< ::test::typesinprotocols::Union> >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.TwoWayCompound\n");
      protocol_->TwoWayCompound(std::move(bits), std::move(enum_), std::move(struct_), std::move(table), std::move(union_), std::move(opt_struct), std::move(opt_union), [signaller = fuzzer_.NewCallbackSignaller()](::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr< ::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr< ::test::typesinprotocols::Union> opt_union) {
        xprintf("Invoked test_typesinprotocols_Protocol.TwoWayCompound\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 4) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayArrayBasic))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayArrayBasic\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::std::array<uint8_t, 5> >() + MinSize< ::std::array<uint16_t, 5> >() + MinSize< ::std::array<uint32_t, 5> >() + MinSize< ::std::array<uint64_t, 5> >() + MinSize< ::std::array<int8_t, 5> >() + MinSize< ::std::array<int16_t, 5> >() + MinSize< ::std::array<int32_t, 5> >() + MinSize< ::std::array<int64_t, 5> >() + MinSize< ::std::array<float, 5> >() + MinSize< ::std::array<double, 5> >() + MinSize< ::std::array< ::std::string, 5> >() + MinSize< ::std::array< ::fidl::StringPtr, 5> >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 12;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::std::array<uint8_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<uint8_t, 5> array_uint8\n", param_size_);
      ::std::array<uint8_t, 5> array_uint8 = Allocate< ::std::array<uint8_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<uint16_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<uint16_t, 5> array_uint16\n", param_size_);
      ::std::array<uint16_t, 5> array_uint16 = Allocate< ::std::array<uint16_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<uint32_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<uint32_t, 5> array_uint32\n", param_size_);
      ::std::array<uint32_t, 5> array_uint32 = Allocate< ::std::array<uint32_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<uint64_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<uint64_t, 5> array_uint64\n", param_size_);
      ::std::array<uint64_t, 5> array_uint64 = Allocate< ::std::array<uint64_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<int8_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<int8_t, 5> array_int8\n", param_size_);
      ::std::array<int8_t, 5> array_int8 = Allocate< ::std::array<int8_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<int16_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<int16_t, 5> array_int16\n", param_size_);
      ::std::array<int16_t, 5> array_int16 = Allocate< ::std::array<int16_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<int32_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<int32_t, 5> array_int32\n", param_size_);
      ::std::array<int32_t, 5> array_int32 = Allocate< ::std::array<int32_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<int64_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<int64_t, 5> array_int64\n", param_size_);
      ::std::array<int64_t, 5> array_int64 = Allocate< ::std::array<int64_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<float, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<float, 5> array_float32\n", param_size_);
      ::std::array<float, 5> array_float32 = Allocate< ::std::array<float, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<double, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<double, 5> array_float64\n", param_size_);
      ::std::array<double, 5> array_float64 = Allocate< ::std::array<double, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::std::string, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::std::string, 5> array_string\n", param_size_);
      ::std::array< ::std::string, 5> array_string = Allocate< ::std::array< ::std::string, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::fidl::StringPtr, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::fidl::StringPtr, 5> array_opt_string\n", param_size_);
      ::std::array< ::fidl::StringPtr, 5> array_opt_string = Allocate< ::std::array< ::fidl::StringPtr, 5> >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.OneWayArrayBasic\n");
      protocol_->OneWayArrayBasic(std::move(array_uint8), std::move(array_uint16), std::move(array_uint32), std::move(array_uint64), std::move(array_int8), std::move(array_int16), std::move(array_int32), std::move(array_int64), std::move(array_float32), std::move(array_float64), std::move(array_string), std::move(array_opt_string));
#endif
    }
    if (method_selection_ == 5) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayArrayBasic))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayArrayBasic\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::std::array<uint8_t, 5> >() + MinSize< ::std::array<uint16_t, 5> >() + MinSize< ::std::array<uint32_t, 5> >() + MinSize< ::std::array<uint64_t, 5> >() + MinSize< ::std::array<int8_t, 5> >() + MinSize< ::std::array<int16_t, 5> >() + MinSize< ::std::array<int32_t, 5> >() + MinSize< ::std::array<int64_t, 5> >() + MinSize< ::std::array<float, 5> >() + MinSize< ::std::array<double, 5> >() + MinSize< ::std::array< ::std::string, 5> >() + MinSize< ::std::array< ::fidl::StringPtr, 5> >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 12;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::std::array<uint8_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<uint8_t, 5> array_uint8\n", param_size_);
      ::std::array<uint8_t, 5> array_uint8 = Allocate< ::std::array<uint8_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<uint16_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<uint16_t, 5> array_uint16\n", param_size_);
      ::std::array<uint16_t, 5> array_uint16 = Allocate< ::std::array<uint16_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<uint32_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<uint32_t, 5> array_uint32\n", param_size_);
      ::std::array<uint32_t, 5> array_uint32 = Allocate< ::std::array<uint32_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<uint64_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<uint64_t, 5> array_uint64\n", param_size_);
      ::std::array<uint64_t, 5> array_uint64 = Allocate< ::std::array<uint64_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<int8_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<int8_t, 5> array_int8\n", param_size_);
      ::std::array<int8_t, 5> array_int8 = Allocate< ::std::array<int8_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<int16_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<int16_t, 5> array_int16\n", param_size_);
      ::std::array<int16_t, 5> array_int16 = Allocate< ::std::array<int16_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<int32_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<int32_t, 5> array_int32\n", param_size_);
      ::std::array<int32_t, 5> array_int32 = Allocate< ::std::array<int32_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<int64_t, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<int64_t, 5> array_int64\n", param_size_);
      ::std::array<int64_t, 5> array_int64 = Allocate< ::std::array<int64_t, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<float, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<float, 5> array_float32\n", param_size_);
      ::std::array<float, 5> array_float32 = Allocate< ::std::array<float, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array<double, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<double, 5> array_float64\n", param_size_);
      ::std::array<double, 5> array_float64 = Allocate< ::std::array<double, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::std::string, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::std::string, 5> array_string\n", param_size_);
      ::std::array< ::std::string, 5> array_string = Allocate< ::std::array< ::std::string, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::fidl::StringPtr, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::fidl::StringPtr, 5> array_opt_string\n", param_size_);
      ::std::array< ::fidl::StringPtr, 5> array_opt_string = Allocate< ::std::array< ::fidl::StringPtr, 5> >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.TwoWayArrayBasic\n");
      protocol_->TwoWayArrayBasic(std::move(array_uint8), std::move(array_uint16), std::move(array_uint32), std::move(array_uint64), std::move(array_int8), std::move(array_int16), std::move(array_int32), std::move(array_int64), std::move(array_float32), std::move(array_float64), std::move(array_string), std::move(array_opt_string), [signaller = fuzzer_.NewCallbackSignaller()](::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array< ::std::string, 5> array_string, ::std::array< ::fidl::StringPtr, 5> array_opt_string) {
        xprintf("Invoked test_typesinprotocols_Protocol.TwoWayArrayBasic\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 6) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayArrayCompound))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayArrayCompound\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::std::array< ::test::typesinprotocols::Bits, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::Enum, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::Struct, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::Table, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::Union, 5> >() + MinSize< ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Struct>, 5> >() + MinSize< ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Union>, 5> >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 7;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::Bits, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::Bits, 5> array_bits\n", param_size_);
      ::std::array< ::test::typesinprotocols::Bits, 5> array_bits = Allocate< ::std::array< ::test::typesinprotocols::Bits, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::Enum, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::Enum, 5> array_enum\n", param_size_);
      ::std::array< ::test::typesinprotocols::Enum, 5> array_enum = Allocate< ::std::array< ::test::typesinprotocols::Enum, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::Struct, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::Struct, 5> array_struct\n", param_size_);
      ::std::array< ::test::typesinprotocols::Struct, 5> array_struct = Allocate< ::std::array< ::test::typesinprotocols::Struct, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::Table, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::Table, 5> array_table\n", param_size_);
      ::std::array< ::test::typesinprotocols::Table, 5> array_table = Allocate< ::std::array< ::test::typesinprotocols::Table, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::Union, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::Union, 5> array_union\n", param_size_);
      ::std::array< ::test::typesinprotocols::Union, 5> array_union = Allocate< ::std::array< ::test::typesinprotocols::Union, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Struct>, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct\n", param_size_);
      ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Struct>, 5> array_opt_struct = Allocate< ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Struct>, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Union>, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union\n", param_size_);
      ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Union>, 5> array_opt_union = Allocate< ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Union>, 5> >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.OneWayArrayCompound\n");
      protocol_->OneWayArrayCompound(std::move(array_bits), std::move(array_enum), std::move(array_struct), std::move(array_table), std::move(array_union), std::move(array_opt_struct), std::move(array_opt_union));
#endif
    }
    if (method_selection_ == 7) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayArrayCompound))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayArrayCompound\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::std::array< ::test::typesinprotocols::Bits, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::Enum, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::Struct, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::Table, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::Union, 5> >() + MinSize< ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Struct>, 5> >() + MinSize< ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Union>, 5> >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 7;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::Bits, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::Bits, 5> array_bits\n", param_size_);
      ::std::array< ::test::typesinprotocols::Bits, 5> array_bits = Allocate< ::std::array< ::test::typesinprotocols::Bits, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::Enum, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::Enum, 5> array_enum\n", param_size_);
      ::std::array< ::test::typesinprotocols::Enum, 5> array_enum = Allocate< ::std::array< ::test::typesinprotocols::Enum, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::Struct, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::Struct, 5> array_struct\n", param_size_);
      ::std::array< ::test::typesinprotocols::Struct, 5> array_struct = Allocate< ::std::array< ::test::typesinprotocols::Struct, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::Table, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::Table, 5> array_table\n", param_size_);
      ::std::array< ::test::typesinprotocols::Table, 5> array_table = Allocate< ::std::array< ::test::typesinprotocols::Table, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::Union, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::Union, 5> array_union\n", param_size_);
      ::std::array< ::test::typesinprotocols::Union, 5> array_union = Allocate< ::std::array< ::test::typesinprotocols::Union, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Struct>, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct\n", param_size_);
      ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Struct>, 5> array_opt_struct = Allocate< ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Struct>, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Union>, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union\n", param_size_);
      ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Union>, 5> array_opt_union = Allocate< ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Union>, 5> >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.TwoWayArrayCompound\n");
      protocol_->TwoWayArrayCompound(std::move(array_bits), std::move(array_enum), std::move(array_struct), std::move(array_table), std::move(array_union), std::move(array_opt_struct), std::move(array_opt_union), [signaller = fuzzer_.NewCallbackSignaller()](::std::array< ::test::typesinprotocols::Bits, 5> array_bits, ::std::array< ::test::typesinprotocols::Enum, 5> array_enum, ::std::array< ::test::typesinprotocols::Struct, 5> array_struct, ::std::array< ::test::typesinprotocols::Table, 5> array_table, ::std::array< ::test::typesinprotocols::Union, 5> array_union, ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array< ::std::unique_ptr< ::test::typesinprotocols::Union>, 5> array_opt_union) {
        xprintf("Invoked test_typesinprotocols_Protocol.TwoWayArrayCompound\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 8) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayVectorBasic))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayVectorBasic\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::std::vector<uint8_t> >() + MinSize< ::std::vector<uint16_t> >() + MinSize< ::std::vector<uint32_t> >() + MinSize< ::std::vector<uint64_t> >() + MinSize< ::std::vector<int8_t> >() + MinSize< ::std::vector<int16_t> >() + MinSize< ::std::vector<int32_t> >() + MinSize< ::std::vector<int64_t> >() + MinSize< ::std::vector<float> >() + MinSize< ::std::vector<double> >() + MinSize< ::std::vector< ::std::string> >() + MinSize< ::std::vector< ::fidl::StringPtr> >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 12;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::std::vector<uint8_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<uint8_t> vector_uint8\n", param_size_);
      ::std::vector<uint8_t> vector_uint8 = Allocate< ::std::vector<uint8_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<uint16_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<uint16_t> vector_uint16\n", param_size_);
      ::std::vector<uint16_t> vector_uint16 = Allocate< ::std::vector<uint16_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<uint32_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<uint32_t> vector_uint32\n", param_size_);
      ::std::vector<uint32_t> vector_uint32 = Allocate< ::std::vector<uint32_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<uint64_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<uint64_t> vector_uint64\n", param_size_);
      ::std::vector<uint64_t> vector_uint64 = Allocate< ::std::vector<uint64_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<int8_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<int8_t> vector_int8\n", param_size_);
      ::std::vector<int8_t> vector_int8 = Allocate< ::std::vector<int8_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<int16_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<int16_t> vector_int16\n", param_size_);
      ::std::vector<int16_t> vector_int16 = Allocate< ::std::vector<int16_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<int32_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<int32_t> vector_int32\n", param_size_);
      ::std::vector<int32_t> vector_int32 = Allocate< ::std::vector<int32_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<int64_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<int64_t> vector_int64\n", param_size_);
      ::std::vector<int64_t> vector_int64 = Allocate< ::std::vector<int64_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<float> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<float> vector_float32\n", param_size_);
      ::std::vector<float> vector_float32 = Allocate< ::std::vector<float> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<double> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<double> vector_float64\n", param_size_);
      ::std::vector<double> vector_float64 = Allocate< ::std::vector<double> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::std::string> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::std::string> vector_string\n", param_size_);
      ::std::vector< ::std::string> vector_string = Allocate< ::std::vector< ::std::string> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::fidl::StringPtr> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::fidl::StringPtr> vector_opt_string\n", param_size_);
      ::std::vector< ::fidl::StringPtr> vector_opt_string = Allocate< ::std::vector< ::fidl::StringPtr> >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.OneWayVectorBasic\n");
      protocol_->OneWayVectorBasic(std::move(vector_uint8), std::move(vector_uint16), std::move(vector_uint32), std::move(vector_uint64), std::move(vector_int8), std::move(vector_int16), std::move(vector_int32), std::move(vector_int64), std::move(vector_float32), std::move(vector_float64), std::move(vector_string), std::move(vector_opt_string));
#endif
    }
    if (method_selection_ == 9) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayVectorBasic))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayVectorBasic\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::std::vector<uint8_t> >() + MinSize< ::std::vector<uint16_t> >() + MinSize< ::std::vector<uint32_t> >() + MinSize< ::std::vector<uint64_t> >() + MinSize< ::std::vector<int8_t> >() + MinSize< ::std::vector<int16_t> >() + MinSize< ::std::vector<int32_t> >() + MinSize< ::std::vector<int64_t> >() + MinSize< ::std::vector<float> >() + MinSize< ::std::vector<double> >() + MinSize< ::std::vector< ::std::string> >() + MinSize< ::std::vector< ::fidl::StringPtr> >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 12;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::std::vector<uint8_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<uint8_t> vector_uint8\n", param_size_);
      ::std::vector<uint8_t> vector_uint8 = Allocate< ::std::vector<uint8_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<uint16_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<uint16_t> vector_uint16\n", param_size_);
      ::std::vector<uint16_t> vector_uint16 = Allocate< ::std::vector<uint16_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<uint32_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<uint32_t> vector_uint32\n", param_size_);
      ::std::vector<uint32_t> vector_uint32 = Allocate< ::std::vector<uint32_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<uint64_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<uint64_t> vector_uint64\n", param_size_);
      ::std::vector<uint64_t> vector_uint64 = Allocate< ::std::vector<uint64_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<int8_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<int8_t> vector_int8\n", param_size_);
      ::std::vector<int8_t> vector_int8 = Allocate< ::std::vector<int8_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<int16_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<int16_t> vector_int16\n", param_size_);
      ::std::vector<int16_t> vector_int16 = Allocate< ::std::vector<int16_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<int32_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<int32_t> vector_int32\n", param_size_);
      ::std::vector<int32_t> vector_int32 = Allocate< ::std::vector<int32_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<int64_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<int64_t> vector_int64\n", param_size_);
      ::std::vector<int64_t> vector_int64 = Allocate< ::std::vector<int64_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<float> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<float> vector_float32\n", param_size_);
      ::std::vector<float> vector_float32 = Allocate< ::std::vector<float> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector<double> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<double> vector_float64\n", param_size_);
      ::std::vector<double> vector_float64 = Allocate< ::std::vector<double> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::std::string> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::std::string> vector_string\n", param_size_);
      ::std::vector< ::std::string> vector_string = Allocate< ::std::vector< ::std::string> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::fidl::StringPtr> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::fidl::StringPtr> vector_opt_string\n", param_size_);
      ::std::vector< ::fidl::StringPtr> vector_opt_string = Allocate< ::std::vector< ::fidl::StringPtr> >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.TwoWayVectorBasic\n");
      protocol_->TwoWayVectorBasic(std::move(vector_uint8), std::move(vector_uint16), std::move(vector_uint32), std::move(vector_uint64), std::move(vector_int8), std::move(vector_int16), std::move(vector_int32), std::move(vector_int64), std::move(vector_float32), std::move(vector_float64), std::move(vector_string), std::move(vector_opt_string), [signaller = fuzzer_.NewCallbackSignaller()](::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector< ::std::string> vector_string, ::std::vector< ::fidl::StringPtr> vector_opt_string) {
        xprintf("Invoked test_typesinprotocols_Protocol.TwoWayVectorBasic\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 10) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayVectorCompound))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayVectorCompound\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::std::vector< ::test::typesinprotocols::Bits> >() + MinSize< ::std::vector< ::test::typesinprotocols::Enum> >() + MinSize< ::std::vector< ::test::typesinprotocols::Struct> >() + MinSize< ::std::vector< ::test::typesinprotocols::Table> >() + MinSize< ::std::vector< ::test::typesinprotocols::Union> >() + MinSize< ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Struct> > >() + MinSize< ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Union> > >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 7;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::Bits> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::Bits> vector_bits\n", param_size_);
      ::std::vector< ::test::typesinprotocols::Bits> vector_bits = Allocate< ::std::vector< ::test::typesinprotocols::Bits> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::Enum> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::Enum> vector_enum\n", param_size_);
      ::std::vector< ::test::typesinprotocols::Enum> vector_enum = Allocate< ::std::vector< ::test::typesinprotocols::Enum> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::Struct> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::Struct> vector_struct\n", param_size_);
      ::std::vector< ::test::typesinprotocols::Struct> vector_struct = Allocate< ::std::vector< ::test::typesinprotocols::Struct> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::Table> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::Table> vector_table\n", param_size_);
      ::std::vector< ::test::typesinprotocols::Table> vector_table = Allocate< ::std::vector< ::test::typesinprotocols::Table> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::Union> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::Union> vector_union\n", param_size_);
      ::std::vector< ::test::typesinprotocols::Union> vector_union = Allocate< ::std::vector< ::test::typesinprotocols::Union> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Struct> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct\n", param_size_);
      ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Struct> > vector_opt_struct = Allocate< ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Struct> > >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Union> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union\n", param_size_);
      ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Union> > vector_opt_union = Allocate< ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Union> > >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.OneWayVectorCompound\n");
      protocol_->OneWayVectorCompound(std::move(vector_bits), std::move(vector_enum), std::move(vector_struct), std::move(vector_table), std::move(vector_union), std::move(vector_opt_struct), std::move(vector_opt_union));
#endif
    }
    if (method_selection_ == 11) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayVectorCompound))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayVectorCompound\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::std::vector< ::test::typesinprotocols::Bits> >() + MinSize< ::std::vector< ::test::typesinprotocols::Enum> >() + MinSize< ::std::vector< ::test::typesinprotocols::Struct> >() + MinSize< ::std::vector< ::test::typesinprotocols::Table> >() + MinSize< ::std::vector< ::test::typesinprotocols::Union> >() + MinSize< ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Struct> > >() + MinSize< ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Union> > >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 7;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::Bits> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::Bits> vector_bits\n", param_size_);
      ::std::vector< ::test::typesinprotocols::Bits> vector_bits = Allocate< ::std::vector< ::test::typesinprotocols::Bits> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::Enum> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::Enum> vector_enum\n", param_size_);
      ::std::vector< ::test::typesinprotocols::Enum> vector_enum = Allocate< ::std::vector< ::test::typesinprotocols::Enum> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::Struct> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::Struct> vector_struct\n", param_size_);
      ::std::vector< ::test::typesinprotocols::Struct> vector_struct = Allocate< ::std::vector< ::test::typesinprotocols::Struct> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::Table> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::Table> vector_table\n", param_size_);
      ::std::vector< ::test::typesinprotocols::Table> vector_table = Allocate< ::std::vector< ::test::typesinprotocols::Table> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::Union> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::Union> vector_union\n", param_size_);
      ::std::vector< ::test::typesinprotocols::Union> vector_union = Allocate< ::std::vector< ::test::typesinprotocols::Union> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Struct> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct\n", param_size_);
      ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Struct> > vector_opt_struct = Allocate< ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Struct> > >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Union> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union\n", param_size_);
      ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Union> > vector_opt_union = Allocate< ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Union> > >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.TwoWayVectorCompound\n");
      protocol_->TwoWayVectorCompound(std::move(vector_bits), std::move(vector_enum), std::move(vector_struct), std::move(vector_table), std::move(vector_union), std::move(vector_opt_struct), std::move(vector_opt_union), [signaller = fuzzer_.NewCallbackSignaller()](::std::vector< ::test::typesinprotocols::Bits> vector_bits, ::std::vector< ::test::typesinprotocols::Enum> vector_enum, ::std::vector< ::test::typesinprotocols::Struct> vector_struct, ::std::vector< ::test::typesinprotocols::Table> vector_table, ::std::vector< ::test::typesinprotocols::Union> vector_union, ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Struct> > vector_opt_struct, ::std::vector< ::std::unique_ptr< ::test::typesinprotocols::Union> > vector_opt_union) {
        xprintf("Invoked test_typesinprotocols_Protocol.TwoWayVectorCompound\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 12) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayVectorOptional))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayVectorOptional\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::fidl::VectorPtr<uint8_t> >() + MinSize< ::fidl::VectorPtr< ::std::string> >() + MinSize< ::fidl::VectorPtr< ::std::unique_ptr< ::test::typesinprotocols::Struct> > >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 3;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::fidl::VectorPtr<uint8_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::VectorPtr<uint8_t> opt_vector_uint8\n", param_size_);
      ::fidl::VectorPtr<uint8_t> opt_vector_uint8 = Allocate< ::fidl::VectorPtr<uint8_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::VectorPtr< ::std::string> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::VectorPtr<::std::string> opt_vector_string\n", param_size_);
      ::fidl::VectorPtr< ::std::string> opt_vector_string = Allocate< ::fidl::VectorPtr< ::std::string> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::VectorPtr< ::std::unique_ptr< ::test::typesinprotocols::Struct> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct\n", param_size_);
      ::fidl::VectorPtr< ::std::unique_ptr< ::test::typesinprotocols::Struct> > opt_vector_opt_struct = Allocate< ::fidl::VectorPtr< ::std::unique_ptr< ::test::typesinprotocols::Struct> > >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.OneWayVectorOptional\n");
      protocol_->OneWayVectorOptional(std::move(opt_vector_uint8), std::move(opt_vector_string), std::move(opt_vector_opt_struct));
#endif
    }
    if (method_selection_ == 13) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayVectorOptional))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayVectorOptional\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::fidl::VectorPtr<uint8_t> >() + MinSize< ::fidl::VectorPtr< ::std::string> >() + MinSize< ::fidl::VectorPtr< ::std::unique_ptr< ::test::typesinprotocols::Struct> > >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 3;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::fidl::VectorPtr<uint8_t> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::VectorPtr<uint8_t> opt_vector_uint8\n", param_size_);
      ::fidl::VectorPtr<uint8_t> opt_vector_uint8 = Allocate< ::fidl::VectorPtr<uint8_t> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::VectorPtr< ::std::string> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::VectorPtr<::std::string> opt_vector_string\n", param_size_);
      ::fidl::VectorPtr< ::std::string> opt_vector_string = Allocate< ::fidl::VectorPtr< ::std::string> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::VectorPtr< ::std::unique_ptr< ::test::typesinprotocols::Struct> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct\n", param_size_);
      ::fidl::VectorPtr< ::std::unique_ptr< ::test::typesinprotocols::Struct> > opt_vector_opt_struct = Allocate< ::fidl::VectorPtr< ::std::unique_ptr< ::test::typesinprotocols::Struct> > >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.TwoWayVectorOptional\n");
      protocol_->TwoWayVectorOptional(std::move(opt_vector_uint8), std::move(opt_vector_string), std::move(opt_vector_opt_struct), [signaller = fuzzer_.NewCallbackSignaller()](::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr< ::std::string> opt_vector_string, ::fidl::VectorPtr< ::std::unique_ptr< ::test::typesinprotocols::Struct> > opt_vector_opt_struct) {
        xprintf("Invoked test_typesinprotocols_Protocol.TwoWayVectorOptional\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 14) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayArrayVectorNested))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayArrayVectorNested\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::std::array< ::std::array<uint8_t, 5>, 5> >() + MinSize< ::std::array< ::std::vector<uint8_t>, 5> >() + MinSize< ::std::vector< ::std::array<uint8_t, 5> > >() + MinSize< ::std::vector< ::std::vector<uint8_t> > >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 4;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::std::array< ::std::array<uint8_t, 5>, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8\n", param_size_);
      ::std::array< ::std::array<uint8_t, 5>, 5> array_array_uint8 = Allocate< ::std::array< ::std::array<uint8_t, 5>, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::std::vector<uint8_t>, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8\n", param_size_);
      ::std::array< ::std::vector<uint8_t>, 5> array_vector_uint8 = Allocate< ::std::array< ::std::vector<uint8_t>, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::std::array<uint8_t, 5> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8\n", param_size_);
      ::std::vector< ::std::array<uint8_t, 5> > vector_array_uint8 = Allocate< ::std::vector< ::std::array<uint8_t, 5> > >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::std::vector<uint8_t> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::std::vector<uint8_t>> vector_vector_uint8\n", param_size_);
      ::std::vector< ::std::vector<uint8_t> > vector_vector_uint8 = Allocate< ::std::vector< ::std::vector<uint8_t> > >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.OneWayArrayVectorNested\n");
      protocol_->OneWayArrayVectorNested(std::move(array_array_uint8), std::move(array_vector_uint8), std::move(vector_array_uint8), std::move(vector_vector_uint8));
#endif
    }
    if (method_selection_ == 15) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayArrayVectorNested))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayArrayVectorNested\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::std::array< ::std::array<uint8_t, 5>, 5> >() + MinSize< ::std::array< ::std::vector<uint8_t>, 5> >() + MinSize< ::std::vector< ::std::array<uint8_t, 5> > >() + MinSize< ::std::vector< ::std::vector<uint8_t> > >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 4;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::std::array< ::std::array<uint8_t, 5>, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8\n", param_size_);
      ::std::array< ::std::array<uint8_t, 5>, 5> array_array_uint8 = Allocate< ::std::array< ::std::array<uint8_t, 5>, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::std::vector<uint8_t>, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8\n", param_size_);
      ::std::array< ::std::vector<uint8_t>, 5> array_vector_uint8 = Allocate< ::std::array< ::std::vector<uint8_t>, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::std::array<uint8_t, 5> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8\n", param_size_);
      ::std::vector< ::std::array<uint8_t, 5> > vector_array_uint8 = Allocate< ::std::vector< ::std::array<uint8_t, 5> > >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::std::vector<uint8_t> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::std::vector<uint8_t>> vector_vector_uint8\n", param_size_);
      ::std::vector< ::std::vector<uint8_t> > vector_vector_uint8 = Allocate< ::std::vector< ::std::vector<uint8_t> > >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.TwoWayArrayVectorNested\n");
      protocol_->TwoWayArrayVectorNested(std::move(array_array_uint8), std::move(array_vector_uint8), std::move(vector_array_uint8), std::move(vector_vector_uint8), [signaller = fuzzer_.NewCallbackSignaller()](::std::array< ::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array< ::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector< ::std::array<uint8_t, 5> > vector_array_uint8, ::std::vector< ::std::vector<uint8_t> > vector_vector_uint8) {
        xprintf("Invoked test_typesinprotocols_Protocol.TwoWayArrayVectorNested\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }
    if (method_selection_ == 16) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_OneWayResource))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: OneWayResource\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::zx::handle>() + MinSize< ::zx::vmo>() + MinSize< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> >() + MinSize< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> >() + MinSize< ::test::typesinprotocols::ResourceStruct>() + MinSize< ::test::typesinprotocols::ResourceTable>() + MinSize< ::test::typesinprotocols::ResourceUnion>() + MinSize< ::zx::handle>() + MinSize< ::zx::vmo>() + MinSize< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> >() + MinSize< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> >() + MinSize< ::std::unique_ptr< ::test::typesinprotocols::ResourceStruct> >() + MinSize< ::std::unique_ptr< ::test::typesinprotocols::ResourceUnion> >() + MinSize< ::std::array< ::zx::handle, 5> >() + MinSize< ::std::array< ::zx::vmo, 5> >() + MinSize< ::std::array< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol>, 5> >() + MinSize< ::std::array< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol>, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::ResourceStruct, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::ResourceTable, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::ResourceUnion, 5> >() + MinSize< ::std::vector< ::zx::handle> >() + MinSize< ::std::vector< ::zx::vmo> >() + MinSize< ::std::vector< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> > >() + MinSize< ::std::vector< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> > >() + MinSize< ::std::vector< ::test::typesinprotocols::ResourceStruct> >() + MinSize< ::std::vector< ::test::typesinprotocols::ResourceTable> >() + MinSize< ::std::vector< ::test::typesinprotocols::ResourceUnion> >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 27;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::zx::handle>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::zx::handle handle\n", param_size_);
      ::zx::handle handle = Allocate< ::zx::handle>{}(&src_, &param_size_);
      param_size_ = MinSize< ::zx::vmo>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::zx::vmo vmo\n", param_size_);
      ::zx::vmo vmo = Allocate< ::zx::vmo>{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end\n", param_size_);
      ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> client_end = Allocate< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end\n", param_size_);
      ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> server_end = Allocate< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::ResourceStruct>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::ResourceStruct struct_\n", param_size_);
      ::test::typesinprotocols::ResourceStruct struct_ = Allocate< ::test::typesinprotocols::ResourceStruct>{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::ResourceTable>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::ResourceTable table\n", param_size_);
      ::test::typesinprotocols::ResourceTable table = Allocate< ::test::typesinprotocols::ResourceTable>{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::ResourceUnion>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::ResourceUnion union_\n", param_size_);
      ::test::typesinprotocols::ResourceUnion union_ = Allocate< ::test::typesinprotocols::ResourceUnion>{}(&src_, &param_size_);
      param_size_ = MinSize< ::zx::handle>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::zx::handle opt_handle\n", param_size_);
      ::zx::handle opt_handle = Allocate< ::zx::handle>{}(&src_, &param_size_);
      param_size_ = MinSize< ::zx::vmo>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::zx::vmo opt_vmo\n", param_size_);
      ::zx::vmo opt_vmo = Allocate< ::zx::vmo>{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end\n", param_size_);
      ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> opt_client_end = Allocate< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end\n", param_size_);
      ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> opt_server_end = Allocate< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::unique_ptr< ::test::typesinprotocols::ResourceStruct> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct\n", param_size_);
      ::std::unique_ptr< ::test::typesinprotocols::ResourceStruct> opt_struct = Allocate< ::std::unique_ptr< ::test::typesinprotocols::ResourceStruct> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::unique_ptr< ::test::typesinprotocols::ResourceUnion> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union\n", param_size_);
      ::std::unique_ptr< ::test::typesinprotocols::ResourceUnion> opt_union = Allocate< ::std::unique_ptr< ::test::typesinprotocols::ResourceUnion> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::zx::handle, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::zx::handle, 5> array_handle\n", param_size_);
      ::std::array< ::zx::handle, 5> array_handle = Allocate< ::std::array< ::zx::handle, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::zx::vmo, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::zx::vmo, 5> array_vmo\n", param_size_);
      ::std::array< ::zx::vmo, 5> array_vmo = Allocate< ::std::array< ::zx::vmo, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol>, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end\n", param_size_);
      ::std::array< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol>, 5> array_client_end = Allocate< ::std::array< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol>, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol>, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end\n", param_size_);
      ::std::array< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol>, 5> array_server_end = Allocate< ::std::array< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol>, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::ResourceStruct, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct\n", param_size_);
      ::std::array< ::test::typesinprotocols::ResourceStruct, 5> array_struct = Allocate< ::std::array< ::test::typesinprotocols::ResourceStruct, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::ResourceTable, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table\n", param_size_);
      ::std::array< ::test::typesinprotocols::ResourceTable, 5> array_table = Allocate< ::std::array< ::test::typesinprotocols::ResourceTable, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::ResourceUnion, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union\n", param_size_);
      ::std::array< ::test::typesinprotocols::ResourceUnion, 5> array_union = Allocate< ::std::array< ::test::typesinprotocols::ResourceUnion, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::zx::handle> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::zx::handle> vector_handle\n", param_size_);
      ::std::vector< ::zx::handle> vector_handle = Allocate< ::std::vector< ::zx::handle> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::zx::vmo> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::zx::vmo> vector_vmo\n", param_size_);
      ::std::vector< ::zx::vmo> vector_vmo = Allocate< ::std::vector< ::zx::vmo> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end\n", param_size_);
      ::std::vector< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> > vector_client_end = Allocate< ::std::vector< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> > >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end\n", param_size_);
      ::std::vector< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> > vector_server_end = Allocate< ::std::vector< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> > >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::ResourceStruct> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct\n", param_size_);
      ::std::vector< ::test::typesinprotocols::ResourceStruct> vector_struct = Allocate< ::std::vector< ::test::typesinprotocols::ResourceStruct> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::ResourceTable> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::ResourceTable> vector_table\n", param_size_);
      ::std::vector< ::test::typesinprotocols::ResourceTable> vector_table = Allocate< ::std::vector< ::test::typesinprotocols::ResourceTable> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::ResourceUnion> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union\n", param_size_);
      ::std::vector< ::test::typesinprotocols::ResourceUnion> vector_union = Allocate< ::std::vector< ::test::typesinprotocols::ResourceUnion> >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.OneWayResource\n");
      protocol_->OneWayResource(std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), std::move(table), std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), std::move(opt_struct), std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), std::move(vector_handle), std::move(vector_vmo), std::move(vector_client_end), std::move(vector_server_end), std::move(vector_struct), std::move(vector_table), std::move(vector_union));
#endif
    }
    if (method_selection_ == 17) {
#if !(defined(GOLDEN_FUZZER) || defined(ALL_METHODS) || defined(METHOD_TwoWayResource))
      // Selected method from protocol that is not part of this fuzzer.
      xprintf("Early exit: Chose disabled method: TwoWayResource\n");
      return 0;
#else
      const size_t min_size_ = MinSize< ::zx::handle>() + MinSize< ::zx::vmo>() + MinSize< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> >() + MinSize< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> >() + MinSize< ::test::typesinprotocols::ResourceStruct>() + MinSize< ::test::typesinprotocols::ResourceTable>() + MinSize< ::test::typesinprotocols::ResourceUnion>() + MinSize< ::zx::handle>() + MinSize< ::zx::vmo>() + MinSize< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> >() + MinSize< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> >() + MinSize< ::std::unique_ptr< ::test::typesinprotocols::ResourceStruct> >() + MinSize< ::std::unique_ptr< ::test::typesinprotocols::ResourceUnion> >() + MinSize< ::std::array< ::zx::handle, 5> >() + MinSize< ::std::array< ::zx::vmo, 5> >() + MinSize< ::std::array< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol>, 5> >() + MinSize< ::std::array< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol>, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::ResourceStruct, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::ResourceTable, 5> >() + MinSize< ::std::array< ::test::typesinprotocols::ResourceUnion, 5> >() + MinSize< ::std::vector< ::zx::handle> >() + MinSize< ::std::vector< ::zx::vmo> >() + MinSize< ::std::vector< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> > >() + MinSize< ::std::vector< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> > >() + MinSize< ::std::vector< ::test::typesinprotocols::ResourceStruct> >() + MinSize< ::std::vector< ::test::typesinprotocols::ResourceTable> >() + MinSize< ::std::vector< ::test::typesinprotocols::ResourceUnion> >();

      // Must have enough bytes for input.
      if (size_ < min_size_) {
        xprintf("Early exit: Input size too small: %zu < %zu\n", size_, min_size_);
        return 0;
      }

      const size_t slack_size_ = size_ - min_size_;
      const size_t slack_size_per_param = slack_size_ / 27;

      xprintf("Allocating parameters with %zu bytes (%zu bytes each)\n", slack_size_, slack_size_per_param);

      size_t param_size_;
      param_size_ = MinSize< ::zx::handle>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::zx::handle handle\n", param_size_);
      ::zx::handle handle = Allocate< ::zx::handle>{}(&src_, &param_size_);
      param_size_ = MinSize< ::zx::vmo>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::zx::vmo vmo\n", param_size_);
      ::zx::vmo vmo = Allocate< ::zx::vmo>{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end\n", param_size_);
      ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> client_end = Allocate< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end\n", param_size_);
      ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> server_end = Allocate< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::ResourceStruct>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::ResourceStruct struct_\n", param_size_);
      ::test::typesinprotocols::ResourceStruct struct_ = Allocate< ::test::typesinprotocols::ResourceStruct>{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::ResourceTable>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::ResourceTable table\n", param_size_);
      ::test::typesinprotocols::ResourceTable table = Allocate< ::test::typesinprotocols::ResourceTable>{}(&src_, &param_size_);
      param_size_ = MinSize< ::test::typesinprotocols::ResourceUnion>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::test::typesinprotocols::ResourceUnion union_\n", param_size_);
      ::test::typesinprotocols::ResourceUnion union_ = Allocate< ::test::typesinprotocols::ResourceUnion>{}(&src_, &param_size_);
      param_size_ = MinSize< ::zx::handle>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::zx::handle opt_handle\n", param_size_);
      ::zx::handle opt_handle = Allocate< ::zx::handle>{}(&src_, &param_size_);
      param_size_ = MinSize< ::zx::vmo>() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::zx::vmo opt_vmo\n", param_size_);
      ::zx::vmo opt_vmo = Allocate< ::zx::vmo>{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end\n", param_size_);
      ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> opt_client_end = Allocate< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end\n", param_size_);
      ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> opt_server_end = Allocate< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::unique_ptr< ::test::typesinprotocols::ResourceStruct> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct\n", param_size_);
      ::std::unique_ptr< ::test::typesinprotocols::ResourceStruct> opt_struct = Allocate< ::std::unique_ptr< ::test::typesinprotocols::ResourceStruct> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::unique_ptr< ::test::typesinprotocols::ResourceUnion> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union\n", param_size_);
      ::std::unique_ptr< ::test::typesinprotocols::ResourceUnion> opt_union = Allocate< ::std::unique_ptr< ::test::typesinprotocols::ResourceUnion> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::zx::handle, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::zx::handle, 5> array_handle\n", param_size_);
      ::std::array< ::zx::handle, 5> array_handle = Allocate< ::std::array< ::zx::handle, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::zx::vmo, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::zx::vmo, 5> array_vmo\n", param_size_);
      ::std::array< ::zx::vmo, 5> array_vmo = Allocate< ::std::array< ::zx::vmo, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol>, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end\n", param_size_);
      ::std::array< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol>, 5> array_client_end = Allocate< ::std::array< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol>, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol>, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end\n", param_size_);
      ::std::array< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol>, 5> array_server_end = Allocate< ::std::array< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol>, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::ResourceStruct, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct\n", param_size_);
      ::std::array< ::test::typesinprotocols::ResourceStruct, 5> array_struct = Allocate< ::std::array< ::test::typesinprotocols::ResourceStruct, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::ResourceTable, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table\n", param_size_);
      ::std::array< ::test::typesinprotocols::ResourceTable, 5> array_table = Allocate< ::std::array< ::test::typesinprotocols::ResourceTable, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::array< ::test::typesinprotocols::ResourceUnion, 5> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union\n", param_size_);
      ::std::array< ::test::typesinprotocols::ResourceUnion, 5> array_union = Allocate< ::std::array< ::test::typesinprotocols::ResourceUnion, 5> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::zx::handle> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::zx::handle> vector_handle\n", param_size_);
      ::std::vector< ::zx::handle> vector_handle = Allocate< ::std::vector< ::zx::handle> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::zx::vmo> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::zx::vmo> vector_vmo\n", param_size_);
      ::std::vector< ::zx::vmo> vector_vmo = Allocate< ::std::vector< ::zx::vmo> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end\n", param_size_);
      ::std::vector< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> > vector_client_end = Allocate< ::std::vector< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> > >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> > >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end\n", param_size_);
      ::std::vector< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> > vector_server_end = Allocate< ::std::vector< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> > >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::ResourceStruct> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct\n", param_size_);
      ::std::vector< ::test::typesinprotocols::ResourceStruct> vector_struct = Allocate< ::std::vector< ::test::typesinprotocols::ResourceStruct> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::ResourceTable> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::ResourceTable> vector_table\n", param_size_);
      ::std::vector< ::test::typesinprotocols::ResourceTable> vector_table = Allocate< ::std::vector< ::test::typesinprotocols::ResourceTable> >{}(&src_, &param_size_);
      param_size_ = MinSize< ::std::vector< ::test::typesinprotocols::ResourceUnion> >() + slack_size_per_param;
      xprintf("Allocating %zu bytes for ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union\n", param_size_);
      ::std::vector< ::test::typesinprotocols::ResourceUnion> vector_union = Allocate< ::std::vector< ::test::typesinprotocols::ResourceUnion> >{}(&src_, &param_size_);

      xprintf("Invoking method test_typesinprotocols_Protocol.TwoWayResource\n");
      protocol_->TwoWayResource(std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), std::move(table), std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), std::move(opt_struct), std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), std::move(vector_handle), std::move(vector_vmo), std::move(vector_client_end), std::move(vector_server_end), std::move(vector_struct), std::move(vector_table), std::move(vector_union), [signaller = fuzzer_.NewCallbackSignaller()](::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr< ::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr< ::test::typesinprotocols::ResourceUnion> opt_union, ::std::array< ::zx::handle, 5> array_handle, ::std::array< ::zx::vmo, 5> array_vmo, ::std::array< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array< ::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array< ::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array< ::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector< ::zx::handle> vector_handle, ::std::vector< ::zx::vmo> vector_vmo, ::std::vector< ::fidl::InterfaceHandle< ::test::typesinprotocols::Protocol> > vector_client_end, ::std::vector< ::fidl::InterfaceRequest< ::test::typesinprotocols::Protocol> > vector_server_end, ::std::vector< ::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector< ::test::typesinprotocols::ResourceTable> vector_table, ::std::vector< ::test::typesinprotocols::ResourceUnion> vector_union) {
        xprintf("Invoked test_typesinprotocols_Protocol.TwoWayResource\n");
        zx_status_t status_ = signaller.SignalCallback();
        if (status_ != ZX_OK) {
          xprintf("signaller.SignalCallback returned bad status: %d\n", status_);
        }
      });
#endif
    }

    loop_->RunUntilIdle();

    if ((status_ = fuzzer_.WaitForCallback()) != ZX_OK) {
      xprintf("fuzzer.WaitForCallback returned bad status: %d\n", status_);
    }

    protocol_.Unbind();
#endif
  }

  xprintf("Fuzzer stopped!\n");

  return 0;
}
