// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = zx_select_case_sensitivity

#pragma once

#include <test/typesinprotocols/cpp/fidl.h>

#include "lib/fidl/cpp/fuzzing/traits.h"
#include "lib/fidl/cpp/internal/header.h"
// For ::std::max_element().
#include <algorithm>
// For uint64_t.
#include <stdint.h>

namespace fuzzing {

using Bits = ::test::typesinprotocols::Bits;
using Enum = ::test::typesinprotocols::Enum;
using Struct = ::test::typesinprotocols::Struct;
using Table = ::test::typesinprotocols::Table;
using Union = ::test::typesinprotocols::Union;
using ResourceStruct = ::test::typesinprotocols::ResourceStruct;
using ResourceTable = ::test::typesinprotocols::ResourceTable;
using ResourceUnion = ::test::typesinprotocols::ResourceUnion;
using Basic = ::test::typesinprotocols::Basic;
using Compound = ::test::typesinprotocols::Compound;
using ArrayBasic = ::test::typesinprotocols::ArrayBasic;
using ArrayCompound = ::test::typesinprotocols::ArrayCompound;
using VectorBasic = ::test::typesinprotocols::VectorBasic;
using VectorCompound = ::test::typesinprotocols::VectorCompound;
using VectorOptional = ::test::typesinprotocols::VectorOptional;
using ArrayVectorNested = ::test::typesinprotocols::ArrayVectorNested;
using Resource = ::test::typesinprotocols::Resource;

template <>
struct MinSize<Bits> {
  operator size_t() { return sizeof(uint32_t); }
};
template <>
struct Allocate<Bits> {
  Bits operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= sizeof(uint32_t));
    return Bits(*reinterpret_cast<const uint32_t*>(src->TakeBytes(sizeof(uint32_t))));
  }
};
template <>
struct MinSize<Enum> {
  operator size_t() { return sizeof(uint64_t); }
};
template <>
struct Allocate<Enum> {
  Enum operator()(FuzzInput* src, size_t* size) {
    Enum out;
    uint64_t selector;
    ZX_ASSERT(*size >= sizeof(uint64_t));
    ZX_ASSERT(src->CopyObject(&selector));
    *size = sizeof(uint64_t);

    switch (selector % 1) {
      case 0:
        out = Enum::VAL;
        break;
    }

    return out;
  }
};
template <>
struct MinSize<Struct> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template <>
struct Allocate<Struct> {
  Struct operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Struct>());
    Struct out;
    const size_t slack_per_member = (*size - MinSize<Struct>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<Table> {
  operator size_t() {
    return 0;
  }
};
template <>
struct Allocate<Table> {
  Table operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Table>());
    Table out;
    return out;
  }
};
template <>
struct MinSize<Union> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<bool>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template <>
struct Allocate<Union> {
  static_assert(1 > 0, "xunion must have at least one member");

  Union operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Union>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    Union out;
    switch (selector % 1) {
      case 0: {
        out.set_b(Allocate<bool>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<ResourceStruct> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template <>
struct Allocate<ResourceStruct> {
  ResourceStruct operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ResourceStruct>());
    ResourceStruct out;
    const size_t slack_per_member = (*size - MinSize<ResourceStruct>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ResourceTable> {
  operator size_t() {
    return 0;
  }
};
template <>
struct Allocate<ResourceTable> {
  ResourceTable operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ResourceTable>());
    ResourceTable out;
    return out;
  }
};
template <>
struct MinSize<ResourceUnion> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<bool>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template <>
struct Allocate<ResourceUnion> {
  static_assert(1 > 0, "xunion must have at least one member");

  ResourceUnion operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ResourceUnion>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    ResourceUnion out;
    switch (selector % 1) {
      case 0: {
        out.set_b(Allocate<bool>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<Basic> {
  operator size_t() {
    return MinSize<uint8_t>() + MinSize<uint16_t>() + MinSize<uint32_t>() + MinSize<uint64_t>() + MinSize<int8_t>() + MinSize<int16_t>() + MinSize<int32_t>() + MinSize<int64_t>() + MinSize<float>() + MinSize<double>() + MinSize<::std::string>() + MinSize<::fidl::StringPtr>();
  }
};
template <>
struct Allocate<Basic> {
  Basic operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Basic>());
    Basic out;
    const size_t slack_per_member = (*size - MinSize<Basic>()) / 12;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.uint8 = Allocate<uint8_t>{}(src, &out_size);
    out_size = MinSize<uint16_t>() + slack_per_member;
    out.uint16 = Allocate<uint16_t>{}(src, &out_size);
    out_size = MinSize<uint32_t>() + slack_per_member;
    out.uint32 = Allocate<uint32_t>{}(src, &out_size);
    out_size = MinSize<uint64_t>() + slack_per_member;
    out.uint64 = Allocate<uint64_t>{}(src, &out_size);
    out_size = MinSize<int8_t>() + slack_per_member;
    out.int8 = Allocate<int8_t>{}(src, &out_size);
    out_size = MinSize<int16_t>() + slack_per_member;
    out.int16 = Allocate<int16_t>{}(src, &out_size);
    out_size = MinSize<int32_t>() + slack_per_member;
    out.int32 = Allocate<int32_t>{}(src, &out_size);
    out_size = MinSize<int64_t>() + slack_per_member;
    out.int64 = Allocate<int64_t>{}(src, &out_size);
    out_size = MinSize<float>() + slack_per_member;
    out.float32 = Allocate<float>{}(src, &out_size);
    out_size = MinSize<double>() + slack_per_member;
    out.float64 = Allocate<double>{}(src, &out_size);
    out_size = MinSize<::std::string>() + slack_per_member;
    out.string = Allocate<::std::string>{}(src, &out_size);
    out_size = MinSize<::fidl::StringPtr>() + slack_per_member;
    out.opt_string = Allocate<::fidl::StringPtr>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<Compound> {
  operator size_t() {
    return MinSize<::test::typesinprotocols::Bits>() + MinSize<::test::typesinprotocols::Enum>() + MinSize<::test::typesinprotocols::Struct>() + MinSize<::test::typesinprotocols::Table>() + MinSize<::test::typesinprotocols::Union>() + MinSize<::std::unique_ptr<::test::typesinprotocols::Struct>>() + MinSize<::std::unique_ptr<::test::typesinprotocols::Union>>();
  }
};
template <>
struct Allocate<Compound> {
  Compound operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Compound>());
    Compound out;
    const size_t slack_per_member = (*size - MinSize<Compound>()) / 7;
    size_t out_size;
    out_size = MinSize<::test::typesinprotocols::Bits>() + slack_per_member;
    out.bits = Allocate<::test::typesinprotocols::Bits>{}(src, &out_size);
    out_size = MinSize<::test::typesinprotocols::Enum>() + slack_per_member;
    out.enum_ = Allocate<::test::typesinprotocols::Enum>{}(src, &out_size);
    out_size = MinSize<::test::typesinprotocols::Struct>() + slack_per_member;
    out.struct_ = Allocate<::test::typesinprotocols::Struct>{}(src, &out_size);
    out_size = MinSize<::test::typesinprotocols::Table>() + slack_per_member;
    out.table = Allocate<::test::typesinprotocols::Table>{}(src, &out_size);
    out_size = MinSize<::test::typesinprotocols::Union>() + slack_per_member;
    out.union_ = Allocate<::test::typesinprotocols::Union>{}(src, &out_size);
    out_size = MinSize<::std::unique_ptr<::test::typesinprotocols::Struct>>() + slack_per_member;
    out.opt_struct = Allocate<::std::unique_ptr<::test::typesinprotocols::Struct>>{}(src, &out_size);
    out_size = MinSize<::std::unique_ptr<::test::typesinprotocols::Union>>() + slack_per_member;
    out.opt_union = Allocate<::std::unique_ptr<::test::typesinprotocols::Union>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ArrayBasic> {
  operator size_t() {
    return MinSize<::std::array<uint8_t, 5>>() + MinSize<::std::array<uint16_t, 5>>() + MinSize<::std::array<uint32_t, 5>>() + MinSize<::std::array<uint64_t, 5>>() + MinSize<::std::array<int8_t, 5>>() + MinSize<::std::array<int16_t, 5>>() + MinSize<::std::array<int32_t, 5>>() + MinSize<::std::array<int64_t, 5>>() + MinSize<::std::array<float, 5>>() + MinSize<::std::array<double, 5>>() + MinSize<::std::array<::std::string, 5>>() + MinSize<::std::array<::fidl::StringPtr, 5>>();
  }
};
template <>
struct Allocate<ArrayBasic> {
  ArrayBasic operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ArrayBasic>());
    ArrayBasic out;
    const size_t slack_per_member = (*size - MinSize<ArrayBasic>()) / 12;
    size_t out_size;
    out_size = MinSize<::std::array<uint8_t, 5>>() + slack_per_member;
    out.array_uint8 = Allocate<::std::array<uint8_t, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<uint16_t, 5>>() + slack_per_member;
    out.array_uint16 = Allocate<::std::array<uint16_t, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<uint32_t, 5>>() + slack_per_member;
    out.array_uint32 = Allocate<::std::array<uint32_t, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<uint64_t, 5>>() + slack_per_member;
    out.array_uint64 = Allocate<::std::array<uint64_t, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<int8_t, 5>>() + slack_per_member;
    out.array_int8 = Allocate<::std::array<int8_t, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<int16_t, 5>>() + slack_per_member;
    out.array_int16 = Allocate<::std::array<int16_t, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<int32_t, 5>>() + slack_per_member;
    out.array_int32 = Allocate<::std::array<int32_t, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<int64_t, 5>>() + slack_per_member;
    out.array_int64 = Allocate<::std::array<int64_t, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<float, 5>>() + slack_per_member;
    out.array_float32 = Allocate<::std::array<float, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<double, 5>>() + slack_per_member;
    out.array_float64 = Allocate<::std::array<double, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::std::string, 5>>() + slack_per_member;
    out.array_string = Allocate<::std::array<::std::string, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::fidl::StringPtr, 5>>() + slack_per_member;
    out.array_opt_string = Allocate<::std::array<::fidl::StringPtr, 5>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ArrayCompound> {
  operator size_t() {
    return MinSize<::std::array<::test::typesinprotocols::Bits, 5>>() + MinSize<::std::array<::test::typesinprotocols::Enum, 5>>() + MinSize<::std::array<::test::typesinprotocols::Struct, 5>>() + MinSize<::std::array<::test::typesinprotocols::Table, 5>>() + MinSize<::std::array<::test::typesinprotocols::Union, 5>>() + MinSize<::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>>() + MinSize<::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>>();
  }
};
template <>
struct Allocate<ArrayCompound> {
  ArrayCompound operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ArrayCompound>());
    ArrayCompound out;
    const size_t slack_per_member = (*size - MinSize<ArrayCompound>()) / 7;
    size_t out_size;
    out_size = MinSize<::std::array<::test::typesinprotocols::Bits, 5>>() + slack_per_member;
    out.array_bits = Allocate<::std::array<::test::typesinprotocols::Bits, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::test::typesinprotocols::Enum, 5>>() + slack_per_member;
    out.array_enum = Allocate<::std::array<::test::typesinprotocols::Enum, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::test::typesinprotocols::Struct, 5>>() + slack_per_member;
    out.array_struct = Allocate<::std::array<::test::typesinprotocols::Struct, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::test::typesinprotocols::Table, 5>>() + slack_per_member;
    out.array_table = Allocate<::std::array<::test::typesinprotocols::Table, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::test::typesinprotocols::Union, 5>>() + slack_per_member;
    out.array_union = Allocate<::std::array<::test::typesinprotocols::Union, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>>() + slack_per_member;
    out.array_opt_struct = Allocate<::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>>() + slack_per_member;
    out.array_opt_union = Allocate<::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<VectorBasic> {
  operator size_t() {
    return MinSize<::std::vector<uint8_t>>() + MinSize<::std::vector<uint16_t>>() + MinSize<::std::vector<uint32_t>>() + MinSize<::std::vector<uint64_t>>() + MinSize<::std::vector<int8_t>>() + MinSize<::std::vector<int16_t>>() + MinSize<::std::vector<int32_t>>() + MinSize<::std::vector<int64_t>>() + MinSize<::std::vector<float>>() + MinSize<::std::vector<double>>() + MinSize<::std::vector<::std::string>>() + MinSize<::std::vector<::fidl::StringPtr>>();
  }
};
template <>
struct Allocate<VectorBasic> {
  VectorBasic operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<VectorBasic>());
    VectorBasic out;
    const size_t slack_per_member = (*size - MinSize<VectorBasic>()) / 12;
    size_t out_size;
    out_size = MinSize<::std::vector<uint8_t>>() + slack_per_member;
    out.vector_uint8 = Allocate<::std::vector<uint8_t>>{}(src, &out_size);
    out_size = MinSize<::std::vector<uint16_t>>() + slack_per_member;
    out.vector_uint16 = Allocate<::std::vector<uint16_t>>{}(src, &out_size);
    out_size = MinSize<::std::vector<uint32_t>>() + slack_per_member;
    out.vector_uint32 = Allocate<::std::vector<uint32_t>>{}(src, &out_size);
    out_size = MinSize<::std::vector<uint64_t>>() + slack_per_member;
    out.vector_uint64 = Allocate<::std::vector<uint64_t>>{}(src, &out_size);
    out_size = MinSize<::std::vector<int8_t>>() + slack_per_member;
    out.vector_int8 = Allocate<::std::vector<int8_t>>{}(src, &out_size);
    out_size = MinSize<::std::vector<int16_t>>() + slack_per_member;
    out.vector_int16 = Allocate<::std::vector<int16_t>>{}(src, &out_size);
    out_size = MinSize<::std::vector<int32_t>>() + slack_per_member;
    out.vector_int32 = Allocate<::std::vector<int32_t>>{}(src, &out_size);
    out_size = MinSize<::std::vector<int64_t>>() + slack_per_member;
    out.vector_int64 = Allocate<::std::vector<int64_t>>{}(src, &out_size);
    out_size = MinSize<::std::vector<float>>() + slack_per_member;
    out.vector_float32 = Allocate<::std::vector<float>>{}(src, &out_size);
    out_size = MinSize<::std::vector<double>>() + slack_per_member;
    out.vector_float64 = Allocate<::std::vector<double>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::std::string>>() + slack_per_member;
    out.vector_string = Allocate<::std::vector<::std::string>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::fidl::StringPtr>>() + slack_per_member;
    out.vector_opt_string = Allocate<::std::vector<::fidl::StringPtr>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<VectorCompound> {
  operator size_t() {
    return MinSize<::std::vector<::test::typesinprotocols::Bits>>() + MinSize<::std::vector<::test::typesinprotocols::Enum>>() + MinSize<::std::vector<::test::typesinprotocols::Struct>>() + MinSize<::std::vector<::test::typesinprotocols::Table>>() + MinSize<::std::vector<::test::typesinprotocols::Union>>() + MinSize<::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>>() + MinSize<::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>>();
  }
};
template <>
struct Allocate<VectorCompound> {
  VectorCompound operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<VectorCompound>());
    VectorCompound out;
    const size_t slack_per_member = (*size - MinSize<VectorCompound>()) / 7;
    size_t out_size;
    out_size = MinSize<::std::vector<::test::typesinprotocols::Bits>>() + slack_per_member;
    out.vector_bits = Allocate<::std::vector<::test::typesinprotocols::Bits>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::test::typesinprotocols::Enum>>() + slack_per_member;
    out.vector_enum = Allocate<::std::vector<::test::typesinprotocols::Enum>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::test::typesinprotocols::Struct>>() + slack_per_member;
    out.vector_struct = Allocate<::std::vector<::test::typesinprotocols::Struct>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::test::typesinprotocols::Table>>() + slack_per_member;
    out.vector_table = Allocate<::std::vector<::test::typesinprotocols::Table>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::test::typesinprotocols::Union>>() + slack_per_member;
    out.vector_union = Allocate<::std::vector<::test::typesinprotocols::Union>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>>() + slack_per_member;
    out.vector_opt_struct = Allocate<::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>>() + slack_per_member;
    out.vector_opt_union = Allocate<::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<VectorOptional> {
  operator size_t() {
    return MinSize<::fidl::VectorPtr<uint8_t>>() + MinSize<::fidl::VectorPtr<::std::string>>() + MinSize<::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>>();
  }
};
template <>
struct Allocate<VectorOptional> {
  VectorOptional operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<VectorOptional>());
    VectorOptional out;
    const size_t slack_per_member = (*size - MinSize<VectorOptional>()) / 3;
    size_t out_size;
    out_size = MinSize<::fidl::VectorPtr<uint8_t>>() + slack_per_member;
    out.opt_vector_uint8 = Allocate<::fidl::VectorPtr<uint8_t>>{}(src, &out_size);
    out_size = MinSize<::fidl::VectorPtr<::std::string>>() + slack_per_member;
    out.opt_vector_string = Allocate<::fidl::VectorPtr<::std::string>>{}(src, &out_size);
    out_size = MinSize<::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>>() + slack_per_member;
    out.opt_vector_opt_struct = Allocate<::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ArrayVectorNested> {
  operator size_t() {
    return MinSize<::std::array<::std::array<uint8_t, 5>, 5>>() + MinSize<::std::array<::std::vector<uint8_t>, 5>>() + MinSize<::std::vector<::std::array<uint8_t, 5>>>() + MinSize<::std::vector<::std::vector<uint8_t>>>();
  }
};
template <>
struct Allocate<ArrayVectorNested> {
  ArrayVectorNested operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ArrayVectorNested>());
    ArrayVectorNested out;
    const size_t slack_per_member = (*size - MinSize<ArrayVectorNested>()) / 4;
    size_t out_size;
    out_size = MinSize<::std::array<::std::array<uint8_t, 5>, 5>>() + slack_per_member;
    out.array_array_uint8 = Allocate<::std::array<::std::array<uint8_t, 5>, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::std::vector<uint8_t>, 5>>() + slack_per_member;
    out.array_vector_uint8 = Allocate<::std::array<::std::vector<uint8_t>, 5>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::std::array<uint8_t, 5>>>() + slack_per_member;
    out.vector_array_uint8 = Allocate<::std::vector<::std::array<uint8_t, 5>>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::std::vector<uint8_t>>>() + slack_per_member;
    out.vector_vector_uint8 = Allocate<::std::vector<::std::vector<uint8_t>>>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<Resource> {
  operator size_t() {
    return MinSize<::zx::handle>() + MinSize<::zx::vmo>() + MinSize<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>() + MinSize<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>() + MinSize<::test::typesinprotocols::ResourceStruct>() + MinSize<::test::typesinprotocols::ResourceTable>() + MinSize<::test::typesinprotocols::ResourceUnion>() + MinSize<::zx::handle>() + MinSize<::zx::vmo>() + MinSize<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>() + MinSize<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>() + MinSize<::std::unique_ptr<::test::typesinprotocols::ResourceStruct>>() + MinSize<::std::unique_ptr<::test::typesinprotocols::ResourceUnion>>() + MinSize<::std::array<::zx::handle, 5>>() + MinSize<::std::array<::zx::vmo, 5>>() + MinSize<::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>>() + MinSize<::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>>() + MinSize<::std::array<::test::typesinprotocols::ResourceStruct, 5>>() + MinSize<::std::array<::test::typesinprotocols::ResourceTable, 5>>() + MinSize<::std::array<::test::typesinprotocols::ResourceUnion, 5>>() + MinSize<::std::vector<::zx::handle>>() + MinSize<::std::vector<::zx::vmo>>() + MinSize<::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>>() + MinSize<::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>>() + MinSize<::std::vector<::test::typesinprotocols::ResourceStruct>>() + MinSize<::std::vector<::test::typesinprotocols::ResourceTable>>() + MinSize<::std::vector<::test::typesinprotocols::ResourceUnion>>();
  }
};
template <>
struct Allocate<Resource> {
  Resource operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Resource>());
    Resource out;
    const size_t slack_per_member = (*size - MinSize<Resource>()) / 27;
    size_t out_size;
    out_size = MinSize<::zx::handle>() + slack_per_member;
    out.handle = Allocate<::zx::handle>{}(src, &out_size);
    out_size = MinSize<::zx::vmo>() + slack_per_member;
    out.vmo = Allocate<::zx::vmo>{}(src, &out_size);
    out_size = MinSize<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>() + slack_per_member;
    out.client_end = Allocate<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>{}(src, &out_size);
    out_size = MinSize<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>() + slack_per_member;
    out.server_end = Allocate<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>{}(src, &out_size);
    out_size = MinSize<::test::typesinprotocols::ResourceStruct>() + slack_per_member;
    out.struct_ = Allocate<::test::typesinprotocols::ResourceStruct>{}(src, &out_size);
    out_size = MinSize<::test::typesinprotocols::ResourceTable>() + slack_per_member;
    out.table = Allocate<::test::typesinprotocols::ResourceTable>{}(src, &out_size);
    out_size = MinSize<::test::typesinprotocols::ResourceUnion>() + slack_per_member;
    out.union_ = Allocate<::test::typesinprotocols::ResourceUnion>{}(src, &out_size);
    out_size = MinSize<::zx::handle>() + slack_per_member;
    out.opt_handle = Allocate<::zx::handle>{}(src, &out_size);
    out_size = MinSize<::zx::vmo>() + slack_per_member;
    out.opt_vmo = Allocate<::zx::vmo>{}(src, &out_size);
    out_size = MinSize<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>() + slack_per_member;
    out.opt_client_end = Allocate<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>{}(src, &out_size);
    out_size = MinSize<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>() + slack_per_member;
    out.opt_server_end = Allocate<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>{}(src, &out_size);
    out_size = MinSize<::std::unique_ptr<::test::typesinprotocols::ResourceStruct>>() + slack_per_member;
    out.opt_struct = Allocate<::std::unique_ptr<::test::typesinprotocols::ResourceStruct>>{}(src, &out_size);
    out_size = MinSize<::std::unique_ptr<::test::typesinprotocols::ResourceUnion>>() + slack_per_member;
    out.opt_union = Allocate<::std::unique_ptr<::test::typesinprotocols::ResourceUnion>>{}(src, &out_size);
    out_size = MinSize<::std::array<::zx::handle, 5>>() + slack_per_member;
    out.array_handle = Allocate<::std::array<::zx::handle, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::zx::vmo, 5>>() + slack_per_member;
    out.array_vmo = Allocate<::std::array<::zx::vmo, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>>() + slack_per_member;
    out.array_client_end = Allocate<::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>>() + slack_per_member;
    out.array_server_end = Allocate<::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::test::typesinprotocols::ResourceStruct, 5>>() + slack_per_member;
    out.array_struct = Allocate<::std::array<::test::typesinprotocols::ResourceStruct, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::test::typesinprotocols::ResourceTable, 5>>() + slack_per_member;
    out.array_table = Allocate<::std::array<::test::typesinprotocols::ResourceTable, 5>>{}(src, &out_size);
    out_size = MinSize<::std::array<::test::typesinprotocols::ResourceUnion, 5>>() + slack_per_member;
    out.array_union = Allocate<::std::array<::test::typesinprotocols::ResourceUnion, 5>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::zx::handle>>() + slack_per_member;
    out.vector_handle = Allocate<::std::vector<::zx::handle>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::zx::vmo>>() + slack_per_member;
    out.vector_vmo = Allocate<::std::vector<::zx::vmo>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>>() + slack_per_member;
    out.vector_client_end = Allocate<::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>>() + slack_per_member;
    out.vector_server_end = Allocate<::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::test::typesinprotocols::ResourceStruct>>() + slack_per_member;
    out.vector_struct = Allocate<::std::vector<::test::typesinprotocols::ResourceStruct>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::test::typesinprotocols::ResourceTable>>() + slack_per_member;
    out.vector_table = Allocate<::std::vector<::test::typesinprotocols::ResourceTable>>{}(src, &out_size);
    out_size = MinSize<::std::vector<::test::typesinprotocols::ResourceUnion>>() + slack_per_member;
    out.vector_union = Allocate<::std::vector<::test::typesinprotocols::ResourceUnion>>{}(src, &out_size);
    return out;
  }
};

}  // namespace fuzzing
