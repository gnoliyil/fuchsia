{{/*
// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
*/}}

{{- define "Filename:NaturalOStreamHeader" -}}
  fidl/{{ .LibraryDots }}/cpp/natural_ostream.h
{{- end }}

{{- define "File:NaturalOStreamHeader" -}}
  {{- UseUnified -}}
  // WARNING: This file is machine generated by fidlgen.
  {{ range $experiment := .Experiments }}
  // fidl_experiment = {{ $experiment }}
  {{- end }}

  #pragma once

  #include <iostream>
  #include <lib/fidl/cpp/natural_ostream.h>

  #include <{{ .Library | Filename "NaturalTypesHeader" }}>

  {{ range .Dependencies -}}
    #include <{{ . | Filename "NaturalOStreamHeader" }}>
  {{ end }}

  {{ EnsureNamespace "" }}
  {{- range .Decls }}
    {{- if and (ne .Kind Kinds.Const) (ne .Kind Kinds.Protocol) (ne .Kind Kinds.Service) }}
      template<>
      struct fidl::ostream::Formatter<{{ . }}> {
        static std::ostream& Format(std::ostream& os, const {{ . }}& value);
      };
    {{- end }}
  {{- end }}

  {{ range .Decls }}
    {{ EnsureNamespace . }}
    {{- if and (ne .Kind Kinds.Const) (ne .Kind Kinds.Protocol) (ne .Kind Kinds.Service) }}
      std::ostream& operator<<(std::ostream& os, const {{ . }}& value);
    {{- end }}
  {{- end }}

  {{ EnsureNamespace "" }}
  {{- range .Protocols }}
    {{- if .Transport }}
      template<>
      struct fidl::ostream::Formatter<{{ .ClientEnd }}> {
        static std::ostream& Format(std::ostream& os, const {{ .ClientEnd }}& value) {
          return os << "ClientEnd<" << "{{ .NoLeading }}" << ">(" << value.channel().get() << ")";
        }
      };

      template<>
      struct fidl::ostream::Formatter<{{ .ServerEnd }}> {
        static std::ostream& Format(std::ostream& os, const {{ .ServerEnd }}& value) {
          return os << "ServerEnd<" << "{{ .NoLeading }}" << ">(" << value.channel().get() << ")";
        }
      };
    {{- end }}
  {{- end }}

  {{ range .Protocols }}
    {{- if .Transport }}
      {{ EnsureNamespace .Transport.Namespace }}

      inline std::ostream& operator<<(std::ostream& os, const {{ .ClientEnd }}& value) {
          return fidl::ostream::Formatter<{{ .ClientEnd }}>::Format(os, value);
      }

      inline std::ostream& operator<<(std::ostream& os, const {{ .ServerEnd }}& value) {
          return fidl::ostream::Formatter<{{ .ServerEnd }}>::Format(os, value);
      }
    {{- end }}
  {{- end }}

  {{ EndOfFile }}
{{- end }}
