// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = zx_select_case_sensitivity

#pragma once

#include <fidl/test.union/cpp/natural_types.h>
#include <lib/fidl/cpp/hlcpp_conversion.h>
#include <lib/fidl/cpp/wire/service_handler.h>
#include <test/union/cpp/fidl.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace fidl {
namespace internal {

template <>
struct NaturalToHLCPPTraits<fidl::ClientEnd<::test_union::TestProtocol>> {
  using HLCPPType = fidl::InterfaceHandle<::test::union_::TestProtocol>;
  static inline fidl::InterfaceHandle<::test::union_::TestProtocol> Convert(fidl::ClientEnd<::test_union::TestProtocol>&& c) {
    return fidl::InterfaceHandle<::test::union_::TestProtocol>(c.TakeChannel());
  }
};

template <>
struct NaturalToHLCPPTraits<fidl::ServerEnd<::test_union::TestProtocol>> {
  using HLCPPType = fidl::InterfaceRequest<::test::union_::TestProtocol>;
  static inline fidl::InterfaceRequest<::test::union_::TestProtocol> Convert(fidl::ServerEnd<::test_union::TestProtocol>&& c) {
    return fidl::InterfaceRequest<::test::union_::TestProtocol>(c.TakeChannel());
  }
};

template <>
struct HLCPPToNaturalTraits<fidl::InterfaceHandle<::test::union_::TestProtocol>> {
  using NaturalType = fidl::ClientEnd<::test_union::TestProtocol>;
  static inline fidl::ClientEnd<::test_union::TestProtocol> Convert(fidl::InterfaceHandle<::test::union_::TestProtocol>&& c) {
    return fidl::ClientEnd<::test_union::TestProtocol>(c.TakeChannel());
  }
};

template <>
struct HLCPPToNaturalTraits<fidl::InterfaceRequest<::test::union_::TestProtocol>> {
  using NaturalType = fidl::ServerEnd<::test_union::TestProtocol>;
  static inline fidl::ServerEnd<::test_union::TestProtocol> Convert(fidl::InterfaceRequest<::test::union_::TestProtocol>&& c) {
    return fidl::ServerEnd<::test_union::TestProtocol>(c.TakeChannel());
  }
};

template <>
struct NaturalToHLCPPTraits<fidl::ProtocolHandler<::test_union::TestProtocol>> {
  using HLCPPType = fidl::InterfaceRequestHandler<::test::union_::TestProtocol>;
  static inline fidl::InterfaceRequestHandler<::test::union_::TestProtocol> Convert(fidl::ProtocolHandler<::test_union::TestProtocol>&& c) {
    return [c = std::move(c)](fidl::InterfaceRequest<::test::union_::TestProtocol> r) {
      c(::fidl::HLCPPToNatural(r));
    };
  }
};

template <>
struct HLCPPToNaturalTraits<fidl::InterfaceRequestHandler<::test::union_::TestProtocol>> {
  using NaturalType = fidl::ProtocolHandler<::test_union::TestProtocol>;
  static inline fidl::ProtocolHandler<::test_union::TestProtocol> Convert(fidl::InterfaceRequestHandler<::test::union_::TestProtocol>&& c) {
    return [c = std::move(c)](fidl::ServerEnd<::test_union::TestProtocol> r) {
      c(::fidl::NaturalToHLCPP(r));
    };
  }
};

template <>
struct NaturalToHLCPPTraits<::test_union::Pizza> {
  using HLCPPType = ::test::union_::Pizza;
  static inline ::test::union_::Pizza Convert(::test_union::Pizza&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::Pizza> {
  using NaturalType = ::test_union::Pizza;
  static inline ::test_union::Pizza Convert(::test::union_::Pizza&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::Pasta> {
  using HLCPPType = ::test::union_::Pasta;
  static inline ::test::union_::Pasta Convert(::test_union::Pasta&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::Pasta> {
  using NaturalType = ::test_union::Pasta;
  static inline ::test_union::Pasta Convert(::test::union_::Pasta&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::NullableUnionStruct> {
  using HLCPPType = ::test::union_::NullableUnionStruct;
  static inline ::test::union_::NullableUnionStruct Convert(::test_union::NullableUnionStruct&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::NullableUnionStruct> {
  using NaturalType = ::test_union::NullableUnionStruct;
  static inline ::test_union::NullableUnionStruct Convert(::test::union_::NullableUnionStruct&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::Empty> {
  using HLCPPType = ::test::union_::Empty;
  static inline ::test::union_::Empty Convert(::test_union::Empty&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::Empty> {
  using NaturalType = ::test_union::Empty;
  static inline ::test_union::Empty Convert(::test::union_::Empty&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse> {
  using HLCPPType = ::test::union_::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse;
  static inline ::test::union_::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse Convert(::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse> {
  using NaturalType = ::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse;
  static inline ::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse Convert(::test::union_::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse> {
  using HLCPPType = ::test::union_::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse;
  static inline ::test::union_::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse Convert(::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse> {
  using NaturalType = ::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse;
  static inline ::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse Convert(::test::union_::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::StructWithNullableUnion> {
  using HLCPPType = ::test::union_::StructWithNullableUnion;
  static inline ::test::union_::StructWithNullableUnion Convert(::test_union::StructWithNullableUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::StructWithNullableUnion> {
  using NaturalType = ::test_union::StructWithNullableUnion;
  static inline ::test_union::StructWithNullableUnion Convert(::test::union_::StructWithNullableUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::UnionSandwich> {
  using HLCPPType = ::test::union_::UnionSandwich;
  static inline ::test::union_::UnionSandwich Convert(::test_union::UnionSandwich&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::UnionSandwich> {
  using NaturalType = ::test_union::UnionSandwich;
  static inline ::test_union::UnionSandwich Convert(::test::union_::UnionSandwich&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::PizzaOrPasta> {
  using HLCPPType = ::test::union_::PizzaOrPasta;
  static inline ::test::union_::PizzaOrPasta Convert(::test_union::PizzaOrPasta&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::PizzaOrPasta> {
  using NaturalType = ::test_union::PizzaOrPasta;
  static inline ::test_union::PizzaOrPasta Convert(::test::union_::PizzaOrPasta&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::ExplicitPizzaOrPasta> {
  using HLCPPType = ::test::union_::ExplicitPizzaOrPasta;
  static inline ::test::union_::ExplicitPizzaOrPasta Convert(::test_union::ExplicitPizzaOrPasta&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::ExplicitPizzaOrPasta> {
  using NaturalType = ::test_union::ExplicitPizzaOrPasta;
  static inline ::test_union::ExplicitPizzaOrPasta Convert(::test::union_::ExplicitPizzaOrPasta&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::FlexiblePizzaOrPasta> {
  using HLCPPType = ::test::union_::FlexiblePizzaOrPasta;
  static inline ::test::union_::FlexiblePizzaOrPasta Convert(::test_union::FlexiblePizzaOrPasta&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::FlexiblePizzaOrPasta> {
  using NaturalType = ::test_union::FlexiblePizzaOrPasta;
  static inline ::test_union::FlexiblePizzaOrPasta Convert(::test::union_::FlexiblePizzaOrPasta&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::StrictPizzaOrPasta> {
  using HLCPPType = ::test::union_::StrictPizzaOrPasta;
  static inline ::test::union_::StrictPizzaOrPasta Convert(::test_union::StrictPizzaOrPasta&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::StrictPizzaOrPasta> {
  using NaturalType = ::test_union::StrictPizzaOrPasta;
  static inline ::test_union::StrictPizzaOrPasta Convert(::test::union_::StrictPizzaOrPasta&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::Union> {
  using HLCPPType = ::test::union_::Union;
  static inline ::test::union_::Union Convert(::test_union::Union&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::Union> {
  using NaturalType = ::test_union::Union;
  static inline ::test_union::Union Convert(::test::union_::Union&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::FlexibleUnion> {
  using HLCPPType = ::test::union_::FlexibleUnion;
  static inline ::test::union_::FlexibleUnion Convert(::test_union::FlexibleUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::FlexibleUnion> {
  using NaturalType = ::test_union::FlexibleUnion;
  static inline ::test_union::FlexibleUnion Convert(::test::union_::FlexibleUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::StrictUnion> {
  using HLCPPType = ::test::union_::StrictUnion;
  static inline ::test::union_::StrictUnion Convert(::test_union::StrictUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::StrictUnion> {
  using NaturalType = ::test_union::StrictUnion;
  static inline ::test_union::StrictUnion Convert(::test::union_::StrictUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::FieldCollision> {
  using HLCPPType = ::test::union_::FieldCollision;
  static inline ::test::union_::FieldCollision Convert(::test_union::FieldCollision&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::FieldCollision> {
  using NaturalType = ::test_union::FieldCollision;
  static inline ::test_union::FieldCollision Convert(::test::union_::FieldCollision&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::ExplicitUnion> {
  using HLCPPType = ::test::union_::ExplicitUnion;
  static inline ::test::union_::ExplicitUnion Convert(::test_union::ExplicitUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::ExplicitUnion> {
  using NaturalType = ::test_union::ExplicitUnion;
  static inline ::test_union::ExplicitUnion Convert(::test::union_::ExplicitUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::ReverseOrdinalUnion> {
  using HLCPPType = ::test::union_::ReverseOrdinalUnion;
  static inline ::test::union_::ReverseOrdinalUnion Convert(::test_union::ReverseOrdinalUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::ReverseOrdinalUnion> {
  using NaturalType = ::test_union::ReverseOrdinalUnion;
  static inline ::test_union::ReverseOrdinalUnion Convert(::test::union_::ReverseOrdinalUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::FlexibleFoo> {
  using HLCPPType = ::test::union_::FlexibleFoo;
  static inline ::test::union_::FlexibleFoo Convert(::test_union::FlexibleFoo&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::FlexibleFoo> {
  using NaturalType = ::test_union::FlexibleFoo;
  static inline ::test_union::FlexibleFoo Convert(::test::union_::FlexibleFoo&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::StrictFoo> {
  using HLCPPType = ::test::union_::StrictFoo;
  static inline ::test::union_::StrictFoo Convert(::test_union::StrictFoo&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::StrictFoo> {
  using NaturalType = ::test_union::StrictFoo;
  static inline ::test_union::StrictFoo Convert(::test::union_::StrictFoo&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::ExplicitFoo> {
  using HLCPPType = ::test::union_::ExplicitFoo;
  static inline ::test::union_::ExplicitFoo Convert(::test_union::ExplicitFoo&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::ExplicitFoo> {
  using NaturalType = ::test_union::ExplicitFoo;
  static inline ::test_union::ExplicitFoo Convert(::test::union_::ExplicitFoo&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::ExplicitStrictFoo> {
  using HLCPPType = ::test::union_::ExplicitStrictFoo;
  static inline ::test::union_::ExplicitStrictFoo Convert(::test_union::ExplicitStrictFoo&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::ExplicitStrictFoo> {
  using NaturalType = ::test_union::ExplicitStrictFoo;
  static inline ::test_union::ExplicitStrictFoo Convert(::test::union_::ExplicitStrictFoo&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::OlderSimpleUnion> {
  using HLCPPType = ::test::union_::OlderSimpleUnion;
  static inline ::test::union_::OlderSimpleUnion Convert(::test_union::OlderSimpleUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::OlderSimpleUnion> {
  using NaturalType = ::test_union::OlderSimpleUnion;
  static inline ::test_union::OlderSimpleUnion Convert(::test::union_::OlderSimpleUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::NewerSimpleUnion> {
  using HLCPPType = ::test::union_::NewerSimpleUnion;
  static inline ::test::union_::NewerSimpleUnion Convert(::test_union::NewerSimpleUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::NewerSimpleUnion> {
  using NaturalType = ::test_union::NewerSimpleUnion;
  static inline ::test_union::NewerSimpleUnion Convert(::test::union_::NewerSimpleUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::StrictSimpleUnion> {
  using HLCPPType = ::test::union_::StrictSimpleUnion;
  static inline ::test::union_::StrictSimpleUnion Convert(::test_union::StrictSimpleUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::StrictSimpleUnion> {
  using NaturalType = ::test_union::StrictSimpleUnion;
  static inline ::test_union::StrictSimpleUnion Convert(::test::union_::StrictSimpleUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::UnionContainingEmptyStruct> {
  using HLCPPType = ::test::union_::UnionContainingEmptyStruct;
  static inline ::test::union_::UnionContainingEmptyStruct Convert(::test_union::UnionContainingEmptyStruct&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::UnionContainingEmptyStruct> {
  using NaturalType = ::test_union::UnionContainingEmptyStruct;
  static inline ::test_union::UnionContainingEmptyStruct Convert(::test::union_::UnionContainingEmptyStruct&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::StrictBoundedUnion> {
  using HLCPPType = ::test::union_::StrictBoundedUnion;
  static inline ::test::union_::StrictBoundedUnion Convert(::test_union::StrictBoundedUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::StrictBoundedUnion> {
  using NaturalType = ::test_union::StrictBoundedUnion;
  static inline ::test_union::StrictBoundedUnion Convert(::test::union_::StrictBoundedUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::ExplicitFlexibleUnion> {
  using HLCPPType = ::test::union_::ExplicitFlexibleUnion;
  static inline ::test::union_::ExplicitFlexibleUnion Convert(::test_union::ExplicitFlexibleUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::ExplicitFlexibleUnion> {
  using NaturalType = ::test_union::ExplicitFlexibleUnion;
  static inline ::test_union::ExplicitFlexibleUnion Convert(::test::union_::ExplicitFlexibleUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::UnionWithAttributes> {
  using HLCPPType = ::test::union_::UnionWithAttributes;
  static inline ::test::union_::UnionWithAttributes Convert(::test_union::UnionWithAttributes&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::UnionWithAttributes> {
  using NaturalType = ::test_union::UnionWithAttributes;
  static inline ::test_union::UnionWithAttributes Convert(::test::union_::UnionWithAttributes&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::EmptyFlexibleUnion> {
  using HLCPPType = ::test::union_::EmptyFlexibleUnion;
  static inline ::test::union_::EmptyFlexibleUnion Convert(::test_union::EmptyFlexibleUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::EmptyFlexibleUnion> {
  using NaturalType = ::test_union::EmptyFlexibleUnion;
  static inline ::test_union::EmptyFlexibleUnion Convert(::test::union_::EmptyFlexibleUnion&&);
};
template <>
struct NaturalToHLCPPTraits<::test_union::OnlyReservedFlexibleUnion> {
  using HLCPPType = ::test::union_::OnlyReservedFlexibleUnion;
  static inline ::test::union_::OnlyReservedFlexibleUnion Convert(::test_union::OnlyReservedFlexibleUnion&&);
};
template <>
struct HLCPPToNaturalTraits<::test::union_::OnlyReservedFlexibleUnion> {
  using NaturalType = ::test_union::OnlyReservedFlexibleUnion;
  static inline ::test_union::OnlyReservedFlexibleUnion Convert(::test::union_::OnlyReservedFlexibleUnion&&);
};

::test::union_::Pizza NaturalToHLCPPTraits<::test_union::Pizza>::Convert(::test_union::Pizza&& value) {
  ::test::union_::Pizza hlcpp;
  hlcpp.toppings = ::fidl::NaturalToHLCPP(std::move(value.toppings()));
  return hlcpp;
}

::test_union::Pizza HLCPPToNaturalTraits<::test::union_::Pizza>::Convert(::test::union_::Pizza&& value) {
  return ::test_union::Pizza{{
      .toppings = ::fidl::HLCPPToNatural(std::move(value.toppings)),
  }};
}
::test::union_::Pasta NaturalToHLCPPTraits<::test_union::Pasta>::Convert(::test_union::Pasta&& value) {
  ::test::union_::Pasta hlcpp;
  hlcpp.sauce = ::fidl::NaturalToHLCPP(std::move(value.sauce()));
  return hlcpp;
}

::test_union::Pasta HLCPPToNaturalTraits<::test::union_::Pasta>::Convert(::test::union_::Pasta&& value) {
  return ::test_union::Pasta{{
      .sauce = ::fidl::HLCPPToNatural(std::move(value.sauce)),
  }};
}
::test::union_::NullableUnionStruct NaturalToHLCPPTraits<::test_union::NullableUnionStruct>::Convert(::test_union::NullableUnionStruct&& value) {
  ::test::union_::NullableUnionStruct hlcpp;
  hlcpp.the_union = ::fidl::NaturalToHLCPP(std::move(value.the_union()));
  return hlcpp;
}

::test_union::NullableUnionStruct HLCPPToNaturalTraits<::test::union_::NullableUnionStruct>::Convert(::test::union_::NullableUnionStruct&& value) {
  return ::test_union::NullableUnionStruct{{
      .the_union = ::fidl::HLCPPToNatural(std::move(value.the_union)),
  }};
}
::test::union_::Empty NaturalToHLCPPTraits<::test_union::Empty>::Convert(::test_union::Empty&& value) {
  ::test::union_::Empty hlcpp;
  hlcpp.__reserved = ::fidl::NaturalToHLCPP(std::move(value.__reserved()));
  return hlcpp;
}

::test_union::Empty HLCPPToNaturalTraits<::test::union_::Empty>::Convert(::test::union_::Empty&& value) {
  return ::test_union::Empty{{
      .__reserved = ::fidl::HLCPPToNatural(std::move(value.__reserved)),
  }};
}
::test::union_::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse NaturalToHLCPPTraits<::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse>::Convert(::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse&& value) {
  ::test::union_::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse hlcpp;
  hlcpp.xu = ::fidl::NaturalToHLCPP(std::move(value.xu()));
  return hlcpp;
}

::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse HLCPPToNaturalTraits<::test::union_::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse>::Convert(::test::union_::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse&& value) {
  return ::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse{{
      .xu = ::fidl::HLCPPToNatural(std::move(value.xu)),
  }};
}
::test::union_::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse NaturalToHLCPPTraits<::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse>::Convert(::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse&& value) {
  ::test::union_::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse hlcpp;
  hlcpp.xu = ::fidl::NaturalToHLCPP(std::move(value.xu()));
  return hlcpp;
}

::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse HLCPPToNaturalTraits<::test::union_::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse>::Convert(::test::union_::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse&& value) {
  return ::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse{{
      .xu = ::fidl::HLCPPToNatural(std::move(value.xu)),
  }};
}
::test::union_::StructWithNullableUnion NaturalToHLCPPTraits<::test_union::StructWithNullableUnion>::Convert(::test_union::StructWithNullableUnion&& value) {
  ::test::union_::StructWithNullableUnion hlcpp;
  hlcpp.x1 = ::fidl::NaturalToHLCPP(std::move(value.x1()));
  return hlcpp;
}

::test_union::StructWithNullableUnion HLCPPToNaturalTraits<::test::union_::StructWithNullableUnion>::Convert(::test::union_::StructWithNullableUnion&& value) {
  return ::test_union::StructWithNullableUnion{{
      .x1 = ::fidl::HLCPPToNatural(std::move(value.x1)),
  }};
}
::test::union_::UnionSandwich NaturalToHLCPPTraits<::test_union::UnionSandwich>::Convert(::test_union::UnionSandwich&& value) {
  ::test::union_::UnionSandwich hlcpp;
  hlcpp.a = ::fidl::NaturalToHLCPP(std::move(value.a()));
  hlcpp.u = ::fidl::NaturalToHLCPP(std::move(value.u()));
  hlcpp.b = ::fidl::NaturalToHLCPP(std::move(value.b()));
  return hlcpp;
}

::test_union::UnionSandwich HLCPPToNaturalTraits<::test::union_::UnionSandwich>::Convert(::test::union_::UnionSandwich&& value) {
  return ::test_union::UnionSandwich{{
      .a = ::fidl::HLCPPToNatural(std::move(value.a)),
      .u = ::fidl::HLCPPToNatural(std::move(value.u)),
      .b = ::fidl::HLCPPToNatural(std::move(value.b)),
  }};
}

::test::union_::PizzaOrPasta NaturalToHLCPPTraits<::test_union::PizzaOrPasta>::Convert(::test_union::PizzaOrPasta&& value) {
  ::test::union_::PizzaOrPasta hlcpp;
  switch (value.Which()) {
    case ::test_union::PizzaOrPasta::Tag::kPizza:
      hlcpp.set_pizza(::fidl::NaturalToHLCPP(std::move(value.pizza().value())));
      break;
    case ::test_union::PizzaOrPasta::Tag::kPasta:
      hlcpp.set_pasta(::fidl::NaturalToHLCPP(std::move(value.pasta().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::PizzaOrPasta HLCPPToNaturalTraits<::test::union_::PizzaOrPasta>::Convert(::test::union_::PizzaOrPasta&& value) {
  using _NaturalUnion = ::test_union::PizzaOrPasta;
  switch (value.Which()) {
    case ::test::union_::PizzaOrPasta::Tag::kPizza:
      return _NaturalUnion::WithPizza(
          ::fidl::HLCPPToNatural(std::move(value.pizza())));
    case ::test::union_::PizzaOrPasta::Tag::kPasta:
      return _NaturalUnion::WithPasta(
          ::fidl::HLCPPToNatural(std::move(value.pasta())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::PizzaOrPasta");
  }
}
::test::union_::ExplicitPizzaOrPasta NaturalToHLCPPTraits<::test_union::ExplicitPizzaOrPasta>::Convert(::test_union::ExplicitPizzaOrPasta&& value) {
  ::test::union_::ExplicitPizzaOrPasta hlcpp;
  switch (value.Which()) {
    case ::test_union::ExplicitPizzaOrPasta::Tag::kPizza:
      hlcpp.set_pizza(::fidl::NaturalToHLCPP(std::move(value.pizza().value())));
      break;
    case ::test_union::ExplicitPizzaOrPasta::Tag::kPasta:
      hlcpp.set_pasta(::fidl::NaturalToHLCPP(std::move(value.pasta().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::ExplicitPizzaOrPasta HLCPPToNaturalTraits<::test::union_::ExplicitPizzaOrPasta>::Convert(::test::union_::ExplicitPizzaOrPasta&& value) {
  using _NaturalUnion = ::test_union::ExplicitPizzaOrPasta;
  switch (value.Which()) {
    case ::test::union_::ExplicitPizzaOrPasta::Tag::kPizza:
      return _NaturalUnion::WithPizza(
          ::fidl::HLCPPToNatural(std::move(value.pizza())));
    case ::test::union_::ExplicitPizzaOrPasta::Tag::kPasta:
      return _NaturalUnion::WithPasta(
          ::fidl::HLCPPToNatural(std::move(value.pasta())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::ExplicitPizzaOrPasta");
  }
}
::test::union_::FlexiblePizzaOrPasta NaturalToHLCPPTraits<::test_union::FlexiblePizzaOrPasta>::Convert(::test_union::FlexiblePizzaOrPasta&& value) {
  ::test::union_::FlexiblePizzaOrPasta hlcpp;
  switch (value.Which()) {
    case ::test_union::FlexiblePizzaOrPasta::Tag::kPizza:
      hlcpp.set_pizza(::fidl::NaturalToHLCPP(std::move(value.pizza().value())));
      break;
    case ::test_union::FlexiblePizzaOrPasta::Tag::kPasta:
      hlcpp.set_pasta(::fidl::NaturalToHLCPP(std::move(value.pasta().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::FlexiblePizzaOrPasta HLCPPToNaturalTraits<::test::union_::FlexiblePizzaOrPasta>::Convert(::test::union_::FlexiblePizzaOrPasta&& value) {
  using _NaturalUnion = ::test_union::FlexiblePizzaOrPasta;
  switch (value.Which()) {
    case ::test::union_::FlexiblePizzaOrPasta::Tag::kPizza:
      return _NaturalUnion::WithPizza(
          ::fidl::HLCPPToNatural(std::move(value.pizza())));
    case ::test::union_::FlexiblePizzaOrPasta::Tag::kPasta:
      return _NaturalUnion::WithPasta(
          ::fidl::HLCPPToNatural(std::move(value.pasta())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::StrictPizzaOrPasta NaturalToHLCPPTraits<::test_union::StrictPizzaOrPasta>::Convert(::test_union::StrictPizzaOrPasta&& value) {
  ::test::union_::StrictPizzaOrPasta hlcpp;
  switch (value.Which()) {
    case ::test_union::StrictPizzaOrPasta::Tag::kPizza:
      hlcpp.set_pizza(::fidl::NaturalToHLCPP(std::move(value.pizza().value())));
      break;
    case ::test_union::StrictPizzaOrPasta::Tag::kPasta:
      hlcpp.set_pasta(::fidl::NaturalToHLCPP(std::move(value.pasta().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::StrictPizzaOrPasta HLCPPToNaturalTraits<::test::union_::StrictPizzaOrPasta>::Convert(::test::union_::StrictPizzaOrPasta&& value) {
  using _NaturalUnion = ::test_union::StrictPizzaOrPasta;
  switch (value.Which()) {
    case ::test::union_::StrictPizzaOrPasta::Tag::kPizza:
      return _NaturalUnion::WithPizza(
          ::fidl::HLCPPToNatural(std::move(value.pizza())));
    case ::test::union_::StrictPizzaOrPasta::Tag::kPasta:
      return _NaturalUnion::WithPasta(
          ::fidl::HLCPPToNatural(std::move(value.pasta())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::StrictPizzaOrPasta");
  }
}
::test::union_::Union NaturalToHLCPPTraits<::test_union::Union>::Convert(::test_union::Union&& value) {
  ::test::union_::Union hlcpp;
  switch (value.Which()) {
    case ::test_union::Union::Tag::kPrimitive:
      hlcpp.set_Primitive(::fidl::NaturalToHLCPP(std::move(value.primitive().value())));
      break;
    case ::test_union::Union::Tag::kStringNeedsConstructor:
      hlcpp.set_StringNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.string_needs_constructor().value())));
      break;
    case ::test_union::Union::Tag::kVectorStringAlsoNeedsConstructor:
      hlcpp.set_VectorStringAlsoNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.vector_string_also_needs_constructor().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::Union HLCPPToNaturalTraits<::test::union_::Union>::Convert(::test::union_::Union&& value) {
  using _NaturalUnion = ::test_union::Union;
  switch (value.Which()) {
    case ::test::union_::Union::Tag::kPrimitive:
      return _NaturalUnion::WithPrimitive(
          ::fidl::HLCPPToNatural(std::move(value.Primitive())));
    case ::test::union_::Union::Tag::kStringNeedsConstructor:
      return _NaturalUnion::WithStringNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.StringNeedsConstructor())));
    case ::test::union_::Union::Tag::kVectorStringAlsoNeedsConstructor:
      return _NaturalUnion::WithVectorStringAlsoNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.VectorStringAlsoNeedsConstructor())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::Union");
  }
}
::test::union_::FlexibleUnion NaturalToHLCPPTraits<::test_union::FlexibleUnion>::Convert(::test_union::FlexibleUnion&& value) {
  ::test::union_::FlexibleUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::FlexibleUnion::Tag::kPrimitive:
      hlcpp.set_Primitive(::fidl::NaturalToHLCPP(std::move(value.primitive().value())));
      break;
    case ::test_union::FlexibleUnion::Tag::kStringNeedsConstructor:
      hlcpp.set_StringNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.string_needs_constructor().value())));
      break;
    case ::test_union::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor:
      hlcpp.set_VectorStringAlsoNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.vector_string_also_needs_constructor().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::FlexibleUnion HLCPPToNaturalTraits<::test::union_::FlexibleUnion>::Convert(::test::union_::FlexibleUnion&& value) {
  using _NaturalUnion = ::test_union::FlexibleUnion;
  switch (value.Which()) {
    case ::test::union_::FlexibleUnion::Tag::kPrimitive:
      return _NaturalUnion::WithPrimitive(
          ::fidl::HLCPPToNatural(std::move(value.Primitive())));
    case ::test::union_::FlexibleUnion::Tag::kStringNeedsConstructor:
      return _NaturalUnion::WithStringNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.StringNeedsConstructor())));
    case ::test::union_::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor:
      return _NaturalUnion::WithVectorStringAlsoNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.VectorStringAlsoNeedsConstructor())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::StrictUnion NaturalToHLCPPTraits<::test_union::StrictUnion>::Convert(::test_union::StrictUnion&& value) {
  ::test::union_::StrictUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::StrictUnion::Tag::kPrimitive:
      hlcpp.set_Primitive(::fidl::NaturalToHLCPP(std::move(value.primitive().value())));
      break;
    case ::test_union::StrictUnion::Tag::kStringNeedsConstructor:
      hlcpp.set_StringNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.string_needs_constructor().value())));
      break;
    case ::test_union::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor:
      hlcpp.set_VectorStringAlsoNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.vector_string_also_needs_constructor().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::StrictUnion HLCPPToNaturalTraits<::test::union_::StrictUnion>::Convert(::test::union_::StrictUnion&& value) {
  using _NaturalUnion = ::test_union::StrictUnion;
  switch (value.Which()) {
    case ::test::union_::StrictUnion::Tag::kPrimitive:
      return _NaturalUnion::WithPrimitive(
          ::fidl::HLCPPToNatural(std::move(value.Primitive())));
    case ::test::union_::StrictUnion::Tag::kStringNeedsConstructor:
      return _NaturalUnion::WithStringNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.StringNeedsConstructor())));
    case ::test::union_::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor:
      return _NaturalUnion::WithVectorStringAlsoNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.VectorStringAlsoNeedsConstructor())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::StrictUnion");
  }
}
::test::union_::FieldCollision NaturalToHLCPPTraits<::test_union::FieldCollision>::Convert(::test_union::FieldCollision&& value) {
  ::test::union_::FieldCollision hlcpp;
  switch (value.Which()) {
    case ::test_union::FieldCollision::Tag::kFieldCollisionTag:
      hlcpp.set_field_collision_tag(::fidl::NaturalToHLCPP(std::move(value.field_collision_tag().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::FieldCollision HLCPPToNaturalTraits<::test::union_::FieldCollision>::Convert(::test::union_::FieldCollision&& value) {
  using _NaturalUnion = ::test_union::FieldCollision;
  switch (value.Which()) {
    case ::test::union_::FieldCollision::Tag::kFieldCollisionTag:
      return _NaturalUnion::WithFieldCollisionTag(
          ::fidl::HLCPPToNatural(std::move(value.field_collision_tag())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::FieldCollision");
  }
}
::test::union_::ExplicitUnion NaturalToHLCPPTraits<::test_union::ExplicitUnion>::Convert(::test_union::ExplicitUnion&& value) {
  ::test::union_::ExplicitUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::ExplicitUnion::Tag::kPrimitive:
      hlcpp.set_Primitive(::fidl::NaturalToHLCPP(std::move(value.primitive().value())));
      break;
    case ::test_union::ExplicitUnion::Tag::kStringNeedsConstructor:
      hlcpp.set_StringNeedsConstructor(::fidl::NaturalToHLCPP(std::move(value.string_needs_constructor().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::ExplicitUnion HLCPPToNaturalTraits<::test::union_::ExplicitUnion>::Convert(::test::union_::ExplicitUnion&& value) {
  using _NaturalUnion = ::test_union::ExplicitUnion;
  switch (value.Which()) {
    case ::test::union_::ExplicitUnion::Tag::kPrimitive:
      return _NaturalUnion::WithPrimitive(
          ::fidl::HLCPPToNatural(std::move(value.Primitive())));
    case ::test::union_::ExplicitUnion::Tag::kStringNeedsConstructor:
      return _NaturalUnion::WithStringNeedsConstructor(
          ::fidl::HLCPPToNatural(std::move(value.StringNeedsConstructor())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::ExplicitUnion");
  }
}
::test::union_::ReverseOrdinalUnion NaturalToHLCPPTraits<::test_union::ReverseOrdinalUnion>::Convert(::test_union::ReverseOrdinalUnion&& value) {
  ::test::union_::ReverseOrdinalUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::ReverseOrdinalUnion::Tag::kFirst:
      hlcpp.set_first(::fidl::NaturalToHLCPP(std::move(value.first().value())));
      break;
    case ::test_union::ReverseOrdinalUnion::Tag::kSecond:
      hlcpp.set_second(::fidl::NaturalToHLCPP(std::move(value.second().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::ReverseOrdinalUnion HLCPPToNaturalTraits<::test::union_::ReverseOrdinalUnion>::Convert(::test::union_::ReverseOrdinalUnion&& value) {
  using _NaturalUnion = ::test_union::ReverseOrdinalUnion;
  switch (value.Which()) {
    case ::test::union_::ReverseOrdinalUnion::Tag::kFirst:
      return _NaturalUnion::WithFirst(
          ::fidl::HLCPPToNatural(std::move(value.first())));
    case ::test::union_::ReverseOrdinalUnion::Tag::kSecond:
      return _NaturalUnion::WithSecond(
          ::fidl::HLCPPToNatural(std::move(value.second())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::ReverseOrdinalUnion");
  }
}
::test::union_::FlexibleFoo NaturalToHLCPPTraits<::test_union::FlexibleFoo>::Convert(::test_union::FlexibleFoo&& value) {
  ::test::union_::FlexibleFoo hlcpp;
  switch (value.Which()) {
    case ::test_union::FlexibleFoo::Tag::kS:
      hlcpp.set_s(::fidl::NaturalToHLCPP(std::move(value.s().value())));
      break;
    case ::test_union::FlexibleFoo::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::FlexibleFoo HLCPPToNaturalTraits<::test::union_::FlexibleFoo>::Convert(::test::union_::FlexibleFoo&& value) {
  using _NaturalUnion = ::test_union::FlexibleFoo;
  switch (value.Which()) {
    case ::test::union_::FlexibleFoo::Tag::kS:
      return _NaturalUnion::WithS(
          ::fidl::HLCPPToNatural(std::move(value.s())));
    case ::test::union_::FlexibleFoo::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::StrictFoo NaturalToHLCPPTraits<::test_union::StrictFoo>::Convert(::test_union::StrictFoo&& value) {
  ::test::union_::StrictFoo hlcpp;
  switch (value.Which()) {
    case ::test_union::StrictFoo::Tag::kS:
      hlcpp.set_s(::fidl::NaturalToHLCPP(std::move(value.s().value())));
      break;
    case ::test_union::StrictFoo::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::StrictFoo HLCPPToNaturalTraits<::test::union_::StrictFoo>::Convert(::test::union_::StrictFoo&& value) {
  using _NaturalUnion = ::test_union::StrictFoo;
  switch (value.Which()) {
    case ::test::union_::StrictFoo::Tag::kS:
      return _NaturalUnion::WithS(
          ::fidl::HLCPPToNatural(std::move(value.s())));
    case ::test::union_::StrictFoo::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::StrictFoo");
  }
}
::test::union_::ExplicitFoo NaturalToHLCPPTraits<::test_union::ExplicitFoo>::Convert(::test_union::ExplicitFoo&& value) {
  ::test::union_::ExplicitFoo hlcpp;
  switch (value.Which()) {
    case ::test_union::ExplicitFoo::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    case ::test_union::ExplicitFoo::Tag::kS:
      hlcpp.set_s(::fidl::NaturalToHLCPP(std::move(value.s().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::ExplicitFoo HLCPPToNaturalTraits<::test::union_::ExplicitFoo>::Convert(::test::union_::ExplicitFoo&& value) {
  using _NaturalUnion = ::test_union::ExplicitFoo;
  switch (value.Which()) {
    case ::test::union_::ExplicitFoo::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    case ::test::union_::ExplicitFoo::Tag::kS:
      return _NaturalUnion::WithS(
          ::fidl::HLCPPToNatural(std::move(value.s())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::ExplicitStrictFoo NaturalToHLCPPTraits<::test_union::ExplicitStrictFoo>::Convert(::test_union::ExplicitStrictFoo&& value) {
  ::test::union_::ExplicitStrictFoo hlcpp;
  switch (value.Which()) {
    case ::test_union::ExplicitStrictFoo::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    case ::test_union::ExplicitStrictFoo::Tag::kS:
      hlcpp.set_s(::fidl::NaturalToHLCPP(std::move(value.s().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::ExplicitStrictFoo HLCPPToNaturalTraits<::test::union_::ExplicitStrictFoo>::Convert(::test::union_::ExplicitStrictFoo&& value) {
  using _NaturalUnion = ::test_union::ExplicitStrictFoo;
  switch (value.Which()) {
    case ::test::union_::ExplicitStrictFoo::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    case ::test::union_::ExplicitStrictFoo::Tag::kS:
      return _NaturalUnion::WithS(
          ::fidl::HLCPPToNatural(std::move(value.s())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::ExplicitStrictFoo");
  }
}
::test::union_::OlderSimpleUnion NaturalToHLCPPTraits<::test_union::OlderSimpleUnion>::Convert(::test_union::OlderSimpleUnion&& value) {
  ::test::union_::OlderSimpleUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::OlderSimpleUnion::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    case ::test_union::OlderSimpleUnion::Tag::kF:
      hlcpp.set_f(::fidl::NaturalToHLCPP(std::move(value.f().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::OlderSimpleUnion HLCPPToNaturalTraits<::test::union_::OlderSimpleUnion>::Convert(::test::union_::OlderSimpleUnion&& value) {
  using _NaturalUnion = ::test_union::OlderSimpleUnion;
  switch (value.Which()) {
    case ::test::union_::OlderSimpleUnion::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    case ::test::union_::OlderSimpleUnion::Tag::kF:
      return _NaturalUnion::WithF(
          ::fidl::HLCPPToNatural(std::move(value.f())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::NewerSimpleUnion NaturalToHLCPPTraits<::test_union::NewerSimpleUnion>::Convert(::test_union::NewerSimpleUnion&& value) {
  ::test::union_::NewerSimpleUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::NewerSimpleUnion::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    case ::test_union::NewerSimpleUnion::Tag::kS:
      hlcpp.set_s(::fidl::NaturalToHLCPP(std::move(value.s().value())));
      break;
    case ::test_union::NewerSimpleUnion::Tag::kV:
      hlcpp.set_v(::fidl::NaturalToHLCPP(std::move(value.v().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::NewerSimpleUnion HLCPPToNaturalTraits<::test::union_::NewerSimpleUnion>::Convert(::test::union_::NewerSimpleUnion&& value) {
  using _NaturalUnion = ::test_union::NewerSimpleUnion;
  switch (value.Which()) {
    case ::test::union_::NewerSimpleUnion::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    case ::test::union_::NewerSimpleUnion::Tag::kS:
      return _NaturalUnion::WithS(
          ::fidl::HLCPPToNatural(std::move(value.s())));
    case ::test::union_::NewerSimpleUnion::Tag::kV:
      return _NaturalUnion::WithV(
          ::fidl::HLCPPToNatural(std::move(value.v())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::StrictSimpleUnion NaturalToHLCPPTraits<::test_union::StrictSimpleUnion>::Convert(::test_union::StrictSimpleUnion&& value) {
  ::test::union_::StrictSimpleUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::StrictSimpleUnion::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    case ::test_union::StrictSimpleUnion::Tag::kF:
      hlcpp.set_f(::fidl::NaturalToHLCPP(std::move(value.f().value())));
      break;
    case ::test_union::StrictSimpleUnion::Tag::kS:
      hlcpp.set_s(::fidl::NaturalToHLCPP(std::move(value.s().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::StrictSimpleUnion HLCPPToNaturalTraits<::test::union_::StrictSimpleUnion>::Convert(::test::union_::StrictSimpleUnion&& value) {
  using _NaturalUnion = ::test_union::StrictSimpleUnion;
  switch (value.Which()) {
    case ::test::union_::StrictSimpleUnion::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    case ::test::union_::StrictSimpleUnion::Tag::kF:
      return _NaturalUnion::WithF(
          ::fidl::HLCPPToNatural(std::move(value.f())));
    case ::test::union_::StrictSimpleUnion::Tag::kS:
      return _NaturalUnion::WithS(
          ::fidl::HLCPPToNatural(std::move(value.s())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::StrictSimpleUnion");
  }
}
::test::union_::UnionContainingEmptyStruct NaturalToHLCPPTraits<::test_union::UnionContainingEmptyStruct>::Convert(::test_union::UnionContainingEmptyStruct&& value) {
  ::test::union_::UnionContainingEmptyStruct hlcpp;
  switch (value.Which()) {
    case ::test_union::UnionContainingEmptyStruct::Tag::kEmpty:
      hlcpp.set_empty(::fidl::NaturalToHLCPP(std::move(value.empty().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::UnionContainingEmptyStruct HLCPPToNaturalTraits<::test::union_::UnionContainingEmptyStruct>::Convert(::test::union_::UnionContainingEmptyStruct&& value) {
  using _NaturalUnion = ::test_union::UnionContainingEmptyStruct;
  switch (value.Which()) {
    case ::test::union_::UnionContainingEmptyStruct::Tag::kEmpty:
      return _NaturalUnion::WithEmpty(
          ::fidl::HLCPPToNatural(std::move(value.empty())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::StrictBoundedUnion NaturalToHLCPPTraits<::test_union::StrictBoundedUnion>::Convert(::test_union::StrictBoundedUnion&& value) {
  ::test::union_::StrictBoundedUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::StrictBoundedUnion::Tag::kV:
      hlcpp.set_v(::fidl::NaturalToHLCPP(std::move(value.v().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::StrictBoundedUnion HLCPPToNaturalTraits<::test::union_::StrictBoundedUnion>::Convert(::test::union_::StrictBoundedUnion&& value) {
  using _NaturalUnion = ::test_union::StrictBoundedUnion;
  switch (value.Which()) {
    case ::test::union_::StrictBoundedUnion::Tag::kV:
      return _NaturalUnion::WithV(
          ::fidl::HLCPPToNatural(std::move(value.v())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::union_::StrictBoundedUnion");
  }
}
::test::union_::ExplicitFlexibleUnion NaturalToHLCPPTraits<::test_union::ExplicitFlexibleUnion>::Convert(::test_union::ExplicitFlexibleUnion&& value) {
  ::test::union_::ExplicitFlexibleUnion hlcpp;
  switch (value.Which()) {
    case ::test_union::ExplicitFlexibleUnion::Tag::kI:
      hlcpp.set_i(::fidl::NaturalToHLCPP(std::move(value.i().value())));
      break;
    case ::test_union::ExplicitFlexibleUnion::Tag::kF:
      hlcpp.set_f(::fidl::NaturalToHLCPP(std::move(value.f().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::ExplicitFlexibleUnion HLCPPToNaturalTraits<::test::union_::ExplicitFlexibleUnion>::Convert(::test::union_::ExplicitFlexibleUnion&& value) {
  using _NaturalUnion = ::test_union::ExplicitFlexibleUnion;
  switch (value.Which()) {
    case ::test::union_::ExplicitFlexibleUnion::Tag::kI:
      return _NaturalUnion::WithI(
          ::fidl::HLCPPToNatural(std::move(value.i())));
    case ::test::union_::ExplicitFlexibleUnion::Tag::kF:
      return _NaturalUnion::WithF(
          ::fidl::HLCPPToNatural(std::move(value.f())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::UnionWithAttributes NaturalToHLCPPTraits<::test_union::UnionWithAttributes>::Convert(::test_union::UnionWithAttributes&& value) {
  ::test::union_::UnionWithAttributes hlcpp;
  switch (value.Which()) {
    case ::test_union::UnionWithAttributes::Tag::kX:
      hlcpp.set_x(::fidl::NaturalToHLCPP(std::move(value.x().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_union::UnionWithAttributes HLCPPToNaturalTraits<::test::union_::UnionWithAttributes>::Convert(::test::union_::UnionWithAttributes&& value) {
  using _NaturalUnion = ::test_union::UnionWithAttributes;
  switch (value.Which()) {
    case ::test::union_::UnionWithAttributes::Tag::kX:
      return _NaturalUnion::WithX(
          ::fidl::HLCPPToNatural(std::move(value.x())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::EmptyFlexibleUnion NaturalToHLCPPTraits<::test_union::EmptyFlexibleUnion>::Convert(::test_union::EmptyFlexibleUnion&& value) {
  ::test::union_::EmptyFlexibleUnion hlcpp;
  switch (value.Which()) {
    default:
      break;
  }
  return hlcpp;
}

::test_union::EmptyFlexibleUnion HLCPPToNaturalTraits<::test::union_::EmptyFlexibleUnion>::Convert(::test::union_::EmptyFlexibleUnion&& value) {
  using _NaturalUnion = ::test_union::EmptyFlexibleUnion;
  switch (value.Which()) {
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::union_::OnlyReservedFlexibleUnion NaturalToHLCPPTraits<::test_union::OnlyReservedFlexibleUnion>::Convert(::test_union::OnlyReservedFlexibleUnion&& value) {
  ::test::union_::OnlyReservedFlexibleUnion hlcpp;
  switch (value.Which()) {
    default:
      break;
  }
  return hlcpp;
}

::test_union::OnlyReservedFlexibleUnion HLCPPToNaturalTraits<::test::union_::OnlyReservedFlexibleUnion>::Convert(::test::union_::OnlyReservedFlexibleUnion&& value) {
  using _NaturalUnion = ::test_union::OnlyReservedFlexibleUnion;
  switch (value.Which()) {
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}

#pragma clang diagnostic pop

}  // namespace internal
}  // namespace fidl
