// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include <cinttypes>
#include <string>

#include <lib/fidl/cpp/natural_types.h>
#include <lib/fidl/cpp/natural_coding_traits.h>

#include <fidl/test.protocols/cpp/markers.h>
#include <fidl/test.protocols/cpp/common_types.h>


#ifdef __Fuchsia__

  #include <lib/zx/channel.h>
  #include <lib/zx/handle.h>
  #include <lib/zx/socket.h>
  

#endif  // __Fuchsia__


namespace test_protocols {





class WithAndWithoutRequestResponseNoRequestWithResponseResponse;


class WithAndWithoutRequestResponseWithRequestNoResponseRequest;


class WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;


class WithAndWithoutRequestResponseWithRequestWithResponseRequest;


class WithAndWithoutRequestResponseWithRequestWithResponseResponse;


class WithAndWithoutRequestResponseOnWithResponseRequest;


class WithErrorSyntaxResponseAsStructResponse;


class WithErrorSyntaxResponseAsStructTopResponse;


class WithErrorSyntaxErrorAsPrimitiveResponse;


class WithErrorSyntaxErrorAsPrimitiveTopResponse;


class WithErrorSyntaxErrorAsEnumResponse;


class WithErrorSyntaxErrorAsEnumTopResponse;


class WithErrorSyntaxHandleInResultResponse;


class WithErrorSyntaxHandleInResultTopResponse;


class ChannelProtocolMethodARequest;


class ChannelProtocolEventARequest;


class ChannelProtocolMethodBRequest;


class ChannelProtocolMethodBResponse;


class ChannelProtocolTakeHandleRequest;


class ChannelProtocolMutateSocketRequest;


class ChannelProtocolMutateSocketResponse;


class SyscallProtocolMethodCRequest;


class TransitionalRequestRequest;


class TransitionalRequestResponse;


class TransitionalOneWayRequest;


class TransitionalEventRequest;


class HandleRightsProtocolNoResponseMethodRequest;


class HandleRightsProtocolResponseMethodRequest;


class HandleRightsProtocolResponseMethodResponse;


class HandleRightsProtocolAnEventRequest;


class ProtocolEnds;


class WithProtocolEndsClientEndsRequest;


class WithProtocolEndsClientEndsResponse;


class WithProtocolEndsServerEndsRequest;


class WithProtocolEndsServerEndsResponse;


class WithProtocolEndsStructContainingEndsRequest;


class WithProtocolEndsStructContainingEndsResponse;


class ManyParametersFifteenRequest;


class MethodWithUnionUnionMethodRequest;


class MethodWithUnionUnionMethodResponse;





class WithErrorSyntaxResponseAsStructResult;



class WithErrorSyntaxErrorAsPrimitiveResult;



class WithErrorSyntaxErrorAsEnumResult;



class WithErrorSyntaxHandleInResultResult;



class TheUnion;




  



extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;


class WithAndWithoutRequestResponseNoRequestWithResponseResponse {
 private:
  struct Storage_;
 public:
  WithAndWithoutRequestResponseNoRequestWithResponseResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithAndWithoutRequestResponseNoRequestWithResponseResponse(::std::string ret) noexcept
    : storage_({
      .ret = std::move(ret)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithAndWithoutRequestResponseNoRequestWithResponseResponse| only if all of its members are default constructible.
  WithAndWithoutRequestResponseNoRequestWithResponseResponse() = default;
#pragma clang diagnostic pop

  WithAndWithoutRequestResponseNoRequestWithResponseResponse(WithAndWithoutRequestResponseNoRequestWithResponseResponse&&) noexcept = default;
  WithAndWithoutRequestResponseNoRequestWithResponseResponse& operator=(WithAndWithoutRequestResponseNoRequestWithResponseResponse&&) noexcept = default;
    WithAndWithoutRequestResponseNoRequestWithResponseResponse(const WithAndWithoutRequestResponseNoRequestWithResponseResponse& other) noexcept : WithAndWithoutRequestResponseNoRequestWithResponseResponse(other.CloneStorage_()){}
    WithAndWithoutRequestResponseNoRequestWithResponseResponse& operator=(const WithAndWithoutRequestResponseNoRequestWithResponseResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const WithAndWithoutRequestResponseNoRequestWithResponseResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const WithAndWithoutRequestResponseNoRequestWithResponseResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse, 16>::Equal(this, &other);
    }
    
      const ::std::string &
    ret() const {
      return storage_.ret;
    }

    
    ::std::string& ret() {
      return storage_.ret;
    }

    // Setter for ret.
    //
    
    WithAndWithoutRequestResponseNoRequestWithResponseResponse& ret(::std::string value) {
      storage_.ret = std::move(value);
      return *this;
    }

  WithAndWithoutRequestResponseNoRequestWithResponseResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithAndWithoutRequestResponseNoRequestWithResponseResponse(Storage_{
      .ret ={},
  }) {}

 private:
  struct Storage_ final {
      ::std::string ret;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::string, fidl::internal::NaturalCodingConstraintString<>>{
        &Storage_::ret, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;


class WithAndWithoutRequestResponseWithRequestNoResponseRequest {
 private:
  struct Storage_;
 public:
  WithAndWithoutRequestResponseWithRequestNoResponseRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithAndWithoutRequestResponseWithRequestNoResponseRequest(::std::string arg) noexcept
    : storage_({
      .arg = std::move(arg)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithAndWithoutRequestResponseWithRequestNoResponseRequest| only if all of its members are default constructible.
  WithAndWithoutRequestResponseWithRequestNoResponseRequest() = default;
#pragma clang diagnostic pop

  WithAndWithoutRequestResponseWithRequestNoResponseRequest(WithAndWithoutRequestResponseWithRequestNoResponseRequest&&) noexcept = default;
  WithAndWithoutRequestResponseWithRequestNoResponseRequest& operator=(WithAndWithoutRequestResponseWithRequestNoResponseRequest&&) noexcept = default;
    WithAndWithoutRequestResponseWithRequestNoResponseRequest(const WithAndWithoutRequestResponseWithRequestNoResponseRequest& other) noexcept : WithAndWithoutRequestResponseWithRequestNoResponseRequest(other.CloneStorage_()){}
    WithAndWithoutRequestResponseWithRequestNoResponseRequest& operator=(const WithAndWithoutRequestResponseWithRequestNoResponseRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const WithAndWithoutRequestResponseWithRequestNoResponseRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest, 16>::Equal(this, &other);
    }
    bool operator!=(const WithAndWithoutRequestResponseWithRequestNoResponseRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest, 16>::Equal(this, &other);
    }
    
      const ::std::string &
    arg() const {
      return storage_.arg;
    }

    
    ::std::string& arg() {
      return storage_.arg;
    }

    // Setter for arg.
    //
    
    WithAndWithoutRequestResponseWithRequestNoResponseRequest& arg(::std::string value) {
      storage_.arg = std::move(value);
      return *this;
    }

  WithAndWithoutRequestResponseWithRequestNoResponseRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithAndWithoutRequestResponseWithRequestNoResponseRequest(Storage_{
      .arg ={},
  }) {}

 private:
  struct Storage_ final {
      ::std::string arg;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::string, fidl::internal::NaturalCodingConstraintString<>>{
        &Storage_::arg, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;


class WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
 private:
  struct Storage_;
 public:
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(::std::string arg) noexcept
    : storage_({
      .arg = std::move(arg)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithAndWithoutRequestResponseWithRequestEmptyResponseRequest| only if all of its members are default constructible.
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest() = default;
#pragma clang diagnostic pop

  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&) noexcept = default;
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest& operator=(WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&) noexcept = default;
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(const WithAndWithoutRequestResponseWithRequestEmptyResponseRequest& other) noexcept : WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(other.CloneStorage_()){}
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest& operator=(const WithAndWithoutRequestResponseWithRequestEmptyResponseRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const WithAndWithoutRequestResponseWithRequestEmptyResponseRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, 16>::Equal(this, &other);
    }
    bool operator!=(const WithAndWithoutRequestResponseWithRequestEmptyResponseRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, 16>::Equal(this, &other);
    }
    
      const ::std::string &
    arg() const {
      return storage_.arg;
    }

    
    ::std::string& arg() {
      return storage_.arg;
    }

    // Setter for arg.
    //
    
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest& arg(::std::string value) {
      storage_.arg = std::move(value);
      return *this;
    }

  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(Storage_{
      .arg ={},
  }) {}

 private:
  struct Storage_ final {
      ::std::string arg;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::string, fidl::internal::NaturalCodingConstraintString<>>{
        &Storage_::arg, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;


class WithAndWithoutRequestResponseWithRequestWithResponseRequest {
 private:
  struct Storage_;
 public:
  WithAndWithoutRequestResponseWithRequestWithResponseRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithAndWithoutRequestResponseWithRequestWithResponseRequest(::std::string arg) noexcept
    : storage_({
      .arg = std::move(arg)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithAndWithoutRequestResponseWithRequestWithResponseRequest| only if all of its members are default constructible.
  WithAndWithoutRequestResponseWithRequestWithResponseRequest() = default;
#pragma clang diagnostic pop

  WithAndWithoutRequestResponseWithRequestWithResponseRequest(WithAndWithoutRequestResponseWithRequestWithResponseRequest&&) noexcept = default;
  WithAndWithoutRequestResponseWithRequestWithResponseRequest& operator=(WithAndWithoutRequestResponseWithRequestWithResponseRequest&&) noexcept = default;
    WithAndWithoutRequestResponseWithRequestWithResponseRequest(const WithAndWithoutRequestResponseWithRequestWithResponseRequest& other) noexcept : WithAndWithoutRequestResponseWithRequestWithResponseRequest(other.CloneStorage_()){}
    WithAndWithoutRequestResponseWithRequestWithResponseRequest& operator=(const WithAndWithoutRequestResponseWithRequestWithResponseRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const WithAndWithoutRequestResponseWithRequestWithResponseRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest, 16>::Equal(this, &other);
    }
    bool operator!=(const WithAndWithoutRequestResponseWithRequestWithResponseRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest, 16>::Equal(this, &other);
    }
    
      const ::std::string &
    arg() const {
      return storage_.arg;
    }

    
    ::std::string& arg() {
      return storage_.arg;
    }

    // Setter for arg.
    //
    
    WithAndWithoutRequestResponseWithRequestWithResponseRequest& arg(::std::string value) {
      storage_.arg = std::move(value);
      return *this;
    }

  WithAndWithoutRequestResponseWithRequestWithResponseRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithAndWithoutRequestResponseWithRequestWithResponseRequest(Storage_{
      .arg ={},
  }) {}

 private:
  struct Storage_ final {
      ::std::string arg;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::string, fidl::internal::NaturalCodingConstraintString<>>{
        &Storage_::arg, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;


class WithAndWithoutRequestResponseWithRequestWithResponseResponse {
 private:
  struct Storage_;
 public:
  WithAndWithoutRequestResponseWithRequestWithResponseResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithAndWithoutRequestResponseWithRequestWithResponseResponse(::std::string ret) noexcept
    : storage_({
      .ret = std::move(ret)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithAndWithoutRequestResponseWithRequestWithResponseResponse| only if all of its members are default constructible.
  WithAndWithoutRequestResponseWithRequestWithResponseResponse() = default;
#pragma clang diagnostic pop

  WithAndWithoutRequestResponseWithRequestWithResponseResponse(WithAndWithoutRequestResponseWithRequestWithResponseResponse&&) noexcept = default;
  WithAndWithoutRequestResponseWithRequestWithResponseResponse& operator=(WithAndWithoutRequestResponseWithRequestWithResponseResponse&&) noexcept = default;
    WithAndWithoutRequestResponseWithRequestWithResponseResponse(const WithAndWithoutRequestResponseWithRequestWithResponseResponse& other) noexcept : WithAndWithoutRequestResponseWithRequestWithResponseResponse(other.CloneStorage_()){}
    WithAndWithoutRequestResponseWithRequestWithResponseResponse& operator=(const WithAndWithoutRequestResponseWithRequestWithResponseResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const WithAndWithoutRequestResponseWithRequestWithResponseResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const WithAndWithoutRequestResponseWithRequestWithResponseResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse, 16>::Equal(this, &other);
    }
    
      const ::std::string &
    ret() const {
      return storage_.ret;
    }

    
    ::std::string& ret() {
      return storage_.ret;
    }

    // Setter for ret.
    //
    
    WithAndWithoutRequestResponseWithRequestWithResponseResponse& ret(::std::string value) {
      storage_.ret = std::move(value);
      return *this;
    }

  WithAndWithoutRequestResponseWithRequestWithResponseResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithAndWithoutRequestResponseWithRequestWithResponseResponse(Storage_{
      .ret ={},
  }) {}

 private:
  struct Storage_ final {
      ::std::string ret;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::string, fidl::internal::NaturalCodingConstraintString<>>{
        &Storage_::ret, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;


class WithAndWithoutRequestResponseOnWithResponseRequest {
 private:
  struct Storage_;
 public:
  WithAndWithoutRequestResponseOnWithResponseRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithAndWithoutRequestResponseOnWithResponseRequest(::std::string ret) noexcept
    : storage_({
      .ret = std::move(ret)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithAndWithoutRequestResponseOnWithResponseRequest| only if all of its members are default constructible.
  WithAndWithoutRequestResponseOnWithResponseRequest() = default;
#pragma clang diagnostic pop

  WithAndWithoutRequestResponseOnWithResponseRequest(WithAndWithoutRequestResponseOnWithResponseRequest&&) noexcept = default;
  WithAndWithoutRequestResponseOnWithResponseRequest& operator=(WithAndWithoutRequestResponseOnWithResponseRequest&&) noexcept = default;
    WithAndWithoutRequestResponseOnWithResponseRequest(const WithAndWithoutRequestResponseOnWithResponseRequest& other) noexcept : WithAndWithoutRequestResponseOnWithResponseRequest(other.CloneStorage_()){}
    WithAndWithoutRequestResponseOnWithResponseRequest& operator=(const WithAndWithoutRequestResponseOnWithResponseRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const WithAndWithoutRequestResponseOnWithResponseRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest, 16>::Equal(this, &other);
    }
    bool operator!=(const WithAndWithoutRequestResponseOnWithResponseRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest, 16>::Equal(this, &other);
    }
    
      const ::std::string &
    ret() const {
      return storage_.ret;
    }

    
    ::std::string& ret() {
      return storage_.ret;
    }

    // Setter for ret.
    //
    
    WithAndWithoutRequestResponseOnWithResponseRequest& ret(::std::string value) {
      storage_.ret = std::move(value);
      return *this;
    }

  WithAndWithoutRequestResponseOnWithResponseRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithAndWithoutRequestResponseOnWithResponseRequest(Storage_{
      .ret ={},
  }) {}

 private:
  struct Storage_ final {
      ::std::string ret;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::string, fidl::internal::NaturalCodingConstraintString<>>{
        &Storage_::ret, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  
  
  
  
  



extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;


class WithErrorSyntaxResponseAsStructResponse {
 private:
  struct Storage_;
 public:
  WithErrorSyntaxResponseAsStructResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithErrorSyntaxResponseAsStructResponse(int64_t a, int64_t b, int64_t c) noexcept
    : storage_({
      .a = std::move(a), 
      .b = std::move(b), 
      .c = std::move(c)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithErrorSyntaxResponseAsStructResponse| only if all of its members are default constructible.
  WithErrorSyntaxResponseAsStructResponse() = default;
#pragma clang diagnostic pop

  WithErrorSyntaxResponseAsStructResponse(WithErrorSyntaxResponseAsStructResponse&&) noexcept = default;
  WithErrorSyntaxResponseAsStructResponse& operator=(WithErrorSyntaxResponseAsStructResponse&&) noexcept = default;
    WithErrorSyntaxResponseAsStructResponse(const WithErrorSyntaxResponseAsStructResponse& other) noexcept : WithErrorSyntaxResponseAsStructResponse(other.CloneStorage_()){}
    WithErrorSyntaxResponseAsStructResponse& operator=(const WithErrorSyntaxResponseAsStructResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const WithErrorSyntaxResponseAsStructResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxResponseAsStructResponse, 24>::Equal(this, &other);
    }
    bool operator!=(const WithErrorSyntaxResponseAsStructResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxResponseAsStructResponse, 24>::Equal(this, &other);
    }
    
      int64_t
    a() const {
      return storage_.a;
    }

    
    int64_t& a() {
      return storage_.a;
    }

    // Setter for a.
    //
    
    WithErrorSyntaxResponseAsStructResponse& a(int64_t value) {
      storage_.a = std::move(value);
      return *this;
    }
    
      int64_t
    b() const {
      return storage_.b;
    }

    
    int64_t& b() {
      return storage_.b;
    }

    // Setter for b.
    //
    
    WithErrorSyntaxResponseAsStructResponse& b(int64_t value) {
      storage_.b = std::move(value);
      return *this;
    }
    
      int64_t
    c() const {
      return storage_.c;
    }

    
    int64_t& c() {
      return storage_.c;
    }

    // Setter for c.
    //
    
    WithErrorSyntaxResponseAsStructResponse& c(int64_t value) {
      storage_.c = std::move(value);
      return *this;
    }

  WithErrorSyntaxResponseAsStructResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithErrorSyntaxResponseAsStructResponse(Storage_{
      .a ={},
      .b ={},
      .c ={},
  }) {}

 private:
  struct Storage_ final {
      int64_t a
        = {};
      int64_t b
        = {};
      int64_t c
        = {};
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxResponseAsStructResponse, 24>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithErrorSyntaxResponseAsStructResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::a, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::b, 8
      }, ::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::c, 16
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ResponseAsStruct_ResultTable;


class WithErrorSyntaxResponseAsStructResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_protocols::WithErrorSyntaxResponseAsStructResponse
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  WithErrorSyntaxResponseAsStructResult(WithErrorSyntaxResponseAsStructResult&& other) noexcept
      : WithErrorSyntaxResponseAsStructResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  WithErrorSyntaxResponseAsStructResult& operator=(WithErrorSyntaxResponseAsStructResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    WithErrorSyntaxResponseAsStructResult(const WithErrorSyntaxResponseAsStructResult& other) noexcept : WithErrorSyntaxResponseAsStructResult(other.CloneStorage_()){}
    WithErrorSyntaxResponseAsStructResult& operator=(const WithErrorSyntaxResponseAsStructResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const WithErrorSyntaxResponseAsStructResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const WithErrorSyntaxResponseAsStructResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocols::WithErrorSyntaxResponseAsStructResult::Tag Which() const {
    return WithErrorSyntaxResponseAsStructResult::IndexToTag(storage_->index()).value();
  }
    static WithErrorSyntaxResponseAsStructResult WithResponse(::test_protocols::WithErrorSyntaxResponseAsStructResponse val) {
      return WithErrorSyntaxResponseAsStructResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    WithErrorSyntaxResponseAsStructResult& response(::test_protocols::WithErrorSyntaxResponseAsStructResponse value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static WithErrorSyntaxResponseAsStructResult WithErr(uint32_t val) {
      return WithErrorSyntaxResponseAsStructResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    WithErrorSyntaxResponseAsStructResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  WithErrorSyntaxResponseAsStructResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocols::WithErrorSyntaxResponseAsStructResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit WithErrorSyntaxResponseAsStructResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocols::WithErrorSyntaxResponseAsStructResult::Tag tag) {
    switch (tag) {
        case ::test_protocols::WithErrorSyntaxResponseAsStructResult::Tag::kResponse: return 1;
        case ::test_protocols::WithErrorSyntaxResponseAsStructResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocols::WithErrorSyntaxResponseAsStructResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocols::WithErrorSyntaxResponseAsStructResult::Tag::kResponse;
        case 2: return ::test_protocols::WithErrorSyntaxResponseAsStructResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;


class WithErrorSyntaxResponseAsStructTopResponse {
 private:
  struct Storage_;
 public:
  WithErrorSyntaxResponseAsStructTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithErrorSyntaxResponseAsStructTopResponse(::test_protocols::WithErrorSyntaxResponseAsStructResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithErrorSyntaxResponseAsStructTopResponse| only if all of its members are default constructible.
  WithErrorSyntaxResponseAsStructTopResponse() = default;
#pragma clang diagnostic pop

  WithErrorSyntaxResponseAsStructTopResponse(WithErrorSyntaxResponseAsStructTopResponse&&) noexcept = default;
  WithErrorSyntaxResponseAsStructTopResponse& operator=(WithErrorSyntaxResponseAsStructTopResponse&&) noexcept = default;
    WithErrorSyntaxResponseAsStructTopResponse(const WithErrorSyntaxResponseAsStructTopResponse& other) noexcept : WithErrorSyntaxResponseAsStructTopResponse(other.CloneStorage_()){}
    WithErrorSyntaxResponseAsStructTopResponse& operator=(const WithErrorSyntaxResponseAsStructTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const WithErrorSyntaxResponseAsStructTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxResponseAsStructTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const WithErrorSyntaxResponseAsStructTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxResponseAsStructTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_protocols::WithErrorSyntaxResponseAsStructResult &
    result() const {
      return storage_.result;
    }

    
    ::test_protocols::WithErrorSyntaxResponseAsStructResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    WithErrorSyntaxResponseAsStructTopResponse& result(::test_protocols::WithErrorSyntaxResponseAsStructResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  WithErrorSyntaxResponseAsStructTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithErrorSyntaxResponseAsStructTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}

 private:
  struct Storage_ final {
      ::test_protocols::WithErrorSyntaxResponseAsStructResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxResponseAsStructTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithErrorSyntaxResponseAsStructTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocols::WithErrorSyntaxResponseAsStructResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;


class WithErrorSyntaxErrorAsPrimitiveResponse {
 private:
  struct Storage_;
 public:
  WithErrorSyntaxErrorAsPrimitiveResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithErrorSyntaxErrorAsPrimitiveResponse(uint8_t __reserved) noexcept
    : storage_({
      .__reserved = std::move(__reserved)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithErrorSyntaxErrorAsPrimitiveResponse| only if all of its members are default constructible.
  WithErrorSyntaxErrorAsPrimitiveResponse() = default;
#pragma clang diagnostic pop

  WithErrorSyntaxErrorAsPrimitiveResponse(WithErrorSyntaxErrorAsPrimitiveResponse&&) noexcept = default;
  WithErrorSyntaxErrorAsPrimitiveResponse& operator=(WithErrorSyntaxErrorAsPrimitiveResponse&&) noexcept = default;
    WithErrorSyntaxErrorAsPrimitiveResponse(const WithErrorSyntaxErrorAsPrimitiveResponse& other) noexcept : WithErrorSyntaxErrorAsPrimitiveResponse(other.CloneStorage_()){}
    WithErrorSyntaxErrorAsPrimitiveResponse& operator=(const WithErrorSyntaxErrorAsPrimitiveResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const WithErrorSyntaxErrorAsPrimitiveResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResponse, 1>::Equal(this, &other);
    }
    bool operator!=(const WithErrorSyntaxErrorAsPrimitiveResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResponse, 1>::Equal(this, &other);
    }
    
      uint8_t
    __reserved() const {
      return storage_.__reserved;
    }

    
    uint8_t& __reserved() {
      return storage_.__reserved;
    }

    // Setter for __reserved.
    //
    
    WithErrorSyntaxErrorAsPrimitiveResponse& __reserved(uint8_t value) {
      storage_.__reserved = std::move(value);
      return *this;
    }

  WithErrorSyntaxErrorAsPrimitiveResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithErrorSyntaxErrorAsPrimitiveResponse(Storage_{
      .__reserved =0u,
  }) {}

 private:
  struct Storage_ final {
      uint8_t __reserved
        =0u;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResponse, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, uint8_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::__reserved, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResultTable;


class WithErrorSyntaxErrorAsPrimitiveResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResponse
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  WithErrorSyntaxErrorAsPrimitiveResult(WithErrorSyntaxErrorAsPrimitiveResult&& other) noexcept
      : WithErrorSyntaxErrorAsPrimitiveResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  WithErrorSyntaxErrorAsPrimitiveResult& operator=(WithErrorSyntaxErrorAsPrimitiveResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    WithErrorSyntaxErrorAsPrimitiveResult(const WithErrorSyntaxErrorAsPrimitiveResult& other) noexcept : WithErrorSyntaxErrorAsPrimitiveResult(other.CloneStorage_()){}
    WithErrorSyntaxErrorAsPrimitiveResult& operator=(const WithErrorSyntaxErrorAsPrimitiveResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const WithErrorSyntaxErrorAsPrimitiveResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const WithErrorSyntaxErrorAsPrimitiveResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult::Tag Which() const {
    return WithErrorSyntaxErrorAsPrimitiveResult::IndexToTag(storage_->index()).value();
  }
    static WithErrorSyntaxErrorAsPrimitiveResult WithResponse(::test_protocols::WithErrorSyntaxErrorAsPrimitiveResponse val) {
      return WithErrorSyntaxErrorAsPrimitiveResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    WithErrorSyntaxErrorAsPrimitiveResult& response(::test_protocols::WithErrorSyntaxErrorAsPrimitiveResponse value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static WithErrorSyntaxErrorAsPrimitiveResult WithErr(uint32_t val) {
      return WithErrorSyntaxErrorAsPrimitiveResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    WithErrorSyntaxErrorAsPrimitiveResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  WithErrorSyntaxErrorAsPrimitiveResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit WithErrorSyntaxErrorAsPrimitiveResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult::Tag tag) {
    switch (tag) {
        case ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult::Tag::kResponse: return 1;
        case ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult::Tag::kResponse;
        case 2: return ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;


class WithErrorSyntaxErrorAsPrimitiveTopResponse {
 private:
  struct Storage_;
 public:
  WithErrorSyntaxErrorAsPrimitiveTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithErrorSyntaxErrorAsPrimitiveTopResponse(::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithErrorSyntaxErrorAsPrimitiveTopResponse| only if all of its members are default constructible.
  WithErrorSyntaxErrorAsPrimitiveTopResponse() = default;
#pragma clang diagnostic pop

  WithErrorSyntaxErrorAsPrimitiveTopResponse(WithErrorSyntaxErrorAsPrimitiveTopResponse&&) noexcept = default;
  WithErrorSyntaxErrorAsPrimitiveTopResponse& operator=(WithErrorSyntaxErrorAsPrimitiveTopResponse&&) noexcept = default;
    WithErrorSyntaxErrorAsPrimitiveTopResponse(const WithErrorSyntaxErrorAsPrimitiveTopResponse& other) noexcept : WithErrorSyntaxErrorAsPrimitiveTopResponse(other.CloneStorage_()){}
    WithErrorSyntaxErrorAsPrimitiveTopResponse& operator=(const WithErrorSyntaxErrorAsPrimitiveTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const WithErrorSyntaxErrorAsPrimitiveTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const WithErrorSyntaxErrorAsPrimitiveTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult &
    result() const {
      return storage_.result;
    }

    
    ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    WithErrorSyntaxErrorAsPrimitiveTopResponse& result(::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  WithErrorSyntaxErrorAsPrimitiveTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithErrorSyntaxErrorAsPrimitiveTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}

 private:
  struct Storage_ final {
      ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;


class WithErrorSyntaxErrorAsEnumResponse {
 private:
  struct Storage_;
 public:
  WithErrorSyntaxErrorAsEnumResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithErrorSyntaxErrorAsEnumResponse(uint8_t __reserved) noexcept
    : storage_({
      .__reserved = std::move(__reserved)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithErrorSyntaxErrorAsEnumResponse| only if all of its members are default constructible.
  WithErrorSyntaxErrorAsEnumResponse() = default;
#pragma clang diagnostic pop

  WithErrorSyntaxErrorAsEnumResponse(WithErrorSyntaxErrorAsEnumResponse&&) noexcept = default;
  WithErrorSyntaxErrorAsEnumResponse& operator=(WithErrorSyntaxErrorAsEnumResponse&&) noexcept = default;
    WithErrorSyntaxErrorAsEnumResponse(const WithErrorSyntaxErrorAsEnumResponse& other) noexcept : WithErrorSyntaxErrorAsEnumResponse(other.CloneStorage_()){}
    WithErrorSyntaxErrorAsEnumResponse& operator=(const WithErrorSyntaxErrorAsEnumResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const WithErrorSyntaxErrorAsEnumResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumResponse, 1>::Equal(this, &other);
    }
    bool operator!=(const WithErrorSyntaxErrorAsEnumResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumResponse, 1>::Equal(this, &other);
    }
    
      uint8_t
    __reserved() const {
      return storage_.__reserved;
    }

    
    uint8_t& __reserved() {
      return storage_.__reserved;
    }

    // Setter for __reserved.
    //
    
    WithErrorSyntaxErrorAsEnumResponse& __reserved(uint8_t value) {
      storage_.__reserved = std::move(value);
      return *this;
    }

  WithErrorSyntaxErrorAsEnumResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithErrorSyntaxErrorAsEnumResponse(Storage_{
      .__reserved =0u,
  }) {}

 private:
  struct Storage_ final {
      uint8_t __reserved
        =0u;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumResponse, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithErrorSyntaxErrorAsEnumResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, uint8_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::__reserved, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ErrorAsEnum_ResultTable;


class WithErrorSyntaxErrorAsEnumResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_protocols::WithErrorSyntaxErrorAsEnumResponse
        , ::test_protocols::ErrorEnum>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  WithErrorSyntaxErrorAsEnumResult(WithErrorSyntaxErrorAsEnumResult&& other) noexcept
      : WithErrorSyntaxErrorAsEnumResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  WithErrorSyntaxErrorAsEnumResult& operator=(WithErrorSyntaxErrorAsEnumResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    WithErrorSyntaxErrorAsEnumResult(const WithErrorSyntaxErrorAsEnumResult& other) noexcept : WithErrorSyntaxErrorAsEnumResult(other.CloneStorage_()){}
    WithErrorSyntaxErrorAsEnumResult& operator=(const WithErrorSyntaxErrorAsEnumResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const WithErrorSyntaxErrorAsEnumResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const WithErrorSyntaxErrorAsEnumResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocols::WithErrorSyntaxErrorAsEnumResult::Tag Which() const {
    return WithErrorSyntaxErrorAsEnumResult::IndexToTag(storage_->index()).value();
  }
    static WithErrorSyntaxErrorAsEnumResult WithResponse(::test_protocols::WithErrorSyntaxErrorAsEnumResponse val) {
      return WithErrorSyntaxErrorAsEnumResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    WithErrorSyntaxErrorAsEnumResult& response(::test_protocols::WithErrorSyntaxErrorAsEnumResponse value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static WithErrorSyntaxErrorAsEnumResult WithErr(::test_protocols::ErrorEnum val) {
      return WithErrorSyntaxErrorAsEnumResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    WithErrorSyntaxErrorAsEnumResult& err(::test_protocols::ErrorEnum value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  WithErrorSyntaxErrorAsEnumResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit WithErrorSyntaxErrorAsEnumResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocols::WithErrorSyntaxErrorAsEnumResult::Tag tag) {
    switch (tag) {
        case ::test_protocols::WithErrorSyntaxErrorAsEnumResult::Tag::kResponse: return 1;
        case ::test_protocols::WithErrorSyntaxErrorAsEnumResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocols::WithErrorSyntaxErrorAsEnumResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocols::WithErrorSyntaxErrorAsEnumResult::Tag::kResponse;
        case 2: return ::test_protocols::WithErrorSyntaxErrorAsEnumResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;


class WithErrorSyntaxErrorAsEnumTopResponse {
 private:
  struct Storage_;
 public:
  WithErrorSyntaxErrorAsEnumTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithErrorSyntaxErrorAsEnumTopResponse(::test_protocols::WithErrorSyntaxErrorAsEnumResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithErrorSyntaxErrorAsEnumTopResponse| only if all of its members are default constructible.
  WithErrorSyntaxErrorAsEnumTopResponse() = default;
#pragma clang diagnostic pop

  WithErrorSyntaxErrorAsEnumTopResponse(WithErrorSyntaxErrorAsEnumTopResponse&&) noexcept = default;
  WithErrorSyntaxErrorAsEnumTopResponse& operator=(WithErrorSyntaxErrorAsEnumTopResponse&&) noexcept = default;
    WithErrorSyntaxErrorAsEnumTopResponse(const WithErrorSyntaxErrorAsEnumTopResponse& other) noexcept : WithErrorSyntaxErrorAsEnumTopResponse(other.CloneStorage_()){}
    WithErrorSyntaxErrorAsEnumTopResponse& operator=(const WithErrorSyntaxErrorAsEnumTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const WithErrorSyntaxErrorAsEnumTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const WithErrorSyntaxErrorAsEnumTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_protocols::WithErrorSyntaxErrorAsEnumResult &
    result() const {
      return storage_.result;
    }

    
    ::test_protocols::WithErrorSyntaxErrorAsEnumResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    WithErrorSyntaxErrorAsEnumTopResponse& result(::test_protocols::WithErrorSyntaxErrorAsEnumResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  WithErrorSyntaxErrorAsEnumTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithErrorSyntaxErrorAsEnumTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}

 private:
  struct Storage_ final {
      ::test_protocols::WithErrorSyntaxErrorAsEnumResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocols::WithErrorSyntaxErrorAsEnumResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;


class WithErrorSyntaxHandleInResultResponse {
 private:
  struct Storage_;
 public:
  WithErrorSyntaxHandleInResultResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithErrorSyntaxHandleInResultResponse(::zx::handle h) noexcept
    : storage_({
      .h = std::move(h)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithErrorSyntaxHandleInResultResponse| only if all of its members are default constructible.
  WithErrorSyntaxHandleInResultResponse() = default;
#pragma clang diagnostic pop

  WithErrorSyntaxHandleInResultResponse(WithErrorSyntaxHandleInResultResponse&&) noexcept = default;
  WithErrorSyntaxHandleInResultResponse& operator=(WithErrorSyntaxHandleInResultResponse&&) noexcept = default;
    
      const ::zx::handle &
    h() const {
      return storage_.h;
    }

    
    ::zx::handle& h() {
      return storage_.h;
    }

    // Setter for h.
    //
    
    WithErrorSyntaxHandleInResultResponse& h(::zx::handle value) {
      storage_.h = std::move(value);
      return *this;
    }

  WithErrorSyntaxHandleInResultResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithErrorSyntaxHandleInResultResponse(Storage_{
      .h ={},
  }) {}

 private:
  struct Storage_ final {
      ::zx::handle h;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxHandleInResultResponse, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithErrorSyntaxHandleInResultResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::zx::handle, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>>{
        &Storage_::h, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithErrorSyntax_HandleInResult_ResultTable;


class WithErrorSyntaxHandleInResultResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_protocols::WithErrorSyntaxHandleInResultResponse
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  WithErrorSyntaxHandleInResultResult(WithErrorSyntaxHandleInResultResult&& other) noexcept
      : WithErrorSyntaxHandleInResultResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  WithErrorSyntaxHandleInResultResult& operator=(WithErrorSyntaxHandleInResultResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }

  constexpr ::test_protocols::WithErrorSyntaxHandleInResultResult::Tag Which() const {
    return WithErrorSyntaxHandleInResultResult::IndexToTag(storage_->index()).value();
  }
    static WithErrorSyntaxHandleInResultResult WithResponse(::test_protocols::WithErrorSyntaxHandleInResultResponse val) {
      return WithErrorSyntaxHandleInResultResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    WithErrorSyntaxHandleInResultResult& response(::test_protocols::WithErrorSyntaxHandleInResultResponse value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static WithErrorSyntaxHandleInResultResult WithErr(uint32_t val) {
      return WithErrorSyntaxHandleInResultResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    WithErrorSyntaxHandleInResultResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  WithErrorSyntaxHandleInResultResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocols::WithErrorSyntaxHandleInResultResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit WithErrorSyntaxHandleInResultResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocols::WithErrorSyntaxHandleInResultResult::Tag tag) {
    switch (tag) {
        case ::test_protocols::WithErrorSyntaxHandleInResultResult::Tag::kResponse: return 1;
        case ::test_protocols::WithErrorSyntaxHandleInResultResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocols::WithErrorSyntaxHandleInResultResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocols::WithErrorSyntaxHandleInResultResult::Tag::kResponse;
        case 2: return ::test_protocols::WithErrorSyntaxHandleInResultResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};



#endif  // __Fuchsia__

  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;


class WithErrorSyntaxHandleInResultTopResponse {
 private:
  struct Storage_;
 public:
  WithErrorSyntaxHandleInResultTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithErrorSyntaxHandleInResultTopResponse(::test_protocols::WithErrorSyntaxHandleInResultResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithErrorSyntaxHandleInResultTopResponse| only if all of its members are default constructible.
  WithErrorSyntaxHandleInResultTopResponse() = default;
#pragma clang diagnostic pop

  WithErrorSyntaxHandleInResultTopResponse(WithErrorSyntaxHandleInResultTopResponse&&) noexcept = default;
  WithErrorSyntaxHandleInResultTopResponse& operator=(WithErrorSyntaxHandleInResultTopResponse&&) noexcept = default;
    
      const ::test_protocols::WithErrorSyntaxHandleInResultResult &
    result() const {
      return storage_.result;
    }

    
    ::test_protocols::WithErrorSyntaxHandleInResultResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    WithErrorSyntaxHandleInResultTopResponse& result(::test_protocols::WithErrorSyntaxHandleInResultResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  WithErrorSyntaxHandleInResultTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithErrorSyntaxHandleInResultTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}

 private:
  struct Storage_ final {
      ::test_protocols::WithErrorSyntaxHandleInResultResult result;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxHandleInResultTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithErrorSyntaxHandleInResultTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocols::WithErrorSyntaxHandleInResultResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  
  
  
  



extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;


class ChannelProtocolMethodARequest {
 private:
  struct Storage_;
 public:
  ChannelProtocolMethodARequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ChannelProtocolMethodARequest(int64_t a, int64_t b) noexcept
    : storage_({
      .a = std::move(a), 
      .b = std::move(b)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ChannelProtocolMethodARequest| only if all of its members are default constructible.
  ChannelProtocolMethodARequest() = default;
#pragma clang diagnostic pop

  ChannelProtocolMethodARequest(ChannelProtocolMethodARequest&&) noexcept = default;
  ChannelProtocolMethodARequest& operator=(ChannelProtocolMethodARequest&&) noexcept = default;
    ChannelProtocolMethodARequest(const ChannelProtocolMethodARequest& other) noexcept : ChannelProtocolMethodARequest(other.CloneStorage_()){}
    ChannelProtocolMethodARequest& operator=(const ChannelProtocolMethodARequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const ChannelProtocolMethodARequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMethodARequest, 16>::Equal(this, &other);
    }
    bool operator!=(const ChannelProtocolMethodARequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMethodARequest, 16>::Equal(this, &other);
    }
    
      int64_t
    a() const {
      return storage_.a;
    }

    
    int64_t& a() {
      return storage_.a;
    }

    // Setter for a.
    //
    
    ChannelProtocolMethodARequest& a(int64_t value) {
      storage_.a = std::move(value);
      return *this;
    }
    
      int64_t
    b() const {
      return storage_.b;
    }

    
    int64_t& b() {
      return storage_.b;
    }

    // Setter for b.
    //
    
    ChannelProtocolMethodARequest& b(int64_t value) {
      storage_.b = std::move(value);
      return *this;
    }

  ChannelProtocolMethodARequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ChannelProtocolMethodARequest(Storage_{
      .a ={},
      .b ={},
  }) {}

 private:
  struct Storage_ final {
      int64_t a
        = {};
      int64_t b
        = {};
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMethodARequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::ChannelProtocolMethodARequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::a, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::b, 8
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;


class ChannelProtocolEventARequest {
 private:
  struct Storage_;
 public:
  ChannelProtocolEventARequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ChannelProtocolEventARequest(int64_t a, int64_t b) noexcept
    : storage_({
      .a = std::move(a), 
      .b = std::move(b)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ChannelProtocolEventARequest| only if all of its members are default constructible.
  ChannelProtocolEventARequest() = default;
#pragma clang diagnostic pop

  ChannelProtocolEventARequest(ChannelProtocolEventARequest&&) noexcept = default;
  ChannelProtocolEventARequest& operator=(ChannelProtocolEventARequest&&) noexcept = default;
    ChannelProtocolEventARequest(const ChannelProtocolEventARequest& other) noexcept : ChannelProtocolEventARequest(other.CloneStorage_()){}
    ChannelProtocolEventARequest& operator=(const ChannelProtocolEventARequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const ChannelProtocolEventARequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolEventARequest, 16>::Equal(this, &other);
    }
    bool operator!=(const ChannelProtocolEventARequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolEventARequest, 16>::Equal(this, &other);
    }
    
      int64_t
    a() const {
      return storage_.a;
    }

    
    int64_t& a() {
      return storage_.a;
    }

    // Setter for a.
    //
    
    ChannelProtocolEventARequest& a(int64_t value) {
      storage_.a = std::move(value);
      return *this;
    }
    
      int64_t
    b() const {
      return storage_.b;
    }

    
    int64_t& b() {
      return storage_.b;
    }

    // Setter for b.
    //
    
    ChannelProtocolEventARequest& b(int64_t value) {
      storage_.b = std::move(value);
      return *this;
    }

  ChannelProtocolEventARequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ChannelProtocolEventARequest(Storage_{
      .a ={},
      .b ={},
  }) {}

 private:
  struct Storage_ final {
      int64_t a
        = {};
      int64_t b
        = {};
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolEventARequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::ChannelProtocolEventARequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::a, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::b, 8
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;


class ChannelProtocolMethodBRequest {
 private:
  struct Storage_;
 public:
  ChannelProtocolMethodBRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ChannelProtocolMethodBRequest(int64_t a, int64_t b) noexcept
    : storage_({
      .a = std::move(a), 
      .b = std::move(b)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ChannelProtocolMethodBRequest| only if all of its members are default constructible.
  ChannelProtocolMethodBRequest() = default;
#pragma clang diagnostic pop

  ChannelProtocolMethodBRequest(ChannelProtocolMethodBRequest&&) noexcept = default;
  ChannelProtocolMethodBRequest& operator=(ChannelProtocolMethodBRequest&&) noexcept = default;
    ChannelProtocolMethodBRequest(const ChannelProtocolMethodBRequest& other) noexcept : ChannelProtocolMethodBRequest(other.CloneStorage_()){}
    ChannelProtocolMethodBRequest& operator=(const ChannelProtocolMethodBRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const ChannelProtocolMethodBRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMethodBRequest, 16>::Equal(this, &other);
    }
    bool operator!=(const ChannelProtocolMethodBRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMethodBRequest, 16>::Equal(this, &other);
    }
    
      int64_t
    a() const {
      return storage_.a;
    }

    
    int64_t& a() {
      return storage_.a;
    }

    // Setter for a.
    //
    
    ChannelProtocolMethodBRequest& a(int64_t value) {
      storage_.a = std::move(value);
      return *this;
    }
    
      int64_t
    b() const {
      return storage_.b;
    }

    
    int64_t& b() {
      return storage_.b;
    }

    // Setter for b.
    //
    
    ChannelProtocolMethodBRequest& b(int64_t value) {
      storage_.b = std::move(value);
      return *this;
    }

  ChannelProtocolMethodBRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ChannelProtocolMethodBRequest(Storage_{
      .a ={},
      .b ={},
  }) {}

 private:
  struct Storage_ final {
      int64_t a
        = {};
      int64_t b
        = {};
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMethodBRequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::ChannelProtocolMethodBRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::a, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::b, 8
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBResponseTable;


class ChannelProtocolMethodBResponse {
 private:
  struct Storage_;
 public:
  ChannelProtocolMethodBResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ChannelProtocolMethodBResponse(int64_t result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ChannelProtocolMethodBResponse| only if all of its members are default constructible.
  ChannelProtocolMethodBResponse() = default;
#pragma clang diagnostic pop

  ChannelProtocolMethodBResponse(ChannelProtocolMethodBResponse&&) noexcept = default;
  ChannelProtocolMethodBResponse& operator=(ChannelProtocolMethodBResponse&&) noexcept = default;
    ChannelProtocolMethodBResponse(const ChannelProtocolMethodBResponse& other) noexcept : ChannelProtocolMethodBResponse(other.CloneStorage_()){}
    ChannelProtocolMethodBResponse& operator=(const ChannelProtocolMethodBResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const ChannelProtocolMethodBResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMethodBResponse, 8>::Equal(this, &other);
    }
    bool operator!=(const ChannelProtocolMethodBResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMethodBResponse, 8>::Equal(this, &other);
    }
    
      int64_t
    result() const {
      return storage_.result;
    }

    
    int64_t& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ChannelProtocolMethodBResponse& result(int64_t value) {
      storage_.result = std::move(value);
      return *this;
    }

  ChannelProtocolMethodBResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ChannelProtocolMethodBResponse(Storage_{
      .result ={},
  }) {}

 private:
  struct Storage_ final {
      int64_t result
        = {};
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMethodBResponse, 8>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::ChannelProtocolMethodBResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_ChannelProtocolTakeHandleRequestTable;


class ChannelProtocolTakeHandleRequest {
 private:
  struct Storage_;
 public:
  ChannelProtocolTakeHandleRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ChannelProtocolTakeHandleRequest(::zx::handle h) noexcept
    : storage_({
      .h = std::move(h)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ChannelProtocolTakeHandleRequest| only if all of its members are default constructible.
  ChannelProtocolTakeHandleRequest() = default;
#pragma clang diagnostic pop

  ChannelProtocolTakeHandleRequest(ChannelProtocolTakeHandleRequest&&) noexcept = default;
  ChannelProtocolTakeHandleRequest& operator=(ChannelProtocolTakeHandleRequest&&) noexcept = default;
    
      const ::zx::handle &
    h() const {
      return storage_.h;
    }

    
    ::zx::handle& h() {
      return storage_.h;
    }

    // Setter for h.
    //
    
    ChannelProtocolTakeHandleRequest& h(::zx::handle value) {
      storage_.h = std::move(value);
      return *this;
    }

  ChannelProtocolTakeHandleRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ChannelProtocolTakeHandleRequest(Storage_{
      .h ={},
  }) {}

 private:
  struct Storage_ final {
      ::zx::handle h;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolTakeHandleRequest, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::ChannelProtocolTakeHandleRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::zx::handle, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>>{
        &Storage_::h, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketRequestTable;


class ChannelProtocolMutateSocketRequest {
 private:
  struct Storage_;
 public:
  ChannelProtocolMutateSocketRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ChannelProtocolMutateSocketRequest(::zx::socket a) noexcept
    : storage_({
      .a = std::move(a)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ChannelProtocolMutateSocketRequest| only if all of its members are default constructible.
  ChannelProtocolMutateSocketRequest() = default;
#pragma clang diagnostic pop

  ChannelProtocolMutateSocketRequest(ChannelProtocolMutateSocketRequest&&) noexcept = default;
  ChannelProtocolMutateSocketRequest& operator=(ChannelProtocolMutateSocketRequest&&) noexcept = default;
    
      const ::zx::socket &
    a() const {
      return storage_.a;
    }

    
    ::zx::socket& a() {
      return storage_.a;
    }

    // Setter for a.
    //
    
    ChannelProtocolMutateSocketRequest& a(::zx::socket value) {
      storage_.a = std::move(value);
      return *this;
    }

  ChannelProtocolMutateSocketRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ChannelProtocolMutateSocketRequest(Storage_{
      .a ={},
  }) {}

 private:
  struct Storage_ final {
      ::zx::socket a;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMutateSocketRequest, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::ChannelProtocolMutateSocketRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::zx::socket, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x80000000, false>>{
        &Storage_::a, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketResponseTable;


class ChannelProtocolMutateSocketResponse {
 private:
  struct Storage_;
 public:
  ChannelProtocolMutateSocketResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ChannelProtocolMutateSocketResponse(::zx::socket b) noexcept
    : storage_({
      .b = std::move(b)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ChannelProtocolMutateSocketResponse| only if all of its members are default constructible.
  ChannelProtocolMutateSocketResponse() = default;
#pragma clang diagnostic pop

  ChannelProtocolMutateSocketResponse(ChannelProtocolMutateSocketResponse&&) noexcept = default;
  ChannelProtocolMutateSocketResponse& operator=(ChannelProtocolMutateSocketResponse&&) noexcept = default;
    
      const ::zx::socket &
    b() const {
      return storage_.b;
    }

    
    ::zx::socket& b() {
      return storage_.b;
    }

    // Setter for b.
    //
    
    ChannelProtocolMutateSocketResponse& b(::zx::socket value) {
      storage_.b = std::move(value);
      return *this;
    }

  ChannelProtocolMutateSocketResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ChannelProtocolMutateSocketResponse(Storage_{
      .b ={},
  }) {}

 private:
  struct Storage_ final {
      ::zx::socket b;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMutateSocketResponse, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::ChannelProtocolMutateSocketResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::zx::socket, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x80000000, false>>{
        &Storage_::b, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  
  
  
  



extern "C" const fidl_type_t test_protocols_SyscallProtocolMethodCRequestTable;


class SyscallProtocolMethodCRequest {
 private:
  struct Storage_;
 public:
  SyscallProtocolMethodCRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    SyscallProtocolMethodCRequest(int64_t a, int64_t b) noexcept
    : storage_({
      .a = std::move(a), 
      .b = std::move(b)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |SyscallProtocolMethodCRequest| only if all of its members are default constructible.
  SyscallProtocolMethodCRequest() = default;
#pragma clang diagnostic pop

  SyscallProtocolMethodCRequest(SyscallProtocolMethodCRequest&&) noexcept = default;
  SyscallProtocolMethodCRequest& operator=(SyscallProtocolMethodCRequest&&) noexcept = default;
    SyscallProtocolMethodCRequest(const SyscallProtocolMethodCRequest& other) noexcept : SyscallProtocolMethodCRequest(other.CloneStorage_()){}
    SyscallProtocolMethodCRequest& operator=(const SyscallProtocolMethodCRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const SyscallProtocolMethodCRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::SyscallProtocolMethodCRequest, 16>::Equal(this, &other);
    }
    bool operator!=(const SyscallProtocolMethodCRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::SyscallProtocolMethodCRequest, 16>::Equal(this, &other);
    }
    
      int64_t
    a() const {
      return storage_.a;
    }

    
    int64_t& a() {
      return storage_.a;
    }

    // Setter for a.
    //
    
    SyscallProtocolMethodCRequest& a(int64_t value) {
      storage_.a = std::move(value);
      return *this;
    }
    
      int64_t
    b() const {
      return storage_.b;
    }

    
    int64_t& b() {
      return storage_.b;
    }

    // Setter for b.
    //
    
    SyscallProtocolMethodCRequest& b(int64_t value) {
      storage_.b = std::move(value);
      return *this;
    }

  SyscallProtocolMethodCRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : SyscallProtocolMethodCRequest(Storage_{
      .a ={},
      .b ={},
  }) {}

 private:
  struct Storage_ final {
      int64_t a
        = {};
      int64_t b
        = {};
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::SyscallProtocolMethodCRequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::SyscallProtocolMethodCRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::a, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::b, 8
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;


class TransitionalRequestRequest {
 private:
  struct Storage_;
 public:
  TransitionalRequestRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    TransitionalRequestRequest(int64_t x) noexcept
    : storage_({
      .x = std::move(x)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |TransitionalRequestRequest| only if all of its members are default constructible.
  TransitionalRequestRequest() = default;
#pragma clang diagnostic pop

  TransitionalRequestRequest(TransitionalRequestRequest&&) noexcept = default;
  TransitionalRequestRequest& operator=(TransitionalRequestRequest&&) noexcept = default;
    TransitionalRequestRequest(const TransitionalRequestRequest& other) noexcept : TransitionalRequestRequest(other.CloneStorage_()){}
    TransitionalRequestRequest& operator=(const TransitionalRequestRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const TransitionalRequestRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalRequestRequest, 8>::Equal(this, &other);
    }
    bool operator!=(const TransitionalRequestRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalRequestRequest, 8>::Equal(this, &other);
    }
    
      int64_t
    x() const {
      return storage_.x;
    }

    
    int64_t& x() {
      return storage_.x;
    }

    // Setter for x.
    //
    
    TransitionalRequestRequest& x(int64_t value) {
      storage_.x = std::move(value);
      return *this;
    }

  TransitionalRequestRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : TransitionalRequestRequest(Storage_{
      .x ={},
  }) {}

 private:
  struct Storage_ final {
      int64_t x
        = {};
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalRequestRequest, 8>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::TransitionalRequestRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::x, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_TransitionalRequestResponseTable;


class TransitionalRequestResponse {
 private:
  struct Storage_;
 public:
  TransitionalRequestResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    TransitionalRequestResponse(int64_t y) noexcept
    : storage_({
      .y = std::move(y)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |TransitionalRequestResponse| only if all of its members are default constructible.
  TransitionalRequestResponse() = default;
#pragma clang diagnostic pop

  TransitionalRequestResponse(TransitionalRequestResponse&&) noexcept = default;
  TransitionalRequestResponse& operator=(TransitionalRequestResponse&&) noexcept = default;
    TransitionalRequestResponse(const TransitionalRequestResponse& other) noexcept : TransitionalRequestResponse(other.CloneStorage_()){}
    TransitionalRequestResponse& operator=(const TransitionalRequestResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const TransitionalRequestResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalRequestResponse, 8>::Equal(this, &other);
    }
    bool operator!=(const TransitionalRequestResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalRequestResponse, 8>::Equal(this, &other);
    }
    
      int64_t
    y() const {
      return storage_.y;
    }

    
    int64_t& y() {
      return storage_.y;
    }

    // Setter for y.
    //
    
    TransitionalRequestResponse& y(int64_t value) {
      storage_.y = std::move(value);
      return *this;
    }

  TransitionalRequestResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : TransitionalRequestResponse(Storage_{
      .y ={},
  }) {}

 private:
  struct Storage_ final {
      int64_t y
        = {};
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalRequestResponse, 8>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::TransitionalRequestResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::y, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;


class TransitionalOneWayRequest {
 private:
  struct Storage_;
 public:
  TransitionalOneWayRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    TransitionalOneWayRequest(int64_t x) noexcept
    : storage_({
      .x = std::move(x)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |TransitionalOneWayRequest| only if all of its members are default constructible.
  TransitionalOneWayRequest() = default;
#pragma clang diagnostic pop

  TransitionalOneWayRequest(TransitionalOneWayRequest&&) noexcept = default;
  TransitionalOneWayRequest& operator=(TransitionalOneWayRequest&&) noexcept = default;
    TransitionalOneWayRequest(const TransitionalOneWayRequest& other) noexcept : TransitionalOneWayRequest(other.CloneStorage_()){}
    TransitionalOneWayRequest& operator=(const TransitionalOneWayRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const TransitionalOneWayRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalOneWayRequest, 8>::Equal(this, &other);
    }
    bool operator!=(const TransitionalOneWayRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalOneWayRequest, 8>::Equal(this, &other);
    }
    
      int64_t
    x() const {
      return storage_.x;
    }

    
    int64_t& x() {
      return storage_.x;
    }

    // Setter for x.
    //
    
    TransitionalOneWayRequest& x(int64_t value) {
      storage_.x = std::move(value);
      return *this;
    }

  TransitionalOneWayRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : TransitionalOneWayRequest(Storage_{
      .x ={},
  }) {}

 private:
  struct Storage_ final {
      int64_t x
        = {};
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalOneWayRequest, 8>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::TransitionalOneWayRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::x, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;


class TransitionalEventRequest {
 private:
  struct Storage_;
 public:
  TransitionalEventRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    TransitionalEventRequest(int64_t x) noexcept
    : storage_({
      .x = std::move(x)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |TransitionalEventRequest| only if all of its members are default constructible.
  TransitionalEventRequest() = default;
#pragma clang diagnostic pop

  TransitionalEventRequest(TransitionalEventRequest&&) noexcept = default;
  TransitionalEventRequest& operator=(TransitionalEventRequest&&) noexcept = default;
    TransitionalEventRequest(const TransitionalEventRequest& other) noexcept : TransitionalEventRequest(other.CloneStorage_()){}
    TransitionalEventRequest& operator=(const TransitionalEventRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const TransitionalEventRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalEventRequest, 8>::Equal(this, &other);
    }
    bool operator!=(const TransitionalEventRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalEventRequest, 8>::Equal(this, &other);
    }
    
      int64_t
    x() const {
      return storage_.x;
    }

    
    int64_t& x() {
      return storage_.x;
    }

    // Setter for x.
    //
    
    TransitionalEventRequest& x(int64_t value) {
      storage_.x = std::move(value);
      return *this;
    }

  TransitionalEventRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : TransitionalEventRequest(Storage_{
      .x ={},
  }) {}

 private:
  struct Storage_ final {
      int64_t x
        = {};
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalEventRequest, 8>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::TransitionalEventRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::x, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  
  
  
  
  
  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;


class HandleRightsProtocolNoResponseMethodRequest {
 private:
  struct Storage_;
 public:
  HandleRightsProtocolNoResponseMethodRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    HandleRightsProtocolNoResponseMethodRequest(::zx::socket h) noexcept
    : storage_({
      .h = std::move(h)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |HandleRightsProtocolNoResponseMethodRequest| only if all of its members are default constructible.
  HandleRightsProtocolNoResponseMethodRequest() = default;
#pragma clang diagnostic pop

  HandleRightsProtocolNoResponseMethodRequest(HandleRightsProtocolNoResponseMethodRequest&&) noexcept = default;
  HandleRightsProtocolNoResponseMethodRequest& operator=(HandleRightsProtocolNoResponseMethodRequest&&) noexcept = default;
    
      const ::zx::socket &
    h() const {
      return storage_.h;
    }

    
    ::zx::socket& h() {
      return storage_.h;
    }

    // Setter for h.
    //
    
    HandleRightsProtocolNoResponseMethodRequest& h(::zx::socket value) {
      storage_.h = std::move(value);
      return *this;
    }

  HandleRightsProtocolNoResponseMethodRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : HandleRightsProtocolNoResponseMethodRequest(Storage_{
      .h ={},
  }) {}

 private:
  struct Storage_ final {
      ::zx::socket h;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::HandleRightsProtocolNoResponseMethodRequest, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::HandleRightsProtocolNoResponseMethodRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::zx::socket, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>>{
        &Storage_::h, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodRequestTable;


class HandleRightsProtocolResponseMethodRequest {
 private:
  struct Storage_;
 public:
  HandleRightsProtocolResponseMethodRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    HandleRightsProtocolResponseMethodRequest(::zx::socket h) noexcept
    : storage_({
      .h = std::move(h)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |HandleRightsProtocolResponseMethodRequest| only if all of its members are default constructible.
  HandleRightsProtocolResponseMethodRequest() = default;
#pragma clang diagnostic pop

  HandleRightsProtocolResponseMethodRequest(HandleRightsProtocolResponseMethodRequest&&) noexcept = default;
  HandleRightsProtocolResponseMethodRequest& operator=(HandleRightsProtocolResponseMethodRequest&&) noexcept = default;
    
      const ::zx::socket &
    h() const {
      return storage_.h;
    }

    
    ::zx::socket& h() {
      return storage_.h;
    }

    // Setter for h.
    //
    
    HandleRightsProtocolResponseMethodRequest& h(::zx::socket value) {
      storage_.h = std::move(value);
      return *this;
    }

  HandleRightsProtocolResponseMethodRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : HandleRightsProtocolResponseMethodRequest(Storage_{
      .h ={},
  }) {}

 private:
  struct Storage_ final {
      ::zx::socket h;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::HandleRightsProtocolResponseMethodRequest, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::HandleRightsProtocolResponseMethodRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::zx::socket, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>>{
        &Storage_::h, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodResponseTable;


class HandleRightsProtocolResponseMethodResponse {
 private:
  struct Storage_;
 public:
  HandleRightsProtocolResponseMethodResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    HandleRightsProtocolResponseMethodResponse(::zx::socket h) noexcept
    : storage_({
      .h = std::move(h)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |HandleRightsProtocolResponseMethodResponse| only if all of its members are default constructible.
  HandleRightsProtocolResponseMethodResponse() = default;
#pragma clang diagnostic pop

  HandleRightsProtocolResponseMethodResponse(HandleRightsProtocolResponseMethodResponse&&) noexcept = default;
  HandleRightsProtocolResponseMethodResponse& operator=(HandleRightsProtocolResponseMethodResponse&&) noexcept = default;
    
      const ::zx::socket &
    h() const {
      return storage_.h;
    }

    
    ::zx::socket& h() {
      return storage_.h;
    }

    // Setter for h.
    //
    
    HandleRightsProtocolResponseMethodResponse& h(::zx::socket value) {
      storage_.h = std::move(value);
      return *this;
    }

  HandleRightsProtocolResponseMethodResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : HandleRightsProtocolResponseMethodResponse(Storage_{
      .h ={},
  }) {}

 private:
  struct Storage_ final {
      ::zx::socket h;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::HandleRightsProtocolResponseMethodResponse, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::HandleRightsProtocolResponseMethodResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::zx::socket, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x2, false>>{
        &Storage_::h, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_HandleRightsProtocolAnEventRequestTable;


class HandleRightsProtocolAnEventRequest {
 private:
  struct Storage_;
 public:
  HandleRightsProtocolAnEventRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    HandleRightsProtocolAnEventRequest(::zx::socket h) noexcept
    : storage_({
      .h = std::move(h)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |HandleRightsProtocolAnEventRequest| only if all of its members are default constructible.
  HandleRightsProtocolAnEventRequest() = default;
#pragma clang diagnostic pop

  HandleRightsProtocolAnEventRequest(HandleRightsProtocolAnEventRequest&&) noexcept = default;
  HandleRightsProtocolAnEventRequest& operator=(HandleRightsProtocolAnEventRequest&&) noexcept = default;
    
      const ::zx::socket &
    h() const {
      return storage_.h;
    }

    
    ::zx::socket& h() {
      return storage_.h;
    }

    // Setter for h.
    //
    
    HandleRightsProtocolAnEventRequest& h(::zx::socket value) {
      storage_.h = std::move(value);
      return *this;
    }

  HandleRightsProtocolAnEventRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : HandleRightsProtocolAnEventRequest(Storage_{
      .h ={},
  }) {}

 private:
  struct Storage_ final {
      ::zx::socket h;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::HandleRightsProtocolAnEventRequest, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::HandleRightsProtocolAnEventRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::zx::socket, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>>{
        &Storage_::h, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  
  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_ProtocolEndsTable;


class ProtocolEnds {
 private:
  struct Storage_;
 public:
  ProtocolEnds(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ProtocolEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client, ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server, ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client_opt, ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server_opt) noexcept
    : storage_({
      .client = std::move(client), 
      .server = std::move(server), 
      .client_opt = std::move(client_opt), 
      .server_opt = std::move(server_opt)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ProtocolEnds| only if all of its members are default constructible.
  ProtocolEnds() = default;
#pragma clang diagnostic pop

  ProtocolEnds(ProtocolEnds&&) noexcept = default;
  ProtocolEnds& operator=(ProtocolEnds&&) noexcept = default;
    
      const ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> &
    client() const {
      return storage_.client;
    }

    
    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& client() {
      return storage_.client;
    }

    // Setter for client.
    //
    
    ProtocolEnds& client(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> value) {
      storage_.client = std::move(value);
      return *this;
    }
    
      const ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> &
    server() const {
      return storage_.server;
    }

    
    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& server() {
      return storage_.server;
    }

    // Setter for server.
    //
    
    ProtocolEnds& server(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> value) {
      storage_.server = std::move(value);
      return *this;
    }
    
      const ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> &
    client_opt() const {
      return storage_.client_opt;
    }

    
    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& client_opt() {
      return storage_.client_opt;
    }

    // Setter for client_opt.
    //
    
    ProtocolEnds& client_opt(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> value) {
      storage_.client_opt = std::move(value);
      return *this;
    }
    
      const ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> &
    server_opt() const {
      return storage_.server_opt;
    }

    
    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& server_opt() {
      return storage_.server_opt;
    }

    // Setter for server_opt.
    //
    
    ProtocolEnds& server_opt(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> value) {
      storage_.server_opt = std::move(value);
      return *this;
    }

  ProtocolEnds(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ProtocolEnds(Storage_{
      .client ={},
      .server ={},
      .client_opt ={},
      .server_opt ={},
  }) {}

 private:
  struct Storage_ final {
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client;
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server;
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client_opt;
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server_opt;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ProtocolEnds, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::ProtocolEnds>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
        &Storage_::client, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
        &Storage_::server, 4
      }, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>>{
        &Storage_::client_opt, 8
      }, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>>{
        &Storage_::server_opt, 12
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsRequestTable;


class WithProtocolEndsClientEndsRequest {
 private:
  struct Storage_;
 public:
  WithProtocolEndsClientEndsRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithProtocolEndsClientEndsRequest(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> in) noexcept
    : storage_({
      .in = std::move(in)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithProtocolEndsClientEndsRequest| only if all of its members are default constructible.
  WithProtocolEndsClientEndsRequest() = default;
#pragma clang diagnostic pop

  WithProtocolEndsClientEndsRequest(WithProtocolEndsClientEndsRequest&&) noexcept = default;
  WithProtocolEndsClientEndsRequest& operator=(WithProtocolEndsClientEndsRequest&&) noexcept = default;
    
      const ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> &
    in() const {
      return storage_.in;
    }

    
    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& in() {
      return storage_.in;
    }

    // Setter for in.
    //
    
    WithProtocolEndsClientEndsRequest& in(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> value) {
      storage_.in = std::move(value);
      return *this;
    }

  WithProtocolEndsClientEndsRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithProtocolEndsClientEndsRequest(Storage_{
      .in ={},
  }) {}

 private:
  struct Storage_ final {
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> in;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithProtocolEndsClientEndsRequest, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithProtocolEndsClientEndsRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
        &Storage_::in, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsResponseTable;


class WithProtocolEndsClientEndsResponse {
 private:
  struct Storage_;
 public:
  WithProtocolEndsClientEndsResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithProtocolEndsClientEndsResponse(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> out) noexcept
    : storage_({
      .out = std::move(out)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithProtocolEndsClientEndsResponse| only if all of its members are default constructible.
  WithProtocolEndsClientEndsResponse() = default;
#pragma clang diagnostic pop

  WithProtocolEndsClientEndsResponse(WithProtocolEndsClientEndsResponse&&) noexcept = default;
  WithProtocolEndsClientEndsResponse& operator=(WithProtocolEndsClientEndsResponse&&) noexcept = default;
    
      const ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> &
    out() const {
      return storage_.out;
    }

    
    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& out() {
      return storage_.out;
    }

    // Setter for out.
    //
    
    WithProtocolEndsClientEndsResponse& out(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> value) {
      storage_.out = std::move(value);
      return *this;
    }

  WithProtocolEndsClientEndsResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithProtocolEndsClientEndsResponse(Storage_{
      .out ={},
  }) {}

 private:
  struct Storage_ final {
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> out;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithProtocolEndsClientEndsResponse, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithProtocolEndsClientEndsResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>>{
        &Storage_::out, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsRequestTable;


class WithProtocolEndsServerEndsRequest {
 private:
  struct Storage_;
 public:
  WithProtocolEndsServerEndsRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithProtocolEndsServerEndsRequest(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> in) noexcept
    : storage_({
      .in = std::move(in)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithProtocolEndsServerEndsRequest| only if all of its members are default constructible.
  WithProtocolEndsServerEndsRequest() = default;
#pragma clang diagnostic pop

  WithProtocolEndsServerEndsRequest(WithProtocolEndsServerEndsRequest&&) noexcept = default;
  WithProtocolEndsServerEndsRequest& operator=(WithProtocolEndsServerEndsRequest&&) noexcept = default;
    
      const ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> &
    in() const {
      return storage_.in;
    }

    
    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& in() {
      return storage_.in;
    }

    // Setter for in.
    //
    
    WithProtocolEndsServerEndsRequest& in(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> value) {
      storage_.in = std::move(value);
      return *this;
    }

  WithProtocolEndsServerEndsRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithProtocolEndsServerEndsRequest(Storage_{
      .in ={},
  }) {}

 private:
  struct Storage_ final {
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> in;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithProtocolEndsServerEndsRequest, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithProtocolEndsServerEndsRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>>{
        &Storage_::in, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsResponseTable;


class WithProtocolEndsServerEndsResponse {
 private:
  struct Storage_;
 public:
  WithProtocolEndsServerEndsResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithProtocolEndsServerEndsResponse(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> out) noexcept
    : storage_({
      .out = std::move(out)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithProtocolEndsServerEndsResponse| only if all of its members are default constructible.
  WithProtocolEndsServerEndsResponse() = default;
#pragma clang diagnostic pop

  WithProtocolEndsServerEndsResponse(WithProtocolEndsServerEndsResponse&&) noexcept = default;
  WithProtocolEndsServerEndsResponse& operator=(WithProtocolEndsServerEndsResponse&&) noexcept = default;
    
      const ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> &
    out() const {
      return storage_.out;
    }

    
    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& out() {
      return storage_.out;
    }

    // Setter for out.
    //
    
    WithProtocolEndsServerEndsResponse& out(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> value) {
      storage_.out = std::move(value);
      return *this;
    }

  WithProtocolEndsServerEndsResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithProtocolEndsServerEndsResponse(Storage_{
      .out ={},
  }) {}

 private:
  struct Storage_ final {
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> out;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithProtocolEndsServerEndsResponse, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithProtocolEndsServerEndsResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
        &Storage_::out, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsRequestTable;


class WithProtocolEndsStructContainingEndsRequest {
 private:
  struct Storage_;
 public:
  WithProtocolEndsStructContainingEndsRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithProtocolEndsStructContainingEndsRequest(::test_protocols::ProtocolEnds in) noexcept
    : storage_({
      .in = std::move(in)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithProtocolEndsStructContainingEndsRequest| only if all of its members are default constructible.
  WithProtocolEndsStructContainingEndsRequest() = default;
#pragma clang diagnostic pop

  WithProtocolEndsStructContainingEndsRequest(WithProtocolEndsStructContainingEndsRequest&&) noexcept = default;
  WithProtocolEndsStructContainingEndsRequest& operator=(WithProtocolEndsStructContainingEndsRequest&&) noexcept = default;
    
      const ::test_protocols::ProtocolEnds &
    in() const {
      return storage_.in;
    }

    
    ::test_protocols::ProtocolEnds& in() {
      return storage_.in;
    }

    // Setter for in.
    //
    
    WithProtocolEndsStructContainingEndsRequest& in(::test_protocols::ProtocolEnds value) {
      storage_.in = std::move(value);
      return *this;
    }

  WithProtocolEndsStructContainingEndsRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithProtocolEndsStructContainingEndsRequest(Storage_{
      .in =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}

 private:
  struct Storage_ final {
      ::test_protocols::ProtocolEnds in;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithProtocolEndsStructContainingEndsRequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithProtocolEndsStructContainingEndsRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocols::ProtocolEnds, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::in, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsResponseTable;


class WithProtocolEndsStructContainingEndsResponse {
 private:
  struct Storage_;
 public:
  WithProtocolEndsStructContainingEndsResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    WithProtocolEndsStructContainingEndsResponse(::test_protocols::ProtocolEnds out) noexcept
    : storage_({
      .out = std::move(out)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |WithProtocolEndsStructContainingEndsResponse| only if all of its members are default constructible.
  WithProtocolEndsStructContainingEndsResponse() = default;
#pragma clang diagnostic pop

  WithProtocolEndsStructContainingEndsResponse(WithProtocolEndsStructContainingEndsResponse&&) noexcept = default;
  WithProtocolEndsStructContainingEndsResponse& operator=(WithProtocolEndsStructContainingEndsResponse&&) noexcept = default;
    
      const ::test_protocols::ProtocolEnds &
    out() const {
      return storage_.out;
    }

    
    ::test_protocols::ProtocolEnds& out() {
      return storage_.out;
    }

    // Setter for out.
    //
    
    WithProtocolEndsStructContainingEndsResponse& out(::test_protocols::ProtocolEnds value) {
      storage_.out = std::move(value);
      return *this;
    }

  WithProtocolEndsStructContainingEndsResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : WithProtocolEndsStructContainingEndsResponse(Storage_{
      .out =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}

 private:
  struct Storage_ final {
      ::test_protocols::ProtocolEnds out;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithProtocolEndsStructContainingEndsResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::WithProtocolEndsStructContainingEndsResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocols::ProtocolEnds, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::out, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  
  
  
  



extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;


class ManyParametersFifteenRequest {
 private:
  struct Storage_;
 public:
  ManyParametersFifteenRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ManyParametersFifteenRequest(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) noexcept
    : storage_({
      .p1 = std::move(p1), 
      .p2 = std::move(p2), 
      .p3 = std::move(p3), 
      .p4 = std::move(p4), 
      .p5 = std::move(p5), 
      .p6 = std::move(p6), 
      .p7 = std::move(p7), 
      .p8 = std::move(p8), 
      .p9 = std::move(p9), 
      .p10 = std::move(p10), 
      .p11 = std::move(p11), 
      .p12 = std::move(p12), 
      .p13 = std::move(p13), 
      .p14 = std::move(p14), 
      .p15 = std::move(p15)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ManyParametersFifteenRequest| only if all of its members are default constructible.
  ManyParametersFifteenRequest() = default;
#pragma clang diagnostic pop

  ManyParametersFifteenRequest(ManyParametersFifteenRequest&&) noexcept = default;
  ManyParametersFifteenRequest& operator=(ManyParametersFifteenRequest&&) noexcept = default;
    ManyParametersFifteenRequest(const ManyParametersFifteenRequest& other) noexcept : ManyParametersFifteenRequest(other.CloneStorage_()){}
    ManyParametersFifteenRequest& operator=(const ManyParametersFifteenRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const ManyParametersFifteenRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ManyParametersFifteenRequest, 15>::Equal(this, &other);
    }
    bool operator!=(const ManyParametersFifteenRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::ManyParametersFifteenRequest, 15>::Equal(this, &other);
    }
    
      bool
    p1() const {
      return storage_.p1;
    }

    
    bool& p1() {
      return storage_.p1;
    }

    // Setter for p1.
    //
    
    ManyParametersFifteenRequest& p1(bool value) {
      storage_.p1 = std::move(value);
      return *this;
    }
    
      bool
    p2() const {
      return storage_.p2;
    }

    
    bool& p2() {
      return storage_.p2;
    }

    // Setter for p2.
    //
    
    ManyParametersFifteenRequest& p2(bool value) {
      storage_.p2 = std::move(value);
      return *this;
    }
    
      bool
    p3() const {
      return storage_.p3;
    }

    
    bool& p3() {
      return storage_.p3;
    }

    // Setter for p3.
    //
    
    ManyParametersFifteenRequest& p3(bool value) {
      storage_.p3 = std::move(value);
      return *this;
    }
    
      bool
    p4() const {
      return storage_.p4;
    }

    
    bool& p4() {
      return storage_.p4;
    }

    // Setter for p4.
    //
    
    ManyParametersFifteenRequest& p4(bool value) {
      storage_.p4 = std::move(value);
      return *this;
    }
    
      bool
    p5() const {
      return storage_.p5;
    }

    
    bool& p5() {
      return storage_.p5;
    }

    // Setter for p5.
    //
    
    ManyParametersFifteenRequest& p5(bool value) {
      storage_.p5 = std::move(value);
      return *this;
    }
    
      bool
    p6() const {
      return storage_.p6;
    }

    
    bool& p6() {
      return storage_.p6;
    }

    // Setter for p6.
    //
    
    ManyParametersFifteenRequest& p6(bool value) {
      storage_.p6 = std::move(value);
      return *this;
    }
    
      bool
    p7() const {
      return storage_.p7;
    }

    
    bool& p7() {
      return storage_.p7;
    }

    // Setter for p7.
    //
    
    ManyParametersFifteenRequest& p7(bool value) {
      storage_.p7 = std::move(value);
      return *this;
    }
    
      bool
    p8() const {
      return storage_.p8;
    }

    
    bool& p8() {
      return storage_.p8;
    }

    // Setter for p8.
    //
    
    ManyParametersFifteenRequest& p8(bool value) {
      storage_.p8 = std::move(value);
      return *this;
    }
    
      bool
    p9() const {
      return storage_.p9;
    }

    
    bool& p9() {
      return storage_.p9;
    }

    // Setter for p9.
    //
    
    ManyParametersFifteenRequest& p9(bool value) {
      storage_.p9 = std::move(value);
      return *this;
    }
    
      bool
    p10() const {
      return storage_.p10;
    }

    
    bool& p10() {
      return storage_.p10;
    }

    // Setter for p10.
    //
    
    ManyParametersFifteenRequest& p10(bool value) {
      storage_.p10 = std::move(value);
      return *this;
    }
    
      bool
    p11() const {
      return storage_.p11;
    }

    
    bool& p11() {
      return storage_.p11;
    }

    // Setter for p11.
    //
    
    ManyParametersFifteenRequest& p11(bool value) {
      storage_.p11 = std::move(value);
      return *this;
    }
    
      bool
    p12() const {
      return storage_.p12;
    }

    
    bool& p12() {
      return storage_.p12;
    }

    // Setter for p12.
    //
    
    ManyParametersFifteenRequest& p12(bool value) {
      storage_.p12 = std::move(value);
      return *this;
    }
    
      bool
    p13() const {
      return storage_.p13;
    }

    
    bool& p13() {
      return storage_.p13;
    }

    // Setter for p13.
    //
    
    ManyParametersFifteenRequest& p13(bool value) {
      storage_.p13 = std::move(value);
      return *this;
    }
    
      bool
    p14() const {
      return storage_.p14;
    }

    
    bool& p14() {
      return storage_.p14;
    }

    // Setter for p14.
    //
    
    ManyParametersFifteenRequest& p14(bool value) {
      storage_.p14 = std::move(value);
      return *this;
    }
    
      bool
    p15() const {
      return storage_.p15;
    }

    
    bool& p15() {
      return storage_.p15;
    }

    // Setter for p15.
    //
    
    ManyParametersFifteenRequest& p15(bool value) {
      storage_.p15 = std::move(value);
      return *this;
    }

  ManyParametersFifteenRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ManyParametersFifteenRequest(Storage_{
      .p1 ={},
      .p2 ={},
      .p3 ={},
      .p4 ={},
      .p5 ={},
      .p6 ={},
      .p7 ={},
      .p8 ={},
      .p9 ={},
      .p10 ={},
      .p11 ={},
      .p12 ={},
      .p13 ={},
      .p14 ={},
      .p15 ={},
  }) {}

 private:
  struct Storage_ final {
      bool p1
        = {};
      bool p2
        = {};
      bool p3
        = {};
      bool p4
        = {};
      bool p5
        = {};
      bool p6
        = {};
      bool p7
        = {};
      bool p8
        = {};
      bool p9
        = {};
      bool p10
        = {};
      bool p11
        = {};
      bool p12
        = {};
      bool p13
        = {};
      bool p14
        = {};
      bool p15
        = {};
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ManyParametersFifteenRequest, 15>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::ManyParametersFifteenRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p1, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p2, 1
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p3, 2
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p4, 3
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p5, 4
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p6, 5
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p7, 6
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p8, 7
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p9, 8
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p10, 9
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p11, 10
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p12, 11
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p13, 12
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p14, 13
      }, ::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::p15, 14
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  
  
  
  



extern "C" const fidl_type_t test_protocols_TheUnionTable;


class TheUnion {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kV = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  TheUnion(TheUnion&& other) noexcept
      : TheUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  TheUnion& operator=(TheUnion&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    TheUnion(const TheUnion& other) noexcept : TheUnion(other.CloneStorage_()){}
    TheUnion& operator=(const TheUnion& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const TheUnion& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const TheUnion& other) const noexcept {
      return *storage_ != *other.storage_;
    }
  constexpr bool IsUnknown() const {
    return Which() == ::test_protocols::TheUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  constexpr ::test_protocols::TheUnion::Tag Which() const {
    return TheUnion::IndexToTag(storage_->index()).value();
  }
    static TheUnion WithV(uint32_t val) {
      return TheUnion(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> v() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> v() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the v member.
    //
    
    TheUnion& v(uint32_t value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }

  TheUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocols::TheUnion>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit TheUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocols::TheUnion::Tag tag) {
    switch (tag) {
        case ::test_protocols::TheUnion::Tag::kV: return 1;
      default: {
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocols::TheUnion::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocols::TheUnion::Tag::kV;
        default: return ::test_protocols::TheUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
    }
  }

};


  



extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodRequestTable;


class MethodWithUnionUnionMethodRequest {
 private:
  struct Storage_;
 public:
  MethodWithUnionUnionMethodRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    MethodWithUnionUnionMethodRequest(::test_protocols::TheUnion u) noexcept
    : storage_({
      .u = std::move(u)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |MethodWithUnionUnionMethodRequest| only if all of its members are default constructible.
  MethodWithUnionUnionMethodRequest() = default;
#pragma clang diagnostic pop

  MethodWithUnionUnionMethodRequest(MethodWithUnionUnionMethodRequest&&) noexcept = default;
  MethodWithUnionUnionMethodRequest& operator=(MethodWithUnionUnionMethodRequest&&) noexcept = default;
    MethodWithUnionUnionMethodRequest(const MethodWithUnionUnionMethodRequest& other) noexcept : MethodWithUnionUnionMethodRequest(other.CloneStorage_()){}
    MethodWithUnionUnionMethodRequest& operator=(const MethodWithUnionUnionMethodRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const MethodWithUnionUnionMethodRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::MethodWithUnionUnionMethodRequest, 16>::Equal(this, &other);
    }
    bool operator!=(const MethodWithUnionUnionMethodRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::MethodWithUnionUnionMethodRequest, 16>::Equal(this, &other);
    }
    
      const ::test_protocols::TheUnion &
    u() const {
      return storage_.u;
    }

    
    ::test_protocols::TheUnion& u() {
      return storage_.u;
    }

    // Setter for u.
    //
    
    MethodWithUnionUnionMethodRequest& u(::test_protocols::TheUnion value) {
      storage_.u = std::move(value);
      return *this;
    }

  MethodWithUnionUnionMethodRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MethodWithUnionUnionMethodRequest(Storage_{
      .u =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}

 private:
  struct Storage_ final {
      ::test_protocols::TheUnion u;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::MethodWithUnionUnionMethodRequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::MethodWithUnionUnionMethodRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocols::TheUnion, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::u, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodResponseTable;


class MethodWithUnionUnionMethodResponse {
 private:
  struct Storage_;
 public:
  MethodWithUnionUnionMethodResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    MethodWithUnionUnionMethodResponse(::fidl::Box<::test_protocols::TheUnion> u) noexcept
    : storage_({
      .u = std::move(u)
    }) {}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |MethodWithUnionUnionMethodResponse| only if all of its members are default constructible.
  MethodWithUnionUnionMethodResponse() = default;
#pragma clang diagnostic pop

  MethodWithUnionUnionMethodResponse(MethodWithUnionUnionMethodResponse&&) noexcept = default;
  MethodWithUnionUnionMethodResponse& operator=(MethodWithUnionUnionMethodResponse&&) noexcept = default;
    MethodWithUnionUnionMethodResponse(const MethodWithUnionUnionMethodResponse& other) noexcept : MethodWithUnionUnionMethodResponse(other.CloneStorage_()){}
    MethodWithUnionUnionMethodResponse& operator=(const MethodWithUnionUnionMethodResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool operator==(const MethodWithUnionUnionMethodResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocols::MethodWithUnionUnionMethodResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const MethodWithUnionUnionMethodResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocols::MethodWithUnionUnionMethodResponse, 16>::Equal(this, &other);
    }
    
      const ::fidl::Box<::test_protocols::TheUnion> &
    u() const {
      return storage_.u;
    }

    
    ::fidl::Box<::test_protocols::TheUnion>& u() {
      return storage_.u;
    }

    // Setter for u.
    //
    
    MethodWithUnionUnionMethodResponse& u(::fidl::Box<::test_protocols::TheUnion> value) {
      storage_.u = std::move(value);
      return *this;
    }

  MethodWithUnionUnionMethodResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MethodWithUnionUnionMethodResponse(Storage_{
      .u ={},
  }) {}

 private:
  struct Storage_ final {
      ::fidl::Box<::test_protocols::TheUnion> u;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocols::MethodWithUnionUnionMethodResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::MethodWithUnionUnionMethodResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::fidl::Box<::test_protocols::TheUnion>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::u, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  

}  // namespace test_protocols
namespace fidl {


  

  extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest, 16> {};

  
  

  extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, 16> {};

  
  

  extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest, 16> {};

  
  

  extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest, 16> {};

  
  

  extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithErrorSyntaxResponseAsStructResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithErrorSyntaxResponseAsStructResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 24;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::WithErrorSyntaxResponseAsStructResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithErrorSyntaxResponseAsStructResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxResponseAsStructResponse, 24> {};

  
  

  extern "C" const fidl_type_t test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithErrorSyntaxResponseAsStructTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithErrorSyntaxResponseAsStructTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 24;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocols::WithErrorSyntaxResponseAsStructTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithErrorSyntaxResponseAsStructTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxResponseAsStructTopResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 1;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalEmptyStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResponse> {};

  
  

  extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithErrorSyntaxErrorAsEnumResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithErrorSyntaxErrorAsEnumResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 1;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::WithErrorSyntaxErrorAsEnumResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalEmptyStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumResponse> {};

  
  

  extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse, 16> {};

  
  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;

  
  template <>
  struct IsResource<::test_protocols::WithErrorSyntaxHandleInResultResponse> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::WithErrorSyntaxHandleInResultResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithErrorSyntaxHandleInResultResponse> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 4;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::WithErrorSyntaxHandleInResultResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithErrorSyntaxHandleInResultResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxHandleInResultResponse, 4> {};

  

#endif  // __Fuchsia__

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;

  
  template <>
  struct IsResource<::test_protocols::WithErrorSyntaxHandleInResultTopResponse> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::WithErrorSyntaxHandleInResultTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithErrorSyntaxHandleInResultTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocols::WithErrorSyntaxHandleInResultTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithErrorSyntaxHandleInResultTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithErrorSyntaxHandleInResultTopResponse, 16> {};

  

#endif  // __Fuchsia__

  

  extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;

  
  template <>
  struct IsFidlType<::test_protocols::ChannelProtocolMethodARequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::ChannelProtocolMethodARequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::ChannelProtocolMethodARequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::ChannelProtocolMethodARequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMethodARequest, 16> {};

  
  

  extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;

  
  template <>
  struct IsFidlType<::test_protocols::ChannelProtocolEventARequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::ChannelProtocolEventARequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::ChannelProtocolEventARequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::ChannelProtocolEventARequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolEventARequest, 16> {};

  
  

  extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;

  
  template <>
  struct IsFidlType<::test_protocols::ChannelProtocolMethodBRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::ChannelProtocolMethodBRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::ChannelProtocolMethodBRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::ChannelProtocolMethodBRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMethodBRequest, 16> {};

  
  

  extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBResponseTable;

  
  template <>
  struct IsFidlType<::test_protocols::ChannelProtocolMethodBResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::ChannelProtocolMethodBResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 8;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::ChannelProtocolMethodBResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::ChannelProtocolMethodBResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMethodBResponse, 8> {};

  
  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_ChannelProtocolTakeHandleRequestTable;

  
  template <>
  struct IsResource<::test_protocols::ChannelProtocolTakeHandleRequest> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::ChannelProtocolTakeHandleRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::ChannelProtocolTakeHandleRequest> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 4;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::ChannelProtocolTakeHandleRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::ChannelProtocolTakeHandleRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolTakeHandleRequest, 4> {};

  

#endif  // __Fuchsia__

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketRequestTable;

  
  template <>
  struct IsResource<::test_protocols::ChannelProtocolMutateSocketRequest> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::ChannelProtocolMutateSocketRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::ChannelProtocolMutateSocketRequest> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 4;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::ChannelProtocolMutateSocketRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::ChannelProtocolMutateSocketRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMutateSocketRequest, 4> {};

  

#endif  // __Fuchsia__

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketResponseTable;

  
  template <>
  struct IsResource<::test_protocols::ChannelProtocolMutateSocketResponse> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::ChannelProtocolMutateSocketResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::ChannelProtocolMutateSocketResponse> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 4;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::ChannelProtocolMutateSocketResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::ChannelProtocolMutateSocketResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ChannelProtocolMutateSocketResponse, 4> {};

  

#endif  // __Fuchsia__

  

  extern "C" const fidl_type_t test_protocols_SyscallProtocolMethodCRequestTable;

  
  template <>
  struct IsFidlType<::test_protocols::SyscallProtocolMethodCRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::SyscallProtocolMethodCRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::SyscallProtocolMethodCRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::SyscallProtocolMethodCRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::SyscallProtocolMethodCRequest, 16> {};

  
  

  extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;

  
  template <>
  struct IsFidlType<::test_protocols::TransitionalRequestRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::TransitionalRequestRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 8;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::TransitionalRequestRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::TransitionalRequestRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalRequestRequest, 8> {};

  
  

  extern "C" const fidl_type_t test_protocols_TransitionalRequestResponseTable;

  
  template <>
  struct IsFidlType<::test_protocols::TransitionalRequestResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::TransitionalRequestResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 8;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::TransitionalRequestResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::TransitionalRequestResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalRequestResponse, 8> {};

  
  

  extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;

  
  template <>
  struct IsFidlType<::test_protocols::TransitionalOneWayRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::TransitionalOneWayRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 8;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::TransitionalOneWayRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::TransitionalOneWayRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalOneWayRequest, 8> {};

  
  

  extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;

  
  template <>
  struct IsFidlType<::test_protocols::TransitionalEventRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::TransitionalEventRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 8;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::TransitionalEventRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::TransitionalEventRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::TransitionalEventRequest, 8> {};

  
  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

  
  template <>
  struct IsResource<::test_protocols::HandleRightsProtocolNoResponseMethodRequest> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::HandleRightsProtocolNoResponseMethodRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::HandleRightsProtocolNoResponseMethodRequest> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 4;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::HandleRightsProtocolNoResponseMethodRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::HandleRightsProtocolNoResponseMethodRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::HandleRightsProtocolNoResponseMethodRequest, 4> {};

  

#endif  // __Fuchsia__

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodRequestTable;

  
  template <>
  struct IsResource<::test_protocols::HandleRightsProtocolResponseMethodRequest> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::HandleRightsProtocolResponseMethodRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::HandleRightsProtocolResponseMethodRequest> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 4;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::HandleRightsProtocolResponseMethodRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::HandleRightsProtocolResponseMethodRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::HandleRightsProtocolResponseMethodRequest, 4> {};

  

#endif  // __Fuchsia__

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodResponseTable;

  
  template <>
  struct IsResource<::test_protocols::HandleRightsProtocolResponseMethodResponse> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::HandleRightsProtocolResponseMethodResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::HandleRightsProtocolResponseMethodResponse> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 4;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::HandleRightsProtocolResponseMethodResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::HandleRightsProtocolResponseMethodResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::HandleRightsProtocolResponseMethodResponse, 4> {};

  

#endif  // __Fuchsia__

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_HandleRightsProtocolAnEventRequestTable;

  
  template <>
  struct IsResource<::test_protocols::HandleRightsProtocolAnEventRequest> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::HandleRightsProtocolAnEventRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::HandleRightsProtocolAnEventRequest> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 4;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::HandleRightsProtocolAnEventRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::HandleRightsProtocolAnEventRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::HandleRightsProtocolAnEventRequest, 4> {};

  

#endif  // __Fuchsia__

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_ProtocolEndsTable;

  
  template <>
  struct IsResource<::test_protocols::ProtocolEnds> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::ProtocolEnds> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::ProtocolEnds> {
    static constexpr uint32_t kMaxNumHandles = 4;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::ProtocolEnds> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::ProtocolEnds, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ProtocolEnds, 16> {};

  

#endif  // __Fuchsia__

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsRequestTable;

  
  template <>
  struct IsResource<::test_protocols::WithProtocolEndsClientEndsRequest> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::WithProtocolEndsClientEndsRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithProtocolEndsClientEndsRequest> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 4;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::WithProtocolEndsClientEndsRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithProtocolEndsClientEndsRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithProtocolEndsClientEndsRequest, 4> {};

  

#endif  // __Fuchsia__

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsResponseTable;

  
  template <>
  struct IsResource<::test_protocols::WithProtocolEndsClientEndsResponse> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::WithProtocolEndsClientEndsResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithProtocolEndsClientEndsResponse> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 4;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::WithProtocolEndsClientEndsResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithProtocolEndsClientEndsResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithProtocolEndsClientEndsResponse, 4> {};

  

#endif  // __Fuchsia__

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsRequestTable;

  
  template <>
  struct IsResource<::test_protocols::WithProtocolEndsServerEndsRequest> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::WithProtocolEndsServerEndsRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithProtocolEndsServerEndsRequest> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 4;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::WithProtocolEndsServerEndsRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithProtocolEndsServerEndsRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithProtocolEndsServerEndsRequest, 4> {};

  

#endif  // __Fuchsia__

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsResponseTable;

  
  template <>
  struct IsResource<::test_protocols::WithProtocolEndsServerEndsResponse> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::WithProtocolEndsServerEndsResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithProtocolEndsServerEndsResponse> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 4;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::WithProtocolEndsServerEndsResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithProtocolEndsServerEndsResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithProtocolEndsServerEndsResponse, 4> {};

  

#endif  // __Fuchsia__

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

  
  template <>
  struct IsResource<::test_protocols::WithProtocolEndsStructContainingEndsRequest> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::WithProtocolEndsStructContainingEndsRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithProtocolEndsStructContainingEndsRequest> {
    static constexpr uint32_t kMaxNumHandles = 4;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::WithProtocolEndsStructContainingEndsRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithProtocolEndsStructContainingEndsRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithProtocolEndsStructContainingEndsRequest, 16> {};

  

#endif  // __Fuchsia__

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsResponseTable;

  
  template <>
  struct IsResource<::test_protocols::WithProtocolEndsStructContainingEndsResponse> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::WithProtocolEndsStructContainingEndsResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithProtocolEndsStructContainingEndsResponse> {
    static constexpr uint32_t kMaxNumHandles = 4;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::WithProtocolEndsStructContainingEndsResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithProtocolEndsStructContainingEndsResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::WithProtocolEndsStructContainingEndsResponse, 16> {};

  

#endif  // __Fuchsia__

  

  extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;

  
  template <>
  struct IsFidlType<::test_protocols::ManyParametersFifteenRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::ManyParametersFifteenRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 15;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_protocols::ManyParametersFifteenRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::ManyParametersFifteenRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::ManyParametersFifteenRequest, 15> {};

  
  

  extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodRequestTable;

  
  template <>
  struct IsFidlType<::test_protocols::MethodWithUnionUnionMethodRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::MethodWithUnionUnionMethodRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocols::MethodWithUnionUnionMethodRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::MethodWithUnionUnionMethodRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::MethodWithUnionUnionMethodRequest, 16> {};

  
  

  extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodResponseTable;

  
  template <>
  struct IsFidlType<::test_protocols::MethodWithUnionUnionMethodResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::MethodWithUnionUnionMethodResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocols::MethodWithUnionUnionMethodResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::MethodWithUnionUnionMethodResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocols::MethodWithUnionUnionMethodResponse, 16> {};

  


  

  extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ResponseAsStruct_ResultTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithErrorSyntaxResponseAsStructResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithErrorSyntaxResponseAsStructResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 24;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocols::WithErrorSyntaxResponseAsStructResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithErrorSyntaxResponseAsStructResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocols::WithErrorSyntaxResponseAsStructResult> {};


  

  extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResultTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult> {};


  

  extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ErrorAsEnum_ResultTable;

  
  template <>
  struct IsFidlType<::test_protocols::WithErrorSyntaxErrorAsEnumResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithErrorSyntaxErrorAsEnumResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocols::WithErrorSyntaxErrorAsEnumResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumResult> {};


  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_protocols_WithErrorSyntax_HandleInResult_ResultTable;

  
  template <>
  struct IsResource<::test_protocols::WithErrorSyntaxHandleInResultResult> : public std::true_type {};
  template <>
  struct IsFidlType<::test_protocols::WithErrorSyntaxHandleInResultResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::WithErrorSyntaxHandleInResultResult> {
    static constexpr uint32_t kMaxNumHandles = 1;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocols::WithErrorSyntaxHandleInResultResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::WithErrorSyntaxHandleInResultResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocols::WithErrorSyntaxHandleInResultResult> {};



#endif  // __Fuchsia__

  

  extern "C" const fidl_type_t test_protocols_TheUnionTable;

  
  template <>
  struct IsFidlType<::test_protocols::TheUnion> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocols::TheUnion> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocols::TheUnion> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocols::TheUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocols::TheUnion> {};




  template <>
  struct internal::NaturalCodingTraits<::test_protocols::ErrorEnum, ::fidl::internal::NaturalCodingConstraintEmpty> {
    static constexpr size_t inline_size_v2 = sizeof(uint32_t);
    static constexpr bool is_memcpy_compatible = false;

    static void Encode(internal::NaturalEncoder* encoder, ::test_protocols::ErrorEnum* value, size_t offset, size_t recursion_depth) {
      switch (*value) {
        case ::test_protocols::ErrorEnum::kErrFoo:
        case ::test_protocols::ErrorEnum::kErrBar:
          break;
        default:
          encoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
          return;
      }
      *encoder->template GetPtr<::test_protocols::ErrorEnum>(offset) = *value;
    }
    static void Decode(internal::NaturalDecoder* decoder, ::test_protocols::ErrorEnum* value, size_t offset, size_t recursion_depth) {
      *value = *decoder->template GetPtr<::test_protocols::ErrorEnum>(offset);
      switch (*value) {
        case ::test_protocols::ErrorEnum::kErrFoo:
        case ::test_protocols::ErrorEnum::kErrBar:
          break;
        default:
          decoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
          return;
      }
    }
  };

}  // namespace fidl

