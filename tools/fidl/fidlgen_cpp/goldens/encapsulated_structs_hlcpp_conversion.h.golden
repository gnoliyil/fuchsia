// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include <fidl/test.encapsulatedstructs/cpp/natural_types.h>
#include <lib/fidl/cpp/hlcpp_conversion.h>
#include <lib/fidl/cpp/wire/service_handler.h>
#include <test/encapsulatedstructs/cpp/fidl.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace fidl {
namespace internal {

template <>
struct NaturalToHLCPPTraits<::test_encapsulatedstructs::Int8Int32> {
  using HLCPPType = ::test::encapsulatedstructs::Int8Int32;
  static inline ::test::encapsulatedstructs::Int8Int32 Convert(::test_encapsulatedstructs::Int8Int32&&);
};
template <>
struct HLCPPToNaturalTraits<::test::encapsulatedstructs::Int8Int32> {
  using NaturalType = ::test_encapsulatedstructs::Int8Int32;
  static inline ::test_encapsulatedstructs::Int8Int32 Convert(::test::encapsulatedstructs::Int8Int32&&);
};
template <>
struct NaturalToHLCPPTraits<::test_encapsulatedstructs::Int16Int8> {
  using HLCPPType = ::test::encapsulatedstructs::Int16Int8;
  static inline ::test::encapsulatedstructs::Int16Int8 Convert(::test_encapsulatedstructs::Int16Int8&&);
};
template <>
struct HLCPPToNaturalTraits<::test::encapsulatedstructs::Int16Int8> {
  using NaturalType = ::test_encapsulatedstructs::Int16Int8;
  static inline ::test_encapsulatedstructs::Int16Int8 Convert(::test::encapsulatedstructs::Int16Int8&&);
};
template <>
struct NaturalToHLCPPTraits<::test_encapsulatedstructs::ArrayInt16Int8> {
  using HLCPPType = ::test::encapsulatedstructs::ArrayInt16Int8;
  static inline ::test::encapsulatedstructs::ArrayInt16Int8 Convert(::test_encapsulatedstructs::ArrayInt16Int8&&);
};
template <>
struct HLCPPToNaturalTraits<::test::encapsulatedstructs::ArrayInt16Int8> {
  using NaturalType = ::test_encapsulatedstructs::ArrayInt16Int8;
  static inline ::test_encapsulatedstructs::ArrayInt16Int8 Convert(::test::encapsulatedstructs::ArrayInt16Int8&&);
};
template <>
struct NaturalToHLCPPTraits<::test_encapsulatedstructs::StructPaddingTestStruct> {
  using HLCPPType = ::test::encapsulatedstructs::StructPaddingTestStruct;
  static inline ::test::encapsulatedstructs::StructPaddingTestStruct Convert(::test_encapsulatedstructs::StructPaddingTestStruct&&);
};
template <>
struct HLCPPToNaturalTraits<::test::encapsulatedstructs::StructPaddingTestStruct> {
  using NaturalType = ::test_encapsulatedstructs::StructPaddingTestStruct;
  static inline ::test_encapsulatedstructs::StructPaddingTestStruct Convert(::test::encapsulatedstructs::StructPaddingTestStruct&&);
};
template <>
struct NaturalToHLCPPTraits<::test_encapsulatedstructs::NonInlineStructTestStruct> {
  using HLCPPType = ::test::encapsulatedstructs::NonInlineStructTestStruct;
  static inline ::test::encapsulatedstructs::NonInlineStructTestStruct Convert(::test_encapsulatedstructs::NonInlineStructTestStruct&&);
};
template <>
struct HLCPPToNaturalTraits<::test::encapsulatedstructs::NonInlineStructTestStruct> {
  using NaturalType = ::test_encapsulatedstructs::NonInlineStructTestStruct;
  static inline ::test_encapsulatedstructs::NonInlineStructTestStruct Convert(::test::encapsulatedstructs::NonInlineStructTestStruct&&);
};
template <>
struct NaturalToHLCPPTraits<::test_encapsulatedstructs::TopLevelStruct> {
  using HLCPPType = ::test::encapsulatedstructs::TopLevelStruct;
  static inline ::test::encapsulatedstructs::TopLevelStruct Convert(::test_encapsulatedstructs::TopLevelStruct&&);
};
template <>
struct HLCPPToNaturalTraits<::test::encapsulatedstructs::TopLevelStruct> {
  using NaturalType = ::test_encapsulatedstructs::TopLevelStruct;
  static inline ::test_encapsulatedstructs::TopLevelStruct Convert(::test::encapsulatedstructs::TopLevelStruct&&);
};

::test::encapsulatedstructs::Int8Int32 NaturalToHLCPPTraits<::test_encapsulatedstructs::Int8Int32>::Convert(::test_encapsulatedstructs::Int8Int32&& value) {
  ::test::encapsulatedstructs::Int8Int32 hlcpp;
  hlcpp.a = ::fidl::NaturalToHLCPP(std::move(value.a()));
  hlcpp.b = ::fidl::NaturalToHLCPP(std::move(value.b()));
  return hlcpp;
}

::test_encapsulatedstructs::Int8Int32 HLCPPToNaturalTraits<::test::encapsulatedstructs::Int8Int32>::Convert(::test::encapsulatedstructs::Int8Int32&& value) {
  return ::test_encapsulatedstructs::Int8Int32{{
      .a = ::fidl::HLCPPToNatural(std::move(value.a)),
      .b = ::fidl::HLCPPToNatural(std::move(value.b)),
  }};
}
::test::encapsulatedstructs::Int16Int8 NaturalToHLCPPTraits<::test_encapsulatedstructs::Int16Int8>::Convert(::test_encapsulatedstructs::Int16Int8&& value) {
  ::test::encapsulatedstructs::Int16Int8 hlcpp;
  hlcpp.a = ::fidl::NaturalToHLCPP(std::move(value.a()));
  hlcpp.b = ::fidl::NaturalToHLCPP(std::move(value.b()));
  return hlcpp;
}

::test_encapsulatedstructs::Int16Int8 HLCPPToNaturalTraits<::test::encapsulatedstructs::Int16Int8>::Convert(::test::encapsulatedstructs::Int16Int8&& value) {
  return ::test_encapsulatedstructs::Int16Int8{{
      .a = ::fidl::HLCPPToNatural(std::move(value.a)),
      .b = ::fidl::HLCPPToNatural(std::move(value.b)),
  }};
}
::test::encapsulatedstructs::ArrayInt16Int8 NaturalToHLCPPTraits<::test_encapsulatedstructs::ArrayInt16Int8>::Convert(::test_encapsulatedstructs::ArrayInt16Int8&& value) {
  ::test::encapsulatedstructs::ArrayInt16Int8 hlcpp;
  hlcpp.arr = ::fidl::NaturalToHLCPP(std::move(value.arr()));
  return hlcpp;
}

::test_encapsulatedstructs::ArrayInt16Int8 HLCPPToNaturalTraits<::test::encapsulatedstructs::ArrayInt16Int8>::Convert(::test::encapsulatedstructs::ArrayInt16Int8&& value) {
  return ::test_encapsulatedstructs::ArrayInt16Int8{{
      .arr = ::fidl::HLCPPToNatural(std::move(value.arr)),
  }};
}
::test::encapsulatedstructs::StructPaddingTestStruct NaturalToHLCPPTraits<::test_encapsulatedstructs::StructPaddingTestStruct>::Convert(::test_encapsulatedstructs::StructPaddingTestStruct&& value) {
  ::test::encapsulatedstructs::StructPaddingTestStruct hlcpp;
  hlcpp.trailing = ::fidl::NaturalToHLCPP(std::move(value.trailing()));
  hlcpp.inner = ::fidl::NaturalToHLCPP(std::move(value.inner()));
  hlcpp.array = ::fidl::NaturalToHLCPP(std::move(value.array()));
  return hlcpp;
}

::test_encapsulatedstructs::StructPaddingTestStruct HLCPPToNaturalTraits<::test::encapsulatedstructs::StructPaddingTestStruct>::Convert(::test::encapsulatedstructs::StructPaddingTestStruct&& value) {
  return ::test_encapsulatedstructs::StructPaddingTestStruct{{
      .trailing = ::fidl::HLCPPToNatural(std::move(value.trailing)),
      .inner = ::fidl::HLCPPToNatural(std::move(value.inner)),
      .array = ::fidl::HLCPPToNatural(std::move(value.array)),
  }};
}
::test::encapsulatedstructs::NonInlineStructTestStruct NaturalToHLCPPTraits<::test_encapsulatedstructs::NonInlineStructTestStruct>::Convert(::test_encapsulatedstructs::NonInlineStructTestStruct&& value) {
  ::test::encapsulatedstructs::NonInlineStructTestStruct hlcpp;
  hlcpp.element = ::fidl::NaturalToHLCPP(std::move(value.element()));
  hlcpp.h = ::fidl::NaturalToHLCPP(std::move(value.h()));
  return hlcpp;
}

::test_encapsulatedstructs::NonInlineStructTestStruct HLCPPToNaturalTraits<::test::encapsulatedstructs::NonInlineStructTestStruct>::Convert(::test::encapsulatedstructs::NonInlineStructTestStruct&& value) {
  return ::test_encapsulatedstructs::NonInlineStructTestStruct{{
      .element = ::fidl::HLCPPToNatural(std::move(value.element)),
      .h = ::fidl::HLCPPToNatural(std::move(value.h)),
  }};
}
::test::encapsulatedstructs::TopLevelStruct NaturalToHLCPPTraits<::test_encapsulatedstructs::TopLevelStruct>::Convert(::test_encapsulatedstructs::TopLevelStruct&& value) {
  ::test::encapsulatedstructs::TopLevelStruct hlcpp;
  hlcpp.a = ::fidl::NaturalToHLCPP(std::move(value.a()));
  hlcpp.b = ::fidl::NaturalToHLCPP(std::move(value.b()));
  return hlcpp;
}

::test_encapsulatedstructs::TopLevelStruct HLCPPToNaturalTraits<::test::encapsulatedstructs::TopLevelStruct>::Convert(::test::encapsulatedstructs::TopLevelStruct&& value) {
  return ::test_encapsulatedstructs::TopLevelStruct{{
      .a = ::fidl::HLCPPToNatural(std::move(value.a)),
      .b = ::fidl::HLCPPToNatural(std::move(value.b)),
  }};
}

#pragma clang diagnostic pop

}  // namespace internal
}  // namespace fidl
