// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

#pragma once

#include <fidl/test.protocols/cpp/markers.h>
#include <fidl/test.protocols/cpp/natural_types.h>
#include <fidl/test.protocols/cpp/wire_messaging.h>
#include <lib/fidl/cpp/channel.h>
#include <lib/fidl/cpp/client.h>
#include <lib/fidl/cpp/internal/thenable.h>
#include <lib/fidl/cpp/natural_types.h>
#include <lib/fidl/cpp/unified_messaging.h>
#include <lib/fidl/cpp/wire/unknown_interaction_handler.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace fidl {

}  // namespace fidl

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> {
  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
  using Response = ::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> {
  using Request = ::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest;

  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> {
  using Request = ::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
  using Request = ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest;

  using Response = ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> {
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> {
  using Request = ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest;
};

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final {
 public:
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final : public ::fit::result<::fidl::Error> {
 public:
  using ::fit::result<::fidl::Error>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final : public ::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse {
 public:
  using ::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse::WithAndWithoutRequestResponseNoRequestWithResponseResponse;
  Response(::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse v) : WithAndWithoutRequestResponseNoRequestWithResponseResponse(std::move(v)) {}
};

template <>
class ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final : public ::fit::result<::fidl::Error, ::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final {
 public:
};

template <>
class ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final : public ::fit::result<::fidl::Error> {
 public:
  using ::fit::result<::fidl::Error>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final : public ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse {
 public:
  using ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse::WithAndWithoutRequestResponseWithRequestWithResponseResponse;
  Response(::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse v) : WithAndWithoutRequestResponseWithRequestWithResponseResponse(std::move(v)) {}
};

template <>
class ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final : public ::fit::result<::fidl::Error, ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::WithAndWithoutRequestResponse> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse() const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse() const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(const ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>& request) const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(const ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& request) const;

  ::fit::result<::fidl::OneWayError> NoRequestNoResponse() const;

  ::fit::result<::fidl::OneWayError> WithRequestNoResponse(const ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>& request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse();

  ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse();

  ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(const ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>& request);

  ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(const ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& request);

  ::fit::result<::fidl::OneWayError> NoRequestNoResponse();

  ::fit::result<::fidl::OneWayError> WithRequestNoResponse(const ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>& request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void OnEmptyResponse() = 0;
  virtual void OnWithResponse(::fidl::Event<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>&) = 0;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
  void OnEmptyResponse() override {}
  void OnWithResponse(::fidl::Event<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>&) override {}
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::WithAndWithoutRequestResponse> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
  ::fidl::Status DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      internal::MessageStorageViewBase* storage_view) override;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fit::result<::fidl::OneWayError> OnEmptyResponse();

  ::fit::result<::fidl::OneWayError> OnWithResponse(const ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest& payload);
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fit::result<::fidl::OneWayError> OnEmptyResponse();

  ::fit::result<::fidl::OneWayError> OnWithResponse(const ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest& payload);
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> : public ::fidl::CompleterBase {
 public:
  void Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> : public ::fidl::CompleterBase {
 public:
  void Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithAndWithoutRequestResponse;

  using Handler = fidl::ProtocolHandler<::test_protocols::WithAndWithoutRequestResponse>;

  using NoRequestNoResponseCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>;

  virtual void NoRequestNoResponse(
      NoRequestNoResponseCompleter::Sync& completer) = 0;

  using NoRequestEmptyResponseCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>;

  virtual void NoRequestEmptyResponse(
      NoRequestEmptyResponseCompleter::Sync& completer) = 0;

  using NoRequestWithResponseCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;

  virtual void NoRequestWithResponse(
      NoRequestWithResponseCompleter::Sync& completer) = 0;

  using WithRequestNoResponseRequest = ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>;
  using WithRequestNoResponseCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>;

  virtual void WithRequestNoResponse(WithRequestNoResponseRequest& request,
                                     WithRequestNoResponseCompleter::Sync& completer) = 0;

  using WithRequestEmptyResponseRequest = ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>;
  using WithRequestEmptyResponseCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>;

  virtual void WithRequestEmptyResponse(WithRequestEmptyResponseRequest& request,
                                        WithRequestEmptyResponseCompleter::Sync& completer) = 0;

  using WithRequestWithResponseRequest = ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;
  using WithRequestWithResponseCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;

  virtual void WithRequestWithResponse(WithRequestWithResponseRequest& request,
                                       WithRequestWithResponseCompleter::Sync& completer) = 0;

  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl = this, dispatcher = dispatcher](::fidl::ServerEnd<::test_protocols::WithAndWithoutRequestResponse> request) {
      (void)::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::WithAndWithoutRequestResponse> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithErrorSyntax::ResponseAsStruct> {
  using Response = ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::ResponseAsStruct>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithErrorSyntax::ResponseAsStruct>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
  using Response = ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithErrorSyntax::ErrorAsEnum> {
  using Response = ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsEnum>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithErrorSyntax::HandleInResult> {
  using Response = ::test_protocols::WithErrorSyntaxHandleInResultTopResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::HandleInResult>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithErrorSyntax::HandleInResult>&)>;
};

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct> final : public ::fit::result<uint32_t, ::test_protocols::WithErrorSyntaxResponseAsStructResponse> {
 public:
  using ::fit::result<uint32_t, ::test_protocols::WithErrorSyntaxResponseAsStructResponse>::result;
  Response(::fit::result<uint32_t, ::test_protocols::WithErrorSyntaxResponseAsStructResponse> v) : result(std::move(v)) {}
  Response() = delete;
};
template <>
class ::fidl::internal::ResponseMessageConverter<::test_protocols::WithErrorSyntax::ResponseAsStruct> {
  using DomainObject = ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse;

 public:
  static DomainObject IntoDomainObject(const ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxResponseAsStructResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxResponseAsStructResult::WithResponse(std::move(m.value()))}};
    }
  }
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::WithErrorSyntax::ResponseAsStruct> final : public ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::test_protocols::WithErrorSyntaxResponseAsStructResponse> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::test_protocols::WithErrorSyntaxResponseAsStructResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final : public ::fit::result<uint32_t> {
 public:
  using ::fit::result<uint32_t>::result;
  Response(::fit::result<uint32_t> v) : result(std::move(v)) {}
  Response() = delete;
};
template <>
class ::fidl::internal::ResponseMessageConverter<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
  using DomainObject = ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse;

 public:
  static DomainObject IntoDomainObject(const ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxErrorAsPrimitiveResult::WithResponse({})}};
    }
  }
};

template <>
class ::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final : public ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum> final : public ::fit::result<::test_protocols::ErrorEnum> {
 public:
  using ::fit::result<::test_protocols::ErrorEnum>::result;
  Response(::fit::result<::test_protocols::ErrorEnum> v) : result(std::move(v)) {}
  Response() = delete;
};
template <>
class ::fidl::internal::ResponseMessageConverter<::test_protocols::WithErrorSyntax::ErrorAsEnum> {
  using DomainObject = ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse;

 public:
  static DomainObject IntoDomainObject(const ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxErrorAsEnumResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxErrorAsEnumResult::WithResponse({})}};
    }
  }
};

template <>
class ::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsEnum> final : public ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::ErrorAsEnum>>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult> final : public ::fit::result<uint32_t, ::test_protocols::WithErrorSyntaxHandleInResultResponse> {
 public:
  using ::fit::result<uint32_t, ::test_protocols::WithErrorSyntaxHandleInResultResponse>::result;
  Response(::fit::result<uint32_t, ::test_protocols::WithErrorSyntaxHandleInResultResponse> v) : result(std::move(v)) {}
  Response() = delete;
};
template <>
class ::fidl::internal::ResponseMessageConverter<::test_protocols::WithErrorSyntax::HandleInResult> {
  using DomainObject = ::test_protocols::WithErrorSyntaxHandleInResultTopResponse;

 public:
  static DomainObject IntoDomainObject(::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult> m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxHandleInResultResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_protocols::WithErrorSyntaxHandleInResultResult::WithResponse(std::move(m.value()))}};
    }
  }
};

template <>
class ::fidl::Result<::test_protocols::WithErrorSyntax::HandleInResult> final : public ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::HandleInResult>, ::test_protocols::WithErrorSyntaxHandleInResultResponse> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_protocols::WithErrorSyntax::HandleInResult>, ::test_protocols::WithErrorSyntaxHandleInResultResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct() const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive() const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum() const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult() const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::WithErrorSyntax> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::WithErrorSyntax>> {
 public:
  ::fidl::Result<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct();

  ::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive();

  ::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum();

  ::fidl::Result<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult();

 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithErrorSyntax> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithErrorSyntax>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithErrorSyntax>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::WithErrorSyntax> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithErrorSyntax>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithErrorSyntax>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::WithErrorSyntax> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::WithErrorSyntax>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::ResponseAsStruct> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithErrorSyntax::HandleInResult> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::WithErrorSyntax> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithErrorSyntax;

  using Handler = fidl::ProtocolHandler<::test_protocols::WithErrorSyntax>;

  using ResponseAsStructCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithErrorSyntax::ResponseAsStruct>;

  virtual void ResponseAsStruct(
      ResponseAsStructCompleter::Sync& completer) = 0;

  using ErrorAsPrimitiveCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

  virtual void ErrorAsPrimitive(
      ErrorAsPrimitiveCompleter::Sync& completer) = 0;

  using ErrorAsEnumCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithErrorSyntax::ErrorAsEnum>;

  virtual void ErrorAsEnum(
      ErrorAsEnumCompleter::Sync& completer) = 0;

  using HandleInResultCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithErrorSyntax::HandleInResult>;

  virtual void HandleInResult(
      HandleInResultCompleter::Sync& completer) = 0;

  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl = this, dispatcher = dispatcher](::fidl::ServerEnd<::test_protocols::WithErrorSyntax> request) {
      (void)::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::WithErrorSyntax> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::WithErrorSyntax>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::ChannelProtocol::MethodA> {
  using Request = ::test_protocols::ChannelProtocolMethodARequest;

  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::ChannelProtocol::EventA> {
  using Request = ::test_protocols::ChannelProtocolEventARequest;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::ChannelProtocol::MethodB> {
  using Request = ::test_protocols::ChannelProtocolMethodBRequest;

  using Response = ::test_protocols::ChannelProtocolMethodBResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::ChannelProtocol::MethodB>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::ChannelProtocol::MethodB>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::ChannelProtocol::TakeHandle> {
  using Request = ::test_protocols::ChannelProtocolTakeHandleRequest;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::ChannelProtocol::TakeHandle>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::ChannelProtocol::TakeHandle>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::ChannelProtocol::MutateSocket> {
  using Request = ::test_protocols::ChannelProtocolMutateSocketRequest;

  using Response = ::test_protocols::ChannelProtocolMutateSocketResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::ChannelProtocol::MutateSocket>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::ChannelProtocol::MutateSocket>&)>;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolTakeHandleRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::MethodB> final : public ::test_protocols::ChannelProtocolMethodBResponse {
 public:
  using ::test_protocols::ChannelProtocolMethodBResponse::ChannelProtocolMethodBResponse;
  Response(::test_protocols::ChannelProtocolMethodBResponse v) : ChannelProtocolMethodBResponse(std::move(v)) {}
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::ChannelProtocol::MethodB> final : public ::fit::result<::fidl::Error, ::test_protocols::ChannelProtocolMethodBResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::ChannelProtocolMethodBResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle> final {
 public:
};

template <>
class ::fidl::Result<::test_protocols::ChannelProtocol::TakeHandle> final : public ::fit::result<::fidl::Error> {
 public:
  using ::fit::result<::fidl::Error>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket> final : public ::test_protocols::ChannelProtocolMutateSocketResponse {
 public:
  using ::test_protocols::ChannelProtocolMutateSocketResponse::ChannelProtocolMutateSocketResponse;
  Response(::test_protocols::ChannelProtocolMutateSocketResponse v) : ChannelProtocolMutateSocketResponse(std::move(v)) {}
};

template <>
class ::fidl::Result<::test_protocols::ChannelProtocol::MutateSocket> final : public ::fit::result<::fidl::Error, ::test_protocols::ChannelProtocolMutateSocketResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::ChannelProtocolMutateSocketResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::ChannelProtocol::MethodB> MethodB(const ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>& request) const;

  ::fidl::internal::NaturalThenable<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle> request) const;

  ::fidl::internal::NaturalThenable<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket> request) const;

  ::fit::result<::fidl::OneWayError> MethodA(const ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>& request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::ChannelProtocol> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::ChannelProtocol>> {
 public:
  ::fidl::Result<::test_protocols::ChannelProtocol::MethodB> MethodB(const ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>& request);

  ::fidl::Result<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle> request);

  ::fidl::Result<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket> request);

  ::fit::result<::fidl::OneWayError> MethodA(const ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>& request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ChannelProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void EventA(::fidl::Event<::test_protocols::ChannelProtocol::EventA>&) = 0;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ChannelProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
  void EventA(::fidl::Event<::test_protocols::ChannelProtocol::EventA>&) override {}
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ChannelProtocol>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::ChannelProtocol> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ChannelProtocol>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ChannelProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
  ::fidl::Status DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      internal::MessageStorageViewBase* storage_view) override;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::ChannelProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fit::result<::fidl::OneWayError> EventA(const ::test_protocols::ChannelProtocolEventARequest& payload);
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::ChannelProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fit::result<::fidl::OneWayError> EventA(const ::test_protocols::ChannelProtocolEventARequest& payload);
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::ChannelProtocol::MethodB> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::ChannelProtocol::TakeHandle> : public ::fidl::CompleterBase {
 public:
  void Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::ChannelProtocol::MutateSocket> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::ChannelProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ChannelProtocol;

  using Handler = fidl::ProtocolHandler<::test_protocols::ChannelProtocol>;

  using MethodARequest = ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>;
  using MethodACompleter = ::fidl::internal::NaturalCompleter<::test_protocols::ChannelProtocol::MethodA>;

  virtual void MethodA(MethodARequest& request,
                       MethodACompleter::Sync& completer) = 0;

  using MethodBRequest = ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>;
  using MethodBCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::ChannelProtocol::MethodB>;

  virtual void MethodB(MethodBRequest& request,
                       MethodBCompleter::Sync& completer) = 0;

  using TakeHandleRequest = ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>;
  using TakeHandleCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::ChannelProtocol::TakeHandle>;

  virtual void TakeHandle(TakeHandleRequest& request,
                          TakeHandleCompleter::Sync& completer) = 0;

  using MutateSocketRequest = ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>;
  using MutateSocketCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::ChannelProtocol::MutateSocket>;

  virtual void MutateSocket(MutateSocketRequest& request,
                            MutateSocketCompleter::Sync& completer) = 0;

  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl = this, dispatcher = dispatcher](::fidl::ServerEnd<::test_protocols::ChannelProtocol> request) {
      (void)::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::ChannelProtocol> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::ChannelProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::Transitional::Request> {
  using Request = ::test_protocols::TransitionalRequestRequest;

  using Response = ::test_protocols::TransitionalRequestResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::Transitional::Request>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::Transitional::Request>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::Transitional::OneWay> {
  using Request = ::test_protocols::TransitionalOneWayRequest;

  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::Transitional::Event> {
  using Request = ::test_protocols::TransitionalEventRequest;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_TransitionalRequestResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::Transitional::Request> final : public ::test_protocols::TransitionalRequestResponse {
 public:
  using ::test_protocols::TransitionalRequestResponse::TransitionalRequestResponse;
  Response(::test_protocols::TransitionalRequestResponse v) : TransitionalRequestResponse(std::move(v)) {}
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::Transitional::Request> final : public ::fit::result<::fidl::Error, ::test_protocols::TransitionalRequestResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::TransitionalRequestResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::Transitional> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::Transitional::Request> Request(const ::fidl::Request<::test_protocols::Transitional::Request>& request) const;

  ::fit::result<::fidl::OneWayError> OneWay(const ::fidl::Request<::test_protocols::Transitional::OneWay>& request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::Transitional> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::Transitional>> {
 public:
  ::fidl::Result<::test_protocols::Transitional::Request> Request(const ::fidl::Request<::test_protocols::Transitional::Request>& request);

  ::fit::result<::fidl::OneWayError> OneWay(const ::fidl::Request<::test_protocols::Transitional::OneWay>& request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::Transitional> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::Transitional>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::Transitional> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void Event(::fidl::Event<::test_protocols::Transitional::Event>&) = 0;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::Transitional>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::Transitional>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
  void Event(::fidl::Event<::test_protocols::Transitional::Event>&) override {}
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::Transitional>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::Transitional>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;
  void Event(::fidl::Event<::test_protocols::Transitional::Event>&) override {
    OnTransitionalEvent_();
  }

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::Transitional> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::Transitional>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::Transitional>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
  ::fidl::Status DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      internal::MessageStorageViewBase* storage_view) override;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::Transitional> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fit::result<::fidl::OneWayError> Event(const ::test_protocols::TransitionalEventRequest& payload);
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::Transitional>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::Transitional>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fit::result<::fidl::OneWayError> Event(const ::test_protocols::TransitionalEventRequest& payload);
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::Transitional::Request> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::Transitional::Request>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::Transitional> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::Transitional;

  using Handler = fidl::ProtocolHandler<::test_protocols::Transitional>;

  using RequestRequest = ::fidl::Request<::test_protocols::Transitional::Request>;
  using RequestCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::Transitional::Request>;

  virtual void Request(RequestRequest& request,
                       RequestCompleter::Sync& completer) { completer.Close(ZX_ERR_NOT_SUPPORTED); }

  using OneWayRequest = ::fidl::Request<::test_protocols::Transitional::OneWay>;
  using OneWayCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::Transitional::OneWay>;

  virtual void OneWay(OneWayRequest& request,
                      OneWayCompleter::Sync& completer) { completer.Close(ZX_ERR_NOT_SUPPORTED); }

  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl = this, dispatcher = dispatcher](::fidl::ServerEnd<::test_protocols::Transitional> request) {
      (void)::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::Transitional> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::Transitional>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::DiscoverableProtocol::Method> {
  using Completer = fidl::Completer<>;
};

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::DiscoverableProtocol> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fit::result<::fidl::OneWayError> Method() const;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::DiscoverableProtocol> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::DiscoverableProtocol>> {
 public:
  ::fit::result<::fidl::OneWayError> Method();

 private:
  ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::DiscoverableProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::DiscoverableProtocol>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::DiscoverableProtocol> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::DiscoverableProtocol>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::DiscoverableProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::DiscoverableProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

#endif  // __Fuchsia__

template <>
class ::fidl::Server<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::DiscoverableProtocol;

  using Handler = fidl::ProtocolHandler<::test_protocols::DiscoverableProtocol>;

  using MethodCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::DiscoverableProtocol::Method>;

  virtual void Method(
      MethodCompleter::Sync& completer) = 0;

  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl = this, dispatcher = dispatcher](::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> request) {
      (void)::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::DiscoverableProtocol> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::DiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::AnotherDiscoverableProtocol> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::AnotherDiscoverableProtocol> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::AnotherDiscoverableProtocol>> {
 public:
 private:
  ::fidl::UnownedClientEnd<::test_protocols::AnotherDiscoverableProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::AnotherDiscoverableProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::AnotherDiscoverableProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::AnotherDiscoverableProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::AnotherDiscoverableProtocol> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::AnotherDiscoverableProtocol> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::AnotherDiscoverableProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::AnotherDiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::AnotherDiscoverableProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

#endif  // __Fuchsia__

template <>
class ::fidl::Server<::test_protocols::AnotherDiscoverableProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::AnotherDiscoverableProtocol;

  using Handler = fidl::ProtocolHandler<::test_protocols::AnotherDiscoverableProtocol>;

  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl = this, dispatcher = dispatcher](::fidl::ServerEnd<::test_protocols::AnotherDiscoverableProtocol> request) {
      (void)::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::AnotherDiscoverableProtocol> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::AnotherDiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::HandleRightsProtocol::NoResponseMethod> {
  using Request = ::test_protocols::HandleRightsProtocolNoResponseMethodRequest;

  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::HandleRightsProtocol::ResponseMethod> {
  using Request = ::test_protocols::HandleRightsProtocolResponseMethodRequest;

  using Response = ::test_protocols::HandleRightsProtocolResponseMethodResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::HandleRightsProtocol::ResponseMethod>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::HandleRightsProtocol::ResponseMethod>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::HandleRightsProtocol::AnEvent> {
  using Request = ::test_protocols::HandleRightsProtocolAnEventRequest;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolAnEventRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::HandleRightsProtocol::ResponseMethod> final : public ::test_protocols::HandleRightsProtocolResponseMethodResponse {
 public:
  using ::test_protocols::HandleRightsProtocolResponseMethodResponse::HandleRightsProtocolResponseMethodResponse;
  Response(::test_protocols::HandleRightsProtocolResponseMethodResponse v) : HandleRightsProtocolResponseMethodResponse(std::move(v)) {}
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::HandleRightsProtocol::ResponseMethod> final : public ::fit::result<::fidl::Error, ::test_protocols::HandleRightsProtocolResponseMethodResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::HandleRightsProtocolResponseMethodResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::HandleRightsProtocol> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod> request) const;

  ::fit::result<::fidl::OneWayError> NoResponseMethod(::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod> request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::HandleRightsProtocol> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::HandleRightsProtocol>> {
 public:
  ::fidl::Result<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod> request);

  ::fit::result<::fidl::OneWayError> NoResponseMethod(::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod> request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void AnEvent(::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>&) = 0;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::HandleRightsProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
  void AnEvent(::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>&) override {}
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::HandleRightsProtocol>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::HandleRightsProtocol> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::HandleRightsProtocol>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::HandleRightsProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
  ::fidl::Status DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      internal::MessageStorageViewBase* storage_view) override;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fit::result<::fidl::OneWayError> AnEvent(::test_protocols::HandleRightsProtocolAnEventRequest payload);
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::HandleRightsProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fit::result<::fidl::OneWayError> AnEvent(::test_protocols::HandleRightsProtocolAnEventRequest payload);
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::HandleRightsProtocol::ResponseMethod> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::HandleRightsProtocol::ResponseMethod> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::HandleRightsProtocol;

  using Handler = fidl::ProtocolHandler<::test_protocols::HandleRightsProtocol>;

  using NoResponseMethodRequest = ::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod>;
  using NoResponseMethodCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::HandleRightsProtocol::NoResponseMethod>;

  virtual void NoResponseMethod(NoResponseMethodRequest& request,
                                NoResponseMethodCompleter::Sync& completer) = 0;

  using ResponseMethodRequest = ::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod>;
  using ResponseMethodCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::HandleRightsProtocol::ResponseMethod>;

  virtual void ResponseMethod(ResponseMethodRequest& request,
                              ResponseMethodCompleter::Sync& completer) = 0;

  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl = this, dispatcher = dispatcher](::fidl::ServerEnd<::test_protocols::HandleRightsProtocol> request) {
      (void)::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::HandleRightsProtocol> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::HandleRightsProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithProtocolEnds::ClientEnds> {
  using Request = ::test_protocols::WithProtocolEndsClientEndsRequest;

  using Response = ::test_protocols::WithProtocolEndsClientEndsResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithProtocolEnds::ClientEnds>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithProtocolEnds::ServerEnds> {
  using Request = ::test_protocols::WithProtocolEndsServerEndsRequest;

  using Response = ::test_protocols::WithProtocolEndsServerEndsResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithProtocolEnds::ServerEnds>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::WithProtocolEnds::StructContainingEnds> {
  using Request = ::test_protocols::WithProtocolEndsStructContainingEndsRequest;

  using Response = ::test_protocols::WithProtocolEndsStructContainingEndsResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::WithProtocolEnds::StructContainingEnds>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::WithProtocolEnds::StructContainingEnds>&)>;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsResponseTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds> final : public ::test_protocols::WithProtocolEndsClientEndsResponse {
 public:
  using ::test_protocols::WithProtocolEndsClientEndsResponse::WithProtocolEndsClientEndsResponse;
  Response(::test_protocols::WithProtocolEndsClientEndsResponse v) : WithProtocolEndsClientEndsResponse(std::move(v)) {}
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::WithProtocolEnds::ClientEnds> final : public ::fit::result<::fidl::Error, ::test_protocols::WithProtocolEndsClientEndsResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::WithProtocolEndsClientEndsResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds> final : public ::test_protocols::WithProtocolEndsServerEndsResponse {
 public:
  using ::test_protocols::WithProtocolEndsServerEndsResponse::WithProtocolEndsServerEndsResponse;
  Response(::test_protocols::WithProtocolEndsServerEndsResponse v) : WithProtocolEndsServerEndsResponse(std::move(v)) {}
};

template <>
class ::fidl::Result<::test_protocols::WithProtocolEnds::ServerEnds> final : public ::fit::result<::fidl::Error, ::test_protocols::WithProtocolEndsServerEndsResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::WithProtocolEndsServerEndsResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::StructContainingEnds> final : public ::test_protocols::WithProtocolEndsStructContainingEndsResponse {
 public:
  using ::test_protocols::WithProtocolEndsStructContainingEndsResponse::WithProtocolEndsStructContainingEndsResponse;
  Response(::test_protocols::WithProtocolEndsStructContainingEndsResponse v) : WithProtocolEndsStructContainingEndsResponse(std::move(v)) {}
};

template <>
class ::fidl::Result<::test_protocols::WithProtocolEnds::StructContainingEnds> final : public ::fit::result<::fidl::Error, ::test_protocols::WithProtocolEndsStructContainingEndsResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::WithProtocolEndsStructContainingEndsResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds> request) const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds> request) const;

  ::fidl::internal::NaturalThenable<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds> request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::WithProtocolEnds> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::WithProtocolEnds>> {
 public:
  ::fidl::Result<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds> request);

  ::fidl::Result<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds> request);

  ::fidl::Result<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds> request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithProtocolEnds> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithProtocolEnds>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithProtocolEnds>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::WithProtocolEnds> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithProtocolEnds>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::WithProtocolEnds>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::WithProtocolEnds> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::WithProtocolEnds>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::WithProtocolEnds::StructContainingEnds> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::WithProtocolEnds::StructContainingEnds> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::WithProtocolEnds> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithProtocolEnds;

  using Handler = fidl::ProtocolHandler<::test_protocols::WithProtocolEnds>;

  using ClientEndsRequest = ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>;
  using ClientEndsCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithProtocolEnds::ClientEnds>;

  virtual void ClientEnds(ClientEndsRequest& request,
                          ClientEndsCompleter::Sync& completer) = 0;

  using ServerEndsRequest = ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>;
  using ServerEndsCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithProtocolEnds::ServerEnds>;

  virtual void ServerEnds(ServerEndsRequest& request,
                          ServerEndsCompleter::Sync& completer) = 0;

  using StructContainingEndsRequest = ::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds>;
  using StructContainingEndsCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::WithProtocolEnds::StructContainingEnds>;

  virtual void StructContainingEnds(StructContainingEndsRequest& request,
                                    StructContainingEndsCompleter::Sync& completer) = 0;

  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl = this, dispatcher = dispatcher](::fidl::ServerEnd<::test_protocols::WithProtocolEnds> request) {
      (void)::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::WithProtocolEnds> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::WithProtocolEnds>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::ManyParameters::Fifteen> {
  using Request = ::test_protocols::ManyParametersFifteenRequest;

  using Completer = fidl::Completer<>;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::ManyParameters> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fit::result<::fidl::OneWayError> Fifteen(const ::fidl::Request<::test_protocols::ManyParameters::Fifteen>& request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::ManyParameters> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::ManyParameters>> {
 public:
  ::fit::result<::fidl::OneWayError> Fifteen(const ::fidl::Request<::test_protocols::ManyParameters::Fifteen>& request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::ManyParameters>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ManyParameters> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::ManyParameters>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ManyParameters>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::ManyParameters>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ManyParameters>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::ManyParameters> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ManyParameters>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::ManyParameters>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::ManyParameters> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::ManyParameters>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::ManyParameters>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

#endif  // __Fuchsia__

template <>
class ::fidl::Server<::test_protocols::ManyParameters> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ManyParameters;

  using Handler = fidl::ProtocolHandler<::test_protocols::ManyParameters>;

  using FifteenRequest = ::fidl::Request<::test_protocols::ManyParameters::Fifteen>;
  using FifteenCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::ManyParameters::Fifteen>;

  virtual void Fifteen(FifteenRequest& request,
                       FifteenCompleter::Sync& completer) = 0;

  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl = this, dispatcher = dispatcher](::fidl::ServerEnd<::test_protocols::ManyParameters> request) {
      (void)::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::ManyParameters> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::ManyParameters>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_protocols::MethodWithUnion::UnionMethod> {
  using Request = ::test_protocols::MethodWithUnionUnionMethodRequest;

  using Response = ::test_protocols::MethodWithUnionUnionMethodResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_protocols::MethodWithUnion::UnionMethod>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_protocols::MethodWithUnion::UnionMethod>&)>;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodRequestTable;

__LOCAL extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::MethodWithUnion::UnionMethod> final : public ::test_protocols::MethodWithUnionUnionMethodResponse {
 public:
  using ::test_protocols::MethodWithUnionUnionMethodResponse::MethodWithUnionUnionMethodResponse;
  Response(::test_protocols::MethodWithUnionUnionMethodResponse v) : MethodWithUnionUnionMethodResponse(std::move(v)) {}
};
namespace test_protocols {
}  // namespace test_protocols

template <>
class ::fidl::Result<::test_protocols::MethodWithUnion::UnionMethod> final : public ::fit::result<::fidl::Error, ::test_protocols::MethodWithUnionUnionMethodResponse> {
 public:
  using ::fit::result<::fidl::Error, ::test_protocols::MethodWithUnionUnionMethodResponse>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::MethodWithUnion> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(const ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>& request) const;
};
namespace test_protocols {

#endif  // __Fuchsia__

}  // namespace test_protocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_protocols::MethodWithUnion> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_protocols::MethodWithUnion>> {
 public:
  ::fidl::Result<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(const ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>& request);

 private:
  ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::MethodWithUnion> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::MethodWithUnion>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::SyncEventHandler<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_protocols::MethodWithUnion>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::MethodWithUnion> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_protocols::MethodWithUnion>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_protocols::MethodWithUnion>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::MethodWithUnion> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_protocols::MethodWithUnion>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_protocols::MethodWithUnion::UnionMethod> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_protocols::MethodWithUnion::UnionMethod>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::MethodWithUnion> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::MethodWithUnion;

  using Handler = fidl::ProtocolHandler<::test_protocols::MethodWithUnion>;

  using UnionMethodRequest = ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>;
  using UnionMethodCompleter = ::fidl::internal::NaturalCompleter<::test_protocols::MethodWithUnion::UnionMethod>;

  virtual void UnionMethod(UnionMethodRequest& request,
                           UnionMethodCompleter::Sync& completer) = 0;

  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl = this, dispatcher = dispatcher](::fidl::ServerEnd<::test_protocols::MethodWithUnion> request) {
      (void)::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::MethodWithUnion> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::MethodWithUnion>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

#pragma clang diagnostic pop
