// WARNING: This file is machine generated by fidlgen.
  
  // fidl_experiment = no_optional_structs
  // fidl_experiment = output_index_json
  // fidl_experiment = simple_empty_response_syntax
  // fidl_experiment = unknown_interactions
  // fidl_experiment = unknown_interactions_mandate

  #pragma once

  #include <cinttypes>

  #include <lib/fidl/cpp/wire/internal/transport_err.h>
  #include <lib/fidl/cpp/wire/array.h>
  #include <lib/fidl/cpp/wire/envelope.h>
  #include <lib/fidl/cpp/wire/message_storage.h>
  #include <lib/fidl/cpp/wire/message.h>
  #include <lib/fidl/cpp/wire/object_view.h>
  #include <lib/fidl/cpp/wire/string_view.h>
  #include <lib/fidl/cpp/wire/traits.h>
  #include <lib/fidl/cpp/wire/wire_types.h>
  #include <lib/stdcompat/optional.h>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>
    #include <lib/zx/handle.h>
    #include <lib/zx/vmo.h>
    

#endif  // __Fuchsia__


  #include <fidl/test.typesinprotocols/cpp/markers.h>
  #include <fidl/test.typesinprotocols/cpp/common_types.h>
  

  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wshadow"

  namespace test_typesinprotocols {


  
namespace wire {
using Bits = ::test_typesinprotocols::Bits;
  

using Enum = ::test_typesinprotocols::Enum;
  


struct Struct;


struct ResourceStruct;


struct Basic;


struct Compound;


struct ArrayBasic;


struct ArrayCompound;


struct VectorBasic;


struct VectorCompound;


struct VectorOptional;


struct ArrayVectorNested;


struct Resource;


struct ProtocolErrorBasicTopResponse;


struct ProtocolErrorCompoundTopResponse;


struct ProtocolErrorArrayBasicTopResponse;


struct ProtocolErrorArrayCompoundTopResponse;


struct ProtocolErrorVectorBasicTopResponse;


struct ProtocolErrorVectorCompoundTopResponse;


struct ProtocolErrorVectorOptionalTopResponse;


struct ProtocolErrorArrayVectorNestedTopResponse;


struct ProtocolErrorResourceTopResponse;
  


class Table;


class ResourceTable;
  


class Union;


class ResourceUnion;


class ProtocolErrorBasicResult;


class ProtocolErrorCompoundResult;


class ProtocolErrorArrayBasicResult;


class ProtocolErrorArrayCompoundResult;


class ProtocolErrorVectorBasicResult;


class ProtocolErrorVectorCompoundResult;


class ProtocolErrorVectorOptionalResult;


class ProtocolErrorArrayVectorNestedResult;


class ProtocolErrorResourceResult;
    



extern "C" const fidl_type_t test_typesinprotocols_StructTable;

struct Struct {

    uint8_t __reserved = {};
};
    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ResourceStructTable;

struct ResourceStruct {

    uint8_t __reserved = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  


}  // namespace wire
}  // namespace test_typesinprotocols

template<>
class ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>;
template<>
class ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>;

template <>
struct ::fidl::WireTableFrame<::test_typesinprotocols::wire::Table> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;

  friend class ::test_typesinprotocols::wire::Table;
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>>;
};

namespace test_typesinprotocols {
namespace wire {

extern "C" const fidl_type_t test_typesinprotocols_TableTable;

class Table {
public:
  Table() = default;
  Table(const Table& other) noexcept = default;
  Table& operator=(const Table& other) noexcept = default;
  Table(Table&& other) noexcept = default;
  Table& operator=(Table&& other) noexcept = default;

  ~Table() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>> frame);
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES


  explicit Table(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit Table(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>> frame_ptr_;
};}  // namespace wire
}  // namespace test_typesinprotocols

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_typesinprotocols::wire::Table Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_typesinprotocols::wire::Table t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_typesinprotocols::wire::Table table_;
};

template<>
class ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table> final : public ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>>;

 public:
 private:
  friend class ::test_typesinprotocols::wire::Table;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table> final : public ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>>;

 private:
  friend class ::test_typesinprotocols::wire::Table;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>::FromExternal(frame)) {}
};namespace test_typesinprotocols {
namespace wire {

inline ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table> Table::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table> Table::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>(std::move(frame));
}

#ifdef __Fuchsia__


}  // namespace wire
}  // namespace test_typesinprotocols

template<>
class ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>;
template<>
class ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>;

template <>
struct ::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;

  friend class ::test_typesinprotocols::wire::ResourceTable;
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>>;
};

namespace test_typesinprotocols {
namespace wire {

extern "C" const fidl_type_t test_typesinprotocols_ResourceTableTable;

class ResourceTable {
public:
  ResourceTable() = default;
  ResourceTable(const ResourceTable& other) noexcept = default;
  ResourceTable& operator=(const ResourceTable& other) noexcept = default;
  ResourceTable(ResourceTable&& other) noexcept = default;
  ResourceTable& operator=(ResourceTable&& other) noexcept = default;

  ~ResourceTable() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;
  void _CloseHandles();

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>> frame);
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES


  explicit ResourceTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit ResourceTable(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>> frame_ptr_;
};}  // namespace wire
}  // namespace test_typesinprotocols

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_typesinprotocols::wire::ResourceTable Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_typesinprotocols::wire::ResourceTable t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_typesinprotocols::wire::ResourceTable table_;
};

template<>
class ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>>;

 public:
 private:
  friend class ::test_typesinprotocols::wire::ResourceTable;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>>;

 private:
  friend class ::test_typesinprotocols::wire::ResourceTable;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>::FromExternal(frame)) {}
};namespace test_typesinprotocols {
namespace wire {

inline ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable> ResourceTable::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable> ResourceTable::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>(std::move(frame));
}

#endif  // __Fuchsia__

  



extern "C" const fidl_type_t test_typesinprotocols_UnionTable;

class Union {
  public:

  Union() : ordinal_(::test_typesinprotocols::wire::Union::Ordinal::Invalid), envelope_{} {}

  Union(const Union&) = default;
  Union& operator=(const Union&) = default;
  Union(Union&&) = default;
  Union& operator=(Union&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_typesinprotocols::wire::Union::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::Union::Ordinal::Invalid; }

  bool is_b() const { return ordinal_ == ::test_typesinprotocols::wire::Union::Ordinal::kB; }
  
  static Union WithB(bool val) {
    Union result;
    result.ordinal_ = ::test_typesinprotocols::wire::Union::Ordinal::kB;
    result.envelope_.As<bool>().set_data(std::move(val));
    return result;
  }


  bool& b() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::Union::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }
  const bool& b() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::Union::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }
  ::test_typesinprotocols::wire::Union::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::Union::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ResourceUnionTable;

class ResourceUnion {
  public:

  ResourceUnion() : ordinal_(::test_typesinprotocols::wire::ResourceUnion::Ordinal::Invalid), envelope_{} {}

  
  ~ResourceUnion();
  ResourceUnion(ResourceUnion&& other) {
    _Move(std::move(other));
  }
  ResourceUnion& operator=(ResourceUnion&& other) {
    if (this != &other) {
      _Move(std::move(other));
    }
    return *this;
  }

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_typesinprotocols::wire::ResourceUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ResourceUnion::Ordinal::Invalid; }

  bool is_b() const { return ordinal_ == ::test_typesinprotocols::wire::ResourceUnion::Ordinal::kB; }
  
  static ResourceUnion WithB(bool val) {
    ResourceUnion result;
    result.ordinal_ = ::test_typesinprotocols::wire::ResourceUnion::Ordinal::kB;
    result.envelope_.As<bool>().set_data(std::move(val));
    return result;
  }


  bool& b() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ResourceUnion::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }
  const bool& b() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ResourceUnion::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }
  ::test_typesinprotocols::wire::ResourceUnion::Tag Which() const;
  void _CloseHandles();

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };
  void _Move(ResourceUnion&& other);

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ResourceUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

#endif  // __Fuchsia__




extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorBasic_ResultTable;

class ProtocolErrorBasicResult {
  public:

  ProtocolErrorBasicResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::Invalid), envelope_{} {}

  ProtocolErrorBasicResult(const ProtocolErrorBasicResult&) = default;
  ProtocolErrorBasicResult& operator=(const ProtocolErrorBasicResult&) = default;
  ProtocolErrorBasicResult(ProtocolErrorBasicResult&&) = default;
  ProtocolErrorBasicResult& operator=(ProtocolErrorBasicResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kResponse; }
  
  static ProtocolErrorBasicResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Basic> val) {
    ProtocolErrorBasicResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kResponse;
    result.envelope_.As<::test_typesinprotocols::wire::Basic>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ProtocolErrorBasicResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Basic>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_typesinprotocols::wire::Basic& response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::Basic>().get_data();
  }
  const ::test_typesinprotocols::wire::Basic& response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::Basic>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kErr; }
  
  static ProtocolErrorBasicResult WithErr(uint32_t val) {
    ProtocolErrorBasicResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorCompound_ResultTable;

class ProtocolErrorCompoundResult {
  public:

  ProtocolErrorCompoundResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::Invalid), envelope_{} {}

  ProtocolErrorCompoundResult(const ProtocolErrorCompoundResult&) = default;
  ProtocolErrorCompoundResult& operator=(const ProtocolErrorCompoundResult&) = default;
  ProtocolErrorCompoundResult(ProtocolErrorCompoundResult&&) = default;
  ProtocolErrorCompoundResult& operator=(ProtocolErrorCompoundResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kResponse; }
  
  static ProtocolErrorCompoundResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Compound> val) {
    ProtocolErrorCompoundResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kResponse;
    result.envelope_.As<::test_typesinprotocols::wire::Compound>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ProtocolErrorCompoundResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Compound>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_typesinprotocols::wire::Compound& response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::Compound>().get_data();
  }
  const ::test_typesinprotocols::wire::Compound& response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::Compound>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kErr; }
  
  static ProtocolErrorCompoundResult WithErr(uint32_t val) {
    ProtocolErrorCompoundResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorArrayBasic_ResultTable;

class ProtocolErrorArrayBasicResult {
  public:

  ProtocolErrorArrayBasicResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::Invalid), envelope_{} {}

  ProtocolErrorArrayBasicResult(const ProtocolErrorArrayBasicResult&) = default;
  ProtocolErrorArrayBasicResult& operator=(const ProtocolErrorArrayBasicResult&) = default;
  ProtocolErrorArrayBasicResult(ProtocolErrorArrayBasicResult&&) = default;
  ProtocolErrorArrayBasicResult& operator=(ProtocolErrorArrayBasicResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kResponse; }
  
  static ProtocolErrorArrayBasicResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayBasic> val) {
    ProtocolErrorArrayBasicResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kResponse;
    result.envelope_.As<::test_typesinprotocols::wire::ArrayBasic>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ProtocolErrorArrayBasicResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayBasic>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_typesinprotocols::wire::ArrayBasic& response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::ArrayBasic>().get_data();
  }
  const ::test_typesinprotocols::wire::ArrayBasic& response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::ArrayBasic>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kErr; }
  
  static ProtocolErrorArrayBasicResult WithErr(uint32_t val) {
    ProtocolErrorArrayBasicResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorArrayCompound_ResultTable;

class ProtocolErrorArrayCompoundResult {
  public:

  ProtocolErrorArrayCompoundResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::Invalid), envelope_{} {}

  ProtocolErrorArrayCompoundResult(const ProtocolErrorArrayCompoundResult&) = default;
  ProtocolErrorArrayCompoundResult& operator=(const ProtocolErrorArrayCompoundResult&) = default;
  ProtocolErrorArrayCompoundResult(ProtocolErrorArrayCompoundResult&&) = default;
  ProtocolErrorArrayCompoundResult& operator=(ProtocolErrorArrayCompoundResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kResponse; }
  
  static ProtocolErrorArrayCompoundResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayCompound> val) {
    ProtocolErrorArrayCompoundResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kResponse;
    result.envelope_.As<::test_typesinprotocols::wire::ArrayCompound>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ProtocolErrorArrayCompoundResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayCompound>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_typesinprotocols::wire::ArrayCompound& response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::ArrayCompound>().get_data();
  }
  const ::test_typesinprotocols::wire::ArrayCompound& response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::ArrayCompound>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kErr; }
  
  static ProtocolErrorArrayCompoundResult WithErr(uint32_t val) {
    ProtocolErrorArrayCompoundResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorVectorBasic_ResultTable;

class ProtocolErrorVectorBasicResult {
  public:

  ProtocolErrorVectorBasicResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::Invalid), envelope_{} {}

  ProtocolErrorVectorBasicResult(const ProtocolErrorVectorBasicResult&) = default;
  ProtocolErrorVectorBasicResult& operator=(const ProtocolErrorVectorBasicResult&) = default;
  ProtocolErrorVectorBasicResult(ProtocolErrorVectorBasicResult&&) = default;
  ProtocolErrorVectorBasicResult& operator=(ProtocolErrorVectorBasicResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kResponse; }
  
  static ProtocolErrorVectorBasicResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorBasic> val) {
    ProtocolErrorVectorBasicResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kResponse;
    result.envelope_.As<::test_typesinprotocols::wire::VectorBasic>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ProtocolErrorVectorBasicResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorBasic>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_typesinprotocols::wire::VectorBasic& response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::VectorBasic>().get_data();
  }
  const ::test_typesinprotocols::wire::VectorBasic& response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::VectorBasic>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kErr; }
  
  static ProtocolErrorVectorBasicResult WithErr(uint32_t val) {
    ProtocolErrorVectorBasicResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorVectorCompound_ResultTable;

class ProtocolErrorVectorCompoundResult {
  public:

  ProtocolErrorVectorCompoundResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::Invalid), envelope_{} {}

  ProtocolErrorVectorCompoundResult(const ProtocolErrorVectorCompoundResult&) = default;
  ProtocolErrorVectorCompoundResult& operator=(const ProtocolErrorVectorCompoundResult&) = default;
  ProtocolErrorVectorCompoundResult(ProtocolErrorVectorCompoundResult&&) = default;
  ProtocolErrorVectorCompoundResult& operator=(ProtocolErrorVectorCompoundResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kResponse; }
  
  static ProtocolErrorVectorCompoundResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorCompound> val) {
    ProtocolErrorVectorCompoundResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kResponse;
    result.envelope_.As<::test_typesinprotocols::wire::VectorCompound>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ProtocolErrorVectorCompoundResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorCompound>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_typesinprotocols::wire::VectorCompound& response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::VectorCompound>().get_data();
  }
  const ::test_typesinprotocols::wire::VectorCompound& response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::VectorCompound>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kErr; }
  
  static ProtocolErrorVectorCompoundResult WithErr(uint32_t val) {
    ProtocolErrorVectorCompoundResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorVectorOptional_ResultTable;

class ProtocolErrorVectorOptionalResult {
  public:

  ProtocolErrorVectorOptionalResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::Invalid), envelope_{} {}

  ProtocolErrorVectorOptionalResult(const ProtocolErrorVectorOptionalResult&) = default;
  ProtocolErrorVectorOptionalResult& operator=(const ProtocolErrorVectorOptionalResult&) = default;
  ProtocolErrorVectorOptionalResult(ProtocolErrorVectorOptionalResult&&) = default;
  ProtocolErrorVectorOptionalResult& operator=(ProtocolErrorVectorOptionalResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kResponse; }
  
  static ProtocolErrorVectorOptionalResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorOptional> val) {
    ProtocolErrorVectorOptionalResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kResponse;
    result.envelope_.As<::test_typesinprotocols::wire::VectorOptional>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ProtocolErrorVectorOptionalResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorOptional>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_typesinprotocols::wire::VectorOptional& response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::VectorOptional>().get_data();
  }
  const ::test_typesinprotocols::wire::VectorOptional& response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::VectorOptional>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kErr; }
  
  static ProtocolErrorVectorOptionalResult WithErr(uint32_t val) {
    ProtocolErrorVectorOptionalResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorArrayVectorNested_ResultTable;

class ProtocolErrorArrayVectorNestedResult {
  public:

  ProtocolErrorArrayVectorNestedResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::Invalid), envelope_{} {}

  ProtocolErrorArrayVectorNestedResult(const ProtocolErrorArrayVectorNestedResult&) = default;
  ProtocolErrorArrayVectorNestedResult& operator=(const ProtocolErrorArrayVectorNestedResult&) = default;
  ProtocolErrorArrayVectorNestedResult(ProtocolErrorArrayVectorNestedResult&&) = default;
  ProtocolErrorArrayVectorNestedResult& operator=(ProtocolErrorArrayVectorNestedResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kResponse; }
  
  static ProtocolErrorArrayVectorNestedResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayVectorNested> val) {
    ProtocolErrorArrayVectorNestedResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kResponse;
    result.envelope_.As<::test_typesinprotocols::wire::ArrayVectorNested>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ProtocolErrorArrayVectorNestedResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayVectorNested>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_typesinprotocols::wire::ArrayVectorNested& response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::ArrayVectorNested>().get_data();
  }
  const ::test_typesinprotocols::wire::ArrayVectorNested& response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::ArrayVectorNested>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kErr; }
  
  static ProtocolErrorArrayVectorNestedResult WithErr(uint32_t val) {
    ProtocolErrorArrayVectorNestedResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorResource_ResultTable;

class ProtocolErrorResourceResult {
  public:

  ProtocolErrorResourceResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::Invalid), envelope_{} {}

  
  ~ProtocolErrorResourceResult();
  ProtocolErrorResourceResult(ProtocolErrorResourceResult&& other) {
    _Move(std::move(other));
  }
  ProtocolErrorResourceResult& operator=(ProtocolErrorResourceResult&& other) {
    if (this != &other) {
      _Move(std::move(other));
    }
    return *this;
  }

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kResponse; }
  
  static ProtocolErrorResourceResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Resource> val) {
    ProtocolErrorResourceResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kResponse;
    result.envelope_.As<::test_typesinprotocols::wire::Resource>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static ProtocolErrorResourceResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Resource>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_typesinprotocols::wire::Resource& response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::Resource>().get_data();
  }
  const ::test_typesinprotocols::wire::Resource& response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::Resource>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kErr; }
  
  static ProtocolErrorResourceResult WithErr(uint32_t val) {
    ProtocolErrorResourceResult result;
    result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag>(ordinal_);
  }
  void _CloseHandles();

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };
  void _Move(ProtocolErrorResourceResult&& other);

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

#endif  // __Fuchsia__

  
  
    
    
    



extern "C" const fidl_type_t test_typesinprotocols_BasicTable;

struct Basic {

    uint8_t uint8 = {};

    uint16_t uint16 = {};

    uint32_t uint32 = {};

    uint64_t uint64 = {};

    int8_t int8 = {};

    int16_t int16 = {};

    int32_t int32 = {};

    int64_t int64 = {};

    float float32 = {};

    double float64 = {};

    ::fidl::StringView string = {};

    ::fidl::StringView opt_string = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_CompoundTable;

struct Compound {

    ::test_typesinprotocols::wire::Bits bits = {};

    ::test_typesinprotocols::wire::Enum enum_ = {};

    ::test_typesinprotocols::wire::Struct struct_ = {};

    ::test_typesinprotocols::wire::Table table = {};

    ::test_typesinprotocols::wire::Union union_ = {};

    ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct = {};

    ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_ArrayBasicTable;

struct ArrayBasic {

    ::fidl::Array<uint8_t, 5> array_uint8 = {};

    ::fidl::Array<uint16_t, 5> array_uint16 = {};

    ::fidl::Array<uint32_t, 5> array_uint32 = {};

    ::fidl::Array<uint64_t, 5> array_uint64 = {};

    ::fidl::Array<int8_t, 5> array_int8 = {};

    ::fidl::Array<int16_t, 5> array_int16 = {};

    ::fidl::Array<int32_t, 5> array_int32 = {};

    ::fidl::Array<int64_t, 5> array_int64 = {};

    ::fidl::Array<float, 5> array_float32 = {};

    ::fidl::Array<double, 5> array_float64 = {};

    ::fidl::Array<::fidl::StringView, 5> array_string = {};

    ::fidl::Array<::fidl::StringView, 5> array_opt_string = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_ArrayCompoundTable;

struct ArrayCompound {

    ::fidl::Array<::test_typesinprotocols::wire::Bits, 5> array_bits = {};

    ::fidl::Array<::test_typesinprotocols::wire::Enum, 5> array_enum = {};

    ::fidl::Array<::test_typesinprotocols::wire::Struct, 5> array_struct = {};

    ::fidl::Array<::test_typesinprotocols::wire::Table, 5> array_table = {};

    ::fidl::Array<::test_typesinprotocols::wire::Union, 5> array_union = {};

    ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5> array_opt_struct = {};

    ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5> array_opt_union = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_VectorBasicTable;

struct VectorBasic {

    ::fidl::VectorView<uint8_t> vector_uint8 = {};

    ::fidl::VectorView<uint16_t> vector_uint16 = {};

    ::fidl::VectorView<uint32_t> vector_uint32 = {};

    ::fidl::VectorView<uint64_t> vector_uint64 = {};

    ::fidl::VectorView<int8_t> vector_int8 = {};

    ::fidl::VectorView<int16_t> vector_int16 = {};

    ::fidl::VectorView<int32_t> vector_int32 = {};

    ::fidl::VectorView<int64_t> vector_int64 = {};

    ::fidl::VectorView<float> vector_float32 = {};

    ::fidl::VectorView<double> vector_float64 = {};

    ::fidl::VectorView<::fidl::StringView> vector_string = {};

    ::fidl::VectorView<::fidl::StringView> vector_opt_string = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_VectorCompoundTable;

struct VectorCompound {

    ::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits = {};

    ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum = {};

    ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct = {};

    ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table = {};

    ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union = {};

    ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct = {};

    ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_VectorOptionalTable;

struct VectorOptional {

    ::fidl::VectorView<uint8_t> opt_vector_uint8 = {};

    ::fidl::VectorView<::fidl::StringView> opt_vector_string = {};

    ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct = {};

    ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_ArrayVectorNestedTable;

struct ArrayVectorNested {

    ::fidl::Array<::fidl::Array<uint8_t, 5>, 5> array_array_uint8 = {};

    ::fidl::Array<::fidl::VectorView<uint8_t>, 5> array_vector_uint8 = {};

    ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8 = {};

    ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8 = {};
};
    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ResourceTable;

struct Resource {

    ::zx::handle handle = {};

    ::zx::vmo vmo = {};

    ::fidl::ClientEnd<::test_typesinprotocols::Protocol> client_end = {};

    ::fidl::ServerEnd<::test_typesinprotocols::Protocol> server_end = {};

    ::test_typesinprotocols::wire::ResourceStruct struct_ = {};

    ::test_typesinprotocols::wire::ResourceTable table = {};

    ::test_typesinprotocols::wire::ResourceUnion union_ = {};

    ::zx::handle opt_handle = {};

    ::zx::vmo opt_vmo = {};

    ::fidl::ClientEnd<::test_typesinprotocols::Protocol> opt_client_end = {};

    ::fidl::ServerEnd<::test_typesinprotocols::Protocol> opt_server_end = {};

    ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct = {};

    ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union = {};

    ::fidl::Array<::zx::handle, 5> array_handle = {};

    ::fidl::Array<::zx::vmo, 5> array_vmo = {};

    ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> array_client_end = {};

    ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> array_server_end = {};

    ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5> array_struct = {};

    ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5> array_table = {};

    ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5> array_union = {};

    ::fidl::VectorView<::zx::handle> vector_handle = {};

    ::fidl::VectorView<::zx::vmo> vector_vmo = {};

    ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end = {};

    ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end = {};

    ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct = {};

    ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table = {};

    ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorBasicTopResponseTable;

struct ProtocolErrorBasicTopResponse {
  using Result = test_typesinprotocols::wire::ProtocolErrorBasicResult;

    ::test_typesinprotocols::wire::ProtocolErrorBasicResult result = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorCompoundTopResponseTable;

struct ProtocolErrorCompoundTopResponse {
  using Result = test_typesinprotocols::wire::ProtocolErrorCompoundResult;

    ::test_typesinprotocols::wire::ProtocolErrorCompoundResult result = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayBasicTopResponseTable;

struct ProtocolErrorArrayBasicTopResponse {
  using Result = test_typesinprotocols::wire::ProtocolErrorArrayBasicResult;

    ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult result = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayCompoundTopResponseTable;

struct ProtocolErrorArrayCompoundTopResponse {
  using Result = test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult;

    ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult result = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorBasicTopResponseTable;

struct ProtocolErrorVectorBasicTopResponse {
  using Result = test_typesinprotocols::wire::ProtocolErrorVectorBasicResult;

    ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult result = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorCompoundTopResponseTable;

struct ProtocolErrorVectorCompoundTopResponse {
  using Result = test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult;

    ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult result = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorOptionalTopResponseTable;

struct ProtocolErrorVectorOptionalTopResponse {
  using Result = test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult;

    ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult result = {};
};
    



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayVectorNestedTopResponseTable;

struct ProtocolErrorArrayVectorNestedTopResponse {
  using Result = test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult;

    ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult result = {};
};
    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorResourceTopResponseTable;

struct ProtocolErrorResourceTopResponse {
  using Result = test_typesinprotocols::wire::ProtocolErrorResourceResult;

    ::test_typesinprotocols::wire::ProtocolErrorResourceResult result = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__


  }  // namespace wire
}  // namespace test_typesinprotocols
namespace fidl {


  
template <bool IsRecursive>
struct internal::WireCodingTraits<::test_typesinprotocols::wire::Bits, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = sizeof(uint32_t);
  static constexpr bool is_memcpy_compatible = true;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Bits* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<::test_typesinprotocols::wire::Bits>() = *value;
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};


  
template <bool IsRecursive>
struct internal::WireCodingTraits<::test_typesinprotocols::wire::Enum, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = sizeof(uint32_t);
  static constexpr bool is_memcpy_compatible = true;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Enum* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<::test_typesinprotocols::wire::Enum>() = *value;
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};


  


template<>
struct TypeTraits<::test_typesinprotocols::wire::Struct> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::Struct> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::Struct> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::Struct>);
static_assert(offsetof(::test_typesinprotocols::wire::Struct, __reserved) == 0);
static_assert(sizeof(::test_typesinprotocols::wire::Struct) == TypeTraits<::test_typesinprotocols::wire::Struct>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Struct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::Struct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Struct* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::Struct));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_typesinprotocols::wire::ResourceStruct> : public std::true_type {};

template<>
struct TypeTraits<::test_typesinprotocols::wire::ResourceStruct> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ResourceStruct> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ResourceStruct> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ResourceStruct>);
static_assert(offsetof(::test_typesinprotocols::wire::ResourceStruct, __reserved) == 0);
static_assert(sizeof(::test_typesinprotocols::wire::ResourceStruct) == TypeTraits<::test_typesinprotocols::wire::ResourceStruct>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ResourceStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ResourceStruct* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ResourceStruct));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};

#endif  // __Fuchsia__



template<>
struct TypeTraits<::test_typesinprotocols::wire::Basic> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 80;
  static constexpr uint32_t kPrimarySizeV1 = 80;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::Basic> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::Basic> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::Basic>);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint16) == 2);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint32) == 4);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint64) == 8);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int8) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int16) == 18);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int32) == 20);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int64) == 24);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, float32) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, float64) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, string) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, opt_string) == 64);
static_assert(sizeof(::test_typesinprotocols::wire::Basic) == TypeTraits<::test_typesinprotocols::wire::Basic>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 80;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<double, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<true>, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::Basic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Basic* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::Basic));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 0);
      internal::WireZeroPadding<uint64_t>(encoder, position + 16);
      internal::WireZeroPadding<uint64_t>(encoder, position + 32);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->uint8, position + 0, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->uint16, position + 2, recursion_depth);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->uint32, position + 4, recursion_depth);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->uint64, position + 8, recursion_depth);
      internal::WireCodingTraits<int8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->int8, position + 16, recursion_depth);
      internal::WireCodingTraits<int16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->int16, position + 18, recursion_depth);
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->int32, position + 20, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->int64, position + 24, recursion_depth);
      internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->float32, position + 32, recursion_depth);
      internal::WireCodingTraits<double, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->float64, position + 40, recursion_depth);
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Encode(encoder, &value->string, position + 48, recursion_depth);
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<true>, IsRecursive>::Encode(encoder, &value->opt_string, position + 64, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 2, recursion_depth);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
      internal::WireCodingTraits<int8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 16, recursion_depth);
      internal::WireCodingTraits<int16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 18, recursion_depth);
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 20, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 24, recursion_depth);
      internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 32, recursion_depth);
      internal::WireCodingTraits<double, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 40, recursion_depth);
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Decode(
        decoder, position + 48, recursion_depth);
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<true>, IsRecursive>::Decode(
        decoder, position + 64, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0x000000000000ff00ull);
    internal::WireCheckPadding<uint64_t>(decoder, position + 16, 0x000000000000ff00ull);
    internal::WireCheckPadding<uint64_t>(decoder, position + 32, 0xffffffff00000000ull);
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::Compound> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 72;
  static constexpr uint32_t kPrimarySizeV1 = 88;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::Compound> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::Compound> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::Compound>);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, bits) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, enum_) == 4);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, struct_) == 8);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, table) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, union_) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, opt_struct) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, opt_union) == 56);
static_assert(sizeof(::test_typesinprotocols::wire::Compound) == TypeTraits<::test_typesinprotocols::wire::Compound>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 72;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::Bits, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::Enum, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::Struct, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::Table, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::Union, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::Compound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Compound* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::Compound));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 8);
      internal::WireCodingTraits<::test_typesinprotocols::wire::Bits, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->bits, position + 0, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::Enum, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->enum_, position + 4, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::Struct, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->struct_, position + 8, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::Table, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->table, position + 16, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::Union, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->union_, position + 32, recursion_depth);
      internal::WireCodingTraits<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->opt_struct, position + 48, recursion_depth);
      internal::WireCodingTraits<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->opt_union, position + 56, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_typesinprotocols::wire::Bits, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::Enum, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::Struct, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::Table, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 16, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::Union, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 32, recursion_depth);
      internal::WireCodingTraits<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 48, recursion_depth);
      internal::WireCodingTraits<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
        decoder, position + 56, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 8, 0xffffffffffffff00ull);
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::ArrayBasic> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 384;
  static constexpr uint32_t kPrimarySizeV1 = 384;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ArrayBasic> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ArrayBasic> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ArrayBasic>);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint16) == 6);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint32) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint64) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int8) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int16) == 86);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int32) == 96);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int64) == 120);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_float32) == 160);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_float64) == 184);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_string) == 224);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_opt_string) == 304);
static_assert(sizeof(::test_typesinprotocols::wire::ArrayBasic) == TypeTraits<::test_typesinprotocols::wire::ArrayBasic>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 384;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<uint8_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<uint16_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<uint32_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<uint64_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<int8_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<int16_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<int32_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<int64_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<float, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<double, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::StringView, 5>, fidl::internal::WireCodingConstraintString<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::StringView, 5>, fidl::internal::WireCodingConstraintString<true>, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ArrayBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ArrayBasic* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ArrayBasic));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 0);
      internal::WireZeroPadding<uint64_t>(encoder, position + 32);
      internal::WireZeroPadding<uint64_t>(encoder, position + 80);
      internal::WireZeroPadding<uint64_t>(encoder, position + 112);
      internal::WireZeroPadding<uint64_t>(encoder, position + 176);
      internal::WireCodingTraits<::fidl::Array<uint8_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_uint8, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<uint16_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_uint16, position + 6, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<uint32_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_uint32, position + 16, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<uint64_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_uint64, position + 40, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<int8_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_int8, position + 80, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<int16_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_int16, position + 86, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<int32_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_int32, position + 96, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<int64_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_int64, position + 120, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<float, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_float32, position + 160, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<double, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_float64, position + 184, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::StringView, 5>, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Encode(encoder, &value->array_string, position + 224, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::StringView, 5>, fidl::internal::WireCodingConstraintString<true>, IsRecursive>::Encode(encoder, &value->array_opt_string, position + 304, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::Array<uint8_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<uint16_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 6, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<uint32_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 16, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<uint64_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 40, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<int8_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 80, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<int16_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 86, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<int32_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 96, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<int64_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 120, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<float, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 160, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<double, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 184, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::StringView, 5>, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Decode(
        decoder, position + 224, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::StringView, 5>, fidl::internal::WireCodingConstraintString<true>, IsRecursive>::Decode(
        decoder, position + 304, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0x0000ff0000000000ull);
    internal::WireCheckPadding<uint64_t>(decoder, position + 32, 0xffffffff00000000ull);
    internal::WireCheckPadding<uint64_t>(decoder, position + 80, 0x0000ff0000000000ull);
    internal::WireCheckPadding<uint64_t>(decoder, position + 112, 0xffffffff00000000ull);
    internal::WireCheckPadding<uint64_t>(decoder, position + 176, 0xffffffff00000000ull);
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::ArrayCompound> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 328;
  static constexpr uint32_t kPrimarySizeV1 = 408;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 40;
  static constexpr uint32_t kMaxOutOfLineV1 = 120;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ArrayCompound> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ArrayCompound> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ArrayCompound>);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_bits) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_enum) == 20);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_struct) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_table) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_union) == 128);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_opt_struct) == 208);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_opt_union) == 248);
static_assert(sizeof(::test_typesinprotocols::wire::ArrayCompound) == TypeTraits<::test_typesinprotocols::wire::ArrayCompound>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 328;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::Bits, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::Enum, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::Struct, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::Table, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::Union, 5>, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ArrayCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ArrayCompound* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ArrayCompound));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 40);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Bits, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_bits, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Enum, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_enum, position + 20, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Struct, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_struct, position + 40, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Table, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_table, position + 48, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Union, 5>, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->array_union, position + 128, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_opt_struct, position + 208, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->array_opt_union, position + 248, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Bits, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Enum, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 20, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Struct, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 40, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Table, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 48, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Union, 5>, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 128, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 208, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
        decoder, position + 248, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 40, 0xffffff0000000000ull);
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::VectorBasic> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 192;
  static constexpr uint32_t kPrimarySizeV1 = 192;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::VectorBasic> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::VectorBasic> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::VectorBasic>);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint16) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint32) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint64) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int8) == 64);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int16) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int32) == 96);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int64) == 112);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_float32) == 128);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_float64) == 144);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_string) == 160);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_opt_string) == 176);
static_assert(sizeof(::test_typesinprotocols::wire::VectorBasic) == TypeTraits<::test_typesinprotocols::wire::VectorBasic>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 192;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<uint16_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<uint32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<uint64_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<int8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<int16_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<int32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<int64_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<float>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<double>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<true>, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::VectorBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::VectorBasic* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::VectorBasic));
    } else {
      internal::WireCodingTraits<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_uint8, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<uint16_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_uint16, position + 16, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<uint32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_uint32, position + 32, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<uint64_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_uint64, position + 48, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<int8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_int8, position + 64, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<int16_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_int16, position + 80, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<int32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_int32, position + 96, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<int64_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_int64, position + 112, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<float>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_float32, position + 128, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<double>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_float64, position + 144, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::Encode(encoder, &value->vector_string, position + 160, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<true>, false>, IsRecursive>::Encode(encoder, &value->vector_opt_string, position + 176, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<uint16_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 16, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<uint32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 32, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<uint64_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 48, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<int8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 64, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<int16_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 80, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<int32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 96, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<int64_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 112, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<float>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 128, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<double>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 144, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::Decode(
        decoder, position + 160, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<true>, false>, IsRecursive>::Decode(
        decoder, position + 176, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::VectorCompound> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 112;
  static constexpr uint32_t kPrimarySizeV1 = 112;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::VectorCompound> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::VectorCompound> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::VectorCompound>);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_bits) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_enum) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_struct) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_table) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_union) == 64);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_opt_struct) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_opt_union) == 96);
static_assert(sizeof(::test_typesinprotocols::wire::VectorCompound) == TypeTraits<::test_typesinprotocols::wire::VectorCompound>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 112;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::Bits>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::Enum>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::Table>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::Union>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<false>, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<true>, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::VectorCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::VectorCompound* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::VectorCompound));
    } else {
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Bits>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_bits, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Enum>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_enum, position + 16, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_struct, position + 32, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Table>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_table, position + 48, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Union>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<false>, false>, IsRecursive>::Encode(encoder, &value->vector_union, position + 64, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_opt_struct, position + 80, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<true>, false>, IsRecursive>::Encode(encoder, &value->vector_opt_union, position + 96, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Bits>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Enum>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 16, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 32, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Table>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 48, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Union>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<false>, false>, IsRecursive>::Decode(
        decoder, position + 64, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 80, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<true>, false>, IsRecursive>::Decode(
        decoder, position + 96, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::VectorOptional> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 64;
  static constexpr uint32_t kPrimarySizeV1 = 64;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::VectorOptional> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::VectorOptional> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::VectorOptional>);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_string) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_struct) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_opt_struct) == 48);
static_assert(sizeof(::test_typesinprotocols::wire::VectorOptional) == TypeTraits<::test_typesinprotocols::wire::VectorOptional>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 64;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::VectorOptional, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::VectorOptional* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::VectorOptional));
    } else {
      internal::WireCodingTraits<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Encode(encoder, &value->opt_vector_uint8, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, true>, IsRecursive>::Encode(encoder, &value->opt_vector_string, position + 16, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Encode(encoder, &value->opt_vector_struct, position + 32, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Encode(encoder, &value->opt_vector_opt_struct, position + 48, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, true>, IsRecursive>::Decode(
        decoder, position + 16, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Decode(
        decoder, position + 32, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Decode(
        decoder, position + 48, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::ArrayVectorNested> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 144;
  static constexpr uint32_t kPrimarySizeV1 = 144;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ArrayVectorNested> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ArrayVectorNested> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ArrayVectorNested>);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, array_array_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, array_vector_uint8) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, vector_array_uint8) == 112);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, vector_vector_uint8) == 128);
static_assert(sizeof(::test_typesinprotocols::wire::ArrayVectorNested) == TypeTraits<::test_typesinprotocols::wire::ArrayVectorNested>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 144;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::Array<uint8_t, 5>, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::VectorView<uint8_t>, 5>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::Array<uint8_t, 5>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::VectorView<uint8_t>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, false>, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ArrayVectorNested, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ArrayVectorNested* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ArrayVectorNested));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 24);
      internal::WireCodingTraits<::fidl::Array<::fidl::Array<uint8_t, 5>, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_array_uint8, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::VectorView<uint8_t>, 5>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->array_vector_uint8, position + 32, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::Array<uint8_t, 5>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_array_uint8, position + 112, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::VectorView<uint8_t>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, false>, IsRecursive>::Encode(encoder, &value->vector_vector_uint8, position + 128, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::Array<::fidl::Array<uint8_t, 5>, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::VectorView<uint8_t>, 5>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 32, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::Array<uint8_t, 5>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 112, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::VectorView<uint8_t>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, false>, IsRecursive>::Decode(
        decoder, position + 128, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 24, 0xffffffffffffff00ull);
  }
};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_typesinprotocols::wire::Resource> : public std::true_type {};

template<>
struct TypeTraits<::test_typesinprotocols::wire::Resource> {
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 456;
  static constexpr uint32_t kPrimarySizeV1 = 512;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::Resource> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::Resource> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::Resource>);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, handle) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vmo) == 4);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, client_end) == 8);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, server_end) == 12);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, struct_) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, table) == 24);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, union_) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_handle) == 56);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_vmo) == 60);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_client_end) == 64);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_server_end) == 68);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_struct) == 72);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_union) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_handle) == 96);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_vmo) == 116);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_client_end) == 136);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_server_end) == 156);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_struct) == 176);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_table) == 184);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_union) == 264);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_handle) == 344);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_vmo) == 360);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_client_end) == 376);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_server_end) == 392);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_struct) == 408);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_table) == 424);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_union) == 440);
static_assert(sizeof(::test_typesinprotocols::wire::Resource) == TypeTraits<::test_typesinprotocols::wire::Resource>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Resource, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 456;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ResourceStruct, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ResourceTable, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ResourceUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::zx::handle, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::zx::vmo, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::zx::handle>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::zx::vmo>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<false>, false>, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::Resource, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Resource* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::Resource));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 16);
      internal::WireZeroPadding<uint64_t>(encoder, position + 176);
      internal::WireCodingTraits<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->handle, position + 0, recursion_depth);
      internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->vmo, position + 4, recursion_depth);
      internal::WireCodingTraits<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->client_end, position + 8, recursion_depth);
      internal::WireCodingTraits<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->server_end, position + 12, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceStruct, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->struct_, position + 16, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceTable, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->table, position + 24, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->union_, position + 40, recursion_depth);
      internal::WireCodingTraits<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, true>, IsRecursive>::Encode(encoder, &value->opt_handle, position + 56, recursion_depth);
      internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, true>, IsRecursive>::Encode(encoder, &value->opt_vmo, position + 60, recursion_depth);
      internal::WireCodingTraits<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Encode(encoder, &value->opt_client_end, position + 64, recursion_depth);
      internal::WireCodingTraits<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Encode(encoder, &value->opt_server_end, position + 68, recursion_depth);
      internal::WireCodingTraits<::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->opt_struct, position + 72, recursion_depth);
      internal::WireCodingTraits<::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->opt_union, position + 80, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::zx::handle, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->array_handle, position + 96, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::zx::vmo, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->array_vmo, position + 116, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->array_client_end, position + 136, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->array_server_end, position + 156, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_struct, position + 176, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_table, position + 184, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->array_union, position + 264, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::zx::handle>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, false>, IsRecursive>::Encode(encoder, &value->vector_handle, position + 344, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::zx::vmo>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, false>, IsRecursive>::Encode(encoder, &value->vector_vmo, position + 360, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, false>, IsRecursive>::Encode(encoder, &value->vector_client_end, position + 376, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, false>, IsRecursive>::Encode(encoder, &value->vector_server_end, position + 392, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_struct, position + 408, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_table, position + 424, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<false>, false>, IsRecursive>::Encode(encoder, &value->vector_union, position + 440, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
      internal::WireCodingTraits<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
      internal::WireCodingTraits<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
        decoder, position + 12, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceStruct, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 16, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceTable, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 24, recursion_depth);
      internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 40, recursion_depth);
      internal::WireCodingTraits<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, true>, IsRecursive>::Decode(
        decoder, position + 56, recursion_depth);
      internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, true>, IsRecursive>::Decode(
        decoder, position + 60, recursion_depth);
      internal::WireCodingTraits<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Decode(
        decoder, position + 64, recursion_depth);
      internal::WireCodingTraits<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Decode(
        decoder, position + 68, recursion_depth);
      internal::WireCodingTraits<::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 72, recursion_depth);
      internal::WireCodingTraits<::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
        decoder, position + 80, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::zx::handle, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>::Decode(
        decoder, position + 96, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::zx::vmo, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::Decode(
        decoder, position + 116, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
        decoder, position + 136, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
        decoder, position + 156, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 176, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 184, recursion_depth);
      internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 264, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::zx::handle>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, false>, IsRecursive>::Decode(
        decoder, position + 344, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::zx::vmo>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, false>, IsRecursive>::Decode(
        decoder, position + 360, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, false>, IsRecursive>::Decode(
        decoder, position + 376, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, false>, IsRecursive>::Decode(
        decoder, position + 392, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 408, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
        decoder, position + 424, recursion_depth);
      internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<false>, false>, IsRecursive>::Decode(
        decoder, position + 440, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 16, 0xffffffffffffff00ull);
    internal::WireCheckPadding<uint64_t>(decoder, position + 176, 0xffffff0000000000ull);
  }
};

#endif  // __Fuchsia__



template<>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorBasicTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorBasicTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ProtocolErrorBasicTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorBasicTopResponse>);
static_assert(offsetof(::test_typesinprotocols::wire::ProtocolErrorBasicTopResponse, result) == 0);
static_assert(sizeof(::test_typesinprotocols::wire::ProtocolErrorBasicTopResponse) == TypeTraits<::test_typesinprotocols::wire::ProtocolErrorBasicTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ProtocolErrorBasicResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ProtocolErrorBasicTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorBasicTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ProtocolErrorBasicTopResponse));
    } else {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 80;
  static constexpr uint32_t kMaxOutOfLineV1 = 112;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorCompoundTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ProtocolErrorCompoundTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorCompoundTopResponse>);
static_assert(offsetof(::test_typesinprotocols::wire::ProtocolErrorCompoundTopResponse, result) == 0);
static_assert(sizeof(::test_typesinprotocols::wire::ProtocolErrorCompoundTopResponse) == TypeTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ProtocolErrorCompoundTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorCompoundTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ProtocolErrorCompoundTopResponse));
    } else {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorArrayBasicTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ProtocolErrorArrayBasicTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorArrayBasicTopResponse>);
static_assert(offsetof(::test_typesinprotocols::wire::ProtocolErrorArrayBasicTopResponse, result) == 0);
static_assert(sizeof(::test_typesinprotocols::wire::ProtocolErrorArrayBasicTopResponse) == TypeTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ProtocolErrorArrayBasicTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorArrayBasicTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ProtocolErrorArrayBasicTopResponse));
    } else {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 368;
  static constexpr uint32_t kMaxOutOfLineV1 = 528;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundTopResponse>);
static_assert(offsetof(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundTopResponse, result) == 0);
static_assert(sizeof(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundTopResponse) == TypeTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundTopResponse));
    } else {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorVectorBasicTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ProtocolErrorVectorBasicTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorVectorBasicTopResponse>);
static_assert(offsetof(::test_typesinprotocols::wire::ProtocolErrorVectorBasicTopResponse, result) == 0);
static_assert(sizeof(::test_typesinprotocols::wire::ProtocolErrorVectorBasicTopResponse) == TypeTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ProtocolErrorVectorBasicTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorVectorBasicTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ProtocolErrorVectorBasicTopResponse));
    } else {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundTopResponse>);
static_assert(offsetof(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundTopResponse, result) == 0);
static_assert(sizeof(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundTopResponse) == TypeTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundTopResponse));
    } else {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalTopResponse>);
static_assert(offsetof(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalTopResponse, result) == 0);
static_assert(sizeof(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalTopResponse) == TypeTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalTopResponse));
    } else {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedTopResponse>);
static_assert(offsetof(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedTopResponse, result) == 0);
static_assert(sizeof(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedTopResponse) == TypeTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedTopResponse));
    } else {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_typesinprotocols::wire::ProtocolErrorResourceTopResponse> : public std::true_type {};

template<>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorResourceTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorResourceTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ProtocolErrorResourceTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorResourceTopResponse>);
static_assert(offsetof(::test_typesinprotocols::wire::ProtocolErrorResourceTopResponse, result) == 0);
static_assert(sizeof(::test_typesinprotocols::wire::ProtocolErrorResourceTopResponse) == TypeTraits<::test_typesinprotocols::wire::ProtocolErrorResourceTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ProtocolErrorResourceResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ProtocolErrorResourceTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorResourceTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ProtocolErrorResourceTopResponse));
    } else {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__

  


template <>
struct TypeTraits<::test_typesinprotocols::wire::Table> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::Table> : public std::true_type {};
template <>
struct IsTable<::test_typesinprotocols::wire::Table> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::Table>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Table, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Table* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_typesinprotocols::wire::ResourceTable> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ResourceTable> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ResourceTable> : public std::true_type {};
template <>
struct IsTable<::test_typesinprotocols::wire::ResourceTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ResourceTable>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceTable, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ResourceTable* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};

#endif  // __Fuchsia__

  


template <>
struct TypeTraits<::test_typesinprotocols::wire::Union> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::Union> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::Union> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::Union>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Union, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Union* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::Union::Tag::kB
        encode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::Union::Tag::kB
        encode_fn = ::fidl::internal::MakeEncodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_typesinprotocols::wire::Union::Tag tag = *position.As<::test_typesinprotocols::wire::Union::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_typesinprotocols::wire::Union::Tag::kB:
        decode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_typesinprotocols::wire::Union::Tag::kB:
        decode_fn = ::fidl::internal::MakeDecodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Union, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Union, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_typesinprotocols::wire::ResourceUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ResourceUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ResourceUnion> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ResourceUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ResourceUnion>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ResourceUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ResourceUnion::Tag::kB
        encode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ResourceUnion::Tag::kB
        encode_fn = ::fidl::internal::MakeEncodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_typesinprotocols::wire::ResourceUnion::Tag tag = *position.As<::test_typesinprotocols::wire::ResourceUnion::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_typesinprotocols::wire::ResourceUnion::Tag::kB:
        decode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_typesinprotocols::wire::ResourceUnion::Tag::kB:
        decode_fn = ::fidl::internal::MakeDecodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#endif  // __Fuchsia__



template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorBasicResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorBasicResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorBasicResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorBasicResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::Basic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::Basic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 80;
  static constexpr uint32_t kMaxOutOfLineV1 = 112;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorCompoundResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorCompoundResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorCompoundResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorCompoundResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::Compound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::Compound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::ArrayBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::ArrayBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 368;
  static constexpr uint32_t kMaxOutOfLineV1 = 528;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::ArrayCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::ArrayCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::VectorBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::VectorBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::VectorCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::VectorCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::VectorOptional, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::VectorOptional, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::ArrayVectorNested, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::ArrayVectorNested, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_typesinprotocols::wire::ProtocolErrorResourceResult> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult> {
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorResourceResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorResourceResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorResourceResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorResourceResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Resource, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::Resource, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Resource, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::Resource, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#endif  // __Fuchsia__


  #pragma clang diagnostic pop

  }  // namespace fidl

