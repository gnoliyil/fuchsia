// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include <fidl/test.emptystruct/cpp/natural_types.h>
#include <lib/fidl/cpp/hlcpp_conversion.h>
#include <lib/fidl/cpp/wire/service_handler.h>
#include <test/emptystruct/cpp/fidl.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace fidl {
namespace internal {

template <>
struct NaturalToHLCPPTraits<fidl::ClientEnd<::test_emptystruct::EmptyProtocol>> {
  using HLCPPType = fidl::InterfaceHandle<::test::emptystruct::EmptyProtocol>;
  static inline fidl::InterfaceHandle<::test::emptystruct::EmptyProtocol> Convert(fidl::ClientEnd<::test_emptystruct::EmptyProtocol>&& c) {
    return fidl::InterfaceHandle<::test::emptystruct::EmptyProtocol>(c.TakeChannel());
  }
};

template <>
struct NaturalToHLCPPTraits<fidl::ServerEnd<::test_emptystruct::EmptyProtocol>> {
  using HLCPPType = fidl::InterfaceRequest<::test::emptystruct::EmptyProtocol>;
  static inline fidl::InterfaceRequest<::test::emptystruct::EmptyProtocol> Convert(fidl::ServerEnd<::test_emptystruct::EmptyProtocol>&& c) {
    return fidl::InterfaceRequest<::test::emptystruct::EmptyProtocol>(c.TakeChannel());
  }
};

template <>
struct HLCPPToNaturalTraits<fidl::InterfaceHandle<::test::emptystruct::EmptyProtocol>> {
  using NaturalType = fidl::ClientEnd<::test_emptystruct::EmptyProtocol>;
  static inline fidl::ClientEnd<::test_emptystruct::EmptyProtocol> Convert(fidl::InterfaceHandle<::test::emptystruct::EmptyProtocol>&& c) {
    return fidl::ClientEnd<::test_emptystruct::EmptyProtocol>(c.TakeChannel());
  }
};

template <>
struct HLCPPToNaturalTraits<fidl::InterfaceRequest<::test::emptystruct::EmptyProtocol>> {
  using NaturalType = fidl::ServerEnd<::test_emptystruct::EmptyProtocol>;
  static inline fidl::ServerEnd<::test_emptystruct::EmptyProtocol> Convert(fidl::InterfaceRequest<::test::emptystruct::EmptyProtocol>&& c) {
    return fidl::ServerEnd<::test_emptystruct::EmptyProtocol>(c.TakeChannel());
  }
};

template <>
struct NaturalToHLCPPTraits<fidl::ProtocolHandler<::test_emptystruct::EmptyProtocol>> {
  using HLCPPType = fidl::InterfaceRequestHandler<::test::emptystruct::EmptyProtocol>;
  static inline fidl::InterfaceRequestHandler<::test::emptystruct::EmptyProtocol> Convert(fidl::ProtocolHandler<::test_emptystruct::EmptyProtocol>&& c) {
    return [c = std::move(c)](fidl::InterfaceRequest<::test::emptystruct::EmptyProtocol> r) {
      c(::fidl::HLCPPToNatural(r));
    };
  }
};

template <>
struct HLCPPToNaturalTraits<fidl::InterfaceRequestHandler<::test::emptystruct::EmptyProtocol>> {
  using NaturalType = fidl::ProtocolHandler<::test_emptystruct::EmptyProtocol>;
  static inline fidl::ProtocolHandler<::test_emptystruct::EmptyProtocol> Convert(fidl::InterfaceRequestHandler<::test::emptystruct::EmptyProtocol>&& c) {
    return [c = std::move(c)](fidl::ServerEnd<::test_emptystruct::EmptyProtocol> r) {
      c(::fidl::NaturalToHLCPP(r));
    };
  }
};

template <>
struct NaturalToHLCPPTraits<::test_emptystruct::Empty> {
  using HLCPPType = ::test::emptystruct::Empty;
  static inline ::test::emptystruct::Empty Convert(::test_emptystruct::Empty&&);
};
template <>
struct HLCPPToNaturalTraits<::test::emptystruct::Empty> {
  using NaturalType = ::test_emptystruct::Empty;
  static inline ::test_emptystruct::Empty Convert(::test::emptystruct::Empty&&);
};
template <>
struct NaturalToHLCPPTraits<::test_emptystruct::EmptyProtocolSendRequest> {
  using HLCPPType = ::test::emptystruct::EmptyProtocolSendRequest;
  static inline ::test::emptystruct::EmptyProtocolSendRequest Convert(::test_emptystruct::EmptyProtocolSendRequest&&);
};
template <>
struct HLCPPToNaturalTraits<::test::emptystruct::EmptyProtocolSendRequest> {
  using NaturalType = ::test_emptystruct::EmptyProtocolSendRequest;
  static inline ::test_emptystruct::EmptyProtocolSendRequest Convert(::test::emptystruct::EmptyProtocolSendRequest&&);
};
template <>
struct NaturalToHLCPPTraits<::test_emptystruct::EmptyProtocolReceiveRequest> {
  using HLCPPType = ::test::emptystruct::EmptyProtocolReceiveRequest;
  static inline ::test::emptystruct::EmptyProtocolReceiveRequest Convert(::test_emptystruct::EmptyProtocolReceiveRequest&&);
};
template <>
struct HLCPPToNaturalTraits<::test::emptystruct::EmptyProtocolReceiveRequest> {
  using NaturalType = ::test_emptystruct::EmptyProtocolReceiveRequest;
  static inline ::test_emptystruct::EmptyProtocolReceiveRequest Convert(::test::emptystruct::EmptyProtocolReceiveRequest&&);
};
template <>
struct NaturalToHLCPPTraits<::test_emptystruct::EmptyProtocolSendAndReceiveRequest> {
  using HLCPPType = ::test::emptystruct::EmptyProtocolSendAndReceiveRequest;
  static inline ::test::emptystruct::EmptyProtocolSendAndReceiveRequest Convert(::test_emptystruct::EmptyProtocolSendAndReceiveRequest&&);
};
template <>
struct HLCPPToNaturalTraits<::test::emptystruct::EmptyProtocolSendAndReceiveRequest> {
  using NaturalType = ::test_emptystruct::EmptyProtocolSendAndReceiveRequest;
  static inline ::test_emptystruct::EmptyProtocolSendAndReceiveRequest Convert(::test::emptystruct::EmptyProtocolSendAndReceiveRequest&&);
};
template <>
struct NaturalToHLCPPTraits<::test_emptystruct::EmptyProtocolSendAndReceiveResponse> {
  using HLCPPType = ::test::emptystruct::EmptyProtocolSendAndReceiveResponse;
  static inline ::test::emptystruct::EmptyProtocolSendAndReceiveResponse Convert(::test_emptystruct::EmptyProtocolSendAndReceiveResponse&&);
};
template <>
struct HLCPPToNaturalTraits<::test::emptystruct::EmptyProtocolSendAndReceiveResponse> {
  using NaturalType = ::test_emptystruct::EmptyProtocolSendAndReceiveResponse;
  static inline ::test_emptystruct::EmptyProtocolSendAndReceiveResponse Convert(::test::emptystruct::EmptyProtocolSendAndReceiveResponse&&);
};

::test::emptystruct::Empty NaturalToHLCPPTraits<::test_emptystruct::Empty>::Convert(::test_emptystruct::Empty&& value) {
  ::test::emptystruct::Empty hlcpp;
  hlcpp.__reserved = ::fidl::NaturalToHLCPP(std::move(value.__reserved()));
  return hlcpp;
}

::test_emptystruct::Empty HLCPPToNaturalTraits<::test::emptystruct::Empty>::Convert(::test::emptystruct::Empty&& value) {
  return ::test_emptystruct::Empty{{
      .__reserved = ::fidl::HLCPPToNatural(std::move(value.__reserved)),
  }};
}
::test::emptystruct::EmptyProtocolSendRequest NaturalToHLCPPTraits<::test_emptystruct::EmptyProtocolSendRequest>::Convert(::test_emptystruct::EmptyProtocolSendRequest&& value) {
  ::test::emptystruct::EmptyProtocolSendRequest hlcpp;
  hlcpp.e = ::fidl::NaturalToHLCPP(std::move(value.e()));
  return hlcpp;
}

::test_emptystruct::EmptyProtocolSendRequest HLCPPToNaturalTraits<::test::emptystruct::EmptyProtocolSendRequest>::Convert(::test::emptystruct::EmptyProtocolSendRequest&& value) {
  return ::test_emptystruct::EmptyProtocolSendRequest{{
      .e = ::fidl::HLCPPToNatural(std::move(value.e)),
  }};
}
::test::emptystruct::EmptyProtocolReceiveRequest NaturalToHLCPPTraits<::test_emptystruct::EmptyProtocolReceiveRequest>::Convert(::test_emptystruct::EmptyProtocolReceiveRequest&& value) {
  ::test::emptystruct::EmptyProtocolReceiveRequest hlcpp;
  hlcpp.e = ::fidl::NaturalToHLCPP(std::move(value.e()));
  return hlcpp;
}

::test_emptystruct::EmptyProtocolReceiveRequest HLCPPToNaturalTraits<::test::emptystruct::EmptyProtocolReceiveRequest>::Convert(::test::emptystruct::EmptyProtocolReceiveRequest&& value) {
  return ::test_emptystruct::EmptyProtocolReceiveRequest{{
      .e = ::fidl::HLCPPToNatural(std::move(value.e)),
  }};
}
::test::emptystruct::EmptyProtocolSendAndReceiveRequest NaturalToHLCPPTraits<::test_emptystruct::EmptyProtocolSendAndReceiveRequest>::Convert(::test_emptystruct::EmptyProtocolSendAndReceiveRequest&& value) {
  ::test::emptystruct::EmptyProtocolSendAndReceiveRequest hlcpp;
  hlcpp.e = ::fidl::NaturalToHLCPP(std::move(value.e()));
  return hlcpp;
}

::test_emptystruct::EmptyProtocolSendAndReceiveRequest HLCPPToNaturalTraits<::test::emptystruct::EmptyProtocolSendAndReceiveRequest>::Convert(::test::emptystruct::EmptyProtocolSendAndReceiveRequest&& value) {
  return ::test_emptystruct::EmptyProtocolSendAndReceiveRequest{{
      .e = ::fidl::HLCPPToNatural(std::move(value.e)),
  }};
}
::test::emptystruct::EmptyProtocolSendAndReceiveResponse NaturalToHLCPPTraits<::test_emptystruct::EmptyProtocolSendAndReceiveResponse>::Convert(::test_emptystruct::EmptyProtocolSendAndReceiveResponse&& value) {
  ::test::emptystruct::EmptyProtocolSendAndReceiveResponse hlcpp;
  hlcpp.e = ::fidl::NaturalToHLCPP(std::move(value.e()));
  return hlcpp;
}

::test_emptystruct::EmptyProtocolSendAndReceiveResponse HLCPPToNaturalTraits<::test::emptystruct::EmptyProtocolSendAndReceiveResponse>::Convert(::test::emptystruct::EmptyProtocolSendAndReceiveResponse&& value) {
  return ::test_emptystruct::EmptyProtocolSendAndReceiveResponse{{
      .e = ::fidl::HLCPPToNatural(std::move(value.e)),
  }};
}

#pragma clang diagnostic pop

}  // namespace internal
}  // namespace fidl
