// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include <cinttypes>
#include <string>

#include <lib/fidl/cpp/natural_types.h>
#include <lib/fidl/cpp/natural_coding_traits.h>

#include <fidl/test.typesinprotocols/cpp/markers.h>
#include <fidl/test.typesinprotocols/cpp/common_types.h>


#ifdef __Fuchsia__

  #include <lib/zx/channel.h>
  #include <lib/zx/handle.h>
  #include <lib/zx/vmo.h>
  

#endif  // __Fuchsia__


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_typesinprotocols {





class Struct;


class ResourceStruct;


class Basic;


class Compound;


class ArrayBasic;


class ArrayCompound;


class VectorBasic;


class VectorCompound;


class VectorOptional;


class ArrayVectorNested;


class Resource;


class ProtocolErrorBasicTopResponse;


class ProtocolErrorCompoundTopResponse;


class ProtocolErrorArrayBasicTopResponse;


class ProtocolErrorArrayCompoundTopResponse;


class ProtocolErrorVectorBasicTopResponse;


class ProtocolErrorVectorCompoundTopResponse;


class ProtocolErrorVectorOptionalTopResponse;


class ProtocolErrorArrayVectorNestedTopResponse;


class ProtocolErrorResourceTopResponse;




class Table;



class ResourceTable;




class Union;



class ResourceUnion;



class ProtocolErrorBasicResult;



class ProtocolErrorCompoundResult;



class ProtocolErrorArrayBasicResult;



class ProtocolErrorArrayCompoundResult;



class ProtocolErrorVectorBasicResult;



class ProtocolErrorVectorCompoundResult;



class ProtocolErrorVectorOptionalResult;



class ProtocolErrorArrayVectorNestedResult;



class ProtocolErrorResourceResult;




  
  
  
  
  
  
  



extern "C" const fidl_type_t test_typesinprotocols_StructTable;


class Struct {
 private:
  struct Storage_;
 public:
  Struct(Storage_ storage) noexcept;
    Struct(uint8_t __reserved) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |Struct| only if all of its members are default constructible.
  Struct() = default;
#pragma clang diagnostic pop

  Struct(Struct&&) noexcept = default;
  Struct& operator=(Struct&&) noexcept = default;
    Struct(const Struct& other) noexcept;
    Struct& operator=(const Struct& other) noexcept;

    bool operator==(const Struct& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Struct, 1>::Equal(this, &other);
    }
    bool operator!=(const Struct& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Struct, 1>::Equal(this, &other);
    }
    
      uint8_t
    __reserved() const {
      return storage_.__reserved;
    }

    
    uint8_t& __reserved() {
      return storage_.__reserved;
    }

    // Setter for __reserved.
    //
    
    Struct& __reserved(uint8_t value);

  Struct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      uint8_t __reserved
        =0u;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Struct, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::Struct>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, uint8_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::__reserved, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  



extern "C" const fidl_type_t test_typesinprotocols_TableTable;


class Table {
 private:
  struct Storage_;
 public:
  Table(Storage_ storage) noexcept;
  Table() noexcept = default;
  Table(Table&&) noexcept = default;
  Table& operator=(Table&&) noexcept = default;
    Table(const Table& other) noexcept;
    Table& operator=(const Table& other) noexcept;
    bool operator==(const Table& other) const noexcept {
      return ::fidl::internal::NaturalTableCodingTraits<::test_typesinprotocols::Table>::Equal(this, &other);
    }
    bool operator!=(const Table& other) const noexcept {
      return !::fidl::internal::NaturalTableCodingTraits<::test_typesinprotocols::Table>::Equal(this, &other);
    }

  bool IsEmpty() const {
      return true;
  }

  Table(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
  };

  // TODO(https://fxbug.dev/91252): Box the storage.
  Storage_ storage_;
    Storage_ CloneStorage_() const;
  friend struct ::fidl::internal::NaturalTableCodingTraits<::test_typesinprotocols::Table>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::Table>;
  static constexpr auto kMembers = std::make_tuple();
};

  
  
  
  



extern "C" const fidl_type_t test_typesinprotocols_UnionTable;


class Union {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , bool>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  Union(Union&& other) noexcept
      : Union(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  Union& operator=(Union&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    Union(const Union& other) noexcept : Union(other.CloneStorage_()){}
    Union& operator=(const Union& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const Union& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const Union& other) const noexcept {
      return *storage_ != *other.storage_;
    }
  constexpr bool IsUnknown() const {
    return Which() == ::test_typesinprotocols::Union::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  constexpr ::test_typesinprotocols::Union::Tag Which() const {
    return Union::IndexToTag(storage_->index()).value();
  }
    static Union WithB(bool val) {
      return Union(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> b() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> b() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the b member.
    //
    
    Union& b(bool value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }

  Union(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::Union>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit Union(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::Union::Tag tag) {
    switch (tag) {
        case ::test_typesinprotocols::Union::Tag::kB: return 1;
      default: {
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_typesinprotocols::Union::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_typesinprotocols::Union::Tag::kB;
        default: return ::test_typesinprotocols::Union::Tag::_do_not_handle_this__write_a_default_case_instead;
    }
  }

};


  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ResourceStructTable;


class ResourceStruct {
 private:
  struct Storage_;
 public:
  ResourceStruct(Storage_ storage) noexcept;
    ResourceStruct(uint8_t __reserved) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ResourceStruct| only if all of its members are default constructible.
  ResourceStruct() = default;
#pragma clang diagnostic pop

  ResourceStruct(ResourceStruct&&) noexcept = default;
  ResourceStruct& operator=(ResourceStruct&&) noexcept = default;
    
      uint8_t
    __reserved() const {
      return storage_.__reserved;
    }

    
    uint8_t& __reserved() {
      return storage_.__reserved;
    }

    // Setter for __reserved.
    //
    
    ResourceStruct& __reserved(uint8_t value);

  ResourceStruct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      uint8_t __reserved
        =0u;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ResourceStruct, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ResourceStruct>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, uint8_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::__reserved, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ResourceTableTable;


class ResourceTable {
 private:
  struct Storage_;
 public:
  ResourceTable(Storage_ storage) noexcept;
  ResourceTable() noexcept = default;
  ResourceTable(ResourceTable&&) noexcept = default;
  ResourceTable& operator=(ResourceTable&&) noexcept = default;

  bool IsEmpty() const {
      return true;
  }

  ResourceTable(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
  };

  // TODO(https://fxbug.dev/91252): Box the storage.
  Storage_ storage_;
  friend struct ::fidl::internal::NaturalTableCodingTraits<::test_typesinprotocols::ResourceTable>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ResourceTable>;
  static constexpr auto kMembers = std::make_tuple();
};


#endif  // __Fuchsia__

  
  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ResourceUnionTable;


class ResourceUnion {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , bool>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  ResourceUnion(ResourceUnion&& other) noexcept
      : ResourceUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ResourceUnion& operator=(ResourceUnion&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
  constexpr bool IsUnknown() const {
    return Which() == ::test_typesinprotocols::ResourceUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  constexpr ::test_typesinprotocols::ResourceUnion::Tag Which() const {
    return ResourceUnion::IndexToTag(storage_->index()).value();
  }
    static ResourceUnion WithB(bool val) {
      return ResourceUnion(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> b() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> b() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the b member.
    //
    
    ResourceUnion& b(bool value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }

  ResourceUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ResourceUnion>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ResourceUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ResourceUnion::Tag tag) {
    switch (tag) {
        case ::test_typesinprotocols::ResourceUnion::Tag::kB: return 1;
      default: {
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_typesinprotocols::ResourceUnion::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_typesinprotocols::ResourceUnion::Tag::kB;
        default: return ::test_typesinprotocols::ResourceUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
    }
  }

};



#endif  // __Fuchsia__

  



extern "C" const fidl_type_t test_typesinprotocols_BasicTable;


class Basic {
 private:
  struct Storage_;
 public:
  Basic(Storage_ storage) noexcept;
    Basic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::std::optional<::std::string> opt_string) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |Basic| only if all of its members are default constructible.
  Basic() = default;
#pragma clang diagnostic pop

  Basic(Basic&&) noexcept = default;
  Basic& operator=(Basic&&) noexcept = default;
    Basic(const Basic& other) noexcept;
    Basic& operator=(const Basic& other) noexcept;

    bool operator==(const Basic& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Basic, 80>::Equal(this, &other);
    }
    bool operator!=(const Basic& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Basic, 80>::Equal(this, &other);
    }
    
      uint8_t
    uint8() const {
      return storage_.uint8;
    }

    
    uint8_t& uint8() {
      return storage_.uint8;
    }

    // Setter for uint8.
    //
    
    Basic& uint8(uint8_t value);
    
      uint16_t
    uint16() const {
      return storage_.uint16;
    }

    
    uint16_t& uint16() {
      return storage_.uint16;
    }

    // Setter for uint16.
    //
    
    Basic& uint16(uint16_t value);
    
      uint32_t
    uint32() const {
      return storage_.uint32;
    }

    
    uint32_t& uint32() {
      return storage_.uint32;
    }

    // Setter for uint32.
    //
    
    Basic& uint32(uint32_t value);
    
      uint64_t
    uint64() const {
      return storage_.uint64;
    }

    
    uint64_t& uint64() {
      return storage_.uint64;
    }

    // Setter for uint64.
    //
    
    Basic& uint64(uint64_t value);
    
      int8_t
    int8() const {
      return storage_.int8;
    }

    
    int8_t& int8() {
      return storage_.int8;
    }

    // Setter for int8.
    //
    
    Basic& int8(int8_t value);
    
      int16_t
    int16() const {
      return storage_.int16;
    }

    
    int16_t& int16() {
      return storage_.int16;
    }

    // Setter for int16.
    //
    
    Basic& int16(int16_t value);
    
      int32_t
    int32() const {
      return storage_.int32;
    }

    
    int32_t& int32() {
      return storage_.int32;
    }

    // Setter for int32.
    //
    
    Basic& int32(int32_t value);
    
      int64_t
    int64() const {
      return storage_.int64;
    }

    
    int64_t& int64() {
      return storage_.int64;
    }

    // Setter for int64.
    //
    
    Basic& int64(int64_t value);
    
      float
    float32() const {
      return storage_.float32;
    }

    
    float& float32() {
      return storage_.float32;
    }

    // Setter for float32.
    //
    
    Basic& float32(float value);
    
      double
    float64() const {
      return storage_.float64;
    }

    
    double& float64() {
      return storage_.float64;
    }

    // Setter for float64.
    //
    
    Basic& float64(double value);
    
      const ::std::string &
    string() const {
      return storage_.string;
    }

    
    ::std::string& string() {
      return storage_.string;
    }

    // Setter for string.
    //
    
    Basic& string(::std::string value);
    
      const ::std::optional<::std::string> &
    opt_string() const {
      return storage_.opt_string;
    }

    
    ::std::optional<::std::string>& opt_string() {
      return storage_.opt_string;
    }

    // Setter for opt_string.
    //
    
    Basic& opt_string(::std::optional<::std::string> value);

  Basic(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      uint8_t uint8
        = {};
      uint16_t uint16
        = {};
      uint32_t uint32
        = {};
      uint64_t uint64
        = {};
      int8_t int8
        = {};
      int16_t int16
        = {};
      int32_t int32
        = {};
      int64_t int64
        = {};
      float float32
        = {};
      double float64
        = {};
      ::std::string string;
      ::std::optional<::std::string> opt_string;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Basic, 80>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::Basic>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, uint8_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::uint8, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, uint16_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::uint16, 2
      }, ::fidl::internal::NaturalStructMember<Storage_, uint32_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::uint32, 4
      }, ::fidl::internal::NaturalStructMember<Storage_, uint64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::uint64, 8
      }, ::fidl::internal::NaturalStructMember<Storage_, int8_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::int8, 16
      }, ::fidl::internal::NaturalStructMember<Storage_, int16_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::int16, 18
      }, ::fidl::internal::NaturalStructMember<Storage_, int32_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::int32, 20
      }, ::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::int64, 24
      }, ::fidl::internal::NaturalStructMember<Storage_, float, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::float32, 32
      }, ::fidl::internal::NaturalStructMember<Storage_, double, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::float64, 40
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::string, fidl::internal::NaturalCodingConstraintString<>>{
        &Storage_::string, 48
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::optional<::std::string>, fidl::internal::NaturalCodingConstraintString<>>{
        &Storage_::opt_string, 64
      });
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
        .offset = 0,
        .mask = 0x000000000000ff00ull,
      }, ::fidl::internal::NaturalStructPadding<uint64_t>{
        .offset = 16,
        .mask = 0x000000000000ff00ull,
      }, ::fidl::internal::NaturalStructPadding<uint64_t>{
        .offset = 32,
        .mask = 0xffffffff00000000ull,
      });

};


  
  
  



extern "C" const fidl_type_t test_typesinprotocols_CompoundTable;


class Compound {
 private:
  struct Storage_;
 public:
  Compound(Storage_ storage) noexcept;
    Compound(::test_typesinprotocols::Bits bits, ::test_typesinprotocols::Enum enum_, ::test_typesinprotocols::Struct struct_, ::test_typesinprotocols::Table table, ::test_typesinprotocols::Union union_, ::fidl::Box<::test_typesinprotocols::Struct> opt_struct, ::fidl::Box<::test_typesinprotocols::Union> opt_union) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |Compound| only if all of its members are default constructible.
  Compound() = default;
#pragma clang diagnostic pop

  Compound(Compound&&) noexcept = default;
  Compound& operator=(Compound&&) noexcept = default;
    Compound(const Compound& other) noexcept;
    Compound& operator=(const Compound& other) noexcept;

    bool operator==(const Compound& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Compound, 72>::Equal(this, &other);
    }
    bool operator!=(const Compound& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Compound, 72>::Equal(this, &other);
    }
    
      ::test_typesinprotocols::Bits
    bits() const {
      return storage_.bits;
    }

    
    ::test_typesinprotocols::Bits& bits() {
      return storage_.bits;
    }

    // Setter for bits.
    //
    
    Compound& bits(::test_typesinprotocols::Bits value);
    
      ::test_typesinprotocols::Enum
    enum_() const {
      return storage_.enum_;
    }

    
    ::test_typesinprotocols::Enum& enum_() {
      return storage_.enum_;
    }

    // Setter for enum_.
    //
    
    Compound& enum_(::test_typesinprotocols::Enum value);
    
      const ::test_typesinprotocols::Struct &
    struct_() const {
      return storage_.struct_;
    }

    
    ::test_typesinprotocols::Struct& struct_() {
      return storage_.struct_;
    }

    // Setter for struct_.
    //
    
    Compound& struct_(::test_typesinprotocols::Struct value);
    
      const ::test_typesinprotocols::Table &
    table() const {
      return storage_.table;
    }

    
    ::test_typesinprotocols::Table& table() {
      return storage_.table;
    }

    // Setter for table.
    //
    
    Compound& table(::test_typesinprotocols::Table value);
    
      const ::test_typesinprotocols::Union &
    union_() const {
      return storage_.union_;
    }

    
    ::test_typesinprotocols::Union& union_() {
      return storage_.union_;
    }

    // Setter for union_.
    //
    
    Compound& union_(::test_typesinprotocols::Union value);
    
      const ::fidl::Box<::test_typesinprotocols::Struct> &
    opt_struct() const {
      return storage_.opt_struct;
    }

    
    ::fidl::Box<::test_typesinprotocols::Struct>& opt_struct() {
      return storage_.opt_struct;
    }

    // Setter for opt_struct.
    //
    
    Compound& opt_struct(::fidl::Box<::test_typesinprotocols::Struct> value);
    
      const ::fidl::Box<::test_typesinprotocols::Union> &
    opt_union() const {
      return storage_.opt_union;
    }

    
    ::fidl::Box<::test_typesinprotocols::Union>& opt_union() {
      return storage_.opt_union;
    }

    // Setter for opt_union.
    //
    
    Compound& opt_union(::fidl::Box<::test_typesinprotocols::Union> value);

  Compound(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_typesinprotocols::Bits bits
        = {};
      ::test_typesinprotocols::Enum enum_
        = {};
      ::test_typesinprotocols::Struct struct_;
      ::test_typesinprotocols::Table table;
      ::test_typesinprotocols::Union union_;
      ::fidl::Box<::test_typesinprotocols::Struct> opt_struct;
      ::fidl::Box<::test_typesinprotocols::Union> opt_union;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Compound, 72>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::Compound>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::Bits, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::bits, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::Enum, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::enum_, 4
      }, ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::Struct, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::struct_, 8
      }, ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::Table, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::table, 16
      }, ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::Union, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::union_, 32
      }, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::Box<::test_typesinprotocols::Struct>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::opt_struct, 48
      }, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::Box<::test_typesinprotocols::Union>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::opt_union, 56
      });
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
        .offset = 8,
        .mask = 0xffffffffffffff00ull,
      });

};


  
  
  



extern "C" const fidl_type_t test_typesinprotocols_ArrayBasicTable;


class ArrayBasic {
 private:
  struct Storage_;
 public:
  ArrayBasic(Storage_ storage) noexcept;
    ArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::std::optional<::std::string>, 5> array_opt_string) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ArrayBasic| only if all of its members are default constructible.
  ArrayBasic() = default;
#pragma clang diagnostic pop

  ArrayBasic(ArrayBasic&&) noexcept = default;
  ArrayBasic& operator=(ArrayBasic&&) noexcept = default;
    ArrayBasic(const ArrayBasic& other) noexcept;
    ArrayBasic& operator=(const ArrayBasic& other) noexcept;

    bool operator==(const ArrayBasic& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayBasic, 384>::Equal(this, &other);
    }
    bool operator!=(const ArrayBasic& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayBasic, 384>::Equal(this, &other);
    }
    
      const ::std::array<uint8_t, 5> &
    array_uint8() const {
      return storage_.array_uint8;
    }

    
    ::std::array<uint8_t, 5>& array_uint8() {
      return storage_.array_uint8;
    }

    // Setter for array_uint8.
    //
    
    ArrayBasic& array_uint8(::std::array<uint8_t, 5> value);
    
      const ::std::array<uint16_t, 5> &
    array_uint16() const {
      return storage_.array_uint16;
    }

    
    ::std::array<uint16_t, 5>& array_uint16() {
      return storage_.array_uint16;
    }

    // Setter for array_uint16.
    //
    
    ArrayBasic& array_uint16(::std::array<uint16_t, 5> value);
    
      const ::std::array<uint32_t, 5> &
    array_uint32() const {
      return storage_.array_uint32;
    }

    
    ::std::array<uint32_t, 5>& array_uint32() {
      return storage_.array_uint32;
    }

    // Setter for array_uint32.
    //
    
    ArrayBasic& array_uint32(::std::array<uint32_t, 5> value);
    
      const ::std::array<uint64_t, 5> &
    array_uint64() const {
      return storage_.array_uint64;
    }

    
    ::std::array<uint64_t, 5>& array_uint64() {
      return storage_.array_uint64;
    }

    // Setter for array_uint64.
    //
    
    ArrayBasic& array_uint64(::std::array<uint64_t, 5> value);
    
      const ::std::array<int8_t, 5> &
    array_int8() const {
      return storage_.array_int8;
    }

    
    ::std::array<int8_t, 5>& array_int8() {
      return storage_.array_int8;
    }

    // Setter for array_int8.
    //
    
    ArrayBasic& array_int8(::std::array<int8_t, 5> value);
    
      const ::std::array<int16_t, 5> &
    array_int16() const {
      return storage_.array_int16;
    }

    
    ::std::array<int16_t, 5>& array_int16() {
      return storage_.array_int16;
    }

    // Setter for array_int16.
    //
    
    ArrayBasic& array_int16(::std::array<int16_t, 5> value);
    
      const ::std::array<int32_t, 5> &
    array_int32() const {
      return storage_.array_int32;
    }

    
    ::std::array<int32_t, 5>& array_int32() {
      return storage_.array_int32;
    }

    // Setter for array_int32.
    //
    
    ArrayBasic& array_int32(::std::array<int32_t, 5> value);
    
      const ::std::array<int64_t, 5> &
    array_int64() const {
      return storage_.array_int64;
    }

    
    ::std::array<int64_t, 5>& array_int64() {
      return storage_.array_int64;
    }

    // Setter for array_int64.
    //
    
    ArrayBasic& array_int64(::std::array<int64_t, 5> value);
    
      const ::std::array<float, 5> &
    array_float32() const {
      return storage_.array_float32;
    }

    
    ::std::array<float, 5>& array_float32() {
      return storage_.array_float32;
    }

    // Setter for array_float32.
    //
    
    ArrayBasic& array_float32(::std::array<float, 5> value);
    
      const ::std::array<double, 5> &
    array_float64() const {
      return storage_.array_float64;
    }

    
    ::std::array<double, 5>& array_float64() {
      return storage_.array_float64;
    }

    // Setter for array_float64.
    //
    
    ArrayBasic& array_float64(::std::array<double, 5> value);
    
      const ::std::array<::std::string, 5> &
    array_string() const {
      return storage_.array_string;
    }

    
    ::std::array<::std::string, 5>& array_string() {
      return storage_.array_string;
    }

    // Setter for array_string.
    //
    
    ArrayBasic& array_string(::std::array<::std::string, 5> value);
    
      const ::std::array<::std::optional<::std::string>, 5> &
    array_opt_string() const {
      return storage_.array_opt_string;
    }

    
    ::std::array<::std::optional<::std::string>, 5>& array_opt_string() {
      return storage_.array_opt_string;
    }

    // Setter for array_opt_string.
    //
    
    ArrayBasic& array_opt_string(::std::array<::std::optional<::std::string>, 5> value);

  ArrayBasic(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::array<uint8_t, 5> array_uint8
        = {};
      ::std::array<uint16_t, 5> array_uint16
        = {};
      ::std::array<uint32_t, 5> array_uint32
        = {};
      ::std::array<uint64_t, 5> array_uint64
        = {};
      ::std::array<int8_t, 5> array_int8
        = {};
      ::std::array<int16_t, 5> array_int16
        = {};
      ::std::array<int32_t, 5> array_int32
        = {};
      ::std::array<int64_t, 5> array_int64
        = {};
      ::std::array<float, 5> array_float32
        = {};
      ::std::array<double, 5> array_float64
        = {};
      ::std::array<::std::string, 5> array_string;
      ::std::array<::std::optional<::std::string>, 5> array_opt_string;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayBasic, 384>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ArrayBasic>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::array<uint8_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_uint8, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<uint16_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_uint16, 6
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<uint32_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_uint32, 16
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<uint64_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_uint64, 40
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<int8_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_int8, 80
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<int16_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_int16, 86
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<int32_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_int32, 96
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<int64_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_int64, 120
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<float, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_float32, 160
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<double, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_float64, 184
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::std::string, 5>, fidl::internal::NaturalCodingConstraintString<>>{
        &Storage_::array_string, 224
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::std::optional<::std::string>, 5>, fidl::internal::NaturalCodingConstraintString<>>{
        &Storage_::array_opt_string, 304
      });
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
        .offset = 0,
        .mask = 0x0000ff0000000000ull,
      }, ::fidl::internal::NaturalStructPadding<uint64_t>{
        .offset = 32,
        .mask = 0xffffffff00000000ull,
      }, ::fidl::internal::NaturalStructPadding<uint64_t>{
        .offset = 80,
        .mask = 0x0000ff0000000000ull,
      }, ::fidl::internal::NaturalStructPadding<uint64_t>{
        .offset = 112,
        .mask = 0xffffffff00000000ull,
      }, ::fidl::internal::NaturalStructPadding<uint64_t>{
        .offset = 176,
        .mask = 0xffffffff00000000ull,
      });

};


  
  
  



extern "C" const fidl_type_t test_typesinprotocols_ArrayCompoundTable;


class ArrayCompound {
 private:
  struct Storage_;
 public:
  ArrayCompound(Storage_ storage) noexcept;
    ArrayCompound(::std::array<::test_typesinprotocols::Bits, 5> array_bits, ::std::array<::test_typesinprotocols::Enum, 5> array_enum, ::std::array<::test_typesinprotocols::Struct, 5> array_struct, ::std::array<::test_typesinprotocols::Table, 5> array_table, ::std::array<::test_typesinprotocols::Union, 5> array_union, ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5> array_opt_union) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ArrayCompound| only if all of its members are default constructible.
  ArrayCompound() = default;
#pragma clang diagnostic pop

  ArrayCompound(ArrayCompound&&) noexcept = default;
  ArrayCompound& operator=(ArrayCompound&&) noexcept = default;
    ArrayCompound(const ArrayCompound& other) noexcept;
    ArrayCompound& operator=(const ArrayCompound& other) noexcept;

    bool operator==(const ArrayCompound& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayCompound, 328>::Equal(this, &other);
    }
    bool operator!=(const ArrayCompound& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayCompound, 328>::Equal(this, &other);
    }
    
      const ::std::array<::test_typesinprotocols::Bits, 5> &
    array_bits() const {
      return storage_.array_bits;
    }

    
    ::std::array<::test_typesinprotocols::Bits, 5>& array_bits() {
      return storage_.array_bits;
    }

    // Setter for array_bits.
    //
    
    ArrayCompound& array_bits(::std::array<::test_typesinprotocols::Bits, 5> value);
    
      const ::std::array<::test_typesinprotocols::Enum, 5> &
    array_enum() const {
      return storage_.array_enum;
    }

    
    ::std::array<::test_typesinprotocols::Enum, 5>& array_enum() {
      return storage_.array_enum;
    }

    // Setter for array_enum.
    //
    
    ArrayCompound& array_enum(::std::array<::test_typesinprotocols::Enum, 5> value);
    
      const ::std::array<::test_typesinprotocols::Struct, 5> &
    array_struct() const {
      return storage_.array_struct;
    }

    
    ::std::array<::test_typesinprotocols::Struct, 5>& array_struct() {
      return storage_.array_struct;
    }

    // Setter for array_struct.
    //
    
    ArrayCompound& array_struct(::std::array<::test_typesinprotocols::Struct, 5> value);
    
      const ::std::array<::test_typesinprotocols::Table, 5> &
    array_table() const {
      return storage_.array_table;
    }

    
    ::std::array<::test_typesinprotocols::Table, 5>& array_table() {
      return storage_.array_table;
    }

    // Setter for array_table.
    //
    
    ArrayCompound& array_table(::std::array<::test_typesinprotocols::Table, 5> value);
    
      const ::std::array<::test_typesinprotocols::Union, 5> &
    array_union() const {
      return storage_.array_union;
    }

    
    ::std::array<::test_typesinprotocols::Union, 5>& array_union() {
      return storage_.array_union;
    }

    // Setter for array_union.
    //
    
    ArrayCompound& array_union(::std::array<::test_typesinprotocols::Union, 5> value);
    
      const ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5> &
    array_opt_struct() const {
      return storage_.array_opt_struct;
    }

    
    ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5>& array_opt_struct() {
      return storage_.array_opt_struct;
    }

    // Setter for array_opt_struct.
    //
    
    ArrayCompound& array_opt_struct(::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5> value);
    
      const ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5> &
    array_opt_union() const {
      return storage_.array_opt_union;
    }

    
    ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5>& array_opt_union() {
      return storage_.array_opt_union;
    }

    // Setter for array_opt_union.
    //
    
    ArrayCompound& array_opt_union(::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5> value);

  ArrayCompound(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::array<::test_typesinprotocols::Bits, 5> array_bits
        = {};
      ::std::array<::test_typesinprotocols::Enum, 5> array_enum
        = {};
      ::std::array<::test_typesinprotocols::Struct, 5> array_struct;
      ::std::array<::test_typesinprotocols::Table, 5> array_table;
      ::std::array<::test_typesinprotocols::Union, 5> array_union;
      ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5> array_opt_struct;
      ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5> array_opt_union;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayCompound, 328>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ArrayCompound>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::Bits, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_bits, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::Enum, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_enum, 20
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::Struct, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_struct, 40
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::Table, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_table, 48
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::Union, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_union, 128
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_opt_struct, 208
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_opt_union, 248
      });
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
        .offset = 40,
        .mask = 0xffffff0000000000ull,
      });

};


  
  
  



extern "C" const fidl_type_t test_typesinprotocols_VectorBasicTable;


class VectorBasic {
 private:
  struct Storage_;
 public:
  VectorBasic(Storage_ storage) noexcept;
    VectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::std::optional<::std::string>> vector_opt_string) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |VectorBasic| only if all of its members are default constructible.
  VectorBasic() = default;
#pragma clang diagnostic pop

  VectorBasic(VectorBasic&&) noexcept = default;
  VectorBasic& operator=(VectorBasic&&) noexcept = default;
    VectorBasic(const VectorBasic& other) noexcept;
    VectorBasic& operator=(const VectorBasic& other) noexcept;

    bool operator==(const VectorBasic& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorBasic, 192>::Equal(this, &other);
    }
    bool operator!=(const VectorBasic& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorBasic, 192>::Equal(this, &other);
    }
    
      const ::std::vector<uint8_t> &
    vector_uint8() const {
      return storage_.vector_uint8;
    }

    
    ::std::vector<uint8_t>& vector_uint8() {
      return storage_.vector_uint8;
    }

    // Setter for vector_uint8.
    //
    
    VectorBasic& vector_uint8(::std::vector<uint8_t> value);
    
      const ::std::vector<uint16_t> &
    vector_uint16() const {
      return storage_.vector_uint16;
    }

    
    ::std::vector<uint16_t>& vector_uint16() {
      return storage_.vector_uint16;
    }

    // Setter for vector_uint16.
    //
    
    VectorBasic& vector_uint16(::std::vector<uint16_t> value);
    
      const ::std::vector<uint32_t> &
    vector_uint32() const {
      return storage_.vector_uint32;
    }

    
    ::std::vector<uint32_t>& vector_uint32() {
      return storage_.vector_uint32;
    }

    // Setter for vector_uint32.
    //
    
    VectorBasic& vector_uint32(::std::vector<uint32_t> value);
    
      const ::std::vector<uint64_t> &
    vector_uint64() const {
      return storage_.vector_uint64;
    }

    
    ::std::vector<uint64_t>& vector_uint64() {
      return storage_.vector_uint64;
    }

    // Setter for vector_uint64.
    //
    
    VectorBasic& vector_uint64(::std::vector<uint64_t> value);
    
      const ::std::vector<int8_t> &
    vector_int8() const {
      return storage_.vector_int8;
    }

    
    ::std::vector<int8_t>& vector_int8() {
      return storage_.vector_int8;
    }

    // Setter for vector_int8.
    //
    
    VectorBasic& vector_int8(::std::vector<int8_t> value);
    
      const ::std::vector<int16_t> &
    vector_int16() const {
      return storage_.vector_int16;
    }

    
    ::std::vector<int16_t>& vector_int16() {
      return storage_.vector_int16;
    }

    // Setter for vector_int16.
    //
    
    VectorBasic& vector_int16(::std::vector<int16_t> value);
    
      const ::std::vector<int32_t> &
    vector_int32() const {
      return storage_.vector_int32;
    }

    
    ::std::vector<int32_t>& vector_int32() {
      return storage_.vector_int32;
    }

    // Setter for vector_int32.
    //
    
    VectorBasic& vector_int32(::std::vector<int32_t> value);
    
      const ::std::vector<int64_t> &
    vector_int64() const {
      return storage_.vector_int64;
    }

    
    ::std::vector<int64_t>& vector_int64() {
      return storage_.vector_int64;
    }

    // Setter for vector_int64.
    //
    
    VectorBasic& vector_int64(::std::vector<int64_t> value);
    
      const ::std::vector<float> &
    vector_float32() const {
      return storage_.vector_float32;
    }

    
    ::std::vector<float>& vector_float32() {
      return storage_.vector_float32;
    }

    // Setter for vector_float32.
    //
    
    VectorBasic& vector_float32(::std::vector<float> value);
    
      const ::std::vector<double> &
    vector_float64() const {
      return storage_.vector_float64;
    }

    
    ::std::vector<double>& vector_float64() {
      return storage_.vector_float64;
    }

    // Setter for vector_float64.
    //
    
    VectorBasic& vector_float64(::std::vector<double> value);
    
      const ::std::vector<::std::string> &
    vector_string() const {
      return storage_.vector_string;
    }

    
    ::std::vector<::std::string>& vector_string() {
      return storage_.vector_string;
    }

    // Setter for vector_string.
    //
    
    VectorBasic& vector_string(::std::vector<::std::string> value);
    
      const ::std::vector<::std::optional<::std::string>> &
    vector_opt_string() const {
      return storage_.vector_opt_string;
    }

    
    ::std::vector<::std::optional<::std::string>>& vector_opt_string() {
      return storage_.vector_opt_string;
    }

    // Setter for vector_opt_string.
    //
    
    VectorBasic& vector_opt_string(::std::vector<::std::optional<::std::string>> value);

  VectorBasic(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::vector<uint8_t> vector_uint8;
      ::std::vector<uint16_t> vector_uint16;
      ::std::vector<uint32_t> vector_uint32;
      ::std::vector<uint64_t> vector_uint64;
      ::std::vector<int8_t> vector_int8;
      ::std::vector<int16_t> vector_int16;
      ::std::vector<int32_t> vector_int32;
      ::std::vector<int64_t> vector_int64;
      ::std::vector<float> vector_float32;
      ::std::vector<double> vector_float64;
      ::std::vector<::std::string> vector_string;
      ::std::vector<::std::optional<::std::string>> vector_opt_string;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorBasic, 192>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::VectorBasic>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::vector<uint8_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_uint8, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<uint16_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_uint16, 16
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<uint32_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_uint32, 32
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<uint64_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_uint64, 48
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<int8_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_int8, 64
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<int16_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_int16, 80
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<int32_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_int32, 96
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<int64_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_int64, 112
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<float>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_float32, 128
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<double>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_float64, 144
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::std::string>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintString<>>>{
        &Storage_::vector_string, 160
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::std::optional<::std::string>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintString<>>>{
        &Storage_::vector_opt_string, 176
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_typesinprotocols_VectorCompoundTable;


class VectorCompound {
 private:
  struct Storage_;
 public:
  VectorCompound(Storage_ storage) noexcept;
    VectorCompound(::std::vector<::test_typesinprotocols::Bits> vector_bits, ::std::vector<::test_typesinprotocols::Enum> vector_enum, ::std::vector<::test_typesinprotocols::Struct> vector_struct, ::std::vector<::test_typesinprotocols::Table> vector_table, ::std::vector<::test_typesinprotocols::Union> vector_union, ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::fidl::Box<::test_typesinprotocols::Union>> vector_opt_union) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |VectorCompound| only if all of its members are default constructible.
  VectorCompound() = default;
#pragma clang diagnostic pop

  VectorCompound(VectorCompound&&) noexcept = default;
  VectorCompound& operator=(VectorCompound&&) noexcept = default;
    VectorCompound(const VectorCompound& other) noexcept;
    VectorCompound& operator=(const VectorCompound& other) noexcept;

    bool operator==(const VectorCompound& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorCompound, 112>::Equal(this, &other);
    }
    bool operator!=(const VectorCompound& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorCompound, 112>::Equal(this, &other);
    }
    
      const ::std::vector<::test_typesinprotocols::Bits> &
    vector_bits() const {
      return storage_.vector_bits;
    }

    
    ::std::vector<::test_typesinprotocols::Bits>& vector_bits() {
      return storage_.vector_bits;
    }

    // Setter for vector_bits.
    //
    
    VectorCompound& vector_bits(::std::vector<::test_typesinprotocols::Bits> value);
    
      const ::std::vector<::test_typesinprotocols::Enum> &
    vector_enum() const {
      return storage_.vector_enum;
    }

    
    ::std::vector<::test_typesinprotocols::Enum>& vector_enum() {
      return storage_.vector_enum;
    }

    // Setter for vector_enum.
    //
    
    VectorCompound& vector_enum(::std::vector<::test_typesinprotocols::Enum> value);
    
      const ::std::vector<::test_typesinprotocols::Struct> &
    vector_struct() const {
      return storage_.vector_struct;
    }

    
    ::std::vector<::test_typesinprotocols::Struct>& vector_struct() {
      return storage_.vector_struct;
    }

    // Setter for vector_struct.
    //
    
    VectorCompound& vector_struct(::std::vector<::test_typesinprotocols::Struct> value);
    
      const ::std::vector<::test_typesinprotocols::Table> &
    vector_table() const {
      return storage_.vector_table;
    }

    
    ::std::vector<::test_typesinprotocols::Table>& vector_table() {
      return storage_.vector_table;
    }

    // Setter for vector_table.
    //
    
    VectorCompound& vector_table(::std::vector<::test_typesinprotocols::Table> value);
    
      const ::std::vector<::test_typesinprotocols::Union> &
    vector_union() const {
      return storage_.vector_union;
    }

    
    ::std::vector<::test_typesinprotocols::Union>& vector_union() {
      return storage_.vector_union;
    }

    // Setter for vector_union.
    //
    
    VectorCompound& vector_union(::std::vector<::test_typesinprotocols::Union> value);
    
      const ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>> &
    vector_opt_struct() const {
      return storage_.vector_opt_struct;
    }

    
    ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>& vector_opt_struct() {
      return storage_.vector_opt_struct;
    }

    // Setter for vector_opt_struct.
    //
    
    VectorCompound& vector_opt_struct(::std::vector<::fidl::Box<::test_typesinprotocols::Struct>> value);
    
      const ::std::vector<::fidl::Box<::test_typesinprotocols::Union>> &
    vector_opt_union() const {
      return storage_.vector_opt_union;
    }

    
    ::std::vector<::fidl::Box<::test_typesinprotocols::Union>>& vector_opt_union() {
      return storage_.vector_opt_union;
    }

    // Setter for vector_opt_union.
    //
    
    VectorCompound& vector_opt_union(::std::vector<::fidl::Box<::test_typesinprotocols::Union>> value);

  VectorCompound(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::vector<::test_typesinprotocols::Bits> vector_bits;
      ::std::vector<::test_typesinprotocols::Enum> vector_enum;
      ::std::vector<::test_typesinprotocols::Struct> vector_struct;
      ::std::vector<::test_typesinprotocols::Table> vector_table;
      ::std::vector<::test_typesinprotocols::Union> vector_union;
      ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>> vector_opt_struct;
      ::std::vector<::fidl::Box<::test_typesinprotocols::Union>> vector_opt_union;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorCompound, 112>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::VectorCompound>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::Bits>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_bits, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::Enum>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_enum, 16
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::Struct>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_struct, 32
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::Table>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_table, 48
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::Union>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_union, 64
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_opt_struct, 80
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::fidl::Box<::test_typesinprotocols::Union>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_opt_union, 96
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_typesinprotocols_VectorOptionalTable;


class VectorOptional {
 private:
  struct Storage_;
 public:
  VectorOptional(Storage_ storage) noexcept;
    VectorOptional(::std::optional<::std::vector<uint8_t>> opt_vector_uint8, ::std::optional<::std::vector<::std::string>> opt_vector_string, ::std::optional<::std::vector<::test_typesinprotocols::Struct>> opt_vector_struct, ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>> opt_vector_opt_struct) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |VectorOptional| only if all of its members are default constructible.
  VectorOptional() = default;
#pragma clang diagnostic pop

  VectorOptional(VectorOptional&&) noexcept = default;
  VectorOptional& operator=(VectorOptional&&) noexcept = default;
    VectorOptional(const VectorOptional& other) noexcept;
    VectorOptional& operator=(const VectorOptional& other) noexcept;

    bool operator==(const VectorOptional& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorOptional, 64>::Equal(this, &other);
    }
    bool operator!=(const VectorOptional& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorOptional, 64>::Equal(this, &other);
    }
    
      const ::std::optional<::std::vector<uint8_t>> &
    opt_vector_uint8() const {
      return storage_.opt_vector_uint8;
    }

    
    ::std::optional<::std::vector<uint8_t>>& opt_vector_uint8() {
      return storage_.opt_vector_uint8;
    }

    // Setter for opt_vector_uint8.
    //
    
    VectorOptional& opt_vector_uint8(::std::optional<::std::vector<uint8_t>> value);
    
      const ::std::optional<::std::vector<::std::string>> &
    opt_vector_string() const {
      return storage_.opt_vector_string;
    }

    
    ::std::optional<::std::vector<::std::string>>& opt_vector_string() {
      return storage_.opt_vector_string;
    }

    // Setter for opt_vector_string.
    //
    
    VectorOptional& opt_vector_string(::std::optional<::std::vector<::std::string>> value);
    
      const ::std::optional<::std::vector<::test_typesinprotocols::Struct>> &
    opt_vector_struct() const {
      return storage_.opt_vector_struct;
    }

    
    ::std::optional<::std::vector<::test_typesinprotocols::Struct>>& opt_vector_struct() {
      return storage_.opt_vector_struct;
    }

    // Setter for opt_vector_struct.
    //
    
    VectorOptional& opt_vector_struct(::std::optional<::std::vector<::test_typesinprotocols::Struct>> value);
    
      const ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>> &
    opt_vector_opt_struct() const {
      return storage_.opt_vector_opt_struct;
    }

    
    ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>>& opt_vector_opt_struct() {
      return storage_.opt_vector_opt_struct;
    }

    // Setter for opt_vector_opt_struct.
    //
    
    VectorOptional& opt_vector_opt_struct(::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>> value);

  VectorOptional(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::optional<::std::vector<uint8_t>> opt_vector_uint8;
      ::std::optional<::std::vector<::std::string>> opt_vector_string;
      ::std::optional<::std::vector<::test_typesinprotocols::Struct>> opt_vector_struct;
      ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>> opt_vector_opt_struct;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorOptional, 64>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::VectorOptional>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::optional<::std::vector<uint8_t>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::opt_vector_uint8, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::optional<::std::vector<::std::string>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintString<>>>{
        &Storage_::opt_vector_string, 16
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::optional<::std::vector<::test_typesinprotocols::Struct>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::opt_vector_struct, 32
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::opt_vector_opt_struct, 48
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  



extern "C" const fidl_type_t test_typesinprotocols_ArrayVectorNestedTable;


class ArrayVectorNested {
 private:
  struct Storage_;
 public:
  ArrayVectorNested(Storage_ storage) noexcept;
    ArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ArrayVectorNested| only if all of its members are default constructible.
  ArrayVectorNested() = default;
#pragma clang diagnostic pop

  ArrayVectorNested(ArrayVectorNested&&) noexcept = default;
  ArrayVectorNested& operator=(ArrayVectorNested&&) noexcept = default;
    ArrayVectorNested(const ArrayVectorNested& other) noexcept;
    ArrayVectorNested& operator=(const ArrayVectorNested& other) noexcept;

    bool operator==(const ArrayVectorNested& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayVectorNested, 144>::Equal(this, &other);
    }
    bool operator!=(const ArrayVectorNested& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayVectorNested, 144>::Equal(this, &other);
    }
    
      const ::std::array<::std::array<uint8_t, 5>, 5> &
    array_array_uint8() const {
      return storage_.array_array_uint8;
    }

    
    ::std::array<::std::array<uint8_t, 5>, 5>& array_array_uint8() {
      return storage_.array_array_uint8;
    }

    // Setter for array_array_uint8.
    //
    
    ArrayVectorNested& array_array_uint8(::std::array<::std::array<uint8_t, 5>, 5> value);
    
      const ::std::array<::std::vector<uint8_t>, 5> &
    array_vector_uint8() const {
      return storage_.array_vector_uint8;
    }

    
    ::std::array<::std::vector<uint8_t>, 5>& array_vector_uint8() {
      return storage_.array_vector_uint8;
    }

    // Setter for array_vector_uint8.
    //
    
    ArrayVectorNested& array_vector_uint8(::std::array<::std::vector<uint8_t>, 5> value);
    
      const ::std::vector<::std::array<uint8_t, 5>> &
    vector_array_uint8() const {
      return storage_.vector_array_uint8;
    }

    
    ::std::vector<::std::array<uint8_t, 5>>& vector_array_uint8() {
      return storage_.vector_array_uint8;
    }

    // Setter for vector_array_uint8.
    //
    
    ArrayVectorNested& vector_array_uint8(::std::vector<::std::array<uint8_t, 5>> value);
    
      const ::std::vector<::std::vector<uint8_t>> &
    vector_vector_uint8() const {
      return storage_.vector_vector_uint8;
    }

    
    ::std::vector<::std::vector<uint8_t>>& vector_vector_uint8() {
      return storage_.vector_vector_uint8;
    }

    // Setter for vector_vector_uint8.
    //
    
    ArrayVectorNested& vector_vector_uint8(::std::vector<::std::vector<uint8_t>> value);

  ArrayVectorNested(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8
        = {};
      ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8;
      ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8;
      ::std::vector<::std::vector<uint8_t>> vector_vector_uint8;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayVectorNested, 144>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ArrayVectorNested>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::array<::std::array<uint8_t, 5>, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_array_uint8, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::std::vector<uint8_t>, 5>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::array_vector_uint8, 32
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::std::array<uint8_t, 5>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_array_uint8, 112
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::std::vector<uint8_t>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>>{
        &Storage_::vector_vector_uint8, 128
      });
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
        .offset = 24,
        .mask = 0xffffffffffffff00ull,
      });

};


  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ResourceTable;


class Resource {
 private:
  struct Storage_;
 public:
  Resource(Storage_ storage) noexcept;
    Resource(::zx::handle handle, ::zx::vmo vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol> server_end, ::test_typesinprotocols::ResourceStruct struct_, ::test_typesinprotocols::ResourceTable table, ::test_typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol> opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol> opt_server_end, ::fidl::Box<::test_typesinprotocols::ResourceStruct> opt_struct, ::fidl::Box<::test_typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test_typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test_typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test_typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test_typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test_typesinprotocols::ResourceTable> vector_table, ::std::vector<::test_typesinprotocols::ResourceUnion> vector_union) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |Resource| only if all of its members are default constructible.
  Resource() = default;
#pragma clang diagnostic pop

  Resource(Resource&&) noexcept = default;
  Resource& operator=(Resource&&) noexcept = default;
    
      const ::zx::handle &
    handle() const {
      return storage_.handle;
    }

    
    ::zx::handle& handle() {
      return storage_.handle;
    }

    // Setter for handle.
    //
    
    Resource& handle(::zx::handle value);
    
      const ::zx::vmo &
    vmo() const {
      return storage_.vmo;
    }

    
    ::zx::vmo& vmo() {
      return storage_.vmo;
    }

    // Setter for vmo.
    //
    
    Resource& vmo(::zx::vmo value);
    
      const ::fidl::ClientEnd<::test_typesinprotocols::Protocol> &
    client_end() const {
      return storage_.client_end;
    }

    
    ::fidl::ClientEnd<::test_typesinprotocols::Protocol>& client_end() {
      return storage_.client_end;
    }

    // Setter for client_end.
    //
    
    Resource& client_end(::fidl::ClientEnd<::test_typesinprotocols::Protocol> value);
    
      const ::fidl::ServerEnd<::test_typesinprotocols::Protocol> &
    server_end() const {
      return storage_.server_end;
    }

    
    ::fidl::ServerEnd<::test_typesinprotocols::Protocol>& server_end() {
      return storage_.server_end;
    }

    // Setter for server_end.
    //
    
    Resource& server_end(::fidl::ServerEnd<::test_typesinprotocols::Protocol> value);
    
      const ::test_typesinprotocols::ResourceStruct &
    struct_() const {
      return storage_.struct_;
    }

    
    ::test_typesinprotocols::ResourceStruct& struct_() {
      return storage_.struct_;
    }

    // Setter for struct_.
    //
    
    Resource& struct_(::test_typesinprotocols::ResourceStruct value);
    
      const ::test_typesinprotocols::ResourceTable &
    table() const {
      return storage_.table;
    }

    
    ::test_typesinprotocols::ResourceTable& table() {
      return storage_.table;
    }

    // Setter for table.
    //
    
    Resource& table(::test_typesinprotocols::ResourceTable value);
    
      const ::test_typesinprotocols::ResourceUnion &
    union_() const {
      return storage_.union_;
    }

    
    ::test_typesinprotocols::ResourceUnion& union_() {
      return storage_.union_;
    }

    // Setter for union_.
    //
    
    Resource& union_(::test_typesinprotocols::ResourceUnion value);
    
      const ::zx::handle &
    opt_handle() const {
      return storage_.opt_handle;
    }

    
    ::zx::handle& opt_handle() {
      return storage_.opt_handle;
    }

    // Setter for opt_handle.
    //
    
    Resource& opt_handle(::zx::handle value);
    
      const ::zx::vmo &
    opt_vmo() const {
      return storage_.opt_vmo;
    }

    
    ::zx::vmo& opt_vmo() {
      return storage_.opt_vmo;
    }

    // Setter for opt_vmo.
    //
    
    Resource& opt_vmo(::zx::vmo value);
    
      const ::fidl::ClientEnd<::test_typesinprotocols::Protocol> &
    opt_client_end() const {
      return storage_.opt_client_end;
    }

    
    ::fidl::ClientEnd<::test_typesinprotocols::Protocol>& opt_client_end() {
      return storage_.opt_client_end;
    }

    // Setter for opt_client_end.
    //
    
    Resource& opt_client_end(::fidl::ClientEnd<::test_typesinprotocols::Protocol> value);
    
      const ::fidl::ServerEnd<::test_typesinprotocols::Protocol> &
    opt_server_end() const {
      return storage_.opt_server_end;
    }

    
    ::fidl::ServerEnd<::test_typesinprotocols::Protocol>& opt_server_end() {
      return storage_.opt_server_end;
    }

    // Setter for opt_server_end.
    //
    
    Resource& opt_server_end(::fidl::ServerEnd<::test_typesinprotocols::Protocol> value);
    
      const ::fidl::Box<::test_typesinprotocols::ResourceStruct> &
    opt_struct() const {
      return storage_.opt_struct;
    }

    
    ::fidl::Box<::test_typesinprotocols::ResourceStruct>& opt_struct() {
      return storage_.opt_struct;
    }

    // Setter for opt_struct.
    //
    
    Resource& opt_struct(::fidl::Box<::test_typesinprotocols::ResourceStruct> value);
    
      const ::fidl::Box<::test_typesinprotocols::ResourceUnion> &
    opt_union() const {
      return storage_.opt_union;
    }

    
    ::fidl::Box<::test_typesinprotocols::ResourceUnion>& opt_union() {
      return storage_.opt_union;
    }

    // Setter for opt_union.
    //
    
    Resource& opt_union(::fidl::Box<::test_typesinprotocols::ResourceUnion> value);
    
      const ::std::array<::zx::handle, 5> &
    array_handle() const {
      return storage_.array_handle;
    }

    
    ::std::array<::zx::handle, 5>& array_handle() {
      return storage_.array_handle;
    }

    // Setter for array_handle.
    //
    
    Resource& array_handle(::std::array<::zx::handle, 5> value);
    
      const ::std::array<::zx::vmo, 5> &
    array_vmo() const {
      return storage_.array_vmo;
    }

    
    ::std::array<::zx::vmo, 5>& array_vmo() {
      return storage_.array_vmo;
    }

    // Setter for array_vmo.
    //
    
    Resource& array_vmo(::std::array<::zx::vmo, 5> value);
    
      const ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> &
    array_client_end() const {
      return storage_.array_client_end;
    }

    
    ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>& array_client_end() {
      return storage_.array_client_end;
    }

    // Setter for array_client_end.
    //
    
    Resource& array_client_end(::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> value);
    
      const ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> &
    array_server_end() const {
      return storage_.array_server_end;
    }

    
    ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>& array_server_end() {
      return storage_.array_server_end;
    }

    // Setter for array_server_end.
    //
    
    Resource& array_server_end(::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> value);
    
      const ::std::array<::test_typesinprotocols::ResourceStruct, 5> &
    array_struct() const {
      return storage_.array_struct;
    }

    
    ::std::array<::test_typesinprotocols::ResourceStruct, 5>& array_struct() {
      return storage_.array_struct;
    }

    // Setter for array_struct.
    //
    
    Resource& array_struct(::std::array<::test_typesinprotocols::ResourceStruct, 5> value);
    
      const ::std::array<::test_typesinprotocols::ResourceTable, 5> &
    array_table() const {
      return storage_.array_table;
    }

    
    ::std::array<::test_typesinprotocols::ResourceTable, 5>& array_table() {
      return storage_.array_table;
    }

    // Setter for array_table.
    //
    
    Resource& array_table(::std::array<::test_typesinprotocols::ResourceTable, 5> value);
    
      const ::std::array<::test_typesinprotocols::ResourceUnion, 5> &
    array_union() const {
      return storage_.array_union;
    }

    
    ::std::array<::test_typesinprotocols::ResourceUnion, 5>& array_union() {
      return storage_.array_union;
    }

    // Setter for array_union.
    //
    
    Resource& array_union(::std::array<::test_typesinprotocols::ResourceUnion, 5> value);
    
      const ::std::vector<::zx::handle> &
    vector_handle() const {
      return storage_.vector_handle;
    }

    
    ::std::vector<::zx::handle>& vector_handle() {
      return storage_.vector_handle;
    }

    // Setter for vector_handle.
    //
    
    Resource& vector_handle(::std::vector<::zx::handle> value);
    
      const ::std::vector<::zx::vmo> &
    vector_vmo() const {
      return storage_.vector_vmo;
    }

    
    ::std::vector<::zx::vmo>& vector_vmo() {
      return storage_.vector_vmo;
    }

    // Setter for vector_vmo.
    //
    
    Resource& vector_vmo(::std::vector<::zx::vmo> value);
    
      const ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> &
    vector_client_end() const {
      return storage_.vector_client_end;
    }

    
    ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>>& vector_client_end() {
      return storage_.vector_client_end;
    }

    // Setter for vector_client_end.
    //
    
    Resource& vector_client_end(::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> value);
    
      const ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> &
    vector_server_end() const {
      return storage_.vector_server_end;
    }

    
    ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>>& vector_server_end() {
      return storage_.vector_server_end;
    }

    // Setter for vector_server_end.
    //
    
    Resource& vector_server_end(::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> value);
    
      const ::std::vector<::test_typesinprotocols::ResourceStruct> &
    vector_struct() const {
      return storage_.vector_struct;
    }

    
    ::std::vector<::test_typesinprotocols::ResourceStruct>& vector_struct() {
      return storage_.vector_struct;
    }

    // Setter for vector_struct.
    //
    
    Resource& vector_struct(::std::vector<::test_typesinprotocols::ResourceStruct> value);
    
      const ::std::vector<::test_typesinprotocols::ResourceTable> &
    vector_table() const {
      return storage_.vector_table;
    }

    
    ::std::vector<::test_typesinprotocols::ResourceTable>& vector_table() {
      return storage_.vector_table;
    }

    // Setter for vector_table.
    //
    
    Resource& vector_table(::std::vector<::test_typesinprotocols::ResourceTable> value);
    
      const ::std::vector<::test_typesinprotocols::ResourceUnion> &
    vector_union() const {
      return storage_.vector_union;
    }

    
    ::std::vector<::test_typesinprotocols::ResourceUnion>& vector_union() {
      return storage_.vector_union;
    }

    // Setter for vector_union.
    //
    
    Resource& vector_union(::std::vector<::test_typesinprotocols::ResourceUnion> value);

  Resource(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::zx::handle handle;
      ::zx::vmo vmo;
      ::fidl::ClientEnd<::test_typesinprotocols::Protocol> client_end;
      ::fidl::ServerEnd<::test_typesinprotocols::Protocol> server_end;
      ::test_typesinprotocols::ResourceStruct struct_;
      ::test_typesinprotocols::ResourceTable table;
      ::test_typesinprotocols::ResourceUnion union_;
      ::zx::handle opt_handle;
      ::zx::vmo opt_vmo;
      ::fidl::ClientEnd<::test_typesinprotocols::Protocol> opt_client_end;
      ::fidl::ServerEnd<::test_typesinprotocols::Protocol> opt_server_end;
      ::fidl::Box<::test_typesinprotocols::ResourceStruct> opt_struct;
      ::fidl::Box<::test_typesinprotocols::ResourceUnion> opt_union;
      ::std::array<::zx::handle, 5> array_handle;
      ::std::array<::zx::vmo, 5> array_vmo;
      ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> array_client_end;
      ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> array_server_end;
      ::std::array<::test_typesinprotocols::ResourceStruct, 5> array_struct;
      ::std::array<::test_typesinprotocols::ResourceTable, 5> array_table;
      ::std::array<::test_typesinprotocols::ResourceUnion, 5> array_union;
      ::std::vector<::zx::handle> vector_handle;
      ::std::vector<::zx::vmo> vector_vmo;
      ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end;
      ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end;
      ::std::vector<::test_typesinprotocols::ResourceStruct> vector_struct;
      ::std::vector<::test_typesinprotocols::ResourceTable> vector_table;
      ::std::vector<::test_typesinprotocols::ResourceUnion> vector_union;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Resource, 456>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::Resource>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::zx::handle, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>>{
        &Storage_::handle, 0
      }, ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmo, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>>{
        &Storage_::vmo, 4
      }, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
        &Storage_::client_end, 8
      }, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
        &Storage_::server_end, 12
      }, ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ResourceStruct, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::struct_, 16
      }, ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ResourceTable, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::table, 24
      }, ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ResourceUnion, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::union_, 40
      }, ::fidl::internal::NaturalStructMember<Storage_, ::zx::handle, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, true>>{
        &Storage_::opt_handle, 56
      }, ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmo, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, true>>{
        &Storage_::opt_vmo, 60
      }, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>>{
        &Storage_::opt_client_end, 64
      }, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>>{
        &Storage_::opt_server_end, 68
      }, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::Box<::test_typesinprotocols::ResourceStruct>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::opt_struct, 72
      }, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::Box<::test_typesinprotocols::ResourceUnion>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::opt_union, 80
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::zx::handle, 5>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>>{
        &Storage_::array_handle, 96
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::zx::vmo, 5>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>>{
        &Storage_::array_vmo, 116
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
        &Storage_::array_client_end, 136
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
        &Storage_::array_server_end, 156
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::ResourceStruct, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_struct, 176
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::ResourceTable, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_table, 184
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::ResourceUnion, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::array_union, 264
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::zx::handle>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>>>{
        &Storage_::vector_handle, 344
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::zx::vmo>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>>>{
        &Storage_::vector_vmo, 360
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>>{
        &Storage_::vector_client_end, 376
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>>{
        &Storage_::vector_server_end, 392
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::ResourceStruct>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_struct, 408
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::ResourceTable>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_table, 424
      }, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::ResourceUnion>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
        &Storage_::vector_union, 440
      });
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
        .offset = 16,
        .mask = 0xffffffffffffff00ull,
      }, ::fidl::internal::NaturalStructPadding<uint64_t>{
        .offset = 176,
        .mask = 0xffffff0000000000ull,
      });

};



#endif  // __Fuchsia__

  
  
  
  
  



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorBasic_ResultTable;


class ProtocolErrorBasicResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_typesinprotocols::Basic
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  ProtocolErrorBasicResult(ProtocolErrorBasicResult&& other) noexcept
      : ProtocolErrorBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ProtocolErrorBasicResult& operator=(ProtocolErrorBasicResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ProtocolErrorBasicResult(const ProtocolErrorBasicResult& other) noexcept : ProtocolErrorBasicResult(other.CloneStorage_()){}
    ProtocolErrorBasicResult& operator=(const ProtocolErrorBasicResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ProtocolErrorBasicResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ProtocolErrorBasicResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_typesinprotocols::ProtocolErrorBasicResult::Tag Which() const {
    return ProtocolErrorBasicResult::IndexToTag(storage_->index()).value();
  }
    static ProtocolErrorBasicResult WithResponse(::test_typesinprotocols::Basic val) {
      return ProtocolErrorBasicResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    ProtocolErrorBasicResult& response(::test_typesinprotocols::Basic value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static ProtocolErrorBasicResult WithErr(uint32_t val) {
      return ProtocolErrorBasicResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    ProtocolErrorBasicResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  ProtocolErrorBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorBasicResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorBasicResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorBasicResult::Tag tag) {
    switch (tag) {
        case ::test_typesinprotocols::ProtocolErrorBasicResult::Tag::kResponse: return 1;
        case ::test_typesinprotocols::ProtocolErrorBasicResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_typesinprotocols::ProtocolErrorBasicResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_typesinprotocols::ProtocolErrorBasicResult::Tag::kResponse;
        case 2: return ::test_typesinprotocols::ProtocolErrorBasicResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorBasicTopResponseTable;


class ProtocolErrorBasicTopResponse {
 private:
  struct Storage_;
 public:
  ProtocolErrorBasicTopResponse(Storage_ storage) noexcept;
    ProtocolErrorBasicTopResponse(::test_typesinprotocols::ProtocolErrorBasicResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ProtocolErrorBasicTopResponse| only if all of its members are default constructible.
  ProtocolErrorBasicTopResponse() = default;
#pragma clang diagnostic pop

  ProtocolErrorBasicTopResponse(ProtocolErrorBasicTopResponse&&) noexcept = default;
  ProtocolErrorBasicTopResponse& operator=(ProtocolErrorBasicTopResponse&&) noexcept = default;
    ProtocolErrorBasicTopResponse(const ProtocolErrorBasicTopResponse& other) noexcept;
    ProtocolErrorBasicTopResponse& operator=(const ProtocolErrorBasicTopResponse& other) noexcept;

    bool operator==(const ProtocolErrorBasicTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorBasicTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const ProtocolErrorBasicTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorBasicTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_typesinprotocols::ProtocolErrorBasicResult &
    result() const {
      return storage_.result;
    }

    
    ::test_typesinprotocols::ProtocolErrorBasicResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ProtocolErrorBasicTopResponse& result(::test_typesinprotocols::ProtocolErrorBasicResult value);

  ProtocolErrorBasicTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_typesinprotocols::ProtocolErrorBasicResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorBasicTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ProtocolErrorBasicTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ProtocolErrorBasicResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorCompound_ResultTable;


class ProtocolErrorCompoundResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_typesinprotocols::Compound
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  ProtocolErrorCompoundResult(ProtocolErrorCompoundResult&& other) noexcept
      : ProtocolErrorCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ProtocolErrorCompoundResult& operator=(ProtocolErrorCompoundResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ProtocolErrorCompoundResult(const ProtocolErrorCompoundResult& other) noexcept : ProtocolErrorCompoundResult(other.CloneStorage_()){}
    ProtocolErrorCompoundResult& operator=(const ProtocolErrorCompoundResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ProtocolErrorCompoundResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ProtocolErrorCompoundResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_typesinprotocols::ProtocolErrorCompoundResult::Tag Which() const {
    return ProtocolErrorCompoundResult::IndexToTag(storage_->index()).value();
  }
    static ProtocolErrorCompoundResult WithResponse(::test_typesinprotocols::Compound val) {
      return ProtocolErrorCompoundResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    ProtocolErrorCompoundResult& response(::test_typesinprotocols::Compound value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static ProtocolErrorCompoundResult WithErr(uint32_t val) {
      return ProtocolErrorCompoundResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    ProtocolErrorCompoundResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  ProtocolErrorCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorCompoundResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorCompoundResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorCompoundResult::Tag tag) {
    switch (tag) {
        case ::test_typesinprotocols::ProtocolErrorCompoundResult::Tag::kResponse: return 1;
        case ::test_typesinprotocols::ProtocolErrorCompoundResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_typesinprotocols::ProtocolErrorCompoundResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_typesinprotocols::ProtocolErrorCompoundResult::Tag::kResponse;
        case 2: return ::test_typesinprotocols::ProtocolErrorCompoundResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorCompoundTopResponseTable;


class ProtocolErrorCompoundTopResponse {
 private:
  struct Storage_;
 public:
  ProtocolErrorCompoundTopResponse(Storage_ storage) noexcept;
    ProtocolErrorCompoundTopResponse(::test_typesinprotocols::ProtocolErrorCompoundResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ProtocolErrorCompoundTopResponse| only if all of its members are default constructible.
  ProtocolErrorCompoundTopResponse() = default;
#pragma clang diagnostic pop

  ProtocolErrorCompoundTopResponse(ProtocolErrorCompoundTopResponse&&) noexcept = default;
  ProtocolErrorCompoundTopResponse& operator=(ProtocolErrorCompoundTopResponse&&) noexcept = default;
    ProtocolErrorCompoundTopResponse(const ProtocolErrorCompoundTopResponse& other) noexcept;
    ProtocolErrorCompoundTopResponse& operator=(const ProtocolErrorCompoundTopResponse& other) noexcept;

    bool operator==(const ProtocolErrorCompoundTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorCompoundTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const ProtocolErrorCompoundTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorCompoundTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_typesinprotocols::ProtocolErrorCompoundResult &
    result() const {
      return storage_.result;
    }

    
    ::test_typesinprotocols::ProtocolErrorCompoundResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ProtocolErrorCompoundTopResponse& result(::test_typesinprotocols::ProtocolErrorCompoundResult value);

  ProtocolErrorCompoundTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_typesinprotocols::ProtocolErrorCompoundResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorCompoundTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ProtocolErrorCompoundTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ProtocolErrorCompoundResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorArrayBasic_ResultTable;


class ProtocolErrorArrayBasicResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_typesinprotocols::ArrayBasic
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  ProtocolErrorArrayBasicResult(ProtocolErrorArrayBasicResult&& other) noexcept
      : ProtocolErrorArrayBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ProtocolErrorArrayBasicResult& operator=(ProtocolErrorArrayBasicResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ProtocolErrorArrayBasicResult(const ProtocolErrorArrayBasicResult& other) noexcept : ProtocolErrorArrayBasicResult(other.CloneStorage_()){}
    ProtocolErrorArrayBasicResult& operator=(const ProtocolErrorArrayBasicResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ProtocolErrorArrayBasicResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ProtocolErrorArrayBasicResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag Which() const {
    return ProtocolErrorArrayBasicResult::IndexToTag(storage_->index()).value();
  }
    static ProtocolErrorArrayBasicResult WithResponse(::test_typesinprotocols::ArrayBasic val) {
      return ProtocolErrorArrayBasicResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    ProtocolErrorArrayBasicResult& response(::test_typesinprotocols::ArrayBasic value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static ProtocolErrorArrayBasicResult WithErr(uint32_t val) {
      return ProtocolErrorArrayBasicResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    ProtocolErrorArrayBasicResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  ProtocolErrorArrayBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorArrayBasicResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorArrayBasicResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag tag) {
    switch (tag) {
        case ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag::kResponse: return 1;
        case ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag::kResponse;
        case 2: return ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayBasicTopResponseTable;


class ProtocolErrorArrayBasicTopResponse {
 private:
  struct Storage_;
 public:
  ProtocolErrorArrayBasicTopResponse(Storage_ storage) noexcept;
    ProtocolErrorArrayBasicTopResponse(::test_typesinprotocols::ProtocolErrorArrayBasicResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ProtocolErrorArrayBasicTopResponse| only if all of its members are default constructible.
  ProtocolErrorArrayBasicTopResponse() = default;
#pragma clang diagnostic pop

  ProtocolErrorArrayBasicTopResponse(ProtocolErrorArrayBasicTopResponse&&) noexcept = default;
  ProtocolErrorArrayBasicTopResponse& operator=(ProtocolErrorArrayBasicTopResponse&&) noexcept = default;
    ProtocolErrorArrayBasicTopResponse(const ProtocolErrorArrayBasicTopResponse& other) noexcept;
    ProtocolErrorArrayBasicTopResponse& operator=(const ProtocolErrorArrayBasicTopResponse& other) noexcept;

    bool operator==(const ProtocolErrorArrayBasicTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const ProtocolErrorArrayBasicTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_typesinprotocols::ProtocolErrorArrayBasicResult &
    result() const {
      return storage_.result;
    }

    
    ::test_typesinprotocols::ProtocolErrorArrayBasicResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ProtocolErrorArrayBasicTopResponse& result(::test_typesinprotocols::ProtocolErrorArrayBasicResult value);

  ProtocolErrorArrayBasicTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_typesinprotocols::ProtocolErrorArrayBasicResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ProtocolErrorArrayBasicResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorArrayCompound_ResultTable;


class ProtocolErrorArrayCompoundResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_typesinprotocols::ArrayCompound
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  ProtocolErrorArrayCompoundResult(ProtocolErrorArrayCompoundResult&& other) noexcept
      : ProtocolErrorArrayCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ProtocolErrorArrayCompoundResult& operator=(ProtocolErrorArrayCompoundResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ProtocolErrorArrayCompoundResult(const ProtocolErrorArrayCompoundResult& other) noexcept : ProtocolErrorArrayCompoundResult(other.CloneStorage_()){}
    ProtocolErrorArrayCompoundResult& operator=(const ProtocolErrorArrayCompoundResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ProtocolErrorArrayCompoundResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ProtocolErrorArrayCompoundResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag Which() const {
    return ProtocolErrorArrayCompoundResult::IndexToTag(storage_->index()).value();
  }
    static ProtocolErrorArrayCompoundResult WithResponse(::test_typesinprotocols::ArrayCompound val) {
      return ProtocolErrorArrayCompoundResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    ProtocolErrorArrayCompoundResult& response(::test_typesinprotocols::ArrayCompound value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static ProtocolErrorArrayCompoundResult WithErr(uint32_t val) {
      return ProtocolErrorArrayCompoundResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    ProtocolErrorArrayCompoundResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  ProtocolErrorArrayCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorArrayCompoundResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag tag) {
    switch (tag) {
        case ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag::kResponse: return 1;
        case ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag::kResponse;
        case 2: return ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayCompoundTopResponseTable;


class ProtocolErrorArrayCompoundTopResponse {
 private:
  struct Storage_;
 public:
  ProtocolErrorArrayCompoundTopResponse(Storage_ storage) noexcept;
    ProtocolErrorArrayCompoundTopResponse(::test_typesinprotocols::ProtocolErrorArrayCompoundResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ProtocolErrorArrayCompoundTopResponse| only if all of its members are default constructible.
  ProtocolErrorArrayCompoundTopResponse() = default;
#pragma clang diagnostic pop

  ProtocolErrorArrayCompoundTopResponse(ProtocolErrorArrayCompoundTopResponse&&) noexcept = default;
  ProtocolErrorArrayCompoundTopResponse& operator=(ProtocolErrorArrayCompoundTopResponse&&) noexcept = default;
    ProtocolErrorArrayCompoundTopResponse(const ProtocolErrorArrayCompoundTopResponse& other) noexcept;
    ProtocolErrorArrayCompoundTopResponse& operator=(const ProtocolErrorArrayCompoundTopResponse& other) noexcept;

    bool operator==(const ProtocolErrorArrayCompoundTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const ProtocolErrorArrayCompoundTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_typesinprotocols::ProtocolErrorArrayCompoundResult &
    result() const {
      return storage_.result;
    }

    
    ::test_typesinprotocols::ProtocolErrorArrayCompoundResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ProtocolErrorArrayCompoundTopResponse& result(::test_typesinprotocols::ProtocolErrorArrayCompoundResult value);

  ProtocolErrorArrayCompoundTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_typesinprotocols::ProtocolErrorArrayCompoundResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ProtocolErrorArrayCompoundResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorVectorBasic_ResultTable;


class ProtocolErrorVectorBasicResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_typesinprotocols::VectorBasic
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  ProtocolErrorVectorBasicResult(ProtocolErrorVectorBasicResult&& other) noexcept
      : ProtocolErrorVectorBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ProtocolErrorVectorBasicResult& operator=(ProtocolErrorVectorBasicResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ProtocolErrorVectorBasicResult(const ProtocolErrorVectorBasicResult& other) noexcept : ProtocolErrorVectorBasicResult(other.CloneStorage_()){}
    ProtocolErrorVectorBasicResult& operator=(const ProtocolErrorVectorBasicResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ProtocolErrorVectorBasicResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ProtocolErrorVectorBasicResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag Which() const {
    return ProtocolErrorVectorBasicResult::IndexToTag(storage_->index()).value();
  }
    static ProtocolErrorVectorBasicResult WithResponse(::test_typesinprotocols::VectorBasic val) {
      return ProtocolErrorVectorBasicResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    ProtocolErrorVectorBasicResult& response(::test_typesinprotocols::VectorBasic value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static ProtocolErrorVectorBasicResult WithErr(uint32_t val) {
      return ProtocolErrorVectorBasicResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    ProtocolErrorVectorBasicResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  ProtocolErrorVectorBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorVectorBasicResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorVectorBasicResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag tag) {
    switch (tag) {
        case ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag::kResponse: return 1;
        case ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag::kResponse;
        case 2: return ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorBasicTopResponseTable;


class ProtocolErrorVectorBasicTopResponse {
 private:
  struct Storage_;
 public:
  ProtocolErrorVectorBasicTopResponse(Storage_ storage) noexcept;
    ProtocolErrorVectorBasicTopResponse(::test_typesinprotocols::ProtocolErrorVectorBasicResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ProtocolErrorVectorBasicTopResponse| only if all of its members are default constructible.
  ProtocolErrorVectorBasicTopResponse() = default;
#pragma clang diagnostic pop

  ProtocolErrorVectorBasicTopResponse(ProtocolErrorVectorBasicTopResponse&&) noexcept = default;
  ProtocolErrorVectorBasicTopResponse& operator=(ProtocolErrorVectorBasicTopResponse&&) noexcept = default;
    ProtocolErrorVectorBasicTopResponse(const ProtocolErrorVectorBasicTopResponse& other) noexcept;
    ProtocolErrorVectorBasicTopResponse& operator=(const ProtocolErrorVectorBasicTopResponse& other) noexcept;

    bool operator==(const ProtocolErrorVectorBasicTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const ProtocolErrorVectorBasicTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_typesinprotocols::ProtocolErrorVectorBasicResult &
    result() const {
      return storage_.result;
    }

    
    ::test_typesinprotocols::ProtocolErrorVectorBasicResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ProtocolErrorVectorBasicTopResponse& result(::test_typesinprotocols::ProtocolErrorVectorBasicResult value);

  ProtocolErrorVectorBasicTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_typesinprotocols::ProtocolErrorVectorBasicResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ProtocolErrorVectorBasicResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorVectorCompound_ResultTable;


class ProtocolErrorVectorCompoundResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_typesinprotocols::VectorCompound
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  ProtocolErrorVectorCompoundResult(ProtocolErrorVectorCompoundResult&& other) noexcept
      : ProtocolErrorVectorCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ProtocolErrorVectorCompoundResult& operator=(ProtocolErrorVectorCompoundResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ProtocolErrorVectorCompoundResult(const ProtocolErrorVectorCompoundResult& other) noexcept : ProtocolErrorVectorCompoundResult(other.CloneStorage_()){}
    ProtocolErrorVectorCompoundResult& operator=(const ProtocolErrorVectorCompoundResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ProtocolErrorVectorCompoundResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ProtocolErrorVectorCompoundResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag Which() const {
    return ProtocolErrorVectorCompoundResult::IndexToTag(storage_->index()).value();
  }
    static ProtocolErrorVectorCompoundResult WithResponse(::test_typesinprotocols::VectorCompound val) {
      return ProtocolErrorVectorCompoundResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    ProtocolErrorVectorCompoundResult& response(::test_typesinprotocols::VectorCompound value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static ProtocolErrorVectorCompoundResult WithErr(uint32_t val) {
      return ProtocolErrorVectorCompoundResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    ProtocolErrorVectorCompoundResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  ProtocolErrorVectorCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorVectorCompoundResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag tag) {
    switch (tag) {
        case ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag::kResponse: return 1;
        case ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag::kResponse;
        case 2: return ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorCompoundTopResponseTable;


class ProtocolErrorVectorCompoundTopResponse {
 private:
  struct Storage_;
 public:
  ProtocolErrorVectorCompoundTopResponse(Storage_ storage) noexcept;
    ProtocolErrorVectorCompoundTopResponse(::test_typesinprotocols::ProtocolErrorVectorCompoundResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ProtocolErrorVectorCompoundTopResponse| only if all of its members are default constructible.
  ProtocolErrorVectorCompoundTopResponse() = default;
#pragma clang diagnostic pop

  ProtocolErrorVectorCompoundTopResponse(ProtocolErrorVectorCompoundTopResponse&&) noexcept = default;
  ProtocolErrorVectorCompoundTopResponse& operator=(ProtocolErrorVectorCompoundTopResponse&&) noexcept = default;
    ProtocolErrorVectorCompoundTopResponse(const ProtocolErrorVectorCompoundTopResponse& other) noexcept;
    ProtocolErrorVectorCompoundTopResponse& operator=(const ProtocolErrorVectorCompoundTopResponse& other) noexcept;

    bool operator==(const ProtocolErrorVectorCompoundTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const ProtocolErrorVectorCompoundTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_typesinprotocols::ProtocolErrorVectorCompoundResult &
    result() const {
      return storage_.result;
    }

    
    ::test_typesinprotocols::ProtocolErrorVectorCompoundResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ProtocolErrorVectorCompoundTopResponse& result(::test_typesinprotocols::ProtocolErrorVectorCompoundResult value);

  ProtocolErrorVectorCompoundTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_typesinprotocols::ProtocolErrorVectorCompoundResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ProtocolErrorVectorCompoundResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorVectorOptional_ResultTable;


class ProtocolErrorVectorOptionalResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_typesinprotocols::VectorOptional
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  ProtocolErrorVectorOptionalResult(ProtocolErrorVectorOptionalResult&& other) noexcept
      : ProtocolErrorVectorOptionalResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ProtocolErrorVectorOptionalResult& operator=(ProtocolErrorVectorOptionalResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ProtocolErrorVectorOptionalResult(const ProtocolErrorVectorOptionalResult& other) noexcept : ProtocolErrorVectorOptionalResult(other.CloneStorage_()){}
    ProtocolErrorVectorOptionalResult& operator=(const ProtocolErrorVectorOptionalResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ProtocolErrorVectorOptionalResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ProtocolErrorVectorOptionalResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag Which() const {
    return ProtocolErrorVectorOptionalResult::IndexToTag(storage_->index()).value();
  }
    static ProtocolErrorVectorOptionalResult WithResponse(::test_typesinprotocols::VectorOptional val) {
      return ProtocolErrorVectorOptionalResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    ProtocolErrorVectorOptionalResult& response(::test_typesinprotocols::VectorOptional value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static ProtocolErrorVectorOptionalResult WithErr(uint32_t val) {
      return ProtocolErrorVectorOptionalResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    ProtocolErrorVectorOptionalResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  ProtocolErrorVectorOptionalResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorVectorOptionalResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag tag) {
    switch (tag) {
        case ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag::kResponse: return 1;
        case ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag::kResponse;
        case 2: return ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorOptionalTopResponseTable;


class ProtocolErrorVectorOptionalTopResponse {
 private:
  struct Storage_;
 public:
  ProtocolErrorVectorOptionalTopResponse(Storage_ storage) noexcept;
    ProtocolErrorVectorOptionalTopResponse(::test_typesinprotocols::ProtocolErrorVectorOptionalResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ProtocolErrorVectorOptionalTopResponse| only if all of its members are default constructible.
  ProtocolErrorVectorOptionalTopResponse() = default;
#pragma clang diagnostic pop

  ProtocolErrorVectorOptionalTopResponse(ProtocolErrorVectorOptionalTopResponse&&) noexcept = default;
  ProtocolErrorVectorOptionalTopResponse& operator=(ProtocolErrorVectorOptionalTopResponse&&) noexcept = default;
    ProtocolErrorVectorOptionalTopResponse(const ProtocolErrorVectorOptionalTopResponse& other) noexcept;
    ProtocolErrorVectorOptionalTopResponse& operator=(const ProtocolErrorVectorOptionalTopResponse& other) noexcept;

    bool operator==(const ProtocolErrorVectorOptionalTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const ProtocolErrorVectorOptionalTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_typesinprotocols::ProtocolErrorVectorOptionalResult &
    result() const {
      return storage_.result;
    }

    
    ::test_typesinprotocols::ProtocolErrorVectorOptionalResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ProtocolErrorVectorOptionalTopResponse& result(::test_typesinprotocols::ProtocolErrorVectorOptionalResult value);

  ProtocolErrorVectorOptionalTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_typesinprotocols::ProtocolErrorVectorOptionalResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ProtocolErrorVectorOptionalResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorArrayVectorNested_ResultTable;


class ProtocolErrorArrayVectorNestedResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_typesinprotocols::ArrayVectorNested
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  ProtocolErrorArrayVectorNestedResult(ProtocolErrorArrayVectorNestedResult&& other) noexcept
      : ProtocolErrorArrayVectorNestedResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ProtocolErrorArrayVectorNestedResult& operator=(ProtocolErrorArrayVectorNestedResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ProtocolErrorArrayVectorNestedResult(const ProtocolErrorArrayVectorNestedResult& other) noexcept : ProtocolErrorArrayVectorNestedResult(other.CloneStorage_()){}
    ProtocolErrorArrayVectorNestedResult& operator=(const ProtocolErrorArrayVectorNestedResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ProtocolErrorArrayVectorNestedResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ProtocolErrorArrayVectorNestedResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag Which() const {
    return ProtocolErrorArrayVectorNestedResult::IndexToTag(storage_->index()).value();
  }
    static ProtocolErrorArrayVectorNestedResult WithResponse(::test_typesinprotocols::ArrayVectorNested val) {
      return ProtocolErrorArrayVectorNestedResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    ProtocolErrorArrayVectorNestedResult& response(::test_typesinprotocols::ArrayVectorNested value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static ProtocolErrorArrayVectorNestedResult WithErr(uint32_t val) {
      return ProtocolErrorArrayVectorNestedResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    ProtocolErrorArrayVectorNestedResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  ProtocolErrorArrayVectorNestedResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorArrayVectorNestedResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag tag) {
    switch (tag) {
        case ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag::kResponse: return 1;
        case ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag::kResponse;
        case 2: return ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayVectorNestedTopResponseTable;


class ProtocolErrorArrayVectorNestedTopResponse {
 private:
  struct Storage_;
 public:
  ProtocolErrorArrayVectorNestedTopResponse(Storage_ storage) noexcept;
    ProtocolErrorArrayVectorNestedTopResponse(::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ProtocolErrorArrayVectorNestedTopResponse| only if all of its members are default constructible.
  ProtocolErrorArrayVectorNestedTopResponse() = default;
#pragma clang diagnostic pop

  ProtocolErrorArrayVectorNestedTopResponse(ProtocolErrorArrayVectorNestedTopResponse&&) noexcept = default;
  ProtocolErrorArrayVectorNestedTopResponse& operator=(ProtocolErrorArrayVectorNestedTopResponse&&) noexcept = default;
    ProtocolErrorArrayVectorNestedTopResponse(const ProtocolErrorArrayVectorNestedTopResponse& other) noexcept;
    ProtocolErrorArrayVectorNestedTopResponse& operator=(const ProtocolErrorArrayVectorNestedTopResponse& other) noexcept;

    bool operator==(const ProtocolErrorArrayVectorNestedTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const ProtocolErrorArrayVectorNestedTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult &
    result() const {
      return storage_.result;
    }

    
    ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ProtocolErrorArrayVectorNestedTopResponse& result(::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult value);

  ProtocolErrorArrayVectorNestedTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorResource_ResultTable;


class ProtocolErrorResourceResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_typesinprotocols::Resource
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  ProtocolErrorResourceResult(ProtocolErrorResourceResult&& other) noexcept
      : ProtocolErrorResourceResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ProtocolErrorResourceResult& operator=(ProtocolErrorResourceResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }

  constexpr ::test_typesinprotocols::ProtocolErrorResourceResult::Tag Which() const {
    return ProtocolErrorResourceResult::IndexToTag(storage_->index()).value();
  }
    static ProtocolErrorResourceResult WithResponse(::test_typesinprotocols::Resource val) {
      return ProtocolErrorResourceResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    ProtocolErrorResourceResult& response(::test_typesinprotocols::Resource value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static ProtocolErrorResourceResult WithErr(uint32_t val) {
      return ProtocolErrorResourceResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    ProtocolErrorResourceResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  ProtocolErrorResourceResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorResourceResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorResourceResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorResourceResult::Tag tag) {
    switch (tag) {
        case ::test_typesinprotocols::ProtocolErrorResourceResult::Tag::kResponse: return 1;
        case ::test_typesinprotocols::ProtocolErrorResourceResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_typesinprotocols::ProtocolErrorResourceResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_typesinprotocols::ProtocolErrorResourceResult::Tag::kResponse;
        case 2: return ::test_typesinprotocols::ProtocolErrorResourceResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};



#endif  // __Fuchsia__

  



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorResourceTopResponseTable;


class ProtocolErrorResourceTopResponse {
 private:
  struct Storage_;
 public:
  ProtocolErrorResourceTopResponse(Storage_ storage) noexcept;
    ProtocolErrorResourceTopResponse(::test_typesinprotocols::ProtocolErrorResourceResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ProtocolErrorResourceTopResponse| only if all of its members are default constructible.
  ProtocolErrorResourceTopResponse() = default;
#pragma clang diagnostic pop

  ProtocolErrorResourceTopResponse(ProtocolErrorResourceTopResponse&&) noexcept = default;
  ProtocolErrorResourceTopResponse& operator=(ProtocolErrorResourceTopResponse&&) noexcept = default;
    
      const ::test_typesinprotocols::ProtocolErrorResourceResult &
    result() const {
      return storage_.result;
    }

    
    ::test_typesinprotocols::ProtocolErrorResourceResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ProtocolErrorResourceTopResponse& result(::test_typesinprotocols::ProtocolErrorResourceResult value);

  ProtocolErrorResourceTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_typesinprotocols::ProtocolErrorResourceResult result;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorResourceTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ProtocolErrorResourceTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ProtocolErrorResourceResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};



#endif  // __Fuchsia__

  
  
  
  
  


  
  
  
  
  
  

  

  inline Struct::Struct(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline Struct::Struct(uint8_t __reserved) noexcept
    : storage_({
      .__reserved = std::move(__reserved)
    }) {}
    inline Struct::Struct(const ::test_typesinprotocols::Struct& other) noexcept : ::test_typesinprotocols::Struct(other.CloneStorage_()){}
    inline Struct& ::test_typesinprotocols::Struct::operator=(const ::test_typesinprotocols::Struct& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline Struct::Struct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Struct(Storage_{
      .__reserved =0u,
  }) {}
    inline Struct& Struct::__reserved(uint8_t value) {
      storage_.__reserved = std::move(value);
      return *this;
    }

  
  
  
  
  

  

  inline Table::Table(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline Table::Table(const ::test_typesinprotocols::Table& other) noexcept : Table(other.CloneStorage_()){}
    inline Table& ::test_typesinprotocols::Table::operator=(const Table& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline Table::Table(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Table(Storage_{}) {}

  
  
  
  
  

  
#ifdef __Fuchsia__


  inline ResourceStruct::ResourceStruct(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ResourceStruct::ResourceStruct(uint8_t __reserved) noexcept
    : storage_({
      .__reserved = std::move(__reserved)
    }) {}

  inline ResourceStruct::ResourceStruct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ResourceStruct(Storage_{
      .__reserved =0u,
  }) {}
    inline ResourceStruct& ResourceStruct::__reserved(uint8_t value) {
      storage_.__reserved = std::move(value);
      return *this;
    }

  

#endif  // __Fuchsia__

  
  
  
  

  
#ifdef __Fuchsia__


  inline ResourceTable::ResourceTable(Storage_ storage) noexcept : storage_(std::move(storage)) {}

  inline ResourceTable::ResourceTable(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ResourceTable(Storage_{}) {}

  

#endif  // __Fuchsia__

  
  
  
  

  

  inline Basic::Basic(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline Basic::Basic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::std::optional<::std::string> opt_string) noexcept
    : storage_({
      .uint8 = std::move(uint8), 
      .uint16 = std::move(uint16), 
      .uint32 = std::move(uint32), 
      .uint64 = std::move(uint64), 
      .int8 = std::move(int8), 
      .int16 = std::move(int16), 
      .int32 = std::move(int32), 
      .int64 = std::move(int64), 
      .float32 = std::move(float32), 
      .float64 = std::move(float64), 
      .string = std::move(string), 
      .opt_string = std::move(opt_string)
    }) {}
    inline Basic::Basic(const ::test_typesinprotocols::Basic& other) noexcept : ::test_typesinprotocols::Basic(other.CloneStorage_()){}
    inline Basic& ::test_typesinprotocols::Basic::operator=(const ::test_typesinprotocols::Basic& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline Basic::Basic(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Basic(Storage_{
      .uint8 ={},
      .uint16 ={},
      .uint32 ={},
      .uint64 ={},
      .int8 ={},
      .int16 ={},
      .int32 ={},
      .int64 ={},
      .float32 ={},
      .float64 ={},
      .string ={},
      .opt_string ={},
  }) {}
    inline Basic& Basic::uint8(uint8_t value) {
      storage_.uint8 = std::move(value);
      return *this;
    }
    inline Basic& Basic::uint16(uint16_t value) {
      storage_.uint16 = std::move(value);
      return *this;
    }
    inline Basic& Basic::uint32(uint32_t value) {
      storage_.uint32 = std::move(value);
      return *this;
    }
    inline Basic& Basic::uint64(uint64_t value) {
      storage_.uint64 = std::move(value);
      return *this;
    }
    inline Basic& Basic::int8(int8_t value) {
      storage_.int8 = std::move(value);
      return *this;
    }
    inline Basic& Basic::int16(int16_t value) {
      storage_.int16 = std::move(value);
      return *this;
    }
    inline Basic& Basic::int32(int32_t value) {
      storage_.int32 = std::move(value);
      return *this;
    }
    inline Basic& Basic::int64(int64_t value) {
      storage_.int64 = std::move(value);
      return *this;
    }
    inline Basic& Basic::float32(float value) {
      storage_.float32 = std::move(value);
      return *this;
    }
    inline Basic& Basic::float64(double value) {
      storage_.float64 = std::move(value);
      return *this;
    }
    inline Basic& Basic::string(::std::string value) {
      storage_.string = std::move(value);
      return *this;
    }
    inline Basic& Basic::opt_string(::std::optional<::std::string> value) {
      storage_.opt_string = std::move(value);
      return *this;
    }

  
  
  
  

  

  inline Compound::Compound(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline Compound::Compound(::test_typesinprotocols::Bits bits, ::test_typesinprotocols::Enum enum_, ::test_typesinprotocols::Struct struct_, ::test_typesinprotocols::Table table, ::test_typesinprotocols::Union union_, ::fidl::Box<::test_typesinprotocols::Struct> opt_struct, ::fidl::Box<::test_typesinprotocols::Union> opt_union) noexcept
    : storage_({
      .bits = std::move(bits), 
      .enum_ = std::move(enum_), 
      .struct_ = std::move(struct_), 
      .table = std::move(table), 
      .union_ = std::move(union_), 
      .opt_struct = std::move(opt_struct), 
      .opt_union = std::move(opt_union)
    }) {}
    inline Compound::Compound(const ::test_typesinprotocols::Compound& other) noexcept : ::test_typesinprotocols::Compound(other.CloneStorage_()){}
    inline Compound& ::test_typesinprotocols::Compound::operator=(const ::test_typesinprotocols::Compound& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline Compound::Compound(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Compound(Storage_{
      .bits ={},
      .enum_ ={},
      .struct_ =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
      .table =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
      .union_ =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
      .opt_struct ={},
      .opt_union ={},
  }) {}
    inline Compound& Compound::bits(::test_typesinprotocols::Bits value) {
      storage_.bits = std::move(value);
      return *this;
    }
    inline Compound& Compound::enum_(::test_typesinprotocols::Enum value) {
      storage_.enum_ = std::move(value);
      return *this;
    }
    inline Compound& Compound::struct_(::test_typesinprotocols::Struct value) {
      storage_.struct_ = std::move(value);
      return *this;
    }
    inline Compound& Compound::table(::test_typesinprotocols::Table value) {
      storage_.table = std::move(value);
      return *this;
    }
    inline Compound& Compound::union_(::test_typesinprotocols::Union value) {
      storage_.union_ = std::move(value);
      return *this;
    }
    inline Compound& Compound::opt_struct(::fidl::Box<::test_typesinprotocols::Struct> value) {
      storage_.opt_struct = std::move(value);
      return *this;
    }
    inline Compound& Compound::opt_union(::fidl::Box<::test_typesinprotocols::Union> value) {
      storage_.opt_union = std::move(value);
      return *this;
    }

  
  
  
  

  

  inline ArrayBasic::ArrayBasic(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ArrayBasic::ArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::std::optional<::std::string>, 5> array_opt_string) noexcept
    : storage_({
      .array_uint8 = std::move(array_uint8), 
      .array_uint16 = std::move(array_uint16), 
      .array_uint32 = std::move(array_uint32), 
      .array_uint64 = std::move(array_uint64), 
      .array_int8 = std::move(array_int8), 
      .array_int16 = std::move(array_int16), 
      .array_int32 = std::move(array_int32), 
      .array_int64 = std::move(array_int64), 
      .array_float32 = std::move(array_float32), 
      .array_float64 = std::move(array_float64), 
      .array_string = std::move(array_string), 
      .array_opt_string = std::move(array_opt_string)
    }) {}
    inline ArrayBasic::ArrayBasic(const ::test_typesinprotocols::ArrayBasic& other) noexcept : ::test_typesinprotocols::ArrayBasic(other.CloneStorage_()){}
    inline ArrayBasic& ::test_typesinprotocols::ArrayBasic::operator=(const ::test_typesinprotocols::ArrayBasic& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ArrayBasic::ArrayBasic(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ArrayBasic(Storage_{
      .array_uint8 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<uint8_t, 5>>::Make(),
      .array_uint16 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<uint16_t, 5>>::Make(),
      .array_uint32 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<uint32_t, 5>>::Make(),
      .array_uint64 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<uint64_t, 5>>::Make(),
      .array_int8 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<int8_t, 5>>::Make(),
      .array_int16 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<int16_t, 5>>::Make(),
      .array_int32 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<int32_t, 5>>::Make(),
      .array_int64 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<int64_t, 5>>::Make(),
      .array_float32 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<float, 5>>::Make(),
      .array_float64 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<double, 5>>::Make(),
      .array_string =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::std::string, 5>>::Make(),
      .array_opt_string =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::std::optional<::std::string>, 5>>::Make(),
  }) {}
    inline ArrayBasic& ArrayBasic::array_uint8(::std::array<uint8_t, 5> value) {
      storage_.array_uint8 = std::move(value);
      return *this;
    }
    inline ArrayBasic& ArrayBasic::array_uint16(::std::array<uint16_t, 5> value) {
      storage_.array_uint16 = std::move(value);
      return *this;
    }
    inline ArrayBasic& ArrayBasic::array_uint32(::std::array<uint32_t, 5> value) {
      storage_.array_uint32 = std::move(value);
      return *this;
    }
    inline ArrayBasic& ArrayBasic::array_uint64(::std::array<uint64_t, 5> value) {
      storage_.array_uint64 = std::move(value);
      return *this;
    }
    inline ArrayBasic& ArrayBasic::array_int8(::std::array<int8_t, 5> value) {
      storage_.array_int8 = std::move(value);
      return *this;
    }
    inline ArrayBasic& ArrayBasic::array_int16(::std::array<int16_t, 5> value) {
      storage_.array_int16 = std::move(value);
      return *this;
    }
    inline ArrayBasic& ArrayBasic::array_int32(::std::array<int32_t, 5> value) {
      storage_.array_int32 = std::move(value);
      return *this;
    }
    inline ArrayBasic& ArrayBasic::array_int64(::std::array<int64_t, 5> value) {
      storage_.array_int64 = std::move(value);
      return *this;
    }
    inline ArrayBasic& ArrayBasic::array_float32(::std::array<float, 5> value) {
      storage_.array_float32 = std::move(value);
      return *this;
    }
    inline ArrayBasic& ArrayBasic::array_float64(::std::array<double, 5> value) {
      storage_.array_float64 = std::move(value);
      return *this;
    }
    inline ArrayBasic& ArrayBasic::array_string(::std::array<::std::string, 5> value) {
      storage_.array_string = std::move(value);
      return *this;
    }
    inline ArrayBasic& ArrayBasic::array_opt_string(::std::array<::std::optional<::std::string>, 5> value) {
      storage_.array_opt_string = std::move(value);
      return *this;
    }

  
  
  
  

  

  inline ArrayCompound::ArrayCompound(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ArrayCompound::ArrayCompound(::std::array<::test_typesinprotocols::Bits, 5> array_bits, ::std::array<::test_typesinprotocols::Enum, 5> array_enum, ::std::array<::test_typesinprotocols::Struct, 5> array_struct, ::std::array<::test_typesinprotocols::Table, 5> array_table, ::std::array<::test_typesinprotocols::Union, 5> array_union, ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5> array_opt_union) noexcept
    : storage_({
      .array_bits = std::move(array_bits), 
      .array_enum = std::move(array_enum), 
      .array_struct = std::move(array_struct), 
      .array_table = std::move(array_table), 
      .array_union = std::move(array_union), 
      .array_opt_struct = std::move(array_opt_struct), 
      .array_opt_union = std::move(array_opt_union)
    }) {}
    inline ArrayCompound::ArrayCompound(const ::test_typesinprotocols::ArrayCompound& other) noexcept : ::test_typesinprotocols::ArrayCompound(other.CloneStorage_()){}
    inline ArrayCompound& ::test_typesinprotocols::ArrayCompound::operator=(const ::test_typesinprotocols::ArrayCompound& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ArrayCompound::ArrayCompound(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ArrayCompound(Storage_{
      .array_bits =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::Bits, 5>>::Make(),
      .array_enum =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::Enum, 5>>::Make(),
      .array_struct =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::Struct, 5>>::Make(),
      .array_table =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::Table, 5>>::Make(),
      .array_union =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::Union, 5>>::Make(),
      .array_opt_struct =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5>>::Make(),
      .array_opt_union =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5>>::Make(),
  }) {}
    inline ArrayCompound& ArrayCompound::array_bits(::std::array<::test_typesinprotocols::Bits, 5> value) {
      storage_.array_bits = std::move(value);
      return *this;
    }
    inline ArrayCompound& ArrayCompound::array_enum(::std::array<::test_typesinprotocols::Enum, 5> value) {
      storage_.array_enum = std::move(value);
      return *this;
    }
    inline ArrayCompound& ArrayCompound::array_struct(::std::array<::test_typesinprotocols::Struct, 5> value) {
      storage_.array_struct = std::move(value);
      return *this;
    }
    inline ArrayCompound& ArrayCompound::array_table(::std::array<::test_typesinprotocols::Table, 5> value) {
      storage_.array_table = std::move(value);
      return *this;
    }
    inline ArrayCompound& ArrayCompound::array_union(::std::array<::test_typesinprotocols::Union, 5> value) {
      storage_.array_union = std::move(value);
      return *this;
    }
    inline ArrayCompound& ArrayCompound::array_opt_struct(::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5> value) {
      storage_.array_opt_struct = std::move(value);
      return *this;
    }
    inline ArrayCompound& ArrayCompound::array_opt_union(::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5> value) {
      storage_.array_opt_union = std::move(value);
      return *this;
    }

  
  
  
  

  

  inline VectorBasic::VectorBasic(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline VectorBasic::VectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::std::optional<::std::string>> vector_opt_string) noexcept
    : storage_({
      .vector_uint8 = std::move(vector_uint8), 
      .vector_uint16 = std::move(vector_uint16), 
      .vector_uint32 = std::move(vector_uint32), 
      .vector_uint64 = std::move(vector_uint64), 
      .vector_int8 = std::move(vector_int8), 
      .vector_int16 = std::move(vector_int16), 
      .vector_int32 = std::move(vector_int32), 
      .vector_int64 = std::move(vector_int64), 
      .vector_float32 = std::move(vector_float32), 
      .vector_float64 = std::move(vector_float64), 
      .vector_string = std::move(vector_string), 
      .vector_opt_string = std::move(vector_opt_string)
    }) {}
    inline VectorBasic::VectorBasic(const ::test_typesinprotocols::VectorBasic& other) noexcept : ::test_typesinprotocols::VectorBasic(other.CloneStorage_()){}
    inline VectorBasic& ::test_typesinprotocols::VectorBasic::operator=(const ::test_typesinprotocols::VectorBasic& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline VectorBasic::VectorBasic(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : VectorBasic(Storage_{
      .vector_uint8 ={},
      .vector_uint16 ={},
      .vector_uint32 ={},
      .vector_uint64 ={},
      .vector_int8 ={},
      .vector_int16 ={},
      .vector_int32 ={},
      .vector_int64 ={},
      .vector_float32 ={},
      .vector_float64 ={},
      .vector_string ={},
      .vector_opt_string ={},
  }) {}
    inline VectorBasic& VectorBasic::vector_uint8(::std::vector<uint8_t> value) {
      storage_.vector_uint8 = std::move(value);
      return *this;
    }
    inline VectorBasic& VectorBasic::vector_uint16(::std::vector<uint16_t> value) {
      storage_.vector_uint16 = std::move(value);
      return *this;
    }
    inline VectorBasic& VectorBasic::vector_uint32(::std::vector<uint32_t> value) {
      storage_.vector_uint32 = std::move(value);
      return *this;
    }
    inline VectorBasic& VectorBasic::vector_uint64(::std::vector<uint64_t> value) {
      storage_.vector_uint64 = std::move(value);
      return *this;
    }
    inline VectorBasic& VectorBasic::vector_int8(::std::vector<int8_t> value) {
      storage_.vector_int8 = std::move(value);
      return *this;
    }
    inline VectorBasic& VectorBasic::vector_int16(::std::vector<int16_t> value) {
      storage_.vector_int16 = std::move(value);
      return *this;
    }
    inline VectorBasic& VectorBasic::vector_int32(::std::vector<int32_t> value) {
      storage_.vector_int32 = std::move(value);
      return *this;
    }
    inline VectorBasic& VectorBasic::vector_int64(::std::vector<int64_t> value) {
      storage_.vector_int64 = std::move(value);
      return *this;
    }
    inline VectorBasic& VectorBasic::vector_float32(::std::vector<float> value) {
      storage_.vector_float32 = std::move(value);
      return *this;
    }
    inline VectorBasic& VectorBasic::vector_float64(::std::vector<double> value) {
      storage_.vector_float64 = std::move(value);
      return *this;
    }
    inline VectorBasic& VectorBasic::vector_string(::std::vector<::std::string> value) {
      storage_.vector_string = std::move(value);
      return *this;
    }
    inline VectorBasic& VectorBasic::vector_opt_string(::std::vector<::std::optional<::std::string>> value) {
      storage_.vector_opt_string = std::move(value);
      return *this;
    }

  
  
  
  

  

  inline VectorCompound::VectorCompound(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline VectorCompound::VectorCompound(::std::vector<::test_typesinprotocols::Bits> vector_bits, ::std::vector<::test_typesinprotocols::Enum> vector_enum, ::std::vector<::test_typesinprotocols::Struct> vector_struct, ::std::vector<::test_typesinprotocols::Table> vector_table, ::std::vector<::test_typesinprotocols::Union> vector_union, ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::fidl::Box<::test_typesinprotocols::Union>> vector_opt_union) noexcept
    : storage_({
      .vector_bits = std::move(vector_bits), 
      .vector_enum = std::move(vector_enum), 
      .vector_struct = std::move(vector_struct), 
      .vector_table = std::move(vector_table), 
      .vector_union = std::move(vector_union), 
      .vector_opt_struct = std::move(vector_opt_struct), 
      .vector_opt_union = std::move(vector_opt_union)
    }) {}
    inline VectorCompound::VectorCompound(const ::test_typesinprotocols::VectorCompound& other) noexcept : ::test_typesinprotocols::VectorCompound(other.CloneStorage_()){}
    inline VectorCompound& ::test_typesinprotocols::VectorCompound::operator=(const ::test_typesinprotocols::VectorCompound& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline VectorCompound::VectorCompound(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : VectorCompound(Storage_{
      .vector_bits ={},
      .vector_enum ={},
      .vector_struct ={},
      .vector_table ={},
      .vector_union ={},
      .vector_opt_struct ={},
      .vector_opt_union ={},
  }) {}
    inline VectorCompound& VectorCompound::vector_bits(::std::vector<::test_typesinprotocols::Bits> value) {
      storage_.vector_bits = std::move(value);
      return *this;
    }
    inline VectorCompound& VectorCompound::vector_enum(::std::vector<::test_typesinprotocols::Enum> value) {
      storage_.vector_enum = std::move(value);
      return *this;
    }
    inline VectorCompound& VectorCompound::vector_struct(::std::vector<::test_typesinprotocols::Struct> value) {
      storage_.vector_struct = std::move(value);
      return *this;
    }
    inline VectorCompound& VectorCompound::vector_table(::std::vector<::test_typesinprotocols::Table> value) {
      storage_.vector_table = std::move(value);
      return *this;
    }
    inline VectorCompound& VectorCompound::vector_union(::std::vector<::test_typesinprotocols::Union> value) {
      storage_.vector_union = std::move(value);
      return *this;
    }
    inline VectorCompound& VectorCompound::vector_opt_struct(::std::vector<::fidl::Box<::test_typesinprotocols::Struct>> value) {
      storage_.vector_opt_struct = std::move(value);
      return *this;
    }
    inline VectorCompound& VectorCompound::vector_opt_union(::std::vector<::fidl::Box<::test_typesinprotocols::Union>> value) {
      storage_.vector_opt_union = std::move(value);
      return *this;
    }

  
  
  
  

  

  inline VectorOptional::VectorOptional(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline VectorOptional::VectorOptional(::std::optional<::std::vector<uint8_t>> opt_vector_uint8, ::std::optional<::std::vector<::std::string>> opt_vector_string, ::std::optional<::std::vector<::test_typesinprotocols::Struct>> opt_vector_struct, ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>> opt_vector_opt_struct) noexcept
    : storage_({
      .opt_vector_uint8 = std::move(opt_vector_uint8), 
      .opt_vector_string = std::move(opt_vector_string), 
      .opt_vector_struct = std::move(opt_vector_struct), 
      .opt_vector_opt_struct = std::move(opt_vector_opt_struct)
    }) {}
    inline VectorOptional::VectorOptional(const ::test_typesinprotocols::VectorOptional& other) noexcept : ::test_typesinprotocols::VectorOptional(other.CloneStorage_()){}
    inline VectorOptional& ::test_typesinprotocols::VectorOptional::operator=(const ::test_typesinprotocols::VectorOptional& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline VectorOptional::VectorOptional(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : VectorOptional(Storage_{
      .opt_vector_uint8 ={},
      .opt_vector_string ={},
      .opt_vector_struct ={},
      .opt_vector_opt_struct ={},
  }) {}
    inline VectorOptional& VectorOptional::opt_vector_uint8(::std::optional<::std::vector<uint8_t>> value) {
      storage_.opt_vector_uint8 = std::move(value);
      return *this;
    }
    inline VectorOptional& VectorOptional::opt_vector_string(::std::optional<::std::vector<::std::string>> value) {
      storage_.opt_vector_string = std::move(value);
      return *this;
    }
    inline VectorOptional& VectorOptional::opt_vector_struct(::std::optional<::std::vector<::test_typesinprotocols::Struct>> value) {
      storage_.opt_vector_struct = std::move(value);
      return *this;
    }
    inline VectorOptional& VectorOptional::opt_vector_opt_struct(::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>> value) {
      storage_.opt_vector_opt_struct = std::move(value);
      return *this;
    }

  
  
  
  

  

  inline ArrayVectorNested::ArrayVectorNested(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ArrayVectorNested::ArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) noexcept
    : storage_({
      .array_array_uint8 = std::move(array_array_uint8), 
      .array_vector_uint8 = std::move(array_vector_uint8), 
      .vector_array_uint8 = std::move(vector_array_uint8), 
      .vector_vector_uint8 = std::move(vector_vector_uint8)
    }) {}
    inline ArrayVectorNested::ArrayVectorNested(const ::test_typesinprotocols::ArrayVectorNested& other) noexcept : ::test_typesinprotocols::ArrayVectorNested(other.CloneStorage_()){}
    inline ArrayVectorNested& ::test_typesinprotocols::ArrayVectorNested::operator=(const ::test_typesinprotocols::ArrayVectorNested& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ArrayVectorNested::ArrayVectorNested(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ArrayVectorNested(Storage_{
      .array_array_uint8 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::std::array<uint8_t, 5>, 5>>::Make(),
      .array_vector_uint8 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::std::vector<uint8_t>, 5>>::Make(),
      .vector_array_uint8 ={},
      .vector_vector_uint8 ={},
  }) {}
    inline ArrayVectorNested& ArrayVectorNested::array_array_uint8(::std::array<::std::array<uint8_t, 5>, 5> value) {
      storage_.array_array_uint8 = std::move(value);
      return *this;
    }
    inline ArrayVectorNested& ArrayVectorNested::array_vector_uint8(::std::array<::std::vector<uint8_t>, 5> value) {
      storage_.array_vector_uint8 = std::move(value);
      return *this;
    }
    inline ArrayVectorNested& ArrayVectorNested::vector_array_uint8(::std::vector<::std::array<uint8_t, 5>> value) {
      storage_.vector_array_uint8 = std::move(value);
      return *this;
    }
    inline ArrayVectorNested& ArrayVectorNested::vector_vector_uint8(::std::vector<::std::vector<uint8_t>> value) {
      storage_.vector_vector_uint8 = std::move(value);
      return *this;
    }

  
  
  
  

  
#ifdef __Fuchsia__


  inline Resource::Resource(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline Resource::Resource(::zx::handle handle, ::zx::vmo vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol> server_end, ::test_typesinprotocols::ResourceStruct struct_, ::test_typesinprotocols::ResourceTable table, ::test_typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol> opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol> opt_server_end, ::fidl::Box<::test_typesinprotocols::ResourceStruct> opt_struct, ::fidl::Box<::test_typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test_typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test_typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test_typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test_typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test_typesinprotocols::ResourceTable> vector_table, ::std::vector<::test_typesinprotocols::ResourceUnion> vector_union) noexcept
    : storage_({
      .handle = std::move(handle), 
      .vmo = std::move(vmo), 
      .client_end = std::move(client_end), 
      .server_end = std::move(server_end), 
      .struct_ = std::move(struct_), 
      .table = std::move(table), 
      .union_ = std::move(union_), 
      .opt_handle = std::move(opt_handle), 
      .opt_vmo = std::move(opt_vmo), 
      .opt_client_end = std::move(opt_client_end), 
      .opt_server_end = std::move(opt_server_end), 
      .opt_struct = std::move(opt_struct), 
      .opt_union = std::move(opt_union), 
      .array_handle = std::move(array_handle), 
      .array_vmo = std::move(array_vmo), 
      .array_client_end = std::move(array_client_end), 
      .array_server_end = std::move(array_server_end), 
      .array_struct = std::move(array_struct), 
      .array_table = std::move(array_table), 
      .array_union = std::move(array_union), 
      .vector_handle = std::move(vector_handle), 
      .vector_vmo = std::move(vector_vmo), 
      .vector_client_end = std::move(vector_client_end), 
      .vector_server_end = std::move(vector_server_end), 
      .vector_struct = std::move(vector_struct), 
      .vector_table = std::move(vector_table), 
      .vector_union = std::move(vector_union)
    }) {}

  inline Resource::Resource(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Resource(Storage_{
      .handle ={},
      .vmo ={},
      .client_end ={},
      .server_end ={},
      .struct_ =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
      .table =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
      .union_ =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
      .opt_handle ={},
      .opt_vmo ={},
      .opt_client_end ={},
      .opt_server_end ={},
      .opt_struct ={},
      .opt_union ={},
      .array_handle =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::zx::handle, 5>>::Make(),
      .array_vmo =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::zx::vmo, 5>>::Make(),
      .array_client_end =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>>::Make(),
      .array_server_end =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>>::Make(),
      .array_struct =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::ResourceStruct, 5>>::Make(),
      .array_table =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::ResourceTable, 5>>::Make(),
      .array_union =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::ResourceUnion, 5>>::Make(),
      .vector_handle ={},
      .vector_vmo ={},
      .vector_client_end ={},
      .vector_server_end ={},
      .vector_struct ={},
      .vector_table ={},
      .vector_union ={},
  }) {}
    inline Resource& Resource::handle(::zx::handle value) {
      storage_.handle = std::move(value);
      return *this;
    }
    inline Resource& Resource::vmo(::zx::vmo value) {
      storage_.vmo = std::move(value);
      return *this;
    }
    inline Resource& Resource::client_end(::fidl::ClientEnd<::test_typesinprotocols::Protocol> value) {
      storage_.client_end = std::move(value);
      return *this;
    }
    inline Resource& Resource::server_end(::fidl::ServerEnd<::test_typesinprotocols::Protocol> value) {
      storage_.server_end = std::move(value);
      return *this;
    }
    inline Resource& Resource::struct_(::test_typesinprotocols::ResourceStruct value) {
      storage_.struct_ = std::move(value);
      return *this;
    }
    inline Resource& Resource::table(::test_typesinprotocols::ResourceTable value) {
      storage_.table = std::move(value);
      return *this;
    }
    inline Resource& Resource::union_(::test_typesinprotocols::ResourceUnion value) {
      storage_.union_ = std::move(value);
      return *this;
    }
    inline Resource& Resource::opt_handle(::zx::handle value) {
      storage_.opt_handle = std::move(value);
      return *this;
    }
    inline Resource& Resource::opt_vmo(::zx::vmo value) {
      storage_.opt_vmo = std::move(value);
      return *this;
    }
    inline Resource& Resource::opt_client_end(::fidl::ClientEnd<::test_typesinprotocols::Protocol> value) {
      storage_.opt_client_end = std::move(value);
      return *this;
    }
    inline Resource& Resource::opt_server_end(::fidl::ServerEnd<::test_typesinprotocols::Protocol> value) {
      storage_.opt_server_end = std::move(value);
      return *this;
    }
    inline Resource& Resource::opt_struct(::fidl::Box<::test_typesinprotocols::ResourceStruct> value) {
      storage_.opt_struct = std::move(value);
      return *this;
    }
    inline Resource& Resource::opt_union(::fidl::Box<::test_typesinprotocols::ResourceUnion> value) {
      storage_.opt_union = std::move(value);
      return *this;
    }
    inline Resource& Resource::array_handle(::std::array<::zx::handle, 5> value) {
      storage_.array_handle = std::move(value);
      return *this;
    }
    inline Resource& Resource::array_vmo(::std::array<::zx::vmo, 5> value) {
      storage_.array_vmo = std::move(value);
      return *this;
    }
    inline Resource& Resource::array_client_end(::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> value) {
      storage_.array_client_end = std::move(value);
      return *this;
    }
    inline Resource& Resource::array_server_end(::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> value) {
      storage_.array_server_end = std::move(value);
      return *this;
    }
    inline Resource& Resource::array_struct(::std::array<::test_typesinprotocols::ResourceStruct, 5> value) {
      storage_.array_struct = std::move(value);
      return *this;
    }
    inline Resource& Resource::array_table(::std::array<::test_typesinprotocols::ResourceTable, 5> value) {
      storage_.array_table = std::move(value);
      return *this;
    }
    inline Resource& Resource::array_union(::std::array<::test_typesinprotocols::ResourceUnion, 5> value) {
      storage_.array_union = std::move(value);
      return *this;
    }
    inline Resource& Resource::vector_handle(::std::vector<::zx::handle> value) {
      storage_.vector_handle = std::move(value);
      return *this;
    }
    inline Resource& Resource::vector_vmo(::std::vector<::zx::vmo> value) {
      storage_.vector_vmo = std::move(value);
      return *this;
    }
    inline Resource& Resource::vector_client_end(::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> value) {
      storage_.vector_client_end = std::move(value);
      return *this;
    }
    inline Resource& Resource::vector_server_end(::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> value) {
      storage_.vector_server_end = std::move(value);
      return *this;
    }
    inline Resource& Resource::vector_struct(::std::vector<::test_typesinprotocols::ResourceStruct> value) {
      storage_.vector_struct = std::move(value);
      return *this;
    }
    inline Resource& Resource::vector_table(::std::vector<::test_typesinprotocols::ResourceTable> value) {
      storage_.vector_table = std::move(value);
      return *this;
    }
    inline Resource& Resource::vector_union(::std::vector<::test_typesinprotocols::ResourceUnion> value) {
      storage_.vector_union = std::move(value);
      return *this;
    }

  

#endif  // __Fuchsia__

  
  
  
  
  

  

  inline ProtocolErrorBasicTopResponse::ProtocolErrorBasicTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ProtocolErrorBasicTopResponse::ProtocolErrorBasicTopResponse(::test_typesinprotocols::ProtocolErrorBasicResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline ProtocolErrorBasicTopResponse::ProtocolErrorBasicTopResponse(const ::test_typesinprotocols::ProtocolErrorBasicTopResponse& other) noexcept : ::test_typesinprotocols::ProtocolErrorBasicTopResponse(other.CloneStorage_()){}
    inline ProtocolErrorBasicTopResponse& ::test_typesinprotocols::ProtocolErrorBasicTopResponse::operator=(const ::test_typesinprotocols::ProtocolErrorBasicTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ProtocolErrorBasicTopResponse::ProtocolErrorBasicTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ProtocolErrorBasicTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline ProtocolErrorBasicTopResponse& ProtocolErrorBasicTopResponse::result(::test_typesinprotocols::ProtocolErrorBasicResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  

  inline ProtocolErrorCompoundTopResponse::ProtocolErrorCompoundTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ProtocolErrorCompoundTopResponse::ProtocolErrorCompoundTopResponse(::test_typesinprotocols::ProtocolErrorCompoundResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline ProtocolErrorCompoundTopResponse::ProtocolErrorCompoundTopResponse(const ::test_typesinprotocols::ProtocolErrorCompoundTopResponse& other) noexcept : ::test_typesinprotocols::ProtocolErrorCompoundTopResponse(other.CloneStorage_()){}
    inline ProtocolErrorCompoundTopResponse& ::test_typesinprotocols::ProtocolErrorCompoundTopResponse::operator=(const ::test_typesinprotocols::ProtocolErrorCompoundTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ProtocolErrorCompoundTopResponse::ProtocolErrorCompoundTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ProtocolErrorCompoundTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline ProtocolErrorCompoundTopResponse& ProtocolErrorCompoundTopResponse::result(::test_typesinprotocols::ProtocolErrorCompoundResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  

  inline ProtocolErrorArrayBasicTopResponse::ProtocolErrorArrayBasicTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ProtocolErrorArrayBasicTopResponse::ProtocolErrorArrayBasicTopResponse(::test_typesinprotocols::ProtocolErrorArrayBasicResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline ProtocolErrorArrayBasicTopResponse::ProtocolErrorArrayBasicTopResponse(const ::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse& other) noexcept : ::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse(other.CloneStorage_()){}
    inline ProtocolErrorArrayBasicTopResponse& ::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse::operator=(const ::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ProtocolErrorArrayBasicTopResponse::ProtocolErrorArrayBasicTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ProtocolErrorArrayBasicTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline ProtocolErrorArrayBasicTopResponse& ProtocolErrorArrayBasicTopResponse::result(::test_typesinprotocols::ProtocolErrorArrayBasicResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  

  inline ProtocolErrorArrayCompoundTopResponse::ProtocolErrorArrayCompoundTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ProtocolErrorArrayCompoundTopResponse::ProtocolErrorArrayCompoundTopResponse(::test_typesinprotocols::ProtocolErrorArrayCompoundResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline ProtocolErrorArrayCompoundTopResponse::ProtocolErrorArrayCompoundTopResponse(const ::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse& other) noexcept : ::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse(other.CloneStorage_()){}
    inline ProtocolErrorArrayCompoundTopResponse& ::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse::operator=(const ::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ProtocolErrorArrayCompoundTopResponse::ProtocolErrorArrayCompoundTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ProtocolErrorArrayCompoundTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline ProtocolErrorArrayCompoundTopResponse& ProtocolErrorArrayCompoundTopResponse::result(::test_typesinprotocols::ProtocolErrorArrayCompoundResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  

  inline ProtocolErrorVectorBasicTopResponse::ProtocolErrorVectorBasicTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ProtocolErrorVectorBasicTopResponse::ProtocolErrorVectorBasicTopResponse(::test_typesinprotocols::ProtocolErrorVectorBasicResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline ProtocolErrorVectorBasicTopResponse::ProtocolErrorVectorBasicTopResponse(const ::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse& other) noexcept : ::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse(other.CloneStorage_()){}
    inline ProtocolErrorVectorBasicTopResponse& ::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse::operator=(const ::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ProtocolErrorVectorBasicTopResponse::ProtocolErrorVectorBasicTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ProtocolErrorVectorBasicTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline ProtocolErrorVectorBasicTopResponse& ProtocolErrorVectorBasicTopResponse::result(::test_typesinprotocols::ProtocolErrorVectorBasicResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  

  inline ProtocolErrorVectorCompoundTopResponse::ProtocolErrorVectorCompoundTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ProtocolErrorVectorCompoundTopResponse::ProtocolErrorVectorCompoundTopResponse(::test_typesinprotocols::ProtocolErrorVectorCompoundResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline ProtocolErrorVectorCompoundTopResponse::ProtocolErrorVectorCompoundTopResponse(const ::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse& other) noexcept : ::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse(other.CloneStorage_()){}
    inline ProtocolErrorVectorCompoundTopResponse& ::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse::operator=(const ::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ProtocolErrorVectorCompoundTopResponse::ProtocolErrorVectorCompoundTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ProtocolErrorVectorCompoundTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline ProtocolErrorVectorCompoundTopResponse& ProtocolErrorVectorCompoundTopResponse::result(::test_typesinprotocols::ProtocolErrorVectorCompoundResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  

  inline ProtocolErrorVectorOptionalTopResponse::ProtocolErrorVectorOptionalTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ProtocolErrorVectorOptionalTopResponse::ProtocolErrorVectorOptionalTopResponse(::test_typesinprotocols::ProtocolErrorVectorOptionalResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline ProtocolErrorVectorOptionalTopResponse::ProtocolErrorVectorOptionalTopResponse(const ::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse& other) noexcept : ::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse(other.CloneStorage_()){}
    inline ProtocolErrorVectorOptionalTopResponse& ::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse::operator=(const ::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ProtocolErrorVectorOptionalTopResponse::ProtocolErrorVectorOptionalTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ProtocolErrorVectorOptionalTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline ProtocolErrorVectorOptionalTopResponse& ProtocolErrorVectorOptionalTopResponse::result(::test_typesinprotocols::ProtocolErrorVectorOptionalResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  

  inline ProtocolErrorArrayVectorNestedTopResponse::ProtocolErrorArrayVectorNestedTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ProtocolErrorArrayVectorNestedTopResponse::ProtocolErrorArrayVectorNestedTopResponse(::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline ProtocolErrorArrayVectorNestedTopResponse::ProtocolErrorArrayVectorNestedTopResponse(const ::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse& other) noexcept : ::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse(other.CloneStorage_()){}
    inline ProtocolErrorArrayVectorNestedTopResponse& ::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse::operator=(const ::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ProtocolErrorArrayVectorNestedTopResponse::ProtocolErrorArrayVectorNestedTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ProtocolErrorArrayVectorNestedTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline ProtocolErrorArrayVectorNestedTopResponse& ProtocolErrorArrayVectorNestedTopResponse::result(::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  
#ifdef __Fuchsia__


  inline ProtocolErrorResourceTopResponse::ProtocolErrorResourceTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ProtocolErrorResourceTopResponse::ProtocolErrorResourceTopResponse(::test_typesinprotocols::ProtocolErrorResourceResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}

  inline ProtocolErrorResourceTopResponse::ProtocolErrorResourceTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ProtocolErrorResourceTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline ProtocolErrorResourceTopResponse& ProtocolErrorResourceTopResponse::result(::test_typesinprotocols::ProtocolErrorResourceResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  

#endif  // __Fuchsia__

  
  
  

}  // namespace test_typesinprotocols
namespace fidl {


  

  extern "C" const fidl_type_t test_typesinprotocols_StructTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::Struct> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::Struct> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 1;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::Struct> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::Struct, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalEmptyStructCodingTraits<::test_typesinprotocols::Struct> {};

  
  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_typesinprotocols_ResourceStructTable;

  
  template <>
  struct IsResource<::test_typesinprotocols::ResourceStruct> : public std::true_type {};
  template <>
  struct IsFidlType<::test_typesinprotocols::ResourceStruct> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ResourceStruct> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 0;
    static constexpr uint32_t kPrimarySize = 1;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = false;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::ResourceStruct> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ResourceStruct, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalEmptyStructCodingTraits<::test_typesinprotocols::ResourceStruct> {};

  

#endif  // __Fuchsia__

  

  extern "C" const fidl_type_t test_typesinprotocols_BasicTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::Basic> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::Basic> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 80;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::Basic> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::Basic, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Basic, 80> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_CompoundTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::Compound> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::Compound> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 72;
    static constexpr uint32_t kMaxOutOfLine = 8;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::Compound> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::Compound, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Compound, 72> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_ArrayBasicTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ArrayBasic> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ArrayBasic> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 384;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::ArrayBasic> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ArrayBasic, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayBasic, 384> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_ArrayCompoundTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ArrayCompound> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ArrayCompound> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 328;
    static constexpr uint32_t kMaxOutOfLine = 40;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::ArrayCompound> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ArrayCompound, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayCompound, 328> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_VectorBasicTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::VectorBasic> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::VectorBasic> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 192;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::VectorBasic> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::VectorBasic, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorBasic, 192> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_VectorCompoundTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::VectorCompound> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::VectorCompound> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 112;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::VectorCompound> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::VectorCompound, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorCompound, 112> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_VectorOptionalTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::VectorOptional> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::VectorOptional> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 64;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::VectorOptional> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::VectorOptional, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorOptional, 64> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_ArrayVectorNestedTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ArrayVectorNested> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ArrayVectorNested> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 144;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = false;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::ArrayVectorNested> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ArrayVectorNested, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayVectorNested, 144> {};

  
  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_typesinprotocols_ResourceTable;

  
  template <>
  struct IsResource<::test_typesinprotocols::Resource> : public std::true_type {};
  template <>
  struct IsFidlType<::test_typesinprotocols::Resource> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::Resource> {
    static constexpr uint32_t kMaxNumHandles = 4294967295;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 456;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::Resource> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::Resource, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Resource, 456> {};

  

#endif  // __Fuchsia__

  

  extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorBasicTopResponseTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorBasicTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorBasicTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::ProtocolErrorBasicTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorBasicTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorBasicTopResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorCompoundTopResponseTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorCompoundTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorCompoundTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 80;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::ProtocolErrorCompoundTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorCompoundTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorCompoundTopResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayBasicTopResponseTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayCompoundTopResponseTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 368;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorBasicTopResponseTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorCompoundTopResponseTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorOptionalTopResponseTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayVectorNestedTopResponseTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse, 16> {};

  
  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorResourceTopResponseTable;

  
  template <>
  struct IsResource<::test_typesinprotocols::ProtocolErrorResourceTopResponse> : public std::true_type {};
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorResourceTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorResourceTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 4294967295;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_typesinprotocols::ProtocolErrorResourceTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorResourceTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ProtocolErrorResourceTopResponse, 16> {};

  

#endif  // __Fuchsia__


  

  extern "C" const fidl_type_t test_typesinprotocols_TableTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::Table> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::Table> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsTable<::test_typesinprotocols::Table> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::Table, ::fidl::internal::NaturalCodingConstraintEmpty> :
    public ::fidl::internal::NaturalTableCodingTraits<::test_typesinprotocols::Table> {};

  

  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_typesinprotocols_ResourceTableTable;

  
  template <>
  struct IsResource<::test_typesinprotocols::ResourceTable> : public std::true_type {};
  template <>
  struct IsFidlType<::test_typesinprotocols::ResourceTable> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ResourceTable> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsTable<::test_typesinprotocols::ResourceTable> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ResourceTable, ::fidl::internal::NaturalCodingConstraintEmpty> :
    public ::fidl::internal::NaturalTableCodingTraits<::test_typesinprotocols::ResourceTable> {};

  

#endif  // __Fuchsia__



  

  extern "C" const fidl_type_t test_typesinprotocols_UnionTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::Union> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::Union> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_typesinprotocols::Union> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::Union, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::Union> {};


  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_typesinprotocols_ResourceUnionTable;

  
  template <>
  struct IsResource<::test_typesinprotocols::ResourceUnion> : public std::true_type {};
  template <>
  struct IsFidlType<::test_typesinprotocols::ResourceUnion> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ResourceUnion> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_typesinprotocols::ResourceUnion> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ResourceUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ResourceUnion> {};



#endif  // __Fuchsia__

  

  extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorBasic_ResultTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorBasicResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorBasicResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_typesinprotocols::ProtocolErrorBasicResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorBasicResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorBasicResult> {};


  

  extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorCompound_ResultTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorCompoundResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorCompoundResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 80;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_typesinprotocols::ProtocolErrorCompoundResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorCompoundResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorCompoundResult> {};


  

  extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorArrayBasic_ResultTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorArrayBasicResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorArrayBasicResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_typesinprotocols::ProtocolErrorArrayBasicResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorArrayBasicResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorArrayBasicResult> {};


  

  extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorArrayCompound_ResultTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorArrayCompoundResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 368;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_typesinprotocols::ProtocolErrorArrayCompoundResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundResult> {};


  

  extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorVectorBasic_ResultTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorVectorBasicResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorVectorBasicResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_typesinprotocols::ProtocolErrorVectorBasicResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorVectorBasicResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorVectorBasicResult> {};


  

  extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorVectorCompound_ResultTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorVectorCompoundResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_typesinprotocols::ProtocolErrorVectorCompoundResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundResult> {};


  

  extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorVectorOptional_ResultTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorVectorOptionalResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_typesinprotocols::ProtocolErrorVectorOptionalResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalResult> {};


  

  extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorArrayVectorNested_ResultTable;

  
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult> {};


  
#ifdef __Fuchsia__


  extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorResource_ResultTable;

  
  template <>
  struct IsResource<::test_typesinprotocols::ProtocolErrorResourceResult> : public std::true_type {};
  template <>
  struct IsFidlType<::test_typesinprotocols::ProtocolErrorResourceResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_typesinprotocols::ProtocolErrorResourceResult> {
    static constexpr uint32_t kMaxNumHandles = 4294967295;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 4294967295;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_typesinprotocols::ProtocolErrorResourceResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorResourceResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorResourceResult> {};



#endif  // __Fuchsia__


  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::Bits, ::fidl::internal::NaturalCodingConstraintEmpty> {
    static constexpr size_t inline_size_v2 = sizeof(uint32_t);
    static constexpr bool is_memcpy_compatible = true;

    static void Encode(internal::NaturalEncoder* encoder, ::test_typesinprotocols::Bits* value, size_t offset, size_t recursion_depth) {
      *encoder->template GetPtr<::test_typesinprotocols::Bits>(offset) = *value;
    }
    static void Decode(internal::NaturalDecoder* decoder, ::test_typesinprotocols::Bits* value, size_t offset, size_t recursion_depth) {
      *value = *decoder->template GetPtr<::test_typesinprotocols::Bits>(offset);
    }
  };

  template <>
  struct internal::NaturalCodingTraits<::test_typesinprotocols::Enum, ::fidl::internal::NaturalCodingConstraintEmpty> {
    static constexpr size_t inline_size_v2 = sizeof(uint32_t);
    static constexpr bool is_memcpy_compatible = true;

    static void Encode(internal::NaturalEncoder* encoder, ::test_typesinprotocols::Enum* value, size_t offset, size_t recursion_depth) {
      *encoder->template GetPtr<::test_typesinprotocols::Enum>(offset) = *value;
    }
    static void Decode(internal::NaturalDecoder* decoder, ::test_typesinprotocols::Enum* value, size_t offset, size_t recursion_depth) {
      *value = *decoder->template GetPtr<::test_typesinprotocols::Enum>(offset);
    }
  };

#pragma clang diagnostic pop

}  // namespace fidl

