// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include <cinttypes>
#include <string>

#include <lib/fidl/cpp/natural_types.h>
#include <lib/fidl/cpp/natural_coding_traits.h>

#include <fidl/test.protocollayoutssamelibrary/cpp/markers.h>
#include <fidl/test.protocollayoutssamelibrary/cpp/common_types.h>


#ifdef __Fuchsia__

  #include <lib/zx/channel.h>
  

#endif  // __Fuchsia__


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_protocollayoutssamelibrary {





class ComposedProtocolTwoWayAnonComposedWithErrorTopResponse;


class ComposedProtocolOnAnonComposedWithErrorRequest;


class ComposedProtocolTwoWayNamedComposedWithErrorTopResponse;


class ComposedProtocolOnNamedComposedWithErrorRequest;


class MainProtocolTwoWayLocalWithErrorTopResponse;


class MainProtocolOnLocalWithErrorRequest;


class MainProtocolTwoWayAnonWithErrorTopResponse;


class MainProtocolOnAnonWithErrorRequest;




class TablePayload;



class ComposedProtocolOneWayAnonComposedRequest;



class ComposedProtocolTwoWayAnonComposedResponse;



class ComposedProtocolTwoWayAnonComposedWithErrorRequest;



class ComposedProtocolOnAnonComposedWithErrorResponse;



class MainProtocolOneWayAnonRequest;



class MainProtocolTwoWayAnonResponse;



class MainProtocolTwoWayAnonWithErrorRequest;



class MainProtocolOnAnonWithErrorResponse;




class UnionPayload;



class ComposedProtocolTwoWayAnonComposedRequest;



class ComposedProtocolTwoWayAnonComposedWithErrorResponse;



class ComposedProtocolTwoWayAnonComposedWithErrorResult;



class ComposedProtocolOnAnonComposedRequest;



class ComposedProtocolOnAnonComposedWithErrorResult;



class ComposedProtocolTwoWayNamedComposedWithErrorResult;



class ComposedProtocolOnNamedComposedWithErrorResult;



class MainProtocolTwoWayLocalWithErrorResult;



class MainProtocolOnLocalWithErrorResult;



class MainProtocolTwoWayAnonRequest;



class MainProtocolTwoWayAnonWithErrorResponse;



class MainProtocolTwoWayAnonWithErrorResult;



class MainProtocolOnAnonRequest;



class MainProtocolOnAnonWithErrorResult;




  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_TablePayloadTable;


class TablePayload {
 private:
  struct Storage_;
 public:
  TablePayload(Storage_ storage) noexcept;
  TablePayload() noexcept = default;
  TablePayload(TablePayload&&) noexcept = default;
  TablePayload& operator=(TablePayload&&) noexcept = default;
    TablePayload(const TablePayload& other) noexcept;
    TablePayload& operator=(const TablePayload& other) noexcept;
    bool operator==(const TablePayload& other) const noexcept {
      return ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::TablePayload>::Equal(this, &other);
    }
    bool operator!=(const TablePayload& other) const noexcept {
      return !::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::TablePayload>::Equal(this, &other);
    }

  bool IsEmpty() const {
      return !(storage_.a.has_value()
      );
  }
    
    const std::optional<uint16_t>& a() const { return storage_.a; }
    ::std::optional<uint16_t>& a() { return storage_.a; }

    // Setter for a.
    //
    
    TablePayload& a(std::optional<uint16_t> value);

  TablePayload(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::optional<uint16_t> a;
  };

  // TODO(https://fxbug.dev/91252): Box the storage.
  Storage_ storage_;
    Storage_ CloneStorage_() const;
  friend struct ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::TablePayload>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::TablePayload>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalTableMember<Storage_, uint16_t, fidl::internal::NaturalCodingConstraintEmpty>{
        1, &Storage_::a
      });
};

  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_UnionPayloadTable;


class UnionPayload {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , bool>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
  };

  UnionPayload(UnionPayload&& other) noexcept
      : UnionPayload(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  UnionPayload& operator=(UnionPayload&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    UnionPayload(const UnionPayload& other) noexcept : UnionPayload(other.CloneStorage_()){}
    UnionPayload& operator=(const UnionPayload& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const UnionPayload& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const UnionPayload& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocollayoutssamelibrary::UnionPayload::Tag Which() const {
    return UnionPayload::IndexToTag(storage_->index()).value();
  }
    static UnionPayload WithB(bool val) {
      return UnionPayload(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> b() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> b() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the b member.
    //
    
    UnionPayload& b(bool value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }

  UnionPayload(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::UnionPayload>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit UnionPayload(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::UnionPayload::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::UnionPayload::Tag::kB: return 1;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::UnionPayload::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::UnionPayload::Tag::kB;
        default: return std::nullopt;
    }
  }

};


  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolOneWayAnonComposedRequestTable;


class ComposedProtocolOneWayAnonComposedRequest {
 private:
  struct Storage_;
 public:
  ComposedProtocolOneWayAnonComposedRequest(Storage_ storage) noexcept;
  ComposedProtocolOneWayAnonComposedRequest() noexcept = default;
  ComposedProtocolOneWayAnonComposedRequest(ComposedProtocolOneWayAnonComposedRequest&&) noexcept = default;
  ComposedProtocolOneWayAnonComposedRequest& operator=(ComposedProtocolOneWayAnonComposedRequest&&) noexcept = default;
    ComposedProtocolOneWayAnonComposedRequest(const ComposedProtocolOneWayAnonComposedRequest& other) noexcept;
    ComposedProtocolOneWayAnonComposedRequest& operator=(const ComposedProtocolOneWayAnonComposedRequest& other) noexcept;
    bool operator==(const ComposedProtocolOneWayAnonComposedRequest& other) const noexcept {
      return ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest>::Equal(this, &other);
    }
    bool operator!=(const ComposedProtocolOneWayAnonComposedRequest& other) const noexcept {
      return !::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest>::Equal(this, &other);
    }

  bool IsEmpty() const {
      return !(storage_.a.has_value()
      );
  }
    
    const std::optional<uint16_t>& a() const { return storage_.a; }
    ::std::optional<uint16_t>& a() { return storage_.a; }

    // Setter for a.
    //
    
    ComposedProtocolOneWayAnonComposedRequest& a(std::optional<uint16_t> value);

  ComposedProtocolOneWayAnonComposedRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::optional<uint16_t> a;
  };

  // TODO(https://fxbug.dev/91252): Box the storage.
  Storage_ storage_;
    Storage_ CloneStorage_() const;
  friend struct ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalTableMember<Storage_, uint16_t, fidl::internal::NaturalCodingConstraintEmpty>{
        1, &Storage_::a
      });
};

  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolTwoWayAnonComposedRequestTable;


class ComposedProtocolTwoWayAnonComposedRequest {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , bool>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
  };

  ComposedProtocolTwoWayAnonComposedRequest(ComposedProtocolTwoWayAnonComposedRequest&& other) noexcept
      : ComposedProtocolTwoWayAnonComposedRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ComposedProtocolTwoWayAnonComposedRequest& operator=(ComposedProtocolTwoWayAnonComposedRequest&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ComposedProtocolTwoWayAnonComposedRequest(const ComposedProtocolTwoWayAnonComposedRequest& other) noexcept : ComposedProtocolTwoWayAnonComposedRequest(other.CloneStorage_()){}
    ComposedProtocolTwoWayAnonComposedRequest& operator=(const ComposedProtocolTwoWayAnonComposedRequest& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ComposedProtocolTwoWayAnonComposedRequest& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ComposedProtocolTwoWayAnonComposedRequest& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest::Tag Which() const {
    return ComposedProtocolTwoWayAnonComposedRequest::IndexToTag(storage_->index()).value();
  }
    static ComposedProtocolTwoWayAnonComposedRequest WithB(bool val) {
      return ComposedProtocolTwoWayAnonComposedRequest(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> b() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> b() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the b member.
    //
    
    ComposedProtocolTwoWayAnonComposedRequest& b(bool value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }

  ComposedProtocolTwoWayAnonComposedRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ComposedProtocolTwoWayAnonComposedRequest(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest::Tag::kB: return 1;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest::Tag::kB;
        default: return std::nullopt;
    }
  }

};


  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolTwoWayAnonComposedResponseTable;


class ComposedProtocolTwoWayAnonComposedResponse {
 private:
  struct Storage_;
 public:
  ComposedProtocolTwoWayAnonComposedResponse(Storage_ storage) noexcept;
  ComposedProtocolTwoWayAnonComposedResponse() noexcept = default;
  ComposedProtocolTwoWayAnonComposedResponse(ComposedProtocolTwoWayAnonComposedResponse&&) noexcept = default;
  ComposedProtocolTwoWayAnonComposedResponse& operator=(ComposedProtocolTwoWayAnonComposedResponse&&) noexcept = default;
    ComposedProtocolTwoWayAnonComposedResponse(const ComposedProtocolTwoWayAnonComposedResponse& other) noexcept;
    ComposedProtocolTwoWayAnonComposedResponse& operator=(const ComposedProtocolTwoWayAnonComposedResponse& other) noexcept;
    bool operator==(const ComposedProtocolTwoWayAnonComposedResponse& other) const noexcept {
      return ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedResponse>::Equal(this, &other);
    }
    bool operator!=(const ComposedProtocolTwoWayAnonComposedResponse& other) const noexcept {
      return !::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedResponse>::Equal(this, &other);
    }

  bool IsEmpty() const {
      return !(storage_.a.has_value()
      );
  }
    
    const std::optional<uint16_t>& a() const { return storage_.a; }
    ::std::optional<uint16_t>& a() { return storage_.a; }

    // Setter for a.
    //
    
    ComposedProtocolTwoWayAnonComposedResponse& a(std::optional<uint16_t> value);

  ComposedProtocolTwoWayAnonComposedResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::optional<uint16_t> a;
  };

  // TODO(https://fxbug.dev/91252): Box the storage.
  Storage_ storage_;
    Storage_ CloneStorage_() const;
  friend struct ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedResponse>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalTableMember<Storage_, uint16_t, fidl::internal::NaturalCodingConstraintEmpty>{
        1, &Storage_::a
      });
};

  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolTwoWayAnonComposedWithErrorRequestTable;


class ComposedProtocolTwoWayAnonComposedWithErrorRequest {
 private:
  struct Storage_;
 public:
  ComposedProtocolTwoWayAnonComposedWithErrorRequest(Storage_ storage) noexcept;
  ComposedProtocolTwoWayAnonComposedWithErrorRequest() noexcept = default;
  ComposedProtocolTwoWayAnonComposedWithErrorRequest(ComposedProtocolTwoWayAnonComposedWithErrorRequest&&) noexcept = default;
  ComposedProtocolTwoWayAnonComposedWithErrorRequest& operator=(ComposedProtocolTwoWayAnonComposedWithErrorRequest&&) noexcept = default;
    ComposedProtocolTwoWayAnonComposedWithErrorRequest(const ComposedProtocolTwoWayAnonComposedWithErrorRequest& other) noexcept;
    ComposedProtocolTwoWayAnonComposedWithErrorRequest& operator=(const ComposedProtocolTwoWayAnonComposedWithErrorRequest& other) noexcept;
    bool operator==(const ComposedProtocolTwoWayAnonComposedWithErrorRequest& other) const noexcept {
      return ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest>::Equal(this, &other);
    }
    bool operator!=(const ComposedProtocolTwoWayAnonComposedWithErrorRequest& other) const noexcept {
      return !::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest>::Equal(this, &other);
    }

  bool IsEmpty() const {
      return !(storage_.a.has_value()
      );
  }
    
    const std::optional<uint16_t>& a() const { return storage_.a; }
    ::std::optional<uint16_t>& a() { return storage_.a; }

    // Setter for a.
    //
    
    ComposedProtocolTwoWayAnonComposedWithErrorRequest& a(std::optional<uint16_t> value);

  ComposedProtocolTwoWayAnonComposedWithErrorRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::optional<uint16_t> a;
  };

  // TODO(https://fxbug.dev/91252): Box the storage.
  Storage_ storage_;
    Storage_ CloneStorage_() const;
  friend struct ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalTableMember<Storage_, uint16_t, fidl::internal::NaturalCodingConstraintEmpty>{
        1, &Storage_::a
      });
};

  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocol_TwoWayAnonComposedWithError_ResponseTable;


class ComposedProtocolTwoWayAnonComposedWithErrorResponse {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , bool>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
  };

  ComposedProtocolTwoWayAnonComposedWithErrorResponse(ComposedProtocolTwoWayAnonComposedWithErrorResponse&& other) noexcept
      : ComposedProtocolTwoWayAnonComposedWithErrorResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ComposedProtocolTwoWayAnonComposedWithErrorResponse& operator=(ComposedProtocolTwoWayAnonComposedWithErrorResponse&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ComposedProtocolTwoWayAnonComposedWithErrorResponse(const ComposedProtocolTwoWayAnonComposedWithErrorResponse& other) noexcept : ComposedProtocolTwoWayAnonComposedWithErrorResponse(other.CloneStorage_()){}
    ComposedProtocolTwoWayAnonComposedWithErrorResponse& operator=(const ComposedProtocolTwoWayAnonComposedWithErrorResponse& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ComposedProtocolTwoWayAnonComposedWithErrorResponse& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ComposedProtocolTwoWayAnonComposedWithErrorResponse& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag Which() const {
    return ComposedProtocolTwoWayAnonComposedWithErrorResponse::IndexToTag(storage_->index()).value();
  }
    static ComposedProtocolTwoWayAnonComposedWithErrorResponse WithB(bool val) {
      return ComposedProtocolTwoWayAnonComposedWithErrorResponse(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> b() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> b() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the b member.
    //
    
    ComposedProtocolTwoWayAnonComposedWithErrorResponse& b(bool value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }

  ComposedProtocolTwoWayAnonComposedWithErrorResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ComposedProtocolTwoWayAnonComposedWithErrorResponse(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag::kB: return 1;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag::kB;
        default: return std::nullopt;
    }
  }

};


  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocol_TwoWayAnonComposedWithError_ResultTable;


class ComposedProtocolTwoWayAnonComposedWithErrorResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  ComposedProtocolTwoWayAnonComposedWithErrorResult(ComposedProtocolTwoWayAnonComposedWithErrorResult&& other) noexcept
      : ComposedProtocolTwoWayAnonComposedWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ComposedProtocolTwoWayAnonComposedWithErrorResult& operator=(ComposedProtocolTwoWayAnonComposedWithErrorResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ComposedProtocolTwoWayAnonComposedWithErrorResult(const ComposedProtocolTwoWayAnonComposedWithErrorResult& other) noexcept : ComposedProtocolTwoWayAnonComposedWithErrorResult(other.CloneStorage_()){}
    ComposedProtocolTwoWayAnonComposedWithErrorResult& operator=(const ComposedProtocolTwoWayAnonComposedWithErrorResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ComposedProtocolTwoWayAnonComposedWithErrorResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ComposedProtocolTwoWayAnonComposedWithErrorResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag Which() const {
    return ComposedProtocolTwoWayAnonComposedWithErrorResult::IndexToTag(storage_->index()).value();
  }
    static ComposedProtocolTwoWayAnonComposedWithErrorResult WithResponse(::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse val) {
      return ComposedProtocolTwoWayAnonComposedWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    ComposedProtocolTwoWayAnonComposedWithErrorResult& response(::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static ComposedProtocolTwoWayAnonComposedWithErrorResult WithErr(uint32_t val) {
      return ComposedProtocolTwoWayAnonComposedWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    ComposedProtocolTwoWayAnonComposedWithErrorResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  ComposedProtocolTwoWayAnonComposedWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ComposedProtocolTwoWayAnonComposedWithErrorResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag::kResponse: return 1;
        case ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag::kResponse;
        case 2: return ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolTwoWayAnonComposedWithErrorTopResponseTable;


class ComposedProtocolTwoWayAnonComposedWithErrorTopResponse {
 private:
  struct Storage_;
 public:
  ComposedProtocolTwoWayAnonComposedWithErrorTopResponse(Storage_ storage) noexcept;
    ComposedProtocolTwoWayAnonComposedWithErrorTopResponse(::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ComposedProtocolTwoWayAnonComposedWithErrorTopResponse| only if all of its members are default constructible.
  ComposedProtocolTwoWayAnonComposedWithErrorTopResponse() = default;
#pragma clang diagnostic pop

  ComposedProtocolTwoWayAnonComposedWithErrorTopResponse(ComposedProtocolTwoWayAnonComposedWithErrorTopResponse&&) noexcept = default;
  ComposedProtocolTwoWayAnonComposedWithErrorTopResponse& operator=(ComposedProtocolTwoWayAnonComposedWithErrorTopResponse&&) noexcept = default;
    ComposedProtocolTwoWayAnonComposedWithErrorTopResponse(const ComposedProtocolTwoWayAnonComposedWithErrorTopResponse& other) noexcept;
    ComposedProtocolTwoWayAnonComposedWithErrorTopResponse& operator=(const ComposedProtocolTwoWayAnonComposedWithErrorTopResponse& other) noexcept;

    bool operator==(const ComposedProtocolTwoWayAnonComposedWithErrorTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const ComposedProtocolTwoWayAnonComposedWithErrorTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult &
    result() const {
      return storage_.result;
    }

    
    ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ComposedProtocolTwoWayAnonComposedWithErrorTopResponse& result(::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult value);

  ComposedProtocolTwoWayAnonComposedWithErrorTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolOnAnonComposedRequestTable;


class ComposedProtocolOnAnonComposedRequest {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , bool>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
  };

  ComposedProtocolOnAnonComposedRequest(ComposedProtocolOnAnonComposedRequest&& other) noexcept
      : ComposedProtocolOnAnonComposedRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ComposedProtocolOnAnonComposedRequest& operator=(ComposedProtocolOnAnonComposedRequest&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ComposedProtocolOnAnonComposedRequest(const ComposedProtocolOnAnonComposedRequest& other) noexcept : ComposedProtocolOnAnonComposedRequest(other.CloneStorage_()){}
    ComposedProtocolOnAnonComposedRequest& operator=(const ComposedProtocolOnAnonComposedRequest& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ComposedProtocolOnAnonComposedRequest& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ComposedProtocolOnAnonComposedRequest& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedRequest::Tag Which() const {
    return ComposedProtocolOnAnonComposedRequest::IndexToTag(storage_->index()).value();
  }
    static ComposedProtocolOnAnonComposedRequest WithB(bool val) {
      return ComposedProtocolOnAnonComposedRequest(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> b() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> b() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the b member.
    //
    
    ComposedProtocolOnAnonComposedRequest& b(bool value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }

  ComposedProtocolOnAnonComposedRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedRequest>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ComposedProtocolOnAnonComposedRequest(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedRequest::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedRequest::Tag::kB: return 1;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedRequest::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedRequest::Tag::kB;
        default: return std::nullopt;
    }
  }

};


  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocol_OnAnonComposedWithError_ResponseTable;


class ComposedProtocolOnAnonComposedWithErrorResponse {
 private:
  struct Storage_;
 public:
  ComposedProtocolOnAnonComposedWithErrorResponse(Storage_ storage) noexcept;
  ComposedProtocolOnAnonComposedWithErrorResponse() noexcept = default;
  ComposedProtocolOnAnonComposedWithErrorResponse(ComposedProtocolOnAnonComposedWithErrorResponse&&) noexcept = default;
  ComposedProtocolOnAnonComposedWithErrorResponse& operator=(ComposedProtocolOnAnonComposedWithErrorResponse&&) noexcept = default;
    ComposedProtocolOnAnonComposedWithErrorResponse(const ComposedProtocolOnAnonComposedWithErrorResponse& other) noexcept;
    ComposedProtocolOnAnonComposedWithErrorResponse& operator=(const ComposedProtocolOnAnonComposedWithErrorResponse& other) noexcept;
    bool operator==(const ComposedProtocolOnAnonComposedWithErrorResponse& other) const noexcept {
      return ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse>::Equal(this, &other);
    }
    bool operator!=(const ComposedProtocolOnAnonComposedWithErrorResponse& other) const noexcept {
      return !::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse>::Equal(this, &other);
    }

  bool IsEmpty() const {
      return !(storage_.a.has_value()
      );
  }
    
    const std::optional<uint16_t>& a() const { return storage_.a; }
    ::std::optional<uint16_t>& a() { return storage_.a; }

    // Setter for a.
    //
    
    ComposedProtocolOnAnonComposedWithErrorResponse& a(std::optional<uint16_t> value);

  ComposedProtocolOnAnonComposedWithErrorResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::optional<uint16_t> a;
  };

  // TODO(https://fxbug.dev/91252): Box the storage.
  Storage_ storage_;
    Storage_ CloneStorage_() const;
  friend struct ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalTableMember<Storage_, uint16_t, fidl::internal::NaturalCodingConstraintEmpty>{
        1, &Storage_::a
      });
};

  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocol_OnAnonComposedWithError_ResultTable;


class ComposedProtocolOnAnonComposedWithErrorResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  ComposedProtocolOnAnonComposedWithErrorResult(ComposedProtocolOnAnonComposedWithErrorResult&& other) noexcept
      : ComposedProtocolOnAnonComposedWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ComposedProtocolOnAnonComposedWithErrorResult& operator=(ComposedProtocolOnAnonComposedWithErrorResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ComposedProtocolOnAnonComposedWithErrorResult(const ComposedProtocolOnAnonComposedWithErrorResult& other) noexcept : ComposedProtocolOnAnonComposedWithErrorResult(other.CloneStorage_()){}
    ComposedProtocolOnAnonComposedWithErrorResult& operator=(const ComposedProtocolOnAnonComposedWithErrorResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ComposedProtocolOnAnonComposedWithErrorResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ComposedProtocolOnAnonComposedWithErrorResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult::Tag Which() const {
    return ComposedProtocolOnAnonComposedWithErrorResult::IndexToTag(storage_->index()).value();
  }
    static ComposedProtocolOnAnonComposedWithErrorResult WithResponse(::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse val) {
      return ComposedProtocolOnAnonComposedWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    ComposedProtocolOnAnonComposedWithErrorResult& response(::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static ComposedProtocolOnAnonComposedWithErrorResult WithErr(uint32_t val) {
      return ComposedProtocolOnAnonComposedWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    ComposedProtocolOnAnonComposedWithErrorResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  ComposedProtocolOnAnonComposedWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ComposedProtocolOnAnonComposedWithErrorResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult::Tag::kResponse: return 1;
        case ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult::Tag::kResponse;
        case 2: return ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolOnAnonComposedWithErrorRequestTable;


class ComposedProtocolOnAnonComposedWithErrorRequest {
 private:
  struct Storage_;
 public:
  ComposedProtocolOnAnonComposedWithErrorRequest(Storage_ storage) noexcept;
    ComposedProtocolOnAnonComposedWithErrorRequest(::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ComposedProtocolOnAnonComposedWithErrorRequest| only if all of its members are default constructible.
  ComposedProtocolOnAnonComposedWithErrorRequest() = default;
#pragma clang diagnostic pop

  ComposedProtocolOnAnonComposedWithErrorRequest(ComposedProtocolOnAnonComposedWithErrorRequest&&) noexcept = default;
  ComposedProtocolOnAnonComposedWithErrorRequest& operator=(ComposedProtocolOnAnonComposedWithErrorRequest&&) noexcept = default;
    ComposedProtocolOnAnonComposedWithErrorRequest(const ComposedProtocolOnAnonComposedWithErrorRequest& other) noexcept;
    ComposedProtocolOnAnonComposedWithErrorRequest& operator=(const ComposedProtocolOnAnonComposedWithErrorRequest& other) noexcept;

    bool operator==(const ComposedProtocolOnAnonComposedWithErrorRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorRequest, 16>::Equal(this, &other);
    }
    bool operator!=(const ComposedProtocolOnAnonComposedWithErrorRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorRequest, 16>::Equal(this, &other);
    }
    
      const ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult &
    result() const {
      return storage_.result;
    }

    
    ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ComposedProtocolOnAnonComposedWithErrorRequest& result(::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult value);

  ComposedProtocolOnAnonComposedWithErrorRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorRequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocol_TwoWayNamedComposedWithError_ResultTable;


class ComposedProtocolTwoWayNamedComposedWithErrorResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_protocollayoutssamelibrary::UnionPayload
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  ComposedProtocolTwoWayNamedComposedWithErrorResult(ComposedProtocolTwoWayNamedComposedWithErrorResult&& other) noexcept
      : ComposedProtocolTwoWayNamedComposedWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ComposedProtocolTwoWayNamedComposedWithErrorResult& operator=(ComposedProtocolTwoWayNamedComposedWithErrorResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ComposedProtocolTwoWayNamedComposedWithErrorResult(const ComposedProtocolTwoWayNamedComposedWithErrorResult& other) noexcept : ComposedProtocolTwoWayNamedComposedWithErrorResult(other.CloneStorage_()){}
    ComposedProtocolTwoWayNamedComposedWithErrorResult& operator=(const ComposedProtocolTwoWayNamedComposedWithErrorResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ComposedProtocolTwoWayNamedComposedWithErrorResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ComposedProtocolTwoWayNamedComposedWithErrorResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag Which() const {
    return ComposedProtocolTwoWayNamedComposedWithErrorResult::IndexToTag(storage_->index()).value();
  }
    static ComposedProtocolTwoWayNamedComposedWithErrorResult WithResponse(::test_protocollayoutssamelibrary::UnionPayload val) {
      return ComposedProtocolTwoWayNamedComposedWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    ComposedProtocolTwoWayNamedComposedWithErrorResult& response(::test_protocollayoutssamelibrary::UnionPayload value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static ComposedProtocolTwoWayNamedComposedWithErrorResult WithErr(uint32_t val) {
      return ComposedProtocolTwoWayNamedComposedWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    ComposedProtocolTwoWayNamedComposedWithErrorResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  ComposedProtocolTwoWayNamedComposedWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ComposedProtocolTwoWayNamedComposedWithErrorResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag::kResponse: return 1;
        case ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag::kResponse;
        case 2: return ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolTwoWayNamedComposedWithErrorTopResponseTable;


class ComposedProtocolTwoWayNamedComposedWithErrorTopResponse {
 private:
  struct Storage_;
 public:
  ComposedProtocolTwoWayNamedComposedWithErrorTopResponse(Storage_ storage) noexcept;
    ComposedProtocolTwoWayNamedComposedWithErrorTopResponse(::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ComposedProtocolTwoWayNamedComposedWithErrorTopResponse| only if all of its members are default constructible.
  ComposedProtocolTwoWayNamedComposedWithErrorTopResponse() = default;
#pragma clang diagnostic pop

  ComposedProtocolTwoWayNamedComposedWithErrorTopResponse(ComposedProtocolTwoWayNamedComposedWithErrorTopResponse&&) noexcept = default;
  ComposedProtocolTwoWayNamedComposedWithErrorTopResponse& operator=(ComposedProtocolTwoWayNamedComposedWithErrorTopResponse&&) noexcept = default;
    ComposedProtocolTwoWayNamedComposedWithErrorTopResponse(const ComposedProtocolTwoWayNamedComposedWithErrorTopResponse& other) noexcept;
    ComposedProtocolTwoWayNamedComposedWithErrorTopResponse& operator=(const ComposedProtocolTwoWayNamedComposedWithErrorTopResponse& other) noexcept;

    bool operator==(const ComposedProtocolTwoWayNamedComposedWithErrorTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const ComposedProtocolTwoWayNamedComposedWithErrorTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult &
    result() const {
      return storage_.result;
    }

    
    ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ComposedProtocolTwoWayNamedComposedWithErrorTopResponse& result(::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult value);

  ComposedProtocolTwoWayNamedComposedWithErrorTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocol_OnNamedComposedWithError_ResultTable;


class ComposedProtocolOnNamedComposedWithErrorResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_protocollayoutssamelibrary::TablePayload
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  ComposedProtocolOnNamedComposedWithErrorResult(ComposedProtocolOnNamedComposedWithErrorResult&& other) noexcept
      : ComposedProtocolOnNamedComposedWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  ComposedProtocolOnNamedComposedWithErrorResult& operator=(ComposedProtocolOnNamedComposedWithErrorResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    ComposedProtocolOnNamedComposedWithErrorResult(const ComposedProtocolOnNamedComposedWithErrorResult& other) noexcept : ComposedProtocolOnNamedComposedWithErrorResult(other.CloneStorage_()){}
    ComposedProtocolOnNamedComposedWithErrorResult& operator=(const ComposedProtocolOnNamedComposedWithErrorResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const ComposedProtocolOnNamedComposedWithErrorResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const ComposedProtocolOnNamedComposedWithErrorResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult::Tag Which() const {
    return ComposedProtocolOnNamedComposedWithErrorResult::IndexToTag(storage_->index()).value();
  }
    static ComposedProtocolOnNamedComposedWithErrorResult WithResponse(::test_protocollayoutssamelibrary::TablePayload val) {
      return ComposedProtocolOnNamedComposedWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    ComposedProtocolOnNamedComposedWithErrorResult& response(::test_protocollayoutssamelibrary::TablePayload value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static ComposedProtocolOnNamedComposedWithErrorResult WithErr(uint32_t val) {
      return ComposedProtocolOnNamedComposedWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    ComposedProtocolOnNamedComposedWithErrorResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  ComposedProtocolOnNamedComposedWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ComposedProtocolOnNamedComposedWithErrorResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult::Tag::kResponse: return 1;
        case ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult::Tag::kResponse;
        case 2: return ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolOnNamedComposedWithErrorRequestTable;


class ComposedProtocolOnNamedComposedWithErrorRequest {
 private:
  struct Storage_;
 public:
  ComposedProtocolOnNamedComposedWithErrorRequest(Storage_ storage) noexcept;
    ComposedProtocolOnNamedComposedWithErrorRequest(::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ComposedProtocolOnNamedComposedWithErrorRequest| only if all of its members are default constructible.
  ComposedProtocolOnNamedComposedWithErrorRequest() = default;
#pragma clang diagnostic pop

  ComposedProtocolOnNamedComposedWithErrorRequest(ComposedProtocolOnNamedComposedWithErrorRequest&&) noexcept = default;
  ComposedProtocolOnNamedComposedWithErrorRequest& operator=(ComposedProtocolOnNamedComposedWithErrorRequest&&) noexcept = default;
    ComposedProtocolOnNamedComposedWithErrorRequest(const ComposedProtocolOnNamedComposedWithErrorRequest& other) noexcept;
    ComposedProtocolOnNamedComposedWithErrorRequest& operator=(const ComposedProtocolOnNamedComposedWithErrorRequest& other) noexcept;

    bool operator==(const ComposedProtocolOnNamedComposedWithErrorRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorRequest, 16>::Equal(this, &other);
    }
    bool operator!=(const ComposedProtocolOnNamedComposedWithErrorRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorRequest, 16>::Equal(this, &other);
    }
    
      const ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult &
    result() const {
      return storage_.result;
    }

    
    ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    ComposedProtocolOnNamedComposedWithErrorRequest& result(::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult value);

  ComposedProtocolOnNamedComposedWithErrorRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorRequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocol_TwoWayLocalWithError_ResultTable;


class MainProtocolTwoWayLocalWithErrorResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_protocollayoutssamelibrary::UnionPayload
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  MainProtocolTwoWayLocalWithErrorResult(MainProtocolTwoWayLocalWithErrorResult&& other) noexcept
      : MainProtocolTwoWayLocalWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  MainProtocolTwoWayLocalWithErrorResult& operator=(MainProtocolTwoWayLocalWithErrorResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    MainProtocolTwoWayLocalWithErrorResult(const MainProtocolTwoWayLocalWithErrorResult& other) noexcept : MainProtocolTwoWayLocalWithErrorResult(other.CloneStorage_()){}
    MainProtocolTwoWayLocalWithErrorResult& operator=(const MainProtocolTwoWayLocalWithErrorResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const MainProtocolTwoWayLocalWithErrorResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const MainProtocolTwoWayLocalWithErrorResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult::Tag Which() const {
    return MainProtocolTwoWayLocalWithErrorResult::IndexToTag(storage_->index()).value();
  }
    static MainProtocolTwoWayLocalWithErrorResult WithResponse(::test_protocollayoutssamelibrary::UnionPayload val) {
      return MainProtocolTwoWayLocalWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    MainProtocolTwoWayLocalWithErrorResult& response(::test_protocollayoutssamelibrary::UnionPayload value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static MainProtocolTwoWayLocalWithErrorResult WithErr(uint32_t val) {
      return MainProtocolTwoWayLocalWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    MainProtocolTwoWayLocalWithErrorResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  MainProtocolTwoWayLocalWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit MainProtocolTwoWayLocalWithErrorResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult::Tag::kResponse: return 1;
        case ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult::Tag::kResponse;
        case 2: return ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolTwoWayLocalWithErrorTopResponseTable;


class MainProtocolTwoWayLocalWithErrorTopResponse {
 private:
  struct Storage_;
 public:
  MainProtocolTwoWayLocalWithErrorTopResponse(Storage_ storage) noexcept;
    MainProtocolTwoWayLocalWithErrorTopResponse(::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |MainProtocolTwoWayLocalWithErrorTopResponse| only if all of its members are default constructible.
  MainProtocolTwoWayLocalWithErrorTopResponse() = default;
#pragma clang diagnostic pop

  MainProtocolTwoWayLocalWithErrorTopResponse(MainProtocolTwoWayLocalWithErrorTopResponse&&) noexcept = default;
  MainProtocolTwoWayLocalWithErrorTopResponse& operator=(MainProtocolTwoWayLocalWithErrorTopResponse&&) noexcept = default;
    MainProtocolTwoWayLocalWithErrorTopResponse(const MainProtocolTwoWayLocalWithErrorTopResponse& other) noexcept;
    MainProtocolTwoWayLocalWithErrorTopResponse& operator=(const MainProtocolTwoWayLocalWithErrorTopResponse& other) noexcept;

    bool operator==(const MainProtocolTwoWayLocalWithErrorTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const MainProtocolTwoWayLocalWithErrorTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult &
    result() const {
      return storage_.result;
    }

    
    ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    MainProtocolTwoWayLocalWithErrorTopResponse& result(::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult value);

  MainProtocolTwoWayLocalWithErrorTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocol_OnLocalWithError_ResultTable;


class MainProtocolOnLocalWithErrorResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_protocollayoutssamelibrary::TablePayload
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  MainProtocolOnLocalWithErrorResult(MainProtocolOnLocalWithErrorResult&& other) noexcept
      : MainProtocolOnLocalWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  MainProtocolOnLocalWithErrorResult& operator=(MainProtocolOnLocalWithErrorResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    MainProtocolOnLocalWithErrorResult(const MainProtocolOnLocalWithErrorResult& other) noexcept : MainProtocolOnLocalWithErrorResult(other.CloneStorage_()){}
    MainProtocolOnLocalWithErrorResult& operator=(const MainProtocolOnLocalWithErrorResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const MainProtocolOnLocalWithErrorResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const MainProtocolOnLocalWithErrorResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult::Tag Which() const {
    return MainProtocolOnLocalWithErrorResult::IndexToTag(storage_->index()).value();
  }
    static MainProtocolOnLocalWithErrorResult WithResponse(::test_protocollayoutssamelibrary::TablePayload val) {
      return MainProtocolOnLocalWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    MainProtocolOnLocalWithErrorResult& response(::test_protocollayoutssamelibrary::TablePayload value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static MainProtocolOnLocalWithErrorResult WithErr(uint32_t val) {
      return MainProtocolOnLocalWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    MainProtocolOnLocalWithErrorResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  MainProtocolOnLocalWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit MainProtocolOnLocalWithErrorResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult::Tag::kResponse: return 1;
        case ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult::Tag::kResponse;
        case 2: return ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolOnLocalWithErrorRequestTable;


class MainProtocolOnLocalWithErrorRequest {
 private:
  struct Storage_;
 public:
  MainProtocolOnLocalWithErrorRequest(Storage_ storage) noexcept;
    MainProtocolOnLocalWithErrorRequest(::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |MainProtocolOnLocalWithErrorRequest| only if all of its members are default constructible.
  MainProtocolOnLocalWithErrorRequest() = default;
#pragma clang diagnostic pop

  MainProtocolOnLocalWithErrorRequest(MainProtocolOnLocalWithErrorRequest&&) noexcept = default;
  MainProtocolOnLocalWithErrorRequest& operator=(MainProtocolOnLocalWithErrorRequest&&) noexcept = default;
    MainProtocolOnLocalWithErrorRequest(const MainProtocolOnLocalWithErrorRequest& other) noexcept;
    MainProtocolOnLocalWithErrorRequest& operator=(const MainProtocolOnLocalWithErrorRequest& other) noexcept;

    bool operator==(const MainProtocolOnLocalWithErrorRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorRequest, 16>::Equal(this, &other);
    }
    bool operator!=(const MainProtocolOnLocalWithErrorRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorRequest, 16>::Equal(this, &other);
    }
    
      const ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult &
    result() const {
      return storage_.result;
    }

    
    ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    MainProtocolOnLocalWithErrorRequest& result(::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult value);

  MainProtocolOnLocalWithErrorRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorRequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolOneWayAnonRequestTable;


class MainProtocolOneWayAnonRequest {
 private:
  struct Storage_;
 public:
  MainProtocolOneWayAnonRequest(Storage_ storage) noexcept;
  MainProtocolOneWayAnonRequest() noexcept = default;
  MainProtocolOneWayAnonRequest(MainProtocolOneWayAnonRequest&&) noexcept = default;
  MainProtocolOneWayAnonRequest& operator=(MainProtocolOneWayAnonRequest&&) noexcept = default;
    MainProtocolOneWayAnonRequest(const MainProtocolOneWayAnonRequest& other) noexcept;
    MainProtocolOneWayAnonRequest& operator=(const MainProtocolOneWayAnonRequest& other) noexcept;
    bool operator==(const MainProtocolOneWayAnonRequest& other) const noexcept {
      return ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOneWayAnonRequest>::Equal(this, &other);
    }
    bool operator!=(const MainProtocolOneWayAnonRequest& other) const noexcept {
      return !::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOneWayAnonRequest>::Equal(this, &other);
    }

  bool IsEmpty() const {
      return !(storage_.a.has_value()
      );
  }
    
    const std::optional<uint16_t>& a() const { return storage_.a; }
    ::std::optional<uint16_t>& a() { return storage_.a; }

    // Setter for a.
    //
    
    MainProtocolOneWayAnonRequest& a(std::optional<uint16_t> value);

  MainProtocolOneWayAnonRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::optional<uint16_t> a;
  };

  // TODO(https://fxbug.dev/91252): Box the storage.
  Storage_ storage_;
    Storage_ CloneStorage_() const;
  friend struct ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOneWayAnonRequest>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::MainProtocolOneWayAnonRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalTableMember<Storage_, uint16_t, fidl::internal::NaturalCodingConstraintEmpty>{
        1, &Storage_::a
      });
};

  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolTwoWayAnonRequestTable;


class MainProtocolTwoWayAnonRequest {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , bool>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  MainProtocolTwoWayAnonRequest(MainProtocolTwoWayAnonRequest&& other) noexcept
      : MainProtocolTwoWayAnonRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  MainProtocolTwoWayAnonRequest& operator=(MainProtocolTwoWayAnonRequest&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    MainProtocolTwoWayAnonRequest(const MainProtocolTwoWayAnonRequest& other) noexcept : MainProtocolTwoWayAnonRequest(other.CloneStorage_()){}
    MainProtocolTwoWayAnonRequest& operator=(const MainProtocolTwoWayAnonRequest& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const MainProtocolTwoWayAnonRequest& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const MainProtocolTwoWayAnonRequest& other) const noexcept {
      return *storage_ != *other.storage_;
    }
  constexpr bool IsUnknown() const {
    return Which() == ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  constexpr ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest::Tag Which() const {
    return MainProtocolTwoWayAnonRequest::IndexToTag(storage_->index()).value();
  }
    static MainProtocolTwoWayAnonRequest WithB(bool val) {
      return MainProtocolTwoWayAnonRequest(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> b() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> b() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the b member.
    //
    
    MainProtocolTwoWayAnonRequest& b(bool value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }

  MainProtocolTwoWayAnonRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit MainProtocolTwoWayAnonRequest(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest::Tag::kB: return 1;
      default: {
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest::Tag::kB;
        default: return ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
    }
  }

};


  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolTwoWayAnonResponseTable;


class MainProtocolTwoWayAnonResponse {
 private:
  struct Storage_;
 public:
  MainProtocolTwoWayAnonResponse(Storage_ storage) noexcept;
  MainProtocolTwoWayAnonResponse() noexcept = default;
  MainProtocolTwoWayAnonResponse(MainProtocolTwoWayAnonResponse&&) noexcept = default;
  MainProtocolTwoWayAnonResponse& operator=(MainProtocolTwoWayAnonResponse&&) noexcept = default;
    MainProtocolTwoWayAnonResponse(const MainProtocolTwoWayAnonResponse& other) noexcept;
    MainProtocolTwoWayAnonResponse& operator=(const MainProtocolTwoWayAnonResponse& other) noexcept;
    bool operator==(const MainProtocolTwoWayAnonResponse& other) const noexcept {
      return ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonResponse>::Equal(this, &other);
    }
    bool operator!=(const MainProtocolTwoWayAnonResponse& other) const noexcept {
      return !::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonResponse>::Equal(this, &other);
    }

  bool IsEmpty() const {
      return !(storage_.a.has_value()
      );
  }
    
    const std::optional<uint16_t>& a() const { return storage_.a; }
    ::std::optional<uint16_t>& a() { return storage_.a; }

    // Setter for a.
    //
    
    MainProtocolTwoWayAnonResponse& a(std::optional<uint16_t> value);

  MainProtocolTwoWayAnonResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::optional<uint16_t> a;
  };

  // TODO(https://fxbug.dev/91252): Box the storage.
  Storage_ storage_;
    Storage_ CloneStorage_() const;
  friend struct ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonResponse>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalTableMember<Storage_, uint16_t, fidl::internal::NaturalCodingConstraintEmpty>{
        1, &Storage_::a
      });
};

  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolTwoWayAnonWithErrorRequestTable;


class MainProtocolTwoWayAnonWithErrorRequest {
 private:
  struct Storage_;
 public:
  MainProtocolTwoWayAnonWithErrorRequest(Storage_ storage) noexcept;
  MainProtocolTwoWayAnonWithErrorRequest() noexcept = default;
  MainProtocolTwoWayAnonWithErrorRequest(MainProtocolTwoWayAnonWithErrorRequest&&) noexcept = default;
  MainProtocolTwoWayAnonWithErrorRequest& operator=(MainProtocolTwoWayAnonWithErrorRequest&&) noexcept = default;
    MainProtocolTwoWayAnonWithErrorRequest(const MainProtocolTwoWayAnonWithErrorRequest& other) noexcept;
    MainProtocolTwoWayAnonWithErrorRequest& operator=(const MainProtocolTwoWayAnonWithErrorRequest& other) noexcept;
    bool operator==(const MainProtocolTwoWayAnonWithErrorRequest& other) const noexcept {
      return ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest>::Equal(this, &other);
    }
    bool operator!=(const MainProtocolTwoWayAnonWithErrorRequest& other) const noexcept {
      return !::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest>::Equal(this, &other);
    }

  bool IsEmpty() const {
      return !(storage_.a.has_value()
      );
  }
    
    const std::optional<uint16_t>& a() const { return storage_.a; }
    ::std::optional<uint16_t>& a() { return storage_.a; }

    // Setter for a.
    //
    
    MainProtocolTwoWayAnonWithErrorRequest& a(std::optional<uint16_t> value);

  MainProtocolTwoWayAnonWithErrorRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::optional<uint16_t> a;
  };

  // TODO(https://fxbug.dev/91252): Box the storage.
  Storage_ storage_;
    Storage_ CloneStorage_() const;
  friend struct ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalTableMember<Storage_, uint16_t, fidl::internal::NaturalCodingConstraintEmpty>{
        1, &Storage_::a
      });
};

  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocol_TwoWayAnonWithError_ResponseTable;


class MainProtocolTwoWayAnonWithErrorResponse {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , bool>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  MainProtocolTwoWayAnonWithErrorResponse(MainProtocolTwoWayAnonWithErrorResponse&& other) noexcept
      : MainProtocolTwoWayAnonWithErrorResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  MainProtocolTwoWayAnonWithErrorResponse& operator=(MainProtocolTwoWayAnonWithErrorResponse&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    MainProtocolTwoWayAnonWithErrorResponse(const MainProtocolTwoWayAnonWithErrorResponse& other) noexcept : MainProtocolTwoWayAnonWithErrorResponse(other.CloneStorage_()){}
    MainProtocolTwoWayAnonWithErrorResponse& operator=(const MainProtocolTwoWayAnonWithErrorResponse& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const MainProtocolTwoWayAnonWithErrorResponse& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const MainProtocolTwoWayAnonWithErrorResponse& other) const noexcept {
      return *storage_ != *other.storage_;
    }
  constexpr bool IsUnknown() const {
    return Which() == ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  constexpr ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse::Tag Which() const {
    return MainProtocolTwoWayAnonWithErrorResponse::IndexToTag(storage_->index()).value();
  }
    static MainProtocolTwoWayAnonWithErrorResponse WithB(bool val) {
      return MainProtocolTwoWayAnonWithErrorResponse(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> b() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> b() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the b member.
    //
    
    MainProtocolTwoWayAnonWithErrorResponse& b(bool value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }

  MainProtocolTwoWayAnonWithErrorResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit MainProtocolTwoWayAnonWithErrorResponse(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse::Tag::kB: return 1;
      default: {
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse::Tag::kB;
        default: return ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
    }
  }

};


  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocol_TwoWayAnonWithError_ResultTable;


class MainProtocolTwoWayAnonWithErrorResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  MainProtocolTwoWayAnonWithErrorResult(MainProtocolTwoWayAnonWithErrorResult&& other) noexcept
      : MainProtocolTwoWayAnonWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  MainProtocolTwoWayAnonWithErrorResult& operator=(MainProtocolTwoWayAnonWithErrorResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    MainProtocolTwoWayAnonWithErrorResult(const MainProtocolTwoWayAnonWithErrorResult& other) noexcept : MainProtocolTwoWayAnonWithErrorResult(other.CloneStorage_()){}
    MainProtocolTwoWayAnonWithErrorResult& operator=(const MainProtocolTwoWayAnonWithErrorResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const MainProtocolTwoWayAnonWithErrorResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const MainProtocolTwoWayAnonWithErrorResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult::Tag Which() const {
    return MainProtocolTwoWayAnonWithErrorResult::IndexToTag(storage_->index()).value();
  }
    static MainProtocolTwoWayAnonWithErrorResult WithResponse(::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse val) {
      return MainProtocolTwoWayAnonWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    MainProtocolTwoWayAnonWithErrorResult& response(::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static MainProtocolTwoWayAnonWithErrorResult WithErr(uint32_t val) {
      return MainProtocolTwoWayAnonWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    MainProtocolTwoWayAnonWithErrorResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  MainProtocolTwoWayAnonWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit MainProtocolTwoWayAnonWithErrorResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult::Tag::kResponse: return 1;
        case ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult::Tag::kResponse;
        case 2: return ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolTwoWayAnonWithErrorTopResponseTable;


class MainProtocolTwoWayAnonWithErrorTopResponse {
 private:
  struct Storage_;
 public:
  MainProtocolTwoWayAnonWithErrorTopResponse(Storage_ storage) noexcept;
    MainProtocolTwoWayAnonWithErrorTopResponse(::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |MainProtocolTwoWayAnonWithErrorTopResponse| only if all of its members are default constructible.
  MainProtocolTwoWayAnonWithErrorTopResponse() = default;
#pragma clang diagnostic pop

  MainProtocolTwoWayAnonWithErrorTopResponse(MainProtocolTwoWayAnonWithErrorTopResponse&&) noexcept = default;
  MainProtocolTwoWayAnonWithErrorTopResponse& operator=(MainProtocolTwoWayAnonWithErrorTopResponse&&) noexcept = default;
    MainProtocolTwoWayAnonWithErrorTopResponse(const MainProtocolTwoWayAnonWithErrorTopResponse& other) noexcept;
    MainProtocolTwoWayAnonWithErrorTopResponse& operator=(const MainProtocolTwoWayAnonWithErrorTopResponse& other) noexcept;

    bool operator==(const MainProtocolTwoWayAnonWithErrorTopResponse& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorTopResponse, 16>::Equal(this, &other);
    }
    bool operator!=(const MainProtocolTwoWayAnonWithErrorTopResponse& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorTopResponse, 16>::Equal(this, &other);
    }
    
      const ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult &
    result() const {
      return storage_.result;
    }

    
    ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    MainProtocolTwoWayAnonWithErrorTopResponse& result(::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult value);

  MainProtocolTwoWayAnonWithErrorTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorTopResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorTopResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolOnAnonRequestTable;


class MainProtocolOnAnonRequest {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , bool>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  MainProtocolOnAnonRequest(MainProtocolOnAnonRequest&& other) noexcept
      : MainProtocolOnAnonRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  MainProtocolOnAnonRequest& operator=(MainProtocolOnAnonRequest&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    MainProtocolOnAnonRequest(const MainProtocolOnAnonRequest& other) noexcept : MainProtocolOnAnonRequest(other.CloneStorage_()){}
    MainProtocolOnAnonRequest& operator=(const MainProtocolOnAnonRequest& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const MainProtocolOnAnonRequest& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const MainProtocolOnAnonRequest& other) const noexcept {
      return *storage_ != *other.storage_;
    }
  constexpr bool IsUnknown() const {
    return Which() == ::test_protocollayoutssamelibrary::MainProtocolOnAnonRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  constexpr ::test_protocollayoutssamelibrary::MainProtocolOnAnonRequest::Tag Which() const {
    return MainProtocolOnAnonRequest::IndexToTag(storage_->index()).value();
  }
    static MainProtocolOnAnonRequest WithB(bool val) {
      return MainProtocolOnAnonRequest(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> b() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> b() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the b member.
    //
    
    MainProtocolOnAnonRequest& b(bool value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }

  MainProtocolOnAnonRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonRequest>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit MainProtocolOnAnonRequest(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::MainProtocolOnAnonRequest::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::MainProtocolOnAnonRequest::Tag::kB: return 1;
      default: {
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::MainProtocolOnAnonRequest::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::MainProtocolOnAnonRequest::Tag::kB;
        default: return ::test_protocollayoutssamelibrary::MainProtocolOnAnonRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
    }
  }

};


  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocol_OnAnonWithError_ResponseTable;


class MainProtocolOnAnonWithErrorResponse {
 private:
  struct Storage_;
 public:
  MainProtocolOnAnonWithErrorResponse(Storage_ storage) noexcept;
  MainProtocolOnAnonWithErrorResponse() noexcept = default;
  MainProtocolOnAnonWithErrorResponse(MainProtocolOnAnonWithErrorResponse&&) noexcept = default;
  MainProtocolOnAnonWithErrorResponse& operator=(MainProtocolOnAnonWithErrorResponse&&) noexcept = default;
    MainProtocolOnAnonWithErrorResponse(const MainProtocolOnAnonWithErrorResponse& other) noexcept;
    MainProtocolOnAnonWithErrorResponse& operator=(const MainProtocolOnAnonWithErrorResponse& other) noexcept;
    bool operator==(const MainProtocolOnAnonWithErrorResponse& other) const noexcept {
      return ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse>::Equal(this, &other);
    }
    bool operator!=(const MainProtocolOnAnonWithErrorResponse& other) const noexcept {
      return !::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse>::Equal(this, &other);
    }

  bool IsEmpty() const {
      return !(storage_.a.has_value()
      );
  }
    
    const std::optional<uint16_t>& a() const { return storage_.a; }
    ::std::optional<uint16_t>& a() { return storage_.a; }

    // Setter for a.
    //
    
    MainProtocolOnAnonWithErrorResponse& a(std::optional<uint16_t> value);

  MainProtocolOnAnonWithErrorResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::std::optional<uint16_t> a;
  };

  // TODO(https://fxbug.dev/91252): Box the storage.
  Storage_ storage_;
    Storage_ CloneStorage_() const;
  friend struct ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalTableMember<Storage_, uint16_t, fidl::internal::NaturalCodingConstraintEmpty>{
        1, &Storage_::a
      });
};

  
  
  
  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocol_OnAnonWithError_ResultTable;


class MainProtocolOnAnonWithErrorResult {
 private:
  using Storage_ =
    std::variant<
      std::monostate
        , ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse
        , uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  MainProtocolOnAnonWithErrorResult(MainProtocolOnAnonWithErrorResult&& other) noexcept
      : MainProtocolOnAnonWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  MainProtocolOnAnonWithErrorResult& operator=(MainProtocolOnAnonWithErrorResult&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
    MainProtocolOnAnonWithErrorResult(const MainProtocolOnAnonWithErrorResult& other) noexcept : MainProtocolOnAnonWithErrorResult(other.CloneStorage_()){}
    MainProtocolOnAnonWithErrorResult& operator=(const MainProtocolOnAnonWithErrorResult& other) noexcept {
      if (this != &other) {
        storage_ = other.CloneStorage_();
      }
      return *this;
    }

    bool operator==(const MainProtocolOnAnonWithErrorResult& other) const noexcept {
      return *storage_ == *other.storage_;
    }
    bool operator!=(const MainProtocolOnAnonWithErrorResult& other) const noexcept {
      return *storage_ != *other.storage_;
    }

  constexpr ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult::Tag Which() const {
    return MainProtocolOnAnonWithErrorResult::IndexToTag(storage_->index()).value();
  }
    static MainProtocolOnAnonWithErrorResult WithResponse(::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse val) {
      return MainProtocolOnAnonWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<1, Storage_> response() {
      return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
    }

    // Sets the union to hold the response member.
    //
    
    MainProtocolOnAnonWithErrorResult& response(::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse value) {
      storage_->emplace<1>(std::move(value));
      return *this;
    }
    static MainProtocolOnAnonWithErrorResult WithErr(uint32_t val) {
      return MainProtocolOnAnonWithErrorResult(std::make_shared<Storage_>(
        std::in_place_index_t<2>{},
        std::move(val)));
    }

    const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    ::fidl::internal::UnionMemberView<2, Storage_> err() {
      return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
    }

    // Sets the union to hold the err member.
    //
    
    MainProtocolOnAnonWithErrorResult& err(uint32_t value) {
      storage_->emplace<2>(std::move(value));
      return *this;
    }

  MainProtocolOnAnonWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
    std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult>;
  static constexpr auto kMembers = std::make_tuple(
    ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>()
      , ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit MainProtocolOnAnonWithErrorResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult::Tag tag) {
    switch (tag) {
        case ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult::Tag::kResponse: return 1;
        case ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult::Tag::kErr: return 2;
      default: {
          decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult::Tag> IndexToTag(size_t index) {
    switch (index) {
        case 1: return ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult::Tag::kResponse;
        case 2: return ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult::Tag::kErr;
        default: return std::nullopt;
    }
  }

};


  



extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolOnAnonWithErrorRequestTable;


class MainProtocolOnAnonWithErrorRequest {
 private:
  struct Storage_;
 public:
  MainProtocolOnAnonWithErrorRequest(Storage_ storage) noexcept;
    MainProtocolOnAnonWithErrorRequest(::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult result) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |MainProtocolOnAnonWithErrorRequest| only if all of its members are default constructible.
  MainProtocolOnAnonWithErrorRequest() = default;
#pragma clang diagnostic pop

  MainProtocolOnAnonWithErrorRequest(MainProtocolOnAnonWithErrorRequest&&) noexcept = default;
  MainProtocolOnAnonWithErrorRequest& operator=(MainProtocolOnAnonWithErrorRequest&&) noexcept = default;
    MainProtocolOnAnonWithErrorRequest(const MainProtocolOnAnonWithErrorRequest& other) noexcept;
    MainProtocolOnAnonWithErrorRequest& operator=(const MainProtocolOnAnonWithErrorRequest& other) noexcept;

    bool operator==(const MainProtocolOnAnonWithErrorRequest& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorRequest, 16>::Equal(this, &other);
    }
    bool operator!=(const MainProtocolOnAnonWithErrorRequest& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorRequest, 16>::Equal(this, &other);
    }
    
      const ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult &
    result() const {
      return storage_.result;
    }

    
    ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult& result() {
      return storage_.result;
    }

    // Setter for result.
    //
    
    MainProtocolOnAnonWithErrorRequest& result(::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult value);

  MainProtocolOnAnonWithErrorRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
      ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult result;
  };

  Storage_ storage_;
    Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorRequest, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult, fidl::internal::NaturalCodingConstraintEmpty>{
        &Storage_::result, 0
      });
  static constexpr auto kPadding = std::make_tuple();

};


  
  
  
  
  


  
  
  

  

  inline TablePayload::TablePayload(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline TablePayload::TablePayload(const ::test_protocollayoutssamelibrary::TablePayload& other) noexcept : TablePayload(other.CloneStorage_()){}
    inline TablePayload& ::test_protocollayoutssamelibrary::TablePayload::operator=(const TablePayload& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline TablePayload::TablePayload(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : TablePayload(Storage_{}) {}
    inline TablePayload& TablePayload::a(std::optional<uint16_t> value) {
      storage_.a = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  

  inline ComposedProtocolOneWayAnonComposedRequest::ComposedProtocolOneWayAnonComposedRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ComposedProtocolOneWayAnonComposedRequest::ComposedProtocolOneWayAnonComposedRequest(const ::test_protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest& other) noexcept : ComposedProtocolOneWayAnonComposedRequest(other.CloneStorage_()){}
    inline ComposedProtocolOneWayAnonComposedRequest& ::test_protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest::operator=(const ComposedProtocolOneWayAnonComposedRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ComposedProtocolOneWayAnonComposedRequest::ComposedProtocolOneWayAnonComposedRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ComposedProtocolOneWayAnonComposedRequest(Storage_{}) {}
    inline ComposedProtocolOneWayAnonComposedRequest& ComposedProtocolOneWayAnonComposedRequest::a(std::optional<uint16_t> value) {
      storage_.a = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  

  inline ComposedProtocolTwoWayAnonComposedResponse::ComposedProtocolTwoWayAnonComposedResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ComposedProtocolTwoWayAnonComposedResponse::ComposedProtocolTwoWayAnonComposedResponse(const ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedResponse& other) noexcept : ComposedProtocolTwoWayAnonComposedResponse(other.CloneStorage_()){}
    inline ComposedProtocolTwoWayAnonComposedResponse& ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedResponse::operator=(const ComposedProtocolTwoWayAnonComposedResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ComposedProtocolTwoWayAnonComposedResponse::ComposedProtocolTwoWayAnonComposedResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ComposedProtocolTwoWayAnonComposedResponse(Storage_{}) {}
    inline ComposedProtocolTwoWayAnonComposedResponse& ComposedProtocolTwoWayAnonComposedResponse::a(std::optional<uint16_t> value) {
      storage_.a = std::move(value);
      return *this;
    }

  
  
  
  

  

  inline ComposedProtocolTwoWayAnonComposedWithErrorRequest::ComposedProtocolTwoWayAnonComposedWithErrorRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ComposedProtocolTwoWayAnonComposedWithErrorRequest::ComposedProtocolTwoWayAnonComposedWithErrorRequest(const ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest& other) noexcept : ComposedProtocolTwoWayAnonComposedWithErrorRequest(other.CloneStorage_()){}
    inline ComposedProtocolTwoWayAnonComposedWithErrorRequest& ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest::operator=(const ComposedProtocolTwoWayAnonComposedWithErrorRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ComposedProtocolTwoWayAnonComposedWithErrorRequest::ComposedProtocolTwoWayAnonComposedWithErrorRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ComposedProtocolTwoWayAnonComposedWithErrorRequest(Storage_{}) {}
    inline ComposedProtocolTwoWayAnonComposedWithErrorRequest& ComposedProtocolTwoWayAnonComposedWithErrorRequest::a(std::optional<uint16_t> value) {
      storage_.a = std::move(value);
      return *this;
    }

  
  
  
  
  
  
  

  

  inline ComposedProtocolTwoWayAnonComposedWithErrorTopResponse::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ComposedProtocolTwoWayAnonComposedWithErrorTopResponse::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse(::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline ComposedProtocolTwoWayAnonComposedWithErrorTopResponse::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse(const ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse& other) noexcept : ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse(other.CloneStorage_()){}
    inline ComposedProtocolTwoWayAnonComposedWithErrorTopResponse& ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse::operator=(const ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ComposedProtocolTwoWayAnonComposedWithErrorTopResponse::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ComposedProtocolTwoWayAnonComposedWithErrorTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline ComposedProtocolTwoWayAnonComposedWithErrorTopResponse& ComposedProtocolTwoWayAnonComposedWithErrorTopResponse::result(::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  
  

  

  inline ComposedProtocolOnAnonComposedWithErrorResponse::ComposedProtocolOnAnonComposedWithErrorResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ComposedProtocolOnAnonComposedWithErrorResponse::ComposedProtocolOnAnonComposedWithErrorResponse(const ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse& other) noexcept : ComposedProtocolOnAnonComposedWithErrorResponse(other.CloneStorage_()){}
    inline ComposedProtocolOnAnonComposedWithErrorResponse& ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse::operator=(const ComposedProtocolOnAnonComposedWithErrorResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ComposedProtocolOnAnonComposedWithErrorResponse::ComposedProtocolOnAnonComposedWithErrorResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ComposedProtocolOnAnonComposedWithErrorResponse(Storage_{}) {}
    inline ComposedProtocolOnAnonComposedWithErrorResponse& ComposedProtocolOnAnonComposedWithErrorResponse::a(std::optional<uint16_t> value) {
      storage_.a = std::move(value);
      return *this;
    }

  
  
  
  
  

  

  inline ComposedProtocolOnAnonComposedWithErrorRequest::ComposedProtocolOnAnonComposedWithErrorRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ComposedProtocolOnAnonComposedWithErrorRequest::ComposedProtocolOnAnonComposedWithErrorRequest(::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline ComposedProtocolOnAnonComposedWithErrorRequest::ComposedProtocolOnAnonComposedWithErrorRequest(const ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorRequest& other) noexcept : ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorRequest(other.CloneStorage_()){}
    inline ComposedProtocolOnAnonComposedWithErrorRequest& ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorRequest::operator=(const ::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ComposedProtocolOnAnonComposedWithErrorRequest::ComposedProtocolOnAnonComposedWithErrorRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ComposedProtocolOnAnonComposedWithErrorRequest(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline ComposedProtocolOnAnonComposedWithErrorRequest& ComposedProtocolOnAnonComposedWithErrorRequest::result(::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  

  inline ComposedProtocolTwoWayNamedComposedWithErrorTopResponse::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ComposedProtocolTwoWayNamedComposedWithErrorTopResponse::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse(::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline ComposedProtocolTwoWayNamedComposedWithErrorTopResponse::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse(const ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse& other) noexcept : ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse(other.CloneStorage_()){}
    inline ComposedProtocolTwoWayNamedComposedWithErrorTopResponse& ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse::operator=(const ::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ComposedProtocolTwoWayNamedComposedWithErrorTopResponse::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ComposedProtocolTwoWayNamedComposedWithErrorTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline ComposedProtocolTwoWayNamedComposedWithErrorTopResponse& ComposedProtocolTwoWayNamedComposedWithErrorTopResponse::result(::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  

  inline ComposedProtocolOnNamedComposedWithErrorRequest::ComposedProtocolOnNamedComposedWithErrorRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline ComposedProtocolOnNamedComposedWithErrorRequest::ComposedProtocolOnNamedComposedWithErrorRequest(::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline ComposedProtocolOnNamedComposedWithErrorRequest::ComposedProtocolOnNamedComposedWithErrorRequest(const ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorRequest& other) noexcept : ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorRequest(other.CloneStorage_()){}
    inline ComposedProtocolOnNamedComposedWithErrorRequest& ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorRequest::operator=(const ::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline ComposedProtocolOnNamedComposedWithErrorRequest::ComposedProtocolOnNamedComposedWithErrorRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ComposedProtocolOnNamedComposedWithErrorRequest(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline ComposedProtocolOnNamedComposedWithErrorRequest& ComposedProtocolOnNamedComposedWithErrorRequest::result(::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  
  
  

  

  inline MainProtocolTwoWayLocalWithErrorTopResponse::MainProtocolTwoWayLocalWithErrorTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline MainProtocolTwoWayLocalWithErrorTopResponse::MainProtocolTwoWayLocalWithErrorTopResponse(::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline MainProtocolTwoWayLocalWithErrorTopResponse::MainProtocolTwoWayLocalWithErrorTopResponse(const ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorTopResponse& other) noexcept : ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorTopResponse(other.CloneStorage_()){}
    inline MainProtocolTwoWayLocalWithErrorTopResponse& ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorTopResponse::operator=(const ::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline MainProtocolTwoWayLocalWithErrorTopResponse::MainProtocolTwoWayLocalWithErrorTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolTwoWayLocalWithErrorTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline MainProtocolTwoWayLocalWithErrorTopResponse& MainProtocolTwoWayLocalWithErrorTopResponse::result(::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  

  inline MainProtocolOnLocalWithErrorRequest::MainProtocolOnLocalWithErrorRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline MainProtocolOnLocalWithErrorRequest::MainProtocolOnLocalWithErrorRequest(::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline MainProtocolOnLocalWithErrorRequest::MainProtocolOnLocalWithErrorRequest(const ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorRequest& other) noexcept : ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorRequest(other.CloneStorage_()){}
    inline MainProtocolOnLocalWithErrorRequest& ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorRequest::operator=(const ::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline MainProtocolOnLocalWithErrorRequest::MainProtocolOnLocalWithErrorRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolOnLocalWithErrorRequest(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline MainProtocolOnLocalWithErrorRequest& MainProtocolOnLocalWithErrorRequest::result(::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  

  

  inline MainProtocolOneWayAnonRequest::MainProtocolOneWayAnonRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline MainProtocolOneWayAnonRequest::MainProtocolOneWayAnonRequest(const ::test_protocollayoutssamelibrary::MainProtocolOneWayAnonRequest& other) noexcept : MainProtocolOneWayAnonRequest(other.CloneStorage_()){}
    inline MainProtocolOneWayAnonRequest& ::test_protocollayoutssamelibrary::MainProtocolOneWayAnonRequest::operator=(const MainProtocolOneWayAnonRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline MainProtocolOneWayAnonRequest::MainProtocolOneWayAnonRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolOneWayAnonRequest(Storage_{}) {}
    inline MainProtocolOneWayAnonRequest& MainProtocolOneWayAnonRequest::a(std::optional<uint16_t> value) {
      storage_.a = std::move(value);
      return *this;
    }

  
  
  
  
  
  

  

  inline MainProtocolTwoWayAnonResponse::MainProtocolTwoWayAnonResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline MainProtocolTwoWayAnonResponse::MainProtocolTwoWayAnonResponse(const ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonResponse& other) noexcept : MainProtocolTwoWayAnonResponse(other.CloneStorage_()){}
    inline MainProtocolTwoWayAnonResponse& ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonResponse::operator=(const MainProtocolTwoWayAnonResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline MainProtocolTwoWayAnonResponse::MainProtocolTwoWayAnonResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolTwoWayAnonResponse(Storage_{}) {}
    inline MainProtocolTwoWayAnonResponse& MainProtocolTwoWayAnonResponse::a(std::optional<uint16_t> value) {
      storage_.a = std::move(value);
      return *this;
    }

  
  
  
  

  

  inline MainProtocolTwoWayAnonWithErrorRequest::MainProtocolTwoWayAnonWithErrorRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline MainProtocolTwoWayAnonWithErrorRequest::MainProtocolTwoWayAnonWithErrorRequest(const ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest& other) noexcept : MainProtocolTwoWayAnonWithErrorRequest(other.CloneStorage_()){}
    inline MainProtocolTwoWayAnonWithErrorRequest& ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest::operator=(const MainProtocolTwoWayAnonWithErrorRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline MainProtocolTwoWayAnonWithErrorRequest::MainProtocolTwoWayAnonWithErrorRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolTwoWayAnonWithErrorRequest(Storage_{}) {}
    inline MainProtocolTwoWayAnonWithErrorRequest& MainProtocolTwoWayAnonWithErrorRequest::a(std::optional<uint16_t> value) {
      storage_.a = std::move(value);
      return *this;
    }

  
  
  
  
  
  
  

  

  inline MainProtocolTwoWayAnonWithErrorTopResponse::MainProtocolTwoWayAnonWithErrorTopResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline MainProtocolTwoWayAnonWithErrorTopResponse::MainProtocolTwoWayAnonWithErrorTopResponse(::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline MainProtocolTwoWayAnonWithErrorTopResponse::MainProtocolTwoWayAnonWithErrorTopResponse(const ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorTopResponse& other) noexcept : ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorTopResponse(other.CloneStorage_()){}
    inline MainProtocolTwoWayAnonWithErrorTopResponse& ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorTopResponse::operator=(const ::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorTopResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline MainProtocolTwoWayAnonWithErrorTopResponse::MainProtocolTwoWayAnonWithErrorTopResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolTwoWayAnonWithErrorTopResponse(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline MainProtocolTwoWayAnonWithErrorTopResponse& MainProtocolTwoWayAnonWithErrorTopResponse::result(::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  
  
  
  

  

  inline MainProtocolOnAnonWithErrorResponse::MainProtocolOnAnonWithErrorResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline MainProtocolOnAnonWithErrorResponse::MainProtocolOnAnonWithErrorResponse(const ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse& other) noexcept : MainProtocolOnAnonWithErrorResponse(other.CloneStorage_()){}
    inline MainProtocolOnAnonWithErrorResponse& ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse::operator=(const MainProtocolOnAnonWithErrorResponse& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline MainProtocolOnAnonWithErrorResponse::MainProtocolOnAnonWithErrorResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolOnAnonWithErrorResponse(Storage_{}) {}
    inline MainProtocolOnAnonWithErrorResponse& MainProtocolOnAnonWithErrorResponse::a(std::optional<uint16_t> value) {
      storage_.a = std::move(value);
      return *this;
    }

  
  
  
  
  

  

  inline MainProtocolOnAnonWithErrorRequest::MainProtocolOnAnonWithErrorRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    inline MainProtocolOnAnonWithErrorRequest::MainProtocolOnAnonWithErrorRequest(::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult result) noexcept
    : storage_({
      .result = std::move(result)
    }) {}
    inline MainProtocolOnAnonWithErrorRequest::MainProtocolOnAnonWithErrorRequest(const ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorRequest& other) noexcept : ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorRequest(other.CloneStorage_()){}
    inline MainProtocolOnAnonWithErrorRequest& ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorRequest::operator=(const ::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorRequest& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

  inline MainProtocolOnAnonWithErrorRequest::MainProtocolOnAnonWithErrorRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolOnAnonWithErrorRequest(Storage_{
      .result =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
  }) {}
    inline MainProtocolOnAnonWithErrorRequest& MainProtocolOnAnonWithErrorRequest::result(::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult value) {
      storage_.result = std::move(value);
      return *this;
    }

  
  
  
  

}  // namespace test_protocollayoutssamelibrary
namespace fidl {


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolTwoWayAnonComposedWithErrorTopResponseTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 16;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorTopResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolOnAnonComposedWithErrorRequestTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 24;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorRequest, 16> {};

  
  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolTwoWayNamedComposedWithErrorTopResponseTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 16;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorTopResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolOnNamedComposedWithErrorRequestTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 24;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorRequest, 16> {};

  
  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolTwoWayLocalWithErrorTopResponseTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 16;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorTopResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolOnLocalWithErrorRequestTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 24;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorRequest, 16> {};

  
  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolTwoWayAnonWithErrorTopResponseTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorTopResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorTopResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 16;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorTopResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorTopResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorTopResponse, 16> {};

  
  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolOnAnonWithErrorRequestTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 24;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsStruct<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorRequest, 16> {};

  

  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_TablePayloadTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::TablePayload> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::TablePayload> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 8;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsTable<::test_protocollayoutssamelibrary::TablePayload> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::TablePayload, ::fidl::internal::NaturalCodingConstraintEmpty> :
    public ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::TablePayload> {};

  

  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolOneWayAnonComposedRequestTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 8;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsTable<::test_protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest, ::fidl::internal::NaturalCodingConstraintEmpty> :
    public ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOneWayAnonComposedRequest> {};

  

  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolTwoWayAnonComposedResponseTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 8;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsTable<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::internal::NaturalCodingConstraintEmpty> :
    public ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedResponse> {};

  

  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolTwoWayAnonComposedWithErrorRequestTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 8;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsTable<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::internal::NaturalCodingConstraintEmpty> :
    public ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorRequest> {};

  

  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocol_OnAnonComposedWithError_ResponseTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 8;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsTable<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse, ::fidl::internal::NaturalCodingConstraintEmpty> :
    public ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResponse> {};

  

  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolOneWayAnonRequestTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolOneWayAnonRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolOneWayAnonRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 8;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsTable<::test_protocollayoutssamelibrary::MainProtocolOneWayAnonRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOneWayAnonRequest, ::fidl::internal::NaturalCodingConstraintEmpty> :
    public ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOneWayAnonRequest> {};

  

  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolTwoWayAnonResponseTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 8;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsTable<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonResponse, ::fidl::internal::NaturalCodingConstraintEmpty> :
    public ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonResponse> {};

  

  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolTwoWayAnonWithErrorRequestTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 8;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsTable<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::internal::NaturalCodingConstraintEmpty> :
    public ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorRequest> {};

  

  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocol_OnAnonWithError_ResponseTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 8;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsTable<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse, ::fidl::internal::NaturalCodingConstraintEmpty> :
    public ::fidl::internal::NaturalTableCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResponse> {};

  


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_UnionPayloadTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::UnionPayload> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::UnionPayload> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::UnionPayload> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::UnionPayload, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::UnionPayload> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolTwoWayAnonComposedRequestTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedRequest> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocol_TwoWayAnonComposedWithError_ResponseTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResponse> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocol_TwoWayAnonComposedWithError_ResultTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 16;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayAnonComposedWithErrorResult> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocolOnAnonComposedRequestTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedRequest> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocol_OnAnonComposedWithError_ResultTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 24;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnAnonComposedWithErrorResult> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocol_TwoWayNamedComposedWithError_ResultTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 16;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolTwoWayNamedComposedWithErrorResult> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_ComposedProtocol_OnNamedComposedWithError_ResultTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 24;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::ComposedProtocolOnNamedComposedWithErrorResult> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocol_TwoWayLocalWithError_ResultTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 16;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayLocalWithErrorResult> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocol_OnLocalWithError_ResultTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 24;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnLocalWithErrorResult> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolTwoWayAnonRequestTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonRequest> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocol_TwoWayAnonWithError_ResponseTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResponse> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocol_TwoWayAnonWithError_ResultTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 2;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 16;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolTwoWayAnonWithErrorResult> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocolOnAnonRequestTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolOnAnonRequest> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonRequest> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 1;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 0;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::MainProtocolOnAnonRequest> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonRequest> {};


  

  extern "C" const fidl_type_t test_protocollayoutssamelibrary_MainProtocol_OnAnonWithError_ResultTable;

  
  template <>
  struct IsFidlType<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult> : public std::true_type {};

  template<>
  struct TypeTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult> {
    static constexpr uint32_t kMaxNumHandles = 0;
    static constexpr uint32_t kMaxDepth = 3;
    static constexpr uint32_t kPrimarySize = 16;
    static constexpr uint32_t kMaxOutOfLine = 24;
    static constexpr bool kHasEnvelope = true;
    static constexpr bool kHasPointer = true;
  };

  template <>
  struct IsUnion<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult> : public std::true_type {};

  template <>
  struct internal::NaturalCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_protocollayoutssamelibrary::MainProtocolOnAnonWithErrorResult> {};





#pragma clang diagnostic pop

}  // namespace fidl

