// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include <fidl/test.arrays/cpp/natural_types.h>
#include <lib/fidl/cpp/hlcpp_conversion.h>
#include <lib/fidl/cpp/wire/internal/transport_channel.h>
#include <lib/fidl/cpp/wire/service_handler.h>
#include <test/arrays/cpp/fidl.h>

namespace fidl {
namespace internal {

template <>
struct NaturalToHLCPPTraits<::test_arrays::StructSmallArray> {
  using HLCPPType = ::test::arrays::StructSmallArray;
  static inline ::test::arrays::StructSmallArray Convert(::test_arrays::StructSmallArray&&);
};
template <>
struct HLCPPToNaturalTraits<::test::arrays::StructSmallArray> {
  using NaturalType = ::test_arrays::StructSmallArray;
  static inline ::test_arrays::StructSmallArray Convert(::test::arrays::StructSmallArray&&);
};
template <>
struct NaturalToHLCPPTraits<::test_arrays::StructLargeArray> {
  using HLCPPType = ::test::arrays::StructLargeArray;
  static inline ::test::arrays::StructLargeArray Convert(::test_arrays::StructLargeArray&&);
};
template <>
struct HLCPPToNaturalTraits<::test::arrays::StructLargeArray> {
  using NaturalType = ::test_arrays::StructLargeArray;
  static inline ::test_arrays::StructLargeArray Convert(::test::arrays::StructLargeArray&&);
};
template <>
struct NaturalToHLCPPTraits<::test_arrays::TableSmallArray> {
  using HLCPPType = ::test::arrays::TableSmallArray;
  static inline ::test::arrays::TableSmallArray Convert(::test_arrays::TableSmallArray&&);
};
template <>
struct HLCPPToNaturalTraits<::test::arrays::TableSmallArray> {
  using NaturalType = ::test_arrays::TableSmallArray;
  static inline ::test_arrays::TableSmallArray Convert(::test::arrays::TableSmallArray&&);
};
template <>
struct NaturalToHLCPPTraits<::test_arrays::TableLargeArray> {
  using HLCPPType = ::test::arrays::TableLargeArray;
  static inline ::test::arrays::TableLargeArray Convert(::test_arrays::TableLargeArray&&);
};
template <>
struct HLCPPToNaturalTraits<::test::arrays::TableLargeArray> {
  using NaturalType = ::test_arrays::TableLargeArray;
  static inline ::test_arrays::TableLargeArray Convert(::test::arrays::TableLargeArray&&);
};
template <>
struct NaturalToHLCPPTraits<::test_arrays::UnionSmallArray> {
  using HLCPPType = ::test::arrays::UnionSmallArray;
  static inline ::test::arrays::UnionSmallArray Convert(::test_arrays::UnionSmallArray&&);
};
template <>
struct HLCPPToNaturalTraits<::test::arrays::UnionSmallArray> {
  using NaturalType = ::test_arrays::UnionSmallArray;
  static inline ::test_arrays::UnionSmallArray Convert(::test::arrays::UnionSmallArray&&);
};
template <>
struct NaturalToHLCPPTraits<::test_arrays::UnionLargeArray> {
  using HLCPPType = ::test::arrays::UnionLargeArray;
  static inline ::test::arrays::UnionLargeArray Convert(::test_arrays::UnionLargeArray&&);
};
template <>
struct HLCPPToNaturalTraits<::test::arrays::UnionLargeArray> {
  using NaturalType = ::test_arrays::UnionLargeArray;
  static inline ::test_arrays::UnionLargeArray Convert(::test::arrays::UnionLargeArray&&);
};

::test::arrays::StructSmallArray NaturalToHLCPPTraits<::test_arrays::StructSmallArray>::Convert(::test_arrays::StructSmallArray&& value) {
  ::test::arrays::StructSmallArray hlcpp;
  hlcpp.a = ::fidl::NaturalToHLCPP(std::move(value.a()));
  return hlcpp;
}

::test_arrays::StructSmallArray HLCPPToNaturalTraits<::test::arrays::StructSmallArray>::Convert(::test::arrays::StructSmallArray&& value) {
  return ::test_arrays::StructSmallArray{{
      .a = ::fidl::HLCPPToNatural(std::move(value.a)),
  }};
}
::test::arrays::StructLargeArray NaturalToHLCPPTraits<::test_arrays::StructLargeArray>::Convert(::test_arrays::StructLargeArray&& value) {
  ::test::arrays::StructLargeArray hlcpp;
  hlcpp.a = ::fidl::NaturalToHLCPP(std::move(value.a()));
  return hlcpp;
}

::test_arrays::StructLargeArray HLCPPToNaturalTraits<::test::arrays::StructLargeArray>::Convert(::test::arrays::StructLargeArray&& value) {
  return ::test_arrays::StructLargeArray{{
      .a = ::fidl::HLCPPToNatural(std::move(value.a)),
  }};
}
::test::arrays::TableSmallArray NaturalToHLCPPTraits<::test_arrays::TableSmallArray>::Convert(::test_arrays::TableSmallArray&& value) {
  ::test::arrays::TableSmallArray hlcpp;
  if (value.a().has_value()) {
    hlcpp.set_a(::fidl::NaturalToHLCPP(std::move(value.a().value())));
  }
  return hlcpp;
}

::test_arrays::TableSmallArray HLCPPToNaturalTraits<::test::arrays::TableSmallArray>::Convert(::test::arrays::TableSmallArray&& value) {
  ::test_arrays::TableSmallArray natural;
  if (value.has_a()) {
    natural.a() = ::fidl::HLCPPToNatural(std::move(*value.mutable_a()));
  }
  return natural;
}
::test::arrays::TableLargeArray NaturalToHLCPPTraits<::test_arrays::TableLargeArray>::Convert(::test_arrays::TableLargeArray&& value) {
  ::test::arrays::TableLargeArray hlcpp;
  if (value.a().has_value()) {
    hlcpp.set_a(::fidl::NaturalToHLCPP(std::move(value.a().value())));
  }
  return hlcpp;
}

::test_arrays::TableLargeArray HLCPPToNaturalTraits<::test::arrays::TableLargeArray>::Convert(::test::arrays::TableLargeArray&& value) {
  ::test_arrays::TableLargeArray natural;
  if (value.has_a()) {
    natural.a() = ::fidl::HLCPPToNatural(std::move(*value.mutable_a()));
  }
  return natural;
}

::test::arrays::UnionSmallArray NaturalToHLCPPTraits<::test_arrays::UnionSmallArray>::Convert(::test_arrays::UnionSmallArray&& value) {
  ::test::arrays::UnionSmallArray hlcpp;
  switch (value.Which()) {
    case ::test_arrays::UnionSmallArray::Tag::kA:
      hlcpp.set_a(::fidl::NaturalToHLCPP(std::move(value.a().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_arrays::UnionSmallArray HLCPPToNaturalTraits<::test::arrays::UnionSmallArray>::Convert(::test::arrays::UnionSmallArray&& value) {
  using _NaturalUnion = ::test_arrays::UnionSmallArray;
  switch (value.Which()) {
    case ::test::arrays::UnionSmallArray::Tag::kA:
      return _NaturalUnion::WithA(
          ::fidl::HLCPPToNatural(std::move(value.a())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::arrays::UnionSmallArray");
  }
}
::test::arrays::UnionLargeArray NaturalToHLCPPTraits<::test_arrays::UnionLargeArray>::Convert(::test_arrays::UnionLargeArray&& value) {
  ::test::arrays::UnionLargeArray hlcpp;
  switch (value.Which()) {
    case ::test_arrays::UnionLargeArray::Tag::kA:
      hlcpp.set_a(::fidl::NaturalToHLCPP(std::move(value.a().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_arrays::UnionLargeArray HLCPPToNaturalTraits<::test::arrays::UnionLargeArray>::Convert(::test::arrays::UnionLargeArray&& value) {
  using _NaturalUnion = ::test_arrays::UnionLargeArray;
  switch (value.Which()) {
    case ::test::arrays::UnionLargeArray::Tag::kA:
      return _NaturalUnion::WithA(
          ::fidl::HLCPPToNatural(std::move(value.a())));
    default:
      ZX_PANIC("Can't convert invalid strict union %s from HLCPP to Natural", "::test::arrays::UnionLargeArray");
  }
}

}  // namespace internal
}  // namespace fidl
