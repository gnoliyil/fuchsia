// WARNING: This file is machine generated by fidlgen.
  
  // fidl_experiment = no_optional_structs
  // fidl_experiment = output_index_json
  // fidl_experiment = simple_empty_response_syntax
  // fidl_experiment = unknown_interactions

  #pragma once

  #include <fidl/test.typesinprotocols/cpp/markers.h>
  #include <fidl/test.typesinprotocols/cpp/wire_types.h>

  #include <lib/fidl/cpp/wire/wire_messaging.h>

  
#ifdef __Fuchsia__

    #include <lib/fidl/cpp/wire/client.h>
    #include <lib/fidl/cpp/wire/connect_service.h>
    #include <lib/fidl/cpp/wire/server.h>
    #include <lib/fidl/cpp/wire/service_handler.h>
    #include <lib/fidl/cpp/wire/sync_call.h>
    #include <lib/fidl/cpp/wire/unknown_interaction_handler.h>
  

#endif  // __Fuchsia__


  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wshadow"
    
  namespace test_typesinprotocols {

  class Protocol;
    

    
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_BasicTable;
    
    
    
    
    
    
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_CompoundTable;
    
    
    
    
    
    
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ArrayBasicTable;
    
    
    
    
    
    
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ArrayCompoundTable;
    
    
    
    
    
    
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_VectorBasicTable;
    
    
    
    
    
    
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_VectorCompoundTable;
    
    
    
    
    
    
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_VectorOptionalTable;
    
    
    
    
    
    
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ArrayVectorNestedTable;
    
    
    
    
    
}  // namespace test_typesinprotocols

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::OneWayBasic> final { static constexpr uint64_t value = 8948968077914418681lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::TwoWayBasic> final { static constexpr uint64_t value = 2331618702752598159lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::EventBasic> final { static constexpr uint64_t value = 5892309624949902400lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::OneWayCompound> final { static constexpr uint64_t value = 3153289648860022476lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::TwoWayCompound> final { static constexpr uint64_t value = 8787219719097524529lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::EventCompound> final { static constexpr uint64_t value = 7024581948727571669lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::OneWayArrayBasic> final { static constexpr uint64_t value = 7125516817014311449lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::TwoWayArrayBasic> final { static constexpr uint64_t value = 5309034178175279380lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::EventArrayBasic> final { static constexpr uint64_t value = 5888282827283820590lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::OneWayArrayCompound> final { static constexpr uint64_t value = 5064659223443251357lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::TwoWayArrayCompound> final { static constexpr uint64_t value = 849744466051983995lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::EventArrayCompound> final { static constexpr uint64_t value = 2189769767733851157lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::OneWayVectorBasic> final { static constexpr uint64_t value = 5733220720079947351lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::TwoWayVectorBasic> final { static constexpr uint64_t value = 8674156353091415668lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::EventVectorBasic> final { static constexpr uint64_t value = 4583890770109526006lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::OneWayVectorCompound> final { static constexpr uint64_t value = 1853985797298830992lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::TwoWayVectorCompound> final { static constexpr uint64_t value = 3968024057912959924lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::EventVectorCompound> final { static constexpr uint64_t value = 6026375226599919603lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::OneWayVectorOptional> final { static constexpr uint64_t value = 1530215841195476271lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::TwoWayVectorOptional> final { static constexpr uint64_t value = 1030024737742222323lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::EventVectorOptional> final { static constexpr uint64_t value = 1684763340073130077lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> final { static constexpr uint64_t value = 5912603762133524183lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> final { static constexpr uint64_t value = 5351275678438791132lu; };

template<>
struct ::fidl::internal::WireOrdinal<::test_typesinprotocols::Protocol::EventArrayVectorNested> final { static constexpr uint64_t value = 1228201560727880574lu; };

#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayBasic> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Basic;
    
      using Completer = fidl::Completer<>;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayBasic> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Basic;
      using Response = ::test_typesinprotocols::wire::Basic;
    
      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayBasic>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayBasic,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayBasic,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventBasic> {
    
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Basic;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayCompound> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Compound;
    
      using Completer = fidl::Completer<>;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayCompound> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Compound;
      using Response = ::test_typesinprotocols::wire::Compound;
    
      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayCompound>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayCompound,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayCompound,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventCompound> {
    
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Compound;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayArrayBasic> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayBasic;
    
      using Completer = fidl::Completer<>;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayArrayBasic> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayBasic;
      using Response = ::test_typesinprotocols::wire::ArrayBasic;
    
      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayArrayBasic,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayArrayBasic,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventArrayBasic> {
    
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayBasic;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayArrayCompound> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayCompound;
    
      using Completer = fidl::Completer<>;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayArrayCompound> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayCompound;
      using Response = ::test_typesinprotocols::wire::ArrayCompound;
    
      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayArrayCompound,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayArrayCompound,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventArrayCompound> {
    
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayCompound;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayVectorBasic> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorBasic;
    
      using Completer = fidl::Completer<>;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayVectorBasic> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorBasic;
      using Response = ::test_typesinprotocols::wire::VectorBasic;
    
      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayVectorBasic,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayVectorBasic,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventVectorBasic> {
    
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorBasic;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayVectorCompound> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorCompound;
    
      using Completer = fidl::Completer<>;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayVectorCompound> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorCompound;
      using Response = ::test_typesinprotocols::wire::VectorCompound;
    
      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayVectorCompound,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayVectorCompound,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventVectorCompound> {
    
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorCompound;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayVectorOptional> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorOptional;
    
      using Completer = fidl::Completer<>;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayVectorOptional> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorOptional;
      using Response = ::test_typesinprotocols::wire::VectorOptional;
    
      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayVectorOptional,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayVectorOptional,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventVectorOptional> {
    
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorOptional;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayVectorNested;
    
      using Completer = fidl::Completer<>;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayVectorNested;
      using Response = ::test_typesinprotocols::wire::ArrayVectorNested;
    
      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayArrayVectorNested,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayArrayVectorNested,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::ChannelTransport
      >
  >;
};



#endif  // __Fuchsia__


#ifdef __Fuchsia__




template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventArrayVectorNested> {
    
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayVectorNested;
};



#endif  // __Fuchsia__


namespace test_typesinprotocols {

}  // namespace test_typesinprotocols

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_typesinprotocols::Protocol> {
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::internal::WireServerDispatcher<::test_typesinprotocols::Protocol> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_typesinprotocols::Protocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_typesinprotocols::Protocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::Basic body;
  explicit TransactionalRequest(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string)
  : body(::test_typesinprotocols::wire::Basic { uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 80 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::Basic, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::Basic, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::Basic body;
  explicit TransactionalRequest(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string)
  : body(::test_typesinprotocols::wire::Basic { uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 80 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::Basic, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::Basic, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic> final : public ::test_typesinprotocols::wire::Basic {

  
  explicit WireResponse(::test_typesinprotocols::wire::Basic base) : ::test_typesinprotocols::wire::Basic(std::move(base)) {}
  explicit WireResponse(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) : ::test_typesinprotocols::wire::Basic{ .uint8 = std::move(uint8), .uint16 = std::move(uint16), .uint32 = std::move(uint32), .uint64 = std::move(uint64), .int8 = std::move(int8), .int16 = std::move(int16), .int32 = std::move(int32), .int64 = std::move(int64), .float32 = std::move(float32), .float64 = std::move(float64), .string = std::move(string), .opt_string = std::move(opt_string)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 80;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic> body;
  explicit TransactionalResponse(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string)
  : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>(uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 80 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  
    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventBasic> body;

    explicit TransactionalEvent(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string)
    : body{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string } {
      _InitHeader();
    }

  TransactionalEvent() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 80 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::Compound body;
  explicit TransactionalRequest(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union)
  : body(::test_typesinprotocols::wire::Compound { bits, enum_, struct_, table, union_, opt_struct, opt_union } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 72 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::Compound, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::Compound, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::Compound body;
  explicit TransactionalRequest(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union)
  : body(::test_typesinprotocols::wire::Compound { bits, enum_, struct_, table, union_, opt_struct, opt_union } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 72 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::Compound, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::Compound, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound> final : public ::test_typesinprotocols::wire::Compound {

  
  explicit WireResponse(::test_typesinprotocols::wire::Compound base) : ::test_typesinprotocols::wire::Compound(std::move(base)) {}
  explicit WireResponse(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) : ::test_typesinprotocols::wire::Compound{ .bits = std::move(bits), .enum_ = std::move(enum_), .struct_ = std::move(struct_), .table = std::move(table), .union_ = std::move(union_), .opt_struct = std::move(opt_struct), .opt_union = std::move(opt_union)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 72;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound> body;
  explicit TransactionalResponse(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union)
  : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>(bits, enum_, struct_, table, union_, opt_struct, opt_union)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 72 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  
    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventCompound> body;

    explicit TransactionalEvent(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union)
    : body{ bits, enum_, struct_, table, union_, opt_struct, opt_union } {
      _InitHeader();
    }

  TransactionalEvent() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 72 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::ArrayBasic body;
  explicit TransactionalRequest(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string)
  : body(::test_typesinprotocols::wire::ArrayBasic { array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 384 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::ArrayBasic body;
  explicit TransactionalRequest(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string)
  : body(::test_typesinprotocols::wire::ArrayBasic { array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 384 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic> final : public ::test_typesinprotocols::wire::ArrayBasic {

  
  explicit WireResponse(::test_typesinprotocols::wire::ArrayBasic base) : ::test_typesinprotocols::wire::ArrayBasic(std::move(base)) {}
  explicit WireResponse(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) : ::test_typesinprotocols::wire::ArrayBasic{ .array_uint8 = std::move(array_uint8), .array_uint16 = std::move(array_uint16), .array_uint32 = std::move(array_uint32), .array_uint64 = std::move(array_uint64), .array_int8 = std::move(array_int8), .array_int16 = std::move(array_int16), .array_int32 = std::move(array_int32), .array_int64 = std::move(array_int64), .array_float32 = std::move(array_float32), .array_float64 = std::move(array_float64), .array_string = std::move(array_string), .array_opt_string = std::move(array_opt_string)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 384;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic> body;
  explicit TransactionalResponse(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string)
  : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 384 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  
    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayBasic> body;

    explicit TransactionalEvent(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string)
    : body{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string } {
      _InitHeader();
    }

  TransactionalEvent() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 384 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::ArrayCompound body;
  explicit TransactionalRequest(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union)
  : body(::test_typesinprotocols::wire::ArrayCompound { array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 328 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::ArrayCompound body;
  explicit TransactionalRequest(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union)
  : body(::test_typesinprotocols::wire::ArrayCompound { array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 328 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound> final : public ::test_typesinprotocols::wire::ArrayCompound {

  
  explicit WireResponse(::test_typesinprotocols::wire::ArrayCompound base) : ::test_typesinprotocols::wire::ArrayCompound(std::move(base)) {}
  explicit WireResponse(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) : ::test_typesinprotocols::wire::ArrayCompound{ .array_bits = std::move(array_bits), .array_enum = std::move(array_enum), .array_struct = std::move(array_struct), .array_table = std::move(array_table), .array_union = std::move(array_union), .array_opt_struct = std::move(array_opt_struct), .array_opt_union = std::move(array_opt_union)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 328;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound> body;
  explicit TransactionalResponse(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union)
  : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 328 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  
    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayCompound> body;

    explicit TransactionalEvent(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union)
    : body{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union } {
      _InitHeader();
    }

  TransactionalEvent() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 328 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::VectorBasic body;
  explicit TransactionalRequest(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string)
  : body(::test_typesinprotocols::wire::VectorBasic { vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 192 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::VectorBasic body;
  explicit TransactionalRequest(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string)
  : body(::test_typesinprotocols::wire::VectorBasic { vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 192 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic> final : public ::test_typesinprotocols::wire::VectorBasic {

  
  explicit WireResponse(::test_typesinprotocols::wire::VectorBasic base) : ::test_typesinprotocols::wire::VectorBasic(std::move(base)) {}
  explicit WireResponse(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) : ::test_typesinprotocols::wire::VectorBasic{ .vector_uint8 = std::move(vector_uint8), .vector_uint16 = std::move(vector_uint16), .vector_uint32 = std::move(vector_uint32), .vector_uint64 = std::move(vector_uint64), .vector_int8 = std::move(vector_int8), .vector_int16 = std::move(vector_int16), .vector_int32 = std::move(vector_int32), .vector_int64 = std::move(vector_int64), .vector_float32 = std::move(vector_float32), .vector_float64 = std::move(vector_float64), .vector_string = std::move(vector_string), .vector_opt_string = std::move(vector_opt_string)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 192;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic> body;
  explicit TransactionalResponse(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string)
  : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 192 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  
    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorBasic> body;

    explicit TransactionalEvent(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string)
    : body{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string } {
      _InitHeader();
    }

  TransactionalEvent() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 192 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::VectorCompound body;
  explicit TransactionalRequest(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union)
  : body(::test_typesinprotocols::wire::VectorCompound { vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 112 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::VectorCompound body;
  explicit TransactionalRequest(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union)
  : body(::test_typesinprotocols::wire::VectorCompound { vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 112 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound> final : public ::test_typesinprotocols::wire::VectorCompound {

  
  explicit WireResponse(::test_typesinprotocols::wire::VectorCompound base) : ::test_typesinprotocols::wire::VectorCompound(std::move(base)) {}
  explicit WireResponse(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) : ::test_typesinprotocols::wire::VectorCompound{ .vector_bits = std::move(vector_bits), .vector_enum = std::move(vector_enum), .vector_struct = std::move(vector_struct), .vector_table = std::move(vector_table), .vector_union = std::move(vector_union), .vector_opt_struct = std::move(vector_opt_struct), .vector_opt_union = std::move(vector_opt_union)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 112;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound> body;
  explicit TransactionalResponse(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union)
  : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 112 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  
    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorCompound> body;

    explicit TransactionalEvent(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union)
    : body{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union } {
      _InitHeader();
    }

  TransactionalEvent() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 112 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::VectorOptional body;
  explicit TransactionalRequest(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct)
  : body(::test_typesinprotocols::wire::VectorOptional { opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 64 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::VectorOptional body;
  explicit TransactionalRequest(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct)
  : body(::test_typesinprotocols::wire::VectorOptional { opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 64 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional> final : public ::test_typesinprotocols::wire::VectorOptional {

  
  explicit WireResponse(::test_typesinprotocols::wire::VectorOptional base) : ::test_typesinprotocols::wire::VectorOptional(std::move(base)) {}
  explicit WireResponse(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) : ::test_typesinprotocols::wire::VectorOptional{ .opt_vector_uint8 = std::move(opt_vector_uint8), .opt_vector_string = std::move(opt_vector_string), .opt_vector_struct = std::move(opt_vector_struct), .opt_vector_opt_struct = std::move(opt_vector_opt_struct)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 64;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional> body;
  explicit TransactionalResponse(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct)
  : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 64 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  
    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorOptional> body;

    explicit TransactionalEvent(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct)
    : body{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct } {
      _InitHeader();
    }

  TransactionalEvent() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 64 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::ArrayVectorNested body;
  explicit TransactionalRequest(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8)
  : body(::test_typesinprotocols::wire::ArrayVectorNested { array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 144 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::test_typesinprotocols::wire::ArrayVectorNested body;
  explicit TransactionalRequest(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8)
  : body(::test_typesinprotocols::wire::ArrayVectorNested { array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 } ) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 144 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> final : public ::test_typesinprotocols::wire::ArrayVectorNested {

  
  explicit WireResponse(::test_typesinprotocols::wire::ArrayVectorNested base) : ::test_typesinprotocols::wire::ArrayVectorNested(std::move(base)) {}
  explicit WireResponse(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) : ::test_typesinprotocols::wire::ArrayVectorNested{ .array_array_uint8 = std::move(array_array_uint8), .array_vector_uint8 = std::move(array_vector_uint8), .vector_array_uint8 = std::move(vector_array_uint8), .vector_vector_uint8 = std::move(vector_vector_uint8)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 144;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> body;
  explicit TransactionalResponse(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8)
  : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 144 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__
template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  
    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested> body;

    explicit TransactionalEvent(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8)
    : body{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 } {
      _InitHeader();
    }

  TransactionalEvent() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 144 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#endif  // __Fuchsia__


namespace fidl {


#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_BasicTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(80 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(80 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::Basic)
    == TypeTraits<::test_typesinprotocols::wire::Basic>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint16) == 2);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint32) == 4);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint64) == 8);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int8) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int16) == 18);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int32) == 20);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int64) == 24);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, float32) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, float64) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, string) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, opt_string) == 64);

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_BasicTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(80 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(80 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::Basic)
    == TypeTraits<::test_typesinprotocols::wire::Basic>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint16) == 2);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint32) == 4);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint64) == 8);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int8) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int16) == 18);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int32) == 20);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int64) == 24);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, float32) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, float64) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, string) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, opt_string) == 64);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_BasicTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(80 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(80 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_BasicTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 80;
  static constexpr uint32_t kPrimarySizeV1 = 80;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>)
    == TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, uint8) == 0);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, uint16) == 2);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, uint32) == 4);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, uint64) == 8);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, int8) == 16);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, int16) == 18);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, int32) == 20);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, int64) == 24);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, float32) == 32);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, float64) == 40);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, string) == 48);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, opt_string) == 64);
#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_BasicTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(80 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(80 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, body) == sizeof(fidl_message_header_t));

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_CompoundTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(72 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(88 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::Compound)
    == TypeTraits<::test_typesinprotocols::wire::Compound>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, bits) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, enum_) == 4);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, struct_) == 8);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, table) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, union_) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, opt_struct) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, opt_union) == 56);

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_CompoundTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(72 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(88 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::Compound)
    == TypeTraits<::test_typesinprotocols::wire::Compound>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, bits) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, enum_) == 4);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, struct_) == 8);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, table) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, union_) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, opt_struct) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, opt_union) == 56);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_CompoundTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(72 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(88 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_CompoundTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 72;
  static constexpr uint32_t kPrimarySizeV1 = 88;
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>)
    == TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, bits) == 0);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, enum_) == 4);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, struct_) == 8);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, table) == 16);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, union_) == 32);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, opt_struct) == 48);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, opt_union) == 56);
#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_CompoundTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(72 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(88 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, body) == sizeof(fidl_message_header_t));

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayBasicTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(384 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(384 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::ArrayBasic)
    == TypeTraits<::test_typesinprotocols::wire::ArrayBasic>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint16) == 6);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint32) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint64) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int8) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int16) == 86);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int32) == 96);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int64) == 120);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_float32) == 160);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_float64) == 184);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_string) == 224);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_opt_string) == 304);

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayBasicTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(384 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(384 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::ArrayBasic)
    == TypeTraits<::test_typesinprotocols::wire::ArrayBasic>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint16) == 6);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint32) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint64) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int8) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int16) == 86);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int32) == 96);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int64) == 120);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_float32) == 160);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_float64) == 184);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_string) == 224);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_opt_string) == 304);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayBasicTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(384 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(384 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayBasicTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 384;
  static constexpr uint32_t kPrimarySizeV1 = 384;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>)
    == TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_uint8) == 0);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_uint16) == 6);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_uint32) == 16);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_uint64) == 40);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_int8) == 80);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_int16) == 86);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_int32) == 96);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_int64) == 120);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_float32) == 160);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_float64) == 184);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_string) == 224);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_opt_string) == 304);
#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayBasicTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(384 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(384 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, body) == sizeof(fidl_message_header_t));

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayCompoundTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(328 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(408 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 40;
  static constexpr uint32_t kMaxOutOfLineV1 = 120;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::ArrayCompound)
    == TypeTraits<::test_typesinprotocols::wire::ArrayCompound>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_bits) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_enum) == 20);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_struct) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_table) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_union) == 128);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_opt_struct) == 208);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_opt_union) == 248);

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayCompoundTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(328 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(408 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 40;
  static constexpr uint32_t kMaxOutOfLineV1 = 120;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::ArrayCompound)
    == TypeTraits<::test_typesinprotocols::wire::ArrayCompound>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_bits) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_enum) == 20);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_struct) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_table) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_union) == 128);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_opt_struct) == 208);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_opt_union) == 248);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayCompoundTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(328 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(408 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 40;
  static constexpr uint32_t kMaxOutOfLineV1 = 120;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayCompoundTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 328;
  static constexpr uint32_t kPrimarySizeV1 = 408;
  static constexpr uint32_t kMaxOutOfLine = 40;
  static constexpr uint32_t kMaxOutOfLineV1 = 120;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>)
    == TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_bits) == 0);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_enum) == 20);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_struct) == 40);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_table) == 48);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_union) == 128);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_opt_struct) == 208);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_opt_union) == 248);
#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayCompoundTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(328 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(408 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 40;
  static constexpr uint32_t kMaxOutOfLineV1 = 120;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, body) == sizeof(fidl_message_header_t));

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorBasicTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(192 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(192 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::VectorBasic)
    == TypeTraits<::test_typesinprotocols::wire::VectorBasic>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint16) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint32) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint64) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int8) == 64);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int16) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int32) == 96);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int64) == 112);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_float32) == 128);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_float64) == 144);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_string) == 160);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_opt_string) == 176);

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorBasicTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(192 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(192 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::VectorBasic)
    == TypeTraits<::test_typesinprotocols::wire::VectorBasic>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint16) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint32) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint64) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int8) == 64);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int16) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int32) == 96);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int64) == 112);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_float32) == 128);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_float64) == 144);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_string) == 160);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_opt_string) == 176);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorBasicTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(192 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(192 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorBasicTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 192;
  static constexpr uint32_t kPrimarySizeV1 = 192;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>)
    == TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_uint8) == 0);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_uint16) == 16);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_uint32) == 32);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_uint64) == 48);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_int8) == 64);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_int16) == 80);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_int32) == 96);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_int64) == 112);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_float32) == 128);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_float64) == 144);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_string) == 160);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_opt_string) == 176);
#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorBasicTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(192 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(192 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, body) == sizeof(fidl_message_header_t));

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorCompoundTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(112 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(112 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::VectorCompound)
    == TypeTraits<::test_typesinprotocols::wire::VectorCompound>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_bits) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_enum) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_struct) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_table) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_union) == 64);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_opt_struct) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_opt_union) == 96);

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorCompoundTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(112 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(112 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::VectorCompound)
    == TypeTraits<::test_typesinprotocols::wire::VectorCompound>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_bits) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_enum) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_struct) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_table) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_union) == 64);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_opt_struct) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_opt_union) == 96);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorCompoundTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(112 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(112 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorCompoundTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 112;
  static constexpr uint32_t kPrimarySizeV1 = 112;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>)
    == TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_bits) == 0);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_enum) == 16);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_struct) == 32);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_table) == 48);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_union) == 64);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_opt_struct) == 80);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_opt_union) == 96);
#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorCompoundTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(112 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(112 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, body) == sizeof(fidl_message_header_t));

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorOptionalTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(64 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(64 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::VectorOptional)
    == TypeTraits<::test_typesinprotocols::wire::VectorOptional>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_string) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_struct) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_opt_struct) == 48);

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorOptionalTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(64 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(64 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::VectorOptional)
    == TypeTraits<::test_typesinprotocols::wire::VectorOptional>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_string) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_struct) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_opt_struct) == 48);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorOptionalTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(64 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(64 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorOptionalTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 64;
  static constexpr uint32_t kPrimarySizeV1 = 64;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>)
    == TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, opt_vector_uint8) == 0);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, opt_vector_string) == 16);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, opt_vector_struct) == 32);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, opt_vector_opt_struct) == 48);
#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_VectorOptionalTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(64 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(64 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, body) == sizeof(fidl_message_header_t));

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayVectorNestedTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(144 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(144 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::ArrayVectorNested)
    == TypeTraits<::test_typesinprotocols::wire::ArrayVectorNested>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, array_array_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, array_vector_uint8) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, vector_array_uint8) == 112);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, vector_vector_uint8) == 128);

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayVectorNestedTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(144 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(144 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, body) == sizeof(fidl_message_header_t));
static_assert(sizeof(::test_typesinprotocols::wire::ArrayVectorNested)
    == TypeTraits<::test_typesinprotocols::wire::ArrayVectorNested>::kPrimarySize);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, array_array_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, array_vector_uint8) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, vector_array_uint8) == 112);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, vector_vector_uint8) == 128);

#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayVectorNestedTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(144 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(144 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, body) == sizeof(fidl_message_header_t));
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayVectorNestedTable;
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 144;
  static constexpr uint32_t kPrimarySizeV1 = 144;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>)
    == TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, array_array_uint8) == 0);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, array_vector_uint8) == 32);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, vector_array_uint8) == 112);
static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, vector_vector_uint8) == 128);
#ifdef __Fuchsia__
template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>> {
  static constexpr const fidl_type_t* kType =
    &::test_typesinprotocols::test_typesinprotocols_ArrayVectorNestedTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(144 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(144 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, body) == sizeof(fidl_message_header_t));

#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace fidl

    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_typesinprotocols::Protocol> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_typesinprotocols::Protocol>> {
   public:
    static constexpr uint32_t kNumHandles = 64;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_typesinprotocols::Protocol> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_typesinprotocols::Protocol>> {
   public:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_typesinprotocols::Protocol> handles_storage_;
  };





template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayBasic>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayBasic>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayBasic>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayBasic> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayBasic>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayBasic>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayBasic>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayBasic>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> decoded_;
};




template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayCompound>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayCompound>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayCompound>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayCompound> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayCompound>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayCompound>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayCompound>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayCompound>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> decoded_;
};




template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayArrayBasic> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> decoded_;
};




template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayArrayCompound> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> decoded_;
};




template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayVectorBasic> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> decoded_;
};




template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayVectorCompound> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> decoded_;
};




template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorOptional> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayVectorOptional> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> decoded_;
};




template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>(::fidl::internal::StatusFromResult(decoded)) {}

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  
};


template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> decoded_;
};


template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(result) {}
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> decoded_;
};

template<>
class ::fidl::internal::WireEventHandlerInterface<::test_typesinprotocols::Protocol> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
    virtual void EventBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventBasic>* event) = 0;
    virtual void EventCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventCompound>* event) = 0;
    virtual void EventArrayBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayBasic>* event) = 0;
    virtual void EventArrayCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayCompound>* event) = 0;
    virtual void EventVectorBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorBasic>* event) = 0;
    virtual void EventVectorCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorCompound>* event) = 0;
    virtual void EventVectorOptional(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorOptional>* event) = 0;
    virtual void EventArrayVectorNested(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>* event) = 0;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_typesinprotocols::Protocol>
    : public ::fidl::internal::WireEventHandlerInterface<::test_typesinprotocols::Protocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
    void EventBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventBasic>* event) override {}
    void EventCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventCompound>* event) override {}
    void EventArrayBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayBasic>* event) override {}
    void EventArrayCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayCompound>* event) override {}
    void EventVectorBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorBasic>* event) override {}
    void EventVectorCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorCompound>* event) override {}
    void EventVectorOptional(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorOptional>* event) override {}
    void EventArrayVectorNested(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>* event) override {}
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_typesinprotocols::Protocol>
      : public ::fidl::internal::WireEventHandlerInterface<::test_typesinprotocols::Protocol>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_typesinprotocols::Protocol> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_typesinprotocols::Protocol>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_typesinprotocols::Protocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
    ::fidl::Status DispatchEvent(
        ::fidl::IncomingHeaderAndMessage& msg,
        ::fidl::internal::MessageStorageViewBase* storage_view) override;
};



// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |::fidl::ClientEnd<::test_typesinprotocols::Protocol>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>> {
 public:
  
    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::OneWayStatus
    OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic> _request{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayBasic>(_client_end(), &_request);
    }

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayBasic>
    TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic> _request{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayBasic>(_client_end(), &_request);
    }

    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::OneWayStatus
    OneWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound> _request{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayCompound>(_client_end(), &_request);
    }

    // Allocates 96 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayCompound>
    TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound> _request{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayCompound>(_client_end(), &_request);
    }

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::OneWayStatus
    OneWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic> _request{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>(_client_end(), &_request);
    }

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>
    TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic> _request{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(_client_end(), &_request);
    }

    // Allocates 400 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::OneWayStatus
    OneWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound> _request{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>(_client_end(), &_request);
    }

    // Allocates 384 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>
    TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound> _request{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(_client_end(), &_request);
    }

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::OneWayStatus
    OneWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic> _request{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>(_client_end(), &_request);
    }

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>
    TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic> _request{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(_client_end(), &_request);
    }

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::OneWayStatus
    OneWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound> _request{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>(_client_end(), &_request);
    }

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>
    TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound> _request{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(_client_end(), &_request);
    }

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::OneWayStatus
    OneWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional> _request{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>(_client_end(), &_request);
    }

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>
    TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional> _request{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(_client_end(), &_request);
    }

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::OneWayStatus
    OneWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> _request{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>(_client_end(), &_request);
    }

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>
    TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> _request{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
      return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic> _request{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayBasic>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayBasic>
    TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic> _request{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayBasic>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound> _request{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayCompound>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayCompound>
    TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound> _request{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayCompound>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic> _request{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>
    TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic> _request{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound> _request{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>
    TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound> _request{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic> _request{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>
    TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic> _request{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound> _request{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>
    TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound> _request{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional> _request{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>
    TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional> _request{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> _request{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>
    TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> _request{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
      return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayBasic> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayBasic> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

 private:
  void MakeReply(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayBasic> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

 private:
  void MakeReply(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayBasic> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayBasic> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayCompound> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayCompound> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

 private:
  void MakeReply(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayCompound> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

 private:
  void MakeReply(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayCompound> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayCompound> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayBasic> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayArrayBasic> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

 private:
  void MakeReply(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayBasic> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

 private:
  void MakeReply(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayBasic> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayBasic> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayCompound> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayArrayCompound> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

 private:
  void MakeReply(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayCompound> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

 private:
  void MakeReply(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayCompound> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayCompound> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorBasic> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayVectorBasic> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

 private:
  void MakeReply(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorBasic> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

 private:
  void MakeReply(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorBasic> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorBasic> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorCompound> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayVectorCompound> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

 private:
  void MakeReply(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorCompound> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

 private:
  void MakeReply(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorCompound> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorCompound> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorOptional> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayVectorOptional> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

 private:
  void MakeReply(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorOptional> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

 private:
  void MakeReply(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorOptional> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorOptional> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};


template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

 private:
  void MakeReply(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

 private:
  void MakeReply(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |::fidl::ClientEnd<::test_typesinprotocols::Protocol>|
// and |::fidl::ServerEnd<::test_typesinprotocols::Protocol>|).
template<>
class ::fidl::WireServer<::test_typesinprotocols::Protocol> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_typesinprotocols::Protocol;

  using Handler = fidl::ProtocolHandler<::test_typesinprotocols::Protocol>;


    using OneWayBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayBasic>;
      using OneWayBasicRequestView = ::test_typesinprotocols::wire::Basic*;

  
  virtual void OneWayBasic(
      ::test_typesinprotocols::wire::Basic* request,
    OneWayBasicCompleter::Sync& completer)= 0;

    using TwoWayBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayBasic>;
      using TwoWayBasicRequestView = ::test_typesinprotocols::wire::Basic*;

  
  virtual void TwoWayBasic(
      ::test_typesinprotocols::wire::Basic* request,
    TwoWayBasicCompleter::Sync& completer)= 0;

    using OneWayCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayCompound>;
      using OneWayCompoundRequestView = ::test_typesinprotocols::wire::Compound*;

  
  virtual void OneWayCompound(
      ::test_typesinprotocols::wire::Compound* request,
    OneWayCompoundCompleter::Sync& completer)= 0;

    using TwoWayCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayCompound>;
      using TwoWayCompoundRequestView = ::test_typesinprotocols::wire::Compound*;

  
  virtual void TwoWayCompound(
      ::test_typesinprotocols::wire::Compound* request,
    TwoWayCompoundCompleter::Sync& completer)= 0;

    using OneWayArrayBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayArrayBasic>;
      using OneWayArrayBasicRequestView = ::test_typesinprotocols::wire::ArrayBasic*;

  
  virtual void OneWayArrayBasic(
      ::test_typesinprotocols::wire::ArrayBasic* request,
    OneWayArrayBasicCompleter::Sync& completer)= 0;

    using TwoWayArrayBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayArrayBasic>;
      using TwoWayArrayBasicRequestView = ::test_typesinprotocols::wire::ArrayBasic*;

  
  virtual void TwoWayArrayBasic(
      ::test_typesinprotocols::wire::ArrayBasic* request,
    TwoWayArrayBasicCompleter::Sync& completer)= 0;

    using OneWayArrayCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayArrayCompound>;
      using OneWayArrayCompoundRequestView = ::test_typesinprotocols::wire::ArrayCompound*;

  
  virtual void OneWayArrayCompound(
      ::test_typesinprotocols::wire::ArrayCompound* request,
    OneWayArrayCompoundCompleter::Sync& completer)= 0;

    using TwoWayArrayCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayArrayCompound>;
      using TwoWayArrayCompoundRequestView = ::test_typesinprotocols::wire::ArrayCompound*;

  
  virtual void TwoWayArrayCompound(
      ::test_typesinprotocols::wire::ArrayCompound* request,
    TwoWayArrayCompoundCompleter::Sync& completer)= 0;

    using OneWayVectorBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayVectorBasic>;
      using OneWayVectorBasicRequestView = ::test_typesinprotocols::wire::VectorBasic*;

  
  virtual void OneWayVectorBasic(
      ::test_typesinprotocols::wire::VectorBasic* request,
    OneWayVectorBasicCompleter::Sync& completer)= 0;

    using TwoWayVectorBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayVectorBasic>;
      using TwoWayVectorBasicRequestView = ::test_typesinprotocols::wire::VectorBasic*;

  
  virtual void TwoWayVectorBasic(
      ::test_typesinprotocols::wire::VectorBasic* request,
    TwoWayVectorBasicCompleter::Sync& completer)= 0;

    using OneWayVectorCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayVectorCompound>;
      using OneWayVectorCompoundRequestView = ::test_typesinprotocols::wire::VectorCompound*;

  
  virtual void OneWayVectorCompound(
      ::test_typesinprotocols::wire::VectorCompound* request,
    OneWayVectorCompoundCompleter::Sync& completer)= 0;

    using TwoWayVectorCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayVectorCompound>;
      using TwoWayVectorCompoundRequestView = ::test_typesinprotocols::wire::VectorCompound*;

  
  virtual void TwoWayVectorCompound(
      ::test_typesinprotocols::wire::VectorCompound* request,
    TwoWayVectorCompoundCompleter::Sync& completer)= 0;

    using OneWayVectorOptionalCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayVectorOptional>;
      using OneWayVectorOptionalRequestView = ::test_typesinprotocols::wire::VectorOptional*;

  
  virtual void OneWayVectorOptional(
      ::test_typesinprotocols::wire::VectorOptional* request,
    OneWayVectorOptionalCompleter::Sync& completer)= 0;

    using TwoWayVectorOptionalCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayVectorOptional>;
      using TwoWayVectorOptionalRequestView = ::test_typesinprotocols::wire::VectorOptional*;

  
  virtual void TwoWayVectorOptional(
      ::test_typesinprotocols::wire::VectorOptional* request,
    TwoWayVectorOptionalCompleter::Sync& completer)= 0;

    using OneWayArrayVectorNestedCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>;
      using OneWayArrayVectorNestedRequestView = ::test_typesinprotocols::wire::ArrayVectorNested*;

  
  virtual void OneWayArrayVectorNested(
      ::test_typesinprotocols::wire::ArrayVectorNested* request,
    OneWayArrayVectorNestedCompleter::Sync& completer)= 0;

    using TwoWayArrayVectorNestedCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>;
      using TwoWayArrayVectorNestedRequestView = ::test_typesinprotocols::wire::ArrayVectorNested*;

  
  virtual void TwoWayArrayVectorNested(
      ::test_typesinprotocols::wire::ArrayVectorNested* request,
    TwoWayArrayVectorNestedCompleter::Sync& completer)= 0;


  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_typesinprotocols::Protocol> request) {
        (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

  private:
  void dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {

#endif  // __Fuchsia__


  

    
#ifdef __Fuchsia__
}  // namespace fidl

template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
  
  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::OneWayStatus OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);
  
  // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::OneWayStatus OneWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);
  
  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::OneWayStatus OneWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);
  
  // Allocates 400 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::OneWayStatus OneWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);
  
  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::OneWayStatus OneWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);
  
  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::OneWayStatus OneWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);
  
  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::OneWayStatus OneWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);
  
  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::OneWayStatus OneWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayBasic> TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);
    // Allocates 96 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayCompound> TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayArrayBasic> TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);
    // Allocates 384 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayArrayCompound> TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayVectorBasic> TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayVectorCompound> TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayVectorOptional> TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_typesinprotocols::Protocol> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);


// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);


// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);


// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);


// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);


// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);


// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);


// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_typesinprotocols::Protocol> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayBasic> TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayCompound> TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayArrayBasic> TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayArrayCompound> TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayVectorBasic> TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayVectorCompound> TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayVectorOptional> TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayBasic> TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);
  
  // Allocates 96 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayCompound> TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);
  
  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic> TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);
  
  // Allocates 384 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound> TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);
  
  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic> TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);
  
  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound> TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);
  
  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional> TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);
  
  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);
};namespace fidl {

#endif  // __Fuchsia__


    
}  // namespace fidl

#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_typesinprotocols::Protocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

    fidl::OneWayStatus EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);


    fidl::OneWayStatus EventCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);


    fidl::OneWayStatus EventArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);


    fidl::OneWayStatus EventArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);


    fidl::OneWayStatus EventVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);


    fidl::OneWayStatus EventVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);


    fidl::OneWayStatus EventVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);


    fidl::OneWayStatus EventArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);


};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_typesinprotocols::Protocol> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

    fidl::OneWayStatus EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);


    fidl::OneWayStatus EventCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);


    fidl::OneWayStatus EventArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);


    fidl::OneWayStatus EventArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);


    fidl::OneWayStatus EventVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);


    fidl::OneWayStatus EventVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);


    fidl::OneWayStatus EventVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);


    fidl::OneWayStatus EventArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);


};

template<>
class ::fidl::internal::WireEventSender<::test_typesinprotocols::Protocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_typesinprotocols::Protocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

    fidl::OneWayStatus EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);


    fidl::OneWayStatus EventCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);


    fidl::OneWayStatus EventArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);


    fidl::OneWayStatus EventArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);


    fidl::OneWayStatus EventVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);


    fidl::OneWayStatus EventVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);


    fidl::OneWayStatus EventVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);


    fidl::OneWayStatus EventArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);


};

template<>
class ::fidl::internal::WireBufferEventSender<::test_typesinprotocols::Protocol>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_typesinprotocols::Protocol>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

    fidl::OneWayStatus EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);


    fidl::OneWayStatus EventCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);


    fidl::OneWayStatus EventArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);


    fidl::OneWayStatus EventArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);


    fidl::OneWayStatus EventVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);


    fidl::OneWayStatus EventVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);


    fidl::OneWayStatus EventVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);


    fidl::OneWayStatus EventArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);


};

#endif  // __Fuchsia__


  #pragma clang diagnostic pop

  

