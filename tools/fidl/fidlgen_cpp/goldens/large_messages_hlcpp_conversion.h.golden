// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = allow_overflowing
// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include <fidl/test.largemessages/cpp/natural_types.h>
#include <lib/fidl/cpp/hlcpp_conversion.h>
#include <lib/fidl/cpp/wire/internal/transport_channel.h>
#include <test/largemessages/cpp/fidl.h>

namespace fidl {
namespace internal {

template <>
struct NaturalToHLCPPTraits<fidl::ClientEnd<::test_largemessages::Overflowing>> {
  using HLCPPType = fidl::InterfaceHandle<::test::largemessages::Overflowing>;
  static inline fidl::InterfaceHandle<::test::largemessages::Overflowing> Convert(fidl::ClientEnd<::test_largemessages::Overflowing>&& c) {
    return fidl::InterfaceHandle<::test::largemessages::Overflowing>(c.TakeChannel());
  }
};

template <>
struct NaturalToHLCPPTraits<fidl::ServerEnd<::test_largemessages::Overflowing>> {
  using HLCPPType = fidl::InterfaceRequest<::test::largemessages::Overflowing>;
  static inline fidl::InterfaceRequest<::test::largemessages::Overflowing> Convert(fidl::ServerEnd<::test_largemessages::Overflowing>&& c) {
    return fidl::InterfaceRequest<::test::largemessages::Overflowing>(c.TakeChannel());
  }
};

template <>
struct HLCPPToNaturalTraits<fidl::InterfaceHandle<::test::largemessages::Overflowing>> {
  using NaturalType = fidl::ClientEnd<::test_largemessages::Overflowing>;
  static inline fidl::ClientEnd<::test_largemessages::Overflowing> Convert(fidl::InterfaceHandle<::test::largemessages::Overflowing>&& c) {
    return fidl::ClientEnd<::test_largemessages::Overflowing>(c.TakeChannel());
  }
};

template <>
struct HLCPPToNaturalTraits<fidl::InterfaceRequest<::test::largemessages::Overflowing>> {
  using NaturalType = fidl::ServerEnd<::test_largemessages::Overflowing>;
  static inline fidl::ServerEnd<::test_largemessages::Overflowing> Convert(fidl::InterfaceRequest<::test::largemessages::Overflowing>&& c) {
    return fidl::ServerEnd<::test_largemessages::Overflowing>(c.TakeChannel());
  }
};

template <>
struct NaturalToHLCPPTraits<::test_largemessages::BoundedKnownToBeSmall> {
  using HLCPPType = ::test::largemessages::BoundedKnownToBeSmall;
  static inline ::test::largemessages::BoundedKnownToBeSmall Convert(::test_largemessages::BoundedKnownToBeSmall&&);
};
template <>
struct HLCPPToNaturalTraits<::test::largemessages::BoundedKnownToBeSmall> {
  using NaturalType = ::test_largemessages::BoundedKnownToBeSmall;
  static inline ::test_largemessages::BoundedKnownToBeSmall Convert(::test::largemessages::BoundedKnownToBeSmall&&);
};
template <>
struct NaturalToHLCPPTraits<::test_largemessages::BoundedMaybeLarge> {
  using HLCPPType = ::test::largemessages::BoundedMaybeLarge;
  static inline ::test::largemessages::BoundedMaybeLarge Convert(::test_largemessages::BoundedMaybeLarge&&);
};
template <>
struct HLCPPToNaturalTraits<::test::largemessages::BoundedMaybeLarge> {
  using NaturalType = ::test_largemessages::BoundedMaybeLarge;
  static inline ::test_largemessages::BoundedMaybeLarge Convert(::test::largemessages::BoundedMaybeLarge&&);
};
template <>
struct NaturalToHLCPPTraits<::test_largemessages::UnboundedMaybeLargeValue> {
  using HLCPPType = ::test::largemessages::UnboundedMaybeLargeValue;
  static inline ::test::largemessages::UnboundedMaybeLargeValue Convert(::test_largemessages::UnboundedMaybeLargeValue&&);
};
template <>
struct HLCPPToNaturalTraits<::test::largemessages::UnboundedMaybeLargeValue> {
  using NaturalType = ::test_largemessages::UnboundedMaybeLargeValue;
  static inline ::test_largemessages::UnboundedMaybeLargeValue Convert(::test::largemessages::UnboundedMaybeLargeValue&&);
};
template <>
struct NaturalToHLCPPTraits<::test_largemessages::Elements> {
  using HLCPPType = ::test::largemessages::Elements;
  static inline ::test::largemessages::Elements Convert(::test_largemessages::Elements&&);
};
template <>
struct HLCPPToNaturalTraits<::test::largemessages::Elements> {
  using NaturalType = ::test_largemessages::Elements;
  static inline ::test_largemessages::Elements Convert(::test::largemessages::Elements&&);
};
template <>
struct NaturalToHLCPPTraits<::test_largemessages::UnboundedMaybeLargeResource> {
  using HLCPPType = ::test::largemessages::UnboundedMaybeLargeResource;
  static inline ::test::largemessages::UnboundedMaybeLargeResource Convert(::test_largemessages::UnboundedMaybeLargeResource&&);
};
template <>
struct HLCPPToNaturalTraits<::test::largemessages::UnboundedMaybeLargeResource> {
  using NaturalType = ::test_largemessages::UnboundedMaybeLargeResource;
  static inline ::test_largemessages::UnboundedMaybeLargeResource Convert(::test::largemessages::UnboundedMaybeLargeResource&&);
};
template <>
struct NaturalToHLCPPTraits<::test_largemessages::SemiBoundedBelievedToBeSmall> {
  using HLCPPType = ::test::largemessages::SemiBoundedBelievedToBeSmall;
  static inline ::test::largemessages::SemiBoundedBelievedToBeSmall Convert(::test_largemessages::SemiBoundedBelievedToBeSmall&&);
};
template <>
struct HLCPPToNaturalTraits<::test::largemessages::SemiBoundedBelievedToBeSmall> {
  using NaturalType = ::test_largemessages::SemiBoundedBelievedToBeSmall;
  static inline ::test_largemessages::SemiBoundedBelievedToBeSmall Convert(::test::largemessages::SemiBoundedBelievedToBeSmall&&);
};
template <>
struct NaturalToHLCPPTraits<::test_largemessages::SemiBoundedMaybeLarge> {
  using HLCPPType = ::test::largemessages::SemiBoundedMaybeLarge;
  static inline ::test::largemessages::SemiBoundedMaybeLarge Convert(::test_largemessages::SemiBoundedMaybeLarge&&);
};
template <>
struct HLCPPToNaturalTraits<::test::largemessages::SemiBoundedMaybeLarge> {
  using NaturalType = ::test_largemessages::SemiBoundedMaybeLarge;
  static inline ::test_largemessages::SemiBoundedMaybeLarge Convert(::test::largemessages::SemiBoundedMaybeLarge&&);
};

::test::largemessages::BoundedKnownToBeSmall NaturalToHLCPPTraits<::test_largemessages::BoundedKnownToBeSmall>::Convert(::test_largemessages::BoundedKnownToBeSmall&& value) {
  ::test::largemessages::BoundedKnownToBeSmall hlcpp;
  hlcpp.bytes = ::fidl::NaturalToHLCPP(std::move(value.bytes()));
  return hlcpp;
}

::test_largemessages::BoundedKnownToBeSmall HLCPPToNaturalTraits<::test::largemessages::BoundedKnownToBeSmall>::Convert(::test::largemessages::BoundedKnownToBeSmall&& value) {
  return ::test_largemessages::BoundedKnownToBeSmall{{
      .bytes = ::fidl::HLCPPToNatural(std::move(value.bytes)),
  }};
}
::test::largemessages::BoundedMaybeLarge NaturalToHLCPPTraits<::test_largemessages::BoundedMaybeLarge>::Convert(::test_largemessages::BoundedMaybeLarge&& value) {
  ::test::largemessages::BoundedMaybeLarge hlcpp;
  hlcpp.bytes = ::fidl::NaturalToHLCPP(std::move(value.bytes()));
  return hlcpp;
}

::test_largemessages::BoundedMaybeLarge HLCPPToNaturalTraits<::test::largemessages::BoundedMaybeLarge>::Convert(::test::largemessages::BoundedMaybeLarge&& value) {
  return ::test_largemessages::BoundedMaybeLarge{{
      .bytes = ::fidl::HLCPPToNatural(std::move(value.bytes)),
  }};
}
::test::largemessages::UnboundedMaybeLargeValue NaturalToHLCPPTraits<::test_largemessages::UnboundedMaybeLargeValue>::Convert(::test_largemessages::UnboundedMaybeLargeValue&& value) {
  ::test::largemessages::UnboundedMaybeLargeValue hlcpp;
  hlcpp.bytes = ::fidl::NaturalToHLCPP(std::move(value.bytes()));
  return hlcpp;
}

::test_largemessages::UnboundedMaybeLargeValue HLCPPToNaturalTraits<::test::largemessages::UnboundedMaybeLargeValue>::Convert(::test::largemessages::UnboundedMaybeLargeValue&& value) {
  return ::test_largemessages::UnboundedMaybeLargeValue{{
      .bytes = ::fidl::HLCPPToNatural(std::move(value.bytes)),
  }};
}
::test::largemessages::Elements NaturalToHLCPPTraits<::test_largemessages::Elements>::Convert(::test_largemessages::Elements&& value) {
  ::test::largemessages::Elements hlcpp;
  hlcpp.handle = ::fidl::NaturalToHLCPP(std::move(value.handle()));
  hlcpp.bytes = ::fidl::NaturalToHLCPP(std::move(value.bytes()));
  return hlcpp;
}

::test_largemessages::Elements HLCPPToNaturalTraits<::test::largemessages::Elements>::Convert(::test::largemessages::Elements&& value) {
  return ::test_largemessages::Elements{{
      .handle = ::fidl::HLCPPToNatural(std::move(value.handle)),
      .bytes = ::fidl::HLCPPToNatural(std::move(value.bytes)),
  }};
}
::test::largemessages::UnboundedMaybeLargeResource NaturalToHLCPPTraits<::test_largemessages::UnboundedMaybeLargeResource>::Convert(::test_largemessages::UnboundedMaybeLargeResource&& value) {
  ::test::largemessages::UnboundedMaybeLargeResource hlcpp;
  hlcpp.elements = ::fidl::NaturalToHLCPP(std::move(value.elements()));
  return hlcpp;
}

::test_largemessages::UnboundedMaybeLargeResource HLCPPToNaturalTraits<::test::largemessages::UnboundedMaybeLargeResource>::Convert(::test::largemessages::UnboundedMaybeLargeResource&& value) {
  return ::test_largemessages::UnboundedMaybeLargeResource{{
      .elements = ::fidl::HLCPPToNatural(std::move(value.elements)),
  }};
}

::test::largemessages::SemiBoundedBelievedToBeSmall NaturalToHLCPPTraits<::test_largemessages::SemiBoundedBelievedToBeSmall>::Convert(::test_largemessages::SemiBoundedBelievedToBeSmall&& value) {
  ::test::largemessages::SemiBoundedBelievedToBeSmall hlcpp;
  switch (value.Which()) {
    case ::test_largemessages::SemiBoundedBelievedToBeSmall::Tag::kBytes:
      hlcpp.set_bytes(::fidl::NaturalToHLCPP(std::move(value.bytes().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_largemessages::SemiBoundedBelievedToBeSmall HLCPPToNaturalTraits<::test::largemessages::SemiBoundedBelievedToBeSmall>::Convert(::test::largemessages::SemiBoundedBelievedToBeSmall&& value) {
  using _NaturalUnion = ::test_largemessages::SemiBoundedBelievedToBeSmall;
  switch (value.Which()) {
    case ::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::kBytes:
      return _NaturalUnion::WithBytes(
          ::fidl::HLCPPToNatural(std::move(value.bytes())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}
::test::largemessages::SemiBoundedMaybeLarge NaturalToHLCPPTraits<::test_largemessages::SemiBoundedMaybeLarge>::Convert(::test_largemessages::SemiBoundedMaybeLarge&& value) {
  ::test::largemessages::SemiBoundedMaybeLarge hlcpp;
  switch (value.Which()) {
    case ::test_largemessages::SemiBoundedMaybeLarge::Tag::kBytes:
      hlcpp.set_bytes(::fidl::NaturalToHLCPP(std::move(value.bytes().value())));
      break;
    default:
      break;
  }
  return hlcpp;
}

::test_largemessages::SemiBoundedMaybeLarge HLCPPToNaturalTraits<::test::largemessages::SemiBoundedMaybeLarge>::Convert(::test::largemessages::SemiBoundedMaybeLarge&& value) {
  using _NaturalUnion = ::test_largemessages::SemiBoundedMaybeLarge;
  switch (value.Which()) {
    case ::test::largemessages::SemiBoundedMaybeLarge::Tag::kBytes:
      return _NaturalUnion::WithBytes(
          ::fidl::HLCPPToNatural(std::move(value.bytes())));
    default:
      return _NaturalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{});
  }
}

}  // namespace internal
}  // namespace fidl
