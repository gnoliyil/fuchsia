// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = allow_overflowing
// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include <fidl/test.largemessages/cpp/common_types.h>
#include <fidl/test.largemessages/cpp/markers.h>
#include <lib/fidl/cpp/natural_coding_traits.h>
#include <lib/fidl/cpp/natural_types.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/zx/channel.h>
#include <lib/zx/handle.h>

#endif  // __Fuchsia__

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_largemessages {

class BoundedKnownToBeSmall;

class BoundedMaybeLarge;

class UnboundedMaybeLargeValue;

class Elements;

class UnboundedMaybeLargeResource;

class SemiBoundedBelievedToBeSmall;

class SemiBoundedMaybeLarge;

constexpr uint32_t kSmallStructByteVectorSize = 65504u;

constexpr uint32_t kLargeStructByteVectorSize = 65505u;

constexpr uint32_t kSmallUnionByteVectorSize = 65488u;

constexpr uint32_t kLargeUnionByteVectorSize = 65489u;

constexpr uint32_t kHandleCarryingElementsCount = 64u;

constexpr uint32_t kFirst63ElementsByteVectorSize = 1000u;

constexpr uint32_t kSmallLastElementByteVectorSize = 976u;

constexpr uint32_t kLargeLastElementByteVectorSize = 985u;

extern "C" const fidl_type_t test_largemessages_BoundedKnownToBeSmallTable;

class BoundedKnownToBeSmall {
 private:
  struct Storage_;

 public:
  BoundedKnownToBeSmall(Storage_ storage) noexcept;
  BoundedKnownToBeSmall(::std::vector<uint8_t> bytes) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |BoundedKnownToBeSmall| only if all of its members are default constructible.
  BoundedKnownToBeSmall() = default;
#pragma clang diagnostic pop

  BoundedKnownToBeSmall(BoundedKnownToBeSmall&&) noexcept = default;
  BoundedKnownToBeSmall& operator=(BoundedKnownToBeSmall&&) noexcept = default;
  BoundedKnownToBeSmall(const BoundedKnownToBeSmall& other) noexcept;
  BoundedKnownToBeSmall& operator=(const BoundedKnownToBeSmall& other) noexcept;

  bool operator==(const BoundedKnownToBeSmall& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<::test_largemessages::BoundedKnownToBeSmall, 16>::Equal(this, &other);
  }
  bool operator!=(const BoundedKnownToBeSmall& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<::test_largemessages::BoundedKnownToBeSmall, 16>::Equal(this, &other);
  }

  const ::std::vector<uint8_t>&
  bytes() const {
    return storage_.bytes;
  }

  ::std::vector<uint8_t>& bytes() {
    return storage_.bytes;
  }

  // Setter for bytes.
  //

  BoundedKnownToBeSmall& bytes(::std::vector<uint8_t> value);

  BoundedKnownToBeSmall(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::std::vector<uint8_t> bytes;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_largemessages::BoundedKnownToBeSmall, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_largemessages::BoundedKnownToBeSmall>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::vector<uint8_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty, 65504>>{
      &Storage_::bytes, 0});
  static constexpr auto kPadding = std::make_tuple();
};

extern "C" const fidl_type_t test_largemessages_BoundedMaybeLargeTable;

class BoundedMaybeLarge {
 private:
  struct Storage_;

 public:
  BoundedMaybeLarge(Storage_ storage) noexcept;
  BoundedMaybeLarge(::std::vector<uint8_t> bytes) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |BoundedMaybeLarge| only if all of its members are default constructible.
  BoundedMaybeLarge() = default;
#pragma clang diagnostic pop

  BoundedMaybeLarge(BoundedMaybeLarge&&) noexcept = default;
  BoundedMaybeLarge& operator=(BoundedMaybeLarge&&) noexcept = default;
  BoundedMaybeLarge(const BoundedMaybeLarge& other) noexcept;
  BoundedMaybeLarge& operator=(const BoundedMaybeLarge& other) noexcept;

  bool operator==(const BoundedMaybeLarge& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<::test_largemessages::BoundedMaybeLarge, 16>::Equal(this, &other);
  }
  bool operator!=(const BoundedMaybeLarge& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<::test_largemessages::BoundedMaybeLarge, 16>::Equal(this, &other);
  }

  const ::std::vector<uint8_t>&
  bytes() const {
    return storage_.bytes;
  }

  ::std::vector<uint8_t>& bytes() {
    return storage_.bytes;
  }

  // Setter for bytes.
  //

  BoundedMaybeLarge& bytes(::std::vector<uint8_t> value);

  BoundedMaybeLarge(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::std::vector<uint8_t> bytes;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_largemessages::BoundedMaybeLarge, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_largemessages::BoundedMaybeLarge>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::vector<uint8_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty, 65505>>{
      &Storage_::bytes, 0});
  static constexpr auto kPadding = std::make_tuple();
};

extern "C" const fidl_type_t test_largemessages_SemiBoundedBelievedToBeSmallTable;

class SemiBoundedBelievedToBeSmall {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::std::vector<uint8_t>>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kBytes = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  SemiBoundedBelievedToBeSmall(SemiBoundedBelievedToBeSmall&& other) noexcept
      : SemiBoundedBelievedToBeSmall(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  SemiBoundedBelievedToBeSmall& operator=(SemiBoundedBelievedToBeSmall&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
  SemiBoundedBelievedToBeSmall(const SemiBoundedBelievedToBeSmall& other) noexcept : SemiBoundedBelievedToBeSmall(other.CloneStorage_()) {}
  SemiBoundedBelievedToBeSmall& operator=(const SemiBoundedBelievedToBeSmall& other) noexcept {
    if (this != &other) {
      storage_ = other.CloneStorage_();
    }
    return *this;
  }

  bool operator==(const SemiBoundedBelievedToBeSmall& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const SemiBoundedBelievedToBeSmall& other) const noexcept {
    return *storage_ != *other.storage_;
  }
  constexpr bool IsUnknown() const {
    return Which() == ::test_largemessages::SemiBoundedBelievedToBeSmall::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  constexpr ::test_largemessages::SemiBoundedBelievedToBeSmall::Tag Which() const {
    return SemiBoundedBelievedToBeSmall::IndexToTag(storage_->index()).value();
  }
  static SemiBoundedBelievedToBeSmall WithBytes(::std::vector<uint8_t> val) {
    return SemiBoundedBelievedToBeSmall(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> bytes() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<1, Storage_> bytes() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  // Sets the union to hold the bytes member.
  //

  SemiBoundedBelievedToBeSmall& bytes(::std::vector<uint8_t> value) {
    storage_->emplace<1>(std::move(value));
    return *this;
  }

  SemiBoundedBelievedToBeSmall(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_largemessages::SemiBoundedBelievedToBeSmall>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty, 65488>>());

  explicit SemiBoundedBelievedToBeSmall(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_largemessages::SemiBoundedBelievedToBeSmall::Tag tag) {
    switch (tag) {
      case ::test_largemessages::SemiBoundedBelievedToBeSmall::Tag::kBytes:
        return 1;
      default: {
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_largemessages::SemiBoundedBelievedToBeSmall::Tag> IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_largemessages::SemiBoundedBelievedToBeSmall::Tag::kBytes;
      default:
        return ::test_largemessages::SemiBoundedBelievedToBeSmall::Tag::_do_not_handle_this__write_a_default_case_instead;
    }
  }
};

extern "C" const fidl_type_t test_largemessages_SemiBoundedMaybeLargeTable;

class SemiBoundedMaybeLarge {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::std::vector<uint8_t>>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kBytes = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  SemiBoundedMaybeLarge(SemiBoundedMaybeLarge&& other) noexcept
      : SemiBoundedMaybeLarge(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
    *storage_ = std::move(*other.storage_);
  }
  SemiBoundedMaybeLarge& operator=(SemiBoundedMaybeLarge&& other) noexcept {
    if (this != &other) {
      *storage_ = std::move(*other.storage_);
    }
    return *this;
  }
  SemiBoundedMaybeLarge(const SemiBoundedMaybeLarge& other) noexcept : SemiBoundedMaybeLarge(other.CloneStorage_()) {}
  SemiBoundedMaybeLarge& operator=(const SemiBoundedMaybeLarge& other) noexcept {
    if (this != &other) {
      storage_ = other.CloneStorage_();
    }
    return *this;
  }

  bool operator==(const SemiBoundedMaybeLarge& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const SemiBoundedMaybeLarge& other) const noexcept {
    return *storage_ != *other.storage_;
  }
  constexpr bool IsUnknown() const {
    return Which() == ::test_largemessages::SemiBoundedMaybeLarge::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  constexpr ::test_largemessages::SemiBoundedMaybeLarge::Tag Which() const {
    return SemiBoundedMaybeLarge::IndexToTag(storage_->index()).value();
  }
  static SemiBoundedMaybeLarge WithBytes(::std::vector<uint8_t> val) {
    return SemiBoundedMaybeLarge(std::make_shared<Storage_>(
        std::in_place_index_t<1>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> bytes() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<1, Storage_> bytes() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  // Sets the union to hold the bytes member.
  //

  SemiBoundedMaybeLarge& bytes(::std::vector<uint8_t> value) {
    storage_->emplace<1>(std::move(value));
    return *this;
  }

  SemiBoundedMaybeLarge(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
      : storage_(std::make_shared<Storage_>()) {}

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_largemessages::SemiBoundedMaybeLarge>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty, 65489>>());

  explicit SemiBoundedMaybeLarge(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_largemessages::SemiBoundedMaybeLarge::Tag tag) {
    switch (tag) {
      case ::test_largemessages::SemiBoundedMaybeLarge::Tag::kBytes:
        return 1;
      default: {
        return 0;
      }
    }
  }

  static constexpr std::optional<::test_largemessages::SemiBoundedMaybeLarge::Tag> IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_largemessages::SemiBoundedMaybeLarge::Tag::kBytes;
      default:
        return ::test_largemessages::SemiBoundedMaybeLarge::Tag::_do_not_handle_this__write_a_default_case_instead;
    }
  }
};

extern "C" const fidl_type_t test_largemessages_UnboundedMaybeLargeValueTable;

class UnboundedMaybeLargeValue {
 private:
  struct Storage_;

 public:
  UnboundedMaybeLargeValue(Storage_ storage) noexcept;
  UnboundedMaybeLargeValue(::std::vector<uint8_t> bytes) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |UnboundedMaybeLargeValue| only if all of its members are default constructible.
  UnboundedMaybeLargeValue() = default;
#pragma clang diagnostic pop

  UnboundedMaybeLargeValue(UnboundedMaybeLargeValue&&) noexcept = default;
  UnboundedMaybeLargeValue& operator=(UnboundedMaybeLargeValue&&) noexcept = default;
  UnboundedMaybeLargeValue(const UnboundedMaybeLargeValue& other) noexcept;
  UnboundedMaybeLargeValue& operator=(const UnboundedMaybeLargeValue& other) noexcept;

  bool operator==(const UnboundedMaybeLargeValue& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<::test_largemessages::UnboundedMaybeLargeValue, 16>::Equal(this, &other);
  }
  bool operator!=(const UnboundedMaybeLargeValue& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<::test_largemessages::UnboundedMaybeLargeValue, 16>::Equal(this, &other);
  }

  const ::std::vector<uint8_t>&
  bytes() const {
    return storage_.bytes;
  }

  ::std::vector<uint8_t>& bytes() {
    return storage_.bytes;
  }

  // Setter for bytes.
  //

  UnboundedMaybeLargeValue& bytes(::std::vector<uint8_t> value);

  UnboundedMaybeLargeValue(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::std::vector<uint8_t> bytes;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_largemessages::UnboundedMaybeLargeValue, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_largemessages::UnboundedMaybeLargeValue>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::vector<uint8_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
      &Storage_::bytes, 0});
  static constexpr auto kPadding = std::make_tuple();
};

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_largemessages_ElementsTable;

class Elements {
 private:
  struct Storage_;

 public:
  Elements(Storage_ storage) noexcept;
  Elements(::zx::handle handle, ::std::vector<uint8_t> bytes) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |Elements| only if all of its members are default constructible.
  Elements() = default;
#pragma clang diagnostic pop

  Elements(Elements&&) noexcept = default;
  Elements& operator=(Elements&&) noexcept = default;

  const ::zx::handle&
  handle() const {
    return storage_.handle;
  }

  ::zx::handle& handle() {
    return storage_.handle;
  }

  // Setter for handle.
  //

  Elements& handle(::zx::handle value);

  const ::std::vector<uint8_t>&
  bytes() const {
    return storage_.bytes;
  }

  ::std::vector<uint8_t>& bytes() {
    return storage_.bytes;
  }

  // Setter for bytes.
  //

  Elements& bytes(::std::vector<uint8_t> value);

  Elements(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::zx::handle handle;
    ::std::vector<uint8_t> bytes;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_largemessages::Elements, 24>;
  friend struct ::fidl::internal::MemberVisitor<::test_largemessages::Elements>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::zx::handle, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, true>>{
                                                       &Storage_::handle, 0},
                                                   ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<uint8_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty, 1000>>{&Storage_::bytes, 8});
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
      .offset = 0,
      .mask = 0xffffffff00000000ull,
  });
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_largemessages_UnboundedMaybeLargeResourceTable;

class UnboundedMaybeLargeResource {
 private:
  struct Storage_;

 public:
  UnboundedMaybeLargeResource(Storage_ storage) noexcept;
  UnboundedMaybeLargeResource(::std::array<::test_largemessages::Elements, 64> elements) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |UnboundedMaybeLargeResource| only if all of its members are default constructible.
  UnboundedMaybeLargeResource() = default;
#pragma clang diagnostic pop

  UnboundedMaybeLargeResource(UnboundedMaybeLargeResource&&) noexcept = default;
  UnboundedMaybeLargeResource& operator=(UnboundedMaybeLargeResource&&) noexcept = default;

  const ::std::array<::test_largemessages::Elements, 64>&
  elements() const {
    return storage_.elements;
  }

  ::std::array<::test_largemessages::Elements, 64>& elements() {
    return storage_.elements;
  }

  // Setter for elements.
  //

  UnboundedMaybeLargeResource& elements(::std::array<::test_largemessages::Elements, 64> value);

  UnboundedMaybeLargeResource(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::std::array<::test_largemessages::Elements, 64> elements;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_largemessages::UnboundedMaybeLargeResource, 1536>;
  friend struct ::fidl::internal::MemberVisitor<::test_largemessages::UnboundedMaybeLargeResource>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_largemessages::Elements, 64>, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::elements, 0});
  static constexpr auto kPadding = std::make_tuple();
};

#endif  // __Fuchsia__

inline BoundedKnownToBeSmall::BoundedKnownToBeSmall(Storage_ storage) noexcept : storage_(std::move(storage)) {}
inline BoundedKnownToBeSmall::BoundedKnownToBeSmall(::std::vector<uint8_t> bytes) noexcept
    : storage_({.bytes = std::move(bytes)}) {}
inline BoundedKnownToBeSmall::BoundedKnownToBeSmall(const ::test_largemessages::BoundedKnownToBeSmall& other) noexcept : ::test_largemessages::BoundedKnownToBeSmall(other.CloneStorage_()) {}
inline BoundedKnownToBeSmall& ::test_largemessages::BoundedKnownToBeSmall::operator=(const ::test_largemessages::BoundedKnownToBeSmall& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

inline BoundedKnownToBeSmall::BoundedKnownToBeSmall(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : BoundedKnownToBeSmall(Storage_{
                                                                                                                      .bytes = {},
                                                                                                                  }) {}
inline BoundedKnownToBeSmall& BoundedKnownToBeSmall::bytes(::std::vector<uint8_t> value) {
  storage_.bytes = std::move(value);
  return *this;
}

inline BoundedMaybeLarge::BoundedMaybeLarge(Storage_ storage) noexcept : storage_(std::move(storage)) {}
inline BoundedMaybeLarge::BoundedMaybeLarge(::std::vector<uint8_t> bytes) noexcept
    : storage_({.bytes = std::move(bytes)}) {}
inline BoundedMaybeLarge::BoundedMaybeLarge(const ::test_largemessages::BoundedMaybeLarge& other) noexcept : ::test_largemessages::BoundedMaybeLarge(other.CloneStorage_()) {}
inline BoundedMaybeLarge& ::test_largemessages::BoundedMaybeLarge::operator=(const ::test_largemessages::BoundedMaybeLarge& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

inline BoundedMaybeLarge::BoundedMaybeLarge(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : BoundedMaybeLarge(Storage_{
                                                                                                              .bytes = {},
                                                                                                          }) {}
inline BoundedMaybeLarge& BoundedMaybeLarge::bytes(::std::vector<uint8_t> value) {
  storage_.bytes = std::move(value);
  return *this;
}

inline UnboundedMaybeLargeValue::UnboundedMaybeLargeValue(Storage_ storage) noexcept : storage_(std::move(storage)) {}
inline UnboundedMaybeLargeValue::UnboundedMaybeLargeValue(::std::vector<uint8_t> bytes) noexcept
    : storage_({.bytes = std::move(bytes)}) {}
inline UnboundedMaybeLargeValue::UnboundedMaybeLargeValue(const ::test_largemessages::UnboundedMaybeLargeValue& other) noexcept : ::test_largemessages::UnboundedMaybeLargeValue(other.CloneStorage_()) {}
inline UnboundedMaybeLargeValue& ::test_largemessages::UnboundedMaybeLargeValue::operator=(const ::test_largemessages::UnboundedMaybeLargeValue& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

inline UnboundedMaybeLargeValue::UnboundedMaybeLargeValue(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : UnboundedMaybeLargeValue(Storage_{
                                                                                                                            .bytes = {},
                                                                                                                        }) {}
inline UnboundedMaybeLargeValue& UnboundedMaybeLargeValue::bytes(::std::vector<uint8_t> value) {
  storage_.bytes = std::move(value);
  return *this;
}

#ifdef __Fuchsia__

inline Elements::Elements(Storage_ storage) noexcept : storage_(std::move(storage)) {}
inline Elements::Elements(::zx::handle handle, ::std::vector<uint8_t> bytes) noexcept
    : storage_({.handle = std::move(handle),
                .bytes = std::move(bytes)}) {}

inline Elements::Elements(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Elements(Storage_{
                                                                                            .handle = {},
                                                                                            .bytes = {},
                                                                                        }) {}
inline Elements& Elements::handle(::zx::handle value) {
  storage_.handle = std::move(value);
  return *this;
}
inline Elements& Elements::bytes(::std::vector<uint8_t> value) {
  storage_.bytes = std::move(value);
  return *this;
}

#endif  // __Fuchsia__

#ifdef __Fuchsia__

inline UnboundedMaybeLargeResource::UnboundedMaybeLargeResource(Storage_ storage) noexcept : storage_(std::move(storage)) {}
inline UnboundedMaybeLargeResource::UnboundedMaybeLargeResource(::std::array<::test_largemessages::Elements, 64> elements) noexcept
    : storage_({.elements = std::move(elements)}) {}

inline UnboundedMaybeLargeResource::UnboundedMaybeLargeResource(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : UnboundedMaybeLargeResource(Storage_{
                                                                                                                                  .elements = ::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_largemessages::Elements, 64>>::Make(),
                                                                                                                              }) {}
inline UnboundedMaybeLargeResource& UnboundedMaybeLargeResource::elements(::std::array<::test_largemessages::Elements, 64> value) {
  storage_.elements = std::move(value);
  return *this;
}

#endif  // __Fuchsia__

}  // namespace test_largemessages
namespace fidl {

extern "C" const fidl_type_t test_largemessages_BoundedKnownToBeSmallTable;

template <>
struct IsFidlType<::test_largemessages::BoundedKnownToBeSmall> : public std::true_type {};

template <>
struct TypeTraits<::test_largemessages::BoundedKnownToBeSmall> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 65504;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_largemessages::BoundedKnownToBeSmall> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_largemessages::BoundedKnownToBeSmall, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_largemessages::BoundedKnownToBeSmall, 16> {};

extern "C" const fidl_type_t test_largemessages_BoundedMaybeLargeTable;

template <>
struct IsFidlType<::test_largemessages::BoundedMaybeLarge> : public std::true_type {};

template <>
struct TypeTraits<::test_largemessages::BoundedMaybeLarge> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 65512;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_largemessages::BoundedMaybeLarge> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_largemessages::BoundedMaybeLarge, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_largemessages::BoundedMaybeLarge, 16> {};

extern "C" const fidl_type_t test_largemessages_UnboundedMaybeLargeValueTable;

template <>
struct IsFidlType<::test_largemessages::UnboundedMaybeLargeValue> : public std::true_type {};

template <>
struct TypeTraits<::test_largemessages::UnboundedMaybeLargeValue> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_largemessages::UnboundedMaybeLargeValue> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_largemessages::UnboundedMaybeLargeValue, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_largemessages::UnboundedMaybeLargeValue, 16> {};

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_largemessages_ElementsTable;

template <>
struct IsResource<::test_largemessages::Elements> : public std::true_type {};
template <>
struct IsFidlType<::test_largemessages::Elements> : public std::true_type {};

template <>
struct TypeTraits<::test_largemessages::Elements> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 24;
  static constexpr uint32_t kMaxOutOfLine = 1000;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_largemessages::Elements> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_largemessages::Elements, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_largemessages::Elements, 24> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_largemessages_UnboundedMaybeLargeResourceTable;

template <>
struct IsResource<::test_largemessages::UnboundedMaybeLargeResource> : public std::true_type {};
template <>
struct IsFidlType<::test_largemessages::UnboundedMaybeLargeResource> : public std::true_type {};

template <>
struct TypeTraits<::test_largemessages::UnboundedMaybeLargeResource> {
  static constexpr uint32_t kMaxNumHandles = 64;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 1536;
  static constexpr uint32_t kMaxOutOfLine = 64000;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_largemessages::UnboundedMaybeLargeResource> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_largemessages::UnboundedMaybeLargeResource, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_largemessages::UnboundedMaybeLargeResource, 1536> {};

#endif  // __Fuchsia__

extern "C" const fidl_type_t test_largemessages_SemiBoundedBelievedToBeSmallTable;

template <>
struct IsFidlType<::test_largemessages::SemiBoundedBelievedToBeSmall> : public std::true_type {};

template <>
struct TypeTraits<::test_largemessages::SemiBoundedBelievedToBeSmall> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 65504;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_largemessages::SemiBoundedBelievedToBeSmall> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_largemessages::SemiBoundedBelievedToBeSmall, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_largemessages::SemiBoundedBelievedToBeSmall> {};

extern "C" const fidl_type_t test_largemessages_SemiBoundedMaybeLargeTable;

template <>
struct IsFidlType<::test_largemessages::SemiBoundedMaybeLarge> : public std::true_type {};

template <>
struct TypeTraits<::test_largemessages::SemiBoundedMaybeLarge> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 65512;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_largemessages::SemiBoundedMaybeLarge> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_largemessages::SemiBoundedMaybeLarge, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_largemessages::SemiBoundedMaybeLarge> {};

#pragma clang diagnostic pop

}  // namespace fidl
