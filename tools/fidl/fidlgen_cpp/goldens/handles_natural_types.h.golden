// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include <fidl/test.handles/cpp/common_types.h>
#include <fidl/test.handles/cpp/markers.h>
#include <lib/fidl/cpp/natural_coding_traits.h>
#include <lib/fidl/cpp/natural_types.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/fidl_driver/cpp/natural_types.h>
#include <lib/zx/bti.h>
#include <lib/zx/channel.h>
#include <lib/zx/clock.h>
#include <lib/zx/debuglog.h>
#include <lib/zx/event.h>
#include <lib/zx/eventpair.h>
#include <lib/zx/exception.h>
#include <lib/zx/fifo.h>
#include <lib/zx/guest.h>
#include <lib/zx/handle.h>
#include <lib/zx/interrupt.h>
#include <lib/zx/iommu.h>
#include <lib/zx/job.h>
#include <lib/zx/msi.h>
#include <lib/zx/pager.h>
#include <lib/zx/pmt.h>
#include <lib/zx/port.h>
#include <lib/zx/process.h>
#include <lib/zx/profile.h>
#include <lib/zx/resource.h>
#include <lib/zx/socket.h>
#include <lib/zx/stream.h>
#include <lib/zx/suspend_token.h>
#include <lib/zx/thread.h>
#include <lib/zx/timer.h>
#include <lib/zx/vcpu.h>
#include <lib/zx/vmar.h>
#include <lib/zx/vmo.h>

#endif  // __Fuchsia__

#include <fidl/fdf/cpp/natural_types.h>
namespace test_handles {

class Handles;

class FdfHandles;

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_handles_HandlesTable;

class Handles {
 private:
  struct Storage_;

 public:
  Handles(Storage_ storage) noexcept;
  Handles(::zx::handle plain_handle, ::zx::bti bti_handle, ::zx::channel channel_handle, ::zx::clock clock_handle, ::zx::debuglog debuglog_handle, ::zx::event event_handle, ::zx::eventpair eventpair_handle, ::zx::exception exception_handle, ::zx::fifo fifo_handle, ::zx::guest guest_handle, ::zx::interrupt interrupt_handle, ::zx::iommu iommu_handle, ::zx::job job_handle, ::zx::msi msi_handle, ::zx::pager pager_handle, ::zx::pmt pmt_handle, ::zx::port port_handle, ::zx::process process_handle, ::zx::profile profile_handle, ::zx::resource resource_handle, ::zx::socket socket_handle, ::zx::stream stream_handle, ::zx::suspend_token suspendtoken_handle, ::zx::thread thread_handle, ::zx::timer timer_handle, ::zx::vcpu vcpu_handle, ::zx::vmar vmar_handle, ::zx::vmo vmo_handle, ::zx::vmo rights_handle, ::zx::handle aliased_plain_handle_field, ::zx::vmo aliased_subtype_handle_field, ::zx::vmo aliased_rights_handle_field, ::fidl::ClientEnd<::test_handles::SomeProtocol> some_protocol, ::fidl::ServerEnd<::test_handles::SomeProtocol> request_some_protocol) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |Handles| only if all of its members are default constructible.
  Handles() = default;
#pragma clang diagnostic pop

  Handles(Handles&&) noexcept = default;
  Handles& operator=(Handles&&) noexcept = default;

  const ::zx::handle&
  plain_handle() const {
    return storage_.plain_handle;
  }

  ::zx::handle& plain_handle() {
    return storage_.plain_handle;
  }

  // Setter for plain_handle.
  //

  Handles& plain_handle(::zx::handle value);

  const ::zx::bti&
  bti_handle() const {
    return storage_.bti_handle;
  }

  ::zx::bti& bti_handle() {
    return storage_.bti_handle;
  }

  // Setter for bti_handle.
  //

  Handles& bti_handle(::zx::bti value);

  const ::zx::channel&
  channel_handle() const {
    return storage_.channel_handle;
  }

  ::zx::channel& channel_handle() {
    return storage_.channel_handle;
  }

  // Setter for channel_handle.
  //

  Handles& channel_handle(::zx::channel value);

  const ::zx::clock&
  clock_handle() const {
    return storage_.clock_handle;
  }

  ::zx::clock& clock_handle() {
    return storage_.clock_handle;
  }

  // Setter for clock_handle.
  //

  Handles& clock_handle(::zx::clock value);

  const ::zx::debuglog&
  debuglog_handle() const {
    return storage_.debuglog_handle;
  }

  ::zx::debuglog& debuglog_handle() {
    return storage_.debuglog_handle;
  }

  // Setter for debuglog_handle.
  //

  Handles& debuglog_handle(::zx::debuglog value);

  const ::zx::event&
  event_handle() const {
    return storage_.event_handle;
  }

  ::zx::event& event_handle() {
    return storage_.event_handle;
  }

  // Setter for event_handle.
  //

  Handles& event_handle(::zx::event value);

  const ::zx::eventpair&
  eventpair_handle() const {
    return storage_.eventpair_handle;
  }

  ::zx::eventpair& eventpair_handle() {
    return storage_.eventpair_handle;
  }

  // Setter for eventpair_handle.
  //

  Handles& eventpair_handle(::zx::eventpair value);

  const ::zx::exception&
  exception_handle() const {
    return storage_.exception_handle;
  }

  ::zx::exception& exception_handle() {
    return storage_.exception_handle;
  }

  // Setter for exception_handle.
  //

  Handles& exception_handle(::zx::exception value);

  const ::zx::fifo&
  fifo_handle() const {
    return storage_.fifo_handle;
  }

  ::zx::fifo& fifo_handle() {
    return storage_.fifo_handle;
  }

  // Setter for fifo_handle.
  //

  Handles& fifo_handle(::zx::fifo value);

  const ::zx::guest&
  guest_handle() const {
    return storage_.guest_handle;
  }

  ::zx::guest& guest_handle() {
    return storage_.guest_handle;
  }

  // Setter for guest_handle.
  //

  Handles& guest_handle(::zx::guest value);

  const ::zx::interrupt&
  interrupt_handle() const {
    return storage_.interrupt_handle;
  }

  ::zx::interrupt& interrupt_handle() {
    return storage_.interrupt_handle;
  }

  // Setter for interrupt_handle.
  //

  Handles& interrupt_handle(::zx::interrupt value);

  const ::zx::iommu&
  iommu_handle() const {
    return storage_.iommu_handle;
  }

  ::zx::iommu& iommu_handle() {
    return storage_.iommu_handle;
  }

  // Setter for iommu_handle.
  //

  Handles& iommu_handle(::zx::iommu value);

  const ::zx::job&
  job_handle() const {
    return storage_.job_handle;
  }

  ::zx::job& job_handle() {
    return storage_.job_handle;
  }

  // Setter for job_handle.
  //

  Handles& job_handle(::zx::job value);

  const ::zx::msi&
  msi_handle() const {
    return storage_.msi_handle;
  }

  ::zx::msi& msi_handle() {
    return storage_.msi_handle;
  }

  // Setter for msi_handle.
  //

  Handles& msi_handle(::zx::msi value);

  const ::zx::pager&
  pager_handle() const {
    return storage_.pager_handle;
  }

  ::zx::pager& pager_handle() {
    return storage_.pager_handle;
  }

  // Setter for pager_handle.
  //

  Handles& pager_handle(::zx::pager value);

  const ::zx::pmt&
  pmt_handle() const {
    return storage_.pmt_handle;
  }

  ::zx::pmt& pmt_handle() {
    return storage_.pmt_handle;
  }

  // Setter for pmt_handle.
  //

  Handles& pmt_handle(::zx::pmt value);

  const ::zx::port&
  port_handle() const {
    return storage_.port_handle;
  }

  ::zx::port& port_handle() {
    return storage_.port_handle;
  }

  // Setter for port_handle.
  //

  Handles& port_handle(::zx::port value);

  const ::zx::process&
  process_handle() const {
    return storage_.process_handle;
  }

  ::zx::process& process_handle() {
    return storage_.process_handle;
  }

  // Setter for process_handle.
  //

  Handles& process_handle(::zx::process value);

  const ::zx::profile&
  profile_handle() const {
    return storage_.profile_handle;
  }

  ::zx::profile& profile_handle() {
    return storage_.profile_handle;
  }

  // Setter for profile_handle.
  //

  Handles& profile_handle(::zx::profile value);

  const ::zx::resource&
  resource_handle() const {
    return storage_.resource_handle;
  }

  ::zx::resource& resource_handle() {
    return storage_.resource_handle;
  }

  // Setter for resource_handle.
  //

  Handles& resource_handle(::zx::resource value);

  const ::zx::socket&
  socket_handle() const {
    return storage_.socket_handle;
  }

  ::zx::socket& socket_handle() {
    return storage_.socket_handle;
  }

  // Setter for socket_handle.
  //

  Handles& socket_handle(::zx::socket value);

  const ::zx::stream&
  stream_handle() const {
    return storage_.stream_handle;
  }

  ::zx::stream& stream_handle() {
    return storage_.stream_handle;
  }

  // Setter for stream_handle.
  //

  Handles& stream_handle(::zx::stream value);

  const ::zx::suspend_token&
  suspendtoken_handle() const {
    return storage_.suspendtoken_handle;
  }

  ::zx::suspend_token& suspendtoken_handle() {
    return storage_.suspendtoken_handle;
  }

  // Setter for suspendtoken_handle.
  //

  Handles& suspendtoken_handle(::zx::suspend_token value);

  const ::zx::thread&
  thread_handle() const {
    return storage_.thread_handle;
  }

  ::zx::thread& thread_handle() {
    return storage_.thread_handle;
  }

  // Setter for thread_handle.
  //

  Handles& thread_handle(::zx::thread value);

  const ::zx::timer&
  timer_handle() const {
    return storage_.timer_handle;
  }

  ::zx::timer& timer_handle() {
    return storage_.timer_handle;
  }

  // Setter for timer_handle.
  //

  Handles& timer_handle(::zx::timer value);

  const ::zx::vcpu&
  vcpu_handle() const {
    return storage_.vcpu_handle;
  }

  ::zx::vcpu& vcpu_handle() {
    return storage_.vcpu_handle;
  }

  // Setter for vcpu_handle.
  //

  Handles& vcpu_handle(::zx::vcpu value);

  const ::zx::vmar&
  vmar_handle() const {
    return storage_.vmar_handle;
  }

  ::zx::vmar& vmar_handle() {
    return storage_.vmar_handle;
  }

  // Setter for vmar_handle.
  //

  Handles& vmar_handle(::zx::vmar value);

  const ::zx::vmo&
  vmo_handle() const {
    return storage_.vmo_handle;
  }

  ::zx::vmo& vmo_handle() {
    return storage_.vmo_handle;
  }

  // Setter for vmo_handle.
  //

  Handles& vmo_handle(::zx::vmo value);

  const ::zx::vmo&
  rights_handle() const {
    return storage_.rights_handle;
  }

  ::zx::vmo& rights_handle() {
    return storage_.rights_handle;
  }

  // Setter for rights_handle.
  //

  Handles& rights_handle(::zx::vmo value);

  const ::zx::handle&
  aliased_plain_handle_field() const {
    return storage_.aliased_plain_handle_field;
  }

  ::zx::handle& aliased_plain_handle_field() {
    return storage_.aliased_plain_handle_field;
  }

  // Setter for aliased_plain_handle_field.
  //

  Handles& aliased_plain_handle_field(::zx::handle value);

  const ::zx::vmo&
  aliased_subtype_handle_field() const {
    return storage_.aliased_subtype_handle_field;
  }

  ::zx::vmo& aliased_subtype_handle_field() {
    return storage_.aliased_subtype_handle_field;
  }

  // Setter for aliased_subtype_handle_field.
  //

  Handles& aliased_subtype_handle_field(::zx::vmo value);

  const ::zx::vmo&
  aliased_rights_handle_field() const {
    return storage_.aliased_rights_handle_field;
  }

  ::zx::vmo& aliased_rights_handle_field() {
    return storage_.aliased_rights_handle_field;
  }

  // Setter for aliased_rights_handle_field.
  //

  Handles& aliased_rights_handle_field(::zx::vmo value);

  const ::fidl::ClientEnd<::test_handles::SomeProtocol>&
  some_protocol() const {
    return storage_.some_protocol;
  }

  ::fidl::ClientEnd<::test_handles::SomeProtocol>& some_protocol() {
    return storage_.some_protocol;
  }

  // Setter for some_protocol.
  //

  Handles& some_protocol(::fidl::ClientEnd<::test_handles::SomeProtocol> value);

  const ::fidl::ServerEnd<::test_handles::SomeProtocol>&
  request_some_protocol() const {
    return storage_.request_some_protocol;
  }

  ::fidl::ServerEnd<::test_handles::SomeProtocol>& request_some_protocol() {
    return storage_.request_some_protocol;
  }

  // Setter for request_some_protocol.
  //

  Handles& request_some_protocol(::fidl::ServerEnd<::test_handles::SomeProtocol> value);

  Handles(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::zx::handle plain_handle;
    ::zx::bti bti_handle;
    ::zx::channel channel_handle;
    ::zx::clock clock_handle;
    ::zx::debuglog debuglog_handle;
    ::zx::event event_handle;
    ::zx::eventpair eventpair_handle;
    ::zx::exception exception_handle;
    ::zx::fifo fifo_handle;
    ::zx::guest guest_handle;
    ::zx::interrupt interrupt_handle;
    ::zx::iommu iommu_handle;
    ::zx::job job_handle;
    ::zx::msi msi_handle;
    ::zx::pager pager_handle;
    ::zx::pmt pmt_handle;
    ::zx::port port_handle;
    ::zx::process process_handle;
    ::zx::profile profile_handle;
    ::zx::resource resource_handle;
    ::zx::socket socket_handle;
    ::zx::stream stream_handle;
    ::zx::suspend_token suspendtoken_handle;
    ::zx::thread thread_handle;
    ::zx::timer timer_handle;
    ::zx::vcpu vcpu_handle;
    ::zx::vmar vmar_handle;
    ::zx::vmo vmo_handle;
    ::zx::vmo rights_handle;
    ::zx::handle aliased_plain_handle_field;
    ::zx::vmo aliased_subtype_handle_field;
    ::zx::vmo aliased_rights_handle_field;
    ::fidl::ClientEnd<::test_handles::SomeProtocol> some_protocol;
    ::fidl::ServerEnd<::test_handles::SomeProtocol> request_some_protocol;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_handles::Handles, 136>;
  friend struct ::fidl::internal::MemberVisitor<::test_handles::Handles>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::zx::handle, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>>{
                                                       &Storage_::plain_handle, 0},
                                                   ::fidl::internal::NaturalStructMember<Storage_, ::zx::bti, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_BTI, 0x80000000, false>>{&Storage_::bti_handle, 4}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::channel, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, 0x80000000, false>>{&Storage_::channel_handle, 8}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::clock, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CLOCK, 0x80000000, false>>{&Storage_::clock_handle, 12}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::debuglog, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_DEBUGLOG, 0x80000000, false>>{&Storage_::debuglog_handle, 16}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::event, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_EVENT, 0x80000000, false>>{&Storage_::event_handle, 20}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::eventpair, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_EVENTPAIR, 0x80000000, false>>{&Storage_::eventpair_handle, 24}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::exception, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_EXCEPTION, 0x80000000, false>>{&Storage_::exception_handle, 28}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::fifo, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_FIFO, 0x80000000, false>>{&Storage_::fifo_handle, 32}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::guest, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_GUEST, 0x80000000, false>>{&Storage_::guest_handle, 36}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::interrupt, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_INTERRUPT, 0x80000000, false>>{&Storage_::interrupt_handle, 40}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::iommu, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_IOMMU, 0x80000000, false>>{&Storage_::iommu_handle, 44}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::job, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_JOB, 0x80000000, false>>{&Storage_::job_handle, 48}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::msi, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_MSI, 0x80000000, false>>{&Storage_::msi_handle, 52}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::pager, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_PAGER, 0x80000000, false>>{&Storage_::pager_handle, 56}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::pmt, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_PMT, 0x80000000, false>>{&Storage_::pmt_handle, 60}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::port, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_PORT, 0x80000000, false>>{&Storage_::port_handle, 64}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::process, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_PROCESS, 0x80000000, false>>{&Storage_::process_handle, 68}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::profile, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_PROFILE, 0x80000000, false>>{&Storage_::profile_handle, 72}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::resource, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_RESOURCE, 0x80000000, false>>{&Storage_::resource_handle, 76}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::socket, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x80000000, false>>{&Storage_::socket_handle, 80}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::stream, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_STREAM, 0x80000000, false>>{&Storage_::stream_handle, 84}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::suspend_token, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_SUSPEND_TOKEN, 0x80000000, false>>{&Storage_::suspendtoken_handle, 88}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::thread, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_THREAD, 0x80000000, false>>{&Storage_::thread_handle, 92}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::timer, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_TIMER, 0x80000000, false>>{&Storage_::timer_handle, 96}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::vcpu, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VCPU, 0x80000000, false>>{&Storage_::vcpu_handle, 100}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmar, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMAR, 0x80000000, false>>{&Storage_::vmar_handle, 104}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmo, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>>{&Storage_::vmo_handle, 108}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmo, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x5, false>>{&Storage_::rights_handle, 112}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::handle, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>>{&Storage_::aliased_plain_handle_field, 116}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmo, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>>{&Storage_::aliased_subtype_handle_field, 120}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmo, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x1, false>>{&Storage_::aliased_rights_handle_field, 124}, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::ClientEnd<::test_handles::SomeProtocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{&Storage_::some_protocol, 128}, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::ServerEnd<::test_handles::SomeProtocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{&Storage_::request_some_protocol, 132});
  static constexpr auto kPadding = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_handles_FdfHandlesTable;

class FdfHandles {
 private:
  struct Storage_;

 public:
  FdfHandles(Storage_ storage) noexcept;
  FdfHandles(::fdf::Channel fdf_channel_handle, ::fdf::ClientEnd<::test_handles::DriverProtocol> client_end_driver, ::fdf::ServerEnd<::test_handles::DriverProtocol> server_end_driver) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |FdfHandles| only if all of its members are default constructible.
  FdfHandles() = default;
#pragma clang diagnostic pop

  FdfHandles(FdfHandles&&) noexcept = default;
  FdfHandles& operator=(FdfHandles&&) noexcept = default;

  const ::fdf::Channel&
  fdf_channel_handle() const {
    return storage_.fdf_channel_handle;
  }

  ::fdf::Channel& fdf_channel_handle() {
    return storage_.fdf_channel_handle;
  }

  // Setter for fdf_channel_handle.
  //

  FdfHandles& fdf_channel_handle(::fdf::Channel value);

  const ::fdf::ClientEnd<::test_handles::DriverProtocol>&
  client_end_driver() const {
    return storage_.client_end_driver;
  }

  ::fdf::ClientEnd<::test_handles::DriverProtocol>& client_end_driver() {
    return storage_.client_end_driver;
  }

  // Setter for client_end_driver.
  //

  FdfHandles& client_end_driver(::fdf::ClientEnd<::test_handles::DriverProtocol> value);

  const ::fdf::ServerEnd<::test_handles::DriverProtocol>&
  server_end_driver() const {
    return storage_.server_end_driver;
  }

  ::fdf::ServerEnd<::test_handles::DriverProtocol>& server_end_driver() {
    return storage_.server_end_driver;
  }

  // Setter for server_end_driver.
  //

  FdfHandles& server_end_driver(::fdf::ServerEnd<::test_handles::DriverProtocol> value);

  FdfHandles(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::fdf::Channel fdf_channel_handle;
    ::fdf::ClientEnd<::test_handles::DriverProtocol> client_end_driver;
    ::fdf::ServerEnd<::test_handles::DriverProtocol> server_end_driver;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_handles::FdfHandles, 12>;
  friend struct ::fidl::internal::MemberVisitor<::test_handles::FdfHandles>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::fdf::Channel, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, 0x80000000, false>>{
                                                       &Storage_::fdf_channel_handle, 0},
                                                   ::fidl::internal::NaturalStructMember<Storage_, ::fdf::ClientEnd<::test_handles::DriverProtocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{&Storage_::client_end_driver, 4}, ::fidl::internal::NaturalStructMember<Storage_, ::fdf::ServerEnd<::test_handles::DriverProtocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{&Storage_::server_end_driver, 8});
  static constexpr auto kPadding = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

inline Handles::Handles(Storage_ storage) noexcept : storage_(std::move(storage)) {}
inline Handles::Handles(::zx::handle plain_handle, ::zx::bti bti_handle, ::zx::channel channel_handle, ::zx::clock clock_handle, ::zx::debuglog debuglog_handle, ::zx::event event_handle, ::zx::eventpair eventpair_handle, ::zx::exception exception_handle, ::zx::fifo fifo_handle, ::zx::guest guest_handle, ::zx::interrupt interrupt_handle, ::zx::iommu iommu_handle, ::zx::job job_handle, ::zx::msi msi_handle, ::zx::pager pager_handle, ::zx::pmt pmt_handle, ::zx::port port_handle, ::zx::process process_handle, ::zx::profile profile_handle, ::zx::resource resource_handle, ::zx::socket socket_handle, ::zx::stream stream_handle, ::zx::suspend_token suspendtoken_handle, ::zx::thread thread_handle, ::zx::timer timer_handle, ::zx::vcpu vcpu_handle, ::zx::vmar vmar_handle, ::zx::vmo vmo_handle, ::zx::vmo rights_handle, ::zx::handle aliased_plain_handle_field, ::zx::vmo aliased_subtype_handle_field, ::zx::vmo aliased_rights_handle_field, ::fidl::ClientEnd<::test_handles::SomeProtocol> some_protocol, ::fidl::ServerEnd<::test_handles::SomeProtocol> request_some_protocol) noexcept
    : storage_({.plain_handle = std::move(plain_handle),
                .bti_handle = std::move(bti_handle),
                .channel_handle = std::move(channel_handle),
                .clock_handle = std::move(clock_handle),
                .debuglog_handle = std::move(debuglog_handle),
                .event_handle = std::move(event_handle),
                .eventpair_handle = std::move(eventpair_handle),
                .exception_handle = std::move(exception_handle),
                .fifo_handle = std::move(fifo_handle),
                .guest_handle = std::move(guest_handle),
                .interrupt_handle = std::move(interrupt_handle),
                .iommu_handle = std::move(iommu_handle),
                .job_handle = std::move(job_handle),
                .msi_handle = std::move(msi_handle),
                .pager_handle = std::move(pager_handle),
                .pmt_handle = std::move(pmt_handle),
                .port_handle = std::move(port_handle),
                .process_handle = std::move(process_handle),
                .profile_handle = std::move(profile_handle),
                .resource_handle = std::move(resource_handle),
                .socket_handle = std::move(socket_handle),
                .stream_handle = std::move(stream_handle),
                .suspendtoken_handle = std::move(suspendtoken_handle),
                .thread_handle = std::move(thread_handle),
                .timer_handle = std::move(timer_handle),
                .vcpu_handle = std::move(vcpu_handle),
                .vmar_handle = std::move(vmar_handle),
                .vmo_handle = std::move(vmo_handle),
                .rights_handle = std::move(rights_handle),
                .aliased_plain_handle_field = std::move(aliased_plain_handle_field),
                .aliased_subtype_handle_field = std::move(aliased_subtype_handle_field),
                .aliased_rights_handle_field = std::move(aliased_rights_handle_field),
                .some_protocol = std::move(some_protocol),
                .request_some_protocol = std::move(request_some_protocol)}) {}

inline Handles::Handles(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Handles(Storage_{
                                                                                          .plain_handle = {},
                                                                                          .bti_handle = {},
                                                                                          .channel_handle = {},
                                                                                          .clock_handle = {},
                                                                                          .debuglog_handle = {},
                                                                                          .event_handle = {},
                                                                                          .eventpair_handle = {},
                                                                                          .exception_handle = {},
                                                                                          .fifo_handle = {},
                                                                                          .guest_handle = {},
                                                                                          .interrupt_handle = {},
                                                                                          .iommu_handle = {},
                                                                                          .job_handle = {},
                                                                                          .msi_handle = {},
                                                                                          .pager_handle = {},
                                                                                          .pmt_handle = {},
                                                                                          .port_handle = {},
                                                                                          .process_handle = {},
                                                                                          .profile_handle = {},
                                                                                          .resource_handle = {},
                                                                                          .socket_handle = {},
                                                                                          .stream_handle = {},
                                                                                          .suspendtoken_handle = {},
                                                                                          .thread_handle = {},
                                                                                          .timer_handle = {},
                                                                                          .vcpu_handle = {},
                                                                                          .vmar_handle = {},
                                                                                          .vmo_handle = {},
                                                                                          .rights_handle = {},
                                                                                          .aliased_plain_handle_field = {},
                                                                                          .aliased_subtype_handle_field = {},
                                                                                          .aliased_rights_handle_field = {},
                                                                                          .some_protocol = {},
                                                                                          .request_some_protocol = {},
                                                                                      }) {}
inline Handles& Handles::plain_handle(::zx::handle value) {
  storage_.plain_handle = std::move(value);
  return *this;
}
inline Handles& Handles::bti_handle(::zx::bti value) {
  storage_.bti_handle = std::move(value);
  return *this;
}
inline Handles& Handles::channel_handle(::zx::channel value) {
  storage_.channel_handle = std::move(value);
  return *this;
}
inline Handles& Handles::clock_handle(::zx::clock value) {
  storage_.clock_handle = std::move(value);
  return *this;
}
inline Handles& Handles::debuglog_handle(::zx::debuglog value) {
  storage_.debuglog_handle = std::move(value);
  return *this;
}
inline Handles& Handles::event_handle(::zx::event value) {
  storage_.event_handle = std::move(value);
  return *this;
}
inline Handles& Handles::eventpair_handle(::zx::eventpair value) {
  storage_.eventpair_handle = std::move(value);
  return *this;
}
inline Handles& Handles::exception_handle(::zx::exception value) {
  storage_.exception_handle = std::move(value);
  return *this;
}
inline Handles& Handles::fifo_handle(::zx::fifo value) {
  storage_.fifo_handle = std::move(value);
  return *this;
}
inline Handles& Handles::guest_handle(::zx::guest value) {
  storage_.guest_handle = std::move(value);
  return *this;
}
inline Handles& Handles::interrupt_handle(::zx::interrupt value) {
  storage_.interrupt_handle = std::move(value);
  return *this;
}
inline Handles& Handles::iommu_handle(::zx::iommu value) {
  storage_.iommu_handle = std::move(value);
  return *this;
}
inline Handles& Handles::job_handle(::zx::job value) {
  storage_.job_handle = std::move(value);
  return *this;
}
inline Handles& Handles::msi_handle(::zx::msi value) {
  storage_.msi_handle = std::move(value);
  return *this;
}
inline Handles& Handles::pager_handle(::zx::pager value) {
  storage_.pager_handle = std::move(value);
  return *this;
}
inline Handles& Handles::pmt_handle(::zx::pmt value) {
  storage_.pmt_handle = std::move(value);
  return *this;
}
inline Handles& Handles::port_handle(::zx::port value) {
  storage_.port_handle = std::move(value);
  return *this;
}
inline Handles& Handles::process_handle(::zx::process value) {
  storage_.process_handle = std::move(value);
  return *this;
}
inline Handles& Handles::profile_handle(::zx::profile value) {
  storage_.profile_handle = std::move(value);
  return *this;
}
inline Handles& Handles::resource_handle(::zx::resource value) {
  storage_.resource_handle = std::move(value);
  return *this;
}
inline Handles& Handles::socket_handle(::zx::socket value) {
  storage_.socket_handle = std::move(value);
  return *this;
}
inline Handles& Handles::stream_handle(::zx::stream value) {
  storage_.stream_handle = std::move(value);
  return *this;
}
inline Handles& Handles::suspendtoken_handle(::zx::suspend_token value) {
  storage_.suspendtoken_handle = std::move(value);
  return *this;
}
inline Handles& Handles::thread_handle(::zx::thread value) {
  storage_.thread_handle = std::move(value);
  return *this;
}
inline Handles& Handles::timer_handle(::zx::timer value) {
  storage_.timer_handle = std::move(value);
  return *this;
}
inline Handles& Handles::vcpu_handle(::zx::vcpu value) {
  storage_.vcpu_handle = std::move(value);
  return *this;
}
inline Handles& Handles::vmar_handle(::zx::vmar value) {
  storage_.vmar_handle = std::move(value);
  return *this;
}
inline Handles& Handles::vmo_handle(::zx::vmo value) {
  storage_.vmo_handle = std::move(value);
  return *this;
}
inline Handles& Handles::rights_handle(::zx::vmo value) {
  storage_.rights_handle = std::move(value);
  return *this;
}
inline Handles& Handles::aliased_plain_handle_field(::zx::handle value) {
  storage_.aliased_plain_handle_field = std::move(value);
  return *this;
}
inline Handles& Handles::aliased_subtype_handle_field(::zx::vmo value) {
  storage_.aliased_subtype_handle_field = std::move(value);
  return *this;
}
inline Handles& Handles::aliased_rights_handle_field(::zx::vmo value) {
  storage_.aliased_rights_handle_field = std::move(value);
  return *this;
}
inline Handles& Handles::some_protocol(::fidl::ClientEnd<::test_handles::SomeProtocol> value) {
  storage_.some_protocol = std::move(value);
  return *this;
}
inline Handles& Handles::request_some_protocol(::fidl::ServerEnd<::test_handles::SomeProtocol> value) {
  storage_.request_some_protocol = std::move(value);
  return *this;
}

#endif  // __Fuchsia__

#ifdef __Fuchsia__

inline FdfHandles::FdfHandles(Storage_ storage) noexcept : storage_(std::move(storage)) {}
inline FdfHandles::FdfHandles(::fdf::Channel fdf_channel_handle, ::fdf::ClientEnd<::test_handles::DriverProtocol> client_end_driver, ::fdf::ServerEnd<::test_handles::DriverProtocol> server_end_driver) noexcept
    : storage_({.fdf_channel_handle = std::move(fdf_channel_handle),
                .client_end_driver = std::move(client_end_driver),
                .server_end_driver = std::move(server_end_driver)}) {}

inline FdfHandles::FdfHandles(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : FdfHandles(Storage_{
                                                                                                .fdf_channel_handle = {},
                                                                                                .client_end_driver = {},
                                                                                                .server_end_driver = {},
                                                                                            }) {}
inline FdfHandles& FdfHandles::fdf_channel_handle(::fdf::Channel value) {
  storage_.fdf_channel_handle = std::move(value);
  return *this;
}
inline FdfHandles& FdfHandles::client_end_driver(::fdf::ClientEnd<::test_handles::DriverProtocol> value) {
  storage_.client_end_driver = std::move(value);
  return *this;
}
inline FdfHandles& FdfHandles::server_end_driver(::fdf::ServerEnd<::test_handles::DriverProtocol> value) {
  storage_.server_end_driver = std::move(value);
  return *this;
}

#endif  // __Fuchsia__

}  // namespace test_handles
namespace fidl {

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_handles_HandlesTable;

template <>
struct IsResource<::test_handles::Handles> : public std::true_type {};
template <>
struct IsFidlType<::test_handles::Handles> : public std::true_type {};

template <>
struct TypeTraits<::test_handles::Handles> {
  static constexpr uint32_t kMaxNumHandles = 34;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 136;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_handles::Handles> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_handles::Handles, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_handles::Handles, 136> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_handles_FdfHandlesTable;

template <>
struct IsResource<::test_handles::FdfHandles> : public std::true_type {};
template <>
struct IsFidlType<::test_handles::FdfHandles> : public std::true_type {};

template <>
struct TypeTraits<::test_handles::FdfHandles> {
  static constexpr uint32_t kMaxNumHandles = 3;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 12;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_handles::FdfHandles> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_handles::FdfHandles, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_handles::FdfHandles, 12> {};

#endif  // __Fuchsia__

}  // namespace fidl
