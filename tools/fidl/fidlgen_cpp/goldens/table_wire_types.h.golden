// WARNING: This file is machine generated by fidlgen.
  
  // fidl_experiment = no_optional_structs
  // fidl_experiment = output_index_json
  // fidl_experiment = simple_empty_response_syntax
  // fidl_experiment = unknown_interactions

  #pragma once

  #include <cinttypes>

  #include <lib/fidl/cpp/wire/internal/transport_err.h>
  #include <lib/fidl/cpp/wire/array.h>
  #include <lib/fidl/cpp/wire/envelope.h>
  #include <lib/fidl/cpp/wire/message_storage.h>
  #include <lib/fidl/cpp/wire/message.h>
  #include <lib/fidl/cpp/wire/object_view.h>
  #include <lib/fidl/cpp/wire/string_view.h>
  #include <lib/fidl/cpp/wire/traits.h>
  #include <lib/fidl/cpp/wire/wire_types.h>
  #include <lib/stdcompat/optional.h>
#ifdef __Fuchsia__


#endif  // __Fuchsia__


  #include <fidl/test.table/cpp/markers.h>
  #include <fidl/test.table/cpp/common_types.h>
  

  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wshadow"

  namespace test_table {


  
  
  
  
namespace wire {

class EmptyTable;


class SimpleTable;


class OlderSimpleTable;


class NewerSimpleTable;


class ReverseOrdinalTable;


class TableWithAttributes;


class ExtensionTable;


class SixtyFourOrdinalTable;
  
  


}  // namespace wire
}  // namespace test_table

template<>
class ::fidl::WireTableBuilder<::test_table::wire::EmptyTable>;
template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::EmptyTable>;

template <>
struct ::fidl::WireTableFrame<::test_table::wire::EmptyTable> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;

  friend class ::test_table::wire::EmptyTable;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::EmptyTable, ::fidl::WireTableBuilder<::test_table::wire::EmptyTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::EmptyTable, ::fidl::WireTableExternalBuilder<::test_table::wire::EmptyTable>>;
};

namespace test_table {
namespace wire {

extern "C" const fidl_type_t test_table_EmptyTableTable;

class EmptyTable {
public:
  EmptyTable() = default;
  EmptyTable(const EmptyTable& other) noexcept = default;
  EmptyTable& operator=(const EmptyTable& other) noexcept = default;
  EmptyTable(EmptyTable&& other) noexcept = default;
  EmptyTable& operator=(EmptyTable&& other) noexcept = default;

  ~EmptyTable() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_table::wire::EmptyTable> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_table::wire::EmptyTable> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::EmptyTable>> frame);
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES


  explicit EmptyTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::EmptyTable>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit EmptyTable(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::EmptyTable>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::EmptyTable>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::EmptyTable>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::EmptyTable, ::fidl::WireTableBuilder<::test_table::wire::EmptyTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::EmptyTable, ::fidl::WireTableExternalBuilder<::test_table::wire::EmptyTable>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::EmptyTable>> frame_ptr_;
};}  // namespace wire
}  // namespace test_table

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_table::wire::EmptyTable, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_table::wire::EmptyTable Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_table::wire::EmptyTable t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::EmptyTable>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_table::wire::EmptyTable table_;
};

template<>
class ::fidl::WireTableBuilder<::test_table::wire::EmptyTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::EmptyTable, ::fidl::WireTableBuilder<::test_table::wire::EmptyTable>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::EmptyTable, ::fidl::WireTableBuilder<::test_table::wire::EmptyTable>>;

 public:
 private:
  friend class ::test_table::wire::EmptyTable;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::EmptyTable>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::EmptyTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::EmptyTable, ::fidl::WireTableExternalBuilder<::test_table::wire::EmptyTable>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::EmptyTable, ::fidl::WireTableExternalBuilder<::test_table::wire::EmptyTable>>;

 private:
  friend class ::test_table::wire::EmptyTable;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_table::wire::EmptyTable>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::EmptyTable>>::FromExternal(frame)) {}
};namespace test_table {
namespace wire {

inline ::fidl::WireTableBuilder<::test_table::wire::EmptyTable> EmptyTable::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_table::wire::EmptyTable>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_table::wire::EmptyTable> EmptyTable::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::EmptyTable>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_table::wire::EmptyTable>(std::move(frame));
}


}  // namespace wire
}  // namespace test_table

template<>
class ::fidl::WireTableBuilder<::test_table::wire::SimpleTable>;
template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::SimpleTable>;

template <>
struct ::fidl::WireTableFrame<::test_table::wire::SimpleTable> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int64_t> x_;
  [[maybe_unused]] ::fidl::UntypedEnvelope reserved_1_;
  [[maybe_unused]] ::fidl::UntypedEnvelope reserved_2_;
  [[maybe_unused]] ::fidl::UntypedEnvelope reserved_3_;
  ::fidl::Envelope<int64_t> y_;

  friend class ::test_table::wire::SimpleTable;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SimpleTable, ::fidl::WireTableBuilder<::test_table::wire::SimpleTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SimpleTable, ::fidl::WireTableExternalBuilder<::test_table::wire::SimpleTable>>;
};

namespace test_table {
namespace wire {

extern "C" const fidl_type_t test_table_SimpleTableTable;

class SimpleTable {
public:
  SimpleTable() = default;
  SimpleTable(const SimpleTable& other) noexcept = default;
  SimpleTable& operator=(const SimpleTable& other) noexcept = default;
  SimpleTable(SimpleTable&& other) noexcept = default;
  SimpleTable& operator=(SimpleTable&& other) noexcept = default;

  ~SimpleTable() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_table::wire::SimpleTable> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_table::wire::SimpleTable> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SimpleTable>> frame);

  [[ nodiscard ]] int64_t& x() const {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  [[ nodiscard ]] bool has_x() const {
    return max_ordinal_ >= 1 && frame_ptr_->x_.has_data();
  }

  [[ nodiscard ]] int64_t& y() const {
    ZX_ASSERT(has_y());
    return frame_ptr_->y_.get_data();
  }
  [[ nodiscard ]] bool has_y() const {
    return max_ordinal_ >= 5 && frame_ptr_->y_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  SimpleTable& set_x(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }
  SimpleTable& set_x(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SimpleTable& set_x(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  SimpleTable& clear_x() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SimpleTable& set_y(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(5));
    return *this;
  }
  SimpleTable& set_y(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SimpleTable& set_y(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(5));
    return *this;
  }

  SimpleTable& clear_y() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit SimpleTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SimpleTable>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit SimpleTable(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SimpleTable>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SimpleTable>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SimpleTable>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SimpleTable, ::fidl::WireTableBuilder<::test_table::wire::SimpleTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SimpleTable, ::fidl::WireTableExternalBuilder<::test_table::wire::SimpleTable>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SimpleTable>> frame_ptr_;
};}  // namespace wire
}  // namespace test_table

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SimpleTable, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_table::wire::SimpleTable Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_table::wire::SimpleTable t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_x() const {
      return table_.has_x();
    }

    // Clears the x field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_x() {
      table_.clear_x();
    }

    // Getter for x.
    //
    
    [[ nodiscard ]] int64_t& x() const {
      return table_.x();
    }

    // Setter for x.
    //
    
      BuilderImpl& x(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->x_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_y() const {
      return table_.has_y();
    }

    // Clears the y field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_y() {
      table_.clear_y();
    }

    // Getter for y.
    //
    
    [[ nodiscard ]] int64_t& y() const {
      return table_.y();
    }

    // Setter for y.
    //
    
      BuilderImpl& y(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->y_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(5));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SimpleTable>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_table::wire::SimpleTable table_;
};

template<>
class ::fidl::WireTableBuilder<::test_table::wire::SimpleTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SimpleTable, ::fidl::WireTableBuilder<::test_table::wire::SimpleTable>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SimpleTable, ::fidl::WireTableBuilder<::test_table::wire::SimpleTable>>;

 public:
    using Base::x;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SimpleTable>& x(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        x(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::y;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SimpleTable>& y(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        y(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
 private:
  friend class ::test_table::wire::SimpleTable;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SimpleTable>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::SimpleTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SimpleTable, ::fidl::WireTableExternalBuilder<::test_table::wire::SimpleTable>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SimpleTable, ::fidl::WireTableExternalBuilder<::test_table::wire::SimpleTable>>;

 private:
  friend class ::test_table::wire::SimpleTable;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_table::wire::SimpleTable>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SimpleTable>>::FromExternal(frame)) {}
};namespace test_table {
namespace wire {

inline ::fidl::WireTableBuilder<::test_table::wire::SimpleTable> SimpleTable::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_table::wire::SimpleTable>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_table::wire::SimpleTable> SimpleTable::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SimpleTable>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_table::wire::SimpleTable>(std::move(frame));
}


}  // namespace wire
}  // namespace test_table

template<>
class ::fidl::WireTableBuilder<::test_table::wire::OlderSimpleTable>;
template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::OlderSimpleTable>;

template <>
struct ::fidl::WireTableFrame<::test_table::wire::OlderSimpleTable> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int64_t> x_;

  friend class ::test_table::wire::OlderSimpleTable;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::OlderSimpleTable, ::fidl::WireTableBuilder<::test_table::wire::OlderSimpleTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::OlderSimpleTable, ::fidl::WireTableExternalBuilder<::test_table::wire::OlderSimpleTable>>;
};

namespace test_table {
namespace wire {

extern "C" const fidl_type_t test_table_OlderSimpleTableTable;

class OlderSimpleTable {
public:
  OlderSimpleTable() = default;
  OlderSimpleTable(const OlderSimpleTable& other) noexcept = default;
  OlderSimpleTable& operator=(const OlderSimpleTable& other) noexcept = default;
  OlderSimpleTable(OlderSimpleTable&& other) noexcept = default;
  OlderSimpleTable& operator=(OlderSimpleTable&& other) noexcept = default;

  ~OlderSimpleTable() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_table::wire::OlderSimpleTable> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_table::wire::OlderSimpleTable> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::OlderSimpleTable>> frame);

  [[ nodiscard ]] int64_t& x() const {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  [[ nodiscard ]] bool has_x() const {
    return max_ordinal_ >= 1 && frame_ptr_->x_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  OlderSimpleTable& set_x(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }
  OlderSimpleTable& set_x(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  OlderSimpleTable& set_x(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  OlderSimpleTable& clear_x() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit OlderSimpleTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::OlderSimpleTable>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit OlderSimpleTable(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::OlderSimpleTable>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::OlderSimpleTable>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::OlderSimpleTable>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::OlderSimpleTable, ::fidl::WireTableBuilder<::test_table::wire::OlderSimpleTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::OlderSimpleTable, ::fidl::WireTableExternalBuilder<::test_table::wire::OlderSimpleTable>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::OlderSimpleTable>> frame_ptr_;
};}  // namespace wire
}  // namespace test_table

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_table::wire::OlderSimpleTable, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_table::wire::OlderSimpleTable Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_table::wire::OlderSimpleTable t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_x() const {
      return table_.has_x();
    }

    // Clears the x field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_x() {
      table_.clear_x();
    }

    // Getter for x.
    //
    
    [[ nodiscard ]] int64_t& x() const {
      return table_.x();
    }

    // Setter for x.
    //
    
      BuilderImpl& x(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->x_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::OlderSimpleTable>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_table::wire::OlderSimpleTable table_;
};

template<>
class ::fidl::WireTableBuilder<::test_table::wire::OlderSimpleTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::OlderSimpleTable, ::fidl::WireTableBuilder<::test_table::wire::OlderSimpleTable>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::OlderSimpleTable, ::fidl::WireTableBuilder<::test_table::wire::OlderSimpleTable>>;

 public:
    using Base::x;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::OlderSimpleTable>& x(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        x(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
 private:
  friend class ::test_table::wire::OlderSimpleTable;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::OlderSimpleTable>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::OlderSimpleTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::OlderSimpleTable, ::fidl::WireTableExternalBuilder<::test_table::wire::OlderSimpleTable>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::OlderSimpleTable, ::fidl::WireTableExternalBuilder<::test_table::wire::OlderSimpleTable>>;

 private:
  friend class ::test_table::wire::OlderSimpleTable;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_table::wire::OlderSimpleTable>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::OlderSimpleTable>>::FromExternal(frame)) {}
};namespace test_table {
namespace wire {

inline ::fidl::WireTableBuilder<::test_table::wire::OlderSimpleTable> OlderSimpleTable::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_table::wire::OlderSimpleTable>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_table::wire::OlderSimpleTable> OlderSimpleTable::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::OlderSimpleTable>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_table::wire::OlderSimpleTable>(std::move(frame));
}


}  // namespace wire
}  // namespace test_table

template<>
class ::fidl::WireTableBuilder<::test_table::wire::NewerSimpleTable>;
template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::NewerSimpleTable>;

template <>
struct ::fidl::WireTableFrame<::test_table::wire::NewerSimpleTable> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int64_t> x_;
  [[maybe_unused]] ::fidl::UntypedEnvelope reserved_1_;
  [[maybe_unused]] ::fidl::UntypedEnvelope reserved_2_;
  [[maybe_unused]] ::fidl::UntypedEnvelope reserved_3_;
  ::fidl::Envelope<int64_t> y_;
  ::fidl::Envelope<int64_t> z_;

  friend class ::test_table::wire::NewerSimpleTable;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::NewerSimpleTable, ::fidl::WireTableBuilder<::test_table::wire::NewerSimpleTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::NewerSimpleTable, ::fidl::WireTableExternalBuilder<::test_table::wire::NewerSimpleTable>>;
};

namespace test_table {
namespace wire {

extern "C" const fidl_type_t test_table_NewerSimpleTableTable;

class NewerSimpleTable {
public:
  NewerSimpleTable() = default;
  NewerSimpleTable(const NewerSimpleTable& other) noexcept = default;
  NewerSimpleTable& operator=(const NewerSimpleTable& other) noexcept = default;
  NewerSimpleTable(NewerSimpleTable&& other) noexcept = default;
  NewerSimpleTable& operator=(NewerSimpleTable&& other) noexcept = default;

  ~NewerSimpleTable() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_table::wire::NewerSimpleTable> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_table::wire::NewerSimpleTable> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::NewerSimpleTable>> frame);

  [[ nodiscard ]] int64_t& x() const {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  [[ nodiscard ]] bool has_x() const {
    return max_ordinal_ >= 1 && frame_ptr_->x_.has_data();
  }

  [[ nodiscard ]] int64_t& y() const {
    ZX_ASSERT(has_y());
    return frame_ptr_->y_.get_data();
  }
  [[ nodiscard ]] bool has_y() const {
    return max_ordinal_ >= 5 && frame_ptr_->y_.has_data();
  }

  [[ nodiscard ]] int64_t& z() const {
    ZX_ASSERT(has_z());
    return frame_ptr_->z_.get_data();
  }
  [[ nodiscard ]] bool has_z() const {
    return max_ordinal_ >= 6 && frame_ptr_->z_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  NewerSimpleTable& set_x(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }
  NewerSimpleTable& set_x(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  NewerSimpleTable& set_x(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  NewerSimpleTable& clear_x() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  NewerSimpleTable& set_y(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(5));
    return *this;
  }
  NewerSimpleTable& set_y(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  NewerSimpleTable& set_y(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(5));
    return *this;
  }

  NewerSimpleTable& clear_y() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  NewerSimpleTable& set_z(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(6));
    return *this;
  }
  NewerSimpleTable& set_z(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  NewerSimpleTable& set_z(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(6));
    return *this;
  }

  NewerSimpleTable& clear_z() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit NewerSimpleTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::NewerSimpleTable>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit NewerSimpleTable(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::NewerSimpleTable>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::NewerSimpleTable>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::NewerSimpleTable>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::NewerSimpleTable, ::fidl::WireTableBuilder<::test_table::wire::NewerSimpleTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::NewerSimpleTable, ::fidl::WireTableExternalBuilder<::test_table::wire::NewerSimpleTable>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::NewerSimpleTable>> frame_ptr_;
};}  // namespace wire
}  // namespace test_table

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_table::wire::NewerSimpleTable, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_table::wire::NewerSimpleTable Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_table::wire::NewerSimpleTable t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_x() const {
      return table_.has_x();
    }

    // Clears the x field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_x() {
      table_.clear_x();
    }

    // Getter for x.
    //
    
    [[ nodiscard ]] int64_t& x() const {
      return table_.x();
    }

    // Setter for x.
    //
    
      BuilderImpl& x(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->x_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_y() const {
      return table_.has_y();
    }

    // Clears the y field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_y() {
      table_.clear_y();
    }

    // Getter for y.
    //
    
    [[ nodiscard ]] int64_t& y() const {
      return table_.y();
    }

    // Setter for y.
    //
    
      BuilderImpl& y(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->y_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(5));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_z() const {
      return table_.has_z();
    }

    // Clears the z field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_z() {
      table_.clear_z();
    }

    // Getter for z.
    //
    
    [[ nodiscard ]] int64_t& z() const {
      return table_.z();
    }

    // Setter for z.
    //
    
      BuilderImpl& z(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->z_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(6));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::NewerSimpleTable>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_table::wire::NewerSimpleTable table_;
};

template<>
class ::fidl::WireTableBuilder<::test_table::wire::NewerSimpleTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::NewerSimpleTable, ::fidl::WireTableBuilder<::test_table::wire::NewerSimpleTable>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::NewerSimpleTable, ::fidl::WireTableBuilder<::test_table::wire::NewerSimpleTable>>;

 public:
    using Base::x;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::NewerSimpleTable>& x(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        x(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::y;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::NewerSimpleTable>& y(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        y(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::z;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::NewerSimpleTable>& z(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        z(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
 private:
  friend class ::test_table::wire::NewerSimpleTable;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::NewerSimpleTable>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::NewerSimpleTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::NewerSimpleTable, ::fidl::WireTableExternalBuilder<::test_table::wire::NewerSimpleTable>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::NewerSimpleTable, ::fidl::WireTableExternalBuilder<::test_table::wire::NewerSimpleTable>>;

 private:
  friend class ::test_table::wire::NewerSimpleTable;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_table::wire::NewerSimpleTable>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::NewerSimpleTable>>::FromExternal(frame)) {}
};namespace test_table {
namespace wire {

inline ::fidl::WireTableBuilder<::test_table::wire::NewerSimpleTable> NewerSimpleTable::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_table::wire::NewerSimpleTable>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_table::wire::NewerSimpleTable> NewerSimpleTable::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::NewerSimpleTable>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_table::wire::NewerSimpleTable>(std::move(frame));
}


}  // namespace wire
}  // namespace test_table

template<>
class ::fidl::WireTableBuilder<::test_table::wire::ReverseOrdinalTable>;
template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::ReverseOrdinalTable>;

template <>
struct ::fidl::WireTableFrame<::test_table::wire::ReverseOrdinalTable> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int64_t> z_;
  ::fidl::Envelope<int64_t> y_;
  ::fidl::Envelope<int64_t> x_;

  friend class ::test_table::wire::ReverseOrdinalTable;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ReverseOrdinalTable, ::fidl::WireTableBuilder<::test_table::wire::ReverseOrdinalTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ReverseOrdinalTable, ::fidl::WireTableExternalBuilder<::test_table::wire::ReverseOrdinalTable>>;
};

namespace test_table {
namespace wire {

extern "C" const fidl_type_t test_table_ReverseOrdinalTableTable;

class ReverseOrdinalTable {
public:
  ReverseOrdinalTable() = default;
  ReverseOrdinalTable(const ReverseOrdinalTable& other) noexcept = default;
  ReverseOrdinalTable& operator=(const ReverseOrdinalTable& other) noexcept = default;
  ReverseOrdinalTable(ReverseOrdinalTable&& other) noexcept = default;
  ReverseOrdinalTable& operator=(ReverseOrdinalTable&& other) noexcept = default;

  ~ReverseOrdinalTable() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_table::wire::ReverseOrdinalTable> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_table::wire::ReverseOrdinalTable> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ReverseOrdinalTable>> frame);

  [[ nodiscard ]] int64_t& z() const {
    ZX_ASSERT(has_z());
    return frame_ptr_->z_.get_data();
  }
  [[ nodiscard ]] bool has_z() const {
    return max_ordinal_ >= 1 && frame_ptr_->z_.has_data();
  }

  [[ nodiscard ]] int64_t& y() const {
    ZX_ASSERT(has_y());
    return frame_ptr_->y_.get_data();
  }
  [[ nodiscard ]] bool has_y() const {
    return max_ordinal_ >= 2 && frame_ptr_->y_.has_data();
  }

  [[ nodiscard ]] int64_t& x() const {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  [[ nodiscard ]] bool has_x() const {
    return max_ordinal_ >= 3 && frame_ptr_->x_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  ReverseOrdinalTable& set_z(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }
  ReverseOrdinalTable& set_z(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  ReverseOrdinalTable& set_z(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  ReverseOrdinalTable& clear_z() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->z_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  ReverseOrdinalTable& set_y(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(2));
    return *this;
  }
  ReverseOrdinalTable& set_y(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  ReverseOrdinalTable& set_y(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(2));
    return *this;
  }

  ReverseOrdinalTable& clear_y() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->y_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  ReverseOrdinalTable& set_x(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(3));
    return *this;
  }
  ReverseOrdinalTable& set_x(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  ReverseOrdinalTable& set_x(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(3));
    return *this;
  }

  ReverseOrdinalTable& clear_x() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit ReverseOrdinalTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ReverseOrdinalTable>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit ReverseOrdinalTable(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ReverseOrdinalTable>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ReverseOrdinalTable>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ReverseOrdinalTable>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ReverseOrdinalTable, ::fidl::WireTableBuilder<::test_table::wire::ReverseOrdinalTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ReverseOrdinalTable, ::fidl::WireTableExternalBuilder<::test_table::wire::ReverseOrdinalTable>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ReverseOrdinalTable>> frame_ptr_;
};}  // namespace wire
}  // namespace test_table

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ReverseOrdinalTable, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_table::wire::ReverseOrdinalTable Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_table::wire::ReverseOrdinalTable t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_z() const {
      return table_.has_z();
    }

    // Clears the z field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_z() {
      table_.clear_z();
    }

    // Getter for z.
    //
    
    [[ nodiscard ]] int64_t& z() const {
      return table_.z();
    }

    // Setter for z.
    //
    
      BuilderImpl& z(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->z_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_y() const {
      return table_.has_y();
    }

    // Clears the y field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_y() {
      table_.clear_y();
    }

    // Getter for y.
    //
    
    [[ nodiscard ]] int64_t& y() const {
      return table_.y();
    }

    // Setter for y.
    //
    
      BuilderImpl& y(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->y_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(2));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_x() const {
      return table_.has_x();
    }

    // Clears the x field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_x() {
      table_.clear_x();
    }

    // Getter for x.
    //
    
    [[ nodiscard ]] int64_t& x() const {
      return table_.x();
    }

    // Setter for x.
    //
    
      BuilderImpl& x(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->x_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(3));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ReverseOrdinalTable>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_table::wire::ReverseOrdinalTable table_;
};

template<>
class ::fidl::WireTableBuilder<::test_table::wire::ReverseOrdinalTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ReverseOrdinalTable, ::fidl::WireTableBuilder<::test_table::wire::ReverseOrdinalTable>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ReverseOrdinalTable, ::fidl::WireTableBuilder<::test_table::wire::ReverseOrdinalTable>>;

 public:
    using Base::z;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::ReverseOrdinalTable>& z(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        z(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::y;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::ReverseOrdinalTable>& y(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        y(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::x;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::ReverseOrdinalTable>& x(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        x(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
 private:
  friend class ::test_table::wire::ReverseOrdinalTable;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ReverseOrdinalTable>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::ReverseOrdinalTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ReverseOrdinalTable, ::fidl::WireTableExternalBuilder<::test_table::wire::ReverseOrdinalTable>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ReverseOrdinalTable, ::fidl::WireTableExternalBuilder<::test_table::wire::ReverseOrdinalTable>>;

 private:
  friend class ::test_table::wire::ReverseOrdinalTable;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_table::wire::ReverseOrdinalTable>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ReverseOrdinalTable>>::FromExternal(frame)) {}
};namespace test_table {
namespace wire {

inline ::fidl::WireTableBuilder<::test_table::wire::ReverseOrdinalTable> ReverseOrdinalTable::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_table::wire::ReverseOrdinalTable>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_table::wire::ReverseOrdinalTable> ReverseOrdinalTable::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ReverseOrdinalTable>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_table::wire::ReverseOrdinalTable>(std::move(frame));
}


}  // namespace wire
}  // namespace test_table

template<>
class ::fidl::WireTableBuilder<::test_table::wire::TableWithAttributes>;
template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::TableWithAttributes>;

template <>
struct ::fidl::WireTableFrame<::test_table::wire::TableWithAttributes> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int64_t> x_;

  friend class ::test_table::wire::TableWithAttributes;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::TableWithAttributes, ::fidl::WireTableBuilder<::test_table::wire::TableWithAttributes>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::TableWithAttributes, ::fidl::WireTableExternalBuilder<::test_table::wire::TableWithAttributes>>;
};

namespace test_table {
namespace wire {

extern "C" const fidl_type_t test_table_TableWithAttributesTable;

class TableWithAttributes {
public:
  TableWithAttributes() = default;
  TableWithAttributes(const TableWithAttributes& other) noexcept = default;
  TableWithAttributes& operator=(const TableWithAttributes& other) noexcept = default;
  TableWithAttributes(TableWithAttributes&& other) noexcept = default;
  TableWithAttributes& operator=(TableWithAttributes&& other) noexcept = default;

  ~TableWithAttributes() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_table::wire::TableWithAttributes> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_table::wire::TableWithAttributes> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::TableWithAttributes>> frame);

  [[ nodiscard ]] int64_t& x() const {
    ZX_ASSERT(has_x());
    return frame_ptr_->x_.get_data();
  }
  [[ nodiscard ]] bool has_x() const {
    return max_ordinal_ >= 1 && frame_ptr_->x_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  TableWithAttributes& set_x(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }
  TableWithAttributes& set_x(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  TableWithAttributes& set_x(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  TableWithAttributes& clear_x() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->x_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit TableWithAttributes(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::TableWithAttributes>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit TableWithAttributes(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::TableWithAttributes>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::TableWithAttributes>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::TableWithAttributes>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::TableWithAttributes, ::fidl::WireTableBuilder<::test_table::wire::TableWithAttributes>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::TableWithAttributes, ::fidl::WireTableExternalBuilder<::test_table::wire::TableWithAttributes>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::TableWithAttributes>> frame_ptr_;
};}  // namespace wire
}  // namespace test_table

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_table::wire::TableWithAttributes, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_table::wire::TableWithAttributes Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_table::wire::TableWithAttributes t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_x() const {
      return table_.has_x();
    }

    // Clears the x field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_x() {
      table_.clear_x();
    }

    // Getter for x.
    //
    
    [[ nodiscard ]] int64_t& x() const {
      return table_.x();
    }

    // Setter for x.
    //
    
      BuilderImpl& x(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->x_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::TableWithAttributes>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_table::wire::TableWithAttributes table_;
};

template<>
class ::fidl::WireTableBuilder<::test_table::wire::TableWithAttributes> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::TableWithAttributes, ::fidl::WireTableBuilder<::test_table::wire::TableWithAttributes>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::TableWithAttributes, ::fidl::WireTableBuilder<::test_table::wire::TableWithAttributes>>;

 public:
    using Base::x;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::TableWithAttributes>& x(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        x(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
 private:
  friend class ::test_table::wire::TableWithAttributes;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::TableWithAttributes>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::TableWithAttributes> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::TableWithAttributes, ::fidl::WireTableExternalBuilder<::test_table::wire::TableWithAttributes>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::TableWithAttributes, ::fidl::WireTableExternalBuilder<::test_table::wire::TableWithAttributes>>;

 private:
  friend class ::test_table::wire::TableWithAttributes;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_table::wire::TableWithAttributes>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::TableWithAttributes>>::FromExternal(frame)) {}
};namespace test_table {
namespace wire {

inline ::fidl::WireTableBuilder<::test_table::wire::TableWithAttributes> TableWithAttributes::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_table::wire::TableWithAttributes>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_table::wire::TableWithAttributes> TableWithAttributes::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::TableWithAttributes>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_table::wire::TableWithAttributes>(std::move(frame));
}


}  // namespace wire
}  // namespace test_table

template<>
class ::fidl::WireTableBuilder<::test_table::wire::ExtensionTable>;
template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::ExtensionTable>;

template <>
struct ::fidl::WireTableFrame<::test_table::wire::ExtensionTable> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;

  friend class ::test_table::wire::ExtensionTable;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ExtensionTable, ::fidl::WireTableBuilder<::test_table::wire::ExtensionTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ExtensionTable, ::fidl::WireTableExternalBuilder<::test_table::wire::ExtensionTable>>;
};

namespace test_table {
namespace wire {

extern "C" const fidl_type_t test_table_ExtensionTableTable;

class ExtensionTable {
public:
  ExtensionTable() = default;
  ExtensionTable(const ExtensionTable& other) noexcept = default;
  ExtensionTable& operator=(const ExtensionTable& other) noexcept = default;
  ExtensionTable(ExtensionTable&& other) noexcept = default;
  ExtensionTable& operator=(ExtensionTable&& other) noexcept = default;

  ~ExtensionTable() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_table::wire::ExtensionTable> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_table::wire::ExtensionTable> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ExtensionTable>> frame);
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES


  explicit ExtensionTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ExtensionTable>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit ExtensionTable(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ExtensionTable>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ExtensionTable>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ExtensionTable>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ExtensionTable, ::fidl::WireTableBuilder<::test_table::wire::ExtensionTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ExtensionTable, ::fidl::WireTableExternalBuilder<::test_table::wire::ExtensionTable>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ExtensionTable>> frame_ptr_;
};}  // namespace wire
}  // namespace test_table

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ExtensionTable, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_table::wire::ExtensionTable Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_table::wire::ExtensionTable t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ExtensionTable>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_table::wire::ExtensionTable table_;
};

template<>
class ::fidl::WireTableBuilder<::test_table::wire::ExtensionTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ExtensionTable, ::fidl::WireTableBuilder<::test_table::wire::ExtensionTable>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ExtensionTable, ::fidl::WireTableBuilder<::test_table::wire::ExtensionTable>>;

 public:
 private:
  friend class ::test_table::wire::ExtensionTable;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ExtensionTable>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::ExtensionTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ExtensionTable, ::fidl::WireTableExternalBuilder<::test_table::wire::ExtensionTable>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::ExtensionTable, ::fidl::WireTableExternalBuilder<::test_table::wire::ExtensionTable>>;

 private:
  friend class ::test_table::wire::ExtensionTable;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_table::wire::ExtensionTable>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ExtensionTable>>::FromExternal(frame)) {}
};namespace test_table {
namespace wire {

inline ::fidl::WireTableBuilder<::test_table::wire::ExtensionTable> ExtensionTable::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_table::wire::ExtensionTable>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_table::wire::ExtensionTable> ExtensionTable::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::ExtensionTable>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_table::wire::ExtensionTable>(std::move(frame));
}


}  // namespace wire
}  // namespace test_table

template<>
class ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>;
template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::SixtyFourOrdinalTable>;

template <>
struct ::fidl::WireTableFrame<::test_table::wire::SixtyFourOrdinalTable> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int64_t> v1_;
  ::fidl::Envelope<int64_t> v2_;
  ::fidl::Envelope<int64_t> v3_;
  ::fidl::Envelope<int64_t> v4_;
  ::fidl::Envelope<int64_t> v5_;
  ::fidl::Envelope<int64_t> v6_;
  ::fidl::Envelope<int64_t> v7_;
  ::fidl::Envelope<int64_t> v8_;
  ::fidl::Envelope<int64_t> v9_;
  ::fidl::Envelope<int64_t> v10_;
  ::fidl::Envelope<int64_t> v11_;
  ::fidl::Envelope<int64_t> v12_;
  ::fidl::Envelope<int64_t> v13_;
  ::fidl::Envelope<int64_t> v14_;
  ::fidl::Envelope<int64_t> v15_;
  ::fidl::Envelope<int64_t> v16_;
  ::fidl::Envelope<int64_t> v17_;
  ::fidl::Envelope<int64_t> v18_;
  ::fidl::Envelope<int64_t> v19_;
  ::fidl::Envelope<int64_t> v20_;
  ::fidl::Envelope<int64_t> v21_;
  ::fidl::Envelope<int64_t> v22_;
  ::fidl::Envelope<int64_t> v23_;
  ::fidl::Envelope<int64_t> v24_;
  ::fidl::Envelope<int64_t> v25_;
  ::fidl::Envelope<int64_t> v26_;
  ::fidl::Envelope<int64_t> v27_;
  ::fidl::Envelope<int64_t> v28_;
  ::fidl::Envelope<int64_t> v29_;
  ::fidl::Envelope<int64_t> v30_;
  ::fidl::Envelope<int64_t> v31_;
  ::fidl::Envelope<int64_t> v32_;
  ::fidl::Envelope<int64_t> v33_;
  ::fidl::Envelope<int64_t> v34_;
  ::fidl::Envelope<int64_t> v35_;
  ::fidl::Envelope<int64_t> v36_;
  ::fidl::Envelope<int64_t> v37_;
  ::fidl::Envelope<int64_t> v38_;
  ::fidl::Envelope<int64_t> v39_;
  ::fidl::Envelope<int64_t> v40_;
  ::fidl::Envelope<int64_t> v41_;
  ::fidl::Envelope<int64_t> v42_;
  ::fidl::Envelope<int64_t> v43_;
  ::fidl::Envelope<int64_t> v44_;
  ::fidl::Envelope<int64_t> v45_;
  ::fidl::Envelope<int64_t> v46_;
  ::fidl::Envelope<int64_t> v47_;
  ::fidl::Envelope<int64_t> v48_;
  ::fidl::Envelope<int64_t> v49_;
  ::fidl::Envelope<int64_t> v50_;
  ::fidl::Envelope<int64_t> v51_;
  ::fidl::Envelope<int64_t> v52_;
  ::fidl::Envelope<int64_t> v53_;
  ::fidl::Envelope<int64_t> v54_;
  ::fidl::Envelope<int64_t> v55_;
  ::fidl::Envelope<int64_t> v56_;
  ::fidl::Envelope<int64_t> v57_;
  ::fidl::Envelope<int64_t> v58_;
  ::fidl::Envelope<int64_t> v59_;
  ::fidl::Envelope<int64_t> v60_;
  ::fidl::Envelope<int64_t> v61_;
  ::fidl::Envelope<int64_t> v62_;
  ::fidl::Envelope<int64_t> v63_;
  ::fidl::Envelope<::test_table::wire::ExtensionTable> v64_;

  friend class ::test_table::wire::SixtyFourOrdinalTable;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SixtyFourOrdinalTable, ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SixtyFourOrdinalTable, ::fidl::WireTableExternalBuilder<::test_table::wire::SixtyFourOrdinalTable>>;
};

namespace test_table {
namespace wire {

extern "C" const fidl_type_t test_table_SixtyFourOrdinalTableTable;

class SixtyFourOrdinalTable {
public:
  SixtyFourOrdinalTable() = default;
  SixtyFourOrdinalTable(const SixtyFourOrdinalTable& other) noexcept = default;
  SixtyFourOrdinalTable& operator=(const SixtyFourOrdinalTable& other) noexcept = default;
  SixtyFourOrdinalTable(SixtyFourOrdinalTable&& other) noexcept = default;
  SixtyFourOrdinalTable& operator=(SixtyFourOrdinalTable&& other) noexcept = default;

  ~SixtyFourOrdinalTable() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_table::wire::SixtyFourOrdinalTable> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SixtyFourOrdinalTable>> frame);

  [[ nodiscard ]] int64_t& v1() const {
    ZX_ASSERT(has_v1());
    return frame_ptr_->v1_.get_data();
  }
  [[ nodiscard ]] bool has_v1() const {
    return max_ordinal_ >= 1 && frame_ptr_->v1_.has_data();
  }

  [[ nodiscard ]] int64_t& v2() const {
    ZX_ASSERT(has_v2());
    return frame_ptr_->v2_.get_data();
  }
  [[ nodiscard ]] bool has_v2() const {
    return max_ordinal_ >= 2 && frame_ptr_->v2_.has_data();
  }

  [[ nodiscard ]] int64_t& v3() const {
    ZX_ASSERT(has_v3());
    return frame_ptr_->v3_.get_data();
  }
  [[ nodiscard ]] bool has_v3() const {
    return max_ordinal_ >= 3 && frame_ptr_->v3_.has_data();
  }

  [[ nodiscard ]] int64_t& v4() const {
    ZX_ASSERT(has_v4());
    return frame_ptr_->v4_.get_data();
  }
  [[ nodiscard ]] bool has_v4() const {
    return max_ordinal_ >= 4 && frame_ptr_->v4_.has_data();
  }

  [[ nodiscard ]] int64_t& v5() const {
    ZX_ASSERT(has_v5());
    return frame_ptr_->v5_.get_data();
  }
  [[ nodiscard ]] bool has_v5() const {
    return max_ordinal_ >= 5 && frame_ptr_->v5_.has_data();
  }

  [[ nodiscard ]] int64_t& v6() const {
    ZX_ASSERT(has_v6());
    return frame_ptr_->v6_.get_data();
  }
  [[ nodiscard ]] bool has_v6() const {
    return max_ordinal_ >= 6 && frame_ptr_->v6_.has_data();
  }

  [[ nodiscard ]] int64_t& v7() const {
    ZX_ASSERT(has_v7());
    return frame_ptr_->v7_.get_data();
  }
  [[ nodiscard ]] bool has_v7() const {
    return max_ordinal_ >= 7 && frame_ptr_->v7_.has_data();
  }

  [[ nodiscard ]] int64_t& v8() const {
    ZX_ASSERT(has_v8());
    return frame_ptr_->v8_.get_data();
  }
  [[ nodiscard ]] bool has_v8() const {
    return max_ordinal_ >= 8 && frame_ptr_->v8_.has_data();
  }

  [[ nodiscard ]] int64_t& v9() const {
    ZX_ASSERT(has_v9());
    return frame_ptr_->v9_.get_data();
  }
  [[ nodiscard ]] bool has_v9() const {
    return max_ordinal_ >= 9 && frame_ptr_->v9_.has_data();
  }

  [[ nodiscard ]] int64_t& v10() const {
    ZX_ASSERT(has_v10());
    return frame_ptr_->v10_.get_data();
  }
  [[ nodiscard ]] bool has_v10() const {
    return max_ordinal_ >= 10 && frame_ptr_->v10_.has_data();
  }

  [[ nodiscard ]] int64_t& v11() const {
    ZX_ASSERT(has_v11());
    return frame_ptr_->v11_.get_data();
  }
  [[ nodiscard ]] bool has_v11() const {
    return max_ordinal_ >= 11 && frame_ptr_->v11_.has_data();
  }

  [[ nodiscard ]] int64_t& v12() const {
    ZX_ASSERT(has_v12());
    return frame_ptr_->v12_.get_data();
  }
  [[ nodiscard ]] bool has_v12() const {
    return max_ordinal_ >= 12 && frame_ptr_->v12_.has_data();
  }

  [[ nodiscard ]] int64_t& v13() const {
    ZX_ASSERT(has_v13());
    return frame_ptr_->v13_.get_data();
  }
  [[ nodiscard ]] bool has_v13() const {
    return max_ordinal_ >= 13 && frame_ptr_->v13_.has_data();
  }

  [[ nodiscard ]] int64_t& v14() const {
    ZX_ASSERT(has_v14());
    return frame_ptr_->v14_.get_data();
  }
  [[ nodiscard ]] bool has_v14() const {
    return max_ordinal_ >= 14 && frame_ptr_->v14_.has_data();
  }

  [[ nodiscard ]] int64_t& v15() const {
    ZX_ASSERT(has_v15());
    return frame_ptr_->v15_.get_data();
  }
  [[ nodiscard ]] bool has_v15() const {
    return max_ordinal_ >= 15 && frame_ptr_->v15_.has_data();
  }

  [[ nodiscard ]] int64_t& v16() const {
    ZX_ASSERT(has_v16());
    return frame_ptr_->v16_.get_data();
  }
  [[ nodiscard ]] bool has_v16() const {
    return max_ordinal_ >= 16 && frame_ptr_->v16_.has_data();
  }

  [[ nodiscard ]] int64_t& v17() const {
    ZX_ASSERT(has_v17());
    return frame_ptr_->v17_.get_data();
  }
  [[ nodiscard ]] bool has_v17() const {
    return max_ordinal_ >= 17 && frame_ptr_->v17_.has_data();
  }

  [[ nodiscard ]] int64_t& v18() const {
    ZX_ASSERT(has_v18());
    return frame_ptr_->v18_.get_data();
  }
  [[ nodiscard ]] bool has_v18() const {
    return max_ordinal_ >= 18 && frame_ptr_->v18_.has_data();
  }

  [[ nodiscard ]] int64_t& v19() const {
    ZX_ASSERT(has_v19());
    return frame_ptr_->v19_.get_data();
  }
  [[ nodiscard ]] bool has_v19() const {
    return max_ordinal_ >= 19 && frame_ptr_->v19_.has_data();
  }

  [[ nodiscard ]] int64_t& v20() const {
    ZX_ASSERT(has_v20());
    return frame_ptr_->v20_.get_data();
  }
  [[ nodiscard ]] bool has_v20() const {
    return max_ordinal_ >= 20 && frame_ptr_->v20_.has_data();
  }

  [[ nodiscard ]] int64_t& v21() const {
    ZX_ASSERT(has_v21());
    return frame_ptr_->v21_.get_data();
  }
  [[ nodiscard ]] bool has_v21() const {
    return max_ordinal_ >= 21 && frame_ptr_->v21_.has_data();
  }

  [[ nodiscard ]] int64_t& v22() const {
    ZX_ASSERT(has_v22());
    return frame_ptr_->v22_.get_data();
  }
  [[ nodiscard ]] bool has_v22() const {
    return max_ordinal_ >= 22 && frame_ptr_->v22_.has_data();
  }

  [[ nodiscard ]] int64_t& v23() const {
    ZX_ASSERT(has_v23());
    return frame_ptr_->v23_.get_data();
  }
  [[ nodiscard ]] bool has_v23() const {
    return max_ordinal_ >= 23 && frame_ptr_->v23_.has_data();
  }

  [[ nodiscard ]] int64_t& v24() const {
    ZX_ASSERT(has_v24());
    return frame_ptr_->v24_.get_data();
  }
  [[ nodiscard ]] bool has_v24() const {
    return max_ordinal_ >= 24 && frame_ptr_->v24_.has_data();
  }

  [[ nodiscard ]] int64_t& v25() const {
    ZX_ASSERT(has_v25());
    return frame_ptr_->v25_.get_data();
  }
  [[ nodiscard ]] bool has_v25() const {
    return max_ordinal_ >= 25 && frame_ptr_->v25_.has_data();
  }

  [[ nodiscard ]] int64_t& v26() const {
    ZX_ASSERT(has_v26());
    return frame_ptr_->v26_.get_data();
  }
  [[ nodiscard ]] bool has_v26() const {
    return max_ordinal_ >= 26 && frame_ptr_->v26_.has_data();
  }

  [[ nodiscard ]] int64_t& v27() const {
    ZX_ASSERT(has_v27());
    return frame_ptr_->v27_.get_data();
  }
  [[ nodiscard ]] bool has_v27() const {
    return max_ordinal_ >= 27 && frame_ptr_->v27_.has_data();
  }

  [[ nodiscard ]] int64_t& v28() const {
    ZX_ASSERT(has_v28());
    return frame_ptr_->v28_.get_data();
  }
  [[ nodiscard ]] bool has_v28() const {
    return max_ordinal_ >= 28 && frame_ptr_->v28_.has_data();
  }

  [[ nodiscard ]] int64_t& v29() const {
    ZX_ASSERT(has_v29());
    return frame_ptr_->v29_.get_data();
  }
  [[ nodiscard ]] bool has_v29() const {
    return max_ordinal_ >= 29 && frame_ptr_->v29_.has_data();
  }

  [[ nodiscard ]] int64_t& v30() const {
    ZX_ASSERT(has_v30());
    return frame_ptr_->v30_.get_data();
  }
  [[ nodiscard ]] bool has_v30() const {
    return max_ordinal_ >= 30 && frame_ptr_->v30_.has_data();
  }

  [[ nodiscard ]] int64_t& v31() const {
    ZX_ASSERT(has_v31());
    return frame_ptr_->v31_.get_data();
  }
  [[ nodiscard ]] bool has_v31() const {
    return max_ordinal_ >= 31 && frame_ptr_->v31_.has_data();
  }

  [[ nodiscard ]] int64_t& v32() const {
    ZX_ASSERT(has_v32());
    return frame_ptr_->v32_.get_data();
  }
  [[ nodiscard ]] bool has_v32() const {
    return max_ordinal_ >= 32 && frame_ptr_->v32_.has_data();
  }

  [[ nodiscard ]] int64_t& v33() const {
    ZX_ASSERT(has_v33());
    return frame_ptr_->v33_.get_data();
  }
  [[ nodiscard ]] bool has_v33() const {
    return max_ordinal_ >= 33 && frame_ptr_->v33_.has_data();
  }

  [[ nodiscard ]] int64_t& v34() const {
    ZX_ASSERT(has_v34());
    return frame_ptr_->v34_.get_data();
  }
  [[ nodiscard ]] bool has_v34() const {
    return max_ordinal_ >= 34 && frame_ptr_->v34_.has_data();
  }

  [[ nodiscard ]] int64_t& v35() const {
    ZX_ASSERT(has_v35());
    return frame_ptr_->v35_.get_data();
  }
  [[ nodiscard ]] bool has_v35() const {
    return max_ordinal_ >= 35 && frame_ptr_->v35_.has_data();
  }

  [[ nodiscard ]] int64_t& v36() const {
    ZX_ASSERT(has_v36());
    return frame_ptr_->v36_.get_data();
  }
  [[ nodiscard ]] bool has_v36() const {
    return max_ordinal_ >= 36 && frame_ptr_->v36_.has_data();
  }

  [[ nodiscard ]] int64_t& v37() const {
    ZX_ASSERT(has_v37());
    return frame_ptr_->v37_.get_data();
  }
  [[ nodiscard ]] bool has_v37() const {
    return max_ordinal_ >= 37 && frame_ptr_->v37_.has_data();
  }

  [[ nodiscard ]] int64_t& v38() const {
    ZX_ASSERT(has_v38());
    return frame_ptr_->v38_.get_data();
  }
  [[ nodiscard ]] bool has_v38() const {
    return max_ordinal_ >= 38 && frame_ptr_->v38_.has_data();
  }

  [[ nodiscard ]] int64_t& v39() const {
    ZX_ASSERT(has_v39());
    return frame_ptr_->v39_.get_data();
  }
  [[ nodiscard ]] bool has_v39() const {
    return max_ordinal_ >= 39 && frame_ptr_->v39_.has_data();
  }

  [[ nodiscard ]] int64_t& v40() const {
    ZX_ASSERT(has_v40());
    return frame_ptr_->v40_.get_data();
  }
  [[ nodiscard ]] bool has_v40() const {
    return max_ordinal_ >= 40 && frame_ptr_->v40_.has_data();
  }

  [[ nodiscard ]] int64_t& v41() const {
    ZX_ASSERT(has_v41());
    return frame_ptr_->v41_.get_data();
  }
  [[ nodiscard ]] bool has_v41() const {
    return max_ordinal_ >= 41 && frame_ptr_->v41_.has_data();
  }

  [[ nodiscard ]] int64_t& v42() const {
    ZX_ASSERT(has_v42());
    return frame_ptr_->v42_.get_data();
  }
  [[ nodiscard ]] bool has_v42() const {
    return max_ordinal_ >= 42 && frame_ptr_->v42_.has_data();
  }

  [[ nodiscard ]] int64_t& v43() const {
    ZX_ASSERT(has_v43());
    return frame_ptr_->v43_.get_data();
  }
  [[ nodiscard ]] bool has_v43() const {
    return max_ordinal_ >= 43 && frame_ptr_->v43_.has_data();
  }

  [[ nodiscard ]] int64_t& v44() const {
    ZX_ASSERT(has_v44());
    return frame_ptr_->v44_.get_data();
  }
  [[ nodiscard ]] bool has_v44() const {
    return max_ordinal_ >= 44 && frame_ptr_->v44_.has_data();
  }

  [[ nodiscard ]] int64_t& v45() const {
    ZX_ASSERT(has_v45());
    return frame_ptr_->v45_.get_data();
  }
  [[ nodiscard ]] bool has_v45() const {
    return max_ordinal_ >= 45 && frame_ptr_->v45_.has_data();
  }

  [[ nodiscard ]] int64_t& v46() const {
    ZX_ASSERT(has_v46());
    return frame_ptr_->v46_.get_data();
  }
  [[ nodiscard ]] bool has_v46() const {
    return max_ordinal_ >= 46 && frame_ptr_->v46_.has_data();
  }

  [[ nodiscard ]] int64_t& v47() const {
    ZX_ASSERT(has_v47());
    return frame_ptr_->v47_.get_data();
  }
  [[ nodiscard ]] bool has_v47() const {
    return max_ordinal_ >= 47 && frame_ptr_->v47_.has_data();
  }

  [[ nodiscard ]] int64_t& v48() const {
    ZX_ASSERT(has_v48());
    return frame_ptr_->v48_.get_data();
  }
  [[ nodiscard ]] bool has_v48() const {
    return max_ordinal_ >= 48 && frame_ptr_->v48_.has_data();
  }

  [[ nodiscard ]] int64_t& v49() const {
    ZX_ASSERT(has_v49());
    return frame_ptr_->v49_.get_data();
  }
  [[ nodiscard ]] bool has_v49() const {
    return max_ordinal_ >= 49 && frame_ptr_->v49_.has_data();
  }

  [[ nodiscard ]] int64_t& v50() const {
    ZX_ASSERT(has_v50());
    return frame_ptr_->v50_.get_data();
  }
  [[ nodiscard ]] bool has_v50() const {
    return max_ordinal_ >= 50 && frame_ptr_->v50_.has_data();
  }

  [[ nodiscard ]] int64_t& v51() const {
    ZX_ASSERT(has_v51());
    return frame_ptr_->v51_.get_data();
  }
  [[ nodiscard ]] bool has_v51() const {
    return max_ordinal_ >= 51 && frame_ptr_->v51_.has_data();
  }

  [[ nodiscard ]] int64_t& v52() const {
    ZX_ASSERT(has_v52());
    return frame_ptr_->v52_.get_data();
  }
  [[ nodiscard ]] bool has_v52() const {
    return max_ordinal_ >= 52 && frame_ptr_->v52_.has_data();
  }

  [[ nodiscard ]] int64_t& v53() const {
    ZX_ASSERT(has_v53());
    return frame_ptr_->v53_.get_data();
  }
  [[ nodiscard ]] bool has_v53() const {
    return max_ordinal_ >= 53 && frame_ptr_->v53_.has_data();
  }

  [[ nodiscard ]] int64_t& v54() const {
    ZX_ASSERT(has_v54());
    return frame_ptr_->v54_.get_data();
  }
  [[ nodiscard ]] bool has_v54() const {
    return max_ordinal_ >= 54 && frame_ptr_->v54_.has_data();
  }

  [[ nodiscard ]] int64_t& v55() const {
    ZX_ASSERT(has_v55());
    return frame_ptr_->v55_.get_data();
  }
  [[ nodiscard ]] bool has_v55() const {
    return max_ordinal_ >= 55 && frame_ptr_->v55_.has_data();
  }

  [[ nodiscard ]] int64_t& v56() const {
    ZX_ASSERT(has_v56());
    return frame_ptr_->v56_.get_data();
  }
  [[ nodiscard ]] bool has_v56() const {
    return max_ordinal_ >= 56 && frame_ptr_->v56_.has_data();
  }

  [[ nodiscard ]] int64_t& v57() const {
    ZX_ASSERT(has_v57());
    return frame_ptr_->v57_.get_data();
  }
  [[ nodiscard ]] bool has_v57() const {
    return max_ordinal_ >= 57 && frame_ptr_->v57_.has_data();
  }

  [[ nodiscard ]] int64_t& v58() const {
    ZX_ASSERT(has_v58());
    return frame_ptr_->v58_.get_data();
  }
  [[ nodiscard ]] bool has_v58() const {
    return max_ordinal_ >= 58 && frame_ptr_->v58_.has_data();
  }

  [[ nodiscard ]] int64_t& v59() const {
    ZX_ASSERT(has_v59());
    return frame_ptr_->v59_.get_data();
  }
  [[ nodiscard ]] bool has_v59() const {
    return max_ordinal_ >= 59 && frame_ptr_->v59_.has_data();
  }

  [[ nodiscard ]] int64_t& v60() const {
    ZX_ASSERT(has_v60());
    return frame_ptr_->v60_.get_data();
  }
  [[ nodiscard ]] bool has_v60() const {
    return max_ordinal_ >= 60 && frame_ptr_->v60_.has_data();
  }

  [[ nodiscard ]] int64_t& v61() const {
    ZX_ASSERT(has_v61());
    return frame_ptr_->v61_.get_data();
  }
  [[ nodiscard ]] bool has_v61() const {
    return max_ordinal_ >= 61 && frame_ptr_->v61_.has_data();
  }

  [[ nodiscard ]] int64_t& v62() const {
    ZX_ASSERT(has_v62());
    return frame_ptr_->v62_.get_data();
  }
  [[ nodiscard ]] bool has_v62() const {
    return max_ordinal_ >= 62 && frame_ptr_->v62_.has_data();
  }

  [[ nodiscard ]] int64_t& v63() const {
    ZX_ASSERT(has_v63());
    return frame_ptr_->v63_.get_data();
  }
  [[ nodiscard ]] bool has_v63() const {
    return max_ordinal_ >= 63 && frame_ptr_->v63_.has_data();
  }

  [[ nodiscard ]] ::test_table::wire::ExtensionTable& v64() const {
    ZX_ASSERT(has_v64());
    return frame_ptr_->v64_.get_data();
  }
  [[ nodiscard ]] bool has_v64() const {
    return max_ordinal_ >= 64 && frame_ptr_->v64_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  SixtyFourOrdinalTable& set_v1(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v1_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }
  SixtyFourOrdinalTable& set_v1(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v1_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v1(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v1_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v1() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v1_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v2(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v2_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(2));
    return *this;
  }
  SixtyFourOrdinalTable& set_v2(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v2_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v2(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v2_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(2));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v2() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v2_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v3(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v3_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(3));
    return *this;
  }
  SixtyFourOrdinalTable& set_v3(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v3_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v3(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v3_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(3));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v3() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v3_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v4(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v4_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(4));
    return *this;
  }
  SixtyFourOrdinalTable& set_v4(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v4_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v4(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v4_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(4));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v4() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v4_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v5(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v5_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(5));
    return *this;
  }
  SixtyFourOrdinalTable& set_v5(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v5_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v5(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v5_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(5));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v5() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v5_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v6(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v6_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(6));
    return *this;
  }
  SixtyFourOrdinalTable& set_v6(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v6_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v6(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v6_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(6));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v6() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v6_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v7(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v7_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(7));
    return *this;
  }
  SixtyFourOrdinalTable& set_v7(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v7_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v7(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v7_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(7));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v7() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v7_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v8(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v8_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(8));
    return *this;
  }
  SixtyFourOrdinalTable& set_v8(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v8_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v8(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v8_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(8));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v8() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v8_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v9(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v9_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(9));
    return *this;
  }
  SixtyFourOrdinalTable& set_v9(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v9_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v9(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v9_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(9));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v9() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v9_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v10(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v10_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(10));
    return *this;
  }
  SixtyFourOrdinalTable& set_v10(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v10_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v10(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v10_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(10));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v10() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v10_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v11(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v11_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(11));
    return *this;
  }
  SixtyFourOrdinalTable& set_v11(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v11_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v11(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v11_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(11));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v11() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v11_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v12(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v12_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(12));
    return *this;
  }
  SixtyFourOrdinalTable& set_v12(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v12_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v12(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v12_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(12));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v12() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v12_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v13(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v13_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(13));
    return *this;
  }
  SixtyFourOrdinalTable& set_v13(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v13_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v13(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v13_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(13));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v13() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v13_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v14(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v14_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(14));
    return *this;
  }
  SixtyFourOrdinalTable& set_v14(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v14_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v14(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v14_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(14));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v14() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v14_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v15(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v15_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(15));
    return *this;
  }
  SixtyFourOrdinalTable& set_v15(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v15_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v15(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v15_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(15));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v15() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v15_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v16(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v16_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(16));
    return *this;
  }
  SixtyFourOrdinalTable& set_v16(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v16_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v16(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v16_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(16));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v16() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v16_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v17(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v17_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(17));
    return *this;
  }
  SixtyFourOrdinalTable& set_v17(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v17_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v17(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v17_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(17));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v17() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v17_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v18(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v18_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(18));
    return *this;
  }
  SixtyFourOrdinalTable& set_v18(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v18_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v18(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v18_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(18));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v18() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v18_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v19(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v19_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(19));
    return *this;
  }
  SixtyFourOrdinalTable& set_v19(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v19_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v19(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v19_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(19));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v19() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v19_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v20(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v20_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(20));
    return *this;
  }
  SixtyFourOrdinalTable& set_v20(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v20_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v20(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v20_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(20));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v20() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v20_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v21(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v21_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(21));
    return *this;
  }
  SixtyFourOrdinalTable& set_v21(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v21_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v21(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v21_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(21));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v21() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v21_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v22(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v22_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(22));
    return *this;
  }
  SixtyFourOrdinalTable& set_v22(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v22_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v22(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v22_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(22));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v22() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v22_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v23(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v23_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(23));
    return *this;
  }
  SixtyFourOrdinalTable& set_v23(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v23_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v23(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v23_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(23));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v23() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v23_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v24(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v24_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(24));
    return *this;
  }
  SixtyFourOrdinalTable& set_v24(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v24_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v24(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v24_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(24));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v24() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v24_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v25(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v25_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(25));
    return *this;
  }
  SixtyFourOrdinalTable& set_v25(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v25_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v25(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v25_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(25));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v25() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v25_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v26(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v26_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(26));
    return *this;
  }
  SixtyFourOrdinalTable& set_v26(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v26_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v26(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v26_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(26));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v26() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v26_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v27(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v27_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(27));
    return *this;
  }
  SixtyFourOrdinalTable& set_v27(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v27_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v27(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v27_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(27));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v27() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v27_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v28(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v28_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(28));
    return *this;
  }
  SixtyFourOrdinalTable& set_v28(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v28_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v28(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v28_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(28));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v28() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v28_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v29(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v29_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(29));
    return *this;
  }
  SixtyFourOrdinalTable& set_v29(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v29_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v29(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v29_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(29));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v29() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v29_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v30(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v30_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(30));
    return *this;
  }
  SixtyFourOrdinalTable& set_v30(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v30_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v30(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v30_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(30));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v30() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v30_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v31(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v31_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(31));
    return *this;
  }
  SixtyFourOrdinalTable& set_v31(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v31_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v31(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v31_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(31));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v31() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v31_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v32(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v32_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(32));
    return *this;
  }
  SixtyFourOrdinalTable& set_v32(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v32_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v32(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v32_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(32));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v32() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v32_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v33(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v33_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(33));
    return *this;
  }
  SixtyFourOrdinalTable& set_v33(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v33_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v33(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v33_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(33));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v33() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v33_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v34(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v34_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(34));
    return *this;
  }
  SixtyFourOrdinalTable& set_v34(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v34_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v34(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v34_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(34));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v34() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v34_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v35(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v35_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(35));
    return *this;
  }
  SixtyFourOrdinalTable& set_v35(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v35_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v35(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v35_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(35));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v35() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v35_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v36(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v36_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(36));
    return *this;
  }
  SixtyFourOrdinalTable& set_v36(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v36_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v36(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v36_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(36));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v36() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v36_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v37(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v37_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(37));
    return *this;
  }
  SixtyFourOrdinalTable& set_v37(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v37_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v37(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v37_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(37));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v37() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v37_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v38(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v38_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(38));
    return *this;
  }
  SixtyFourOrdinalTable& set_v38(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v38_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v38(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v38_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(38));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v38() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v38_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v39(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v39_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(39));
    return *this;
  }
  SixtyFourOrdinalTable& set_v39(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v39_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v39(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v39_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(39));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v39() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v39_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v40(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v40_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(40));
    return *this;
  }
  SixtyFourOrdinalTable& set_v40(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v40_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v40(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v40_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(40));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v40() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v40_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v41(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v41_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(41));
    return *this;
  }
  SixtyFourOrdinalTable& set_v41(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v41_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v41(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v41_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(41));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v41() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v41_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v42(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v42_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(42));
    return *this;
  }
  SixtyFourOrdinalTable& set_v42(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v42_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v42(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v42_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(42));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v42() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v42_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v43(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v43_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(43));
    return *this;
  }
  SixtyFourOrdinalTable& set_v43(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v43_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v43(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v43_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(43));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v43() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v43_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v44(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v44_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(44));
    return *this;
  }
  SixtyFourOrdinalTable& set_v44(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v44_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v44(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v44_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(44));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v44() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v44_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v45(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v45_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(45));
    return *this;
  }
  SixtyFourOrdinalTable& set_v45(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v45_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v45(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v45_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(45));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v45() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v45_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v46(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v46_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(46));
    return *this;
  }
  SixtyFourOrdinalTable& set_v46(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v46_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v46(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v46_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(46));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v46() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v46_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v47(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v47_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(47));
    return *this;
  }
  SixtyFourOrdinalTable& set_v47(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v47_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v47(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v47_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(47));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v47() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v47_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v48(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v48_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(48));
    return *this;
  }
  SixtyFourOrdinalTable& set_v48(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v48_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v48(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v48_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(48));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v48() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v48_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v49(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v49_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(49));
    return *this;
  }
  SixtyFourOrdinalTable& set_v49(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v49_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v49(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v49_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(49));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v49() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v49_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v50(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v50_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(50));
    return *this;
  }
  SixtyFourOrdinalTable& set_v50(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v50_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v50(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v50_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(50));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v50() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v50_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v51(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v51_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(51));
    return *this;
  }
  SixtyFourOrdinalTable& set_v51(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v51_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v51(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v51_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(51));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v51() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v51_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v52(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v52_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(52));
    return *this;
  }
  SixtyFourOrdinalTable& set_v52(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v52_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v52(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v52_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(52));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v52() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v52_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v53(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v53_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(53));
    return *this;
  }
  SixtyFourOrdinalTable& set_v53(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v53_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v53(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v53_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(53));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v53() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v53_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v54(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v54_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(54));
    return *this;
  }
  SixtyFourOrdinalTable& set_v54(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v54_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v54(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v54_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(54));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v54() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v54_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v55(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v55_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(55));
    return *this;
  }
  SixtyFourOrdinalTable& set_v55(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v55_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v55(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v55_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(55));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v55() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v55_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v56(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v56_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(56));
    return *this;
  }
  SixtyFourOrdinalTable& set_v56(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v56_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v56(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v56_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(56));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v56() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v56_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v57(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v57_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(57));
    return *this;
  }
  SixtyFourOrdinalTable& set_v57(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v57_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v57(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v57_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(57));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v57() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v57_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v58(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v58_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(58));
    return *this;
  }
  SixtyFourOrdinalTable& set_v58(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v58_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v58(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v58_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(58));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v58() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v58_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v59(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v59_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(59));
    return *this;
  }
  SixtyFourOrdinalTable& set_v59(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v59_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v59(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v59_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(59));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v59() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v59_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v60(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v60_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(60));
    return *this;
  }
  SixtyFourOrdinalTable& set_v60(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v60_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v60(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v60_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(60));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v60() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v60_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v61(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v61_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(61));
    return *this;
  }
  SixtyFourOrdinalTable& set_v61(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v61_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v61(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v61_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(61));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v61() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v61_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v62(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v62_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(62));
    return *this;
  }
  SixtyFourOrdinalTable& set_v62(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v62_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v62(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v62_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(62));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v62() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v62_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v63(::fidl::ObjectView<int64_t> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v63_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(63));
    return *this;
  }
  SixtyFourOrdinalTable& set_v63(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v63_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v63(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v63_.set_data(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(63));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v63() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v63_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }
  SixtyFourOrdinalTable& set_v64(::fidl::ObjectView<::test_table::wire::ExtensionTable> elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v64_.set_data(elem);
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(64));
    return *this;
  }
  SixtyFourOrdinalTable& set_v64(std::nullptr_t) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v64_.set_data(nullptr);
    return *this;
  }
  template <typename... Args>
  SixtyFourOrdinalTable& set_v64(::fidl::AnyArena& allocator, Args&&... args) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v64_.set_data(
        ::fidl::ObjectView<::test_table::wire::ExtensionTable>(allocator, std::forward<Args>(args)...));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(64));
    return *this;
  }

  SixtyFourOrdinalTable& clear_v64() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->v64_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit SixtyFourOrdinalTable(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SixtyFourOrdinalTable>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit SixtyFourOrdinalTable(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SixtyFourOrdinalTable>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SixtyFourOrdinalTable>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SixtyFourOrdinalTable>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SixtyFourOrdinalTable, ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SixtyFourOrdinalTable, ::fidl::WireTableExternalBuilder<::test_table::wire::SixtyFourOrdinalTable>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SixtyFourOrdinalTable>> frame_ptr_;
};}  // namespace wire
}  // namespace test_table

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SixtyFourOrdinalTable, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_table::wire::SixtyFourOrdinalTable Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_table::wire::SixtyFourOrdinalTable t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_v1() const {
      return table_.has_v1();
    }

    // Clears the v1 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v1() {
      table_.clear_v1();
    }

    // Getter for v1.
    //
    
    [[ nodiscard ]] int64_t& v1() const {
      return table_.v1();
    }

    // Setter for v1.
    //
    
      BuilderImpl& v1(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v1_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v2() const {
      return table_.has_v2();
    }

    // Clears the v2 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v2() {
      table_.clear_v2();
    }

    // Getter for v2.
    //
    
    [[ nodiscard ]] int64_t& v2() const {
      return table_.v2();
    }

    // Setter for v2.
    //
    
      BuilderImpl& v2(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v2_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(2));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v3() const {
      return table_.has_v3();
    }

    // Clears the v3 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v3() {
      table_.clear_v3();
    }

    // Getter for v3.
    //
    
    [[ nodiscard ]] int64_t& v3() const {
      return table_.v3();
    }

    // Setter for v3.
    //
    
      BuilderImpl& v3(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v3_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(3));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v4() const {
      return table_.has_v4();
    }

    // Clears the v4 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v4() {
      table_.clear_v4();
    }

    // Getter for v4.
    //
    
    [[ nodiscard ]] int64_t& v4() const {
      return table_.v4();
    }

    // Setter for v4.
    //
    
      BuilderImpl& v4(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v4_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(4));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v5() const {
      return table_.has_v5();
    }

    // Clears the v5 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v5() {
      table_.clear_v5();
    }

    // Getter for v5.
    //
    
    [[ nodiscard ]] int64_t& v5() const {
      return table_.v5();
    }

    // Setter for v5.
    //
    
      BuilderImpl& v5(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v5_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(5));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v6() const {
      return table_.has_v6();
    }

    // Clears the v6 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v6() {
      table_.clear_v6();
    }

    // Getter for v6.
    //
    
    [[ nodiscard ]] int64_t& v6() const {
      return table_.v6();
    }

    // Setter for v6.
    //
    
      BuilderImpl& v6(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v6_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(6));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v7() const {
      return table_.has_v7();
    }

    // Clears the v7 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v7() {
      table_.clear_v7();
    }

    // Getter for v7.
    //
    
    [[ nodiscard ]] int64_t& v7() const {
      return table_.v7();
    }

    // Setter for v7.
    //
    
      BuilderImpl& v7(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v7_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(7));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v8() const {
      return table_.has_v8();
    }

    // Clears the v8 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v8() {
      table_.clear_v8();
    }

    // Getter for v8.
    //
    
    [[ nodiscard ]] int64_t& v8() const {
      return table_.v8();
    }

    // Setter for v8.
    //
    
      BuilderImpl& v8(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v8_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(8));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v9() const {
      return table_.has_v9();
    }

    // Clears the v9 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v9() {
      table_.clear_v9();
    }

    // Getter for v9.
    //
    
    [[ nodiscard ]] int64_t& v9() const {
      return table_.v9();
    }

    // Setter for v9.
    //
    
      BuilderImpl& v9(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v9_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(9));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v10() const {
      return table_.has_v10();
    }

    // Clears the v10 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v10() {
      table_.clear_v10();
    }

    // Getter for v10.
    //
    
    [[ nodiscard ]] int64_t& v10() const {
      return table_.v10();
    }

    // Setter for v10.
    //
    
      BuilderImpl& v10(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v10_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(10));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v11() const {
      return table_.has_v11();
    }

    // Clears the v11 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v11() {
      table_.clear_v11();
    }

    // Getter for v11.
    //
    
    [[ nodiscard ]] int64_t& v11() const {
      return table_.v11();
    }

    // Setter for v11.
    //
    
      BuilderImpl& v11(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v11_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(11));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v12() const {
      return table_.has_v12();
    }

    // Clears the v12 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v12() {
      table_.clear_v12();
    }

    // Getter for v12.
    //
    
    [[ nodiscard ]] int64_t& v12() const {
      return table_.v12();
    }

    // Setter for v12.
    //
    
      BuilderImpl& v12(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v12_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(12));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v13() const {
      return table_.has_v13();
    }

    // Clears the v13 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v13() {
      table_.clear_v13();
    }

    // Getter for v13.
    //
    
    [[ nodiscard ]] int64_t& v13() const {
      return table_.v13();
    }

    // Setter for v13.
    //
    
      BuilderImpl& v13(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v13_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(13));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v14() const {
      return table_.has_v14();
    }

    // Clears the v14 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v14() {
      table_.clear_v14();
    }

    // Getter for v14.
    //
    
    [[ nodiscard ]] int64_t& v14() const {
      return table_.v14();
    }

    // Setter for v14.
    //
    
      BuilderImpl& v14(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v14_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(14));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v15() const {
      return table_.has_v15();
    }

    // Clears the v15 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v15() {
      table_.clear_v15();
    }

    // Getter for v15.
    //
    
    [[ nodiscard ]] int64_t& v15() const {
      return table_.v15();
    }

    // Setter for v15.
    //
    
      BuilderImpl& v15(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v15_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(15));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v16() const {
      return table_.has_v16();
    }

    // Clears the v16 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v16() {
      table_.clear_v16();
    }

    // Getter for v16.
    //
    
    [[ nodiscard ]] int64_t& v16() const {
      return table_.v16();
    }

    // Setter for v16.
    //
    
      BuilderImpl& v16(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v16_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(16));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v17() const {
      return table_.has_v17();
    }

    // Clears the v17 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v17() {
      table_.clear_v17();
    }

    // Getter for v17.
    //
    
    [[ nodiscard ]] int64_t& v17() const {
      return table_.v17();
    }

    // Setter for v17.
    //
    
      BuilderImpl& v17(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v17_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(17));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v18() const {
      return table_.has_v18();
    }

    // Clears the v18 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v18() {
      table_.clear_v18();
    }

    // Getter for v18.
    //
    
    [[ nodiscard ]] int64_t& v18() const {
      return table_.v18();
    }

    // Setter for v18.
    //
    
      BuilderImpl& v18(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v18_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(18));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v19() const {
      return table_.has_v19();
    }

    // Clears the v19 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v19() {
      table_.clear_v19();
    }

    // Getter for v19.
    //
    
    [[ nodiscard ]] int64_t& v19() const {
      return table_.v19();
    }

    // Setter for v19.
    //
    
      BuilderImpl& v19(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v19_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(19));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v20() const {
      return table_.has_v20();
    }

    // Clears the v20 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v20() {
      table_.clear_v20();
    }

    // Getter for v20.
    //
    
    [[ nodiscard ]] int64_t& v20() const {
      return table_.v20();
    }

    // Setter for v20.
    //
    
      BuilderImpl& v20(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v20_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(20));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v21() const {
      return table_.has_v21();
    }

    // Clears the v21 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v21() {
      table_.clear_v21();
    }

    // Getter for v21.
    //
    
    [[ nodiscard ]] int64_t& v21() const {
      return table_.v21();
    }

    // Setter for v21.
    //
    
      BuilderImpl& v21(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v21_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(21));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v22() const {
      return table_.has_v22();
    }

    // Clears the v22 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v22() {
      table_.clear_v22();
    }

    // Getter for v22.
    //
    
    [[ nodiscard ]] int64_t& v22() const {
      return table_.v22();
    }

    // Setter for v22.
    //
    
      BuilderImpl& v22(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v22_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(22));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v23() const {
      return table_.has_v23();
    }

    // Clears the v23 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v23() {
      table_.clear_v23();
    }

    // Getter for v23.
    //
    
    [[ nodiscard ]] int64_t& v23() const {
      return table_.v23();
    }

    // Setter for v23.
    //
    
      BuilderImpl& v23(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v23_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(23));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v24() const {
      return table_.has_v24();
    }

    // Clears the v24 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v24() {
      table_.clear_v24();
    }

    // Getter for v24.
    //
    
    [[ nodiscard ]] int64_t& v24() const {
      return table_.v24();
    }

    // Setter for v24.
    //
    
      BuilderImpl& v24(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v24_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(24));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v25() const {
      return table_.has_v25();
    }

    // Clears the v25 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v25() {
      table_.clear_v25();
    }

    // Getter for v25.
    //
    
    [[ nodiscard ]] int64_t& v25() const {
      return table_.v25();
    }

    // Setter for v25.
    //
    
      BuilderImpl& v25(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v25_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(25));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v26() const {
      return table_.has_v26();
    }

    // Clears the v26 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v26() {
      table_.clear_v26();
    }

    // Getter for v26.
    //
    
    [[ nodiscard ]] int64_t& v26() const {
      return table_.v26();
    }

    // Setter for v26.
    //
    
      BuilderImpl& v26(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v26_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(26));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v27() const {
      return table_.has_v27();
    }

    // Clears the v27 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v27() {
      table_.clear_v27();
    }

    // Getter for v27.
    //
    
    [[ nodiscard ]] int64_t& v27() const {
      return table_.v27();
    }

    // Setter for v27.
    //
    
      BuilderImpl& v27(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v27_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(27));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v28() const {
      return table_.has_v28();
    }

    // Clears the v28 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v28() {
      table_.clear_v28();
    }

    // Getter for v28.
    //
    
    [[ nodiscard ]] int64_t& v28() const {
      return table_.v28();
    }

    // Setter for v28.
    //
    
      BuilderImpl& v28(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v28_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(28));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v29() const {
      return table_.has_v29();
    }

    // Clears the v29 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v29() {
      table_.clear_v29();
    }

    // Getter for v29.
    //
    
    [[ nodiscard ]] int64_t& v29() const {
      return table_.v29();
    }

    // Setter for v29.
    //
    
      BuilderImpl& v29(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v29_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(29));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v30() const {
      return table_.has_v30();
    }

    // Clears the v30 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v30() {
      table_.clear_v30();
    }

    // Getter for v30.
    //
    
    [[ nodiscard ]] int64_t& v30() const {
      return table_.v30();
    }

    // Setter for v30.
    //
    
      BuilderImpl& v30(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v30_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(30));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v31() const {
      return table_.has_v31();
    }

    // Clears the v31 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v31() {
      table_.clear_v31();
    }

    // Getter for v31.
    //
    
    [[ nodiscard ]] int64_t& v31() const {
      return table_.v31();
    }

    // Setter for v31.
    //
    
      BuilderImpl& v31(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v31_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(31));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v32() const {
      return table_.has_v32();
    }

    // Clears the v32 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v32() {
      table_.clear_v32();
    }

    // Getter for v32.
    //
    
    [[ nodiscard ]] int64_t& v32() const {
      return table_.v32();
    }

    // Setter for v32.
    //
    
      BuilderImpl& v32(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v32_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(32));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v33() const {
      return table_.has_v33();
    }

    // Clears the v33 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v33() {
      table_.clear_v33();
    }

    // Getter for v33.
    //
    
    [[ nodiscard ]] int64_t& v33() const {
      return table_.v33();
    }

    // Setter for v33.
    //
    
      BuilderImpl& v33(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v33_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(33));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v34() const {
      return table_.has_v34();
    }

    // Clears the v34 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v34() {
      table_.clear_v34();
    }

    // Getter for v34.
    //
    
    [[ nodiscard ]] int64_t& v34() const {
      return table_.v34();
    }

    // Setter for v34.
    //
    
      BuilderImpl& v34(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v34_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(34));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v35() const {
      return table_.has_v35();
    }

    // Clears the v35 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v35() {
      table_.clear_v35();
    }

    // Getter for v35.
    //
    
    [[ nodiscard ]] int64_t& v35() const {
      return table_.v35();
    }

    // Setter for v35.
    //
    
      BuilderImpl& v35(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v35_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(35));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v36() const {
      return table_.has_v36();
    }

    // Clears the v36 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v36() {
      table_.clear_v36();
    }

    // Getter for v36.
    //
    
    [[ nodiscard ]] int64_t& v36() const {
      return table_.v36();
    }

    // Setter for v36.
    //
    
      BuilderImpl& v36(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v36_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(36));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v37() const {
      return table_.has_v37();
    }

    // Clears the v37 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v37() {
      table_.clear_v37();
    }

    // Getter for v37.
    //
    
    [[ nodiscard ]] int64_t& v37() const {
      return table_.v37();
    }

    // Setter for v37.
    //
    
      BuilderImpl& v37(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v37_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(37));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v38() const {
      return table_.has_v38();
    }

    // Clears the v38 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v38() {
      table_.clear_v38();
    }

    // Getter for v38.
    //
    
    [[ nodiscard ]] int64_t& v38() const {
      return table_.v38();
    }

    // Setter for v38.
    //
    
      BuilderImpl& v38(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v38_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(38));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v39() const {
      return table_.has_v39();
    }

    // Clears the v39 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v39() {
      table_.clear_v39();
    }

    // Getter for v39.
    //
    
    [[ nodiscard ]] int64_t& v39() const {
      return table_.v39();
    }

    // Setter for v39.
    //
    
      BuilderImpl& v39(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v39_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(39));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v40() const {
      return table_.has_v40();
    }

    // Clears the v40 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v40() {
      table_.clear_v40();
    }

    // Getter for v40.
    //
    
    [[ nodiscard ]] int64_t& v40() const {
      return table_.v40();
    }

    // Setter for v40.
    //
    
      BuilderImpl& v40(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v40_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(40));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v41() const {
      return table_.has_v41();
    }

    // Clears the v41 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v41() {
      table_.clear_v41();
    }

    // Getter for v41.
    //
    
    [[ nodiscard ]] int64_t& v41() const {
      return table_.v41();
    }

    // Setter for v41.
    //
    
      BuilderImpl& v41(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v41_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(41));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v42() const {
      return table_.has_v42();
    }

    // Clears the v42 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v42() {
      table_.clear_v42();
    }

    // Getter for v42.
    //
    
    [[ nodiscard ]] int64_t& v42() const {
      return table_.v42();
    }

    // Setter for v42.
    //
    
      BuilderImpl& v42(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v42_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(42));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v43() const {
      return table_.has_v43();
    }

    // Clears the v43 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v43() {
      table_.clear_v43();
    }

    // Getter for v43.
    //
    
    [[ nodiscard ]] int64_t& v43() const {
      return table_.v43();
    }

    // Setter for v43.
    //
    
      BuilderImpl& v43(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v43_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(43));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v44() const {
      return table_.has_v44();
    }

    // Clears the v44 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v44() {
      table_.clear_v44();
    }

    // Getter for v44.
    //
    
    [[ nodiscard ]] int64_t& v44() const {
      return table_.v44();
    }

    // Setter for v44.
    //
    
      BuilderImpl& v44(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v44_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(44));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v45() const {
      return table_.has_v45();
    }

    // Clears the v45 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v45() {
      table_.clear_v45();
    }

    // Getter for v45.
    //
    
    [[ nodiscard ]] int64_t& v45() const {
      return table_.v45();
    }

    // Setter for v45.
    //
    
      BuilderImpl& v45(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v45_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(45));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v46() const {
      return table_.has_v46();
    }

    // Clears the v46 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v46() {
      table_.clear_v46();
    }

    // Getter for v46.
    //
    
    [[ nodiscard ]] int64_t& v46() const {
      return table_.v46();
    }

    // Setter for v46.
    //
    
      BuilderImpl& v46(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v46_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(46));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v47() const {
      return table_.has_v47();
    }

    // Clears the v47 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v47() {
      table_.clear_v47();
    }

    // Getter for v47.
    //
    
    [[ nodiscard ]] int64_t& v47() const {
      return table_.v47();
    }

    // Setter for v47.
    //
    
      BuilderImpl& v47(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v47_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(47));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v48() const {
      return table_.has_v48();
    }

    // Clears the v48 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v48() {
      table_.clear_v48();
    }

    // Getter for v48.
    //
    
    [[ nodiscard ]] int64_t& v48() const {
      return table_.v48();
    }

    // Setter for v48.
    //
    
      BuilderImpl& v48(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v48_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(48));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v49() const {
      return table_.has_v49();
    }

    // Clears the v49 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v49() {
      table_.clear_v49();
    }

    // Getter for v49.
    //
    
    [[ nodiscard ]] int64_t& v49() const {
      return table_.v49();
    }

    // Setter for v49.
    //
    
      BuilderImpl& v49(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v49_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(49));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v50() const {
      return table_.has_v50();
    }

    // Clears the v50 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v50() {
      table_.clear_v50();
    }

    // Getter for v50.
    //
    
    [[ nodiscard ]] int64_t& v50() const {
      return table_.v50();
    }

    // Setter for v50.
    //
    
      BuilderImpl& v50(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v50_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(50));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v51() const {
      return table_.has_v51();
    }

    // Clears the v51 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v51() {
      table_.clear_v51();
    }

    // Getter for v51.
    //
    
    [[ nodiscard ]] int64_t& v51() const {
      return table_.v51();
    }

    // Setter for v51.
    //
    
      BuilderImpl& v51(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v51_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(51));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v52() const {
      return table_.has_v52();
    }

    // Clears the v52 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v52() {
      table_.clear_v52();
    }

    // Getter for v52.
    //
    
    [[ nodiscard ]] int64_t& v52() const {
      return table_.v52();
    }

    // Setter for v52.
    //
    
      BuilderImpl& v52(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v52_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(52));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v53() const {
      return table_.has_v53();
    }

    // Clears the v53 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v53() {
      table_.clear_v53();
    }

    // Getter for v53.
    //
    
    [[ nodiscard ]] int64_t& v53() const {
      return table_.v53();
    }

    // Setter for v53.
    //
    
      BuilderImpl& v53(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v53_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(53));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v54() const {
      return table_.has_v54();
    }

    // Clears the v54 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v54() {
      table_.clear_v54();
    }

    // Getter for v54.
    //
    
    [[ nodiscard ]] int64_t& v54() const {
      return table_.v54();
    }

    // Setter for v54.
    //
    
      BuilderImpl& v54(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v54_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(54));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v55() const {
      return table_.has_v55();
    }

    // Clears the v55 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v55() {
      table_.clear_v55();
    }

    // Getter for v55.
    //
    
    [[ nodiscard ]] int64_t& v55() const {
      return table_.v55();
    }

    // Setter for v55.
    //
    
      BuilderImpl& v55(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v55_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(55));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v56() const {
      return table_.has_v56();
    }

    // Clears the v56 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v56() {
      table_.clear_v56();
    }

    // Getter for v56.
    //
    
    [[ nodiscard ]] int64_t& v56() const {
      return table_.v56();
    }

    // Setter for v56.
    //
    
      BuilderImpl& v56(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v56_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(56));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v57() const {
      return table_.has_v57();
    }

    // Clears the v57 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v57() {
      table_.clear_v57();
    }

    // Getter for v57.
    //
    
    [[ nodiscard ]] int64_t& v57() const {
      return table_.v57();
    }

    // Setter for v57.
    //
    
      BuilderImpl& v57(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v57_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(57));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v58() const {
      return table_.has_v58();
    }

    // Clears the v58 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v58() {
      table_.clear_v58();
    }

    // Getter for v58.
    //
    
    [[ nodiscard ]] int64_t& v58() const {
      return table_.v58();
    }

    // Setter for v58.
    //
    
      BuilderImpl& v58(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v58_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(58));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v59() const {
      return table_.has_v59();
    }

    // Clears the v59 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v59() {
      table_.clear_v59();
    }

    // Getter for v59.
    //
    
    [[ nodiscard ]] int64_t& v59() const {
      return table_.v59();
    }

    // Setter for v59.
    //
    
      BuilderImpl& v59(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v59_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(59));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v60() const {
      return table_.has_v60();
    }

    // Clears the v60 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v60() {
      table_.clear_v60();
    }

    // Getter for v60.
    //
    
    [[ nodiscard ]] int64_t& v60() const {
      return table_.v60();
    }

    // Setter for v60.
    //
    
      BuilderImpl& v60(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v60_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(60));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v61() const {
      return table_.has_v61();
    }

    // Clears the v61 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v61() {
      table_.clear_v61();
    }

    // Getter for v61.
    //
    
    [[ nodiscard ]] int64_t& v61() const {
      return table_.v61();
    }

    // Setter for v61.
    //
    
      BuilderImpl& v61(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v61_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(61));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v62() const {
      return table_.has_v62();
    }

    // Clears the v62 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v62() {
      table_.clear_v62();
    }

    // Getter for v62.
    //
    
    [[ nodiscard ]] int64_t& v62() const {
      return table_.v62();
    }

    // Setter for v62.
    //
    
      BuilderImpl& v62(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v62_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(62));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v63() const {
      return table_.has_v63();
    }

    // Clears the v63 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v63() {
      table_.clear_v63();
    }

    // Getter for v63.
    //
    
    [[ nodiscard ]] int64_t& v63() const {
      return table_.v63();
    }

    // Setter for v63.
    //
    
      BuilderImpl& v63(Wrapper_Ignore_Me_<::fidl::ObjectView<int64_t>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v63_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(63));
        return *static_cast<BuilderImpl*>(this);
      }
    [[ nodiscard ]] bool has_v64() const {
      return table_.has_v64();
    }

    // Clears the v64 field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_v64() {
      table_.clear_v64();
    }

    // Getter for v64.
    //
    
    [[ nodiscard ]] ::test_table::wire::ExtensionTable& v64() const {
      return table_.v64();
    }

    // Setter for v64.
    //
    
      BuilderImpl& v64(Wrapper_Ignore_Me_<::fidl::ObjectView<::test_table::wire::ExtensionTable>> elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
        table_.frame_ptr_->v64_.set_data(elem.value);
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(64));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SixtyFourOrdinalTable>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_table::wire::SixtyFourOrdinalTable table_;
};

template<>
class ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SixtyFourOrdinalTable, ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SixtyFourOrdinalTable, ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>>;

 public:
    using Base::v1;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v1(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v1(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v2;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v2(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v2(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v3;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v3(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v3(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v4;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v4(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v4(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v5;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v5(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v5(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v6;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v6(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v6(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v7;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v7(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v7(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v8;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v8(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v8(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v9;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v9(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v9(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v10;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v10(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v10(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v11;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v11(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v11(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v12;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v12(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v12(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v13;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v13(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v13(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v14;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v14(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v14(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v15;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v15(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v15(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v16;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v16(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v16(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v17;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v17(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v17(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v18;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v18(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v18(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v19;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v19(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v19(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v20;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v20(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v20(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v21;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v21(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v21(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v22;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v22(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v22(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v23;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v23(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v23(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v24;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v24(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v24(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v25;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v25(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v25(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v26;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v26(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v26(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v27;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v27(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v27(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v28;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v28(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v28(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v29;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v29(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v29(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v30;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v30(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v30(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v31;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v31(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v31(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v32;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v32(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v32(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v33;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v33(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v33(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v34;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v34(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v34(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v35;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v35(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v35(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v36;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v36(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v36(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v37;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v37(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v37(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v38;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v38(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v38(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v39;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v39(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v39(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v40;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v40(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v40(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v41;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v41(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v41(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v42;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v42(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v42(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v43;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v43(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v43(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v44;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v44(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v44(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v45;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v45(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v45(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v46;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v46(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v46(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v47;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v47(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v47(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v48;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v48(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v48(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v49;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v49(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v49(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v50;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v50(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v50(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v51;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v51(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v51(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v52;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v52(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v52(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v53;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v53(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v53(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v54;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v54(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v54(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v55;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v55(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v55(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v56;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v56(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v56(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v57;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v57(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v57(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v58;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v58(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v58(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v59;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v59(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v59(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v60;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v60(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v60(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v61;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v61(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v61(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v62;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v62(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v62(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v63;
    
      template <
          typename First = int64_t,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<int64_t>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v63(First&& first, Args&&... args_) {
        fidl::ObjectView<int64_t> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v63(Base::Wrapper_Ignore_Me_<fidl::ObjectView<int64_t>>(view_));
        return *this;
      }
    using Base::v64;
    
      template <
          typename First = ::test_table::wire::ExtensionTable,
          typename... Args,
          std::enable_if_t<!std::is_same_v<cpp20::remove_cvref_t<First>, fidl::ObjectView<::test_table::wire::ExtensionTable>>, int> = 0
      >
      ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>& v64(First&& first, Args&&... args_) {
        fidl::ObjectView<::test_table::wire::ExtensionTable> view_(arena_.get(), std::forward<First>(first), std::forward<Args>(args_)...);
        v64(Base::Wrapper_Ignore_Me_<fidl::ObjectView<::test_table::wire::ExtensionTable>>(view_));
        return *this;
      }
 private:
  friend class ::test_table::wire::SixtyFourOrdinalTable;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SixtyFourOrdinalTable>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_table::wire::SixtyFourOrdinalTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SixtyFourOrdinalTable, ::fidl::WireTableExternalBuilder<::test_table::wire::SixtyFourOrdinalTable>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_table::wire::SixtyFourOrdinalTable, ::fidl::WireTableExternalBuilder<::test_table::wire::SixtyFourOrdinalTable>>;

 private:
  friend class ::test_table::wire::SixtyFourOrdinalTable;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_table::wire::SixtyFourOrdinalTable>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SixtyFourOrdinalTable>>::FromExternal(frame)) {}
};namespace test_table {
namespace wire {

inline ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable> SixtyFourOrdinalTable::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_table::wire::SixtyFourOrdinalTable>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_table::wire::SixtyFourOrdinalTable> SixtyFourOrdinalTable::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_table::wire::SixtyFourOrdinalTable>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_table::wire::SixtyFourOrdinalTable>(std::move(frame));
}
  
  
  

  }  // namespace wire
}  // namespace test_table
namespace fidl {


  
  
  
  


template <>
struct TypeTraits<::test_table::wire::EmptyTable> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_table::wire::EmptyTable> : public std::true_type {};
template <>
struct IsTable<::test_table::wire::EmptyTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_table::wire::EmptyTable>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_table::wire::EmptyTable, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_table::wire::EmptyTable* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_table::wire::SimpleTable> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 56;
  static constexpr uint32_t kMaxOutOfLineV1 = 96;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_table::wire::SimpleTable> : public std::true_type {};
template <>
struct IsTable<::test_table::wire::SimpleTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_table::wire::SimpleTable>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_table::wire::SimpleTable, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_table::wire::SimpleTable* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 4:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 4:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 4:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 4:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_table::wire::OlderSimpleTable> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_table::wire::OlderSimpleTable> : public std::true_type {};
template <>
struct IsTable<::test_table::wire::OlderSimpleTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_table::wire::OlderSimpleTable>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_table::wire::OlderSimpleTable, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_table::wire::OlderSimpleTable* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_table::wire::NewerSimpleTable> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 72;
  static constexpr uint32_t kMaxOutOfLineV1 = 120;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_table::wire::NewerSimpleTable> : public std::true_type {};
template <>
struct IsTable<::test_table::wire::NewerSimpleTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_table::wire::NewerSimpleTable>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_table::wire::NewerSimpleTable, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_table::wire::NewerSimpleTable* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 4:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 5:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 4:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 5:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 4:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 5:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 4:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 5:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_table::wire::ReverseOrdinalTable> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 48;
  static constexpr uint32_t kMaxOutOfLineV1 = 72;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_table::wire::ReverseOrdinalTable> : public std::true_type {};
template <>
struct IsTable<::test_table::wire::ReverseOrdinalTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_table::wire::ReverseOrdinalTable>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_table::wire::ReverseOrdinalTable, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_table::wire::ReverseOrdinalTable* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 1:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 2:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 1:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 2:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 1:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 2:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 1:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 2:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_table::wire::TableWithAttributes> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_table::wire::TableWithAttributes> : public std::true_type {};
template <>
struct IsTable<::test_table::wire::TableWithAttributes> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_table::wire::TableWithAttributes>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_table::wire::TableWithAttributes, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_table::wire::TableWithAttributes* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_table::wire::ExtensionTable> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_table::wire::ExtensionTable> : public std::true_type {};
template <>
struct IsTable<::test_table::wire::ExtensionTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_table::wire::ExtensionTable>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_table::wire::ExtensionTable, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_table::wire::ExtensionTable* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_table::wire::SixtyFourOrdinalTable> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 1032;
  static constexpr uint32_t kMaxOutOfLineV1 = 1544;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_table::wire::SixtyFourOrdinalTable> : public std::true_type {};
template <>
struct IsTable<::test_table::wire::SixtyFourOrdinalTable> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_table::wire::SixtyFourOrdinalTable>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_table::wire::SixtyFourOrdinalTable, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_table::wire::SixtyFourOrdinalTable* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 1:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 2:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 3:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 4:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 5:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 6:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 7:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 8:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 9:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 10:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 11:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 12:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 13:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 14:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 15:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 16:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 17:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 18:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 19:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 20:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 21:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 22:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 23:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 24:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 25:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 26:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 27:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 28:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 29:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 30:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 31:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 32:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 33:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 34:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 35:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 36:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 37:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 38:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 39:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 40:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 41:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 42:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 43:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 44:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 45:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 46:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 47:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 48:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 49:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 50:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 51:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 52:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 53:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 54:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 55:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 56:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 57:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 58:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 59:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 60:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 61:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 62:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 63:
          encode_inline_size = ::fidl::internal::WireCodingTraits<::test_table::wire::ExtensionTable, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 1:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 2:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 3:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 4:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 5:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 6:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 7:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 8:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 9:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 10:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 11:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 12:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 13:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 14:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 15:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 16:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 17:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 18:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 19:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 20:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 21:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 22:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 23:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 24:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 25:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 26:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 27:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 28:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 29:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 30:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 31:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 32:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 33:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 34:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 35:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 36:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 37:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 38:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 39:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 40:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 41:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 42:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 43:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 44:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 45:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 46:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 47:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 48:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 49:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 50:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 51:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 52:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 53:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 54:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 55:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 56:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 57:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 58:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 59:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 60:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 61:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 62:
          encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 63:
          encode_fn = ::fidl::internal::MakeEncodeFn<::test_table::wire::ExtensionTable, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 1:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 2:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 3:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 4:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 5:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 6:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 7:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 8:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 9:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 10:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 11:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 12:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 13:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 14:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 15:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 16:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 17:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 18:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 19:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 20:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 21:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 22:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 23:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 24:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 25:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 26:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 27:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 28:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 29:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 30:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 31:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 32:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 33:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 34:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 35:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 36:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 37:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 38:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 39:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 40:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 41:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 42:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 43:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 44:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 45:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 46:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 47:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 48:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 49:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 50:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 51:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 52:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 53:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 54:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 55:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 56:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 57:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 58:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 59:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 60:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 61:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 62:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
        case 63:
          decode_inline_size = ::fidl::internal::WireCodingTraits<::test_table::wire::ExtensionTable, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 1:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 2:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 3:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 4:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 5:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 6:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 7:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 8:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 9:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 10:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 11:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 12:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 13:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 14:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 15:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 16:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 17:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 18:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 19:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 20:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 21:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 22:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 23:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 24:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 25:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 26:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 27:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 28:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 29:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 30:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 31:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 32:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 33:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 34:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 35:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 36:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 37:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 38:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 39:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 40:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 41:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 42:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 43:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 44:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 45:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 46:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 47:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 48:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 49:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 50:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 51:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 52:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 53:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 54:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 55:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 56:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 57:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 58:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 59:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 60:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 61:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 62:
          decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
        case 63:
          decode_fn = ::fidl::internal::MakeDecodeFn<::test_table::wire::ExtensionTable, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};
  

  #pragma clang diagnostic pop

  }  // namespace fidl

