// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

#pragma once

#include <fidl/test.typesinprotocols/cpp/markers.h>
#include <fidl/test.typesinprotocols/cpp/natural_types.h>
#include <fidl/test.typesinprotocols/cpp/wire_messaging.h>
#include <lib/fidl/cpp/channel.h>
#include <lib/fidl/cpp/client.h>
#include <lib/fidl/cpp/internal/thenable.h>
#include <lib/fidl/cpp/natural_types.h>
#include <lib/fidl/cpp/unified_messaging.h>
#include <lib/fidl/cpp/wire/unknown_interaction_handler.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace fidl {

}  // namespace fidl

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::OneWayBasic> {
  using Request = ::test_typesinprotocols::Basic;

  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::TwoWayBasic> {
  using Request = ::test_typesinprotocols::Basic;

  using Response = ::test_typesinprotocols::Basic;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayBasic>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::TwoWayBasic>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::ErrorBasic> {
  using Response = ::test_typesinprotocols::ProtocolErrorBasicTopResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorBasic>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::ErrorBasic>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::EventBasic> {
  using Request = ::test_typesinprotocols::Basic;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::OneWayCompound> {
  using Request = ::test_typesinprotocols::Compound;

  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::TwoWayCompound> {
  using Request = ::test_typesinprotocols::Compound;

  using Response = ::test_typesinprotocols::Compound;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayCompound>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::TwoWayCompound>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::ErrorCompound> {
  using Response = ::test_typesinprotocols::ProtocolErrorCompoundTopResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorCompound>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::ErrorCompound>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::EventCompound> {
  using Request = ::test_typesinprotocols::Compound;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::OneWayArrayBasic> {
  using Request = ::test_typesinprotocols::ArrayBasic;

  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::TwoWayArrayBasic> {
  using Request = ::test_typesinprotocols::ArrayBasic;

  using Response = ::test_typesinprotocols::ArrayBasic;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::TwoWayArrayBasic>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::ErrorArrayBasic> {
  using Response = ::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayBasic>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::ErrorArrayBasic>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::EventArrayBasic> {
  using Request = ::test_typesinprotocols::ArrayBasic;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::OneWayArrayCompound> {
  using Request = ::test_typesinprotocols::ArrayCompound;

  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::TwoWayArrayCompound> {
  using Request = ::test_typesinprotocols::ArrayCompound;

  using Response = ::test_typesinprotocols::ArrayCompound;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::TwoWayArrayCompound>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::ErrorArrayCompound> {
  using Response = ::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayCompound>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::ErrorArrayCompound>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::EventArrayCompound> {
  using Request = ::test_typesinprotocols::ArrayCompound;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::OneWayVectorBasic> {
  using Request = ::test_typesinprotocols::VectorBasic;

  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::TwoWayVectorBasic> {
  using Request = ::test_typesinprotocols::VectorBasic;

  using Response = ::test_typesinprotocols::VectorBasic;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::TwoWayVectorBasic>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::ErrorVectorBasic> {
  using Response = ::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorBasic>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::ErrorVectorBasic>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::EventVectorBasic> {
  using Request = ::test_typesinprotocols::VectorBasic;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::OneWayVectorCompound> {
  using Request = ::test_typesinprotocols::VectorCompound;

  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::TwoWayVectorCompound> {
  using Request = ::test_typesinprotocols::VectorCompound;

  using Response = ::test_typesinprotocols::VectorCompound;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::TwoWayVectorCompound>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::ErrorVectorCompound> {
  using Response = ::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorCompound>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::ErrorVectorCompound>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::EventVectorCompound> {
  using Request = ::test_typesinprotocols::VectorCompound;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::OneWayVectorOptional> {
  using Request = ::test_typesinprotocols::VectorOptional;

  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::TwoWayVectorOptional> {
  using Request = ::test_typesinprotocols::VectorOptional;

  using Response = ::test_typesinprotocols::VectorOptional;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::TwoWayVectorOptional>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::ErrorVectorOptional> {
  using Response = ::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorOptional>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::ErrorVectorOptional>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::EventVectorOptional> {
  using Request = ::test_typesinprotocols::VectorOptional;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> {
  using Request = ::test_typesinprotocols::ArrayVectorNested;

  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> {
  using Request = ::test_typesinprotocols::ArrayVectorNested;

  using Response = ::test_typesinprotocols::ArrayVectorNested;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> {
  using Response = ::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::EventArrayVectorNested> {
  using Request = ::test_typesinprotocols::ArrayVectorNested;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::OneWayResource> {
  using Request = ::test_typesinprotocols::Resource;

  using Completer = fidl::Completer<>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::TwoWayResource> {
  using Request = ::test_typesinprotocols::Resource;

  using Response = ::test_typesinprotocols::Resource;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayResource>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::TwoWayResource>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::ErrorResource> {
  using Response = ::test_typesinprotocols::ProtocolErrorResourceTopResponse;

  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorResource>>;
  using ResultCallback =
      ::fit::callback<void(::fidl::Result<::test_typesinprotocols::Protocol::ErrorResource>&)>;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<::test_typesinprotocols::Protocol::EventResource> {
  using Request = ::test_typesinprotocols::Resource;
};
namespace test_typesinprotocols {
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_BasicTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorBasicTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_CompoundTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorCompoundTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ArrayBasicTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayBasicTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ArrayCompoundTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayCompoundTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_VectorBasicTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorBasicTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_VectorCompoundTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorCompoundTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_VectorOptionalTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorOptionalTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ArrayVectorNestedTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayVectorNestedTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ResourceTable;

__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorResourceTopResponseTable;

#ifdef __Fuchsia__
}  // namespace test_typesinprotocols

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayBasic> final : public ::test_typesinprotocols::Basic {
 public:
  using ::test_typesinprotocols::Basic::Basic;
  Response(::test_typesinprotocols::Basic v) : Basic(std::move(v)) {}
};
namespace test_typesinprotocols {
}  // namespace test_typesinprotocols

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayBasic> final : public ::fit::result<::fidl::Error, ::test_typesinprotocols::Basic> {
 public:
  using ::fit::result<::fidl::Error, ::test_typesinprotocols::Basic>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::ErrorBasic> final : public ::fit::result<uint32_t, ::test_typesinprotocols::Basic> {
 public:
  using ::fit::result<uint32_t, ::test_typesinprotocols::Basic>::result;
  Response(::fit::result<uint32_t, ::test_typesinprotocols::Basic> v) : result(std::move(v)) {}
  Response() = delete;
};
template <>
class ::fidl::internal::ResponseMessageConverter<::test_typesinprotocols::Protocol::ErrorBasic> {
  using DomainObject = ::test_typesinprotocols::ProtocolErrorBasicTopResponse;

 public:
  static DomainObject IntoDomainObject(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorBasic>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorBasicResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorBasicResult::WithResponse(std::move(m.value()))}};
    }
  }
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::ErrorBasic> final : public ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorBasic>, ::test_typesinprotocols::Basic> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorBasic>, ::test_typesinprotocols::Basic>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayCompound> final : public ::test_typesinprotocols::Compound {
 public:
  using ::test_typesinprotocols::Compound::Compound;
  Response(::test_typesinprotocols::Compound v) : Compound(std::move(v)) {}
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayCompound> final : public ::fit::result<::fidl::Error, ::test_typesinprotocols::Compound> {
 public:
  using ::fit::result<::fidl::Error, ::test_typesinprotocols::Compound>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::ErrorCompound> final : public ::fit::result<uint32_t, ::test_typesinprotocols::Compound> {
 public:
  using ::fit::result<uint32_t, ::test_typesinprotocols::Compound>::result;
  Response(::fit::result<uint32_t, ::test_typesinprotocols::Compound> v) : result(std::move(v)) {}
  Response() = delete;
};
template <>
class ::fidl::internal::ResponseMessageConverter<::test_typesinprotocols::Protocol::ErrorCompound> {
  using DomainObject = ::test_typesinprotocols::ProtocolErrorCompoundTopResponse;

 public:
  static DomainObject IntoDomainObject(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorCompound>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorCompoundResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorCompoundResult::WithResponse(std::move(m.value()))}};
    }
  }
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::ErrorCompound> final : public ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorCompound>, ::test_typesinprotocols::Compound> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorCompound>, ::test_typesinprotocols::Compound>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayArrayBasic> final : public ::test_typesinprotocols::ArrayBasic {
 public:
  using ::test_typesinprotocols::ArrayBasic::ArrayBasic;
  Response(::test_typesinprotocols::ArrayBasic v) : ArrayBasic(std::move(v)) {}
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayArrayBasic> final : public ::fit::result<::fidl::Error, ::test_typesinprotocols::ArrayBasic> {
 public:
  using ::fit::result<::fidl::Error, ::test_typesinprotocols::ArrayBasic>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::ErrorArrayBasic> final : public ::fit::result<uint32_t, ::test_typesinprotocols::ArrayBasic> {
 public:
  using ::fit::result<uint32_t, ::test_typesinprotocols::ArrayBasic>::result;
  Response(::fit::result<uint32_t, ::test_typesinprotocols::ArrayBasic> v) : result(std::move(v)) {}
  Response() = delete;
};
template <>
class ::fidl::internal::ResponseMessageConverter<::test_typesinprotocols::Protocol::ErrorArrayBasic> {
  using DomainObject = ::test_typesinprotocols::ProtocolErrorArrayBasicTopResponse;

 public:
  static DomainObject IntoDomainObject(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorArrayBasic>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorArrayBasicResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorArrayBasicResult::WithResponse(std::move(m.value()))}};
    }
  }
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::ErrorArrayBasic> final : public ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::test_typesinprotocols::ArrayBasic> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::test_typesinprotocols::ArrayBasic>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayArrayCompound> final : public ::test_typesinprotocols::ArrayCompound {
 public:
  using ::test_typesinprotocols::ArrayCompound::ArrayCompound;
  Response(::test_typesinprotocols::ArrayCompound v) : ArrayCompound(std::move(v)) {}
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayArrayCompound> final : public ::fit::result<::fidl::Error, ::test_typesinprotocols::ArrayCompound> {
 public:
  using ::fit::result<::fidl::Error, ::test_typesinprotocols::ArrayCompound>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::ErrorArrayCompound> final : public ::fit::result<uint32_t, ::test_typesinprotocols::ArrayCompound> {
 public:
  using ::fit::result<uint32_t, ::test_typesinprotocols::ArrayCompound>::result;
  Response(::fit::result<uint32_t, ::test_typesinprotocols::ArrayCompound> v) : result(std::move(v)) {}
  Response() = delete;
};
template <>
class ::fidl::internal::ResponseMessageConverter<::test_typesinprotocols::Protocol::ErrorArrayCompound> {
  using DomainObject = ::test_typesinprotocols::ProtocolErrorArrayCompoundTopResponse;

 public:
  static DomainObject IntoDomainObject(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorArrayCompound>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::WithResponse(std::move(m.value()))}};
    }
  }
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::ErrorArrayCompound> final : public ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::test_typesinprotocols::ArrayCompound> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::test_typesinprotocols::ArrayCompound>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayVectorBasic> final : public ::test_typesinprotocols::VectorBasic {
 public:
  using ::test_typesinprotocols::VectorBasic::VectorBasic;
  Response(::test_typesinprotocols::VectorBasic v) : VectorBasic(std::move(v)) {}
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayVectorBasic> final : public ::fit::result<::fidl::Error, ::test_typesinprotocols::VectorBasic> {
 public:
  using ::fit::result<::fidl::Error, ::test_typesinprotocols::VectorBasic>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::ErrorVectorBasic> final : public ::fit::result<uint32_t, ::test_typesinprotocols::VectorBasic> {
 public:
  using ::fit::result<uint32_t, ::test_typesinprotocols::VectorBasic>::result;
  Response(::fit::result<uint32_t, ::test_typesinprotocols::VectorBasic> v) : result(std::move(v)) {}
  Response() = delete;
};
template <>
class ::fidl::internal::ResponseMessageConverter<::test_typesinprotocols::Protocol::ErrorVectorBasic> {
  using DomainObject = ::test_typesinprotocols::ProtocolErrorVectorBasicTopResponse;

 public:
  static DomainObject IntoDomainObject(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorVectorBasic>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorVectorBasicResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorVectorBasicResult::WithResponse(std::move(m.value()))}};
    }
  }
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::ErrorVectorBasic> final : public ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::test_typesinprotocols::VectorBasic> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::test_typesinprotocols::VectorBasic>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayVectorCompound> final : public ::test_typesinprotocols::VectorCompound {
 public:
  using ::test_typesinprotocols::VectorCompound::VectorCompound;
  Response(::test_typesinprotocols::VectorCompound v) : VectorCompound(std::move(v)) {}
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayVectorCompound> final : public ::fit::result<::fidl::Error, ::test_typesinprotocols::VectorCompound> {
 public:
  using ::fit::result<::fidl::Error, ::test_typesinprotocols::VectorCompound>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::ErrorVectorCompound> final : public ::fit::result<uint32_t, ::test_typesinprotocols::VectorCompound> {
 public:
  using ::fit::result<uint32_t, ::test_typesinprotocols::VectorCompound>::result;
  Response(::fit::result<uint32_t, ::test_typesinprotocols::VectorCompound> v) : result(std::move(v)) {}
  Response() = delete;
};
template <>
class ::fidl::internal::ResponseMessageConverter<::test_typesinprotocols::Protocol::ErrorVectorCompound> {
  using DomainObject = ::test_typesinprotocols::ProtocolErrorVectorCompoundTopResponse;

 public:
  static DomainObject IntoDomainObject(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorVectorCompound>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::WithResponse(std::move(m.value()))}};
    }
  }
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::ErrorVectorCompound> final : public ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::test_typesinprotocols::VectorCompound> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::test_typesinprotocols::VectorCompound>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayVectorOptional> final : public ::test_typesinprotocols::VectorOptional {
 public:
  using ::test_typesinprotocols::VectorOptional::VectorOptional;
  Response(::test_typesinprotocols::VectorOptional v) : VectorOptional(std::move(v)) {}
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayVectorOptional> final : public ::fit::result<::fidl::Error, ::test_typesinprotocols::VectorOptional> {
 public:
  using ::fit::result<::fidl::Error, ::test_typesinprotocols::VectorOptional>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::ErrorVectorOptional> final : public ::fit::result<uint32_t, ::test_typesinprotocols::VectorOptional> {
 public:
  using ::fit::result<uint32_t, ::test_typesinprotocols::VectorOptional>::result;
  Response(::fit::result<uint32_t, ::test_typesinprotocols::VectorOptional> v) : result(std::move(v)) {}
  Response() = delete;
};
template <>
class ::fidl::internal::ResponseMessageConverter<::test_typesinprotocols::Protocol::ErrorVectorOptional> {
  using DomainObject = ::test_typesinprotocols::ProtocolErrorVectorOptionalTopResponse;

 public:
  static DomainObject IntoDomainObject(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorVectorOptional>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::WithResponse(std::move(m.value()))}};
    }
  }
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::ErrorVectorOptional> final : public ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::test_typesinprotocols::VectorOptional> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::test_typesinprotocols::VectorOptional>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> final : public ::test_typesinprotocols::ArrayVectorNested {
 public:
  using ::test_typesinprotocols::ArrayVectorNested::ArrayVectorNested;
  Response(::test_typesinprotocols::ArrayVectorNested v) : ArrayVectorNested(std::move(v)) {}
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> final : public ::fit::result<::fidl::Error, ::test_typesinprotocols::ArrayVectorNested> {
 public:
  using ::fit::result<::fidl::Error, ::test_typesinprotocols::ArrayVectorNested>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> final : public ::fit::result<uint32_t, ::test_typesinprotocols::ArrayVectorNested> {
 public:
  using ::fit::result<uint32_t, ::test_typesinprotocols::ArrayVectorNested>::result;
  Response(::fit::result<uint32_t, ::test_typesinprotocols::ArrayVectorNested> v) : result(std::move(v)) {}
  Response() = delete;
};
template <>
class ::fidl::internal::ResponseMessageConverter<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> {
  using DomainObject = ::test_typesinprotocols::ProtocolErrorArrayVectorNestedTopResponse;

 public:
  static DomainObject IntoDomainObject(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::WithResponse(std::move(m.value()))}};
    }
  }
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> final : public ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::test_typesinprotocols::ArrayVectorNested> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::test_typesinprotocols::ArrayVectorNested>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayResource> final : public ::test_typesinprotocols::Resource {
 public:
  using ::test_typesinprotocols::Resource::Resource;
  Response(::test_typesinprotocols::Resource v) : Resource(std::move(v)) {}
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayResource> final : public ::fit::result<::fidl::Error, ::test_typesinprotocols::Resource> {
 public:
  using ::fit::result<::fidl::Error, ::test_typesinprotocols::Resource>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::Response<::test_typesinprotocols::Protocol::ErrorResource> final : public ::fit::result<uint32_t, ::test_typesinprotocols::Resource> {
 public:
  using ::fit::result<uint32_t, ::test_typesinprotocols::Resource>::result;
  Response(::fit::result<uint32_t, ::test_typesinprotocols::Resource> v) : result(std::move(v)) {}
  Response() = delete;
};
template <>
class ::fidl::internal::ResponseMessageConverter<::test_typesinprotocols::Protocol::ErrorResource> {
  using DomainObject = ::test_typesinprotocols::ProtocolErrorResourceTopResponse;

 public:
  static DomainObject IntoDomainObject(::fidl::Response<::test_typesinprotocols::Protocol::ErrorResource> m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorResourceResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_typesinprotocols::ProtocolErrorResourceResult::WithResponse(std::move(m.value()))}};
    }
  }
};

template <>
class ::fidl::Result<::test_typesinprotocols::Protocol::ErrorResource> final : public ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorResource>, ::test_typesinprotocols::Resource> {
 public:
  using ::fit::result<::fidl::ErrorsIn<::test_typesinprotocols::Protocol::ErrorResource>, ::test_typesinprotocols::Resource>::result;

 protected:
  Result() = default;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_typesinprotocols::Protocol> final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::TwoWayBasic> TwoWayBasic(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayBasic>& request) const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::ErrorBasic> ErrorBasic() const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::TwoWayCompound> TwoWayCompound(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayCompound>& request) const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::ErrorCompound> ErrorCompound() const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::TwoWayArrayBasic> TwoWayArrayBasic(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayArrayBasic>& request) const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::ErrorArrayBasic> ErrorArrayBasic() const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::TwoWayArrayCompound> TwoWayArrayCompound(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayArrayCompound>& request) const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::ErrorArrayCompound> ErrorArrayCompound() const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::TwoWayVectorBasic> TwoWayVectorBasic(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayVectorBasic>& request) const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::ErrorVectorBasic> ErrorVectorBasic() const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::TwoWayVectorCompound> TwoWayVectorCompound(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayVectorCompound>& request) const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::ErrorVectorCompound> ErrorVectorCompound() const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::TwoWayVectorOptional> TwoWayVectorOptional(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayVectorOptional>& request) const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::ErrorVectorOptional> ErrorVectorOptional() const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> TwoWayArrayVectorNested(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>& request) const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> ErrorArrayVectorNested() const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::TwoWayResource> TwoWayResource(::fidl::Request<::test_typesinprotocols::Protocol::TwoWayResource> request) const;

  ::fidl::internal::NaturalThenable<::test_typesinprotocols::Protocol::ErrorResource> ErrorResource() const;

  ::fit::result<::fidl::OneWayError> OneWayBasic(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayBasic>& request) const;

  ::fit::result<::fidl::OneWayError> OneWayCompound(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayCompound>& request) const;

  ::fit::result<::fidl::OneWayError> OneWayArrayBasic(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayArrayBasic>& request) const;

  ::fit::result<::fidl::OneWayError> OneWayArrayCompound(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayArrayCompound>& request) const;

  ::fit::result<::fidl::OneWayError> OneWayVectorBasic(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayVectorBasic>& request) const;

  ::fit::result<::fidl::OneWayError> OneWayVectorCompound(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayVectorCompound>& request) const;

  ::fit::result<::fidl::OneWayError> OneWayVectorOptional(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayVectorOptional>& request) const;

  ::fit::result<::fidl::OneWayError> OneWayArrayVectorNested(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>& request) const;

  ::fit::result<::fidl::OneWayError> OneWayResource(::fidl::Request<::test_typesinprotocols::Protocol::OneWayResource> request) const;
};
namespace test_typesinprotocols {

#endif  // __Fuchsia__

}  // namespace test_typesinprotocols

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalSyncClientImpl<::test_typesinprotocols::Protocol> final
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalSyncClientImpl<::test_typesinprotocols::Protocol>> {
 public:
  ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayBasic> TwoWayBasic(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayBasic>& request);

  ::fidl::Result<::test_typesinprotocols::Protocol::ErrorBasic> ErrorBasic();

  ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayCompound> TwoWayCompound(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayCompound>& request);

  ::fidl::Result<::test_typesinprotocols::Protocol::ErrorCompound> ErrorCompound();

  ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayArrayBasic> TwoWayArrayBasic(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayArrayBasic>& request);

  ::fidl::Result<::test_typesinprotocols::Protocol::ErrorArrayBasic> ErrorArrayBasic();

  ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayArrayCompound> TwoWayArrayCompound(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayArrayCompound>& request);

  ::fidl::Result<::test_typesinprotocols::Protocol::ErrorArrayCompound> ErrorArrayCompound();

  ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayVectorBasic> TwoWayVectorBasic(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayVectorBasic>& request);

  ::fidl::Result<::test_typesinprotocols::Protocol::ErrorVectorBasic> ErrorVectorBasic();

  ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayVectorCompound> TwoWayVectorCompound(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayVectorCompound>& request);

  ::fidl::Result<::test_typesinprotocols::Protocol::ErrorVectorCompound> ErrorVectorCompound();

  ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayVectorOptional> TwoWayVectorOptional(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayVectorOptional>& request);

  ::fidl::Result<::test_typesinprotocols::Protocol::ErrorVectorOptional> ErrorVectorOptional();

  ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> TwoWayArrayVectorNested(const ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>& request);

  ::fidl::Result<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> ErrorArrayVectorNested();

  ::fidl::Result<::test_typesinprotocols::Protocol::TwoWayResource> TwoWayResource(::fidl::Request<::test_typesinprotocols::Protocol::TwoWayResource> request);

  ::fidl::Result<::test_typesinprotocols::Protocol::ErrorResource> ErrorResource();

  ::fit::result<::fidl::OneWayError> OneWayBasic(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayBasic>& request);

  ::fit::result<::fidl::OneWayError> OneWayCompound(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayCompound>& request);

  ::fit::result<::fidl::OneWayError> OneWayArrayBasic(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayArrayBasic>& request);

  ::fit::result<::fidl::OneWayError> OneWayArrayCompound(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayArrayCompound>& request);

  ::fit::result<::fidl::OneWayError> OneWayVectorBasic(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayVectorBasic>& request);

  ::fit::result<::fidl::OneWayError> OneWayVectorCompound(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayVectorCompound>& request);

  ::fit::result<::fidl::OneWayError> OneWayVectorOptional(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayVectorOptional>& request);

  ::fit::result<::fidl::OneWayError> OneWayArrayVectorNested(const ::fidl::Request<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>& request);

  ::fit::result<::fidl::OneWayError> OneWayResource(::fidl::Request<::test_typesinprotocols::Protocol::OneWayResource> request);

 private:
  ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(
        _transport().get<::fidl::internal::ChannelTransport>());
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<::test_typesinprotocols::Protocol> : public ::fidl::internal::BaseEventHandlerInterface {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void EventBasic(::fidl::Event<::test_typesinprotocols::Protocol::EventBasic>&) = 0;
  virtual void EventCompound(::fidl::Event<::test_typesinprotocols::Protocol::EventCompound>&) = 0;
  virtual void EventArrayBasic(::fidl::Event<::test_typesinprotocols::Protocol::EventArrayBasic>&) = 0;
  virtual void EventArrayCompound(::fidl::Event<::test_typesinprotocols::Protocol::EventArrayCompound>&) = 0;
  virtual void EventVectorBasic(::fidl::Event<::test_typesinprotocols::Protocol::EventVectorBasic>&) = 0;
  virtual void EventVectorCompound(::fidl::Event<::test_typesinprotocols::Protocol::EventVectorCompound>&) = 0;
  virtual void EventVectorOptional(::fidl::Event<::test_typesinprotocols::Protocol::EventVectorOptional>&) = 0;
  virtual void EventArrayVectorNested(::fidl::Event<::test_typesinprotocols::Protocol::EventArrayVectorNested>&) = 0;
  virtual void EventResource(::fidl::Event<::test_typesinprotocols::Protocol::EventResource>&) = 0;
};

template <>
class ::fidl::AsyncEventHandler<::test_typesinprotocols::Protocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_typesinprotocols::Protocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
  void EventBasic(::fidl::Event<::test_typesinprotocols::Protocol::EventBasic>&) override {}
  void EventCompound(::fidl::Event<::test_typesinprotocols::Protocol::EventCompound>&) override {}
  void EventArrayBasic(::fidl::Event<::test_typesinprotocols::Protocol::EventArrayBasic>&) override {}
  void EventArrayCompound(::fidl::Event<::test_typesinprotocols::Protocol::EventArrayCompound>&) override {}
  void EventVectorBasic(::fidl::Event<::test_typesinprotocols::Protocol::EventVectorBasic>&) override {}
  void EventVectorCompound(::fidl::Event<::test_typesinprotocols::Protocol::EventVectorCompound>&) override {}
  void EventVectorOptional(::fidl::Event<::test_typesinprotocols::Protocol::EventVectorOptional>&) override {}
  void EventArrayVectorNested(::fidl::Event<::test_typesinprotocols::Protocol::EventArrayVectorNested>&) override {}
  void EventResource(::fidl::Event<::test_typesinprotocols::Protocol::EventResource>&) override {}
};

template <>
class ::fidl::SyncEventHandler<::test_typesinprotocols::Protocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<::test_typesinprotocols::Protocol>, public ::fidl::internal::SyncEventHandler {
 public:
  SyncEventHandler() = default;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method.
  ::fidl::Status HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end);
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_typesinprotocols::Protocol> final : public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::NaturalEventHandlerInterface<::test_typesinprotocols::Protocol>> {
 public:
  explicit NaturalEventDispatcher(::fidl::internal::NaturalEventHandlerInterface<::test_typesinprotocols::Protocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
  ::fidl::Status DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      internal::MessageStorageViewBase* storage_view) override;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_typesinprotocols::Protocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fit::result<::fidl::OneWayError> EventBasic(const ::test_typesinprotocols::Basic& payload);

  ::fit::result<::fidl::OneWayError> EventCompound(const ::test_typesinprotocols::Compound& payload);

  ::fit::result<::fidl::OneWayError> EventArrayBasic(const ::test_typesinprotocols::ArrayBasic& payload);

  ::fit::result<::fidl::OneWayError> EventArrayCompound(const ::test_typesinprotocols::ArrayCompound& payload);

  ::fit::result<::fidl::OneWayError> EventVectorBasic(const ::test_typesinprotocols::VectorBasic& payload);

  ::fit::result<::fidl::OneWayError> EventVectorCompound(const ::test_typesinprotocols::VectorCompound& payload);

  ::fit::result<::fidl::OneWayError> EventVectorOptional(const ::test_typesinprotocols::VectorOptional& payload);

  ::fit::result<::fidl::OneWayError> EventArrayVectorNested(const ::test_typesinprotocols::ArrayVectorNested& payload);

  ::fit::result<::fidl::OneWayError> EventResource(::test_typesinprotocols::Resource payload);
};

template <>
class ::fidl::internal::NaturalEventSender<::test_typesinprotocols::Protocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::NaturalEventSender<::test_typesinprotocols::Protocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fit::result<::fidl::OneWayError> EventBasic(const ::test_typesinprotocols::Basic& payload);

  ::fit::result<::fidl::OneWayError> EventCompound(const ::test_typesinprotocols::Compound& payload);

  ::fit::result<::fidl::OneWayError> EventArrayBasic(const ::test_typesinprotocols::ArrayBasic& payload);

  ::fit::result<::fidl::OneWayError> EventArrayCompound(const ::test_typesinprotocols::ArrayCompound& payload);

  ::fit::result<::fidl::OneWayError> EventVectorBasic(const ::test_typesinprotocols::VectorBasic& payload);

  ::fit::result<::fidl::OneWayError> EventVectorCompound(const ::test_typesinprotocols::VectorCompound& payload);

  ::fit::result<::fidl::OneWayError> EventVectorOptional(const ::test_typesinprotocols::VectorOptional& payload);

  ::fit::result<::fidl::OneWayError> EventArrayVectorNested(const ::test_typesinprotocols::ArrayVectorNested& payload);

  ::fit::result<::fidl::OneWayError> EventResource(::test_typesinprotocols::Resource payload);
};

#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayBasic> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayBasic>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorBasic> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorBasic>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayCompound> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayCompound>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorCompound> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorCompound>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayBasic> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayArrayBasic>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayBasic> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorArrayBasic>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayCompound> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayArrayCompound>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayCompound> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorArrayCompound>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorBasic> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayVectorBasic>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorBasic> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorVectorBasic>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorCompound> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayVectorCompound>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorCompound> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorVectorCompound>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorOptional> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayVectorOptional>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorOptional> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorVectorOptional>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> : public ::fidl::CompleterBase {
 public:
  void Reply(const ::fidl::Response<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::TwoWayResource> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_typesinprotocols::Protocol::TwoWayResource> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<::test_typesinprotocols::Protocol::ErrorResource> : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_typesinprotocols::Protocol::ErrorResource> response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_typesinprotocols::Protocol> : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_typesinprotocols::Protocol;

  using Handler = fidl::ProtocolHandler<::test_typesinprotocols::Protocol>;

  using OneWayBasicRequest = ::fidl::Request<::test_typesinprotocols::Protocol::OneWayBasic>;
  using OneWayBasicCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::OneWayBasic>;

  virtual void OneWayBasic(OneWayBasicRequest& request,
                           OneWayBasicCompleter::Sync& completer) = 0;

  using TwoWayBasicRequest = ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayBasic>;
  using TwoWayBasicCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::TwoWayBasic>;

  virtual void TwoWayBasic(TwoWayBasicRequest& request,
                           TwoWayBasicCompleter::Sync& completer) = 0;

  using ErrorBasicCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::ErrorBasic>;

  virtual void ErrorBasic(
      ErrorBasicCompleter::Sync& completer) = 0;

  using OneWayCompoundRequest = ::fidl::Request<::test_typesinprotocols::Protocol::OneWayCompound>;
  using OneWayCompoundCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::OneWayCompound>;

  virtual void OneWayCompound(OneWayCompoundRequest& request,
                              OneWayCompoundCompleter::Sync& completer) = 0;

  using TwoWayCompoundRequest = ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayCompound>;
  using TwoWayCompoundCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::TwoWayCompound>;

  virtual void TwoWayCompound(TwoWayCompoundRequest& request,
                              TwoWayCompoundCompleter::Sync& completer) = 0;

  using ErrorCompoundCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::ErrorCompound>;

  virtual void ErrorCompound(
      ErrorCompoundCompleter::Sync& completer) = 0;

  using OneWayArrayBasicRequest = ::fidl::Request<::test_typesinprotocols::Protocol::OneWayArrayBasic>;
  using OneWayArrayBasicCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::OneWayArrayBasic>;

  virtual void OneWayArrayBasic(OneWayArrayBasicRequest& request,
                                OneWayArrayBasicCompleter::Sync& completer) = 0;

  using TwoWayArrayBasicRequest = ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayArrayBasic>;
  using TwoWayArrayBasicCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::TwoWayArrayBasic>;

  virtual void TwoWayArrayBasic(TwoWayArrayBasicRequest& request,
                                TwoWayArrayBasicCompleter::Sync& completer) = 0;

  using ErrorArrayBasicCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::ErrorArrayBasic>;

  virtual void ErrorArrayBasic(
      ErrorArrayBasicCompleter::Sync& completer) = 0;

  using OneWayArrayCompoundRequest = ::fidl::Request<::test_typesinprotocols::Protocol::OneWayArrayCompound>;
  using OneWayArrayCompoundCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::OneWayArrayCompound>;

  virtual void OneWayArrayCompound(OneWayArrayCompoundRequest& request,
                                   OneWayArrayCompoundCompleter::Sync& completer) = 0;

  using TwoWayArrayCompoundRequest = ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayArrayCompound>;
  using TwoWayArrayCompoundCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::TwoWayArrayCompound>;

  virtual void TwoWayArrayCompound(TwoWayArrayCompoundRequest& request,
                                   TwoWayArrayCompoundCompleter::Sync& completer) = 0;

  using ErrorArrayCompoundCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::ErrorArrayCompound>;

  virtual void ErrorArrayCompound(
      ErrorArrayCompoundCompleter::Sync& completer) = 0;

  using OneWayVectorBasicRequest = ::fidl::Request<::test_typesinprotocols::Protocol::OneWayVectorBasic>;
  using OneWayVectorBasicCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::OneWayVectorBasic>;

  virtual void OneWayVectorBasic(OneWayVectorBasicRequest& request,
                                 OneWayVectorBasicCompleter::Sync& completer) = 0;

  using TwoWayVectorBasicRequest = ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayVectorBasic>;
  using TwoWayVectorBasicCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::TwoWayVectorBasic>;

  virtual void TwoWayVectorBasic(TwoWayVectorBasicRequest& request,
                                 TwoWayVectorBasicCompleter::Sync& completer) = 0;

  using ErrorVectorBasicCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::ErrorVectorBasic>;

  virtual void ErrorVectorBasic(
      ErrorVectorBasicCompleter::Sync& completer) = 0;

  using OneWayVectorCompoundRequest = ::fidl::Request<::test_typesinprotocols::Protocol::OneWayVectorCompound>;
  using OneWayVectorCompoundCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::OneWayVectorCompound>;

  virtual void OneWayVectorCompound(OneWayVectorCompoundRequest& request,
                                    OneWayVectorCompoundCompleter::Sync& completer) = 0;

  using TwoWayVectorCompoundRequest = ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayVectorCompound>;
  using TwoWayVectorCompoundCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::TwoWayVectorCompound>;

  virtual void TwoWayVectorCompound(TwoWayVectorCompoundRequest& request,
                                    TwoWayVectorCompoundCompleter::Sync& completer) = 0;

  using ErrorVectorCompoundCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::ErrorVectorCompound>;

  virtual void ErrorVectorCompound(
      ErrorVectorCompoundCompleter::Sync& completer) = 0;

  using OneWayVectorOptionalRequest = ::fidl::Request<::test_typesinprotocols::Protocol::OneWayVectorOptional>;
  using OneWayVectorOptionalCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::OneWayVectorOptional>;

  virtual void OneWayVectorOptional(OneWayVectorOptionalRequest& request,
                                    OneWayVectorOptionalCompleter::Sync& completer) = 0;

  using TwoWayVectorOptionalRequest = ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayVectorOptional>;
  using TwoWayVectorOptionalCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::TwoWayVectorOptional>;

  virtual void TwoWayVectorOptional(TwoWayVectorOptionalRequest& request,
                                    TwoWayVectorOptionalCompleter::Sync& completer) = 0;

  using ErrorVectorOptionalCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::ErrorVectorOptional>;

  virtual void ErrorVectorOptional(
      ErrorVectorOptionalCompleter::Sync& completer) = 0;

  using OneWayArrayVectorNestedRequest = ::fidl::Request<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>;
  using OneWayArrayVectorNestedCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>;

  virtual void OneWayArrayVectorNested(OneWayArrayVectorNestedRequest& request,
                                       OneWayArrayVectorNestedCompleter::Sync& completer) = 0;

  using TwoWayArrayVectorNestedRequest = ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>;
  using TwoWayArrayVectorNestedCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>;

  virtual void TwoWayArrayVectorNested(TwoWayArrayVectorNestedRequest& request,
                                       TwoWayArrayVectorNestedCompleter::Sync& completer) = 0;

  using ErrorArrayVectorNestedCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>;

  virtual void ErrorArrayVectorNested(
      ErrorArrayVectorNestedCompleter::Sync& completer) = 0;

  using OneWayResourceRequest = ::fidl::Request<::test_typesinprotocols::Protocol::OneWayResource>;
  using OneWayResourceCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::OneWayResource>;

  virtual void OneWayResource(OneWayResourceRequest& request,
                              OneWayResourceCompleter::Sync& completer) = 0;

  using TwoWayResourceRequest = ::fidl::Request<::test_typesinprotocols::Protocol::TwoWayResource>;
  using TwoWayResourceCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::TwoWayResource>;

  virtual void TwoWayResource(TwoWayResourceRequest& request,
                              TwoWayResourceCompleter::Sync& completer) = 0;

  using ErrorResourceCompleter = ::fidl::internal::NaturalCompleter<::test_typesinprotocols::Protocol::ErrorResource>;

  virtual void ErrorResource(
      ErrorResourceCompleter::Sync& completer) = 0;

  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher) {
    return [impl = this, dispatcher = dispatcher](::fidl::ServerEnd<::test_typesinprotocols::Protocol> request) {
      (void)::fidl::BindServer(dispatcher, std::move(request), impl);
    };
  }

 private:
  void dispatch_message(
      ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_typesinprotocols::Protocol> final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_typesinprotocols::Protocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

#endif  // __Fuchsia__

#pragma clang diagnostic pop
