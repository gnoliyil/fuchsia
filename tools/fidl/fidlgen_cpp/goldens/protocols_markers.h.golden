// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include <lib/fidl/cpp/wire/internal/transport.h>
#include <lib/fidl/cpp/wire/unknown_interactions.h>

namespace test_protocols {

class WithAndWithoutRequestResponse final {
  WithAndWithoutRequestResponse() = delete;

 public:
  using Transport = ::fidl::internal::ChannelTransport;

  static constexpr ::fidl::internal::Openness kOpenness = ::fidl::internal::Openness::kClosed;

  class NoRequestNoResponse final {
    NoRequestNoResponse() = delete;

   public:
    using Protocol = ::test_protocols::WithAndWithoutRequestResponse;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = false;
    static constexpr bool kHasServerToClient = false;
    static constexpr bool kHasServerToClientBody = false;

    static constexpr bool kHasNonEmptyUserFacingResponse = false;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class NoRequestEmptyResponse final {
    NoRequestEmptyResponse() = delete;

   public:
    using Protocol = ::test_protocols::WithAndWithoutRequestResponse;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = false;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = false;

    static constexpr bool kHasNonEmptyUserFacingResponse = false;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class NoRequestWithResponse final {
    NoRequestWithResponse() = delete;

   public:
    using Protocol = ::test_protocols::WithAndWithoutRequestResponse;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = false;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class WithRequestNoResponse final {
    WithRequestNoResponse() = delete;

   public:
    using Protocol = ::test_protocols::WithAndWithoutRequestResponse;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = false;
    static constexpr bool kHasServerToClientBody = false;

    static constexpr bool kHasNonEmptyUserFacingResponse = false;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class WithRequestEmptyResponse final {
    WithRequestEmptyResponse() = delete;

   public:
    using Protocol = ::test_protocols::WithAndWithoutRequestResponse;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = false;

    static constexpr bool kHasNonEmptyUserFacingResponse = false;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class WithRequestWithResponse final {
    WithRequestWithResponse() = delete;

   public:
    using Protocol = ::test_protocols::WithAndWithoutRequestResponse;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class OnEmptyResponse final {
    OnEmptyResponse() = delete;

   public:
    using Protocol = ::test_protocols::WithAndWithoutRequestResponse;
    static constexpr bool kHasClientToServer = false;
    static constexpr bool kHasClientToServerBody = false;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = false;

    static constexpr bool kHasNonEmptyUserFacingResponse = false;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class OnWithResponse final {
    OnWithResponse() = delete;

   public:
    using Protocol = ::test_protocols::WithAndWithoutRequestResponse;
    static constexpr bool kHasClientToServer = false;
    static constexpr bool kHasClientToServerBody = false;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
};

class WithErrorSyntax final {
  WithErrorSyntax() = delete;

 public:
  using Transport = ::fidl::internal::ChannelTransport;

  static constexpr ::fidl::internal::Openness kOpenness = ::fidl::internal::Openness::kClosed;

  class ResponseAsStruct final {
    ResponseAsStruct() = delete;

   public:
    using Protocol = ::test_protocols::WithErrorSyntax;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = false;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = true;
    static constexpr bool kHasFrameworkError = false;
  };
  class ErrorAsPrimitive final {
    ErrorAsPrimitive() = delete;

   public:
    using Protocol = ::test_protocols::WithErrorSyntax;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = false;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = false;
    static constexpr bool kHasDomainError = true;
    static constexpr bool kHasFrameworkError = false;
  };
  class ErrorAsEnum final {
    ErrorAsEnum() = delete;

   public:
    using Protocol = ::test_protocols::WithErrorSyntax;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = false;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = false;
    static constexpr bool kHasDomainError = true;
    static constexpr bool kHasFrameworkError = false;
  };
  class HandleInResult final {
    HandleInResult() = delete;

   public:
    using Protocol = ::test_protocols::WithErrorSyntax;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = false;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = true;
    static constexpr bool kHasFrameworkError = false;
  };
};

class ChannelProtocol final {
  ChannelProtocol() = delete;

 public:
  using Transport = ::fidl::internal::ChannelTransport;

  static constexpr ::fidl::internal::Openness kOpenness = ::fidl::internal::Openness::kClosed;

  class MethodA final {
    MethodA() = delete;

   public:
    using Protocol = ::test_protocols::ChannelProtocol;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = false;
    static constexpr bool kHasServerToClientBody = false;

    static constexpr bool kHasNonEmptyUserFacingResponse = false;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class EventA final {
    EventA() = delete;

   public:
    using Protocol = ::test_protocols::ChannelProtocol;
    static constexpr bool kHasClientToServer = false;
    static constexpr bool kHasClientToServerBody = false;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class MethodB final {
    MethodB() = delete;

   public:
    using Protocol = ::test_protocols::ChannelProtocol;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class TakeHandle final {
    TakeHandle() = delete;

   public:
    using Protocol = ::test_protocols::ChannelProtocol;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = false;

    static constexpr bool kHasNonEmptyUserFacingResponse = false;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class MutateSocket final {
    MutateSocket() = delete;

   public:
    using Protocol = ::test_protocols::ChannelProtocol;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
};

class Transitional final {
  Transitional() = delete;

 public:
  using Transport = ::fidl::internal::ChannelTransport;

  static constexpr ::fidl::internal::Openness kOpenness = ::fidl::internal::Openness::kClosed;

  class Request final {
    Request() = delete;

   public:
    using Protocol = ::test_protocols::Transitional;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class OneWay final {
    OneWay() = delete;

   public:
    using Protocol = ::test_protocols::Transitional;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = false;
    static constexpr bool kHasServerToClientBody = false;

    static constexpr bool kHasNonEmptyUserFacingResponse = false;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class Event final {
    Event() = delete;

   public:
    using Protocol = ::test_protocols::Transitional;
    static constexpr bool kHasClientToServer = false;
    static constexpr bool kHasClientToServerBody = false;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
};

class DiscoverableProtocol final {
  DiscoverableProtocol() = delete;

 public:
  using Transport = ::fidl::internal::ChannelTransport;

  static constexpr ::fidl::internal::Openness kOpenness = ::fidl::internal::Openness::kClosed;

  class Method final {
    Method() = delete;

   public:
    using Protocol = ::test_protocols::DiscoverableProtocol;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = false;
    static constexpr bool kHasServerToClient = false;
    static constexpr bool kHasServerToClientBody = false;

    static constexpr bool kHasNonEmptyUserFacingResponse = false;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
};

class AnotherDiscoverableProtocol final {
  AnotherDiscoverableProtocol() = delete;

 public:
  using Transport = ::fidl::internal::ChannelTransport;

  static constexpr ::fidl::internal::Openness kOpenness = ::fidl::internal::Openness::kClosed;
};

class HandleRightsProtocol final {
  HandleRightsProtocol() = delete;

 public:
  using Transport = ::fidl::internal::ChannelTransport;

  static constexpr ::fidl::internal::Openness kOpenness = ::fidl::internal::Openness::kClosed;

  class NoResponseMethod final {
    NoResponseMethod() = delete;

   public:
    using Protocol = ::test_protocols::HandleRightsProtocol;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = false;
    static constexpr bool kHasServerToClientBody = false;

    static constexpr bool kHasNonEmptyUserFacingResponse = false;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class ResponseMethod final {
    ResponseMethod() = delete;

   public:
    using Protocol = ::test_protocols::HandleRightsProtocol;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class AnEvent final {
    AnEvent() = delete;

   public:
    using Protocol = ::test_protocols::HandleRightsProtocol;
    static constexpr bool kHasClientToServer = false;
    static constexpr bool kHasClientToServerBody = false;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
};

class WithProtocolEnds final {
  WithProtocolEnds() = delete;

 public:
  using Transport = ::fidl::internal::ChannelTransport;

  static constexpr ::fidl::internal::Openness kOpenness = ::fidl::internal::Openness::kClosed;

  class ClientEnds final {
    ClientEnds() = delete;

   public:
    using Protocol = ::test_protocols::WithProtocolEnds;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class ServerEnds final {
    ServerEnds() = delete;

   public:
    using Protocol = ::test_protocols::WithProtocolEnds;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
  class StructContainingEnds final {
    StructContainingEnds() = delete;

   public:
    using Protocol = ::test_protocols::WithProtocolEnds;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
};

class ManyParameters final {
  ManyParameters() = delete;

 public:
  using Transport = ::fidl::internal::ChannelTransport;

  static constexpr ::fidl::internal::Openness kOpenness = ::fidl::internal::Openness::kClosed;

  class Fifteen final {
    Fifteen() = delete;

   public:
    using Protocol = ::test_protocols::ManyParameters;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = false;
    static constexpr bool kHasServerToClientBody = false;

    static constexpr bool kHasNonEmptyUserFacingResponse = false;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
};

class MethodWithUnion final {
  MethodWithUnion() = delete;

 public:
  using Transport = ::fidl::internal::ChannelTransport;

  static constexpr ::fidl::internal::Openness kOpenness = ::fidl::internal::Openness::kClosed;

  class UnionMethod final {
    UnionMethod() = delete;

   public:
    using Protocol = ::test_protocols::MethodWithUnion;
    static constexpr bool kHasClientToServer = true;
    static constexpr bool kHasClientToServerBody = true;
    static constexpr bool kHasServerToClient = true;
    static constexpr bool kHasServerToClientBody = true;

    static constexpr bool kHasNonEmptyUserFacingResponse = true;
    static constexpr bool kHasDomainError = false;
    static constexpr bool kHasFrameworkError = false;
  };
};

}  // namespace test_protocols
namespace fidl {

template <>
struct IsProtocol<::test_protocols::WithAndWithoutRequestResponse> : public std::true_type {};

template <>
struct IsProtocol<::test_protocols::WithErrorSyntax> : public std::true_type {};

template <>
struct IsProtocol<::test_protocols::ChannelProtocol> : public std::true_type {};

template <>
struct IsProtocol<::test_protocols::Transitional> : public std::true_type {};

template <>
struct IsProtocol<::test_protocols::DiscoverableProtocol> : public std::true_type {};

template <>
struct IsProtocol<::test_protocols::AnotherDiscoverableProtocol> : public std::true_type {};

template <>
struct IsProtocol<::test_protocols::HandleRightsProtocol> : public std::true_type {};

template <>
struct IsProtocol<::test_protocols::WithProtocolEnds> : public std::true_type {};

template <>
struct IsProtocol<::test_protocols::ManyParameters> : public std::true_type {};

template <>
struct IsProtocol<::test_protocols::MethodWithUnion> : public std::true_type {};

}  // namespace fidl
