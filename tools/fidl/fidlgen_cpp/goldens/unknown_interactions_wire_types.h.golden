// WARNING: This file is machine generated by fidlgen.
  
  // fidl_experiment = no_optional_structs
  // fidl_experiment = output_index_json
  // fidl_experiment = simple_empty_response_syntax
  // fidl_experiment = unknown_interactions
  // fidl_experiment = unknown_interactions_new_defaults

  #pragma once

  #include <cinttypes>

  #include <lib/fidl/cpp/wire/internal/transport_err.h>
  #include <lib/fidl/cpp/wire/array.h>
  #include <lib/fidl/cpp/wire/envelope.h>
  #include <lib/fidl/cpp/wire/message_storage.h>
  #include <lib/fidl/cpp/wire/message.h>
  #include <lib/fidl/cpp/wire/object_view.h>
  #include <lib/fidl/cpp/wire/string_view.h>
  #include <lib/fidl/cpp/wire/traits.h>
  #include <lib/fidl/cpp/wire/wire_types.h>
  #include <lib/stdcompat/optional.h>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>
    

#endif  // __Fuchsia__


  #include <fidl/test.unknowninteractions/cpp/markers.h>
  #include <fidl/test.unknowninteractions/cpp/common_types.h>
  

  namespace test_unknowninteractions {


  
  
  
namespace wire {

struct UnknownInteractionsProtocolStrictTwoWayFieldsResponse;


struct UnknownInteractionsProtocolStrictTwoWayErrResponse;


struct UnknownInteractionsProtocolStrictTwoWayErrTopResponse;


struct UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse;


struct UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse;


struct UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse;


struct UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse;


struct UnknownInteractionsProtocolFlexibleTwoWayResponse;


struct UnknownInteractionsProtocolFlexibleTwoWayTopResponse;


struct UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse;


struct UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse;


struct UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse;


struct UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse;


struct UnknownInteractionsProtocolFlexibleTwoWayErrResponse;


struct UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse;


struct UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse;


struct UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse;


struct UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse;


struct UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse;


struct UnknownInteractionsProtocolStrictEventFieldsRequest;


struct UnknownInteractionsProtocolStrictEventErrResponse;


struct UnknownInteractionsProtocolStrictEventErrRequest;


struct UnknownInteractionsProtocolStrictEventFieldsErrResponse;


struct UnknownInteractionsProtocolStrictEventFieldsErrRequest;


struct UnknownInteractionsProtocolStrictEventUnionErrRequest;


struct UnknownInteractionsProtocolStrictEventTableErrRequest;


struct UnknownInteractionsProtocolFlexibleEventFieldsRequest;


struct UnknownInteractionsProtocolFlexibleEventErrResponse;


struct UnknownInteractionsProtocolFlexibleEventErrRequest;


struct UnknownInteractionsProtocolFlexibleEventFieldsErrResponse;


struct UnknownInteractionsProtocolFlexibleEventFieldsErrRequest;


struct UnknownInteractionsProtocolFlexibleEventUnionErrRequest;


struct UnknownInteractionsProtocolFlexibleEventTableErrRequest;


struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;


struct UnknownInteractionsAjarProtocolStrictTwoWayErrResponse;


struct UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse;


struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse;


struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse;


struct UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse;


struct UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse;


struct UnknownInteractionsAjarProtocolStrictEventFieldsRequest;


struct UnknownInteractionsAjarProtocolStrictEventErrResponse;


struct UnknownInteractionsAjarProtocolStrictEventErrRequest;


struct UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse;


struct UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest;


struct UnknownInteractionsAjarProtocolStrictEventUnionErrRequest;


struct UnknownInteractionsAjarProtocolStrictEventTableErrRequest;


struct UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;


struct UnknownInteractionsAjarProtocolFlexibleEventErrResponse;


struct UnknownInteractionsAjarProtocolFlexibleEventErrRequest;


struct UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse;


struct UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest;


struct UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest;


struct UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest;


struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;


struct UnknownInteractionsClosedProtocolStrictTwoWayErrResponse;


struct UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse;


struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse;


struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse;


struct UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse;


struct UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse;


struct UnknownInteractionsClosedProtocolStrictEventFieldsRequest;


struct UnknownInteractionsClosedProtocolStrictEventErrResponse;


struct UnknownInteractionsClosedProtocolStrictEventErrRequest;


struct UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse;


struct UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest;


struct UnknownInteractionsClosedProtocolStrictEventUnionErrRequest;


struct UnknownInteractionsClosedProtocolStrictEventTableErrRequest;


struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;


struct UnknownInteractionsDriverProtocolStrictTwoWayErrResponse;


struct UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse;


struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse;


struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse;


struct UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse;


struct UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse;


struct UnknownInteractionsDriverProtocolFlexibleTwoWayResponse;


struct UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse;


struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse;


struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse;


struct UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse;


struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse;


struct UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse;


struct UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse;


struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse;


struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse;


struct UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse;


struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse;


struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;


struct UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse;


struct UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse;


struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse;


struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse;


struct UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse;


struct UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse;


struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;


struct UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse;


struct UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse;


struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse;


struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse;


struct UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse;


struct UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse;
  


class UnknownInteractionsProtocolStrictTwoWayTableResponse;


class UnknownInteractionsProtocolStrictTwoWayTableErrResponse;


class UnknownInteractionsProtocolFlexibleTwoWayTableResponse;


class UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;


class UnknownInteractionsProtocolStrictEventTableRequest;


class UnknownInteractionsProtocolStrictEventTableErrResponse;


class UnknownInteractionsProtocolFlexibleEventTableRequest;


class UnknownInteractionsProtocolFlexibleEventTableErrResponse;


class UnknownInteractionsAjarProtocolStrictTwoWayTableResponse;


class UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;


class UnknownInteractionsAjarProtocolStrictEventTableRequest;


class UnknownInteractionsAjarProtocolStrictEventTableErrResponse;


class UnknownInteractionsAjarProtocolFlexibleEventTableRequest;


class UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse;


class UnknownInteractionsClosedProtocolStrictTwoWayTableResponse;


class UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;


class UnknownInteractionsClosedProtocolStrictEventTableRequest;


class UnknownInteractionsClosedProtocolStrictEventTableErrResponse;


class UnknownInteractionsDriverProtocolStrictTwoWayTableResponse;


class UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;


class UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;


class UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;
  


class UnknownInteractionsProtocolStrictTwoWayUnionResponse;


class UnknownInteractionsProtocolStrictTwoWayErrResult;


class UnknownInteractionsProtocolStrictTwoWayFieldsErrResult;


class UnknownInteractionsProtocolStrictTwoWayUnionErrResponse;


class UnknownInteractionsProtocolStrictTwoWayUnionErrResult;


class UnknownInteractionsProtocolStrictTwoWayTableErrResult;


class UnknownInteractionsProtocolFlexibleTwoWayResult;


class UnknownInteractionsProtocolFlexibleTwoWayFieldsResult;


class UnknownInteractionsProtocolFlexibleTwoWayUnionResponse;


class UnknownInteractionsProtocolFlexibleTwoWayUnionResult;


class UnknownInteractionsProtocolFlexibleTwoWayTableResult;


class UnknownInteractionsProtocolFlexibleTwoWayErrResult;


class UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult;


class UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;


class UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult;


class UnknownInteractionsProtocolFlexibleTwoWayTableErrResult;


class UnknownInteractionsProtocolStrictEventUnionRequest;


class UnknownInteractionsProtocolStrictEventErrResult;


class UnknownInteractionsProtocolStrictEventFieldsErrResult;


class UnknownInteractionsProtocolStrictEventUnionErrResponse;


class UnknownInteractionsProtocolStrictEventUnionErrResult;


class UnknownInteractionsProtocolStrictEventTableErrResult;


class UnknownInteractionsProtocolFlexibleEventUnionRequest;


class UnknownInteractionsProtocolFlexibleEventErrResult;


class UnknownInteractionsProtocolFlexibleEventFieldsErrResult;


class UnknownInteractionsProtocolFlexibleEventUnionErrResponse;


class UnknownInteractionsProtocolFlexibleEventUnionErrResult;


class UnknownInteractionsProtocolFlexibleEventTableErrResult;


class UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;


class UnknownInteractionsAjarProtocolStrictTwoWayErrResult;


class UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult;


class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;


class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult;


class UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult;


class UnknownInteractionsAjarProtocolStrictEventUnionRequest;


class UnknownInteractionsAjarProtocolStrictEventErrResult;


class UnknownInteractionsAjarProtocolStrictEventFieldsErrResult;


class UnknownInteractionsAjarProtocolStrictEventUnionErrResponse;


class UnknownInteractionsAjarProtocolStrictEventUnionErrResult;


class UnknownInteractionsAjarProtocolStrictEventTableErrResult;


class UnknownInteractionsAjarProtocolFlexibleEventUnionRequest;


class UnknownInteractionsAjarProtocolFlexibleEventErrResult;


class UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult;


class UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse;


class UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult;


class UnknownInteractionsAjarProtocolFlexibleEventTableErrResult;


class UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;


class UnknownInteractionsClosedProtocolStrictTwoWayErrResult;


class UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult;


class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;


class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult;


class UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult;


class UnknownInteractionsClosedProtocolStrictEventUnionRequest;


class UnknownInteractionsClosedProtocolStrictEventErrResult;


class UnknownInteractionsClosedProtocolStrictEventFieldsErrResult;


class UnknownInteractionsClosedProtocolStrictEventUnionErrResponse;


class UnknownInteractionsClosedProtocolStrictEventUnionErrResult;


class UnknownInteractionsClosedProtocolStrictEventTableErrResult;


class UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;


class UnknownInteractionsDriverProtocolStrictTwoWayErrResult;


class UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult;


class UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;


class UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult;


class UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult;


class UnknownInteractionsDriverProtocolFlexibleTwoWayResult;


class UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult;


class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;


class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult;


class UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult;


class UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult;


class UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult;


class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;


class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult;


class UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult;


class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult;


class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult;
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayFieldsResponseTable;

struct UnknownInteractionsProtocolStrictTwoWayFieldsResponse {

    int32_t some_field = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictTwoWayErr_ResponseTable;

struct UnknownInteractionsProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictTwoWayFieldsErr_ResponseTable;

struct UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWay_ResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayFields_ResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayErr_ResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_ResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventFieldsRequestTable;

struct UnknownInteractionsProtocolStrictEventFieldsRequest {

    int32_t some_field = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictEventErr_ResponseTable;

struct UnknownInteractionsProtocolStrictEventErrResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictEventFieldsErr_ResponseTable;

struct UnknownInteractionsProtocolStrictEventFieldsErrResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventFieldsRequestTable;

struct UnknownInteractionsProtocolFlexibleEventFieldsRequest {

    int32_t some_field = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleEventErr_ResponseTable;

struct UnknownInteractionsProtocolFlexibleEventErrResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleEventFieldsErr_ResponseTable;

struct UnknownInteractionsProtocolFlexibleEventFieldsErrResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponseTable;

struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {

    int32_t some_field = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictTwoWayErr_ResponseTable;

struct UnknownInteractionsAjarProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_ResponseTable;

struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventFieldsRequestTable;

struct UnknownInteractionsAjarProtocolStrictEventFieldsRequest {

    int32_t some_field = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictEventErr_ResponseTable;

struct UnknownInteractionsAjarProtocolStrictEventErrResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictEventFieldsErr_ResponseTable;

struct UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventFieldsRequestTable;

struct UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {

    int32_t some_field = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_FlexibleEventErr_ResponseTable;

struct UnknownInteractionsAjarProtocolFlexibleEventErrResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_ResponseTable;

struct UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponseTable;

struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {

    int32_t some_field = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictTwoWayErr_ResponseTable;

struct UnknownInteractionsClosedProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_ResponseTable;

struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventFieldsRequestTable;

struct UnknownInteractionsClosedProtocolStrictEventFieldsRequest {

    int32_t some_field = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictEventErr_ResponseTable;

struct UnknownInteractionsClosedProtocolStrictEventErrResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictEventFieldsErr_ResponseTable;

struct UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponseTable;

struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {

    int32_t some_field = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_StrictTwoWayErr_ResponseTable;

struct UnknownInteractionsDriverProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_ResponseTable;

struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWay_ResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_ResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_ResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_ResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponseTable;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {

    int32_t some_field = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_ResponseTable;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_ResponseTable;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {

    int32_t some_field = {};
};
    
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponseTable;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {

    int32_t some_field = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_ResponseTable;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_ResponseTable;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse {

    int32_t some_field = {};
};
    
    
    
  


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayTableResponseTable;

class UnknownInteractionsProtocolStrictTwoWayTableResponse {
public:
  UnknownInteractionsProtocolStrictTwoWayTableResponse() = default;
  UnknownInteractionsProtocolStrictTwoWayTableResponse(const UnknownInteractionsProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsProtocolStrictTwoWayTableResponse& operator=(const UnknownInteractionsProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsProtocolStrictTwoWayTableResponse(UnknownInteractionsProtocolStrictTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsProtocolStrictTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsProtocolStrictTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolStrictTwoWayTableResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsProtocolStrictTwoWayTableResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> UnknownInteractionsProtocolStrictTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> UnknownInteractionsProtocolStrictTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictTwoWayTableErr_ResponseTable;

class UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
public:
  UnknownInteractionsProtocolStrictTwoWayTableErrResponse() = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResponse(const UnknownInteractionsProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResponse& operator=(const UnknownInteractionsProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResponse(UnknownInteractionsProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResponse& operator=(UnknownInteractionsProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsProtocolStrictTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolStrictTwoWayTableErrResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsProtocolStrictTwoWayTableErrResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> UnknownInteractionsProtocolStrictTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> UnknownInteractionsProtocolStrictTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayTable_ResponseTable;

class UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
public:
  UnknownInteractionsProtocolFlexibleTwoWayTableResponse() = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResponse(const UnknownInteractionsProtocolFlexibleTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResponse& operator=(const UnknownInteractionsProtocolFlexibleTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResponse(UnknownInteractionsProtocolFlexibleTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResponse& operator=(UnknownInteractionsProtocolFlexibleTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsProtocolFlexibleTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolFlexibleTwoWayTableResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsProtocolFlexibleTwoWayTableResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsProtocolFlexibleTwoWayTableResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolFlexibleTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> UnknownInteractionsProtocolFlexibleTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> UnknownInteractionsProtocolFlexibleTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayTableErr_ResponseTable;

class UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
public:
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse() = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse(const UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& operator=(const UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse(UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& operator=(UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventTableRequestTable;

class UnknownInteractionsProtocolStrictEventTableRequest {
public:
  UnknownInteractionsProtocolStrictEventTableRequest() = default;
  UnknownInteractionsProtocolStrictEventTableRequest(const UnknownInteractionsProtocolStrictEventTableRequest& other) noexcept = default;
  UnknownInteractionsProtocolStrictEventTableRequest& operator=(const UnknownInteractionsProtocolStrictEventTableRequest& other) noexcept = default;
  UnknownInteractionsProtocolStrictEventTableRequest(UnknownInteractionsProtocolStrictEventTableRequest&& other) noexcept = default;
  UnknownInteractionsProtocolStrictEventTableRequest& operator=(UnknownInteractionsProtocolStrictEventTableRequest&& other) noexcept = default;

  ~UnknownInteractionsProtocolStrictEventTableRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolStrictEventTableRequest& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsProtocolStrictEventTableRequest& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsProtocolStrictEventTableRequest(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolStrictEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> UnknownInteractionsProtocolStrictEventTableRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> UnknownInteractionsProtocolStrictEventTableRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictEventTableErr_ResponseTable;

class UnknownInteractionsProtocolStrictEventTableErrResponse {
public:
  UnknownInteractionsProtocolStrictEventTableErrResponse() = default;
  UnknownInteractionsProtocolStrictEventTableErrResponse(const UnknownInteractionsProtocolStrictEventTableErrResponse& other) noexcept = default;
  UnknownInteractionsProtocolStrictEventTableErrResponse& operator=(const UnknownInteractionsProtocolStrictEventTableErrResponse& other) noexcept = default;
  UnknownInteractionsProtocolStrictEventTableErrResponse(UnknownInteractionsProtocolStrictEventTableErrResponse&& other) noexcept = default;
  UnknownInteractionsProtocolStrictEventTableErrResponse& operator=(UnknownInteractionsProtocolStrictEventTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsProtocolStrictEventTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolStrictEventTableErrResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsProtocolStrictEventTableErrResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsProtocolStrictEventTableErrResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolStrictEventTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse> UnknownInteractionsProtocolStrictEventTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse> UnknownInteractionsProtocolStrictEventTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventTableRequestTable;

class UnknownInteractionsProtocolFlexibleEventTableRequest {
public:
  UnknownInteractionsProtocolFlexibleEventTableRequest() = default;
  UnknownInteractionsProtocolFlexibleEventTableRequest(const UnknownInteractionsProtocolFlexibleEventTableRequest& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleEventTableRequest& operator=(const UnknownInteractionsProtocolFlexibleEventTableRequest& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleEventTableRequest(UnknownInteractionsProtocolFlexibleEventTableRequest&& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleEventTableRequest& operator=(UnknownInteractionsProtocolFlexibleEventTableRequest&& other) noexcept = default;

  ~UnknownInteractionsProtocolFlexibleEventTableRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolFlexibleEventTableRequest& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsProtocolFlexibleEventTableRequest& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsProtocolFlexibleEventTableRequest(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolFlexibleEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> UnknownInteractionsProtocolFlexibleEventTableRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> UnknownInteractionsProtocolFlexibleEventTableRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleEventTableErr_ResponseTable;

class UnknownInteractionsProtocolFlexibleEventTableErrResponse {
public:
  UnknownInteractionsProtocolFlexibleEventTableErrResponse() = default;
  UnknownInteractionsProtocolFlexibleEventTableErrResponse(const UnknownInteractionsProtocolFlexibleEventTableErrResponse& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleEventTableErrResponse& operator=(const UnknownInteractionsProtocolFlexibleEventTableErrResponse& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleEventTableErrResponse(UnknownInteractionsProtocolFlexibleEventTableErrResponse&& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleEventTableErrResponse& operator=(UnknownInteractionsProtocolFlexibleEventTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsProtocolFlexibleEventTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolFlexibleEventTableErrResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsProtocolFlexibleEventTableErrResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsProtocolFlexibleEventTableErrResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolFlexibleEventTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse> UnknownInteractionsProtocolFlexibleEventTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse> UnknownInteractionsProtocolFlexibleEventTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayTableResponseTable;

class UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
public:
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse() = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse(const UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse(UnknownInteractionsAjarProtocolStrictTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsAjarProtocolStrictTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsAjarProtocolStrictTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsAjarProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_ResponseTable;

class UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
public:
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse() = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse(const UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse(UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& operator=(UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventTableRequestTable;

class UnknownInteractionsAjarProtocolStrictEventTableRequest {
public:
  UnknownInteractionsAjarProtocolStrictEventTableRequest() = default;
  UnknownInteractionsAjarProtocolStrictEventTableRequest(const UnknownInteractionsAjarProtocolStrictEventTableRequest& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictEventTableRequest& operator=(const UnknownInteractionsAjarProtocolStrictEventTableRequest& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictEventTableRequest(UnknownInteractionsAjarProtocolStrictEventTableRequest&& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictEventTableRequest& operator=(UnknownInteractionsAjarProtocolStrictEventTableRequest&& other) noexcept = default;

  ~UnknownInteractionsAjarProtocolStrictEventTableRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarProtocolStrictEventTableRequest& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsAjarProtocolStrictEventTableRequest& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsAjarProtocolStrictEventTableRequest(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarProtocolStrictEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> UnknownInteractionsAjarProtocolStrictEventTableRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> UnknownInteractionsAjarProtocolStrictEventTableRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictEventTableErr_ResponseTable;

class UnknownInteractionsAjarProtocolStrictEventTableErrResponse {
public:
  UnknownInteractionsAjarProtocolStrictEventTableErrResponse() = default;
  UnknownInteractionsAjarProtocolStrictEventTableErrResponse(const UnknownInteractionsAjarProtocolStrictEventTableErrResponse& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictEventTableErrResponse& operator=(const UnknownInteractionsAjarProtocolStrictEventTableErrResponse& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictEventTableErrResponse(UnknownInteractionsAjarProtocolStrictEventTableErrResponse&& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictEventTableErrResponse& operator=(UnknownInteractionsAjarProtocolStrictEventTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsAjarProtocolStrictEventTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarProtocolStrictEventTableErrResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsAjarProtocolStrictEventTableErrResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsAjarProtocolStrictEventTableErrResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarProtocolStrictEventTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse> UnknownInteractionsAjarProtocolStrictEventTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse> UnknownInteractionsAjarProtocolStrictEventTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventTableRequestTable;

class UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
public:
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest() = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest(const UnknownInteractionsAjarProtocolFlexibleEventTableRequest& other) noexcept = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest& operator=(const UnknownInteractionsAjarProtocolFlexibleEventTableRequest& other) noexcept = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest(UnknownInteractionsAjarProtocolFlexibleEventTableRequest&& other) noexcept = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest& operator=(UnknownInteractionsAjarProtocolFlexibleEventTableRequest&& other) noexcept = default;

  ~UnknownInteractionsAjarProtocolFlexibleEventTableRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarProtocolFlexibleEventTableRequest& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsAjarProtocolFlexibleEventTableRequest& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsAjarProtocolFlexibleEventTableRequest(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarProtocolFlexibleEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> UnknownInteractionsAjarProtocolFlexibleEventTableRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> UnknownInteractionsAjarProtocolFlexibleEventTableRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_FlexibleEventTableErr_ResponseTable;

class UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse {
public:
  UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse() = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse(const UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse& other) noexcept = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse& operator=(const UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse& other) noexcept = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse(UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse&& other) noexcept = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse& operator=(UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse> UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse> UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayTableResponseTable;

class UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
public:
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse() = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse(const UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse(UnknownInteractionsClosedProtocolStrictTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsClosedProtocolStrictTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsClosedProtocolStrictTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsClosedProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsClosedProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_ResponseTable;

class UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
public:
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse() = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse(const UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse(UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& operator=(UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventTableRequestTable;

class UnknownInteractionsClosedProtocolStrictEventTableRequest {
public:
  UnknownInteractionsClosedProtocolStrictEventTableRequest() = default;
  UnknownInteractionsClosedProtocolStrictEventTableRequest(const UnknownInteractionsClosedProtocolStrictEventTableRequest& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictEventTableRequest& operator=(const UnknownInteractionsClosedProtocolStrictEventTableRequest& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictEventTableRequest(UnknownInteractionsClosedProtocolStrictEventTableRequest&& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictEventTableRequest& operator=(UnknownInteractionsClosedProtocolStrictEventTableRequest&& other) noexcept = default;

  ~UnknownInteractionsClosedProtocolStrictEventTableRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsClosedProtocolStrictEventTableRequest& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsClosedProtocolStrictEventTableRequest& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsClosedProtocolStrictEventTableRequest(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsClosedProtocolStrictEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> UnknownInteractionsClosedProtocolStrictEventTableRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> UnknownInteractionsClosedProtocolStrictEventTableRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictEventTableErr_ResponseTable;

class UnknownInteractionsClosedProtocolStrictEventTableErrResponse {
public:
  UnknownInteractionsClosedProtocolStrictEventTableErrResponse() = default;
  UnknownInteractionsClosedProtocolStrictEventTableErrResponse(const UnknownInteractionsClosedProtocolStrictEventTableErrResponse& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictEventTableErrResponse& operator=(const UnknownInteractionsClosedProtocolStrictEventTableErrResponse& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictEventTableErrResponse(UnknownInteractionsClosedProtocolStrictEventTableErrResponse&& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictEventTableErrResponse& operator=(UnknownInteractionsClosedProtocolStrictEventTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsClosedProtocolStrictEventTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsClosedProtocolStrictEventTableErrResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsClosedProtocolStrictEventTableErrResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsClosedProtocolStrictEventTableErrResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsClosedProtocolStrictEventTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse> UnknownInteractionsClosedProtocolStrictEventTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse> UnknownInteractionsClosedProtocolStrictEventTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayTableResponseTable;

class UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
public:
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse() = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse(const UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse(UnknownInteractionsDriverProtocolStrictTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsDriverProtocolStrictTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsDriverProtocolStrictTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsDriverProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsDriverProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_ResponseTable;

class UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
public:
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse() = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse(const UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse(UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& operator=(UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_ResponseTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
public:
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse() = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse(UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_ResponseTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
public:
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse() = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse(UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponseTable;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
public:
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse() = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse(const UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_ResponseTable;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
public:
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse() = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse(const UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponseTable;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
public:
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse() = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse(const UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>(std::move(frame));
}


}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_ResponseTable;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
public:
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse() = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse(const UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }
  [[ nodiscard ]] bool has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& set_some_field(int32_t elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

  explicit UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator)
      : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>(allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>&& frame)
      : frame_ptr_(std::move(frame)) {}

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>(allocator);
  }
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>&& frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse Build() {
    ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse t = std::move(table_);
    // Poison this builder to prevent accidental reuse.
    table_.frame_ptr_ = nullptr;
    return t;
  }
    [[ nodiscard ]] bool has_some_field() const {
      return table_.has_some_field();
    }

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field() {
      table_.clear_some_field();
    }

    // Getter for some_field.
    //
    
    [[ nodiscard ]] int32_t& some_field() const {
      return table_.some_field();
    }

    // Setter for some_field.
    //
    
      BuilderImpl& some_field(int32_t elem) {
        ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
        table_.frame_ptr_->some_field_.set_data(std::move(elem));
        table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
        return *static_cast<BuilderImpl*>(this);
      }
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>&& frame)
    : table_(std::move(frame)) {}

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>(arena)),
        arena_(arena) {}

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>* frame)
      : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>::FromExternal(frame)) {}
};namespace test_unknowninteractions {
namespace wire {

inline ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>(arena);
}
inline ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>(std::move(frame));
}
  



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayUnionResponseTable;

class UnknownInteractionsProtocolStrictTwoWayUnionResponse {
  public:

  UnknownInteractionsProtocolStrictTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictTwoWayUnionResponse(const UnknownInteractionsProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionResponse& operator=(const UnknownInteractionsProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionResponse(UnknownInteractionsProtocolStrictTwoWayUnionResponse&&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsProtocolStrictTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsProtocolStrictTwoWayUnionResponse WithSomeField(int32_t val) {
    UnknownInteractionsProtocolStrictTwoWayUnionResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictTwoWayErr_ResultTable;

class UnknownInteractionsProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse;

  UnknownInteractionsProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictTwoWayErrResult(const UnknownInteractionsProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayErrResult(UnknownInteractionsProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse val) {
    UnknownInteractionsProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolStrictTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictTwoWayFieldsErr_ResultTable;

class UnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse;

  UnknownInteractionsProtocolStrictTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictTwoWayFieldsErrResult(const UnknownInteractionsProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayFieldsErrResult& operator=(const UnknownInteractionsProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayFieldsErrResult(UnknownInteractionsProtocolStrictTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsProtocolStrictTwoWayFieldsErrResult& operator=(UnknownInteractionsProtocolStrictTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolStrictTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse val) {
    UnknownInteractionsProtocolStrictTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolStrictTwoWayFieldsErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolStrictTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictTwoWayUnionErr_ResponseTable;

class UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
  public:

  UnknownInteractionsProtocolStrictTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictTwoWayUnionErrResponse(const UnknownInteractionsProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionErrResponse& operator=(const UnknownInteractionsProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionErrResponse(UnknownInteractionsProtocolStrictTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionErrResponse& operator=(UnknownInteractionsProtocolStrictTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsProtocolStrictTwoWayUnionErrResponse WithSomeField(int32_t val) {
    UnknownInteractionsProtocolStrictTwoWayUnionErrResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictTwoWayUnionErr_ResultTable;

class UnknownInteractionsProtocolStrictTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse;

  UnknownInteractionsProtocolStrictTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictTwoWayUnionErrResult(const UnknownInteractionsProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionErrResult& operator=(const UnknownInteractionsProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionErrResult(UnknownInteractionsProtocolStrictTwoWayUnionErrResult&&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionErrResult& operator=(UnknownInteractionsProtocolStrictTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse> val) {
    UnknownInteractionsProtocolStrictTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolStrictTwoWayUnionErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolStrictTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictTwoWayTableErr_ResultTable;

class UnknownInteractionsProtocolStrictTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse;

  UnknownInteractionsProtocolStrictTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictTwoWayTableErrResult(const UnknownInteractionsProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResult& operator=(const UnknownInteractionsProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResult(UnknownInteractionsProtocolStrictTwoWayTableErrResult&&) = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResult& operator=(UnknownInteractionsProtocolStrictTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolStrictTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> val) {
    UnknownInteractionsProtocolStrictTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsProtocolStrictTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolStrictTwoWayTableErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolStrictTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWay_ResultTable;

class UnknownInteractionsProtocolFlexibleTwoWayResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse;

  UnknownInteractionsProtocolFlexibleTwoWayResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleTwoWayResult(const UnknownInteractionsProtocolFlexibleTwoWayResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayResult(UnknownInteractionsProtocolFlexibleTwoWayResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse val) {
    UnknownInteractionsProtocolFlexibleTwoWayResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsProtocolFlexibleTwoWayResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayFields_ResultTable;

class UnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse;

  UnknownInteractionsProtocolFlexibleTwoWayFieldsResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleTwoWayFieldsResult(const UnknownInteractionsProtocolFlexibleTwoWayFieldsResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayFieldsResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayFieldsResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayFieldsResult(UnknownInteractionsProtocolFlexibleTwoWayFieldsResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayFieldsResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayFieldsResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayFieldsResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse val) {
    UnknownInteractionsProtocolFlexibleTwoWayFieldsResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayFieldsResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsProtocolFlexibleTwoWayFieldsResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayUnion_ResponseTable;

class UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
  public:

  UnknownInteractionsProtocolFlexibleTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleTwoWayUnionResponse(const UnknownInteractionsProtocolFlexibleTwoWayUnionResponse&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionResponse& operator=(const UnknownInteractionsProtocolFlexibleTwoWayUnionResponse&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionResponse(UnknownInteractionsProtocolFlexibleTwoWayUnionResponse&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionResponse& operator=(UnknownInteractionsProtocolFlexibleTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayUnionResponse WithSomeField(int32_t val) {
    UnknownInteractionsProtocolFlexibleTwoWayUnionResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayUnion_ResultTable;

class UnknownInteractionsProtocolFlexibleTwoWayUnionResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse;

  UnknownInteractionsProtocolFlexibleTwoWayUnionResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleTwoWayUnionResult(const UnknownInteractionsProtocolFlexibleTwoWayUnionResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayUnionResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionResult(UnknownInteractionsProtocolFlexibleTwoWayUnionResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayUnionResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayUnionResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse> val) {
    UnknownInteractionsProtocolFlexibleTwoWayUnionResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsProtocolFlexibleTwoWayUnionResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayUnionResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsProtocolFlexibleTwoWayUnionResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayTable_ResultTable;

class UnknownInteractionsProtocolFlexibleTwoWayTableResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse;

  UnknownInteractionsProtocolFlexibleTwoWayTableResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleTwoWayTableResult(const UnknownInteractionsProtocolFlexibleTwoWayTableResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayTableResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResult(UnknownInteractionsProtocolFlexibleTwoWayTableResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayTableResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayTableResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> val) {
    UnknownInteractionsProtocolFlexibleTwoWayTableResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsProtocolFlexibleTwoWayTableResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayTableResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsProtocolFlexibleTwoWayTableResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayErr_ResultTable;

class UnknownInteractionsProtocolFlexibleTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse;

  UnknownInteractionsProtocolFlexibleTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleTwoWayErrResult(const UnknownInteractionsProtocolFlexibleTwoWayErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayErrResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayErrResult(UnknownInteractionsProtocolFlexibleTwoWayErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayErrResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse val) {
    UnknownInteractionsProtocolFlexibleTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolFlexibleTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayErrResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsProtocolFlexibleTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_ResultTable;

class UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse;

  UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult(const UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult(UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse val) {
    UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_ResponseTable;

class UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
  public:

  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse(const UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse& operator=(const UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse& operator=(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse WithSomeField(int32_t val) {
    UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_ResultTable;

class UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;

  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult(const UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> val) {
    UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayTableErr_ResultTable;

class UnknownInteractionsProtocolFlexibleTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;

  UnknownInteractionsProtocolFlexibleTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleTwoWayTableErrResult(const UnknownInteractionsProtocolFlexibleTwoWayTableErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayTableErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResult(UnknownInteractionsProtocolFlexibleTwoWayTableErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> val) {
    UnknownInteractionsProtocolFlexibleTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsProtocolFlexibleTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayTableErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolFlexibleTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayTableErrResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsProtocolFlexibleTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventUnionRequestTable;

class UnknownInteractionsProtocolStrictEventUnionRequest {
  public:

  UnknownInteractionsProtocolStrictEventUnionRequest() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictEventUnionRequest(const UnknownInteractionsProtocolStrictEventUnionRequest&) = default;
  UnknownInteractionsProtocolStrictEventUnionRequest& operator=(const UnknownInteractionsProtocolStrictEventUnionRequest&) = default;
  UnknownInteractionsProtocolStrictEventUnionRequest(UnknownInteractionsProtocolStrictEventUnionRequest&&) = default;
  UnknownInteractionsProtocolStrictEventUnionRequest& operator=(UnknownInteractionsProtocolStrictEventUnionRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal::kSomeField; }
  
  static UnknownInteractionsProtocolStrictEventUnionRequest WithSomeField(int32_t val) {
    UnknownInteractionsProtocolStrictEventUnionRequest result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictEventErr_ResultTable;

class UnknownInteractionsProtocolStrictEventErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse;

  UnknownInteractionsProtocolStrictEventErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictEventErrResult(const UnknownInteractionsProtocolStrictEventErrResult&) = default;
  UnknownInteractionsProtocolStrictEventErrResult& operator=(const UnknownInteractionsProtocolStrictEventErrResult&) = default;
  UnknownInteractionsProtocolStrictEventErrResult(UnknownInteractionsProtocolStrictEventErrResult&&) = default;
  UnknownInteractionsProtocolStrictEventErrResult& operator=(UnknownInteractionsProtocolStrictEventErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolStrictEventErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse val) {
    UnknownInteractionsProtocolStrictEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolStrictEventErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolStrictEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictEventFieldsErr_ResultTable;

class UnknownInteractionsProtocolStrictEventFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse;

  UnknownInteractionsProtocolStrictEventFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictEventFieldsErrResult(const UnknownInteractionsProtocolStrictEventFieldsErrResult&) = default;
  UnknownInteractionsProtocolStrictEventFieldsErrResult& operator=(const UnknownInteractionsProtocolStrictEventFieldsErrResult&) = default;
  UnknownInteractionsProtocolStrictEventFieldsErrResult(UnknownInteractionsProtocolStrictEventFieldsErrResult&&) = default;
  UnknownInteractionsProtocolStrictEventFieldsErrResult& operator=(UnknownInteractionsProtocolStrictEventFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolStrictEventFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse val) {
    UnknownInteractionsProtocolStrictEventFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolStrictEventFieldsErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolStrictEventFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictEventUnionErr_ResponseTable;

class UnknownInteractionsProtocolStrictEventUnionErrResponse {
  public:

  UnknownInteractionsProtocolStrictEventUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictEventUnionErrResponse(const UnknownInteractionsProtocolStrictEventUnionErrResponse&) = default;
  UnknownInteractionsProtocolStrictEventUnionErrResponse& operator=(const UnknownInteractionsProtocolStrictEventUnionErrResponse&) = default;
  UnknownInteractionsProtocolStrictEventUnionErrResponse(UnknownInteractionsProtocolStrictEventUnionErrResponse&&) = default;
  UnknownInteractionsProtocolStrictEventUnionErrResponse& operator=(UnknownInteractionsProtocolStrictEventUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsProtocolStrictEventUnionErrResponse WithSomeField(int32_t val) {
    UnknownInteractionsProtocolStrictEventUnionErrResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictEventUnionErr_ResultTable;

class UnknownInteractionsProtocolStrictEventUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse;

  UnknownInteractionsProtocolStrictEventUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictEventUnionErrResult(const UnknownInteractionsProtocolStrictEventUnionErrResult&) = default;
  UnknownInteractionsProtocolStrictEventUnionErrResult& operator=(const UnknownInteractionsProtocolStrictEventUnionErrResult&) = default;
  UnknownInteractionsProtocolStrictEventUnionErrResult(UnknownInteractionsProtocolStrictEventUnionErrResult&&) = default;
  UnknownInteractionsProtocolStrictEventUnionErrResult& operator=(UnknownInteractionsProtocolStrictEventUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolStrictEventUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse> val) {
    UnknownInteractionsProtocolStrictEventUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsProtocolStrictEventUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolStrictEventUnionErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolStrictEventUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictEventTableErr_ResultTable;

class UnknownInteractionsProtocolStrictEventTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse;

  UnknownInteractionsProtocolStrictEventTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictEventTableErrResult(const UnknownInteractionsProtocolStrictEventTableErrResult&) = default;
  UnknownInteractionsProtocolStrictEventTableErrResult& operator=(const UnknownInteractionsProtocolStrictEventTableErrResult&) = default;
  UnknownInteractionsProtocolStrictEventTableErrResult(UnknownInteractionsProtocolStrictEventTableErrResult&&) = default;
  UnknownInteractionsProtocolStrictEventTableErrResult& operator=(UnknownInteractionsProtocolStrictEventTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolStrictEventTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse> val) {
    UnknownInteractionsProtocolStrictEventTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsProtocolStrictEventTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolStrictEventTableErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolStrictEventTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventUnionRequestTable;

class UnknownInteractionsProtocolFlexibleEventUnionRequest {
  public:

  UnknownInteractionsProtocolFlexibleEventUnionRequest() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleEventUnionRequest(const UnknownInteractionsProtocolFlexibleEventUnionRequest&) = default;
  UnknownInteractionsProtocolFlexibleEventUnionRequest& operator=(const UnknownInteractionsProtocolFlexibleEventUnionRequest&) = default;
  UnknownInteractionsProtocolFlexibleEventUnionRequest(UnknownInteractionsProtocolFlexibleEventUnionRequest&&) = default;
  UnknownInteractionsProtocolFlexibleEventUnionRequest& operator=(UnknownInteractionsProtocolFlexibleEventUnionRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal::kSomeField; }
  
  static UnknownInteractionsProtocolFlexibleEventUnionRequest WithSomeField(int32_t val) {
    UnknownInteractionsProtocolFlexibleEventUnionRequest result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleEventErr_ResultTable;

class UnknownInteractionsProtocolFlexibleEventErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse;

  UnknownInteractionsProtocolFlexibleEventErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleEventErrResult(const UnknownInteractionsProtocolFlexibleEventErrResult&) = default;
  UnknownInteractionsProtocolFlexibleEventErrResult& operator=(const UnknownInteractionsProtocolFlexibleEventErrResult&) = default;
  UnknownInteractionsProtocolFlexibleEventErrResult(UnknownInteractionsProtocolFlexibleEventErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleEventErrResult& operator=(UnknownInteractionsProtocolFlexibleEventErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleEventErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse val) {
    UnknownInteractionsProtocolFlexibleEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolFlexibleEventErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolFlexibleEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleEventFieldsErr_ResultTable;

class UnknownInteractionsProtocolFlexibleEventFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse;

  UnknownInteractionsProtocolFlexibleEventFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleEventFieldsErrResult(const UnknownInteractionsProtocolFlexibleEventFieldsErrResult&) = default;
  UnknownInteractionsProtocolFlexibleEventFieldsErrResult& operator=(const UnknownInteractionsProtocolFlexibleEventFieldsErrResult&) = default;
  UnknownInteractionsProtocolFlexibleEventFieldsErrResult(UnknownInteractionsProtocolFlexibleEventFieldsErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleEventFieldsErrResult& operator=(UnknownInteractionsProtocolFlexibleEventFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleEventFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse val) {
    UnknownInteractionsProtocolFlexibleEventFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolFlexibleEventFieldsErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolFlexibleEventFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleEventUnionErr_ResponseTable;

class UnknownInteractionsProtocolFlexibleEventUnionErrResponse {
  public:

  UnknownInteractionsProtocolFlexibleEventUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleEventUnionErrResponse(const UnknownInteractionsProtocolFlexibleEventUnionErrResponse&) = default;
  UnknownInteractionsProtocolFlexibleEventUnionErrResponse& operator=(const UnknownInteractionsProtocolFlexibleEventUnionErrResponse&) = default;
  UnknownInteractionsProtocolFlexibleEventUnionErrResponse(UnknownInteractionsProtocolFlexibleEventUnionErrResponse&&) = default;
  UnknownInteractionsProtocolFlexibleEventUnionErrResponse& operator=(UnknownInteractionsProtocolFlexibleEventUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsProtocolFlexibleEventUnionErrResponse WithSomeField(int32_t val) {
    UnknownInteractionsProtocolFlexibleEventUnionErrResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleEventUnionErr_ResultTable;

class UnknownInteractionsProtocolFlexibleEventUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse;

  UnknownInteractionsProtocolFlexibleEventUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleEventUnionErrResult(const UnknownInteractionsProtocolFlexibleEventUnionErrResult&) = default;
  UnknownInteractionsProtocolFlexibleEventUnionErrResult& operator=(const UnknownInteractionsProtocolFlexibleEventUnionErrResult&) = default;
  UnknownInteractionsProtocolFlexibleEventUnionErrResult(UnknownInteractionsProtocolFlexibleEventUnionErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleEventUnionErrResult& operator=(UnknownInteractionsProtocolFlexibleEventUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleEventUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse> val) {
    UnknownInteractionsProtocolFlexibleEventUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsProtocolFlexibleEventUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolFlexibleEventUnionErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolFlexibleEventUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleEventTableErr_ResultTable;

class UnknownInteractionsProtocolFlexibleEventTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse;

  UnknownInteractionsProtocolFlexibleEventTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleEventTableErrResult(const UnknownInteractionsProtocolFlexibleEventTableErrResult&) = default;
  UnknownInteractionsProtocolFlexibleEventTableErrResult& operator=(const UnknownInteractionsProtocolFlexibleEventTableErrResult&) = default;
  UnknownInteractionsProtocolFlexibleEventTableErrResult(UnknownInteractionsProtocolFlexibleEventTableErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleEventTableErrResult& operator=(UnknownInteractionsProtocolFlexibleEventTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleEventTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse> val) {
    UnknownInteractionsProtocolFlexibleEventTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsProtocolFlexibleEventTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolFlexibleEventTableErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolFlexibleEventTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayUnionResponseTable;

class UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
  public:

  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse(const UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse(UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse&&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse WithSomeField(int32_t val) {
    UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictTwoWayErr_ResultTable;

class UnknownInteractionsAjarProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse;

  UnknownInteractionsAjarProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictTwoWayErrResult(const UnknownInteractionsAjarProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayErrResult(UnknownInteractionsAjarProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsAjarProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse val) {
    UnknownInteractionsAjarProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolStrictTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_ResultTable;

class UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse;

  UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult(const UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult(UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult& operator=(UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse val) {
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_ResponseTable;

class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
  public:

  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse(const UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse& operator=(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse WithSomeField(int32_t val) {
    UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_ResultTable;

class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;

  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult(const UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult& operator=(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> val) {
    UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_ResultTable;

class UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;

  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult(const UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult(UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult& operator=(UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> val) {
    UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventUnionRequestTable;

class UnknownInteractionsAjarProtocolStrictEventUnionRequest {
  public:

  UnknownInteractionsAjarProtocolStrictEventUnionRequest() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictEventUnionRequest(const UnknownInteractionsAjarProtocolStrictEventUnionRequest&) = default;
  UnknownInteractionsAjarProtocolStrictEventUnionRequest& operator=(const UnknownInteractionsAjarProtocolStrictEventUnionRequest&) = default;
  UnknownInteractionsAjarProtocolStrictEventUnionRequest(UnknownInteractionsAjarProtocolStrictEventUnionRequest&&) = default;
  UnknownInteractionsAjarProtocolStrictEventUnionRequest& operator=(UnknownInteractionsAjarProtocolStrictEventUnionRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal::kSomeField; }
  
  static UnknownInteractionsAjarProtocolStrictEventUnionRequest WithSomeField(int32_t val) {
    UnknownInteractionsAjarProtocolStrictEventUnionRequest result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictEventErr_ResultTable;

class UnknownInteractionsAjarProtocolStrictEventErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse;

  UnknownInteractionsAjarProtocolStrictEventErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictEventErrResult(const UnknownInteractionsAjarProtocolStrictEventErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictEventErrResult& operator=(const UnknownInteractionsAjarProtocolStrictEventErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictEventErrResult(UnknownInteractionsAjarProtocolStrictEventErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictEventErrResult& operator=(UnknownInteractionsAjarProtocolStrictEventErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolStrictEventErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse val) {
    UnknownInteractionsAjarProtocolStrictEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolStrictEventErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolStrictEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictEventFieldsErr_ResultTable;

class UnknownInteractionsAjarProtocolStrictEventFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse;

  UnknownInteractionsAjarProtocolStrictEventFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictEventFieldsErrResult(const UnknownInteractionsAjarProtocolStrictEventFieldsErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictEventFieldsErrResult& operator=(const UnknownInteractionsAjarProtocolStrictEventFieldsErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictEventFieldsErrResult(UnknownInteractionsAjarProtocolStrictEventFieldsErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictEventFieldsErrResult& operator=(UnknownInteractionsAjarProtocolStrictEventFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolStrictEventFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse val) {
    UnknownInteractionsAjarProtocolStrictEventFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolStrictEventFieldsErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolStrictEventFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictEventUnionErr_ResponseTable;

class UnknownInteractionsAjarProtocolStrictEventUnionErrResponse {
  public:

  UnknownInteractionsAjarProtocolStrictEventUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictEventUnionErrResponse(const UnknownInteractionsAjarProtocolStrictEventUnionErrResponse&) = default;
  UnknownInteractionsAjarProtocolStrictEventUnionErrResponse& operator=(const UnknownInteractionsAjarProtocolStrictEventUnionErrResponse&) = default;
  UnknownInteractionsAjarProtocolStrictEventUnionErrResponse(UnknownInteractionsAjarProtocolStrictEventUnionErrResponse&&) = default;
  UnknownInteractionsAjarProtocolStrictEventUnionErrResponse& operator=(UnknownInteractionsAjarProtocolStrictEventUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsAjarProtocolStrictEventUnionErrResponse WithSomeField(int32_t val) {
    UnknownInteractionsAjarProtocolStrictEventUnionErrResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictEventUnionErr_ResultTable;

class UnknownInteractionsAjarProtocolStrictEventUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse;

  UnknownInteractionsAjarProtocolStrictEventUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictEventUnionErrResult(const UnknownInteractionsAjarProtocolStrictEventUnionErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictEventUnionErrResult& operator=(const UnknownInteractionsAjarProtocolStrictEventUnionErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictEventUnionErrResult(UnknownInteractionsAjarProtocolStrictEventUnionErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictEventUnionErrResult& operator=(UnknownInteractionsAjarProtocolStrictEventUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolStrictEventUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse> val) {
    UnknownInteractionsAjarProtocolStrictEventUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsAjarProtocolStrictEventUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolStrictEventUnionErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolStrictEventUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictEventTableErr_ResultTable;

class UnknownInteractionsAjarProtocolStrictEventTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse;

  UnknownInteractionsAjarProtocolStrictEventTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictEventTableErrResult(const UnknownInteractionsAjarProtocolStrictEventTableErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictEventTableErrResult& operator=(const UnknownInteractionsAjarProtocolStrictEventTableErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictEventTableErrResult(UnknownInteractionsAjarProtocolStrictEventTableErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictEventTableErrResult& operator=(UnknownInteractionsAjarProtocolStrictEventTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolStrictEventTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse> val) {
    UnknownInteractionsAjarProtocolStrictEventTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsAjarProtocolStrictEventTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolStrictEventTableErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolStrictEventTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventUnionRequestTable;

class UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
  public:

  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest(const UnknownInteractionsAjarProtocolFlexibleEventUnionRequest&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest& operator=(const UnknownInteractionsAjarProtocolFlexibleEventUnionRequest&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest(UnknownInteractionsAjarProtocolFlexibleEventUnionRequest&&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest& operator=(UnknownInteractionsAjarProtocolFlexibleEventUnionRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal::kSomeField; }
  
  static UnknownInteractionsAjarProtocolFlexibleEventUnionRequest WithSomeField(int32_t val) {
    UnknownInteractionsAjarProtocolFlexibleEventUnionRequest result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_FlexibleEventErr_ResultTable;

class UnknownInteractionsAjarProtocolFlexibleEventErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse;

  UnknownInteractionsAjarProtocolFlexibleEventErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolFlexibleEventErrResult(const UnknownInteractionsAjarProtocolFlexibleEventErrResult&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventErrResult& operator=(const UnknownInteractionsAjarProtocolFlexibleEventErrResult&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventErrResult(UnknownInteractionsAjarProtocolFlexibleEventErrResult&&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventErrResult& operator=(UnknownInteractionsAjarProtocolFlexibleEventErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolFlexibleEventErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse val) {
    UnknownInteractionsAjarProtocolFlexibleEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolFlexibleEventErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolFlexibleEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_ResultTable;

class UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse;

  UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult(const UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult& operator=(const UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult(UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult&&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult& operator=(UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse val) {
    UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_ResponseTable;

class UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse {
  public:

  UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse(const UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse& operator=(const UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse(UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse&&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse& operator=(UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse WithSomeField(int32_t val) {
    UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_ResultTable;

class UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse;

  UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult(const UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult& operator=(const UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult(UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult&&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult& operator=(UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse> val) {
    UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_FlexibleEventTableErr_ResultTable;

class UnknownInteractionsAjarProtocolFlexibleEventTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse;

  UnknownInteractionsAjarProtocolFlexibleEventTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolFlexibleEventTableErrResult(const UnknownInteractionsAjarProtocolFlexibleEventTableErrResult&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableErrResult& operator=(const UnknownInteractionsAjarProtocolFlexibleEventTableErrResult&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableErrResult(UnknownInteractionsAjarProtocolFlexibleEventTableErrResult&&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableErrResult& operator=(UnknownInteractionsAjarProtocolFlexibleEventTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolFlexibleEventTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse> val) {
    UnknownInteractionsAjarProtocolFlexibleEventTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsAjarProtocolFlexibleEventTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolFlexibleEventTableErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolFlexibleEventTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayUnionResponseTable;

class UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
  public:

  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse(const UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse(UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse&&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse WithSomeField(int32_t val) {
    UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictTwoWayErr_ResultTable;

class UnknownInteractionsClosedProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse;

  UnknownInteractionsClosedProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictTwoWayErrResult(const UnknownInteractionsClosedProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayErrResult(UnknownInteractionsClosedProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsClosedProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse val) {
    UnknownInteractionsClosedProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedProtocolStrictTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_ResultTable;

class UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse;

  UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult(const UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult(UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult& operator=(UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse val) {
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_ResponseTable;

class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
  public:

  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse(const UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse& operator=(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse WithSomeField(int32_t val) {
    UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_ResultTable;

class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;

  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult(const UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult& operator=(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> val) {
    UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_ResultTable;

class UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;

  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult(const UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult(UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult& operator=(UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> val) {
    UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventUnionRequestTable;

class UnknownInteractionsClosedProtocolStrictEventUnionRequest {
  public:

  UnknownInteractionsClosedProtocolStrictEventUnionRequest() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictEventUnionRequest(const UnknownInteractionsClosedProtocolStrictEventUnionRequest&) = default;
  UnknownInteractionsClosedProtocolStrictEventUnionRequest& operator=(const UnknownInteractionsClosedProtocolStrictEventUnionRequest&) = default;
  UnknownInteractionsClosedProtocolStrictEventUnionRequest(UnknownInteractionsClosedProtocolStrictEventUnionRequest&&) = default;
  UnknownInteractionsClosedProtocolStrictEventUnionRequest& operator=(UnknownInteractionsClosedProtocolStrictEventUnionRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal::kSomeField; }
  
  static UnknownInteractionsClosedProtocolStrictEventUnionRequest WithSomeField(int32_t val) {
    UnknownInteractionsClosedProtocolStrictEventUnionRequest result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictEventErr_ResultTable;

class UnknownInteractionsClosedProtocolStrictEventErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse;

  UnknownInteractionsClosedProtocolStrictEventErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictEventErrResult(const UnknownInteractionsClosedProtocolStrictEventErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictEventErrResult& operator=(const UnknownInteractionsClosedProtocolStrictEventErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictEventErrResult(UnknownInteractionsClosedProtocolStrictEventErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictEventErrResult& operator=(UnknownInteractionsClosedProtocolStrictEventErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedProtocolStrictEventErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse val) {
    UnknownInteractionsClosedProtocolStrictEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedProtocolStrictEventErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedProtocolStrictEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictEventFieldsErr_ResultTable;

class UnknownInteractionsClosedProtocolStrictEventFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse;

  UnknownInteractionsClosedProtocolStrictEventFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictEventFieldsErrResult(const UnknownInteractionsClosedProtocolStrictEventFieldsErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictEventFieldsErrResult& operator=(const UnknownInteractionsClosedProtocolStrictEventFieldsErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictEventFieldsErrResult(UnknownInteractionsClosedProtocolStrictEventFieldsErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictEventFieldsErrResult& operator=(UnknownInteractionsClosedProtocolStrictEventFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedProtocolStrictEventFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse val) {
    UnknownInteractionsClosedProtocolStrictEventFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedProtocolStrictEventFieldsErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedProtocolStrictEventFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictEventUnionErr_ResponseTable;

class UnknownInteractionsClosedProtocolStrictEventUnionErrResponse {
  public:

  UnknownInteractionsClosedProtocolStrictEventUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictEventUnionErrResponse(const UnknownInteractionsClosedProtocolStrictEventUnionErrResponse&) = default;
  UnknownInteractionsClosedProtocolStrictEventUnionErrResponse& operator=(const UnknownInteractionsClosedProtocolStrictEventUnionErrResponse&) = default;
  UnknownInteractionsClosedProtocolStrictEventUnionErrResponse(UnknownInteractionsClosedProtocolStrictEventUnionErrResponse&&) = default;
  UnknownInteractionsClosedProtocolStrictEventUnionErrResponse& operator=(UnknownInteractionsClosedProtocolStrictEventUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsClosedProtocolStrictEventUnionErrResponse WithSomeField(int32_t val) {
    UnknownInteractionsClosedProtocolStrictEventUnionErrResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictEventUnionErr_ResultTable;

class UnknownInteractionsClosedProtocolStrictEventUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse;

  UnknownInteractionsClosedProtocolStrictEventUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictEventUnionErrResult(const UnknownInteractionsClosedProtocolStrictEventUnionErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictEventUnionErrResult& operator=(const UnknownInteractionsClosedProtocolStrictEventUnionErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictEventUnionErrResult(UnknownInteractionsClosedProtocolStrictEventUnionErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictEventUnionErrResult& operator=(UnknownInteractionsClosedProtocolStrictEventUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedProtocolStrictEventUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse> val) {
    UnknownInteractionsClosedProtocolStrictEventUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsClosedProtocolStrictEventUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedProtocolStrictEventUnionErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedProtocolStrictEventUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictEventTableErr_ResultTable;

class UnknownInteractionsClosedProtocolStrictEventTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse;

  UnknownInteractionsClosedProtocolStrictEventTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictEventTableErrResult(const UnknownInteractionsClosedProtocolStrictEventTableErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictEventTableErrResult& operator=(const UnknownInteractionsClosedProtocolStrictEventTableErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictEventTableErrResult(UnknownInteractionsClosedProtocolStrictEventTableErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictEventTableErrResult& operator=(UnknownInteractionsClosedProtocolStrictEventTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedProtocolStrictEventTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse> val) {
    UnknownInteractionsClosedProtocolStrictEventTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsClosedProtocolStrictEventTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedProtocolStrictEventTableErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedProtocolStrictEventTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayUnionResponseTable;

class UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
  public:

  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse(const UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse(UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse&&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse WithSomeField(int32_t val) {
    UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_StrictTwoWayErr_ResultTable;

class UnknownInteractionsDriverProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse;

  UnknownInteractionsDriverProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolStrictTwoWayErrResult(const UnknownInteractionsDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayErrResult(UnknownInteractionsDriverProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsDriverProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse val) {
    UnknownInteractionsDriverProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsDriverProtocolStrictTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsDriverProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_ResultTable;

class UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse;

  UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult(const UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult(UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult& operator=(UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse val) {
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult WithErr(int32_t val) {
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_ResponseTable;

class UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
  public:

  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse(const UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse& operator=(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse WithSomeField(int32_t val) {
    UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_ResultTable;

class UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;

  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult(const UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult&&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult& operator=(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> val) {
    UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult WithErr(int32_t val) {
    UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_ResultTable;

class UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;

  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult(const UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult(UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult&&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult& operator=(UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> val) {
    UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult WithErr(int32_t val) {
    UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWay_ResultTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolFlexibleTwoWayResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayResult(UnknownInteractionsDriverProtocolFlexibleTwoWayResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_ResultTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_ResponseTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
  public:

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse WithSomeField(int32_t val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_ResultTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_ResultTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult(UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_ResultTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult(UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_ResultTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult WithErr(int32_t val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_ResponseTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
  public:

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse WithSomeField(int32_t val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_ResultTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult WithErr(int32_t val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_ResultTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult(UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult WithErr(int32_t val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponseTable;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
  public:

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse(const UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse&&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse WithSomeField(int32_t val) {
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_ResultTable;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse;

  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult(const UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult(UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse val) {
    UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_ResultTable;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse;

  UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult(const UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult(UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse val) {
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_ResponseTable;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
  public:

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse(const UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse WithSomeField(int32_t val) {
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_ResultTable;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult(const UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult&&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> val) {
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_ResultTable;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;

  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult(const UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult&&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> val) {
    UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponseTable;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
  public:

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse(const UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse&&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse WithSomeField(int32_t val) {
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_ResultTable;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse;

  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult(const UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult(UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse val) {
    UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_ResultTable;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse;

  UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult(const UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult(UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse val) {
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_ResponseTable;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
  public:

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse(const UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField; }
  
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse WithSomeField(int32_t val) {
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_ResultTable;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult(const UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult&&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> val) {
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_ResultTable;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;

  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult(const UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult&&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> val) {
    UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};
  
  
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayErrTopResponseTable;

struct UnknownInteractionsProtocolStrictTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponseTable;

struct UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponseTable;

struct UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayTableErrTopResponseTable;

struct UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTopResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTableTopResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayErrTopResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult result = {};
};
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventErrRequestTable;

struct UnknownInteractionsProtocolStrictEventErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventFieldsErrRequestTable;

struct UnknownInteractionsProtocolStrictEventFieldsErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventUnionErrRequestTable;

struct UnknownInteractionsProtocolStrictEventUnionErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventTableErrRequestTable;

struct UnknownInteractionsProtocolStrictEventTableErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult result = {};
};
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventErrRequestTable;

struct UnknownInteractionsProtocolFlexibleEventErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventFieldsErrRequestTable;

struct UnknownInteractionsProtocolFlexibleEventFieldsErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventUnionErrRequestTable;

struct UnknownInteractionsProtocolFlexibleEventUnionErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventTableErrRequestTable;

struct UnknownInteractionsProtocolFlexibleEventTableErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult result = {};
};
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponseTable;

struct UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponseTable;

struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponseTable;

struct UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponseTable;

struct UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult result = {};
};
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventErrRequestTable;

struct UnknownInteractionsAjarProtocolStrictEventErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventFieldsErrRequestTable;

struct UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventUnionErrRequestTable;

struct UnknownInteractionsAjarProtocolStrictEventUnionErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventTableErrRequestTable;

struct UnknownInteractionsAjarProtocolStrictEventTableErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult result = {};
};
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventErrRequestTable;

struct UnknownInteractionsAjarProtocolFlexibleEventErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequestTable;

struct UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequestTable;

struct UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventTableErrRequestTable;

struct UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult result = {};
};
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponseTable;

struct UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponseTable;

struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponseTable;

struct UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponseTable;

struct UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult result = {};
};
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventErrRequestTable;

struct UnknownInteractionsClosedProtocolStrictEventErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventFieldsErrRequestTable;

struct UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventUnionErrRequestTable;

struct UnknownInteractionsClosedProtocolStrictEventUnionErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventTableErrRequestTable;

struct UnknownInteractionsClosedProtocolStrictEventTableErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult result = {};
};
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponseTable;

struct UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponseTable;

struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponseTable;

struct UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponseTable;

struct UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult result = {};
};
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponseTable;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponseTable;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponseTable;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponseTable;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult result = {};
};
    
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponseTable;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult result = {};
};
    
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponseTable;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponseTable;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult result = {};
};
    



extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponseTable;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult result = {};
};

  }  // namespace wire
}  // namespace test_unknowninteractions
namespace fidl {


  
  
  


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayFieldsResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_StrictTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_StrictTwoWayFieldsErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayTableErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWay_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayFields_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTableTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolStrictEventFieldsRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_StrictEventErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolStrictEventErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_StrictEventFieldsErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolStrictEventFieldsErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolStrictEventUnionErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolStrictEventTableErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventFieldsRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_FlexibleEventErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_FlexibleEventFieldsErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventFieldsErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventUnionErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventTableErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventFieldsRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictEventErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictEventFieldsErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventFieldsErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventUnionErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventTableErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventFieldsRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocol_FlexibleEventErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventTableErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventFieldsRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictEventErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictEventFieldsErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventFieldsErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventUnionErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventTableErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocol_StrictTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWay_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse));
    } else {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};
  


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
    fidl_envelope_v2_t* envelopes = static_cast<fidl_envelope_v2_t*>(vec->data);
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t encode_inline_size = 0;
      switch (i) {
        case 0:
          encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
      switch (i) {
        case 0:
          encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_v2_t);
      WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
    }
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
    if (!inner_depth.IsValid()) {
      return;
    }

    ::fidl::internal::WirePosition vector_position;
    if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
      return;
    }

    fidl_vector_t* vec = position.As<fidl_vector_t>();
    for (size_t i = 0; i < vec->count; i++) {
      
      size_t decode_inline_size = 0;
      switch (i) {
        case 0:
          decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
          break;
      }
      DecodeFn<IsRecursive> decode_fn = nullptr;
      switch(i) {
        case 0:
          decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
          break;
      }
      ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_v2_t), inner_depth);
    }
  }
};
  


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kTransportErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kTransportErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr uint32_t kMaxOutOfLineV1 = 32;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

  }  // namespace fidl

