// WARNING: This file is machine generated by fidlgen.
  
  // fidl_experiment = no_optional_structs
  // fidl_experiment = output_index_json
  // fidl_experiment = simple_empty_response_syntax
  // fidl_experiment = unknown_interactions

  #pragma once

  #include <cinttypes>

  #include <lib/fidl/cpp/wire/internal/transport_err.h>
  #include <lib/fidl/cpp/wire/array.h>
  #include <lib/fidl/cpp/wire/envelope.h>
  #include <lib/fidl/cpp/wire/message_storage.h>
  #include <lib/fidl/cpp/wire/message.h>
  #include <lib/fidl/cpp/wire/object_view.h>
  #include <lib/fidl/cpp/wire/string_view.h>
  #include <lib/fidl/cpp/wire/traits.h>
  #include <lib/fidl/cpp/wire/wire_types.h>
  #include <lib/stdcompat/optional.h>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>
    #include <lib/zx/handle.h>
    #include <lib/zx/socket.h>
    

#endif  // __Fuchsia__


  #include <fidl/test.protocols/cpp/markers.h>
  #include <fidl/test.protocols/cpp/common_types.h>
  

  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wshadow"

  namespace test_protocols {


  
  
namespace wire {
using ErrorEnum = ::test_protocols::ErrorEnum;
  


struct WithAndWithoutRequestResponseNoRequestWithResponseResponse;


struct WithAndWithoutRequestResponseWithRequestNoResponseRequest;


struct WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;


struct WithAndWithoutRequestResponseWithRequestWithResponseRequest;


struct WithAndWithoutRequestResponseWithRequestWithResponseResponse;


struct WithAndWithoutRequestResponseOnWithResponseRequest;


struct WithErrorSyntaxResponseAsStructResponse;


struct WithErrorSyntaxResponseAsStructTopResponse;


struct WithErrorSyntaxErrorAsPrimitiveResponse;


struct WithErrorSyntaxErrorAsPrimitiveTopResponse;


struct WithErrorSyntaxErrorAsEnumResponse;


struct WithErrorSyntaxErrorAsEnumTopResponse;


struct WithErrorSyntaxHandleInResultResponse;


struct WithErrorSyntaxHandleInResultTopResponse;


struct ChannelProtocolMethodARequest;


struct ChannelProtocolEventARequest;


struct ChannelProtocolMethodBRequest;


struct ChannelProtocolMethodBResponse;


struct ChannelProtocolTakeHandleRequest;


struct ChannelProtocolMutateSocketRequest;


struct ChannelProtocolMutateSocketResponse;


struct SyscallProtocolMethodCRequest;


struct TransitionalRequestRequest;


struct TransitionalRequestResponse;


struct TransitionalOneWayRequest;


struct TransitionalEventRequest;


struct HandleRightsProtocolNoResponseMethodRequest;


struct HandleRightsProtocolResponseMethodRequest;


struct HandleRightsProtocolResponseMethodResponse;


struct HandleRightsProtocolAnEventRequest;


struct ProtocolEnds;


struct WithProtocolEndsClientEndsRequest;


struct WithProtocolEndsClientEndsResponse;


struct WithProtocolEndsServerEndsRequest;


struct WithProtocolEndsServerEndsResponse;


struct WithProtocolEndsStructContainingEndsRequest;


struct WithProtocolEndsStructContainingEndsResponse;


struct ManyParametersFifteenRequest;


struct MethodWithUnionUnionMethodRequest;


struct MethodWithUnionUnionMethodResponse;
  
  


class WithErrorSyntaxResponseAsStructResult;


class WithErrorSyntaxErrorAsPrimitiveResult;


class WithErrorSyntaxErrorAsEnumResult;


class WithErrorSyntaxHandleInResultResult;


class TheUnion;
    
    
    
    
    
    
    
    
    



extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;

struct WithErrorSyntaxErrorAsPrimitiveResponse {

    uint8_t __reserved = {};
};
    
    



extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;

struct WithErrorSyntaxErrorAsEnumResponse {

    uint8_t __reserved = {};
};
    
    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;

struct WithErrorSyntaxHandleInResultResponse {

    ::zx::handle h = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    
    
    
    
    
    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_ChannelProtocolTakeHandleRequestTable;

struct ChannelProtocolTakeHandleRequest {

    ::zx::handle h = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketRequestTable;

struct ChannelProtocolMutateSocketRequest {

    ::zx::socket a = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketResponseTable;

struct ChannelProtocolMutateSocketResponse {

    ::zx::socket b = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    
    
    
    
    
    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

struct HandleRightsProtocolNoResponseMethodRequest {

    ::zx::socket h = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodRequestTable;

struct HandleRightsProtocolResponseMethodRequest {

    ::zx::socket h = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodResponseTable;

struct HandleRightsProtocolResponseMethodResponse {

    ::zx::socket h = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_HandleRightsProtocolAnEventRequestTable;

struct HandleRightsProtocolAnEventRequest {

    ::zx::socket h = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    
    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsRequestTable;

struct WithProtocolEndsClientEndsRequest {

    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> in = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsResponseTable;

struct WithProtocolEndsClientEndsResponse {

    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> out = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsRequestTable;

struct WithProtocolEndsServerEndsRequest {

    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> in = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsResponseTable;

struct WithProtocolEndsServerEndsResponse {

    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> out = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    
    
    
    
    
  
  



extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ResponseAsStruct_ResultTable;

class WithErrorSyntaxResponseAsStructResult {
  public:
  using Response = test_protocols::wire::WithErrorSyntaxResponseAsStructResponse;

  WithErrorSyntaxResponseAsStructResult() : ordinal_(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal::Invalid), envelope_{} {}

  WithErrorSyntaxResponseAsStructResult(const WithErrorSyntaxResponseAsStructResult&) = default;
  WithErrorSyntaxResponseAsStructResult& operator=(const WithErrorSyntaxResponseAsStructResult&) = default;
  WithErrorSyntaxResponseAsStructResult(WithErrorSyntaxResponseAsStructResult&&) = default;
  WithErrorSyntaxResponseAsStructResult& operator=(WithErrorSyntaxResponseAsStructResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal::kResponse; }
  
  static WithErrorSyntaxResponseAsStructResult WithResponse(::fidl::ObjectView<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse> val) {
    WithErrorSyntaxResponseAsStructResult result;
    result.ordinal_ = ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal::kResponse;
    result.envelope_.As<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>().set_data(std::move(val));
    return result;
  }

  
  template <typename... Args>
  static WithErrorSyntaxResponseAsStructResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>(allocator,
                                         std::forward<Args>(args)...));
  }


  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal::kResponse);
    return envelope_.As<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>().get_data();
  }
  const ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal::kResponse);
    return envelope_.As<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal::kErr; }
  
  static WithErrorSyntaxResponseAsStructResult WithErr(uint32_t val) {
    WithErrorSyntaxResponseAsStructResult result;
    result.ordinal_ = ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResultTable;

class WithErrorSyntaxErrorAsPrimitiveResult {
  public:
  using Response = test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse;

  WithErrorSyntaxErrorAsPrimitiveResult() : ordinal_(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::Invalid), envelope_{} {}

  WithErrorSyntaxErrorAsPrimitiveResult(const WithErrorSyntaxErrorAsPrimitiveResult&) = default;
  WithErrorSyntaxErrorAsPrimitiveResult& operator=(const WithErrorSyntaxErrorAsPrimitiveResult&) = default;
  WithErrorSyntaxErrorAsPrimitiveResult(WithErrorSyntaxErrorAsPrimitiveResult&&) = default;
  WithErrorSyntaxErrorAsPrimitiveResult& operator=(WithErrorSyntaxErrorAsPrimitiveResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kResponse; }
  
  static WithErrorSyntaxErrorAsPrimitiveResult WithResponse(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse val) {
    WithErrorSyntaxErrorAsPrimitiveResult result;
    result.ordinal_ = ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kResponse;
    result.envelope_.As<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>().set_data(std::move(val));
    return result;
  }


  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kResponse);
    return envelope_.As<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>().get_data();
  }
  const ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kResponse);
    return envelope_.As<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kErr; }
  
  static WithErrorSyntaxErrorAsPrimitiveResult WithErr(uint32_t val) {
    WithErrorSyntaxErrorAsPrimitiveResult result;
    result.ordinal_ = ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ErrorAsEnum_ResultTable;

class WithErrorSyntaxErrorAsEnumResult {
  public:
  using Response = test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse;

  WithErrorSyntaxErrorAsEnumResult() : ordinal_(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal::Invalid), envelope_{} {}

  WithErrorSyntaxErrorAsEnumResult(const WithErrorSyntaxErrorAsEnumResult&) = default;
  WithErrorSyntaxErrorAsEnumResult& operator=(const WithErrorSyntaxErrorAsEnumResult&) = default;
  WithErrorSyntaxErrorAsEnumResult(WithErrorSyntaxErrorAsEnumResult&&) = default;
  WithErrorSyntaxErrorAsEnumResult& operator=(WithErrorSyntaxErrorAsEnumResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal::kResponse; }
  
  static WithErrorSyntaxErrorAsEnumResult WithResponse(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse val) {
    WithErrorSyntaxErrorAsEnumResult result;
    result.ordinal_ = ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal::kResponse;
    result.envelope_.As<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>().set_data(std::move(val));
    return result;
  }


  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal::kResponse);
    return envelope_.As<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>().get_data();
  }
  const ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal::kResponse);
    return envelope_.As<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal::kErr; }
  
  static WithErrorSyntaxErrorAsEnumResult WithErr(::test_protocols::wire::ErrorEnum val) {
    WithErrorSyntaxErrorAsEnumResult result;
    result.ordinal_ = ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal::kErr;
    result.envelope_.As<::test_protocols::wire::ErrorEnum>().set_data(std::move(val));
    return result;
  }


  ::test_protocols::wire::ErrorEnum& err() {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal::kErr);
    return envelope_.As<::test_protocols::wire::ErrorEnum>().get_data();
  }
  const ::test_protocols::wire::ErrorEnum& err() const {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal::kErr);
    return envelope_.As<::test_protocols::wire::ErrorEnum>().get_data();
  }
  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithErrorSyntax_HandleInResult_ResultTable;

class WithErrorSyntaxHandleInResultResult {
  public:
  using Response = test_protocols::wire::WithErrorSyntaxHandleInResultResponse;

  WithErrorSyntaxHandleInResultResult() : ordinal_(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal::Invalid), envelope_{} {}

  
  ~WithErrorSyntaxHandleInResultResult();
  WithErrorSyntaxHandleInResultResult(WithErrorSyntaxHandleInResultResult&& other) {
    _Move(std::move(other));
  }
  WithErrorSyntaxHandleInResultResult& operator=(WithErrorSyntaxHandleInResultResult&& other) {
    if (this != &other) {
      _Move(std::move(other));
    }
    return *this;
  }

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal::kResponse; }
  
  static WithErrorSyntaxHandleInResultResult WithResponse(::test_protocols::wire::WithErrorSyntaxHandleInResultResponse val) {
    WithErrorSyntaxHandleInResultResult result;
    result.ordinal_ = ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal::kResponse;
    result.envelope_.As<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse>().set_data(std::move(val));
    return result;
  }


  ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal::kResponse);
    return envelope_.As<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse>().get_data();
  }
  const ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal::kResponse);
    return envelope_.As<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal::kErr; }
  
  static WithErrorSyntaxHandleInResultResult WithErr(uint32_t val) {
    WithErrorSyntaxHandleInResultResult result;
    result.ordinal_ = ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag>(ordinal_);
  }
  void _CloseHandles();

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };
  void _Move(WithErrorSyntaxHandleInResultResult&& other);

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

#endif  // __Fuchsia__




extern "C" const fidl_type_t test_protocols_TheUnionTable;

class TheUnion {
  public:

  TheUnion() : ordinal_(::test_protocols::wire::TheUnion::Ordinal::Invalid), envelope_{} {}

  TheUnion(const TheUnion&) = default;
  TheUnion& operator=(const TheUnion&) = default;
  TheUnion(TheUnion&&) = default;
  TheUnion& operator=(TheUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kV = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_protocols::wire::TheUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const { return ordinal_ == ::test_protocols::wire::TheUnion::Ordinal::Invalid; }

  bool is_v() const { return ordinal_ == ::test_protocols::wire::TheUnion::Ordinal::kV; }
  
  static TheUnion WithV(uint32_t val) {
    TheUnion result;
    result.ordinal_ = ::test_protocols::wire::TheUnion::Ordinal::kV;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }


  uint32_t& v() {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::TheUnion::Ordinal::kV);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& v() const {
    ZX_ASSERT(ordinal_ == ::test_protocols::wire::TheUnion::Ordinal::kV);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocols::wire::TheUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kV = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::TheUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};
  
  
    



extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;

struct WithAndWithoutRequestResponseNoRequestWithResponseResponse {

    ::fidl::StringView ret = {};
};
    



extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

struct WithAndWithoutRequestResponseWithRequestNoResponseRequest {

    ::fidl::StringView arg = {};
};
    



extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

struct WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {

    ::fidl::StringView arg = {};
};
    



extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

struct WithAndWithoutRequestResponseWithRequestWithResponseRequest {

    ::fidl::StringView arg = {};
};
    



extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;

struct WithAndWithoutRequestResponseWithRequestWithResponseResponse {

    ::fidl::StringView ret = {};
};
    



extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

struct WithAndWithoutRequestResponseOnWithResponseRequest {

    ::fidl::StringView ret = {};
};
    



extern "C" const fidl_type_t test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;

struct WithErrorSyntaxResponseAsStructResponse {

    int64_t a = {};

    int64_t b = {};

    int64_t c = {};
};
    



extern "C" const fidl_type_t test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

struct WithErrorSyntaxResponseAsStructTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxResponseAsStructResult;

    ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result = {};
};
    
    



extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

struct WithErrorSyntaxErrorAsPrimitiveTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult;

    ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result = {};
};
    
    



extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

struct WithErrorSyntaxErrorAsEnumTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxErrorAsEnumResult;

    ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result = {};
};
    
    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;

struct WithErrorSyntaxHandleInResultTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxHandleInResultResult;

    ::test_protocols::wire::WithErrorSyntaxHandleInResultResult result = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    



extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;

struct ChannelProtocolMethodARequest {

    int64_t a = {};

    int64_t b = {};
};
    



extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;

struct ChannelProtocolEventARequest {

    int64_t a = {};

    int64_t b = {};
};
    



extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;

struct ChannelProtocolMethodBRequest {

    int64_t a = {};

    int64_t b = {};
};
    



extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBResponseTable;

struct ChannelProtocolMethodBResponse {

    int64_t result = {};
};
    
    
    
    



extern "C" const fidl_type_t test_protocols_SyscallProtocolMethodCRequestTable;

struct SyscallProtocolMethodCRequest {

    int64_t a = {};

    int64_t b = {};
};
    



extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;

struct TransitionalRequestRequest {

    int64_t x = {};
};
    



extern "C" const fidl_type_t test_protocols_TransitionalRequestResponseTable;

struct TransitionalRequestResponse {

    int64_t y = {};
};
    



extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;

struct TransitionalOneWayRequest {

    int64_t x = {};
};
    



extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;

struct TransitionalEventRequest {

    int64_t x = {};
};
    
    
    
    
    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_ProtocolEndsTable;

struct ProtocolEnds {

    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client = {};

    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server = {};

    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client_opt = {};

    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server_opt = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    
    
    
    
    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

struct WithProtocolEndsStructContainingEndsRequest {

    ::test_protocols::wire::ProtocolEnds in = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsResponseTable;

struct WithProtocolEndsStructContainingEndsResponse {

    ::test_protocols::wire::ProtocolEnds out = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

    



extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;

struct ManyParametersFifteenRequest {

    bool p1 = {};

    bool p2 = {};

    bool p3 = {};

    bool p4 = {};

    bool p5 = {};

    bool p6 = {};

    bool p7 = {};

    bool p8 = {};

    bool p9 = {};

    bool p10 = {};

    bool p11 = {};

    bool p12 = {};

    bool p13 = {};

    bool p14 = {};

    bool p15 = {};
};
    



extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodRequestTable;

struct MethodWithUnionUnionMethodRequest {

    ::test_protocols::wire::TheUnion u = {};
};
    



extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodResponseTable;

struct MethodWithUnionUnionMethodResponse {

    ::fidl::WireOptional<::test_protocols::wire::TheUnion> u = {};
};

  }  // namespace wire
}  // namespace test_protocols
namespace fidl {


  
  
template <bool IsRecursive>
struct internal::WireCodingTraits<::test_protocols::wire::ErrorEnum, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = sizeof(uint32_t);
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocols::wire::ErrorEnum* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    switch (*value) {
      case ::test_protocols::wire::ErrorEnum::kErrFoo:
      case ::test_protocols::wire::ErrorEnum::kErrBar:
        break;
      default:
        encoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
        return;
    }
    *position.As<::test_protocols::wire::ErrorEnum>() = *value;
  }
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    [[maybe_unused]] ::test_protocols::wire::ErrorEnum value = *position.As<::test_protocols::wire::ErrorEnum>();
    switch (value) {
      case ::test_protocols::wire::ErrorEnum::kErrFoo:
      case ::test_protocols::wire::ErrorEnum::kErrBar:
        break;
      default:
        decoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
        return;
    }
  }
};


  


template<>
struct TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse>);
static_assert(offsetof(::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse, ret) == 0);
static_assert(sizeof(::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse) == TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse));
    } else {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Encode(encoder, &value->ret, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest>);
static_assert(offsetof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest, arg) == 0);
static_assert(sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest) == TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest));
    } else {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Encode(encoder, &value->arg, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>);
static_assert(offsetof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, arg) == 0);
static_assert(sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest) == TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest));
    } else {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Encode(encoder, &value->arg, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest>);
static_assert(offsetof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest, arg) == 0);
static_assert(sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest) == TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest));
    } else {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Encode(encoder, &value->arg, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse>);
static_assert(offsetof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse, ret) == 0);
static_assert(sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse) == TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse));
    } else {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Encode(encoder, &value->ret, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest>);
static_assert(offsetof(::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest, ret) == 0);
static_assert(sizeof(::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest) == TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest));
    } else {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Encode(encoder, &value->ret, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 24;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>);
static_assert(offsetof(::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse, a) == 0);
static_assert(offsetof(::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse, b) == 8);
static_assert(offsetof(::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse, c) == 16);
static_assert(sizeof(::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse) == TypeTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 24;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse));
    } else {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->c, position + 16, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 16, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse>);
static_assert(offsetof(::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse, result) == 0);
static_assert(sizeof(::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse) == TypeTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse));
    } else {
      internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>);
static_assert(offsetof(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse, __reserved) == 0);
static_assert(sizeof(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse) == TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse>);
static_assert(offsetof(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse, result) == 0);
static_assert(sizeof(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse) == TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse));
    } else {
      internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>);
static_assert(offsetof(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse, __reserved) == 0);
static_assert(sizeof(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse) == TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse>);
static_assert(offsetof(::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse, result) == 0);
static_assert(sizeof(::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse) == TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse));
    } else {
      internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse>);
static_assert(offsetof(::test_protocols::wire::WithErrorSyntaxHandleInResultResponse, h) == 0);
static_assert(sizeof(::test_protocols::wire::WithErrorSyntaxHandleInResultResponse) == TypeTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithErrorSyntaxHandleInResultResponse));
    } else {
      internal::WireCodingTraits<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->h, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse>);
static_assert(offsetof(::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse, result) == 0);
static_assert(sizeof(::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse) == TypeTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_protocols::wire::WithErrorSyntaxHandleInResultResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse));
    } else {
      internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__



template<>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMethodARequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMethodARequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMethodARequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::ChannelProtocolMethodARequest>);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodARequest, a) == 0);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodARequest, b) == 8);
static_assert(sizeof(::test_protocols::wire::ChannelProtocolMethodARequest) == TypeTraits<::test_protocols::wire::ChannelProtocolMethodARequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolMethodARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolMethodARequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::ChannelProtocolMethodARequest));
    } else {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::ChannelProtocolEventARequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolEventARequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolEventARequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::ChannelProtocolEventARequest>);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolEventARequest, a) == 0);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolEventARequest, b) == 8);
static_assert(sizeof(::test_protocols::wire::ChannelProtocolEventARequest) == TypeTraits<::test_protocols::wire::ChannelProtocolEventARequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolEventARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolEventARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolEventARequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::ChannelProtocolEventARequest));
    } else {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMethodBRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMethodBRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMethodBRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::ChannelProtocolMethodBRequest>);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodBRequest, a) == 0);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodBRequest, b) == 8);
static_assert(sizeof(::test_protocols::wire::ChannelProtocolMethodBRequest) == TypeTraits<::test_protocols::wire::ChannelProtocolMethodBRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolMethodBRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolMethodBRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::ChannelProtocolMethodBRequest));
    } else {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMethodBResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMethodBResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMethodBResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::ChannelProtocolMethodBResponse>);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodBResponse, result) == 0);
static_assert(sizeof(::test_protocols::wire::ChannelProtocolMethodBResponse) == TypeTraits<::test_protocols::wire::ChannelProtocolMethodBResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolMethodBResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolMethodBResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::ChannelProtocolMethodBResponse));
    } else {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::ChannelProtocolTakeHandleRequest> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolTakeHandleRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolTakeHandleRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::ChannelProtocolTakeHandleRequest>);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolTakeHandleRequest, h) == 0);
static_assert(sizeof(::test_protocols::wire::ChannelProtocolTakeHandleRequest) == TypeTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolTakeHandleRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolTakeHandleRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::ChannelProtocolTakeHandleRequest));
    } else {
      internal::WireCodingTraits<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->h, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::ChannelProtocolMutateSocketRequest> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMutateSocketRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMutateSocketRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::ChannelProtocolMutateSocketRequest>);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMutateSocketRequest, a) == 0);
static_assert(sizeof(::test_protocols::wire::ChannelProtocolMutateSocketRequest) == TypeTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x80000000, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolMutateSocketRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolMutateSocketRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::ChannelProtocolMutateSocketRequest));
    } else {
      internal::WireCodingTraits<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x80000000, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::ChannelProtocolMutateSocketResponse> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMutateSocketResponse> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMutateSocketResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMutateSocketResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::ChannelProtocolMutateSocketResponse>);
static_assert(offsetof(::test_protocols::wire::ChannelProtocolMutateSocketResponse, b) == 0);
static_assert(sizeof(::test_protocols::wire::ChannelProtocolMutateSocketResponse) == TypeTraits<::test_protocols::wire::ChannelProtocolMutateSocketResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x80000000, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolMutateSocketResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolMutateSocketResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::ChannelProtocolMutateSocketResponse));
    } else {
      internal::WireCodingTraits<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->b, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x80000000, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__



template<>
struct TypeTraits<::test_protocols::wire::SyscallProtocolMethodCRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::SyscallProtocolMethodCRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::SyscallProtocolMethodCRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::SyscallProtocolMethodCRequest>);
static_assert(offsetof(::test_protocols::wire::SyscallProtocolMethodCRequest, a) == 0);
static_assert(offsetof(::test_protocols::wire::SyscallProtocolMethodCRequest, b) == 8);
static_assert(sizeof(::test_protocols::wire::SyscallProtocolMethodCRequest) == TypeTraits<::test_protocols::wire::SyscallProtocolMethodCRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::SyscallProtocolMethodCRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::SyscallProtocolMethodCRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::SyscallProtocolMethodCRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::SyscallProtocolMethodCRequest));
    } else {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::TransitionalRequestRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::TransitionalRequestRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::TransitionalRequestRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::TransitionalRequestRequest>);
static_assert(offsetof(::test_protocols::wire::TransitionalRequestRequest, x) == 0);
static_assert(sizeof(::test_protocols::wire::TransitionalRequestRequest) == TypeTraits<::test_protocols::wire::TransitionalRequestRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalRequestRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::TransitionalRequestRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::TransitionalRequestRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::TransitionalRequestRequest));
    } else {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->x, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::TransitionalRequestResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::TransitionalRequestResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::TransitionalRequestResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::TransitionalRequestResponse>);
static_assert(offsetof(::test_protocols::wire::TransitionalRequestResponse, y) == 0);
static_assert(sizeof(::test_protocols::wire::TransitionalRequestResponse) == TypeTraits<::test_protocols::wire::TransitionalRequestResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalRequestResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::TransitionalRequestResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::TransitionalRequestResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::TransitionalRequestResponse));
    } else {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->y, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::TransitionalOneWayRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::TransitionalOneWayRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::TransitionalOneWayRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::TransitionalOneWayRequest>);
static_assert(offsetof(::test_protocols::wire::TransitionalOneWayRequest, x) == 0);
static_assert(sizeof(::test_protocols::wire::TransitionalOneWayRequest) == TypeTraits<::test_protocols::wire::TransitionalOneWayRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalOneWayRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::TransitionalOneWayRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::TransitionalOneWayRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::TransitionalOneWayRequest));
    } else {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->x, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::TransitionalEventRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::TransitionalEventRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::TransitionalEventRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::TransitionalEventRequest>);
static_assert(offsetof(::test_protocols::wire::TransitionalEventRequest, x) == 0);
static_assert(sizeof(::test_protocols::wire::TransitionalEventRequest) == TypeTraits<::test_protocols::wire::TransitionalEventRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::TransitionalEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::TransitionalEventRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::TransitionalEventRequest));
    } else {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->x, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest>);
static_assert(offsetof(::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest, h) == 0);
static_assert(sizeof(::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest) == TypeTraits<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest));
    } else {
      internal::WireCodingTraits<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>, IsRecursive>::Encode(encoder, &value->h, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest>);
static_assert(offsetof(::test_protocols::wire::HandleRightsProtocolResponseMethodRequest, h) == 0);
static_assert(sizeof(::test_protocols::wire::HandleRightsProtocolResponseMethodRequest) == TypeTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::HandleRightsProtocolResponseMethodRequest));
    } else {
      internal::WireCodingTraits<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>, IsRecursive>::Encode(encoder, &value->h, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse>);
static_assert(offsetof(::test_protocols::wire::HandleRightsProtocolResponseMethodResponse, h) == 0);
static_assert(sizeof(::test_protocols::wire::HandleRightsProtocolResponseMethodResponse) == TypeTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x2, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::HandleRightsProtocolResponseMethodResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::HandleRightsProtocolResponseMethodResponse));
    } else {
      internal::WireCodingTraits<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x2, false>, IsRecursive>::Encode(encoder, &value->h, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x2, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::HandleRightsProtocolAnEventRequest> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::HandleRightsProtocolAnEventRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::HandleRightsProtocolAnEventRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::HandleRightsProtocolAnEventRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::HandleRightsProtocolAnEventRequest>);
static_assert(offsetof(::test_protocols::wire::HandleRightsProtocolAnEventRequest, h) == 0);
static_assert(sizeof(::test_protocols::wire::HandleRightsProtocolAnEventRequest) == TypeTraits<::test_protocols::wire::HandleRightsProtocolAnEventRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolAnEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::HandleRightsProtocolAnEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::HandleRightsProtocolAnEventRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::HandleRightsProtocolAnEventRequest));
    } else {
      internal::WireCodingTraits<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>, IsRecursive>::Encode(encoder, &value->h, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::ProtocolEnds> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::ProtocolEnds> {
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ProtocolEnds> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ProtocolEnds> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::ProtocolEnds>);
static_assert(offsetof(::test_protocols::wire::ProtocolEnds, client) == 0);
static_assert(offsetof(::test_protocols::wire::ProtocolEnds, server) == 4);
static_assert(offsetof(::test_protocols::wire::ProtocolEnds, client_opt) == 8);
static_assert(offsetof(::test_protocols::wire::ProtocolEnds, server_opt) == 12);
static_assert(sizeof(::test_protocols::wire::ProtocolEnds) == TypeTraits<::test_protocols::wire::ProtocolEnds>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ProtocolEnds, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ProtocolEnds, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::ProtocolEnds* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::ProtocolEnds));
    } else {
      internal::WireCodingTraits<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->client, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->server, position + 4, recursion_depth);
      internal::WireCodingTraits<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Encode(encoder, &value->client_opt, position + 8, recursion_depth);
      internal::WireCodingTraits<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Encode(encoder, &value->server_opt, position + 12, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
      internal::WireCodingTraits<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
      internal::WireCodingTraits<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Decode(
        decoder, position + 12, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsClientEndsRequest> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsClientEndsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsClientEndsRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithProtocolEndsClientEndsRequest>);
static_assert(offsetof(::test_protocols::wire::WithProtocolEndsClientEndsRequest, in) == 0);
static_assert(sizeof(::test_protocols::wire::WithProtocolEndsClientEndsRequest) == TypeTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithProtocolEndsClientEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithProtocolEndsClientEndsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithProtocolEndsClientEndsRequest));
    } else {
      internal::WireCodingTraits<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->in, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsClientEndsResponse> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsClientEndsResponse> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsClientEndsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsClientEndsResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithProtocolEndsClientEndsResponse>);
static_assert(offsetof(::test_protocols::wire::WithProtocolEndsClientEndsResponse, out) == 0);
static_assert(sizeof(::test_protocols::wire::WithProtocolEndsClientEndsResponse) == TypeTraits<::test_protocols::wire::WithProtocolEndsClientEndsResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithProtocolEndsClientEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithProtocolEndsClientEndsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithProtocolEndsClientEndsResponse));
    } else {
      internal::WireCodingTraits<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Encode(encoder, &value->out, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsServerEndsRequest> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsServerEndsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsServerEndsRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithProtocolEndsServerEndsRequest>);
static_assert(offsetof(::test_protocols::wire::WithProtocolEndsServerEndsRequest, in) == 0);
static_assert(sizeof(::test_protocols::wire::WithProtocolEndsServerEndsRequest) == TypeTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithProtocolEndsServerEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithProtocolEndsServerEndsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithProtocolEndsServerEndsRequest));
    } else {
      internal::WireCodingTraits<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Encode(encoder, &value->in, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsServerEndsResponse> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsServerEndsResponse> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsServerEndsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsServerEndsResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithProtocolEndsServerEndsResponse>);
static_assert(offsetof(::test_protocols::wire::WithProtocolEndsServerEndsResponse, out) == 0);
static_assert(sizeof(::test_protocols::wire::WithProtocolEndsServerEndsResponse) == TypeTraits<::test_protocols::wire::WithProtocolEndsServerEndsResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithProtocolEndsServerEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithProtocolEndsServerEndsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithProtocolEndsServerEndsResponse));
    } else {
      internal::WireCodingTraits<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->out, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest> {
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest>);
static_assert(offsetof(::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest, in) == 0);
static_assert(sizeof(::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest) == TypeTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_protocols::wire::ProtocolEnds, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest));
    } else {
      internal::WireCodingTraits<::test_protocols::wire::ProtocolEnds, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->in, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_protocols::wire::ProtocolEnds, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__


#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse> : public std::true_type {};

template<>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse> {
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse>);
static_assert(offsetof(::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse, out) == 0);
static_assert(sizeof(::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse) == TypeTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_protocols::wire::ProtocolEnds, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse));
    } else {
      internal::WireCodingTraits<::test_protocols::wire::ProtocolEnds, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->out, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_protocols::wire::ProtocolEnds, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};

#endif  // __Fuchsia__



template<>
struct TypeTraits<::test_protocols::wire::ManyParametersFifteenRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 15;
  static constexpr uint32_t kPrimarySizeV1 = 15;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ManyParametersFifteenRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ManyParametersFifteenRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::ManyParametersFifteenRequest>);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p1) == 0);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p2) == 1);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p3) == 2);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p4) == 3);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p5) == 4);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p6) == 5);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p7) == 6);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p8) == 7);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p9) == 8);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p10) == 9);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p11) == 10);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p12) == 11);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p13) == 12);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p14) == 13);
static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p15) == 14);
static_assert(sizeof(::test_protocols::wire::ManyParametersFifteenRequest) == TypeTraits<::test_protocols::wire::ManyParametersFifteenRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ManyParametersFifteenRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 15;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ManyParametersFifteenRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::ManyParametersFifteenRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::ManyParametersFifteenRequest));
    } else {
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p1, position + 0, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p2, position + 1, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p3, position + 2, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p4, position + 3, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p5, position + 4, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p6, position + 5, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p7, position + 6, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p8, position + 7, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p9, position + 8, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p10, position + 9, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p11, position + 10, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p12, position + 11, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p13, position + 12, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p14, position + 13, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->p15, position + 14, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 1, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 2, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 3, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 5, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 6, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 7, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 9, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 10, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 11, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 12, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 13, recursion_depth);
      internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 14, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::MethodWithUnionUnionMethodRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::MethodWithUnionUnionMethodRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::MethodWithUnionUnionMethodRequest>);
static_assert(offsetof(::test_protocols::wire::MethodWithUnionUnionMethodRequest, u) == 0);
static_assert(sizeof(::test_protocols::wire::MethodWithUnionUnionMethodRequest) == TypeTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_protocols::wire::TheUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::MethodWithUnionUnionMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::MethodWithUnionUnionMethodRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::MethodWithUnionUnionMethodRequest));
    } else {
      internal::WireCodingTraits<::test_protocols::wire::TheUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->u, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_protocols::wire::TheUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


template<>
struct TypeTraits<::test_protocols::wire::MethodWithUnionUnionMethodResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::MethodWithUnionUnionMethodResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::MethodWithUnionUnionMethodResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::MethodWithUnionUnionMethodResponse>);
static_assert(offsetof(::test_protocols::wire::MethodWithUnionUnionMethodResponse, u) == 0);
static_assert(sizeof(::test_protocols::wire::MethodWithUnionUnionMethodResponse) == TypeTraits<::test_protocols::wire::MethodWithUnionUnionMethodResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::WireOptional<::test_protocols::wire::TheUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::MethodWithUnionUnionMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_protocols::wire::MethodWithUnionUnionMethodResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_protocols::wire::MethodWithUnionUnionMethodResponse));
    } else {
      internal::WireCodingTraits<::fidl::WireOptional<::test_protocols::wire::TheUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->u, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::fidl::WireOptional<::test_protocols::wire::TheUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};
  
  


template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag tag = *position.As<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag tag = *position.As<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocols::wire::ErrorEnum, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_protocols::wire::ErrorEnum, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag tag = *position.As<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocols::wire::ErrorEnum, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_protocols::wire::ErrorEnum, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithErrorSyntaxHandleInResultResult> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResult> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxHandleInResultResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::WithErrorSyntaxHandleInResultResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::WithErrorSyntaxHandleInResultResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxHandleInResultResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag::kResponse
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag::kErr
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag tag = *position.As<::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag::kResponse:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag::kErr:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#endif  // __Fuchsia__



template <>
struct TypeTraits<::test_protocols::wire::TheUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::TheUnion> : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::TheUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_protocols::wire::TheUnion>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::TheUnion, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocols::wire::TheUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t encode_inline_size;
    switch (u->tag) {
      case 1: // ::test_protocols::wire::TheUnion::Tag::kV
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        encode_inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_protocols::wire::TheUnion::Tag::kV
        encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_protocols::wire::TheUnion::Tag tag = *position.As<::test_protocols::wire::TheUnion::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t decode_inline_size;
    switch (tag) {
      case ::test_protocols::wire::TheUnion::Tag::kV:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        decode_inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_protocols::wire::TheUnion::Tag::kV:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::TheUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_protocols::wire::TheUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

  #pragma clang diagnostic pop

  }  // namespace fidl

