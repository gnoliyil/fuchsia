// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include <lib/fidl/cpp/wire/internal/display_error.h>
#include <lib/fidl/cpp/wire/traits.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_enum {

enum class MyStrictEnum : uint32_t {

  kFoo = 1u,

  kBar = 2u,
};

}  // namespace test_enum

template <>
struct fidl::internal::DisplayError<::test_enum::MyStrictEnum> {
  static size_t Format(const ::test_enum::MyStrictEnum& value, char* destination, size_t capacity);
};

namespace fidl {

constexpr inline auto ToUnderlying(::test_enum::MyStrictEnum value) -> uint32_t {
  return static_cast<uint32_t>(value);
}

}  // namespace fidl
namespace test_enum {

class MyFlexibleEnum final {
 private:
  enum class EnumForSwitching_ : uint32_t {

    kFoo = 1u,

    kBar = 2u,

    _do_not_handle_this__write_a_default_case_instead = 0xffffffff,
  };

  constexpr explicit MyFlexibleEnum(EnumForSwitching_ value) : value_(static_cast<uint32_t>(value)) {}

 public:
  constexpr MyFlexibleEnum() : value_(static_cast<uint32_t>(Unknown())) {}
  constexpr explicit MyFlexibleEnum(uint32_t value) : value_(value) {}
  constexpr operator EnumForSwitching_() const { return static_cast<EnumForSwitching_>(value_); }
  constexpr explicit operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

        return false;
    }
    return true;
  }

  // Returns an enum corresponding to the member designated as @unknown in the
  // FIDL schema if exists, or a compiler-reserved unknown value otherwise.
  constexpr static MyFlexibleEnum Unknown() {
    return MyFlexibleEnum(0xffffffff);
  }

  static const MyFlexibleEnum kFoo;

  static const MyFlexibleEnum kBar;

 private:
  uint32_t value_;
};
constexpr const ::test_enum::MyFlexibleEnum MyFlexibleEnum::kFoo =
    ::test_enum::MyFlexibleEnum(1u);
constexpr const ::test_enum::MyFlexibleEnum MyFlexibleEnum::kBar =
    ::test_enum::MyFlexibleEnum(2u);

}  // namespace test_enum

template <>
struct fidl::internal::DisplayError<::test_enum::MyFlexibleEnum> {
  static size_t Format(const ::test_enum::MyFlexibleEnum& value, char* destination, size_t capacity);
};

namespace fidl {

constexpr inline auto ToUnderlying(::test_enum::MyFlexibleEnum value) -> uint32_t {
  return static_cast<uint32_t>(value);
}

}  // namespace fidl
namespace test_enum {

class MyFlexibleEnumWithCustomUnknown final {
 private:
  enum class EnumForSwitching_ : uint32_t {

    kFoo = 1u,

    kBar = 2u,

    kCustomUnknown = 3u,

    _do_not_handle_this__write_a_default_case_instead = 0xffffffff,
  };

  constexpr explicit MyFlexibleEnumWithCustomUnknown(EnumForSwitching_ value) : value_(static_cast<uint32_t>(value)) {}

 public:
  constexpr MyFlexibleEnumWithCustomUnknown() : value_(static_cast<uint32_t>(Unknown())) {}
  constexpr explicit MyFlexibleEnumWithCustomUnknown(uint32_t value) : value_(value) {}
  constexpr operator EnumForSwitching_() const { return static_cast<EnumForSwitching_>(value_); }
  constexpr explicit operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

        return false;
    }
    return true;
  }

  // Returns an enum corresponding to the member designated as @unknown in the
  // FIDL schema if exists, or a compiler-reserved unknown value otherwise.
  constexpr static MyFlexibleEnumWithCustomUnknown Unknown() {
    return MyFlexibleEnumWithCustomUnknown(0x3);
  }

  static const MyFlexibleEnumWithCustomUnknown kFoo;

  static const MyFlexibleEnumWithCustomUnknown kBar;

  static const MyFlexibleEnumWithCustomUnknown kCustomUnknown;

 private:
  uint32_t value_;
};
constexpr const ::test_enum::MyFlexibleEnumWithCustomUnknown MyFlexibleEnumWithCustomUnknown::kFoo =
    ::test_enum::MyFlexibleEnumWithCustomUnknown(1u);
constexpr const ::test_enum::MyFlexibleEnumWithCustomUnknown MyFlexibleEnumWithCustomUnknown::kBar =
    ::test_enum::MyFlexibleEnumWithCustomUnknown(2u);
constexpr const ::test_enum::MyFlexibleEnumWithCustomUnknown MyFlexibleEnumWithCustomUnknown::kCustomUnknown =
    ::test_enum::MyFlexibleEnumWithCustomUnknown(3u);

}  // namespace test_enum

template <>
struct fidl::internal::DisplayError<::test_enum::MyFlexibleEnumWithCustomUnknown> {
  static size_t Format(const ::test_enum::MyFlexibleEnumWithCustomUnknown& value, char* destination, size_t capacity);
};

namespace fidl {

constexpr inline auto ToUnderlying(::test_enum::MyFlexibleEnumWithCustomUnknown value) -> uint32_t {
  return static_cast<uint32_t>(value);
}

}  // namespace fidl
namespace test_enum {

class MyEmptyFlexibleEnum final {
 private:
  enum class EnumForSwitching_ : uint32_t {

    _do_not_handle_this__write_a_default_case_instead = 0xffffffff,
  };

  constexpr explicit MyEmptyFlexibleEnum(EnumForSwitching_ value) : value_(static_cast<uint32_t>(value)) {}

 public:
  constexpr MyEmptyFlexibleEnum() : value_(static_cast<uint32_t>(Unknown())) {}
  constexpr explicit MyEmptyFlexibleEnum(uint32_t value) : value_(value) {}
  constexpr operator EnumForSwitching_() const { return static_cast<EnumForSwitching_>(value_); }
  constexpr explicit operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    return true;
  }

  // Returns an enum corresponding to the member designated as @unknown in the
  // FIDL schema if exists, or a compiler-reserved unknown value otherwise.
  constexpr static MyEmptyFlexibleEnum Unknown() {
    return MyEmptyFlexibleEnum(0xffffffff);
  }

 private:
  uint32_t value_;
};

}  // namespace test_enum

template <>
struct fidl::internal::DisplayError<::test_enum::MyEmptyFlexibleEnum> {
  static size_t Format(const ::test_enum::MyEmptyFlexibleEnum& value, char* destination, size_t capacity);
};

namespace fidl {

constexpr inline auto ToUnderlying(::test_enum::MyEmptyFlexibleEnum value) -> uint32_t {
  return static_cast<uint32_t>(value);
}

template <>
struct IsFidlType<::test_enum::MyStrictEnum> : public std::true_type {};
template <>
struct ContainsHandle<::test_enum::MyStrictEnum> : public std::false_type {};

template <>
struct IsFidlType<::test_enum::MyFlexibleEnum> : public std::true_type {};
template <>
struct ContainsHandle<::test_enum::MyFlexibleEnum> : public std::false_type {};

template <>
struct IsFidlType<::test_enum::MyFlexibleEnumWithCustomUnknown> : public std::true_type {};
template <>
struct ContainsHandle<::test_enum::MyFlexibleEnumWithCustomUnknown> : public std::false_type {};

template <>
struct IsFidlType<::test_enum::MyEmptyFlexibleEnum> : public std::true_type {};
template <>
struct ContainsHandle<::test_enum::MyEmptyFlexibleEnum> : public std::false_type {};

#pragma clang diagnostic pop

}  // namespace fidl
