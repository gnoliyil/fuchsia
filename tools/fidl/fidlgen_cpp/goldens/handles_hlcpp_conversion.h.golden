// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include <fidl/fdf/cpp/hlcpp_conversion.h>
#include <fidl/test.handles/cpp/natural_types.h>
#include <lib/fidl/cpp/hlcpp_conversion.h>
#include <lib/fidl/cpp/wire/service_handler.h>
#include <test/handles/cpp/fidl.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace fidl {
namespace internal {

template <>
struct NaturalToHLCPPTraits<fidl::ClientEnd<::test_handles::SomeProtocol>> {
  using HLCPPType = fidl::InterfaceHandle<::test::handles::SomeProtocol>;
  static inline fidl::InterfaceHandle<::test::handles::SomeProtocol> Convert(fidl::ClientEnd<::test_handles::SomeProtocol>&& c) {
    return fidl::InterfaceHandle<::test::handles::SomeProtocol>(c.TakeChannel());
  }
};

template <>
struct NaturalToHLCPPTraits<fidl::ServerEnd<::test_handles::SomeProtocol>> {
  using HLCPPType = fidl::InterfaceRequest<::test::handles::SomeProtocol>;
  static inline fidl::InterfaceRequest<::test::handles::SomeProtocol> Convert(fidl::ServerEnd<::test_handles::SomeProtocol>&& c) {
    return fidl::InterfaceRequest<::test::handles::SomeProtocol>(c.TakeChannel());
  }
};

template <>
struct HLCPPToNaturalTraits<fidl::InterfaceHandle<::test::handles::SomeProtocol>> {
  using NaturalType = fidl::ClientEnd<::test_handles::SomeProtocol>;
  static inline fidl::ClientEnd<::test_handles::SomeProtocol> Convert(fidl::InterfaceHandle<::test::handles::SomeProtocol>&& c) {
    return fidl::ClientEnd<::test_handles::SomeProtocol>(c.TakeChannel());
  }
};

template <>
struct HLCPPToNaturalTraits<fidl::InterfaceRequest<::test::handles::SomeProtocol>> {
  using NaturalType = fidl::ServerEnd<::test_handles::SomeProtocol>;
  static inline fidl::ServerEnd<::test_handles::SomeProtocol> Convert(fidl::InterfaceRequest<::test::handles::SomeProtocol>&& c) {
    return fidl::ServerEnd<::test_handles::SomeProtocol>(c.TakeChannel());
  }
};

template <>
struct NaturalToHLCPPTraits<fidl::ProtocolHandler<::test_handles::SomeProtocol>> {
  using HLCPPType = fidl::InterfaceRequestHandler<::test::handles::SomeProtocol>;
  static inline fidl::InterfaceRequestHandler<::test::handles::SomeProtocol> Convert(fidl::ProtocolHandler<::test_handles::SomeProtocol>&& c) {
    return [c = std::move(c)](fidl::InterfaceRequest<::test::handles::SomeProtocol> r) {
      c(::fidl::HLCPPToNatural(r));
    };
  }
};

template <>
struct HLCPPToNaturalTraits<fidl::InterfaceRequestHandler<::test::handles::SomeProtocol>> {
  using NaturalType = fidl::ProtocolHandler<::test_handles::SomeProtocol>;
  static inline fidl::ProtocolHandler<::test_handles::SomeProtocol> Convert(fidl::InterfaceRequestHandler<::test::handles::SomeProtocol>&& c) {
    return [c = std::move(c)](fidl::ServerEnd<::test_handles::SomeProtocol> r) {
      c(::fidl::NaturalToHLCPP(r));
    };
  }
};

template <>
struct NaturalToHLCPPTraits<::test_handles::Handles> {
  using HLCPPType = ::test::handles::Handles;
  static inline ::test::handles::Handles Convert(::test_handles::Handles&&);
};
template <>
struct HLCPPToNaturalTraits<::test::handles::Handles> {
  using NaturalType = ::test_handles::Handles;
  static inline ::test_handles::Handles Convert(::test::handles::Handles&&);
};
template <>
struct NaturalToHLCPPTraits<::test_handles::FdfHandles> {
  using HLCPPType = ::test::handles::FdfHandles;
  static inline ::test::handles::FdfHandles Convert(::test_handles::FdfHandles&&);
};
template <>
struct HLCPPToNaturalTraits<::test::handles::FdfHandles> {
  using NaturalType = ::test_handles::FdfHandles;
  static inline ::test_handles::FdfHandles Convert(::test::handles::FdfHandles&&);
};

::test::handles::Handles NaturalToHLCPPTraits<::test_handles::Handles>::Convert(::test_handles::Handles&& value) {
  ::test::handles::Handles hlcpp;
  hlcpp.plain_handle = ::fidl::NaturalToHLCPP(std::move(value.plain_handle()));
  hlcpp.bti_handle = ::fidl::NaturalToHLCPP(std::move(value.bti_handle()));
  hlcpp.channel_handle = ::fidl::NaturalToHLCPP(std::move(value.channel_handle()));
  hlcpp.clock_handle = ::fidl::NaturalToHLCPP(std::move(value.clock_handle()));
  hlcpp.debuglog_handle = ::fidl::NaturalToHLCPP(std::move(value.debuglog_handle()));
  hlcpp.event_handle = ::fidl::NaturalToHLCPP(std::move(value.event_handle()));
  hlcpp.eventpair_handle = ::fidl::NaturalToHLCPP(std::move(value.eventpair_handle()));
  hlcpp.exception_handle = ::fidl::NaturalToHLCPP(std::move(value.exception_handle()));
  hlcpp.fifo_handle = ::fidl::NaturalToHLCPP(std::move(value.fifo_handle()));
  hlcpp.guest_handle = ::fidl::NaturalToHLCPP(std::move(value.guest_handle()));
  hlcpp.interrupt_handle = ::fidl::NaturalToHLCPP(std::move(value.interrupt_handle()));
  hlcpp.iommu_handle = ::fidl::NaturalToHLCPP(std::move(value.iommu_handle()));
  hlcpp.job_handle = ::fidl::NaturalToHLCPP(std::move(value.job_handle()));
  hlcpp.msi_handle = ::fidl::NaturalToHLCPP(std::move(value.msi_handle()));
  hlcpp.pager_handle = ::fidl::NaturalToHLCPP(std::move(value.pager_handle()));
  hlcpp.pmt_handle = ::fidl::NaturalToHLCPP(std::move(value.pmt_handle()));
  hlcpp.port_handle = ::fidl::NaturalToHLCPP(std::move(value.port_handle()));
  hlcpp.process_handle = ::fidl::NaturalToHLCPP(std::move(value.process_handle()));
  hlcpp.profile_handle = ::fidl::NaturalToHLCPP(std::move(value.profile_handle()));
  hlcpp.resource_handle = ::fidl::NaturalToHLCPP(std::move(value.resource_handle()));
  hlcpp.socket_handle = ::fidl::NaturalToHLCPP(std::move(value.socket_handle()));
  hlcpp.stream_handle = ::fidl::NaturalToHLCPP(std::move(value.stream_handle()));
  hlcpp.suspendtoken_handle = ::fidl::NaturalToHLCPP(std::move(value.suspendtoken_handle()));
  hlcpp.thread_handle = ::fidl::NaturalToHLCPP(std::move(value.thread_handle()));
  hlcpp.timer_handle = ::fidl::NaturalToHLCPP(std::move(value.timer_handle()));
  hlcpp.vcpu_handle = ::fidl::NaturalToHLCPP(std::move(value.vcpu_handle()));
  hlcpp.vmar_handle = ::fidl::NaturalToHLCPP(std::move(value.vmar_handle()));
  hlcpp.vmo_handle = ::fidl::NaturalToHLCPP(std::move(value.vmo_handle()));
  hlcpp.rights_handle = ::fidl::NaturalToHLCPP(std::move(value.rights_handle()));
  hlcpp.aliased_plain_handle_field = ::fidl::NaturalToHLCPP(std::move(value.aliased_plain_handle_field()));
  hlcpp.aliased_subtype_handle_field = ::fidl::NaturalToHLCPP(std::move(value.aliased_subtype_handle_field()));
  hlcpp.aliased_rights_handle_field = ::fidl::NaturalToHLCPP(std::move(value.aliased_rights_handle_field()));
  hlcpp.some_protocol = ::fidl::NaturalToHLCPP(std::move(value.some_protocol()));
  hlcpp.request_some_protocol = ::fidl::NaturalToHLCPP(std::move(value.request_some_protocol()));
  return hlcpp;
}

::test_handles::Handles HLCPPToNaturalTraits<::test::handles::Handles>::Convert(::test::handles::Handles&& value) {
  return ::test_handles::Handles{{
      .plain_handle = ::fidl::HLCPPToNatural(std::move(value.plain_handle)),
      .bti_handle = ::fidl::HLCPPToNatural(std::move(value.bti_handle)),
      .channel_handle = ::fidl::HLCPPToNatural(std::move(value.channel_handle)),
      .clock_handle = ::fidl::HLCPPToNatural(std::move(value.clock_handle)),
      .debuglog_handle = ::fidl::HLCPPToNatural(std::move(value.debuglog_handle)),
      .event_handle = ::fidl::HLCPPToNatural(std::move(value.event_handle)),
      .eventpair_handle = ::fidl::HLCPPToNatural(std::move(value.eventpair_handle)),
      .exception_handle = ::fidl::HLCPPToNatural(std::move(value.exception_handle)),
      .fifo_handle = ::fidl::HLCPPToNatural(std::move(value.fifo_handle)),
      .guest_handle = ::fidl::HLCPPToNatural(std::move(value.guest_handle)),
      .interrupt_handle = ::fidl::HLCPPToNatural(std::move(value.interrupt_handle)),
      .iommu_handle = ::fidl::HLCPPToNatural(std::move(value.iommu_handle)),
      .job_handle = ::fidl::HLCPPToNatural(std::move(value.job_handle)),
      .msi_handle = ::fidl::HLCPPToNatural(std::move(value.msi_handle)),
      .pager_handle = ::fidl::HLCPPToNatural(std::move(value.pager_handle)),
      .pmt_handle = ::fidl::HLCPPToNatural(std::move(value.pmt_handle)),
      .port_handle = ::fidl::HLCPPToNatural(std::move(value.port_handle)),
      .process_handle = ::fidl::HLCPPToNatural(std::move(value.process_handle)),
      .profile_handle = ::fidl::HLCPPToNatural(std::move(value.profile_handle)),
      .resource_handle = ::fidl::HLCPPToNatural(std::move(value.resource_handle)),
      .socket_handle = ::fidl::HLCPPToNatural(std::move(value.socket_handle)),
      .stream_handle = ::fidl::HLCPPToNatural(std::move(value.stream_handle)),
      .suspendtoken_handle = ::fidl::HLCPPToNatural(std::move(value.suspendtoken_handle)),
      .thread_handle = ::fidl::HLCPPToNatural(std::move(value.thread_handle)),
      .timer_handle = ::fidl::HLCPPToNatural(std::move(value.timer_handle)),
      .vcpu_handle = ::fidl::HLCPPToNatural(std::move(value.vcpu_handle)),
      .vmar_handle = ::fidl::HLCPPToNatural(std::move(value.vmar_handle)),
      .vmo_handle = ::fidl::HLCPPToNatural(std::move(value.vmo_handle)),
      .rights_handle = ::fidl::HLCPPToNatural(std::move(value.rights_handle)),
      .aliased_plain_handle_field = ::fidl::HLCPPToNatural(std::move(value.aliased_plain_handle_field)),
      .aliased_subtype_handle_field = ::fidl::HLCPPToNatural(std::move(value.aliased_subtype_handle_field)),
      .aliased_rights_handle_field = ::fidl::HLCPPToNatural(std::move(value.aliased_rights_handle_field)),
      .some_protocol = ::fidl::HLCPPToNatural(std::move(value.some_protocol)),
      .request_some_protocol = ::fidl::HLCPPToNatural(std::move(value.request_some_protocol)),
  }};
}
::test::handles::FdfHandles NaturalToHLCPPTraits<::test_handles::FdfHandles>::Convert(::test_handles::FdfHandles&& value) {
  ::test::handles::FdfHandles hlcpp;
  hlcpp.fdf_channel_handle = ::fidl::NaturalToHLCPP(std::move(value.fdf_channel_handle()));
  hlcpp.client_end_driver = ::fidl::NaturalToHLCPP(std::move(value.client_end_driver()));
  hlcpp.server_end_driver = ::fidl::NaturalToHLCPP(std::move(value.server_end_driver()));
  return hlcpp;
}

::test_handles::FdfHandles HLCPPToNaturalTraits<::test::handles::FdfHandles>::Convert(::test::handles::FdfHandles&& value) {
  return ::test_handles::FdfHandles{{
      .fdf_channel_handle = ::fidl::HLCPPToNatural(std::move(value.fdf_channel_handle)),
      .client_end_driver = ::fidl::HLCPPToNatural(std::move(value.client_end_driver)),
      .server_end_driver = ::fidl::HLCPPToNatural(std::move(value.server_end_driver)),
  }};
}

#pragma clang diagnostic pop

}  // namespace internal
}  // namespace fidl
