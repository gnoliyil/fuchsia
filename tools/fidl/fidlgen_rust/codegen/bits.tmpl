{{/*
// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
*/}}

{{- define "BitsDeclaration" }}
bitflags! {
    {{- range .DocComments }}
    ///{{ . }}
    {{- end }}
    #[derive(Default)]
    pub struct {{ .Name }}: {{ .UnderlyingType }} {
        {{- range .Members }}
        {{- range .DocComments }}
        ///{{ . }}
        {{- end }}
        const {{ .Name }} = {{ .Value }};
        {{- end }}
    }
}

impl {{ .Name }} {
    {{- if .IsStrict }}
    #[deprecated = "Strict bits should not use `has_unknown_bits`"]
    #[inline(always)]
    pub fn has_unknown_bits(&self) -> bool {
        false
    }

    #[deprecated = "Strict bits should not use `get_unknown_bits`"]
    #[inline(always)]
    pub fn get_unknown_bits(&self) -> {{ .UnderlyingType }} {
        0
    }
    {{- else }}
    #[inline(always)]
    pub fn from_bits_allow_unknown(bits: {{ .UnderlyingType }}) -> Self {
        {{- /* TODO(fxbug.dev/124335): Use `from_bits_retain` instead. */}}
        unsafe { Self::from_bits_unchecked(bits) }
    }

    #[inline(always)]
    pub fn has_unknown_bits(&self) -> bool {
        self.get_unknown_bits() != 0
    }

    #[inline(always)]
    pub fn get_unknown_bits(&self) -> {{ .UnderlyingType }} {
        self.bits & !Self::all().bits
    }
    {{- end }}
}
{{ end }}

{{- define "BitsInternal" -}}
unsafe impl fidl::encoding::TypeMarker for {{ .Name }} {
    type Owned = Self;

    #[inline(always)]
    fn inline_align(_context: fidl::encoding::Context) -> usize {
        {{ .Type.TypeShapeV2.Alignment }}
    }

    #[inline(always)]
    fn inline_size(_context: fidl::encoding::Context) -> usize {
        {{ .Type.TypeShapeV2.InlineSize }}
    }
}

impl fidl::encoding::ValueTypeMarker for {{ .Name }} {
    type Borrowed<'a> = Self;
    #[inline(always)]
    fn borrow<'a>(value: &'a <Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'a> {
        *value
    }
}

unsafe impl fidl::encoding::Encode<Self> for {{ .Name }} {
    #[inline]
    unsafe fn encode(self, encoder: &mut fidl::encoding::Encoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        encoder.debug_check_bounds::<Self>(offset);
        {{- if .IsStrict }}
        if self.bits & Self::all().bits != self.bits {
            return Err(fidl::Error::InvalidBitsValue);
        }
        {{- end }}
        encoder.write_num(self.bits, offset);
        Ok(())
    }
}

impl fidl::encoding::Decode<Self> for {{ .Name }} {
    #[inline(always)]
    fn new_empty() -> Self {
        Self::empty()
    }

    #[inline]
    unsafe fn decode(&mut self, decoder: &mut fidl::encoding::Decoder<'_>, offset: usize, _depth: fidl::encoding::Depth) -> fidl::Result<()> {
        decoder.debug_check_bounds::<Self>(offset);
        let prim = decoder.read_num::<{{ .UnderlyingType }}>(offset);
        {{- if .IsStrict }}
        *self = Self::from_bits(prim).ok_or(fidl::Error::InvalidBitsValue)?;
        {{- else }}
        *self = Self::from_bits_allow_unknown(prim);
        {{- end }}
        Ok(())
    }
}
{{- end }}
