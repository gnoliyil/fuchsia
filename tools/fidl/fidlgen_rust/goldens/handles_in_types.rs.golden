// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use {
    bitflags::bitflags,
    fidl::{
        client::QueryResponseFut,
        endpoints::{ControlHandle as _, Responder as _},
    },
    fuchsia_zircon_status as zx_status,
    futures::future::{self, MaybeDone, TryFutureExt},
};

#[cfg(target_os = "fuchsia")]
use fuchsia_zircon as zx;

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[repr(u32)]
pub enum ObjType {
    None = 0,
    Vmo = 3,
}

impl ObjType {
    #[inline]
    pub fn from_primitive(prim: u32) -> Option<Self> {
        match prim {
            0 => Some(Self::None),
            3 => Some(Self::Vmo),
            _ => None,
        }
    }

    #[inline]
    pub const fn into_primitive(self) -> u32 {
        self as u32
    }

    #[deprecated = "Strict enums should not use `is_unknown`"]
    #[inline]
    pub fn is_unknown(&self) -> bool {
        false
    }
}

#[derive(Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EmptyResourceStruct;

impl fidl::Standalone for EmptyResourceStruct {}

#[derive(Debug, PartialEq)]
pub struct HandlesInTypes {
    pub normal_handle: fidl::Vmo,
    pub handle_in_vec: Vec<fidl::Vmo>,
    pub handle_in_array: [fidl::Vmo; 5],
    pub handle_in_mixed_vec_array: Vec<[fidl::Vmo; 5]>,
    pub table_with_handle: TableWithHandle,
    pub union_with_handle: UnionWithHandle,
}

impl fidl::Standalone for HandlesInTypes {}

#[derive(Debug, Default, PartialEq)]
pub struct EmptyResourceTable {
    #[deprecated = "Use `..Default::default()` to construct and `..` to match."]
    #[doc(hidden)]
    pub __non_exhaustive: (),
}

impl fidl::Standalone for EmptyResourceTable {}

#[derive(Debug, Default, PartialEq)]
pub struct TableWithHandle {
    pub h: Option<fidl::Vmo>,
    #[deprecated = "Use `..Default::default()` to construct and `..` to match."]
    #[doc(hidden)]
    pub __non_exhaustive: (),
}

impl fidl::Standalone for TableWithHandle {}

#[derive(Debug)]
pub enum EmptyResourceUnion {
    #[deprecated = "Use `EmptyResourceUnion::unknown()` to construct and `EmptyResourceUnionUnknown!()` to exhaustively match."]
    #[doc(hidden)]
    #[non_exhaustive]
    __Unknown { ordinal: u64 },
}

/// Pattern that matches an unknown `EmptyResourceUnion` member.
#[macro_export]
macro_rules! EmptyResourceUnionUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for EmptyResourceUnion {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            _ => false,
        }
    }
}

impl EmptyResourceUnion {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            #[allow(deprecated)]
            Self::__Unknown { ordinal } => ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        #[allow(deprecated)]
        Self::__Unknown { ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            #[allow(deprecated)]
            Self::__Unknown { .. } => true,
        }
    }
}

impl fidl::Standalone for EmptyResourceUnion {}

#[derive(Debug)]
pub enum UnionWithHandle {
    H(fidl::Vmo),
    #[deprecated = "Use `UnionWithHandle::unknown()` to construct and `UnionWithHandleUnknown!()` to exhaustively match."]
    #[doc(hidden)]
    #[non_exhaustive]
    __Unknown {
        ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnionWithHandle` member.
#[macro_export]
macro_rules! UnionWithHandleUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnionWithHandle {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::H(x), Self::H(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnionWithHandle {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::H(_) => 1,
            #[allow(deprecated)]
            Self::__Unknown { ordinal } => ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        #[allow(deprecated)]
        Self::__Unknown { ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            #[allow(deprecated)]
            Self::__Unknown { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Standalone for UnionWithHandle {}

mod internal {
    use super::*;
    unsafe impl fidl::encoding::TypeMarker for ObjType {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            std::mem::align_of::<u32>()
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            std::mem::size_of::<u32>()
        }

        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            false
        }
    }

    impl fidl::encoding::ValueTypeMarker for ObjType {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            *value
        }
    }

    unsafe impl fidl::encoding::Encode<Self> for ObjType {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.into_primitive(), offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for ObjType {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::None
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);

            *self = Self::from_primitive(prim).ok_or(fidl::Error::InvalidEnumValue)?;
            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for EmptyResourceStruct {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 1,
                fidl::encoding::WireFormatVersion::V2 => 1,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 1,
                fidl::encoding::WireFormatVersion::V2 => 1,
            }
        }
    }
    impl fidl::encoding::ResourceTypeMarker for EmptyResourceStruct {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<EmptyResourceStruct> for &mut EmptyResourceStruct {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<EmptyResourceStruct>(offset);
            encoder.write_num(0u8, offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for EmptyResourceStruct {
        #[inline(always)]
        fn new_empty() -> Self {
            Self
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            match decoder.read_num::<u8>(offset) {
                0 => Ok(()),
                _ => Err(fidl::Error::Invalid),
            }
        }
    }

    unsafe impl fidl::encoding::TypeMarker for HandlesInTypes {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 104,
                fidl::encoding::WireFormatVersion::V2 => 96,
            }
        }
    }
    impl fidl::encoding::ResourceTypeMarker for HandlesInTypes {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<HandlesInTypes> for &mut HandlesInTypes {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<HandlesInTypes>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<HandlesInTypes>::encode(
                (
                    <fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    > as fidl::encoding::ResourceTypeMarker>::take_or_borrow(
                        &mut self.normal_handle,
                    ),
                    <fidl::encoding::UnboundedVector<
                        fidl::encoding::HandleType<
                            fidl::Vmo,
                            { fidl::ObjectType::VMO.into_raw() },
                            2147483648,
                        >,
                    > as fidl::encoding::ResourceTypeMarker>::take_or_borrow(
                        &mut self.handle_in_vec,
                    ),
                    <fidl::encoding::Array<
                        fidl::encoding::HandleType<
                            fidl::Vmo,
                            { fidl::ObjectType::VMO.into_raw() },
                            2147483648,
                        >,
                        5,
                    > as fidl::encoding::ResourceTypeMarker>::take_or_borrow(
                        &mut self.handle_in_array,
                    ),
                    <fidl::encoding::UnboundedVector<
                        fidl::encoding::Array<
                            fidl::encoding::HandleType<
                                fidl::Vmo,
                                { fidl::ObjectType::VMO.into_raw() },
                                2147483648,
                            >,
                            5,
                        >,
                    > as fidl::encoding::ResourceTypeMarker>::take_or_borrow(
                        &mut self.handle_in_mixed_vec_array,
                    ),
                    <TableWithHandle as fidl::encoding::ResourceTypeMarker>::take_or_borrow(
                        &mut self.table_with_handle,
                    ),
                    <UnionWithHandle as fidl::encoding::ResourceTypeMarker>::take_or_borrow(
                        &mut self.union_with_handle,
                    ),
                ),
                encoder,
                offset,
                _depth,
            )
        }
    }
    unsafe impl<
            T0: fidl::encoding::Encode<
                fidl::encoding::HandleType<
                    fidl::Vmo,
                    { fidl::ObjectType::VMO.into_raw() },
                    2147483648,
                >,
            >,
            T1: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                >,
            >,
            T2: fidl::encoding::Encode<
                fidl::encoding::Array<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                    5,
                >,
            >,
            T3: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Array<
                        fidl::encoding::HandleType<
                            fidl::Vmo,
                            { fidl::ObjectType::VMO.into_raw() },
                            2147483648,
                        >,
                        5,
                    >,
                >,
            >,
            T4: fidl::encoding::Encode<TableWithHandle>,
            T5: fidl::encoding::Encode<UnionWithHandle>,
        > fidl::encoding::Encode<HandlesInTypes> for (T0, T1, T2, T3, T4, T5)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<HandlesInTypes>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(40);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                }
                fidl::encoding::WireFormatVersion::V2 => {
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(40);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                }
            };
            // Write the fields.
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            self.0.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            self.1.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 24,
                fidl::encoding::WireFormatVersion::V2 => 24,
            };
            self.2.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 48,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            self.3.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 64,
                fidl::encoding::WireFormatVersion::V2 => 64,
            };
            self.4.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 80,
                fidl::encoding::WireFormatVersion::V2 => 80,
            };
            self.5.encode(encoder, offset + member_offset, depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for HandlesInTypes {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                normal_handle: fidl::new_empty!(fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>),
                handle_in_vec: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<
                        fidl::encoding::HandleType<
                            fidl::Vmo,
                            { fidl::ObjectType::VMO.into_raw() },
                            2147483648,
                        >,
                    >
                ),
                handle_in_array: fidl::new_empty!(
                    fidl::encoding::Array<
                        fidl::encoding::HandleType<
                            fidl::Vmo,
                            { fidl::ObjectType::VMO.into_raw() },
                            2147483648,
                        >,
                        5,
                    >
                ),
                handle_in_mixed_vec_array: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<
                        fidl::encoding::Array<
                            fidl::encoding::HandleType<
                                fidl::Vmo,
                                { fidl::ObjectType::VMO.into_raw() },
                                2147483648,
                            >,
                            5,
                        >,
                    >
                ),
                table_with_handle: fidl::new_empty!(TableWithHandle),
                union_with_handle: fidl::new_empty!(UnionWithHandle),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(0) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 0
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(40) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 40
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
                fidl::encoding::WireFormatVersion::V2 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(0) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 0
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(40) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 40
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
            };
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            fidl::decode!(fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>, &mut self.normal_handle, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                >,
                &mut self.handle_in_vec,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 24,
                fidl::encoding::WireFormatVersion::V2 => 24,
            };
            fidl::decode!(
                fidl::encoding::Array<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                    5,
                >,
                &mut self.handle_in_array,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 48,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Array<
                        fidl::encoding::HandleType<
                            fidl::Vmo,
                            { fidl::ObjectType::VMO.into_raw() },
                            2147483648,
                        >,
                        5,
                    >,
                >,
                &mut self.handle_in_mixed_vec_array,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 64,
                fidl::encoding::WireFormatVersion::V2 => 64,
            };
            fidl::decode!(
                TableWithHandle,
                &mut self.table_with_handle,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 80,
                fidl::encoding::WireFormatVersion::V2 => 80,
            };
            fidl::decode!(
                UnionWithHandle,
                &mut self.union_with_handle,
                decoder,
                offset + member_offset,
                _depth
            )?;
            Ok(())
        }
    }

    impl EmptyResourceTable {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            0
        }
    }

    unsafe impl fidl::encoding::TypeMarker for EmptyResourceTable {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }
    impl fidl::encoding::ResourceTypeMarker for EmptyResourceTable {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<EmptyResourceTable> for &mut EmptyResourceTable {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<EmptyResourceTable>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // write_out_of_line must not be called with a zero-sized out-of-line block.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            let bytes_len = (max_ordinal as usize) * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;

            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for EmptyResourceTable {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            depth.increment()?;
            let envelope_size = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl TableWithHandle {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.h {
                return 1;
            }
            0
        }
    }

    unsafe impl fidl::encoding::TypeMarker for TableWithHandle {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }
    impl fidl::encoding::ResourceTypeMarker for TableWithHandle {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<TableWithHandle> for &mut TableWithHandle {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<TableWithHandle>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // write_out_of_line must not be called with a zero-sized out-of-line block.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            let bytes_len = (max_ordinal as usize) * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<
                fidl::encoding::HandleType<
                    fidl::Vmo,
                    { fidl::ObjectType::VMO.into_raw() },
                    2147483648,
                >,
            >(
                self.h.as_mut().map(
                    <fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    > as fidl::encoding::ResourceTypeMarker>::take_or_borrow,
                ),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for TableWithHandle {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            depth.increment()?;
            let envelope_size = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size = <fidl::encoding::HandleType<
                    fidl::Vmo,
                    { fidl::ObjectType::VMO.into_raw() },
                    2147483648,
                > as fidl::encoding::TypeMarker>::inline_size(
                    decoder.context
                );
                if let fidl::encoding::WireFormatVersion::V2 = decoder.context.wire_format_version {
                    if inlined != (member_inline_size <= 4) {
                        return Err(fidl::Error::InvalidInlineBitInEnvelope);
                    }
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref =
                self.h.get_or_insert_with(|| fidl::new_empty!(fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>));
                fidl::decode!(fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for EmptyResourceUnion {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 24,
                fidl::encoding::WireFormatVersion::V2 => 16,
            }
        }
    }
    impl fidl::encoding::ResourceTypeMarker for EmptyResourceUnion {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<EmptyResourceUnion> for &mut EmptyResourceUnion {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<EmptyResourceUnion>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                #[allow(deprecated)]
                EmptyResourceUnion::__Unknown { .. } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl fidl::encoding::Decode<Self> for EmptyResourceUnion {
        #[inline(always)]
        fn new_empty() -> Self {
            #[allow(deprecated)]
            Self::__Unknown { ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if let fidl::encoding::WireFormatVersion::V2 = decoder.context.wire_format_version {
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = EmptyResourceUnion::__Unknown { ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnionWithHandle {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 24,
                fidl::encoding::WireFormatVersion::V2 => 16,
            }
        }
    }
    impl fidl::encoding::ResourceTypeMarker for UnionWithHandle {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<UnionWithHandle> for &mut UnionWithHandle {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnionWithHandle>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnionWithHandle::H(ref mut val) => fidl::encoding::encode_in_envelope::<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                >(
                    <fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    > as fidl::encoding::ResourceTypeMarker>::take_or_borrow(
                        val
                    ),
                    encoder,
                    offset + 8,
                    _depth,
                ),
                #[allow(deprecated)]
                UnionWithHandle::__Unknown { .. } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl fidl::encoding::Decode<Self> for UnionWithHandle {
        #[inline(always)]
        fn new_empty() -> Self {
            #[allow(deprecated)]
            Self::__Unknown { ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <fidl::encoding::HandleType<
                    fidl::Vmo,
                    { fidl::ObjectType::VMO.into_raw() },
                    2147483648,
                > as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if let fidl::encoding::WireFormatVersion::V2 = decoder.context.wire_format_version {
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnionWithHandle::H(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = UnionWithHandle::H(
                            fidl::new_empty!(fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>),
                        );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnionWithHandle::H(ref mut val) = self {
                        fidl::decode!(fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnionWithHandle::__Unknown { ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }
}
