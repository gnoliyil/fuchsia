// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use {
    bitflags::bitflags,
    fidl::{
        client::QueryResponseFut,
        endpoints::{ControlHandle as _, Responder as _},
    },
    fuchsia_zircon_status as zx_status,
    futures::future::{self, MaybeDone, TryFutureExt},
};

#[cfg(target_os = "fuchsia")]
use fuchsia_zircon as zx;

pub const BOOL: bool = true;

pub const FLOAT32: f32 = 3.14159;

pub const FLOAT64: f64 = 3.14159;

pub const INT16: i16 = 4;

pub const INT32: i32 = 4;

pub const INT64: i64 = 4;

pub const INT8: i8 = 4;

pub const STRING: &str = "string";

pub const UINT16: u16 = 4;

pub const UINT32: u32 = 4;

pub const UINT64: u64 = 4;

pub const UINT8: u8 = 4;

pub const BITS_PRIMITIVE_VAL: u32 = BitsType::VALUE.bits();

pub const BITS_VAL: BitsType = BitsType::VALUE;

pub const ENUM_PRIMITIVE_VAL: i32 = EnumType::Value.into_primitive();

pub const ENUM_VAL: EnumType = EnumType::Value;

pub const OR_RESULT: BitsType = BitsType::from_bits_truncate(7);

pub const OR_RESULT_PRIMITIVE_VAL: u32 = 5;

bitflags! {
    #[derive(Default)]
    pub struct Bits: u32 {
        const B = 8;
    }
}

impl Bits {
    #[deprecated = "Strict bits should not use `has_unknown_bits`"]
    #[inline(always)]
    pub fn has_unknown_bits(&self) -> bool {
        false
    }

    #[deprecated = "Strict bits should not use `get_unknown_bits`"]
    #[inline(always)]
    pub fn get_unknown_bits(&self) -> u32 {
        0
    }
}

bitflags! {
    #[derive(Default)]
    pub struct BitsType: u32 {
        const VALUE = 1;
        const SECOND_VALUE = UINT32;
        const THIRD_VALUE = 2;
    }
}

impl BitsType {
    #[deprecated = "Strict bits should not use `has_unknown_bits`"]
    #[inline(always)]
    pub fn has_unknown_bits(&self) -> bool {
        false
    }

    #[deprecated = "Strict bits should not use `get_unknown_bits`"]
    #[inline(always)]
    pub fn get_unknown_bits(&self) -> u32 {
        0
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[repr(u32)]
pub enum Enum {
    E = 170,
}

impl Enum {
    #[inline]
    pub fn from_primitive(prim: u32) -> Option<Self> {
        match prim {
            170 => Some(Self::E),
            _ => None,
        }
    }

    #[inline]
    pub const fn into_primitive(self) -> u32 {
        self as u32
    }

    #[deprecated = "Strict enums should not use `is_unknown`"]
    #[inline]
    pub fn is_unknown(&self) -> bool {
        false
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[repr(i32)]
pub enum EnumType {
    Value = 3,
    SecondValue = 4,
}

impl EnumType {
    #[inline]
    pub fn from_primitive(prim: i32) -> Option<Self> {
        match prim {
            3 => Some(Self::Value),
            4 => Some(Self::SecondValue),
            _ => None,
        }
    }

    #[inline]
    pub const fn into_primitive(self) -> i32 {
        self as i32
    }

    #[deprecated = "Strict enums should not use `is_unknown`"]
    #[inline]
    pub fn is_unknown(&self) -> bool {
        false
    }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Struct {
    pub int64_with_default: i64,
    pub string_with_default: String,
    pub bool_with_default: bool,
    pub enum_with_default: Enum,
    pub bits_with_default: Bits,
}

impl fidl::Persistable for Struct {}

mod internal {
    use super::*;
    unsafe impl fidl::encoding::TypeMarker for Bits {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
    }

    impl fidl::encoding::ValueTypeMarker for Bits {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            *value
        }
    }

    unsafe impl fidl::encoding::Encode<Self> for Bits {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            if self.bits & Self::all().bits != self.bits {
                return Err(fidl::Error::InvalidBitsValue);
            }
            encoder.write_num(self.bits, offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for Bits {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::empty()
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);
            *self = Self::from_bits(prim).ok_or(fidl::Error::InvalidBitsValue)?;
            Ok(())
        }
    }
    unsafe impl fidl::encoding::TypeMarker for BitsType {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
    }

    impl fidl::encoding::ValueTypeMarker for BitsType {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            *value
        }
    }

    unsafe impl fidl::encoding::Encode<Self> for BitsType {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            if self.bits & Self::all().bits != self.bits {
                return Err(fidl::Error::InvalidBitsValue);
            }
            encoder.write_num(self.bits, offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for BitsType {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::empty()
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);
            *self = Self::from_bits(prim).ok_or(fidl::Error::InvalidBitsValue)?;
            Ok(())
        }
    }
    unsafe impl fidl::encoding::TypeMarker for Enum {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            std::mem::align_of::<u32>()
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            std::mem::size_of::<u32>()
        }

        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            false
        }
    }

    impl fidl::encoding::ValueTypeMarker for Enum {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            *value
        }
    }

    unsafe impl fidl::encoding::Encode<Self> for Enum {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.into_primitive(), offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for Enum {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::E
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);

            *self = Self::from_primitive(prim).ok_or(fidl::Error::InvalidEnumValue)?;
            Ok(())
        }
    }
    unsafe impl fidl::encoding::TypeMarker for EnumType {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            std::mem::align_of::<i32>()
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            std::mem::size_of::<i32>()
        }

        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            false
        }
    }

    impl fidl::encoding::ValueTypeMarker for EnumType {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            *value
        }
    }

    unsafe impl fidl::encoding::Encode<Self> for EnumType {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.into_primitive(), offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for EnumType {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::Value
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<i32>(offset);

            *self = Self::from_primitive(prim).ok_or(fidl::Error::InvalidEnumValue)?;
            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Struct {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 40,
                fidl::encoding::WireFormatVersion::V2 => 40,
            }
        }
    }
    impl fidl::encoding::ValueTypeMarker for Struct {
        type Borrowed<'a> = &'a Self;
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<Struct> for &Struct {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Struct>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<Struct>::encode(
                (
                    <i64 as fidl::encoding::ValueTypeMarker>::borrow(&self.int64_with_default),
                    <fidl::encoding::UnboundedString as fidl::encoding::ValueTypeMarker>::borrow(
                        &self.string_with_default,
                    ),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.bool_with_default),
                    <Enum as fidl::encoding::ValueTypeMarker>::borrow(&self.enum_with_default),
                    <Bits as fidl::encoding::ValueTypeMarker>::borrow(&self.bits_with_default),
                ),
                encoder,
                offset,
                _depth,
            )
        }
    }
    unsafe impl<
            T0: fidl::encoding::Encode<i64>,
            T1: fidl::encoding::Encode<fidl::encoding::UnboundedString>,
            T2: fidl::encoding::Encode<bool>,
            T3: fidl::encoding::Encode<Enum>,
            T4: fidl::encoding::Encode<Bits>,
        > fidl::encoding::Encode<Struct> for (T0, T1, T2, T3, T4)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Struct>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(24);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(32);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                }
                fidl::encoding::WireFormatVersion::V2 => {
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(24);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(32);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                }
            };
            // Write the fields.
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            self.0.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            self.1.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 24,
                fidl::encoding::WireFormatVersion::V2 => 24,
            };
            self.2.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 28,
                fidl::encoding::WireFormatVersion::V2 => 28,
            };
            self.3.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 32,
                fidl::encoding::WireFormatVersion::V2 => 32,
            };
            self.4.encode(encoder, offset + member_offset, depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for Struct {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                int64_with_default: fidl::new_empty!(i64),
                string_with_default: fidl::new_empty!(fidl::encoding::UnboundedString),
                bool_with_default: fidl::new_empty!(bool),
                enum_with_default: fidl::new_empty!(Enum),
                bits_with_default: fidl::new_empty!(Bits),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(24) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0x00000000ffffff00u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 24
                                + ((0x00000000ffffff00u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(32) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 32
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
                fidl::encoding::WireFormatVersion::V2 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(24) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0x00000000ffffff00u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 24
                                + ((0x00000000ffffff00u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(32) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 32
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
            };
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            fidl::decode!(
                i64,
                &mut self.int64_with_default,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            fidl::decode!(
                fidl::encoding::UnboundedString,
                &mut self.string_with_default,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 24,
                fidl::encoding::WireFormatVersion::V2 => 24,
            };
            fidl::decode!(
                bool,
                &mut self.bool_with_default,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 28,
                fidl::encoding::WireFormatVersion::V2 => 28,
            };
            fidl::decode!(
                Enum,
                &mut self.enum_with_default,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 32,
                fidl::encoding::WireFormatVersion::V2 => 32,
            };
            fidl::decode!(
                Bits,
                &mut self.bits_with_default,
                decoder,
                offset + member_offset,
                _depth
            )?;
            Ok(())
        }
    }
}
