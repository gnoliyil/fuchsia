// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use {
    bitflags::bitflags,
    fidl::{
        client::QueryResponseFut,
        endpoints::{ControlHandle as _, Responder as _},
    },
    fuchsia_zircon_status as zx_status,
    futures::future::{self, MaybeDone, TryFutureExt},
};

#[cfg(target_os = "fuchsia")]
use fuchsia_zircon as zx;

bitflags! {
    #[derive(Default)]
    pub struct Bits: u32 {
        const VAL = 1;
    }
}

impl Bits {
    #[inline(always)]
    pub fn from_bits_allow_unknown(bits: u32) -> Self {
        unsafe { Self::from_bits_unchecked(bits) }
    }

    #[inline(always)]
    pub fn has_unknown_bits(&self) -> bool {
        self.get_unknown_bits() != 0
    }

    #[inline(always)]
    pub fn get_unknown_bits(&self) -> u32 {
        self.bits & !Self::all().bits
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[non_exhaustive]
pub enum Enum {
    Val,
    #[deprecated = "Use `Enum::unknown()` to construct and `EnumUnknown!()` to exhaustively match."]
    #[doc(hidden)]
    __Unknown(u32),
}

/// Pattern that matches an unknown `Enum` member.
#[macro_export]
macro_rules! EnumUnknown {
    () => {
        _
    };
}

impl Enum {
    #[inline]
    pub fn from_primitive(prim: u32) -> Option<Self> {
        match prim {
            1 => Some(Self::Val),
            _ => None,
        }
    }

    #[inline]
    pub fn from_primitive_allow_unknown(prim: u32) -> Self {
        match prim {
            1 => Self::Val,
            #[allow(deprecated)]
            x => Self::__Unknown(x),
        }
    }

    #[inline]
    pub fn unknown() -> Self {
        #[allow(deprecated)]
        Self::__Unknown(0xffffffff)
    }

    #[inline]
    pub const fn into_primitive(self) -> u32 {
        match self {
            Self::Val => 1,
            #[allow(deprecated)]
            Self::__Unknown(x) => x,
        }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            #[allow(deprecated)]
            Self::__Unknown(_) => true,
            _ => false,
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd)]
pub struct ArrayBasic {
    pub array_uint8: [u8; 5],
    pub array_uint16: [u16; 5],
    pub array_uint32: [u32; 5],
    pub array_uint64: [u64; 5],
    pub array_int8: [i8; 5],
    pub array_int16: [i16; 5],
    pub array_int32: [i32; 5],
    pub array_int64: [i64; 5],
    pub array_float32: [f32; 5],
    pub array_float64: [f64; 5],
    pub array_string: [String; 5],
    pub array_opt_string: [Option<String>; 5],
}

impl fidl::Persistable for ArrayBasic {}

#[derive(Clone, Debug, PartialEq)]
pub struct ArrayCompound {
    pub array_bits: [Bits; 5],
    pub array_enum: [Enum; 5],
    pub array_struct: [Struct; 5],
    pub array_table: [Table; 5],
    pub array_union: [Union; 5],
}

impl fidl::Persistable for ArrayCompound {}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ArrayVectorNested {
    pub vector_array_uint8: Vec<[u8; 5]>,
    pub vector_vector_uint8: Vec<Vec<u8>>,
}

impl fidl::Persistable for ArrayVectorNested {}

#[derive(Clone, Debug, PartialEq, PartialOrd)]
pub struct Basic {
    pub uint8: u8,
    pub uint16: u16,
    pub uint32: u32,
    pub uint64: u64,
    pub int8: i8,
    pub int16: i16,
    pub int32: i32,
    pub int64: i64,
    pub float32: f32,
    pub float64: f64,
    pub string: String,
    pub opt_string: Option<String>,
}

impl fidl::Persistable for Basic {}

#[derive(Clone, Debug, PartialEq)]
pub struct Compound {
    pub bits: Bits,
    pub enum_: Enum,
    pub struct_: Struct,
    pub table: Table,
    pub union: Union,
    pub opt_struct: Option<Box<Struct>>,
    pub opt_union: Option<Box<Union>>,
}

impl fidl::Persistable for Compound {}

#[derive(Debug, PartialEq)]
pub struct Resource {
    pub handle: fidl::Handle,
    pub vmo: fidl::Vmo,
    pub client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
    pub server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
    pub struct_: ResourceStruct,
    pub table: ResourceTable,
    pub union: ResourceUnion,
    pub opt_handle: Option<fidl::Handle>,
    pub opt_vmo: Option<fidl::Vmo>,
    pub opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
    pub opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
    pub opt_struct: Option<Box<ResourceStruct>>,
    pub opt_union: Option<Box<ResourceUnion>>,
    pub array_handle: [fidl::Handle; 5],
    pub array_vmo: [fidl::Vmo; 5],
    pub array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
    pub array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
    pub array_struct: [ResourceStruct; 5],
    pub array_table: [ResourceTable; 5],
    pub array_union: [ResourceUnion; 5],
    pub vector_handle: Vec<fidl::Handle>,
    pub vector_vmo: Vec<fidl::Vmo>,
    pub vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
    pub vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
    pub vector_struct: Vec<ResourceStruct>,
    pub vector_table: Vec<ResourceTable>,
    pub vector_union: Vec<ResourceUnion>,
}

impl fidl::Standalone for Resource {}

#[derive(Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ResourceStruct;

impl fidl::Standalone for ResourceStruct {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Struct;

impl fidl::Persistable for Struct {}

#[derive(Clone, Debug, PartialEq, PartialOrd)]
pub struct VectorBasic {
    pub vector_uint8: Vec<u8>,
    pub vector_uint16: Vec<u16>,
    pub vector_uint32: Vec<u32>,
    pub vector_uint64: Vec<u64>,
    pub vector_int8: Vec<i8>,
    pub vector_int16: Vec<i16>,
    pub vector_int32: Vec<i32>,
    pub vector_int64: Vec<i64>,
    pub vector_float32: Vec<f32>,
    pub vector_float64: Vec<f64>,
    pub vector_string: Vec<String>,
    pub vector_opt_string: Vec<Option<String>>,
}

impl fidl::Persistable for VectorBasic {}

#[derive(Clone, Debug, PartialEq)]
pub struct VectorCompound {
    pub vector_bits: Vec<Bits>,
    pub vector_enum: Vec<Enum>,
    pub vector_struct: Vec<Struct>,
    pub vector_table: Vec<Table>,
    pub vector_union: Vec<Union>,
    pub vector_opt_struct: Vec<Option<Box<Struct>>>,
    pub vector_opt_union: Vec<Option<Box<Union>>>,
}

impl fidl::Persistable for VectorCompound {}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct VectorOptional {
    pub opt_vector_uint8: Option<Vec<u8>>,
    pub opt_vector_string: Option<Vec<String>>,
    pub opt_vector_struct: Option<Vec<Struct>>,
    pub opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
}

impl fidl::Persistable for VectorOptional {}

#[derive(Debug, Default, PartialEq)]
pub struct ResourceTable {
    #[deprecated = "Use `..Default::default()` to construct and `..` to match."]
    #[doc(hidden)]
    pub __non_exhaustive: (),
}

impl fidl::Standalone for ResourceTable {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct Table {
    #[deprecated = "Use `..Default::default()` to construct and `..` to match."]
    #[doc(hidden)]
    pub __non_exhaustive: (),
}

impl fidl::Persistable for Table {}

#[derive(Debug)]
pub enum ResourceUnion {
    B(bool),
    #[deprecated = "Use `ResourceUnion::unknown()` to construct and `ResourceUnionUnknown!()` to exhaustively match."]
    #[doc(hidden)]
    #[non_exhaustive]
    __Unknown {
        ordinal: u64,
    },
}

/// Pattern that matches an unknown `ResourceUnion` member.
#[macro_export]
macro_rules! ResourceUnionUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for ResourceUnion {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::B(x), Self::B(y)) => *x == *y,
            _ => false,
        }
    }
}

impl ResourceUnion {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::B(_) => 1,
            #[allow(deprecated)]
            Self::__Unknown { ordinal } => ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        #[allow(deprecated)]
        Self::__Unknown { ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            #[allow(deprecated)]
            Self::__Unknown { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Standalone for ResourceUnion {}

#[derive(Clone, Debug)]
pub enum Union {
    B(bool),
    #[deprecated = "Use `Union::unknown()` to construct and `UnionUnknown!()` to exhaustively match."]
    #[doc(hidden)]
    #[non_exhaustive]
    __Unknown {
        ordinal: u64,
    },
}

/// Pattern that matches an unknown `Union` member.
#[macro_export]
macro_rules! UnionUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for Union {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::B(x), Self::B(y)) => *x == *y,
            _ => false,
        }
    }
}

impl Union {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::B(_) => 1,
            #[allow(deprecated)]
            Self::__Unknown { ordinal } => ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        #[allow(deprecated)]
        Self::__Unknown { ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            #[allow(deprecated)]
            Self::__Unknown { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for Union {}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ProtocolMarker;

impl fidl::endpoints::ProtocolMarker for ProtocolMarker {
    type Proxy = ProtocolProxy;
    type RequestStream = ProtocolRequestStream;
    const DEBUG_NAME: &'static str = "(anonymous) Protocol";
}
pub type ProtocolErrorBasicResult =
    Result<(u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>), u32>;
pub type ProtocolErrorCompoundResult =
    Result<(Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>), u32>;
pub type ProtocolErrorArrayBasicResult = Result<
    (
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
    ),
    u32,
>;
pub type ProtocolErrorArrayCompoundResult =
    Result<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]), u32>;
pub type ProtocolErrorVectorBasicResult = Result<
    (
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
    ),
    u32,
>;
pub type ProtocolErrorVectorCompoundResult = Result<
    (
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
    ),
    u32,
>;
pub type ProtocolErrorVectorOptionalResult = Result<
    (Option<Vec<u8>>, Option<Vec<String>>, Option<Vec<Struct>>, Option<Vec<Option<Box<Struct>>>>),
    u32,
>;
pub type ProtocolErrorArrayVectorNestedResult = Result<(Vec<[u8; 5]>, Vec<Vec<u8>>), u32>;
pub type ProtocolErrorResourceResult = Result<
    (
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
    ),
    u32,
>;

pub trait ProtocolProxyInterface: Send + Sync {
    fn r#one_way_basic(
        &self,
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: &str,
        opt_string: Option<&str>,
    ) -> Result<(), fidl::Error>;
    type TwoWayBasicResponseFut: std::future::Future<
            Output = Result<
                (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_basic(
        &self,
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: &str,
        opt_string: Option<&str>,
    ) -> Self::TwoWayBasicResponseFut;
    type ErrorBasicResponseFut: std::future::Future<Output = Result<ProtocolErrorBasicResult, fidl::Error>>
        + Send;
    fn r#error_basic(&self) -> Self::ErrorBasicResponseFut;
    fn r#one_way_compound(
        &self,
        bits: Bits,
        enum_: Enum,
        struct_: &Struct,
        table: &Table,
        union: &Union,
        opt_struct: Option<&Struct>,
        opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error>;
    type TwoWayCompoundResponseFut: std::future::Future<
            Output = Result<
                (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_compound(
        &self,
        bits: Bits,
        enum_: Enum,
        struct_: &Struct,
        table: &Table,
        union: &Union,
        opt_struct: Option<&Struct>,
        opt_union: Option<&Union>,
    ) -> Self::TwoWayCompoundResponseFut;
    type ErrorCompoundResponseFut: std::future::Future<Output = Result<ProtocolErrorCompoundResult, fidl::Error>>
        + Send;
    fn r#error_compound(&self) -> Self::ErrorCompoundResponseFut;
    fn r#one_way_array_basic(
        &self,
        array_uint8: &[u8; 5],
        array_uint16: &[u16; 5],
        array_uint32: &[u32; 5],
        array_uint64: &[u64; 5],
        array_int8: &[i8; 5],
        array_int16: &[i16; 5],
        array_int32: &[i32; 5],
        array_int64: &[i64; 5],
        array_float32: &[f32; 5],
        array_float64: &[f64; 5],
        array_string: &[String; 5],
        array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error>;
    type TwoWayArrayBasicResponseFut: std::future::Future<
            Output = Result<
                (
                    [u8; 5],
                    [u16; 5],
                    [u32; 5],
                    [u64; 5],
                    [i8; 5],
                    [i16; 5],
                    [i32; 5],
                    [i64; 5],
                    [f32; 5],
                    [f64; 5],
                    [String; 5],
                    [Option<String>; 5],
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_array_basic(
        &self,
        array_uint8: &[u8; 5],
        array_uint16: &[u16; 5],
        array_uint32: &[u32; 5],
        array_uint64: &[u64; 5],
        array_int8: &[i8; 5],
        array_int16: &[i16; 5],
        array_int32: &[i32; 5],
        array_int64: &[i64; 5],
        array_float32: &[f32; 5],
        array_float64: &[f64; 5],
        array_string: &[String; 5],
        array_opt_string: &[Option<String>; 5],
    ) -> Self::TwoWayArrayBasicResponseFut;
    type ErrorArrayBasicResponseFut: std::future::Future<Output = Result<ProtocolErrorArrayBasicResult, fidl::Error>>
        + Send;
    fn r#error_array_basic(&self) -> Self::ErrorArrayBasicResponseFut;
    fn r#one_way_array_compound(
        &self,
        array_bits: &[Bits; 5],
        array_enum: &[Enum; 5],
        array_struct: &[Struct; 5],
        array_table: &[Table; 5],
        array_union: &[Union; 5],
    ) -> Result<(), fidl::Error>;
    type TwoWayArrayCompoundResponseFut: std::future::Future<
            Output = Result<
                ([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_array_compound(
        &self,
        array_bits: &[Bits; 5],
        array_enum: &[Enum; 5],
        array_struct: &[Struct; 5],
        array_table: &[Table; 5],
        array_union: &[Union; 5],
    ) -> Self::TwoWayArrayCompoundResponseFut;
    type ErrorArrayCompoundResponseFut: std::future::Future<Output = Result<ProtocolErrorArrayCompoundResult, fidl::Error>>
        + Send;
    fn r#error_array_compound(&self) -> Self::ErrorArrayCompoundResponseFut;
    fn r#one_way_vector_basic(
        &self,
        vector_uint8: &[u8],
        vector_uint16: &[u16],
        vector_uint32: &[u32],
        vector_uint64: &[u64],
        vector_int8: &[i8],
        vector_int16: &[i16],
        vector_int32: &[i32],
        vector_int64: &[i64],
        vector_float32: &[f32],
        vector_float64: &[f64],
        vector_string: &[String],
        vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error>;
    type TwoWayVectorBasicResponseFut: std::future::Future<
            Output = Result<
                (
                    Vec<u8>,
                    Vec<u16>,
                    Vec<u32>,
                    Vec<u64>,
                    Vec<i8>,
                    Vec<i16>,
                    Vec<i32>,
                    Vec<i64>,
                    Vec<f32>,
                    Vec<f64>,
                    Vec<String>,
                    Vec<Option<String>>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_vector_basic(
        &self,
        vector_uint8: &[u8],
        vector_uint16: &[u16],
        vector_uint32: &[u32],
        vector_uint64: &[u64],
        vector_int8: &[i8],
        vector_int16: &[i16],
        vector_int32: &[i32],
        vector_int64: &[i64],
        vector_float32: &[f32],
        vector_float64: &[f64],
        vector_string: &[String],
        vector_opt_string: &[Option<String>],
    ) -> Self::TwoWayVectorBasicResponseFut;
    type ErrorVectorBasicResponseFut: std::future::Future<Output = Result<ProtocolErrorVectorBasicResult, fidl::Error>>
        + Send;
    fn r#error_vector_basic(&self) -> Self::ErrorVectorBasicResponseFut;
    fn r#one_way_vector_compound(
        &self,
        vector_bits: &[Bits],
        vector_enum: &[Enum],
        vector_struct: &[Struct],
        vector_table: &[Table],
        vector_union: &[Union],
        vector_opt_struct: &[Option<Box<Struct>>],
        vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error>;
    type TwoWayVectorCompoundResponseFut: std::future::Future<
            Output = Result<
                (
                    Vec<Bits>,
                    Vec<Enum>,
                    Vec<Struct>,
                    Vec<Table>,
                    Vec<Union>,
                    Vec<Option<Box<Struct>>>,
                    Vec<Option<Box<Union>>>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_vector_compound(
        &self,
        vector_bits: &[Bits],
        vector_enum: &[Enum],
        vector_struct: &[Struct],
        vector_table: &[Table],
        vector_union: &[Union],
        vector_opt_struct: &[Option<Box<Struct>>],
        vector_opt_union: &[Option<Box<Union>>],
    ) -> Self::TwoWayVectorCompoundResponseFut;
    type ErrorVectorCompoundResponseFut: std::future::Future<Output = Result<ProtocolErrorVectorCompoundResult, fidl::Error>>
        + Send;
    fn r#error_vector_compound(&self) -> Self::ErrorVectorCompoundResponseFut;
    fn r#one_way_vector_optional(
        &self,
        opt_vector_uint8: Option<&[u8]>,
        opt_vector_string: Option<&[String]>,
        opt_vector_struct: Option<&[Struct]>,
        opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error>;
    type TwoWayVectorOptionalResponseFut: std::future::Future<
            Output = Result<
                (
                    Option<Vec<u8>>,
                    Option<Vec<String>>,
                    Option<Vec<Struct>>,
                    Option<Vec<Option<Box<Struct>>>>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_vector_optional(
        &self,
        opt_vector_uint8: Option<&[u8]>,
        opt_vector_string: Option<&[String]>,
        opt_vector_struct: Option<&[Struct]>,
        opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Self::TwoWayVectorOptionalResponseFut;
    type ErrorVectorOptionalResponseFut: std::future::Future<Output = Result<ProtocolErrorVectorOptionalResult, fidl::Error>>
        + Send;
    fn r#error_vector_optional(&self) -> Self::ErrorVectorOptionalResponseFut;
    fn r#one_way_array_vector_nested(
        &self,
        vector_array_uint8: &[[u8; 5]],
        vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error>;
    type TwoWayArrayVectorNestedResponseFut: std::future::Future<Output = Result<(Vec<[u8; 5]>, Vec<Vec<u8>>), fidl::Error>>
        + Send;
    fn r#two_way_array_vector_nested(
        &self,
        vector_array_uint8: &[[u8; 5]],
        vector_vector_uint8: &[Vec<u8>],
    ) -> Self::TwoWayArrayVectorNestedResponseFut;
    type ErrorArrayVectorNestedResponseFut: std::future::Future<Output = Result<ProtocolErrorArrayVectorNestedResult, fidl::Error>>
        + Send;
    fn r#error_array_vector_nested(&self) -> Self::ErrorArrayVectorNestedResponseFut;
    fn r#one_way_resource(
        &self,
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<ResourceStruct>,
        opt_union: Option<ResourceUnion>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error>;
    type TwoWayResourceResponseFut: std::future::Future<
            Output = Result<
                (
                    fidl::Handle,
                    fidl::Vmo,
                    fidl::endpoints::ClientEnd<ProtocolMarker>,
                    fidl::endpoints::ServerEnd<ProtocolMarker>,
                    ResourceStruct,
                    ResourceTable,
                    ResourceUnion,
                    Option<fidl::Handle>,
                    Option<fidl::Vmo>,
                    Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    Option<Box<ResourceStruct>>,
                    Option<Box<ResourceUnion>>,
                    [fidl::Handle; 5],
                    [fidl::Vmo; 5],
                    [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                    [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                    [ResourceStruct; 5],
                    [ResourceTable; 5],
                    [ResourceUnion; 5],
                    Vec<fidl::Handle>,
                    Vec<fidl::Vmo>,
                    Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    Vec<ResourceStruct>,
                    Vec<ResourceTable>,
                    Vec<ResourceUnion>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_resource(
        &self,
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<ResourceStruct>,
        opt_union: Option<ResourceUnion>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
    ) -> Self::TwoWayResourceResponseFut;
    type ErrorResourceResponseFut: std::future::Future<Output = Result<ProtocolErrorResourceResult, fidl::Error>>
        + Send;
    fn r#error_resource(&self) -> Self::ErrorResourceResponseFut;
}

#[derive(Debug)]
#[cfg(target_os = "fuchsia")]
pub struct ProtocolSynchronousProxy {
    client: fidl::client::sync::Client,
}

#[cfg(target_os = "fuchsia")]
impl ProtocolSynchronousProxy {
    pub fn new(channel: fidl::Channel) -> Self {
        let protocol_name = <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME;
        Self { client: fidl::client::sync::Client::new(channel, protocol_name) }
    }

    pub fn into_channel(self) -> fidl::Channel {
        self.client.into_channel()
    }

    /// Waits until an event arrives and returns it. It is safe for other
    /// threads to make concurrent requests while waiting for an event.
    pub fn wait_for_event(&self, deadline: zx::Time) -> Result<ProtocolEvent, fidl::Error> {
        ProtocolEvent::decode(self.client.wait_for_event(deadline)?)
    }

    pub fn r#one_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Basic>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0x7c311f0d9e662df9,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
        ___deadline: zx::Time,
    ) -> Result<(u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>), fidl::Error>
    {
        let _response = self.client.send_query::<Basic, Basic>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0x205b92db5139c88f,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.uint8,
            _response.uint16,
            _response.uint32,
            _response.uint64,
            _response.int8,
            _response.int16,
            _response.int32,
            _response.int64,
            _response.float32,
            _response.float64,
            _response.string,
            _response.opt_string,
        ))
    }

    pub fn r#error_basic(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorBasicResult, fidl::Error> {
        let _response = self
            .client
            .send_query::<fidl::encoding::EmptyPayload, fidl::encoding::ResultType<Basic, u32>>(
                (),
                0x459eaa5d11b9ff93,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?;
        Ok(_response.map(|x| {
            (
                x.uint8,
                x.uint16,
                x.uint32,
                x.uint64,
                x.int8,
                x.int16,
                x.int32,
                x.int64,
                x.float32,
                x.float64,
                x.string,
                x.opt_string,
            )
        }))
    }

    pub fn r#one_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Compound>(
            (bits, enum_, struct_, table, union, opt_struct, opt_union),
            0x2bc2bc3a9237c6cc,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
        ___deadline: zx::Time,
    ) -> Result<
        (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
        fidl::Error,
    > {
        let _response = self.client.send_query::<Compound, Compound>(
            (bits, enum_, struct_, table, union, opt_struct, opt_union),
            0x79f279c7201da131,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.bits,
            _response.enum_,
            _response.struct_,
            _response.table,
            _response.union,
            _response.opt_struct,
            _response.opt_union,
        ))
    }

    pub fn r#error_compound(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorCompoundResult, fidl::Error> {
        let _response = self
            .client
            .send_query::<fidl::encoding::EmptyPayload, fidl::encoding::ResultType<Compound, u32>>(
                (),
                0x29817d89a19ec77d,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?;
        Ok(_response
            .map(|x| (x.bits, x.enum_, x.struct_, x.table, x.union, x.opt_struct, x.opt_union)))
    }

    pub fn r#one_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayBasic>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0x62e2ebcadf35ca19,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
        ___deadline: zx::Time,
    ) -> Result<
        (
            [u8; 5],
            [u16; 5],
            [u32; 5],
            [u64; 5],
            [i8; 5],
            [i16; 5],
            [i32; 5],
            [i64; 5],
            [f32; 5],
            [f64; 5],
            [String; 5],
            [Option<String>; 5],
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<ArrayBasic, ArrayBasic>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0x49ad7a74e28ba114,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.array_uint8,
            _response.array_uint16,
            _response.array_uint32,
            _response.array_uint64,
            _response.array_int8,
            _response.array_int16,
            _response.array_int32,
            _response.array_int64,
            _response.array_float32,
            _response.array_float64,
            _response.array_string,
            _response.array_opt_string,
        ))
    }

    pub fn r#error_array_basic(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorArrayBasicResult, fidl::Error> {
        let _response = self.client.send_query::<
            fidl::encoding::EmptyPayload,
            fidl::encoding::ResultType<ArrayBasic, u32>,
        >(
            (),
            0xf0dbde9626fff79,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok(_response.map(|x| {
            (
                x.array_uint8,
                x.array_uint16,
                x.array_uint32,
                x.array_uint64,
                x.array_int8,
                x.array_int16,
                x.array_int32,
                x.array_int64,
                x.array_float32,
                x.array_float64,
                x.array_string,
                x.array_opt_string,
            )
        }))
    }

    pub fn r#one_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayCompound>(
            (array_bits, array_enum, array_struct, array_table, array_union),
            0x464948bae1bda09d,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
        ___deadline: zx::Time,
    ) -> Result<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]), fidl::Error> {
        let _response = self.client.send_query::<ArrayCompound, ArrayCompound>(
            (array_bits, array_enum, array_struct, array_table, array_union),
            0xbcae616f8e1ea7b,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.array_bits,
            _response.array_enum,
            _response.array_struct,
            _response.array_table,
            _response.array_union,
        ))
    }

    pub fn r#error_array_compound(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorArrayCompoundResult, fidl::Error> {
        let _response = self.client.send_query::<
            fidl::encoding::EmptyPayload,
            fidl::encoding::ResultType<ArrayCompound, u32>,
        >(
            (),
            0x52257f80e29c1a04,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok(_response
            .map(|x| (x.array_bits, x.array_enum, x.array_struct, x.array_table, x.array_union)))
    }

    pub fn r#one_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorBasic>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0x4f907dde77464657,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
        ___deadline: zx::Time,
    ) -> Result<
        (
            Vec<u8>,
            Vec<u16>,
            Vec<u32>,
            Vec<u64>,
            Vec<i8>,
            Vec<i16>,
            Vec<i32>,
            Vec<i64>,
            Vec<f32>,
            Vec<f64>,
            Vec<String>,
            Vec<Option<String>>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<VectorBasic, VectorBasic>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0x7860cb3ed8362e74,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.vector_uint8,
            _response.vector_uint16,
            _response.vector_uint32,
            _response.vector_uint64,
            _response.vector_int8,
            _response.vector_int16,
            _response.vector_int32,
            _response.vector_int64,
            _response.vector_float32,
            _response.vector_float64,
            _response.vector_string,
            _response.vector_opt_string,
        ))
    }

    pub fn r#error_vector_basic(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorVectorBasicResult, fidl::Error> {
        let _response = self.client.send_query::<
            fidl::encoding::EmptyPayload,
            fidl::encoding::ResultType<VectorBasic, u32>,
        >(
            (),
            0xc27f841d6313f72,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok(_response.map(|x| {
            (
                x.vector_uint8,
                x.vector_uint16,
                x.vector_uint32,
                x.vector_uint64,
                x.vector_int8,
                x.vector_int16,
                x.vector_int32,
                x.vector_int64,
                x.vector_float32,
                x.vector_float64,
                x.vector_string,
                x.vector_opt_string,
            )
        }))
    }

    pub fn r#one_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorCompound>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0x19baae42829dbe90,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
        ___deadline: zx::Time,
    ) -> Result<
        (
            Vec<Bits>,
            Vec<Enum>,
            Vec<Struct>,
            Vec<Table>,
            Vec<Union>,
            Vec<Option<Box<Struct>>>,
            Vec<Option<Box<Union>>>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<VectorCompound, VectorCompound>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0x371140db701b23b4,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.vector_bits,
            _response.vector_enum,
            _response.vector_struct,
            _response.vector_table,
            _response.vector_union,
            _response.vector_opt_struct,
            _response.vector_opt_union,
        ))
    }

    pub fn r#error_vector_compound(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorVectorCompoundResult, fidl::Error> {
        let _response = self.client.send_query::<
            fidl::encoding::EmptyPayload,
            fidl::encoding::ResultType<VectorCompound, u32>,
        >(
            (),
            0x760e278628f7a985,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok(_response.map(|x| {
            (
                x.vector_bits,
                x.vector_enum,
                x.vector_struct,
                x.vector_table,
                x.vector_union,
                x.vector_opt_struct,
                x.vector_opt_union,
            )
        }))
    }

    pub fn r#one_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorOptional>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0x153c6b333c21c52f,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
        ___deadline: zx::Time,
    ) -> Result<
        (
            Option<Vec<u8>>,
            Option<Vec<String>>,
            Option<Vec<Struct>>,
            Option<Vec<Option<Box<Struct>>>>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<VectorOptional, VectorOptional>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0xe4b620aaafd73f3,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.opt_vector_uint8,
            _response.opt_vector_string,
            _response.opt_vector_struct,
            _response.opt_vector_opt_struct,
        ))
    }

    pub fn r#error_vector_optional(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorVectorOptionalResult, fidl::Error> {
        let _response = self.client.send_query::<
            fidl::encoding::EmptyPayload,
            fidl::encoding::ResultType<VectorOptional, u32>,
        >(
            (),
            0x58e75cf86e2d715e,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok(_response.map(|x| {
            (x.opt_vector_uint8, x.opt_vector_string, x.opt_vector_struct, x.opt_vector_opt_struct)
        }))
    }

    pub fn r#one_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayVectorNested>(
            (vector_array_uint8, vector_vector_uint8),
            0x520dc9cb9b9b5ed7,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
        ___deadline: zx::Time,
    ) -> Result<(Vec<[u8; 5]>, Vec<Vec<u8>>), fidl::Error> {
        let _response = self.client.send_query::<ArrayVectorNested, ArrayVectorNested>(
            (vector_array_uint8, vector_vector_uint8),
            0x4a438ce0948817dc,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((_response.vector_array_uint8, _response.vector_vector_uint8))
    }

    pub fn r#error_array_vector_nested(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorArrayVectorNestedResult, fidl::Error> {
        let _response = self.client.send_query::<
            fidl::encoding::EmptyPayload,
            fidl::encoding::ResultType<ArrayVectorNested, u32>,
        >(
            (),
            0x7e168d89e1dac8a7,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok(_response.map(|x| (x.vector_array_uint8, x.vector_vector_uint8)))
    }

    pub fn r#one_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Resource>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0x5af4795a9ed3a022,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
        ___deadline: zx::Time,
    ) -> Result<
        (
            fidl::Handle,
            fidl::Vmo,
            fidl::endpoints::ClientEnd<ProtocolMarker>,
            fidl::endpoints::ServerEnd<ProtocolMarker>,
            ResourceStruct,
            ResourceTable,
            ResourceUnion,
            Option<fidl::Handle>,
            Option<fidl::Vmo>,
            Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Option<Box<ResourceStruct>>,
            Option<Box<ResourceUnion>>,
            [fidl::Handle; 5],
            [fidl::Vmo; 5],
            [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
            [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
            [ResourceStruct; 5],
            [ResourceTable; 5],
            [ResourceUnion; 5],
            Vec<fidl::Handle>,
            Vec<fidl::Vmo>,
            Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Vec<ResourceStruct>,
            Vec<ResourceTable>,
            Vec<ResourceUnion>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<Resource, Resource>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0x1904824a11c6ad5b,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.handle,
            _response.vmo,
            _response.client_end,
            _response.server_end,
            _response.struct_,
            _response.table,
            _response.union,
            _response.opt_handle,
            _response.opt_vmo,
            _response.opt_client_end,
            _response.opt_server_end,
            _response.opt_struct,
            _response.opt_union,
            _response.array_handle,
            _response.array_vmo,
            _response.array_client_end,
            _response.array_server_end,
            _response.array_struct,
            _response.array_table,
            _response.array_union,
            _response.vector_handle,
            _response.vector_vmo,
            _response.vector_client_end,
            _response.vector_server_end,
            _response.vector_struct,
            _response.vector_table,
            _response.vector_union,
        ))
    }

    pub fn r#error_resource(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorResourceResult, fidl::Error> {
        let _response = self
            .client
            .send_query::<fidl::encoding::EmptyPayload, fidl::encoding::ResultType<Resource, u32>>(
                (),
                0x5b28634d603175b6,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?;
        Ok(_response.map(|x| {
            (
                x.handle,
                x.vmo,
                x.client_end,
                x.server_end,
                x.struct_,
                x.table,
                x.union,
                x.opt_handle,
                x.opt_vmo,
                x.opt_client_end,
                x.opt_server_end,
                x.opt_struct,
                x.opt_union,
                x.array_handle,
                x.array_vmo,
                x.array_client_end,
                x.array_server_end,
                x.array_struct,
                x.array_table,
                x.array_union,
                x.vector_handle,
                x.vector_vmo,
                x.vector_client_end,
                x.vector_server_end,
                x.vector_struct,
                x.vector_table,
                x.vector_union,
            )
        }))
    }
}

#[derive(Debug, Clone)]
pub struct ProtocolProxy {
    client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for ProtocolProxy {
    type Protocol = ProtocolMarker;

    fn from_channel(inner: fidl::AsyncChannel) -> Self {
        Self::new(inner)
    }

    fn into_channel(self) -> Result<::fidl::AsyncChannel, Self> {
        self.client.into_channel().map_err(|client| Self { client })
    }

    fn as_channel(&self) -> &::fidl::AsyncChannel {
        self.client.as_channel()
    }
}

impl ProtocolProxy {
    /// Create a new Proxy for Protocol
    pub fn new(channel: fidl::AsyncChannel) -> Self {
        let protocol_name = <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME;
        Self { client: fidl::client::Client::new(channel, protocol_name) }
    }

    /// Get a Stream of events from the remote end of the Protocol protocol
    ///
    /// # Panics
    ///
    /// Panics if the event stream was already taken.
    pub fn take_event_stream(&self) -> ProtocolEventStream {
        ProtocolEventStream { event_receiver: self.client.take_event_receiver() }
    }

    pub fn r#one_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_basic(
            self, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64,
            string, opt_string,
        )
    }

    pub fn r#two_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> fidl::client::QueryResponseFut<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
    )> {
        ProtocolProxyInterface::r#two_way_basic(
            self, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64,
            string, opt_string,
        )
    }

    pub fn r#error_basic(&self) -> fidl::client::QueryResponseFut<ProtocolErrorBasicResult> {
        ProtocolProxyInterface::r#error_basic(self)
    }

    pub fn r#one_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_compound(
            self, bits, enum_, struct_, table, union, opt_struct, opt_union,
        )
    }

    pub fn r#two_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> fidl::client::QueryResponseFut<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
    )> {
        ProtocolProxyInterface::r#two_way_compound(
            self, bits, enum_, struct_, table, union, opt_struct, opt_union,
        )
    }

    pub fn r#error_compound(&self) -> fidl::client::QueryResponseFut<ProtocolErrorCompoundResult> {
        ProtocolProxyInterface::r#error_compound(self)
    }

    pub fn r#one_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_array_basic(
            self,
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        )
    }

    pub fn r#two_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> fidl::client::QueryResponseFut<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
    )> {
        ProtocolProxyInterface::r#two_way_array_basic(
            self,
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        )
    }

    pub fn r#error_array_basic(
        &self,
    ) -> fidl::client::QueryResponseFut<ProtocolErrorArrayBasicResult> {
        ProtocolProxyInterface::r#error_array_basic(self)
    }

    pub fn r#one_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_array_compound(
            self,
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
        )
    }

    pub fn r#two_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> fidl::client::QueryResponseFut<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5])>
    {
        ProtocolProxyInterface::r#two_way_array_compound(
            self,
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
        )
    }

    pub fn r#error_array_compound(
        &self,
    ) -> fidl::client::QueryResponseFut<ProtocolErrorArrayCompoundResult> {
        ProtocolProxyInterface::r#error_array_compound(self)
    }

    pub fn r#one_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_vector_basic(
            self,
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        )
    }

    pub fn r#two_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> fidl::client::QueryResponseFut<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
    )> {
        ProtocolProxyInterface::r#two_way_vector_basic(
            self,
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        )
    }

    pub fn r#error_vector_basic(
        &self,
    ) -> fidl::client::QueryResponseFut<ProtocolErrorVectorBasicResult> {
        ProtocolProxyInterface::r#error_vector_basic(self)
    }

    pub fn r#one_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_vector_compound(
            self,
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        )
    }

    pub fn r#two_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> fidl::client::QueryResponseFut<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
    )> {
        ProtocolProxyInterface::r#two_way_vector_compound(
            self,
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        )
    }

    pub fn r#error_vector_compound(
        &self,
    ) -> fidl::client::QueryResponseFut<ProtocolErrorVectorCompoundResult> {
        ProtocolProxyInterface::r#error_vector_compound(self)
    }

    pub fn r#one_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_vector_optional(
            self,
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        )
    }

    pub fn r#two_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> fidl::client::QueryResponseFut<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
    )> {
        ProtocolProxyInterface::r#two_way_vector_optional(
            self,
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        )
    }

    pub fn r#error_vector_optional(
        &self,
    ) -> fidl::client::QueryResponseFut<ProtocolErrorVectorOptionalResult> {
        ProtocolProxyInterface::r#error_vector_optional(self)
    }

    pub fn r#one_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_array_vector_nested(
            self,
            vector_array_uint8,
            vector_vector_uint8,
        )
    }

    pub fn r#two_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> fidl::client::QueryResponseFut<(Vec<[u8; 5]>, Vec<Vec<u8>>)> {
        ProtocolProxyInterface::r#two_way_array_vector_nested(
            self,
            vector_array_uint8,
            vector_vector_uint8,
        )
    }

    pub fn r#error_array_vector_nested(
        &self,
    ) -> fidl::client::QueryResponseFut<ProtocolErrorArrayVectorNestedResult> {
        ProtocolProxyInterface::r#error_array_vector_nested(self)
    }

    pub fn r#one_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_resource(
            self,
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        )
    }

    pub fn r#two_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> fidl::client::QueryResponseFut<(
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
    )> {
        ProtocolProxyInterface::r#two_way_resource(
            self,
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        )
    }

    pub fn r#error_resource(&self) -> fidl::client::QueryResponseFut<ProtocolErrorResourceResult> {
        ProtocolProxyInterface::r#error_resource(self)
    }
}

impl ProtocolProxyInterface for ProtocolProxy {
    fn r#one_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Basic>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0x7c311f0d9e662df9,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayBasicResponseFut = fidl::client::QueryResponseFut<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
    )>;
    fn r#two_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Self::TwoWayBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<Basic>(_buf?)?;
            Ok((
                _response.uint8,
                _response.uint16,
                _response.uint32,
                _response.uint64,
                _response.int8,
                _response.int16,
                _response.int32,
                _response.int64,
                _response.float32,
                _response.float64,
                _response.string,
                _response.opt_string,
            ))
        }
        self.client.send_query_and_decode::<
            Basic,
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
        >(
            (uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string,),
            0x205b92db5139c88f,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorBasicResponseFut = fidl::client::QueryResponseFut<ProtocolErrorBasicResult>;
    fn r#error_basic(&self) -> Self::ErrorBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorBasicResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<Basic, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.uint8,
                    x.uint16,
                    x.uint32,
                    x.uint64,
                    x.int8,
                    x.int16,
                    x.int32,
                    x.int64,
                    x.float32,
                    x.float64,
                    x.string,
                    x.opt_string,
                )
            }))
        }
        self.client.send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorBasicResult>(
            (),
            0x459eaa5d11b9ff93,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    fn r#one_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Compound>(
            (bits, enum_, struct_, table, union, opt_struct, opt_union),
            0x2bc2bc3a9237c6cc,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayCompoundResponseFut = fidl::client::QueryResponseFut<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
    )>;
    fn r#two_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Self::TwoWayCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<Compound>(_buf?)?;
            Ok((
                _response.bits,
                _response.enum_,
                _response.struct_,
                _response.table,
                _response.union,
                _response.opt_struct,
                _response.opt_union,
            ))
        }
        self.client.send_query_and_decode::<
            Compound,
            (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
        >(
            (bits, enum_, struct_, table, union, opt_struct, opt_union,),
            0x79f279c7201da131,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorCompoundResponseFut = fidl::client::QueryResponseFut<ProtocolErrorCompoundResult>;
    fn r#error_compound(&self) -> Self::ErrorCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorCompoundResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<Compound, u32>,
            >(_buf?)?;
            Ok(_response
                .map(|x| (x.bits, x.enum_, x.struct_, x.table, x.union, x.opt_struct, x.opt_union)))
        }
        self.client
            .send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorCompoundResult>(
                (),
                0x29817d89a19ec77d,
                fidl::encoding::DynamicFlags::empty(),
                _decode,
            )
    }

    fn r#one_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayBasic>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0x62e2ebcadf35ca19,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayArrayBasicResponseFut = fidl::client::QueryResponseFut<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
    )>;
    fn r#two_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Self::TwoWayArrayBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                [u8; 5],
                [u16; 5],
                [u32; 5],
                [u64; 5],
                [i8; 5],
                [i16; 5],
                [i32; 5],
                [i64; 5],
                [f32; 5],
                [f64; 5],
                [String; 5],
                [Option<String>; 5],
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<ArrayBasic>(_buf?)?;
            Ok((
                _response.array_uint8,
                _response.array_uint16,
                _response.array_uint32,
                _response.array_uint64,
                _response.array_int8,
                _response.array_int16,
                _response.array_int32,
                _response.array_int64,
                _response.array_float32,
                _response.array_float64,
                _response.array_string,
                _response.array_opt_string,
            ))
        }
        self.client.send_query_and_decode::<ArrayBasic, (
            [u8; 5],
            [u16; 5],
            [u32; 5],
            [u64; 5],
            [i8; 5],
            [i16; 5],
            [i32; 5],
            [i64; 5],
            [f32; 5],
            [f64; 5],
            [String; 5],
            [Option<String>; 5],
        )>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0x49ad7a74e28ba114,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorArrayBasicResponseFut = fidl::client::QueryResponseFut<ProtocolErrorArrayBasicResult>;
    fn r#error_array_basic(&self) -> Self::ErrorArrayBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorArrayBasicResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<ArrayBasic, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.array_uint8,
                    x.array_uint16,
                    x.array_uint32,
                    x.array_uint64,
                    x.array_int8,
                    x.array_int16,
                    x.array_int32,
                    x.array_int64,
                    x.array_float32,
                    x.array_float64,
                    x.array_string,
                    x.array_opt_string,
                )
            }))
        }
        self.client
            .send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorArrayBasicResult>(
                (),
                0xf0dbde9626fff79,
                fidl::encoding::DynamicFlags::empty(),
                _decode,
            )
    }

    fn r#one_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayCompound>(
            (array_bits, array_enum, array_struct, array_table, array_union),
            0x464948bae1bda09d,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayArrayCompoundResponseFut =
        fidl::client::QueryResponseFut<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5])>;
    fn r#two_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Self::TwoWayArrayCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]), fidl::Error>
        {
            let _response = fidl::client::decode_transaction_body::<ArrayCompound>(_buf?)?;
            Ok((
                _response.array_bits,
                _response.array_enum,
                _response.array_struct,
                _response.array_table,
                _response.array_union,
            ))
        }
        self.client.send_query_and_decode::<
            ArrayCompound,
            ([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]),
        >(
            (array_bits, array_enum, array_struct, array_table, array_union,),
            0xbcae616f8e1ea7b,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorArrayCompoundResponseFut =
        fidl::client::QueryResponseFut<ProtocolErrorArrayCompoundResult>;
    fn r#error_array_compound(&self) -> Self::ErrorArrayCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorArrayCompoundResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<ArrayCompound, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (x.array_bits, x.array_enum, x.array_struct, x.array_table, x.array_union)
            }))
        }
        self.client.send_query_and_decode::<
            fidl::encoding::EmptyPayload,
            ProtocolErrorArrayCompoundResult,
        >(
            (),
            0x52257f80e29c1a04,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    fn r#one_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorBasic>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0x4f907dde77464657,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayVectorBasicResponseFut = fidl::client::QueryResponseFut<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
    )>;
    fn r#two_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Self::TwoWayVectorBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                Vec<u8>,
                Vec<u16>,
                Vec<u32>,
                Vec<u64>,
                Vec<i8>,
                Vec<i16>,
                Vec<i32>,
                Vec<i64>,
                Vec<f32>,
                Vec<f64>,
                Vec<String>,
                Vec<Option<String>>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<VectorBasic>(_buf?)?;
            Ok((
                _response.vector_uint8,
                _response.vector_uint16,
                _response.vector_uint32,
                _response.vector_uint64,
                _response.vector_int8,
                _response.vector_int16,
                _response.vector_int32,
                _response.vector_int64,
                _response.vector_float32,
                _response.vector_float64,
                _response.vector_string,
                _response.vector_opt_string,
            ))
        }
        self.client.send_query_and_decode::<VectorBasic, (
            Vec<u8>,
            Vec<u16>,
            Vec<u32>,
            Vec<u64>,
            Vec<i8>,
            Vec<i16>,
            Vec<i32>,
            Vec<i64>,
            Vec<f32>,
            Vec<f64>,
            Vec<String>,
            Vec<Option<String>>,
        )>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0x7860cb3ed8362e74,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorVectorBasicResponseFut =
        fidl::client::QueryResponseFut<ProtocolErrorVectorBasicResult>;
    fn r#error_vector_basic(&self) -> Self::ErrorVectorBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorVectorBasicResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<VectorBasic, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.vector_uint8,
                    x.vector_uint16,
                    x.vector_uint32,
                    x.vector_uint64,
                    x.vector_int8,
                    x.vector_int16,
                    x.vector_int32,
                    x.vector_int64,
                    x.vector_float32,
                    x.vector_float64,
                    x.vector_string,
                    x.vector_opt_string,
                )
            }))
        }
        self.client
            .send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorVectorBasicResult>(
                (),
                0xc27f841d6313f72,
                fidl::encoding::DynamicFlags::empty(),
                _decode,
            )
    }

    fn r#one_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorCompound>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0x19baae42829dbe90,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayVectorCompoundResponseFut = fidl::client::QueryResponseFut<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
    )>;
    fn r#two_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Self::TwoWayVectorCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                Vec<Bits>,
                Vec<Enum>,
                Vec<Struct>,
                Vec<Table>,
                Vec<Union>,
                Vec<Option<Box<Struct>>>,
                Vec<Option<Box<Union>>>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<VectorCompound>(_buf?)?;
            Ok((
                _response.vector_bits,
                _response.vector_enum,
                _response.vector_struct,
                _response.vector_table,
                _response.vector_union,
                _response.vector_opt_struct,
                _response.vector_opt_union,
            ))
        }
        self.client.send_query_and_decode::<VectorCompound, (
            Vec<Bits>,
            Vec<Enum>,
            Vec<Struct>,
            Vec<Table>,
            Vec<Union>,
            Vec<Option<Box<Struct>>>,
            Vec<Option<Box<Union>>>,
        )>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0x371140db701b23b4,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorVectorCompoundResponseFut =
        fidl::client::QueryResponseFut<ProtocolErrorVectorCompoundResult>;
    fn r#error_vector_compound(&self) -> Self::ErrorVectorCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorVectorCompoundResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<VectorCompound, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.vector_bits,
                    x.vector_enum,
                    x.vector_struct,
                    x.vector_table,
                    x.vector_union,
                    x.vector_opt_struct,
                    x.vector_opt_union,
                )
            }))
        }
        self.client.send_query_and_decode::<
            fidl::encoding::EmptyPayload,
            ProtocolErrorVectorCompoundResult,
        >(
            (),
            0x760e278628f7a985,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    fn r#one_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorOptional>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0x153c6b333c21c52f,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayVectorOptionalResponseFut = fidl::client::QueryResponseFut<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
    )>;
    fn r#two_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Self::TwoWayVectorOptionalResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                Option<Vec<u8>>,
                Option<Vec<String>>,
                Option<Vec<Struct>>,
                Option<Vec<Option<Box<Struct>>>>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<VectorOptional>(_buf?)?;
            Ok((
                _response.opt_vector_uint8,
                _response.opt_vector_string,
                _response.opt_vector_struct,
                _response.opt_vector_opt_struct,
            ))
        }
        self.client.send_query_and_decode::<VectorOptional, (
            Option<Vec<u8>>,
            Option<Vec<String>>,
            Option<Vec<Struct>>,
            Option<Vec<Option<Box<Struct>>>>,
        )>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0xe4b620aaafd73f3,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorVectorOptionalResponseFut =
        fidl::client::QueryResponseFut<ProtocolErrorVectorOptionalResult>;
    fn r#error_vector_optional(&self) -> Self::ErrorVectorOptionalResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorVectorOptionalResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<VectorOptional, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.opt_vector_uint8,
                    x.opt_vector_string,
                    x.opt_vector_struct,
                    x.opt_vector_opt_struct,
                )
            }))
        }
        self.client.send_query_and_decode::<
            fidl::encoding::EmptyPayload,
            ProtocolErrorVectorOptionalResult,
        >(
            (),
            0x58e75cf86e2d715e,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    fn r#one_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayVectorNested>(
            (vector_array_uint8, vector_vector_uint8),
            0x520dc9cb9b9b5ed7,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayArrayVectorNestedResponseFut =
        fidl::client::QueryResponseFut<(Vec<[u8; 5]>, Vec<Vec<u8>>)>;
    fn r#two_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Self::TwoWayArrayVectorNestedResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<(Vec<[u8; 5]>, Vec<Vec<u8>>), fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<ArrayVectorNested>(_buf?)?;
            Ok((_response.vector_array_uint8, _response.vector_vector_uint8))
        }
        self.client.send_query_and_decode::<ArrayVectorNested, (Vec<[u8; 5]>, Vec<Vec<u8>>)>(
            (vector_array_uint8, vector_vector_uint8),
            0x4a438ce0948817dc,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorArrayVectorNestedResponseFut =
        fidl::client::QueryResponseFut<ProtocolErrorArrayVectorNestedResult>;
    fn r#error_array_vector_nested(&self) -> Self::ErrorArrayVectorNestedResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorArrayVectorNestedResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<ArrayVectorNested, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| (x.vector_array_uint8, x.vector_vector_uint8)))
        }
        self.client.send_query_and_decode::<
            fidl::encoding::EmptyPayload,
            ProtocolErrorArrayVectorNestedResult,
        >(
            (),
            0x7e168d89e1dac8a7,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    fn r#one_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Resource>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0x5af4795a9ed3a022,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayResourceResponseFut = fidl::client::QueryResponseFut<(
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
    )>;
    fn r#two_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Self::TwoWayResourceResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                fidl::Handle,
                fidl::Vmo,
                fidl::endpoints::ClientEnd<ProtocolMarker>,
                fidl::endpoints::ServerEnd<ProtocolMarker>,
                ResourceStruct,
                ResourceTable,
                ResourceUnion,
                Option<fidl::Handle>,
                Option<fidl::Vmo>,
                Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Option<Box<ResourceStruct>>,
                Option<Box<ResourceUnion>>,
                [fidl::Handle; 5],
                [fidl::Vmo; 5],
                [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                [ResourceStruct; 5],
                [ResourceTable; 5],
                [ResourceUnion; 5],
                Vec<fidl::Handle>,
                Vec<fidl::Vmo>,
                Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Vec<ResourceStruct>,
                Vec<ResourceTable>,
                Vec<ResourceUnion>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<Resource>(_buf?)?;
            Ok((
                _response.handle,
                _response.vmo,
                _response.client_end,
                _response.server_end,
                _response.struct_,
                _response.table,
                _response.union,
                _response.opt_handle,
                _response.opt_vmo,
                _response.opt_client_end,
                _response.opt_server_end,
                _response.opt_struct,
                _response.opt_union,
                _response.array_handle,
                _response.array_vmo,
                _response.array_client_end,
                _response.array_server_end,
                _response.array_struct,
                _response.array_table,
                _response.array_union,
                _response.vector_handle,
                _response.vector_vmo,
                _response.vector_client_end,
                _response.vector_server_end,
                _response.vector_struct,
                _response.vector_table,
                _response.vector_union,
            ))
        }
        self.client.send_query_and_decode::<Resource, (
            fidl::Handle,
            fidl::Vmo,
            fidl::endpoints::ClientEnd<ProtocolMarker>,
            fidl::endpoints::ServerEnd<ProtocolMarker>,
            ResourceStruct,
            ResourceTable,
            ResourceUnion,
            Option<fidl::Handle>,
            Option<fidl::Vmo>,
            Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Option<Box<ResourceStruct>>,
            Option<Box<ResourceUnion>>,
            [fidl::Handle; 5],
            [fidl::Vmo; 5],
            [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
            [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
            [ResourceStruct; 5],
            [ResourceTable; 5],
            [ResourceUnion; 5],
            Vec<fidl::Handle>,
            Vec<fidl::Vmo>,
            Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Vec<ResourceStruct>,
            Vec<ResourceTable>,
            Vec<ResourceUnion>,
        )>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0x1904824a11c6ad5b,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorResourceResponseFut = fidl::client::QueryResponseFut<ProtocolErrorResourceResult>;
    fn r#error_resource(&self) -> Self::ErrorResourceResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorResourceResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<Resource, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.handle,
                    x.vmo,
                    x.client_end,
                    x.server_end,
                    x.struct_,
                    x.table,
                    x.union,
                    x.opt_handle,
                    x.opt_vmo,
                    x.opt_client_end,
                    x.opt_server_end,
                    x.opt_struct,
                    x.opt_union,
                    x.array_handle,
                    x.array_vmo,
                    x.array_client_end,
                    x.array_server_end,
                    x.array_struct,
                    x.array_table,
                    x.array_union,
                    x.vector_handle,
                    x.vector_vmo,
                    x.vector_client_end,
                    x.vector_server_end,
                    x.vector_struct,
                    x.vector_table,
                    x.vector_union,
                )
            }))
        }
        self.client
            .send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorResourceResult>(
                (),
                0x5b28634d603175b6,
                fidl::encoding::DynamicFlags::empty(),
                _decode,
            )
    }
}

pub struct ProtocolEventStream {
    event_receiver: fidl::client::EventReceiver,
}

impl std::marker::Unpin for ProtocolEventStream {}

impl futures::stream::FusedStream for ProtocolEventStream {
    fn is_terminated(&self) -> bool {
        self.event_receiver.is_terminated()
    }
}

impl futures::Stream for ProtocolEventStream {
    type Item = Result<ProtocolEvent, fidl::Error>;

    fn poll_next(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Option<Self::Item>> {
        let buf = match futures::ready!(futures::stream::StreamExt::poll_next_unpin(
            &mut self.event_receiver,
            cx
        )?) {
            Some(buf) => buf,
            None => return std::task::Poll::Ready(None),
        };

        std::task::Poll::Ready(Some(ProtocolEvent::decode(buf)))
    }
}

#[derive(Debug)]
pub enum ProtocolEvent {
    EventBasic {
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: String,
        opt_string: Option<String>,
    },
    EventCompound {
        bits: Bits,
        enum_: Enum,
        struct_: Struct,
        table: Table,
        union: Union,
        opt_struct: Option<Box<Struct>>,
        opt_union: Option<Box<Union>>,
    },
    EventArrayBasic {
        array_uint8: [u8; 5],
        array_uint16: [u16; 5],
        array_uint32: [u32; 5],
        array_uint64: [u64; 5],
        array_int8: [i8; 5],
        array_int16: [i16; 5],
        array_int32: [i32; 5],
        array_int64: [i64; 5],
        array_float32: [f32; 5],
        array_float64: [f64; 5],
        array_string: [String; 5],
        array_opt_string: [Option<String>; 5],
    },
    EventArrayCompound {
        array_bits: [Bits; 5],
        array_enum: [Enum; 5],
        array_struct: [Struct; 5],
        array_table: [Table; 5],
        array_union: [Union; 5],
    },
    EventVectorBasic {
        vector_uint8: Vec<u8>,
        vector_uint16: Vec<u16>,
        vector_uint32: Vec<u32>,
        vector_uint64: Vec<u64>,
        vector_int8: Vec<i8>,
        vector_int16: Vec<i16>,
        vector_int32: Vec<i32>,
        vector_int64: Vec<i64>,
        vector_float32: Vec<f32>,
        vector_float64: Vec<f64>,
        vector_string: Vec<String>,
        vector_opt_string: Vec<Option<String>>,
    },
    EventVectorCompound {
        vector_bits: Vec<Bits>,
        vector_enum: Vec<Enum>,
        vector_struct: Vec<Struct>,
        vector_table: Vec<Table>,
        vector_union: Vec<Union>,
        vector_opt_struct: Vec<Option<Box<Struct>>>,
        vector_opt_union: Vec<Option<Box<Union>>>,
    },
    EventVectorOptional {
        opt_vector_uint8: Option<Vec<u8>>,
        opt_vector_string: Option<Vec<String>>,
        opt_vector_struct: Option<Vec<Struct>>,
        opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
    },
    EventArrayVectorNested {
        vector_array_uint8: Vec<[u8; 5]>,
        vector_vector_uint8: Vec<Vec<u8>>,
    },
    EventResource {
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<Box<ResourceStruct>>,
        opt_union: Option<Box<ResourceUnion>>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
    },
}

impl ProtocolEvent {
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_basic(
        self,
    ) -> Option<(u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>)> {
        if let ProtocolEvent::EventBasic {
            uint8,
            uint16,
            uint32,
            uint64,
            int8,
            int16,
            int32,
            int64,
            float32,
            float64,
            string,
            opt_string,
        } = self
        {
            Some((
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_compound(
        self,
    ) -> Option<(Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>)> {
        if let ProtocolEvent::EventCompound {
            bits,
            enum_,
            struct_,
            table,
            union,
            opt_struct,
            opt_union,
        } = self
        {
            Some((bits, enum_, struct_, table, union, opt_struct, opt_union))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_array_basic(
        self,
    ) -> Option<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
    )> {
        if let ProtocolEvent::EventArrayBasic {
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        } = self
        {
            Some((
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_array_compound(
        self,
    ) -> Option<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5])> {
        if let ProtocolEvent::EventArrayCompound {
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
        } = self
        {
            Some((array_bits, array_enum, array_struct, array_table, array_union))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_vector_basic(
        self,
    ) -> Option<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
    )> {
        if let ProtocolEvent::EventVectorBasic {
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        } = self
        {
            Some((
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_vector_compound(
        self,
    ) -> Option<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
    )> {
        if let ProtocolEvent::EventVectorCompound {
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        } = self
        {
            Some((
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_vector_optional(
        self,
    ) -> Option<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
    )> {
        if let ProtocolEvent::EventVectorOptional {
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        } = self
        {
            Some((opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_array_vector_nested(self) -> Option<(Vec<[u8; 5]>, Vec<Vec<u8>>)> {
        if let ProtocolEvent::EventArrayVectorNested { vector_array_uint8, vector_vector_uint8 } =
            self
        {
            Some((vector_array_uint8, vector_vector_uint8))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_resource(
        self,
    ) -> Option<(
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
    )> {
        if let ProtocolEvent::EventResource {
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        } = self
        {
            Some((
                handle,
                vmo,
                client_end,
                server_end,
                struct_,
                table,
                union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,
            ))
        } else {
            None
        }
    }

    /// Decodes a message buffer as a [`ProtocolEvent`]. Transaction
    /// ID in the message must be zero; this method does not check TXID.
    fn decode(mut buf: fidl::MessageBufEtc) -> Result<ProtocolEvent, fidl::Error> {
        let (bytes, _handles) = buf.split_mut();
        let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

        match tx_header.ordinal() {
            0x51c5b06295c10c40 => {
                let mut out = fidl::new_empty!(Basic);
                fidl::encoding::Decoder::decode_into::<Basic>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventBasic {
                    uint8: out.uint8,
                    uint16: out.uint16,
                    uint32: out.uint32,
                    uint64: out.uint64,
                    int8: out.int8,
                    int16: out.int16,
                    int32: out.int32,
                    int64: out.int64,
                    float32: out.float32,
                    float64: out.float64,
                    string: out.string,
                    opt_string: out.opt_string,
                }))
            }
            0x617c5410858734d5 => {
                let mut out = fidl::new_empty!(Compound);
                fidl::encoding::Decoder::decode_into::<Compound>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventCompound {
                    bits: out.bits,
                    enum_: out.enum_,
                    struct_: out.struct_,
                    table: out.table,
                    union: out.union,
                    opt_struct: out.opt_struct,
                    opt_union: out.opt_union,
                }))
            }
            0x51b76208b148f02e => {
                let mut out = fidl::new_empty!(ArrayBasic);
                fidl::encoding::Decoder::decode_into::<ArrayBasic>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventArrayBasic {
                    array_uint8: out.array_uint8,
                    array_uint16: out.array_uint16,
                    array_uint32: out.array_uint32,
                    array_uint64: out.array_uint64,
                    array_int8: out.array_int8,
                    array_int16: out.array_int16,
                    array_int32: out.array_int32,
                    array_int64: out.array_int64,
                    array_float32: out.array_float32,
                    array_float64: out.array_float64,
                    array_string: out.array_string,
                    array_opt_string: out.array_opt_string,
                }))
            }
            0x1e63a00079aa7415 => {
                let mut out = fidl::new_empty!(ArrayCompound);
                fidl::encoding::Decoder::decode_into::<ArrayCompound>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventArrayCompound {
                    array_bits: out.array_bits,
                    array_enum: out.array_enum,
                    array_struct: out.array_struct,
                    array_table: out.array_table,
                    array_union: out.array_union,
                }))
            }
            0x3f9d405e7191eff6 => {
                let mut out = fidl::new_empty!(VectorBasic);
                fidl::encoding::Decoder::decode_into::<VectorBasic>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventVectorBasic {
                    vector_uint8: out.vector_uint8,
                    vector_uint16: out.vector_uint16,
                    vector_uint32: out.vector_uint32,
                    vector_uint64: out.vector_uint64,
                    vector_int8: out.vector_int8,
                    vector_int16: out.vector_int16,
                    vector_int32: out.vector_int32,
                    vector_int64: out.vector_int64,
                    vector_float32: out.vector_float32,
                    vector_float64: out.vector_float64,
                    vector_string: out.vector_string,
                    vector_opt_string: out.vector_opt_string,
                }))
            }
            0x53a1fc56e8b3cff3 => {
                let mut out = fidl::new_empty!(VectorCompound);
                fidl::encoding::Decoder::decode_into::<VectorCompound>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventVectorCompound {
                    vector_bits: out.vector_bits,
                    vector_enum: out.vector_enum,
                    vector_struct: out.vector_struct,
                    vector_table: out.vector_table,
                    vector_union: out.vector_union,
                    vector_opt_struct: out.vector_opt_struct,
                    vector_opt_union: out.vector_opt_union,
                }))
            }
            0x17617b54dfa8d85d => {
                let mut out = fidl::new_empty!(VectorOptional);
                fidl::encoding::Decoder::decode_into::<VectorOptional>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventVectorOptional {
                    opt_vector_uint8: out.opt_vector_uint8,
                    opt_vector_string: out.opt_vector_string,
                    opt_vector_struct: out.opt_vector_struct,
                    opt_vector_opt_struct: out.opt_vector_opt_struct,
                }))
            }
            0x110b72cfebc4037e => {
                let mut out = fidl::new_empty!(ArrayVectorNested);
                fidl::encoding::Decoder::decode_into::<ArrayVectorNested>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventArrayVectorNested {
                    vector_array_uint8: out.vector_array_uint8,
                    vector_vector_uint8: out.vector_vector_uint8,
                }))
            }
            0x4fbde2864601698b => {
                let mut out = fidl::new_empty!(Resource);
                fidl::encoding::Decoder::decode_into::<Resource>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventResource {
                    handle: out.handle,
                    vmo: out.vmo,
                    client_end: out.client_end,
                    server_end: out.server_end,
                    struct_: out.struct_,
                    table: out.table,
                    union: out.union,
                    opt_handle: out.opt_handle,
                    opt_vmo: out.opt_vmo,
                    opt_client_end: out.opt_client_end,
                    opt_server_end: out.opt_server_end,
                    opt_struct: out.opt_struct,
                    opt_union: out.opt_union,
                    array_handle: out.array_handle,
                    array_vmo: out.array_vmo,
                    array_client_end: out.array_client_end,
                    array_server_end: out.array_server_end,
                    array_struct: out.array_struct,
                    array_table: out.array_table,
                    array_union: out.array_union,
                    vector_handle: out.vector_handle,
                    vector_vmo: out.vector_vmo,
                    vector_client_end: out.vector_client_end,
                    vector_server_end: out.vector_server_end,
                    vector_struct: out.vector_struct,
                    vector_table: out.vector_table,
                    vector_union: out.vector_union,
                }))
            }
            _ => Err(fidl::Error::UnknownOrdinal {
                ordinal: tx_header.ordinal(),
                protocol_name: <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME,
            }),
        }
    }
}

/// A Stream of incoming requests for Protocol
pub struct ProtocolRequestStream {
    inner: std::sync::Arc<fidl::ServeInner>,
    is_terminated: bool,
}

impl std::marker::Unpin for ProtocolRequestStream {}

impl futures::stream::FusedStream for ProtocolRequestStream {
    fn is_terminated(&self) -> bool {
        self.is_terminated
    }
}

impl fidl::endpoints::RequestStream for ProtocolRequestStream {
    type Protocol = ProtocolMarker;
    type ControlHandle = ProtocolControlHandle;

    fn from_channel(channel: fidl::AsyncChannel) -> Self {
        Self { inner: std::sync::Arc::new(fidl::ServeInner::new(channel)), is_terminated: false }
    }

    fn control_handle(&self) -> Self::ControlHandle {
        ProtocolControlHandle { inner: self.inner.clone() }
    }

    fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, bool) {
        (self.inner, self.is_terminated)
    }

    fn from_inner(inner: std::sync::Arc<fidl::ServeInner>, is_terminated: bool) -> Self {
        Self { inner, is_terminated }
    }
}

impl futures::Stream for ProtocolRequestStream {
    type Item = Result<ProtocolRequest, fidl::Error>;

    fn poll_next(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Option<Self::Item>> {
        let this = &mut *self;
        if this.inner.poll_shutdown(cx) {
            this.is_terminated = true;
            return std::task::Poll::Ready(None);
        }
        if this.is_terminated {
            panic!("polled ProtocolRequestStream after completion");
        }
        fidl::encoding::with_tls_decode_buf(|bytes, handles| {
            match this.inner.channel().read_etc(cx, bytes, handles) {
                std::task::Poll::Ready(Ok(())) => {}
                std::task::Poll::Pending => return std::task::Poll::Pending,
                std::task::Poll::Ready(Err(zx_status::Status::PEER_CLOSED)) => {
                    this.is_terminated = true;
                    return std::task::Poll::Ready(None);
                }
                std::task::Poll::Ready(Err(e)) => {
                    return std::task::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e))))
                }
            }

            // A message has been received from the channel
            let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;
            if !header.is_compatible() {
                return std::task::Poll::Ready(Some(Err(fidl::Error::IncompatibleMagicNumber(
                    header.magic_number(),
                ))));
            }

            std::task::Poll::Ready(Some(match header.ordinal() {
                0x7c311f0d9e662df9 => {
                    let mut req = fidl::new_empty!(Basic);
                    fidl::encoding::Decoder::decode_into::<Basic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayBasic {
                        uint8: req.uint8,
                        uint16: req.uint16,
                        uint32: req.uint32,
                        uint64: req.uint64,
                        int8: req.int8,
                        int16: req.int16,
                        int32: req.int32,
                        int64: req.int64,
                        float32: req.float32,
                        float64: req.float64,
                        string: req.string,
                        opt_string: req.opt_string,

                        control_handle,
                    })
                }
                0x205b92db5139c88f => {
                    let mut req = fidl::new_empty!(Basic);
                    fidl::encoding::Decoder::decode_into::<Basic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayBasic {
                        uint8: req.uint8,
                        uint16: req.uint16,
                        uint32: req.uint32,
                        uint64: req.uint64,
                        int8: req.int8,
                        int16: req.int16,
                        int32: req.int32,
                        int64: req.int64,
                        float32: req.float32,
                        float64: req.float64,
                        string: req.string,
                        opt_string: req.opt_string,

                        responder: ProtocolTwoWayBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x459eaa5d11b9ff93 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorBasic {
                        responder: ProtocolErrorBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x2bc2bc3a9237c6cc => {
                    let mut req = fidl::new_empty!(Compound);
                    fidl::encoding::Decoder::decode_into::<Compound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayCompound {
                        bits: req.bits,
                        enum_: req.enum_,
                        struct_: req.struct_,
                        table: req.table,
                        union: req.union,
                        opt_struct: req.opt_struct,
                        opt_union: req.opt_union,

                        control_handle,
                    })
                }
                0x79f279c7201da131 => {
                    let mut req = fidl::new_empty!(Compound);
                    fidl::encoding::Decoder::decode_into::<Compound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayCompound {
                        bits: req.bits,
                        enum_: req.enum_,
                        struct_: req.struct_,
                        table: req.table,
                        union: req.union,
                        opt_struct: req.opt_struct,
                        opt_union: req.opt_union,

                        responder: ProtocolTwoWayCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x29817d89a19ec77d => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorCompound {
                        responder: ProtocolErrorCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x62e2ebcadf35ca19 => {
                    let mut req = fidl::new_empty!(ArrayBasic);
                    fidl::encoding::Decoder::decode_into::<ArrayBasic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayArrayBasic {
                        array_uint8: req.array_uint8,
                        array_uint16: req.array_uint16,
                        array_uint32: req.array_uint32,
                        array_uint64: req.array_uint64,
                        array_int8: req.array_int8,
                        array_int16: req.array_int16,
                        array_int32: req.array_int32,
                        array_int64: req.array_int64,
                        array_float32: req.array_float32,
                        array_float64: req.array_float64,
                        array_string: req.array_string,
                        array_opt_string: req.array_opt_string,

                        control_handle,
                    })
                }
                0x49ad7a74e28ba114 => {
                    let mut req = fidl::new_empty!(ArrayBasic);
                    fidl::encoding::Decoder::decode_into::<ArrayBasic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayArrayBasic {
                        array_uint8: req.array_uint8,
                        array_uint16: req.array_uint16,
                        array_uint32: req.array_uint32,
                        array_uint64: req.array_uint64,
                        array_int8: req.array_int8,
                        array_int16: req.array_int16,
                        array_int32: req.array_int32,
                        array_int64: req.array_int64,
                        array_float32: req.array_float32,
                        array_float64: req.array_float64,
                        array_string: req.array_string,
                        array_opt_string: req.array_opt_string,

                        responder: ProtocolTwoWayArrayBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0xf0dbde9626fff79 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorArrayBasic {
                        responder: ProtocolErrorArrayBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x464948bae1bda09d => {
                    let mut req = fidl::new_empty!(ArrayCompound);
                    fidl::encoding::Decoder::decode_into::<ArrayCompound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayArrayCompound {
                        array_bits: req.array_bits,
                        array_enum: req.array_enum,
                        array_struct: req.array_struct,
                        array_table: req.array_table,
                        array_union: req.array_union,

                        control_handle,
                    })
                }
                0xbcae616f8e1ea7b => {
                    let mut req = fidl::new_empty!(ArrayCompound);
                    fidl::encoding::Decoder::decode_into::<ArrayCompound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayArrayCompound {
                        array_bits: req.array_bits,
                        array_enum: req.array_enum,
                        array_struct: req.array_struct,
                        array_table: req.array_table,
                        array_union: req.array_union,

                        responder: ProtocolTwoWayArrayCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x52257f80e29c1a04 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorArrayCompound {
                        responder: ProtocolErrorArrayCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x4f907dde77464657 => {
                    let mut req = fidl::new_empty!(VectorBasic);
                    fidl::encoding::Decoder::decode_into::<VectorBasic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayVectorBasic {
                        vector_uint8: req.vector_uint8,
                        vector_uint16: req.vector_uint16,
                        vector_uint32: req.vector_uint32,
                        vector_uint64: req.vector_uint64,
                        vector_int8: req.vector_int8,
                        vector_int16: req.vector_int16,
                        vector_int32: req.vector_int32,
                        vector_int64: req.vector_int64,
                        vector_float32: req.vector_float32,
                        vector_float64: req.vector_float64,
                        vector_string: req.vector_string,
                        vector_opt_string: req.vector_opt_string,

                        control_handle,
                    })
                }
                0x7860cb3ed8362e74 => {
                    let mut req = fidl::new_empty!(VectorBasic);
                    fidl::encoding::Decoder::decode_into::<VectorBasic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayVectorBasic {
                        vector_uint8: req.vector_uint8,
                        vector_uint16: req.vector_uint16,
                        vector_uint32: req.vector_uint32,
                        vector_uint64: req.vector_uint64,
                        vector_int8: req.vector_int8,
                        vector_int16: req.vector_int16,
                        vector_int32: req.vector_int32,
                        vector_int64: req.vector_int64,
                        vector_float32: req.vector_float32,
                        vector_float64: req.vector_float64,
                        vector_string: req.vector_string,
                        vector_opt_string: req.vector_opt_string,

                        responder: ProtocolTwoWayVectorBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0xc27f841d6313f72 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorVectorBasic {
                        responder: ProtocolErrorVectorBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x19baae42829dbe90 => {
                    let mut req = fidl::new_empty!(VectorCompound);
                    fidl::encoding::Decoder::decode_into::<VectorCompound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayVectorCompound {
                        vector_bits: req.vector_bits,
                        vector_enum: req.vector_enum,
                        vector_struct: req.vector_struct,
                        vector_table: req.vector_table,
                        vector_union: req.vector_union,
                        vector_opt_struct: req.vector_opt_struct,
                        vector_opt_union: req.vector_opt_union,

                        control_handle,
                    })
                }
                0x371140db701b23b4 => {
                    let mut req = fidl::new_empty!(VectorCompound);
                    fidl::encoding::Decoder::decode_into::<VectorCompound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayVectorCompound {
                        vector_bits: req.vector_bits,
                        vector_enum: req.vector_enum,
                        vector_struct: req.vector_struct,
                        vector_table: req.vector_table,
                        vector_union: req.vector_union,
                        vector_opt_struct: req.vector_opt_struct,
                        vector_opt_union: req.vector_opt_union,

                        responder: ProtocolTwoWayVectorCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x760e278628f7a985 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorVectorCompound {
                        responder: ProtocolErrorVectorCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x153c6b333c21c52f => {
                    let mut req = fidl::new_empty!(VectorOptional);
                    fidl::encoding::Decoder::decode_into::<VectorOptional>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayVectorOptional {
                        opt_vector_uint8: req.opt_vector_uint8,
                        opt_vector_string: req.opt_vector_string,
                        opt_vector_struct: req.opt_vector_struct,
                        opt_vector_opt_struct: req.opt_vector_opt_struct,

                        control_handle,
                    })
                }
                0xe4b620aaafd73f3 => {
                    let mut req = fidl::new_empty!(VectorOptional);
                    fidl::encoding::Decoder::decode_into::<VectorOptional>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayVectorOptional {
                        opt_vector_uint8: req.opt_vector_uint8,
                        opt_vector_string: req.opt_vector_string,
                        opt_vector_struct: req.opt_vector_struct,
                        opt_vector_opt_struct: req.opt_vector_opt_struct,

                        responder: ProtocolTwoWayVectorOptionalResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x58e75cf86e2d715e => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorVectorOptional {
                        responder: ProtocolErrorVectorOptionalResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x520dc9cb9b9b5ed7 => {
                    let mut req = fidl::new_empty!(ArrayVectorNested);
                    fidl::encoding::Decoder::decode_into::<ArrayVectorNested>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayArrayVectorNested {
                        vector_array_uint8: req.vector_array_uint8,
                        vector_vector_uint8: req.vector_vector_uint8,

                        control_handle,
                    })
                }
                0x4a438ce0948817dc => {
                    let mut req = fidl::new_empty!(ArrayVectorNested);
                    fidl::encoding::Decoder::decode_into::<ArrayVectorNested>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayArrayVectorNested {
                        vector_array_uint8: req.vector_array_uint8,
                        vector_vector_uint8: req.vector_vector_uint8,

                        responder: ProtocolTwoWayArrayVectorNestedResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x7e168d89e1dac8a7 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorArrayVectorNested {
                        responder: ProtocolErrorArrayVectorNestedResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x5af4795a9ed3a022 => {
                    let mut req = fidl::new_empty!(Resource);
                    fidl::encoding::Decoder::decode_into::<Resource>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayResource {
                        handle: req.handle,
                        vmo: req.vmo,
                        client_end: req.client_end,
                        server_end: req.server_end,
                        struct_: req.struct_,
                        table: req.table,
                        union: req.union,
                        opt_handle: req.opt_handle,
                        opt_vmo: req.opt_vmo,
                        opt_client_end: req.opt_client_end,
                        opt_server_end: req.opt_server_end,
                        opt_struct: req.opt_struct,
                        opt_union: req.opt_union,
                        array_handle: req.array_handle,
                        array_vmo: req.array_vmo,
                        array_client_end: req.array_client_end,
                        array_server_end: req.array_server_end,
                        array_struct: req.array_struct,
                        array_table: req.array_table,
                        array_union: req.array_union,
                        vector_handle: req.vector_handle,
                        vector_vmo: req.vector_vmo,
                        vector_client_end: req.vector_client_end,
                        vector_server_end: req.vector_server_end,
                        vector_struct: req.vector_struct,
                        vector_table: req.vector_table,
                        vector_union: req.vector_union,

                        control_handle,
                    })
                }
                0x1904824a11c6ad5b => {
                    let mut req = fidl::new_empty!(Resource);
                    fidl::encoding::Decoder::decode_into::<Resource>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayResource {
                        handle: req.handle,
                        vmo: req.vmo,
                        client_end: req.client_end,
                        server_end: req.server_end,
                        struct_: req.struct_,
                        table: req.table,
                        union: req.union,
                        opt_handle: req.opt_handle,
                        opt_vmo: req.opt_vmo,
                        opt_client_end: req.opt_client_end,
                        opt_server_end: req.opt_server_end,
                        opt_struct: req.opt_struct,
                        opt_union: req.opt_union,
                        array_handle: req.array_handle,
                        array_vmo: req.array_vmo,
                        array_client_end: req.array_client_end,
                        array_server_end: req.array_server_end,
                        array_struct: req.array_struct,
                        array_table: req.array_table,
                        array_union: req.array_union,
                        vector_handle: req.vector_handle,
                        vector_vmo: req.vector_vmo,
                        vector_client_end: req.vector_client_end,
                        vector_server_end: req.vector_server_end,
                        vector_struct: req.vector_struct,
                        vector_table: req.vector_table,
                        vector_union: req.vector_union,

                        responder: ProtocolTwoWayResourceResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x5b28634d603175b6 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorResource {
                        responder: ProtocolErrorResourceResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                _ => Err(fidl::Error::UnknownOrdinal {
                    ordinal: header.ordinal(),
                    protocol_name: <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME,
                }),
            }))
        })
    }
}

#[derive(Debug)]
pub enum ProtocolRequest {
    OneWayBasic {
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: String,
        opt_string: Option<String>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayBasic {
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: String,
        opt_string: Option<String>,
        responder: ProtocolTwoWayBasicResponder,
    },
    ErrorBasic {
        responder: ProtocolErrorBasicResponder,
    },
    OneWayCompound {
        bits: Bits,
        enum_: Enum,
        struct_: Struct,
        table: Table,
        union: Union,
        opt_struct: Option<Box<Struct>>,
        opt_union: Option<Box<Union>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayCompound {
        bits: Bits,
        enum_: Enum,
        struct_: Struct,
        table: Table,
        union: Union,
        opt_struct: Option<Box<Struct>>,
        opt_union: Option<Box<Union>>,
        responder: ProtocolTwoWayCompoundResponder,
    },
    ErrorCompound {
        responder: ProtocolErrorCompoundResponder,
    },
    OneWayArrayBasic {
        array_uint8: [u8; 5],
        array_uint16: [u16; 5],
        array_uint32: [u32; 5],
        array_uint64: [u64; 5],
        array_int8: [i8; 5],
        array_int16: [i16; 5],
        array_int32: [i32; 5],
        array_int64: [i64; 5],
        array_float32: [f32; 5],
        array_float64: [f64; 5],
        array_string: [String; 5],
        array_opt_string: [Option<String>; 5],
        control_handle: ProtocolControlHandle,
    },
    TwoWayArrayBasic {
        array_uint8: [u8; 5],
        array_uint16: [u16; 5],
        array_uint32: [u32; 5],
        array_uint64: [u64; 5],
        array_int8: [i8; 5],
        array_int16: [i16; 5],
        array_int32: [i32; 5],
        array_int64: [i64; 5],
        array_float32: [f32; 5],
        array_float64: [f64; 5],
        array_string: [String; 5],
        array_opt_string: [Option<String>; 5],
        responder: ProtocolTwoWayArrayBasicResponder,
    },
    ErrorArrayBasic {
        responder: ProtocolErrorArrayBasicResponder,
    },
    OneWayArrayCompound {
        array_bits: [Bits; 5],
        array_enum: [Enum; 5],
        array_struct: [Struct; 5],
        array_table: [Table; 5],
        array_union: [Union; 5],
        control_handle: ProtocolControlHandle,
    },
    TwoWayArrayCompound {
        array_bits: [Bits; 5],
        array_enum: [Enum; 5],
        array_struct: [Struct; 5],
        array_table: [Table; 5],
        array_union: [Union; 5],
        responder: ProtocolTwoWayArrayCompoundResponder,
    },
    ErrorArrayCompound {
        responder: ProtocolErrorArrayCompoundResponder,
    },
    OneWayVectorBasic {
        vector_uint8: Vec<u8>,
        vector_uint16: Vec<u16>,
        vector_uint32: Vec<u32>,
        vector_uint64: Vec<u64>,
        vector_int8: Vec<i8>,
        vector_int16: Vec<i16>,
        vector_int32: Vec<i32>,
        vector_int64: Vec<i64>,
        vector_float32: Vec<f32>,
        vector_float64: Vec<f64>,
        vector_string: Vec<String>,
        vector_opt_string: Vec<Option<String>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayVectorBasic {
        vector_uint8: Vec<u8>,
        vector_uint16: Vec<u16>,
        vector_uint32: Vec<u32>,
        vector_uint64: Vec<u64>,
        vector_int8: Vec<i8>,
        vector_int16: Vec<i16>,
        vector_int32: Vec<i32>,
        vector_int64: Vec<i64>,
        vector_float32: Vec<f32>,
        vector_float64: Vec<f64>,
        vector_string: Vec<String>,
        vector_opt_string: Vec<Option<String>>,
        responder: ProtocolTwoWayVectorBasicResponder,
    },
    ErrorVectorBasic {
        responder: ProtocolErrorVectorBasicResponder,
    },
    OneWayVectorCompound {
        vector_bits: Vec<Bits>,
        vector_enum: Vec<Enum>,
        vector_struct: Vec<Struct>,
        vector_table: Vec<Table>,
        vector_union: Vec<Union>,
        vector_opt_struct: Vec<Option<Box<Struct>>>,
        vector_opt_union: Vec<Option<Box<Union>>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayVectorCompound {
        vector_bits: Vec<Bits>,
        vector_enum: Vec<Enum>,
        vector_struct: Vec<Struct>,
        vector_table: Vec<Table>,
        vector_union: Vec<Union>,
        vector_opt_struct: Vec<Option<Box<Struct>>>,
        vector_opt_union: Vec<Option<Box<Union>>>,
        responder: ProtocolTwoWayVectorCompoundResponder,
    },
    ErrorVectorCompound {
        responder: ProtocolErrorVectorCompoundResponder,
    },
    OneWayVectorOptional {
        opt_vector_uint8: Option<Vec<u8>>,
        opt_vector_string: Option<Vec<String>>,
        opt_vector_struct: Option<Vec<Struct>>,
        opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayVectorOptional {
        opt_vector_uint8: Option<Vec<u8>>,
        opt_vector_string: Option<Vec<String>>,
        opt_vector_struct: Option<Vec<Struct>>,
        opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
        responder: ProtocolTwoWayVectorOptionalResponder,
    },
    ErrorVectorOptional {
        responder: ProtocolErrorVectorOptionalResponder,
    },
    OneWayArrayVectorNested {
        vector_array_uint8: Vec<[u8; 5]>,
        vector_vector_uint8: Vec<Vec<u8>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayArrayVectorNested {
        vector_array_uint8: Vec<[u8; 5]>,
        vector_vector_uint8: Vec<Vec<u8>>,
        responder: ProtocolTwoWayArrayVectorNestedResponder,
    },
    ErrorArrayVectorNested {
        responder: ProtocolErrorArrayVectorNestedResponder,
    },
    OneWayResource {
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<Box<ResourceStruct>>,
        opt_union: Option<Box<ResourceUnion>>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayResource {
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<Box<ResourceStruct>>,
        opt_union: Option<Box<ResourceUnion>>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
        responder: ProtocolTwoWayResourceResponder,
    },
    ErrorResource {
        responder: ProtocolErrorResourceResponder,
    },
}

impl ProtocolRequest {
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_basic(
        self,
    ) -> Option<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayBasic {
            uint8,
            uint16,
            uint32,
            uint64,
            int8,
            int16,
            int32,
            int64,
            float32,
            float64,
            string,
            opt_string,
            control_handle,
        } = self
        {
            Some((
                uint8,
                uint16,
                uint32,
                uint64,
                int8,
                int16,
                int32,
                int64,
                float32,
                float64,
                string,
                opt_string,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_basic(
        self,
    ) -> Option<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
        ProtocolTwoWayBasicResponder,
    )> {
        if let ProtocolRequest::TwoWayBasic {
            uint8,
            uint16,
            uint32,
            uint64,
            int8,
            int16,
            int32,
            int64,
            float32,
            float64,
            string,
            opt_string,
            responder,
        } = self
        {
            Some((
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string, responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_basic(self) -> Option<(ProtocolErrorBasicResponder)> {
        if let ProtocolRequest::ErrorBasic { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_compound(
        self,
    ) -> Option<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayCompound {
            bits,
            enum_,
            struct_,
            table,
            union,
            opt_struct,
            opt_union,
            control_handle,
        } = self
        {
            Some((bits, enum_, struct_, table, union, opt_struct, opt_union, control_handle))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_compound(
        self,
    ) -> Option<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
        ProtocolTwoWayCompoundResponder,
    )> {
        if let ProtocolRequest::TwoWayCompound {
            bits,
            enum_,
            struct_,
            table,
            union,
            opt_struct,
            opt_union,
            responder,
        } = self
        {
            Some((bits, enum_, struct_, table, union, opt_struct, opt_union, responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_compound(self) -> Option<(ProtocolErrorCompoundResponder)> {
        if let ProtocolRequest::ErrorCompound { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_array_basic(
        self,
    ) -> Option<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayArrayBasic {
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
            control_handle,
        } = self
        {
            Some((
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_array_basic(
        self,
    ) -> Option<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
        ProtocolTwoWayArrayBasicResponder,
    )> {
        if let ProtocolRequest::TwoWayArrayBasic {
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
            responder,
        } = self
        {
            Some((
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
                responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_array_basic(self) -> Option<(ProtocolErrorArrayBasicResponder)> {
        if let ProtocolRequest::ErrorArrayBasic { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_array_compound(
        self,
    ) -> Option<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5], ProtocolControlHandle)>
    {
        if let ProtocolRequest::OneWayArrayCompound {
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
            control_handle,
        } = self
        {
            Some((array_bits, array_enum, array_struct, array_table, array_union, control_handle))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_array_compound(
        self,
    ) -> Option<(
        [Bits; 5],
        [Enum; 5],
        [Struct; 5],
        [Table; 5],
        [Union; 5],
        ProtocolTwoWayArrayCompoundResponder,
    )> {
        if let ProtocolRequest::TwoWayArrayCompound {
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
            responder,
        } = self
        {
            Some((array_bits, array_enum, array_struct, array_table, array_union, responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_array_compound(self) -> Option<(ProtocolErrorArrayCompoundResponder)> {
        if let ProtocolRequest::ErrorArrayCompound { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_vector_basic(
        self,
    ) -> Option<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayVectorBasic {
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
            control_handle,
        } = self
        {
            Some((
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_vector_basic(
        self,
    ) -> Option<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
        ProtocolTwoWayVectorBasicResponder,
    )> {
        if let ProtocolRequest::TwoWayVectorBasic {
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
            responder,
        } = self
        {
            Some((
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
                responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_vector_basic(self) -> Option<(ProtocolErrorVectorBasicResponder)> {
        if let ProtocolRequest::ErrorVectorBasic { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_vector_compound(
        self,
    ) -> Option<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayVectorCompound {
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
            control_handle,
        } = self
        {
            Some((
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_vector_compound(
        self,
    ) -> Option<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
        ProtocolTwoWayVectorCompoundResponder,
    )> {
        if let ProtocolRequest::TwoWayVectorCompound {
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
            responder,
        } = self
        {
            Some((
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
                responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_vector_compound(self) -> Option<(ProtocolErrorVectorCompoundResponder)> {
        if let ProtocolRequest::ErrorVectorCompound { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_vector_optional(
        self,
    ) -> Option<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayVectorOptional {
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
            control_handle,
        } = self
        {
            Some((
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_vector_optional(
        self,
    ) -> Option<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
        ProtocolTwoWayVectorOptionalResponder,
    )> {
        if let ProtocolRequest::TwoWayVectorOptional {
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
            responder,
        } = self
        {
            Some((
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,
                responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_vector_optional(self) -> Option<(ProtocolErrorVectorOptionalResponder)> {
        if let ProtocolRequest::ErrorVectorOptional { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_array_vector_nested(
        self,
    ) -> Option<(Vec<[u8; 5]>, Vec<Vec<u8>>, ProtocolControlHandle)> {
        if let ProtocolRequest::OneWayArrayVectorNested {
            vector_array_uint8,
            vector_vector_uint8,
            control_handle,
        } = self
        {
            Some((vector_array_uint8, vector_vector_uint8, control_handle))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_array_vector_nested(
        self,
    ) -> Option<(Vec<[u8; 5]>, Vec<Vec<u8>>, ProtocolTwoWayArrayVectorNestedResponder)> {
        if let ProtocolRequest::TwoWayArrayVectorNested {
            vector_array_uint8,
            vector_vector_uint8,
            responder,
        } = self
        {
            Some((vector_array_uint8, vector_vector_uint8, responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_array_vector_nested(
        self,
    ) -> Option<(ProtocolErrorArrayVectorNestedResponder)> {
        if let ProtocolRequest::ErrorArrayVectorNested { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_resource(
        self,
    ) -> Option<(
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayResource {
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
            control_handle,
        } = self
        {
            Some((
                handle,
                vmo,
                client_end,
                server_end,
                struct_,
                table,
                union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_resource(
        self,
    ) -> Option<(
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
        ProtocolTwoWayResourceResponder,
    )> {
        if let ProtocolRequest::TwoWayResource {
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
            responder,
        } = self
        {
            Some((
                handle,
                vmo,
                client_end,
                server_end,
                struct_,
                table,
                union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,
                responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_resource(self) -> Option<(ProtocolErrorResourceResponder)> {
        if let ProtocolRequest::ErrorResource { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    /// Name of the method defined in FIDL
    pub fn method_name(&self) -> &'static str {
        match *self {
            ProtocolRequest::OneWayBasic { .. } => "one_way_basic",
            ProtocolRequest::TwoWayBasic { .. } => "two_way_basic",
            ProtocolRequest::ErrorBasic { .. } => "error_basic",
            ProtocolRequest::OneWayCompound { .. } => "one_way_compound",
            ProtocolRequest::TwoWayCompound { .. } => "two_way_compound",
            ProtocolRequest::ErrorCompound { .. } => "error_compound",
            ProtocolRequest::OneWayArrayBasic { .. } => "one_way_array_basic",
            ProtocolRequest::TwoWayArrayBasic { .. } => "two_way_array_basic",
            ProtocolRequest::ErrorArrayBasic { .. } => "error_array_basic",
            ProtocolRequest::OneWayArrayCompound { .. } => "one_way_array_compound",
            ProtocolRequest::TwoWayArrayCompound { .. } => "two_way_array_compound",
            ProtocolRequest::ErrorArrayCompound { .. } => "error_array_compound",
            ProtocolRequest::OneWayVectorBasic { .. } => "one_way_vector_basic",
            ProtocolRequest::TwoWayVectorBasic { .. } => "two_way_vector_basic",
            ProtocolRequest::ErrorVectorBasic { .. } => "error_vector_basic",
            ProtocolRequest::OneWayVectorCompound { .. } => "one_way_vector_compound",
            ProtocolRequest::TwoWayVectorCompound { .. } => "two_way_vector_compound",
            ProtocolRequest::ErrorVectorCompound { .. } => "error_vector_compound",
            ProtocolRequest::OneWayVectorOptional { .. } => "one_way_vector_optional",
            ProtocolRequest::TwoWayVectorOptional { .. } => "two_way_vector_optional",
            ProtocolRequest::ErrorVectorOptional { .. } => "error_vector_optional",
            ProtocolRequest::OneWayArrayVectorNested { .. } => "one_way_array_vector_nested",
            ProtocolRequest::TwoWayArrayVectorNested { .. } => "two_way_array_vector_nested",
            ProtocolRequest::ErrorArrayVectorNested { .. } => "error_array_vector_nested",
            ProtocolRequest::OneWayResource { .. } => "one_way_resource",
            ProtocolRequest::TwoWayResource { .. } => "two_way_resource",
            ProtocolRequest::ErrorResource { .. } => "error_resource",
        }
    }
}

#[derive(Debug, Clone)]
pub struct ProtocolControlHandle {
    inner: std::sync::Arc<fidl::ServeInner>,
}

impl fidl::endpoints::ControlHandle for ProtocolControlHandle {
    fn shutdown(&self) {
        self.inner.shutdown()
    }

    fn shutdown_with_epitaph(&self, status: zx_status::Status) {
        self.inner.shutdown_with_epitaph(status)
    }

    fn is_closed(&self) -> bool {
        self.inner.channel().is_closed()
    }

    fn on_closed<'a>(&'a self) -> fidl::OnSignals<'a> {
        self.inner.channel().on_closed()
    }
}

impl ProtocolControlHandle {
    pub fn send_event_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<Basic>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0,
            0x51c5b06295c10c40,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<Compound>(
            (bits, enum_, struct_, table, union, opt_struct, opt_union),
            0,
            0x617c5410858734d5,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<ArrayBasic>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0,
            0x51b76208b148f02e,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<ArrayCompound>(
            (array_bits, array_enum, array_struct, array_table, array_union),
            0,
            0x1e63a00079aa7415,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<VectorBasic>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0,
            0x3f9d405e7191eff6,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<VectorCompound>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0,
            0x53a1fc56e8b3cff3,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<VectorOptional>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0,
            0x17617b54dfa8d85d,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<ArrayVectorNested>(
            (vector_array_uint8, vector_vector_uint8),
            0,
            0x110b72cfebc4037e,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<Resource>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0,
            0x4fbde2864601698b,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
            opt_string,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
            opt_string,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<Basic>>(
                bytes, handles, msg,
            )?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, &str, Option<&str>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, &str, Option<&str>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, &str, Option<&str>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<fidl::encoding::ResultType<Basic, u32>>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(bits, enum_, struct_, table, union, opt_struct, opt_union);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(bits, enum_, struct_, table, union, opt_struct, opt_union);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (bits, enum_, struct_, table, union, opt_struct, opt_union),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<Compound>>(
                bytes, handles, msg,
            )?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (Bits, Enum, &Struct, &Table, &Union, Option<&Struct>, Option<&Union>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (Bits, Enum, &Struct, &Table, &Union, Option<&Struct>, Option<&Union>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (Bits, Enum, &Struct, &Table, &Union, Option<&Struct>, Option<&Union>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<fidl::encoding::ResultType<Compound, u32>>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayArrayBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayArrayBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayArrayBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayArrayBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<ArrayBasic>>(
                bytes, handles, msg,
            )?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorArrayBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorArrayBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorArrayBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorArrayBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (
                &[u8; 5],
                &[u16; 5],
                &[u32; 5],
                &[u64; 5],
                &[i8; 5],
                &[i16; 5],
                &[i32; 5],
                &[i64; 5],
                &[f32; 5],
                &[f64; 5],
                &[String; 5],
                &[Option<String>; 5],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (
                &[u8; 5],
                &[u16; 5],
                &[u32; 5],
                &[u64; 5],
                &[i8; 5],
                &[i16; 5],
                &[i32; 5],
                &[i64; 5],
                &[f32; 5],
                &[f64; 5],
                &[String; 5],
                &[Option<String>; 5],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (
                &[u8; 5],
                &[u16; 5],
                &[u32; 5],
                &[u64; 5],
                &[i8; 5],
                &[i16; 5],
                &[i32; 5],
                &[i64; 5],
                &[f32; 5],
                &[f64; 5],
                &[String; 5],
                &[Option<String>; 5],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<fidl::encoding::ResultType<ArrayBasic, u32>>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayArrayCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayArrayCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayArrayCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayArrayCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(array_bits, array_enum, array_struct, array_table, array_union);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(array_bits, array_enum, array_struct, array_table, array_union);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (array_bits, array_enum, array_struct, array_table, array_union),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<ArrayCompound>>(
                bytes, handles, msg,
            )?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorArrayCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorArrayCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorArrayCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorArrayCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<(&[Bits; 5], &[Enum; 5], &[Struct; 5], &[Table; 5], &[Union; 5]), u32>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<(&[Bits; 5], &[Enum; 5], &[Struct; 5], &[Table; 5], &[Union; 5]), u32>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<(&[Bits; 5], &[Enum; 5], &[Struct; 5], &[Table; 5], &[Union; 5]), u32>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<
                    fidl::encoding::ResultType<ArrayCompound, u32>,
                >,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayVectorBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayVectorBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayVectorBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayVectorBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<VectorBasic>>(
                bytes, handles, msg,
            )?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorVectorBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorVectorBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorVectorBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorVectorBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (
                &[u8],
                &[u16],
                &[u32],
                &[u64],
                &[i8],
                &[i16],
                &[i32],
                &[i64],
                &[f32],
                &[f64],
                &[String],
                &[Option<String>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (
                &[u8],
                &[u16],
                &[u32],
                &[u64],
                &[i8],
                &[i16],
                &[i32],
                &[i64],
                &[f32],
                &[f64],
                &[String],
                &[Option<String>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (
                &[u8],
                &[u16],
                &[u32],
                &[u64],
                &[i8],
                &[i16],
                &[i32],
                &[i64],
                &[f32],
                &[f64],
                &[String],
                &[Option<String>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<
                    fidl::encoding::ResultType<VectorBasic, u32>,
                >,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayVectorCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayVectorCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayVectorCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayVectorCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<VectorCompound>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorVectorCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorVectorCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorVectorCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorVectorCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (
                &[Bits],
                &[Enum],
                &[Struct],
                &[Table],
                &[Union],
                &[Option<Box<Struct>>],
                &[Option<Box<Union>>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (
                &[Bits],
                &[Enum],
                &[Struct],
                &[Table],
                &[Union],
                &[Option<Box<Struct>>],
                &[Option<Box<Union>>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (
                &[Bits],
                &[Enum],
                &[Struct],
                &[Table],
                &[Union],
                &[Option<Box<Struct>>],
                &[Option<Box<Union>>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<
                    fidl::encoding::ResultType<VectorCompound, u32>,
                >,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayVectorOptionalResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayVectorOptionalResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayVectorOptionalResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayVectorOptionalResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<VectorOptional>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorVectorOptionalResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorVectorOptionalResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorVectorOptionalResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorVectorOptionalResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (Option<&[u8]>, Option<&[String]>, Option<&[Struct]>, Option<&[Option<Box<Struct>>]>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (Option<&[u8]>, Option<&[String]>, Option<&[Struct]>, Option<&[Option<Box<Struct>>]>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (Option<&[u8]>, Option<&[String]>, Option<&[Struct]>, Option<&[Option<Box<Struct>>]>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<
                    fidl::encoding::ResultType<VectorOptional, u32>,
                >,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayArrayVectorNestedResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayArrayVectorNestedResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayArrayVectorNestedResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayArrayVectorNestedResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(vector_array_uint8, vector_vector_uint8);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(vector_array_uint8, vector_vector_uint8);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (vector_array_uint8, vector_vector_uint8),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<ArrayVectorNested>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorArrayVectorNestedResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorArrayVectorNestedResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorArrayVectorNestedResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorArrayVectorNestedResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<(&[[u8; 5]], &[Vec<u8>]), u32>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<(&[[u8; 5]], &[Vec<u8>]), u32>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<(&[[u8; 5]], &[Vec<u8>]), u32>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<
                    fidl::encoding::ResultType<ArrayVectorNested, u32>,
                >,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayResourceResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayResourceResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayResourceResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayResourceResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<Resource>>(
                bytes, handles, msg,
            )?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorResourceResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorResourceResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorResourceResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorResourceResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (
                fidl::Handle,
                fidl::Vmo,
                fidl::endpoints::ClientEnd<ProtocolMarker>,
                fidl::endpoints::ServerEnd<ProtocolMarker>,
                ResourceStruct,
                ResourceTable,
                ResourceUnion,
                Option<fidl::Handle>,
                Option<fidl::Vmo>,
                Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Option<ResourceStruct>,
                Option<ResourceUnion>,
                [fidl::Handle; 5],
                [fidl::Vmo; 5],
                [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                [ResourceStruct; 5],
                [ResourceTable; 5],
                [ResourceUnion; 5],
                Vec<fidl::Handle>,
                Vec<fidl::Vmo>,
                Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Vec<ResourceStruct>,
                Vec<ResourceTable>,
                Vec<ResourceUnion>,
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (
                fidl::Handle,
                fidl::Vmo,
                fidl::endpoints::ClientEnd<ProtocolMarker>,
                fidl::endpoints::ServerEnd<ProtocolMarker>,
                ResourceStruct,
                ResourceTable,
                ResourceUnion,
                Option<fidl::Handle>,
                Option<fidl::Vmo>,
                Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Option<ResourceStruct>,
                Option<ResourceUnion>,
                [fidl::Handle; 5],
                [fidl::Vmo; 5],
                [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                [ResourceStruct; 5],
                [ResourceTable; 5],
                [ResourceUnion; 5],
                Vec<fidl::Handle>,
                Vec<fidl::Vmo>,
                Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Vec<ResourceStruct>,
                Vec<ResourceTable>,
                Vec<ResourceUnion>,
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (
                fidl::Handle,
                fidl::Vmo,
                fidl::endpoints::ClientEnd<ProtocolMarker>,
                fidl::endpoints::ServerEnd<ProtocolMarker>,
                ResourceStruct,
                ResourceTable,
                ResourceUnion,
                Option<fidl::Handle>,
                Option<fidl::Vmo>,
                Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Option<ResourceStruct>,
                Option<ResourceUnion>,
                [fidl::Handle; 5],
                [fidl::Vmo; 5],
                [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                [ResourceStruct; 5],
                [ResourceTable; 5],
                [ResourceUnion; 5],
                Vec<fidl::Handle>,
                Vec<fidl::Vmo>,
                Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Vec<ResourceStruct>,
                Vec<ResourceTable>,
                Vec<ResourceUnion>,
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result.as_mut().map_err(|e| *e).map(
                |(
                    handle,
                    vmo,
                    client_end,
                    server_end,
                    struct_,
                    table,
                    union,
                    opt_handle,
                    opt_vmo,
                    opt_client_end,
                    opt_server_end,
                    opt_struct,
                    opt_union,
                    array_handle,
                    array_vmo,
                    array_client_end,
                    array_server_end,
                    array_struct,
                    array_table,
                    array_union,
                    vector_handle,
                    vector_vmo,
                    vector_client_end,
                    vector_server_end,
                    vector_struct,
                    vector_table,
                    vector_union,
                )| {
                    (
                        std::mem::replace(handle, fidl::Handle::invalid().into()),
                        std::mem::replace(vmo, fidl::Handle::invalid().into()),
                        std::mem::replace(client_end, fidl::Handle::invalid().into()),
                        std::mem::replace(server_end, fidl::Handle::invalid().into()),
                        struct_,
                        table,
                        union,
                        opt_handle
                            .as_mut()
                            .map(|x| std::mem::replace(x, fidl::Handle::invalid().into())),
                        opt_vmo
                            .as_mut()
                            .map(|x| std::mem::replace(x, fidl::Handle::invalid().into())),
                        opt_client_end
                            .as_mut()
                            .map(|x| std::mem::replace(x, fidl::Handle::invalid().into())),
                        opt_server_end
                            .as_mut()
                            .map(|x| std::mem::replace(x, fidl::Handle::invalid().into())),
                        opt_struct.as_mut(),
                        opt_union.as_mut(),
                        array_handle,
                        array_vmo,
                        array_client_end,
                        array_server_end,
                        array_struct,
                        array_table,
                        array_union,
                        vector_handle.as_mut_slice(),
                        vector_vmo.as_mut_slice(),
                        vector_client_end.as_mut_slice(),
                        vector_server_end.as_mut_slice(),
                        vector_struct.as_mut_slice(),
                        vector_table.as_mut_slice(),
                        vector_union.as_mut_slice(),
                    )
                },
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<fidl::encoding::ResultType<Resource, u32>>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}

mod internal {
    use super::*;
    unsafe impl fidl::encoding::TypeMarker for Bits {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
    }

    impl fidl::encoding::ValueTypeMarker for Bits {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            *value
        }
    }

    unsafe impl fidl::encoding::Encode<Self> for Bits {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.bits, offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for Bits {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::empty()
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);
            *self = Self::from_bits_allow_unknown(prim);
            Ok(())
        }
    }
    unsafe impl fidl::encoding::TypeMarker for Enum {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            std::mem::align_of::<u32>()
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            std::mem::size_of::<u32>()
        }

        #[inline(always)]
        fn encode_is_copy() -> bool {
            false
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            false
        }
    }

    impl fidl::encoding::ValueTypeMarker for Enum {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            *value
        }
    }

    unsafe impl fidl::encoding::Encode<Self> for Enum {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.into_primitive(), offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for Enum {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::unknown()
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);

            *self = Self::from_primitive_allow_unknown(prim);
            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ArrayBasic {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 384,
                fidl::encoding::WireFormatVersion::V2 => 384,
            }
        }
    }
    impl fidl::encoding::ValueTypeMarker for ArrayBasic {
        type Borrowed<'a> = &'a Self;
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<ArrayBasic> for &ArrayBasic {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ArrayBasic>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<ArrayBasic>::encode(
                (
                    <fidl::encoding::Array<u8, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_uint8),
                    <fidl::encoding::Array<u16, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_uint16),
                    <fidl::encoding::Array<u32, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_uint32),
                    <fidl::encoding::Array<u64, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_uint64),
                    <fidl::encoding::Array<i8, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_int8),
                    <fidl::encoding::Array<i16, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_int16),
                    <fidl::encoding::Array<i32, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_int32),
                    <fidl::encoding::Array<i64, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_int64),
                    <fidl::encoding::Array<f32, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_float32),
                    <fidl::encoding::Array<f64, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_float64),
                    <fidl::encoding::Array<fidl::encoding::UnboundedString, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_string),
                    <fidl::encoding::Array<fidl::encoding::Optional<fidl::encoding::UnboundedString>, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_opt_string),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            T0: fidl::encoding::Encode<fidl::encoding::Array<u8, 5>>,
            T1: fidl::encoding::Encode<fidl::encoding::Array<u16, 5>>,
            T2: fidl::encoding::Encode<fidl::encoding::Array<u32, 5>>,
            T3: fidl::encoding::Encode<fidl::encoding::Array<u64, 5>>,
            T4: fidl::encoding::Encode<fidl::encoding::Array<i8, 5>>,
            T5: fidl::encoding::Encode<fidl::encoding::Array<i16, 5>>,
            T6: fidl::encoding::Encode<fidl::encoding::Array<i32, 5>>,
            T7: fidl::encoding::Encode<fidl::encoding::Array<i64, 5>>,
            T8: fidl::encoding::Encode<fidl::encoding::Array<f32, 5>>,
            T9: fidl::encoding::Encode<fidl::encoding::Array<f64, 5>>,
            T10: fidl::encoding::Encode<fidl::encoding::Array<fidl::encoding::UnboundedString, 5>>,
            T11: fidl::encoding::Encode<
                fidl::encoding::Array<fidl::encoding::Optional<fidl::encoding::UnboundedString>, 5>,
            >,
        > fidl::encoding::Encode<ArrayBasic>
        for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ArrayBasic>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(32);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(80);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(112);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(176);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                }
                fidl::encoding::WireFormatVersion::V2 => {
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(32);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(80);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(112);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(176);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                }
            };
            // Write the fields.
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            self.0.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 6,
                fidl::encoding::WireFormatVersion::V2 => 6,
            };
            self.1.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            self.2.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 40,
                fidl::encoding::WireFormatVersion::V2 => 40,
            };
            self.3.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 80,
                fidl::encoding::WireFormatVersion::V2 => 80,
            };
            self.4.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 86,
                fidl::encoding::WireFormatVersion::V2 => 86,
            };
            self.5.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 96,
                fidl::encoding::WireFormatVersion::V2 => 96,
            };
            self.6.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 120,
                fidl::encoding::WireFormatVersion::V2 => 120,
            };
            self.7.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 160,
                fidl::encoding::WireFormatVersion::V2 => 160,
            };
            self.8.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 184,
                fidl::encoding::WireFormatVersion::V2 => 184,
            };
            self.9.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 224,
                fidl::encoding::WireFormatVersion::V2 => 224,
            };
            self.10.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 304,
                fidl::encoding::WireFormatVersion::V2 => 304,
            };
            self.11.encode(encoder, offset + member_offset, depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for ArrayBasic {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                array_uint8: fidl::new_empty!(fidl::encoding::Array<u8, 5>),
                array_uint16: fidl::new_empty!(fidl::encoding::Array<u16, 5>),
                array_uint32: fidl::new_empty!(fidl::encoding::Array<u32, 5>),
                array_uint64: fidl::new_empty!(fidl::encoding::Array<u64, 5>),
                array_int8: fidl::new_empty!(fidl::encoding::Array<i8, 5>),
                array_int16: fidl::new_empty!(fidl::encoding::Array<i16, 5>),
                array_int32: fidl::new_empty!(fidl::encoding::Array<i32, 5>),
                array_int64: fidl::new_empty!(fidl::encoding::Array<i64, 5>),
                array_float32: fidl::new_empty!(fidl::encoding::Array<f32, 5>),
                array_float64: fidl::new_empty!(fidl::encoding::Array<f64, 5>),
                array_string: fidl::new_empty!(fidl::encoding::Array<fidl::encoding::UnboundedString, 5>),
                array_opt_string: fidl::new_empty!(
                    fidl::encoding::Array<
                        fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                        5,
                    >
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(0) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0x0000ff0000000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 0
                                + ((0x0000ff0000000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(32) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 32
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(80) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0x0000ff0000000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 80
                                + ((0x0000ff0000000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(112) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 112
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(176) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 176
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
                fidl::encoding::WireFormatVersion::V2 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(0) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0x0000ff0000000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 0
                                + ((0x0000ff0000000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(32) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 32
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(80) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0x0000ff0000000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 80
                                + ((0x0000ff0000000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(112) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 112
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(176) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 176
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
            };
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            fidl::decode!(fidl::encoding::Array<u8, 5>, &mut self.array_uint8, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 6,
                fidl::encoding::WireFormatVersion::V2 => 6,
            };
            fidl::decode!(fidl::encoding::Array<u16, 5>, &mut self.array_uint16, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            fidl::decode!(fidl::encoding::Array<u32, 5>, &mut self.array_uint32, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 40,
                fidl::encoding::WireFormatVersion::V2 => 40,
            };
            fidl::decode!(fidl::encoding::Array<u64, 5>, &mut self.array_uint64, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 80,
                fidl::encoding::WireFormatVersion::V2 => 80,
            };
            fidl::decode!(fidl::encoding::Array<i8, 5>, &mut self.array_int8, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 86,
                fidl::encoding::WireFormatVersion::V2 => 86,
            };
            fidl::decode!(fidl::encoding::Array<i16, 5>, &mut self.array_int16, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 96,
                fidl::encoding::WireFormatVersion::V2 => 96,
            };
            fidl::decode!(fidl::encoding::Array<i32, 5>, &mut self.array_int32, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 120,
                fidl::encoding::WireFormatVersion::V2 => 120,
            };
            fidl::decode!(fidl::encoding::Array<i64, 5>, &mut self.array_int64, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 160,
                fidl::encoding::WireFormatVersion::V2 => 160,
            };
            fidl::decode!(fidl::encoding::Array<f32, 5>, &mut self.array_float32, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 184,
                fidl::encoding::WireFormatVersion::V2 => 184,
            };
            fidl::decode!(fidl::encoding::Array<f64, 5>, &mut self.array_float64, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 224,
                fidl::encoding::WireFormatVersion::V2 => 224,
            };
            fidl::decode!(fidl::encoding::Array<fidl::encoding::UnboundedString, 5>, &mut self.array_string, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 304,
                fidl::encoding::WireFormatVersion::V2 => 304,
            };
            fidl::decode!(
                fidl::encoding::Array<fidl::encoding::Optional<fidl::encoding::UnboundedString>, 5>,
                &mut self.array_opt_string,
                decoder,
                offset + member_offset,
                _depth
            )?;
            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ArrayCompound {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 408,
                fidl::encoding::WireFormatVersion::V2 => 328,
            }
        }
    }
    impl fidl::encoding::ValueTypeMarker for ArrayCompound {
        type Borrowed<'a> = &'a Self;
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<ArrayCompound> for &ArrayCompound {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ArrayCompound>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<ArrayCompound>::encode(
                (
                    <fidl::encoding::Array<Bits, 5> as fidl::encoding::ValueTypeMarker>::borrow(
                        &self.array_bits,
                    ),
                    <fidl::encoding::Array<Enum, 5> as fidl::encoding::ValueTypeMarker>::borrow(
                        &self.array_enum,
                    ),
                    <fidl::encoding::Array<Struct, 5> as fidl::encoding::ValueTypeMarker>::borrow(
                        &self.array_struct,
                    ),
                    <fidl::encoding::Array<Table, 5> as fidl::encoding::ValueTypeMarker>::borrow(
                        &self.array_table,
                    ),
                    <fidl::encoding::Array<Union, 5> as fidl::encoding::ValueTypeMarker>::borrow(
                        &self.array_union,
                    ),
                ),
                encoder,
                offset,
                _depth,
            )
        }
    }
    unsafe impl<
            T0: fidl::encoding::Encode<fidl::encoding::Array<Bits, 5>>,
            T1: fidl::encoding::Encode<fidl::encoding::Array<Enum, 5>>,
            T2: fidl::encoding::Encode<fidl::encoding::Array<Struct, 5>>,
            T3: fidl::encoding::Encode<fidl::encoding::Array<Table, 5>>,
            T4: fidl::encoding::Encode<fidl::encoding::Array<Union, 5>>,
        > fidl::encoding::Encode<ArrayCompound> for (T0, T1, T2, T3, T4)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ArrayCompound>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => unsafe {
                    let ptr = encoder.buf.as_mut_ptr().add(offset).offset(40);
                    (ptr as *mut u64).write_unaligned(0);
                },
                fidl::encoding::WireFormatVersion::V2 => unsafe {
                    let ptr = encoder.buf.as_mut_ptr().add(offset).offset(40);
                    (ptr as *mut u64).write_unaligned(0);
                },
            };
            // Write the fields.
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            self.0.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 20,
                fidl::encoding::WireFormatVersion::V2 => 20,
            };
            self.1.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 40,
                fidl::encoding::WireFormatVersion::V2 => 40,
            };
            self.2.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 48,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            self.3.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 128,
                fidl::encoding::WireFormatVersion::V2 => 128,
            };
            self.4.encode(encoder, offset + member_offset, depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for ArrayCompound {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                array_bits: fidl::new_empty!(fidl::encoding::Array<Bits, 5>),
                array_enum: fidl::new_empty!(fidl::encoding::Array<Enum, 5>),
                array_struct: fidl::new_empty!(fidl::encoding::Array<Struct, 5>),
                array_table: fidl::new_empty!(fidl::encoding::Array<Table, 5>),
                array_union: fidl::new_empty!(fidl::encoding::Array<Union, 5>),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(40) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffff0000000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 40
                                + ((0xffffff0000000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
                fidl::encoding::WireFormatVersion::V2 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(40) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffff0000000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 40
                                + ((0xffffff0000000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
            };
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            fidl::decode!(fidl::encoding::Array<Bits, 5>, &mut self.array_bits, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 20,
                fidl::encoding::WireFormatVersion::V2 => 20,
            };
            fidl::decode!(fidl::encoding::Array<Enum, 5>, &mut self.array_enum, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 40,
                fidl::encoding::WireFormatVersion::V2 => 40,
            };
            fidl::decode!(fidl::encoding::Array<Struct, 5>, &mut self.array_struct, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 48,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            fidl::decode!(fidl::encoding::Array<Table, 5>, &mut self.array_table, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 128,
                fidl::encoding::WireFormatVersion::V2 => 128,
            };
            fidl::decode!(fidl::encoding::Array<Union, 5>, &mut self.array_union, decoder, offset + member_offset, _depth)?;
            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ArrayVectorNested {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 144,
                fidl::encoding::WireFormatVersion::V2 => 144,
            }
        }
    }
    impl fidl::encoding::ValueTypeMarker for ArrayVectorNested {
        type Borrowed<'a> = &'a Self;
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<ArrayVectorNested> for &ArrayVectorNested {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ArrayVectorNested>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<ArrayVectorNested>::encode(
                (
                    <fidl::encoding::UnboundedVector<fidl::encoding::Array<u8, 5>> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_array_uint8),
                    <fidl::encoding::UnboundedVector<fidl::encoding::UnboundedVector<u8>> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_vector_uint8),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            T0: fidl::encoding::Encode<fidl::encoding::UnboundedVector<fidl::encoding::Array<u8, 5>>>,
            T1: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<fidl::encoding::UnboundedVector<u8>>,
            >,
        > fidl::encoding::Encode<ArrayVectorNested> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ArrayVectorNested>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {}
                fidl::encoding::WireFormatVersion::V2 => {}
            };
            // Write the fields.
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 112,
                fidl::encoding::WireFormatVersion::V2 => 112,
            };
            self.0.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 128,
                fidl::encoding::WireFormatVersion::V2 => 128,
            };
            self.1.encode(encoder, offset + member_offset, depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for ArrayVectorNested {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                vector_array_uint8: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<fidl::encoding::Array<u8, 5>>
                ),
                vector_vector_uint8: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<fidl::encoding::UnboundedVector<u8>>
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {}
                fidl::encoding::WireFormatVersion::V2 => {}
            };
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 112,
                fidl::encoding::WireFormatVersion::V2 => 112,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<fidl::encoding::Array<u8, 5>>,
                &mut self.vector_array_uint8,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 128,
                fidl::encoding::WireFormatVersion::V2 => 128,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<fidl::encoding::UnboundedVector<u8>>,
                &mut self.vector_vector_uint8,
                decoder,
                offset + member_offset,
                _depth
            )?;
            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Basic {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 80,
                fidl::encoding::WireFormatVersion::V2 => 80,
            }
        }
    }
    impl fidl::encoding::ValueTypeMarker for Basic {
        type Borrowed<'a> = &'a Self;
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<Basic> for &Basic {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Basic>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<Basic>::encode(
                (
                    <u8 as fidl::encoding::ValueTypeMarker>::borrow(&self.uint8),
                    <u16 as fidl::encoding::ValueTypeMarker>::borrow(&self.uint16),
                    <u32 as fidl::encoding::ValueTypeMarker>::borrow(&self.uint32),
                    <u64 as fidl::encoding::ValueTypeMarker>::borrow(&self.uint64),
                    <i8 as fidl::encoding::ValueTypeMarker>::borrow(&self.int8),
                    <i16 as fidl::encoding::ValueTypeMarker>::borrow(&self.int16),
                    <i32 as fidl::encoding::ValueTypeMarker>::borrow(&self.int32),
                    <i64 as fidl::encoding::ValueTypeMarker>::borrow(&self.int64),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.float32),
                    <f64 as fidl::encoding::ValueTypeMarker>::borrow(&self.float64),
                    <fidl::encoding::UnboundedString as fidl::encoding::ValueTypeMarker>::borrow(&self.string),
                    <fidl::encoding::Optional<fidl::encoding::UnboundedString> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_string),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            T0: fidl::encoding::Encode<u8>,
            T1: fidl::encoding::Encode<u16>,
            T2: fidl::encoding::Encode<u32>,
            T3: fidl::encoding::Encode<u64>,
            T4: fidl::encoding::Encode<i8>,
            T5: fidl::encoding::Encode<i16>,
            T6: fidl::encoding::Encode<i32>,
            T7: fidl::encoding::Encode<i64>,
            T8: fidl::encoding::Encode<f32>,
            T9: fidl::encoding::Encode<f64>,
            T10: fidl::encoding::Encode<fidl::encoding::UnboundedString>,
            T11: fidl::encoding::Encode<fidl::encoding::Optional<fidl::encoding::UnboundedString>>,
        > fidl::encoding::Encode<Basic> for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Basic>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(16);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(32);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                }
                fidl::encoding::WireFormatVersion::V2 => {
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(16);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(32);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                }
            };
            // Write the fields.
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            self.0.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 2,
                fidl::encoding::WireFormatVersion::V2 => 2,
            };
            self.1.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 4,
                fidl::encoding::WireFormatVersion::V2 => 4,
            };
            self.2.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            self.3.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            self.4.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 18,
                fidl::encoding::WireFormatVersion::V2 => 18,
            };
            self.5.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 20,
                fidl::encoding::WireFormatVersion::V2 => 20,
            };
            self.6.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 24,
                fidl::encoding::WireFormatVersion::V2 => 24,
            };
            self.7.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 32,
                fidl::encoding::WireFormatVersion::V2 => 32,
            };
            self.8.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 40,
                fidl::encoding::WireFormatVersion::V2 => 40,
            };
            self.9.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 48,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            self.10.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 64,
                fidl::encoding::WireFormatVersion::V2 => 64,
            };
            self.11.encode(encoder, offset + member_offset, depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for Basic {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                uint8: fidl::new_empty!(u8),
                uint16: fidl::new_empty!(u16),
                uint32: fidl::new_empty!(u32),
                uint64: fidl::new_empty!(u64),
                int8: fidl::new_empty!(i8),
                int16: fidl::new_empty!(i16),
                int32: fidl::new_empty!(i32),
                int64: fidl::new_empty!(i64),
                float32: fidl::new_empty!(f32),
                float64: fidl::new_empty!(f64),
                string: fidl::new_empty!(fidl::encoding::UnboundedString),
                opt_string: fidl::new_empty!(
                    fidl::encoding::Optional<fidl::encoding::UnboundedString>
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(0) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0x000000000000ff00u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 0
                                + ((0x000000000000ff00u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(16) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0x000000000000ff00u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 16
                                + ((0x000000000000ff00u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(32) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 32
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
                fidl::encoding::WireFormatVersion::V2 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(0) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0x000000000000ff00u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 0
                                + ((0x000000000000ff00u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(16) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0x000000000000ff00u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 16
                                + ((0x000000000000ff00u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(32) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffff00000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 32
                                + ((0xffffffff00000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
            };
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            fidl::decode!(u8, &mut self.uint8, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 2,
                fidl::encoding::WireFormatVersion::V2 => 2,
            };
            fidl::decode!(u16, &mut self.uint16, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 4,
                fidl::encoding::WireFormatVersion::V2 => 4,
            };
            fidl::decode!(u32, &mut self.uint32, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            fidl::decode!(u64, &mut self.uint64, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            fidl::decode!(i8, &mut self.int8, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 18,
                fidl::encoding::WireFormatVersion::V2 => 18,
            };
            fidl::decode!(i16, &mut self.int16, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 20,
                fidl::encoding::WireFormatVersion::V2 => 20,
            };
            fidl::decode!(i32, &mut self.int32, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 24,
                fidl::encoding::WireFormatVersion::V2 => 24,
            };
            fidl::decode!(i64, &mut self.int64, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 32,
                fidl::encoding::WireFormatVersion::V2 => 32,
            };
            fidl::decode!(f32, &mut self.float32, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 40,
                fidl::encoding::WireFormatVersion::V2 => 40,
            };
            fidl::decode!(f64, &mut self.float64, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 48,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            fidl::decode!(
                fidl::encoding::UnboundedString,
                &mut self.string,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 64,
                fidl::encoding::WireFormatVersion::V2 => 64,
            };
            fidl::decode!(
                fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                &mut self.opt_string,
                decoder,
                offset + member_offset,
                _depth
            )?;
            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Compound {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 88,
                fidl::encoding::WireFormatVersion::V2 => 72,
            }
        }
    }
    impl fidl::encoding::ValueTypeMarker for Compound {
        type Borrowed<'a> = &'a Self;
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<Compound> for &Compound {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Compound>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<Compound>::encode(
                (
                    <Bits as fidl::encoding::ValueTypeMarker>::borrow(&self.bits),
                    <Enum as fidl::encoding::ValueTypeMarker>::borrow(&self.enum_),
                    <Struct as fidl::encoding::ValueTypeMarker>::borrow(&self.struct_),
                    <Table as fidl::encoding::ValueTypeMarker>::borrow(&self.table),
                    <Union as fidl::encoding::ValueTypeMarker>::borrow(&self.union),
                    <fidl::encoding::Boxed<Struct> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_struct),
                    <fidl::encoding::OptionalUnion<Union> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_union),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            T0: fidl::encoding::Encode<Bits>,
            T1: fidl::encoding::Encode<Enum>,
            T2: fidl::encoding::Encode<Struct>,
            T3: fidl::encoding::Encode<Table>,
            T4: fidl::encoding::Encode<Union>,
            T5: fidl::encoding::Encode<fidl::encoding::Boxed<Struct>>,
            T6: fidl::encoding::Encode<fidl::encoding::OptionalUnion<Union>>,
        > fidl::encoding::Encode<Compound> for (T0, T1, T2, T3, T4, T5, T6)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Compound>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => unsafe {
                    let ptr = encoder.buf.as_mut_ptr().add(offset).offset(8);
                    (ptr as *mut u64).write_unaligned(0);
                },
                fidl::encoding::WireFormatVersion::V2 => unsafe {
                    let ptr = encoder.buf.as_mut_ptr().add(offset).offset(8);
                    (ptr as *mut u64).write_unaligned(0);
                },
            };
            // Write the fields.
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            self.0.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 4,
                fidl::encoding::WireFormatVersion::V2 => 4,
            };
            self.1.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            self.2.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            self.3.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 32,
                fidl::encoding::WireFormatVersion::V2 => 32,
            };
            self.4.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 56,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            self.5.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 64,
                fidl::encoding::WireFormatVersion::V2 => 56,
            };
            self.6.encode(encoder, offset + member_offset, depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for Compound {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                bits: fidl::new_empty!(Bits),
                enum_: fidl::new_empty!(Enum),
                struct_: fidl::new_empty!(Struct),
                table: fidl::new_empty!(Table),
                union: fidl::new_empty!(Union),
                opt_struct: fidl::new_empty!(fidl::encoding::Boxed<Struct>),
                opt_union: fidl::new_empty!(fidl::encoding::OptionalUnion<Union>),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(8) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffffffffff00u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 8
                                + ((0xffffffffffffff00u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
                fidl::encoding::WireFormatVersion::V2 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(8) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffffffffff00u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 8
                                + ((0xffffffffffffff00u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
            };
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            fidl::decode!(Bits, &mut self.bits, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 4,
                fidl::encoding::WireFormatVersion::V2 => 4,
            };
            fidl::decode!(Enum, &mut self.enum_, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            fidl::decode!(Struct, &mut self.struct_, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            fidl::decode!(Table, &mut self.table, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 32,
                fidl::encoding::WireFormatVersion::V2 => 32,
            };
            fidl::decode!(Union, &mut self.union, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 56,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            fidl::decode!(
                fidl::encoding::Boxed<Struct>,
                &mut self.opt_struct,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 64,
                fidl::encoding::WireFormatVersion::V2 => 56,
            };
            fidl::decode!(
                fidl::encoding::OptionalUnion<Union>,
                &mut self.opt_union,
                decoder,
                offset + member_offset,
                _depth
            )?;
            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Resource {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 512,
                fidl::encoding::WireFormatVersion::V2 => 456,
            }
        }
    }
    impl fidl::encoding::ResourceTypeMarker for Resource {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<Resource> for &mut Resource {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Resource>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<Resource>::encode(
                (
                    <fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.handle),
                    <fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vmo),
                    <fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.client_end),
                    <fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.server_end),
                    <ResourceStruct as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.struct_),
                    <ResourceTable as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.table),
                    <ResourceUnion as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.union),
                    <fidl::encoding::Optional<fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.opt_handle),
                    <fidl::encoding::Optional<fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.opt_vmo),
                    <fidl::encoding::Optional<fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.opt_client_end),
                    <fidl::encoding::Optional<fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.opt_server_end),
                    <fidl::encoding::Boxed<ResourceStruct> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.opt_struct),
                    <fidl::encoding::OptionalUnion<ResourceUnion> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.opt_union),
                    <fidl::encoding::Array<fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_handle),
                    <fidl::encoding::Array<fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_vmo),
                    <fidl::encoding::Array<fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_client_end),
                    <fidl::encoding::Array<fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_server_end),
                    <fidl::encoding::Array<ResourceStruct, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_struct),
                    <fidl::encoding::Array<ResourceTable, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_table),
                    <fidl::encoding::Array<ResourceUnion, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_union),
                    <fidl::encoding::UnboundedVector<fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_handle),
                    <fidl::encoding::UnboundedVector<fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_vmo),
                    <fidl::encoding::UnboundedVector<fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_client_end),
                    <fidl::encoding::UnboundedVector<fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_server_end),
                    <fidl::encoding::UnboundedVector<ResourceStruct> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_struct),
                    <fidl::encoding::UnboundedVector<ResourceTable> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_table),
                    <fidl::encoding::UnboundedVector<ResourceUnion> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_union),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            T0: fidl::encoding::Encode<
                fidl::encoding::HandleType<
                    fidl::Handle,
                    { fidl::ObjectType::NONE.into_raw() },
                    2147483648,
                >,
            >,
            T1: fidl::encoding::Encode<
                fidl::encoding::HandleType<
                    fidl::Vmo,
                    { fidl::ObjectType::VMO.into_raw() },
                    2147483648,
                >,
            >,
            T2: fidl::encoding::Encode<
                fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            >,
            T3: fidl::encoding::Encode<
                fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            >,
            T4: fidl::encoding::Encode<ResourceStruct>,
            T5: fidl::encoding::Encode<ResourceTable>,
            T6: fidl::encoding::Encode<ResourceUnion>,
            T7: fidl::encoding::Encode<
                fidl::encoding::Optional<
                    fidl::encoding::HandleType<
                        fidl::Handle,
                        { fidl::ObjectType::NONE.into_raw() },
                        2147483648,
                    >,
                >,
            >,
            T8: fidl::encoding::Encode<
                fidl::encoding::Optional<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                >,
            >,
            T9: fidl::encoding::Encode<
                fidl::encoding::Optional<
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                >,
            >,
            T10: fidl::encoding::Encode<
                fidl::encoding::Optional<
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                >,
            >,
            T11: fidl::encoding::Encode<fidl::encoding::Boxed<ResourceStruct>>,
            T12: fidl::encoding::Encode<fidl::encoding::OptionalUnion<ResourceUnion>>,
            T13: fidl::encoding::Encode<
                fidl::encoding::Array<
                    fidl::encoding::HandleType<
                        fidl::Handle,
                        { fidl::ObjectType::NONE.into_raw() },
                        2147483648,
                    >,
                    5,
                >,
            >,
            T14: fidl::encoding::Encode<
                fidl::encoding::Array<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                    5,
                >,
            >,
            T15: fidl::encoding::Encode<
                fidl::encoding::Array<
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    5,
                >,
            >,
            T16: fidl::encoding::Encode<
                fidl::encoding::Array<
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    5,
                >,
            >,
            T17: fidl::encoding::Encode<fidl::encoding::Array<ResourceStruct, 5>>,
            T18: fidl::encoding::Encode<fidl::encoding::Array<ResourceTable, 5>>,
            T19: fidl::encoding::Encode<fidl::encoding::Array<ResourceUnion, 5>>,
            T20: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<
                    fidl::encoding::HandleType<
                        fidl::Handle,
                        { fidl::ObjectType::NONE.into_raw() },
                        2147483648,
                    >,
                >,
            >,
            T21: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                >,
            >,
            T22: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                >,
            >,
            T23: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                >,
            >,
            T24: fidl::encoding::Encode<fidl::encoding::UnboundedVector<ResourceStruct>>,
            T25: fidl::encoding::Encode<fidl::encoding::UnboundedVector<ResourceTable>>,
            T26: fidl::encoding::Encode<fidl::encoding::UnboundedVector<ResourceUnion>>,
        > fidl::encoding::Encode<Resource>
        for (
            T0,
            T1,
            T2,
            T3,
            T4,
            T5,
            T6,
            T7,
            T8,
            T9,
            T10,
            T11,
            T12,
            T13,
            T14,
            T15,
            T16,
            T17,
            T18,
            T19,
            T20,
            T21,
            T22,
            T23,
            T24,
            T25,
            T26,
        )
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Resource>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(16);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(192);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                }
                fidl::encoding::WireFormatVersion::V2 => {
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(16);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                    unsafe {
                        let ptr = encoder.buf.as_mut_ptr().add(offset).offset(176);
                        (ptr as *mut u64).write_unaligned(0);
                    }
                }
            };
            // Write the fields.
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            self.0.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 4,
                fidl::encoding::WireFormatVersion::V2 => 4,
            };
            self.1.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            self.2.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 12,
                fidl::encoding::WireFormatVersion::V2 => 12,
            };
            self.3.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            self.4.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 24,
                fidl::encoding::WireFormatVersion::V2 => 24,
            };
            self.5.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 40,
                fidl::encoding::WireFormatVersion::V2 => 40,
            };
            self.6.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 64,
                fidl::encoding::WireFormatVersion::V2 => 56,
            };
            self.7.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 68,
                fidl::encoding::WireFormatVersion::V2 => 60,
            };
            self.8.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 72,
                fidl::encoding::WireFormatVersion::V2 => 64,
            };
            self.9.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 76,
                fidl::encoding::WireFormatVersion::V2 => 68,
            };
            self.10.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 80,
                fidl::encoding::WireFormatVersion::V2 => 72,
            };
            self.11.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 88,
                fidl::encoding::WireFormatVersion::V2 => 80,
            };
            self.12.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 112,
                fidl::encoding::WireFormatVersion::V2 => 96,
            };
            self.13.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 132,
                fidl::encoding::WireFormatVersion::V2 => 116,
            };
            self.14.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 152,
                fidl::encoding::WireFormatVersion::V2 => 136,
            };
            self.15.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 172,
                fidl::encoding::WireFormatVersion::V2 => 156,
            };
            self.16.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 192,
                fidl::encoding::WireFormatVersion::V2 => 176,
            };
            self.17.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 200,
                fidl::encoding::WireFormatVersion::V2 => 184,
            };
            self.18.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 280,
                fidl::encoding::WireFormatVersion::V2 => 264,
            };
            self.19.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 400,
                fidl::encoding::WireFormatVersion::V2 => 344,
            };
            self.20.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 416,
                fidl::encoding::WireFormatVersion::V2 => 360,
            };
            self.21.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 432,
                fidl::encoding::WireFormatVersion::V2 => 376,
            };
            self.22.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 448,
                fidl::encoding::WireFormatVersion::V2 => 392,
            };
            self.23.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 464,
                fidl::encoding::WireFormatVersion::V2 => 408,
            };
            self.24.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 480,
                fidl::encoding::WireFormatVersion::V2 => 424,
            };
            self.25.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 496,
                fidl::encoding::WireFormatVersion::V2 => 440,
            };
            self.26.encode(encoder, offset + member_offset, depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for Resource {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                handle: fidl::new_empty!(fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>),
                vmo: fidl::new_empty!(fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>),
                client_end: fidl::new_empty!(
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>
                ),
                server_end: fidl::new_empty!(
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>
                ),
                struct_: fidl::new_empty!(ResourceStruct),
                table: fidl::new_empty!(ResourceTable),
                union: fidl::new_empty!(ResourceUnion),
                opt_handle: fidl::new_empty!(
                    fidl::encoding::Optional<
                        fidl::encoding::HandleType<
                            fidl::Handle,
                            { fidl::ObjectType::NONE.into_raw() },
                            2147483648,
                        >,
                    >
                ),
                opt_vmo: fidl::new_empty!(
                    fidl::encoding::Optional<
                        fidl::encoding::HandleType<
                            fidl::Vmo,
                            { fidl::ObjectType::VMO.into_raw() },
                            2147483648,
                        >,
                    >
                ),
                opt_client_end: fidl::new_empty!(
                    fidl::encoding::Optional<
                        fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    >
                ),
                opt_server_end: fidl::new_empty!(
                    fidl::encoding::Optional<
                        fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    >
                ),
                opt_struct: fidl::new_empty!(fidl::encoding::Boxed<ResourceStruct>),
                opt_union: fidl::new_empty!(fidl::encoding::OptionalUnion<ResourceUnion>),
                array_handle: fidl::new_empty!(
                    fidl::encoding::Array<
                        fidl::encoding::HandleType<
                            fidl::Handle,
                            { fidl::ObjectType::NONE.into_raw() },
                            2147483648,
                        >,
                        5,
                    >
                ),
                array_vmo: fidl::new_empty!(
                    fidl::encoding::Array<
                        fidl::encoding::HandleType<
                            fidl::Vmo,
                            { fidl::ObjectType::VMO.into_raw() },
                            2147483648,
                        >,
                        5,
                    >
                ),
                array_client_end: fidl::new_empty!(
                    fidl::encoding::Array<
                        fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                        5,
                    >
                ),
                array_server_end: fidl::new_empty!(
                    fidl::encoding::Array<
                        fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                        5,
                    >
                ),
                array_struct: fidl::new_empty!(fidl::encoding::Array<ResourceStruct, 5>),
                array_table: fidl::new_empty!(fidl::encoding::Array<ResourceTable, 5>),
                array_union: fidl::new_empty!(fidl::encoding::Array<ResourceUnion, 5>),
                vector_handle: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<
                        fidl::encoding::HandleType<
                            fidl::Handle,
                            { fidl::ObjectType::NONE.into_raw() },
                            2147483648,
                        >,
                    >
                ),
                vector_vmo: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<
                        fidl::encoding::HandleType<
                            fidl::Vmo,
                            { fidl::ObjectType::VMO.into_raw() },
                            2147483648,
                        >,
                    >
                ),
                vector_client_end: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<
                        fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    >
                ),
                vector_server_end: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<
                        fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    >
                ),
                vector_struct: fidl::new_empty!(fidl::encoding::UnboundedVector<ResourceStruct>),
                vector_table: fidl::new_empty!(fidl::encoding::UnboundedVector<ResourceTable>),
                vector_union: fidl::new_empty!(fidl::encoding::UnboundedVector<ResourceUnion>),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(16) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffffffffff00u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 16
                                + ((0xffffffffffffff00u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(192) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffff0000000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 192
                                + ((0xffffff0000000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
                fidl::encoding::WireFormatVersion::V2 => {
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(16) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffffffffffff00u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 16
                                + ((0xffffffffffffff00u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                    let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(176) };
                    let padval = unsafe { (ptr as *const u64).read_unaligned() };
                    let maskedval = padval & 0xffffff0000000000u64;
                    if (maskedval != 0) {
                        return Err(fidl::Error::NonZeroPadding {
                            padding_start: offset
                                + 176
                                + ((0xffffff0000000000u64 as u64).trailing_zeros() / 8) as usize,
                        });
                    }
                }
            };
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            fidl::decode!(fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>, &mut self.handle, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 4,
                fidl::encoding::WireFormatVersion::V2 => 4,
            };
            fidl::decode!(fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>, &mut self.vmo, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            fidl::decode!(
                fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                &mut self.client_end,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 12,
                fidl::encoding::WireFormatVersion::V2 => 12,
            };
            fidl::decode!(
                fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                &mut self.server_end,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            fidl::decode!(
                ResourceStruct,
                &mut self.struct_,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 24,
                fidl::encoding::WireFormatVersion::V2 => 24,
            };
            fidl::decode!(ResourceTable, &mut self.table, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 40,
                fidl::encoding::WireFormatVersion::V2 => 40,
            };
            fidl::decode!(ResourceUnion, &mut self.union, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 64,
                fidl::encoding::WireFormatVersion::V2 => 56,
            };
            fidl::decode!(
                fidl::encoding::Optional<
                    fidl::encoding::HandleType<
                        fidl::Handle,
                        { fidl::ObjectType::NONE.into_raw() },
                        2147483648,
                    >,
                >,
                &mut self.opt_handle,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 68,
                fidl::encoding::WireFormatVersion::V2 => 60,
            };
            fidl::decode!(
                fidl::encoding::Optional<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                >,
                &mut self.opt_vmo,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 72,
                fidl::encoding::WireFormatVersion::V2 => 64,
            };
            fidl::decode!(
                fidl::encoding::Optional<
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                >,
                &mut self.opt_client_end,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 76,
                fidl::encoding::WireFormatVersion::V2 => 68,
            };
            fidl::decode!(
                fidl::encoding::Optional<
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                >,
                &mut self.opt_server_end,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 80,
                fidl::encoding::WireFormatVersion::V2 => 72,
            };
            fidl::decode!(
                fidl::encoding::Boxed<ResourceStruct>,
                &mut self.opt_struct,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 88,
                fidl::encoding::WireFormatVersion::V2 => 80,
            };
            fidl::decode!(
                fidl::encoding::OptionalUnion<ResourceUnion>,
                &mut self.opt_union,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 112,
                fidl::encoding::WireFormatVersion::V2 => 96,
            };
            fidl::decode!(
                fidl::encoding::Array<
                    fidl::encoding::HandleType<
                        fidl::Handle,
                        { fidl::ObjectType::NONE.into_raw() },
                        2147483648,
                    >,
                    5,
                >,
                &mut self.array_handle,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 132,
                fidl::encoding::WireFormatVersion::V2 => 116,
            };
            fidl::decode!(
                fidl::encoding::Array<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                    5,
                >,
                &mut self.array_vmo,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 152,
                fidl::encoding::WireFormatVersion::V2 => 136,
            };
            fidl::decode!(
                fidl::encoding::Array<
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    5,
                >,
                &mut self.array_client_end,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 172,
                fidl::encoding::WireFormatVersion::V2 => 156,
            };
            fidl::decode!(
                fidl::encoding::Array<
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    5,
                >,
                &mut self.array_server_end,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 192,
                fidl::encoding::WireFormatVersion::V2 => 176,
            };
            fidl::decode!(fidl::encoding::Array<ResourceStruct, 5>, &mut self.array_struct, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 200,
                fidl::encoding::WireFormatVersion::V2 => 184,
            };
            fidl::decode!(fidl::encoding::Array<ResourceTable, 5>, &mut self.array_table, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 280,
                fidl::encoding::WireFormatVersion::V2 => 264,
            };
            fidl::decode!(fidl::encoding::Array<ResourceUnion, 5>, &mut self.array_union, decoder, offset + member_offset, _depth)?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 400,
                fidl::encoding::WireFormatVersion::V2 => 344,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<
                    fidl::encoding::HandleType<
                        fidl::Handle,
                        { fidl::ObjectType::NONE.into_raw() },
                        2147483648,
                    >,
                >,
                &mut self.vector_handle,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 416,
                fidl::encoding::WireFormatVersion::V2 => 360,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                >,
                &mut self.vector_vmo,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 432,
                fidl::encoding::WireFormatVersion::V2 => 376,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                >,
                &mut self.vector_client_end,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 448,
                fidl::encoding::WireFormatVersion::V2 => 392,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                >,
                &mut self.vector_server_end,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 464,
                fidl::encoding::WireFormatVersion::V2 => 408,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<ResourceStruct>,
                &mut self.vector_struct,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 480,
                fidl::encoding::WireFormatVersion::V2 => 424,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<ResourceTable>,
                &mut self.vector_table,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 496,
                fidl::encoding::WireFormatVersion::V2 => 440,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<ResourceUnion>,
                &mut self.vector_union,
                decoder,
                offset + member_offset,
                _depth
            )?;
            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ResourceStruct {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 1,
                fidl::encoding::WireFormatVersion::V2 => 1,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 1,
                fidl::encoding::WireFormatVersion::V2 => 1,
            }
        }
    }
    impl fidl::encoding::ResourceTypeMarker for ResourceStruct {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<ResourceStruct> for &mut ResourceStruct {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ResourceStruct>(offset);
            encoder.write_num(0u8, offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for ResourceStruct {
        #[inline(always)]
        fn new_empty() -> Self {
            Self
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            match decoder.read_num::<u8>(offset) {
                0 => Ok(()),
                _ => Err(fidl::Error::Invalid),
            }
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Struct {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 1,
                fidl::encoding::WireFormatVersion::V2 => 1,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 1,
                fidl::encoding::WireFormatVersion::V2 => 1,
            }
        }
    }
    impl fidl::encoding::ValueTypeMarker for Struct {
        type Borrowed<'a> = &'a Self;
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<Struct> for &Struct {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Struct>(offset);
            encoder.write_num(0u8, offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for Struct {
        #[inline(always)]
        fn new_empty() -> Self {
            Self
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            match decoder.read_num::<u8>(offset) {
                0 => Ok(()),
                _ => Err(fidl::Error::Invalid),
            }
        }
    }

    unsafe impl fidl::encoding::TypeMarker for VectorBasic {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 192,
                fidl::encoding::WireFormatVersion::V2 => 192,
            }
        }
    }
    impl fidl::encoding::ValueTypeMarker for VectorBasic {
        type Borrowed<'a> = &'a Self;
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<VectorBasic> for &VectorBasic {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<VectorBasic>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<VectorBasic>::encode(
                (
                    <fidl::encoding::UnboundedVector<u8> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_uint8),
                    <fidl::encoding::UnboundedVector<u16> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_uint16),
                    <fidl::encoding::UnboundedVector<u32> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_uint32),
                    <fidl::encoding::UnboundedVector<u64> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_uint64),
                    <fidl::encoding::UnboundedVector<i8> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_int8),
                    <fidl::encoding::UnboundedVector<i16> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_int16),
                    <fidl::encoding::UnboundedVector<i32> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_int32),
                    <fidl::encoding::UnboundedVector<i64> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_int64),
                    <fidl::encoding::UnboundedVector<f32> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_float32),
                    <fidl::encoding::UnboundedVector<f64> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_float64),
                    <fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_string),
                    <fidl::encoding::UnboundedVector<fidl::encoding::Optional<fidl::encoding::UnboundedString>> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_opt_string),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            T0: fidl::encoding::Encode<fidl::encoding::UnboundedVector<u8>>,
            T1: fidl::encoding::Encode<fidl::encoding::UnboundedVector<u16>>,
            T2: fidl::encoding::Encode<fidl::encoding::UnboundedVector<u32>>,
            T3: fidl::encoding::Encode<fidl::encoding::UnboundedVector<u64>>,
            T4: fidl::encoding::Encode<fidl::encoding::UnboundedVector<i8>>,
            T5: fidl::encoding::Encode<fidl::encoding::UnboundedVector<i16>>,
            T6: fidl::encoding::Encode<fidl::encoding::UnboundedVector<i32>>,
            T7: fidl::encoding::Encode<fidl::encoding::UnboundedVector<i64>>,
            T8: fidl::encoding::Encode<fidl::encoding::UnboundedVector<f32>>,
            T9: fidl::encoding::Encode<fidl::encoding::UnboundedVector<f64>>,
            T10: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>,
            >,
            T11: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                >,
            >,
        > fidl::encoding::Encode<VectorBasic>
        for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<VectorBasic>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {}
                fidl::encoding::WireFormatVersion::V2 => {}
            };
            // Write the fields.
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            self.0.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            self.1.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 32,
                fidl::encoding::WireFormatVersion::V2 => 32,
            };
            self.2.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 48,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            self.3.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 64,
                fidl::encoding::WireFormatVersion::V2 => 64,
            };
            self.4.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 80,
                fidl::encoding::WireFormatVersion::V2 => 80,
            };
            self.5.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 96,
                fidl::encoding::WireFormatVersion::V2 => 96,
            };
            self.6.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 112,
                fidl::encoding::WireFormatVersion::V2 => 112,
            };
            self.7.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 128,
                fidl::encoding::WireFormatVersion::V2 => 128,
            };
            self.8.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 144,
                fidl::encoding::WireFormatVersion::V2 => 144,
            };
            self.9.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 160,
                fidl::encoding::WireFormatVersion::V2 => 160,
            };
            self.10.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 176,
                fidl::encoding::WireFormatVersion::V2 => 176,
            };
            self.11.encode(encoder, offset + member_offset, depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for VectorBasic {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                vector_uint8: fidl::new_empty!(fidl::encoding::UnboundedVector<u8>),
                vector_uint16: fidl::new_empty!(fidl::encoding::UnboundedVector<u16>),
                vector_uint32: fidl::new_empty!(fidl::encoding::UnboundedVector<u32>),
                vector_uint64: fidl::new_empty!(fidl::encoding::UnboundedVector<u64>),
                vector_int8: fidl::new_empty!(fidl::encoding::UnboundedVector<i8>),
                vector_int16: fidl::new_empty!(fidl::encoding::UnboundedVector<i16>),
                vector_int32: fidl::new_empty!(fidl::encoding::UnboundedVector<i32>),
                vector_int64: fidl::new_empty!(fidl::encoding::UnboundedVector<i64>),
                vector_float32: fidl::new_empty!(fidl::encoding::UnboundedVector<f32>),
                vector_float64: fidl::new_empty!(fidl::encoding::UnboundedVector<f64>),
                vector_string: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>
                ),
                vector_opt_string: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<
                        fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                    >
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {}
                fidl::encoding::WireFormatVersion::V2 => {}
            };
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<u8>,
                &mut self.vector_uint8,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<u16>,
                &mut self.vector_uint16,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 32,
                fidl::encoding::WireFormatVersion::V2 => 32,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<u32>,
                &mut self.vector_uint32,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 48,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<u64>,
                &mut self.vector_uint64,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 64,
                fidl::encoding::WireFormatVersion::V2 => 64,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<i8>,
                &mut self.vector_int8,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 80,
                fidl::encoding::WireFormatVersion::V2 => 80,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<i16>,
                &mut self.vector_int16,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 96,
                fidl::encoding::WireFormatVersion::V2 => 96,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<i32>,
                &mut self.vector_int32,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 112,
                fidl::encoding::WireFormatVersion::V2 => 112,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<i64>,
                &mut self.vector_int64,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 128,
                fidl::encoding::WireFormatVersion::V2 => 128,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<f32>,
                &mut self.vector_float32,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 144,
                fidl::encoding::WireFormatVersion::V2 => 144,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<f64>,
                &mut self.vector_float64,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 160,
                fidl::encoding::WireFormatVersion::V2 => 160,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>,
                &mut self.vector_string,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 176,
                fidl::encoding::WireFormatVersion::V2 => 176,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                >,
                &mut self.vector_opt_string,
                decoder,
                offset + member_offset,
                _depth
            )?;
            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for VectorCompound {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 112,
                fidl::encoding::WireFormatVersion::V2 => 112,
            }
        }
    }
    impl fidl::encoding::ValueTypeMarker for VectorCompound {
        type Borrowed<'a> = &'a Self;
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<VectorCompound> for &VectorCompound {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<VectorCompound>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<VectorCompound>::encode(
                (
                    <fidl::encoding::UnboundedVector<Bits> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_bits),
                    <fidl::encoding::UnboundedVector<Enum> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_enum),
                    <fidl::encoding::UnboundedVector<Struct> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_struct),
                    <fidl::encoding::UnboundedVector<Table> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_table),
                    <fidl::encoding::UnboundedVector<Union> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_union),
                    <fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_opt_struct),
                    <fidl::encoding::UnboundedVector<fidl::encoding::OptionalUnion<Union>> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_opt_union),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            T0: fidl::encoding::Encode<fidl::encoding::UnboundedVector<Bits>>,
            T1: fidl::encoding::Encode<fidl::encoding::UnboundedVector<Enum>>,
            T2: fidl::encoding::Encode<fidl::encoding::UnboundedVector<Struct>>,
            T3: fidl::encoding::Encode<fidl::encoding::UnboundedVector<Table>>,
            T4: fidl::encoding::Encode<fidl::encoding::UnboundedVector<Union>>,
            T5: fidl::encoding::Encode<fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>>,
            T6: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<fidl::encoding::OptionalUnion<Union>>,
            >,
        > fidl::encoding::Encode<VectorCompound> for (T0, T1, T2, T3, T4, T5, T6)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<VectorCompound>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {}
                fidl::encoding::WireFormatVersion::V2 => {}
            };
            // Write the fields.
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            self.0.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            self.1.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 32,
                fidl::encoding::WireFormatVersion::V2 => 32,
            };
            self.2.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 48,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            self.3.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 64,
                fidl::encoding::WireFormatVersion::V2 => 64,
            };
            self.4.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 80,
                fidl::encoding::WireFormatVersion::V2 => 80,
            };
            self.5.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 96,
                fidl::encoding::WireFormatVersion::V2 => 96,
            };
            self.6.encode(encoder, offset + member_offset, depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for VectorCompound {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                vector_bits: fidl::new_empty!(fidl::encoding::UnboundedVector<Bits>),
                vector_enum: fidl::new_empty!(fidl::encoding::UnboundedVector<Enum>),
                vector_struct: fidl::new_empty!(fidl::encoding::UnboundedVector<Struct>),
                vector_table: fidl::new_empty!(fidl::encoding::UnboundedVector<Table>),
                vector_union: fidl::new_empty!(fidl::encoding::UnboundedVector<Union>),
                vector_opt_struct: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>
                ),
                vector_opt_union: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<fidl::encoding::OptionalUnion<Union>>
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {}
                fidl::encoding::WireFormatVersion::V2 => {}
            };
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<Bits>,
                &mut self.vector_bits,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<Enum>,
                &mut self.vector_enum,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 32,
                fidl::encoding::WireFormatVersion::V2 => 32,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<Struct>,
                &mut self.vector_struct,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 48,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<Table>,
                &mut self.vector_table,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 64,
                fidl::encoding::WireFormatVersion::V2 => 64,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<Union>,
                &mut self.vector_union,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 80,
                fidl::encoding::WireFormatVersion::V2 => 80,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>,
                &mut self.vector_opt_struct,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 96,
                fidl::encoding::WireFormatVersion::V2 => 96,
            };
            fidl::decode!(
                fidl::encoding::UnboundedVector<fidl::encoding::OptionalUnion<Union>>,
                &mut self.vector_opt_union,
                decoder,
                offset + member_offset,
                _depth
            )?;
            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for VectorOptional {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 8,
                fidl::encoding::WireFormatVersion::V2 => 8,
            }
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 64,
                fidl::encoding::WireFormatVersion::V2 => 64,
            }
        }
    }
    impl fidl::encoding::ValueTypeMarker for VectorOptional {
        type Borrowed<'a> = &'a Self;
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<VectorOptional> for &VectorOptional {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<VectorOptional>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<VectorOptional>::encode(
                (
                    <fidl::encoding::Optional<fidl::encoding::UnboundedVector<u8>> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_vector_uint8),
                    <fidl::encoding::Optional<fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_vector_string),
                    <fidl::encoding::Optional<fidl::encoding::UnboundedVector<Struct>> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_vector_struct),
                    <fidl::encoding::Optional<fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_vector_opt_struct),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            T0: fidl::encoding::Encode<fidl::encoding::Optional<fidl::encoding::UnboundedVector<u8>>>,
            T1: fidl::encoding::Encode<
                fidl::encoding::Optional<
                    fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>,
                >,
            >,
            T2: fidl::encoding::Encode<
                fidl::encoding::Optional<fidl::encoding::UnboundedVector<Struct>>,
            >,
            T3: fidl::encoding::Encode<
                fidl::encoding::Optional<
                    fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>,
                >,
            >,
        > fidl::encoding::Encode<VectorOptional> for (T0, T1, T2, T3)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<VectorOptional>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {}
                fidl::encoding::WireFormatVersion::V2 => {}
            };
            // Write the fields.
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            self.0.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            self.1.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 32,
                fidl::encoding::WireFormatVersion::V2 => 32,
            };
            self.2.encode(encoder, offset + member_offset, depth)?;
            let member_offset = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 48,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            self.3.encode(encoder, offset + member_offset, depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for VectorOptional {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                opt_vector_uint8: fidl::new_empty!(
                    fidl::encoding::Optional<fidl::encoding::UnboundedVector<u8>>
                ),
                opt_vector_string: fidl::new_empty!(
                    fidl::encoding::Optional<
                        fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>,
                    >
                ),
                opt_vector_struct: fidl::new_empty!(
                    fidl::encoding::Optional<fidl::encoding::UnboundedVector<Struct>>
                ),
                opt_vector_opt_struct: fidl::new_empty!(
                    fidl::encoding::Optional<
                        fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>,
                    >
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => {}
                fidl::encoding::WireFormatVersion::V2 => {}
            };
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 0,
                fidl::encoding::WireFormatVersion::V2 => 0,
            };
            fidl::decode!(
                fidl::encoding::Optional<fidl::encoding::UnboundedVector<u8>>,
                &mut self.opt_vector_uint8,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 16,
            };
            fidl::decode!(
                fidl::encoding::Optional<
                    fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>,
                >,
                &mut self.opt_vector_string,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 32,
                fidl::encoding::WireFormatVersion::V2 => 32,
            };
            fidl::decode!(
                fidl::encoding::Optional<fidl::encoding::UnboundedVector<Struct>>,
                &mut self.opt_vector_struct,
                decoder,
                offset + member_offset,
                _depth
            )?;
            let member_offset = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 48,
                fidl::encoding::WireFormatVersion::V2 => 48,
            };
            fidl::decode!(
                fidl::encoding::Optional<
                    fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>,
                >,
                &mut self.opt_vector_opt_struct,
                decoder,
                offset + member_offset,
                _depth
            )?;
            Ok(())
        }
    }

    impl ResourceTable {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            0
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ResourceTable {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }
    impl fidl::encoding::ResourceTypeMarker for ResourceTable {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<ResourceTable> for &mut ResourceTable {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ResourceTable>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // write_out_of_line must not be called with a zero-sized out-of-line block.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            let bytes_len = (max_ordinal as usize) * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;

            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for ResourceTable {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            depth.increment()?;
            let envelope_size = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl Table {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            0
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Table {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }
    impl fidl::encoding::ValueTypeMarker for Table {
        type Borrowed<'a> = &'a Self;
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<Table> for &Table {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Table>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // write_out_of_line must not be called with a zero-sized out-of-line block.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = match encoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            let bytes_len = (max_ordinal as usize) * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;

            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for Table {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            depth.increment()?;
            let envelope_size = match decoder.context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 16,
                fidl::encoding::WireFormatVersion::V2 => 8,
            };
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ResourceUnion {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 24,
                fidl::encoding::WireFormatVersion::V2 => 16,
            }
        }
    }
    impl fidl::encoding::ResourceTypeMarker for ResourceUnion {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<ResourceUnion> for &mut ResourceUnion {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ResourceUnion>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                ResourceUnion::B(ref val) => fidl::encoding::encode_in_envelope::<bool>(
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder,
                    offset + 8,
                    _depth,
                ),
                #[allow(deprecated)]
                ResourceUnion::__Unknown { .. } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl fidl::encoding::Decode<Self> for ResourceUnion {
        #[inline(always)]
        fn new_empty() -> Self {
            #[allow(deprecated)]
            Self::__Unknown { ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <bool as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if let fidl::encoding::WireFormatVersion::V2 = decoder.context.wire_format_version {
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let ResourceUnion::B(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = ResourceUnion::B(fidl::new_empty!(bool));
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let ResourceUnion::B(ref mut val) = self {
                        fidl::decode!(bool, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = ResourceUnion::__Unknown { ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Union {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(context: fidl::encoding::Context) -> usize {
            match context.wire_format_version {
                fidl::encoding::WireFormatVersion::V1 => 24,
                fidl::encoding::WireFormatVersion::V2 => 16,
            }
        }
    }
    impl fidl::encoding::ValueTypeMarker for Union {
        type Borrowed<'a> = &'a Self;
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::Encode<Union> for &Union {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Union>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                Union::B(ref val) => fidl::encoding::encode_in_envelope::<bool>(
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder,
                    offset + 8,
                    _depth,
                ),
                #[allow(deprecated)]
                Union::__Unknown { .. } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl fidl::encoding::Decode<Self> for Union {
        #[inline(always)]
        fn new_empty() -> Self {
            #[allow(deprecated)]
            Self::__Unknown { ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <bool as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if let fidl::encoding::WireFormatVersion::V2 = decoder.context.wire_format_version {
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let Union::B(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = Union::B(fidl::new_empty!(bool));
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let Union::B(ref mut val) = self {
                        fidl::decode!(bool, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = Union::__Unknown { ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }
}
