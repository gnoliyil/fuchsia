// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

#![allow(
    unused_parens, // one-element-tuple-case is not a tuple
    unused_mut, // not all args require mutation, but many do
    nonstandard_style, // auto-caps does its best, but is not always successful
)]
#![recursion_limit = "512"]

#[cfg(target_os = "fuchsia")]
#[allow(unused_imports)]
use fuchsia_zircon as zx;

#[allow(unused_imports)]
use {
    bitflags::bitflags,
    fidl::{
        client::QueryResponseFut,
        endpoints::{ControlHandle as _, Responder as _},
        fidl_bits, fidl_enum, fidl_struct, fidl_table, fidl_union,
    },
    fuchsia_zircon_status as zx_status,
    futures::future::{self, MaybeDone, TryFutureExt},
};

bitflags! {
    #[derive(Default)]
    pub struct Bits: u32 {
        const VAL = 1;
    }
}

impl Bits {
    #[inline(always)]
    pub fn from_bits_allow_unknown(bits: u32) -> Self {
        unsafe { Self::from_bits_unchecked(bits) }
    }

    #[inline(always)]
    pub fn has_unknown_bits(&self) -> bool {
        self.get_unknown_bits() != 0
    }

    #[inline(always)]
    pub fn get_unknown_bits(&self) -> u32 {
        self.bits & !Self::all().bits
    }
}

fidl_bits! {
    name: Bits,
    prim_ty: u32,
    flexible: true,
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[non_exhaustive]
pub enum Enum {
    Val,
    #[deprecated = "Use `Enum::unknown()` to construct and `EnumUnknown!()` to exhaustively match."]
    #[doc(hidden)]
    __Unknown(u32),
}
/// Pattern that matches an unknown `Enum` member.
#[macro_export]
macro_rules! EnumUnknown {
    () => {
        _
    };
}

impl Enum {
    #[inline]
    pub fn from_primitive(prim: u32) -> Option<Self> {
        match prim {
            1 => Some(Self::Val),
            _ => None,
        }
    }

    #[inline]
    pub fn from_primitive_allow_unknown(prim: u32) -> Self {
        match prim {
            1 => Self::Val,
            #[allow(deprecated)]
            x => Self::__Unknown(x),
        }
    }

    #[inline]
    pub fn unknown() -> Self {
        #[allow(deprecated)]
        Self::__Unknown(0xffffffff)
    }

    #[inline]
    pub const fn into_primitive(self) -> u32 {
        match self {
            Self::Val => 1,
            #[allow(deprecated)]
            Self::__Unknown(x) => x,
        }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            #[allow(deprecated)]
            Self::__Unknown(_) => true,
            _ => false,
        }
    }
}

fidl_enum! {
    name: Enum,
    prim_ty: u32,
    flexible: true,
}

#[derive(Debug)]
pub enum ResourceUnion {
    B(bool),
    #[deprecated = "Use `ResourceUnion::unknown()` to construct and `ResourceUnionUnknown!()` to exhaustively match."]
    #[doc(hidden)]
    #[non_exhaustive]
    __Unknown {
        ordinal: u64,
    },
}
/// Pattern that matches an unknown `ResourceUnion` member.
#[macro_export]
macro_rules! ResourceUnionUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for ResourceUnion {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::B(x), Self::B(y)) => *x == *y,
            _ => false,
        }
    }
}

impl ResourceUnion {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::B(_) => 1,
            #[allow(deprecated)]
            Self::__Unknown { ordinal } => ordinal,
        }
    }
    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        #[allow(deprecated)]
        Self::__Unknown { ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            #[allow(deprecated)]
            Self::__Unknown { .. } => true,
            _ => false,
        }
    }
}
impl fidl::Standalone for ResourceUnion {}

fidl_union! {
    name: ResourceUnion,
    resource: true,
    members: [
        B {
            ty: bool,
            ordinal: 1,
        },
    ],
    unknown_member: __Unknown,
}

#[derive(Debug, Clone)]
pub enum Union {
    B(bool),
    #[deprecated = "Use `Union::unknown()` to construct and `UnionUnknown!()` to exhaustively match."]
    #[doc(hidden)]
    #[non_exhaustive]
    __Unknown {
        ordinal: u64,
    },
}
/// Pattern that matches an unknown `Union` member.
#[macro_export]
macro_rules! UnionUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for Union {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::B(x), Self::B(y)) => *x == *y,
            _ => false,
        }
    }
}

impl Union {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::B(_) => 1,
            #[allow(deprecated)]
            Self::__Unknown { ordinal } => ordinal,
        }
    }
    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        #[allow(deprecated)]
        Self::__Unknown { ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            #[allow(deprecated)]
            Self::__Unknown { .. } => true,
            _ => false,
        }
    }
}
impl fidl::Persistable for Union {}

fidl_union! {
    name: Union,
    members: [
        B {
            ty: bool,
            ordinal: 1,
        },
    ],
    unknown_member: __Unknown,
}

#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct ArrayBasic {
    pub array_uint8: [u8; 5],
    pub array_uint16: [u16; 5],
    pub array_uint32: [u32; 5],
    pub array_uint64: [u64; 5],
    pub array_int8: [i8; 5],
    pub array_int16: [i16; 5],
    pub array_int32: [i32; 5],
    pub array_int64: [i64; 5],
    pub array_float32: [f32; 5],
    pub array_float64: [f64; 5],
    pub array_string: [String; 5],
    pub array_opt_string: [Option<String>; 5],
}
impl fidl::Persistable for ArrayBasic {}

fidl_struct! {
    name: ArrayBasic,
    members: [
        array_uint8 {
            ty: fidl::encoding::Array<u8, 5>,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        array_uint16 {
            ty: fidl::encoding::Array<u16, 5>,
            index: 1,
            typevar: T1,
            offset_v1: 6,
            offset_v2: 6,
        },
        array_uint32 {
            ty: fidl::encoding::Array<u32, 5>,
            index: 2,
            typevar: T2,
            offset_v1: 16,
            offset_v2: 16,
        },
        array_uint64 {
            ty: fidl::encoding::Array<u64, 5>,
            index: 3,
            typevar: T3,
            offset_v1: 40,
            offset_v2: 40,
        },
        array_int8 {
            ty: fidl::encoding::Array<i8, 5>,
            index: 4,
            typevar: T4,
            offset_v1: 80,
            offset_v2: 80,
        },
        array_int16 {
            ty: fidl::encoding::Array<i16, 5>,
            index: 5,
            typevar: T5,
            offset_v1: 86,
            offset_v2: 86,
        },
        array_int32 {
            ty: fidl::encoding::Array<i32, 5>,
            index: 6,
            typevar: T6,
            offset_v1: 96,
            offset_v2: 96,
        },
        array_int64 {
            ty: fidl::encoding::Array<i64, 5>,
            index: 7,
            typevar: T7,
            offset_v1: 120,
            offset_v2: 120,
        },
        array_float32 {
            ty: fidl::encoding::Array<f32, 5>,
            index: 8,
            typevar: T8,
            offset_v1: 160,
            offset_v2: 160,
        },
        array_float64 {
            ty: fidl::encoding::Array<f64, 5>,
            index: 9,
            typevar: T9,
            offset_v1: 184,
            offset_v2: 184,
        },
        array_string {
            ty: fidl::encoding::Array<fidl::encoding::UnboundedString, 5>,
            index: 10,
            typevar: T10,
            offset_v1: 224,
            offset_v2: 224,
        },
        array_opt_string {
            ty: fidl::encoding::Array<fidl::encoding::Optional<fidl::encoding::UnboundedString>, 5>,
            index: 11,
            typevar: T11,
            offset_v1: 304,
            offset_v2: 304,
        },
    ],
    padding_v1: [
        {
            ty: u64,
            offset: 0,
            mask: 0x0000ff0000000000u64,
        },
        {
            ty: u64,
            offset: 32,
            mask: 0xffffffff00000000u64,
        },
        {
            ty: u64,
            offset: 80,
            mask: 0x0000ff0000000000u64,
        },
        {
            ty: u64,
            offset: 112,
            mask: 0xffffffff00000000u64,
        },
        {
            ty: u64,
            offset: 176,
            mask: 0xffffffff00000000u64,
        },
    ],
    padding_v2: [
        {
            ty: u64,
            offset: 0,
            mask: 0x0000ff0000000000u64,
        },
        {
            ty: u64,
            offset: 32,
            mask: 0xffffffff00000000u64,
        },
        {
            ty: u64,
            offset: 80,
            mask: 0x0000ff0000000000u64,
        },
        {
            ty: u64,
            offset: 112,
            mask: 0xffffffff00000000u64,
        },
        {
            ty: u64,
            offset: 176,
            mask: 0xffffffff00000000u64,
        },
    ],
    size_v1: 384,
    size_v2: 384,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Clone, PartialEq)]
pub struct ArrayCompound {
    pub array_bits: [Bits; 5],
    pub array_enum: [Enum; 5],
    pub array_struct: [Struct; 5],
    pub array_table: [Table; 5],
    pub array_union: [Union; 5],
}
impl fidl::Persistable for ArrayCompound {}

fidl_struct! {
    name: ArrayCompound,
    members: [
        array_bits {
            ty: fidl::encoding::Array<Bits, 5>,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        array_enum {
            ty: fidl::encoding::Array<Enum, 5>,
            index: 1,
            typevar: T1,
            offset_v1: 20,
            offset_v2: 20,
        },
        array_struct {
            ty: fidl::encoding::Array<Struct, 5>,
            index: 2,
            typevar: T2,
            offset_v1: 40,
            offset_v2: 40,
        },
        array_table {
            ty: fidl::encoding::Array<Table, 5>,
            index: 3,
            typevar: T3,
            offset_v1: 48,
            offset_v2: 48,
        },
        array_union {
            ty: fidl::encoding::Array<Union, 5>,
            index: 4,
            typevar: T4,
            offset_v1: 128,
            offset_v2: 128,
        },
    ],
    padding_v1: [
        {
            ty: u64,
            offset: 40,
            mask: 0xffffff0000000000u64,
        },
    ],
    padding_v2: [
        {
            ty: u64,
            offset: 40,
            mask: 0xffffff0000000000u64,
        },
    ],
    size_v1: 408,
    size_v2: 328,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ArrayVectorNested {
    pub vector_array_uint8: Vec<[u8; 5]>,
    pub vector_vector_uint8: Vec<Vec<u8>>,
}
impl fidl::Persistable for ArrayVectorNested {}

fidl_struct! {
    name: ArrayVectorNested,
    members: [
        vector_array_uint8 {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::Array<u8, 5>>,
            index: 0,
            typevar: T0,
            offset_v1: 112,
            offset_v2: 112,
        },
        vector_vector_uint8 {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::UnboundedVector<u8>>,
            index: 1,
            typevar: T1,
            offset_v1: 128,
            offset_v2: 128,
        },
    ],
    padding_v1: [
    ],
    padding_v2: [
    ],
    size_v1: 144,
    size_v2: 144,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Basic {
    pub uint8: u8,
    pub uint16: u16,
    pub uint32: u32,
    pub uint64: u64,
    pub int8: i8,
    pub int16: i16,
    pub int32: i32,
    pub int64: i64,
    pub float32: f32,
    pub float64: f64,
    pub string: String,
    pub opt_string: Option<String>,
}
impl fidl::Persistable for Basic {}

fidl_struct! {
    name: Basic,
    members: [
        uint8 {
            ty: u8,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        uint16 {
            ty: u16,
            index: 1,
            typevar: T1,
            offset_v1: 2,
            offset_v2: 2,
        },
        uint32 {
            ty: u32,
            index: 2,
            typevar: T2,
            offset_v1: 4,
            offset_v2: 4,
        },
        uint64 {
            ty: u64,
            index: 3,
            typevar: T3,
            offset_v1: 8,
            offset_v2: 8,
        },
        int8 {
            ty: i8,
            index: 4,
            typevar: T4,
            offset_v1: 16,
            offset_v2: 16,
        },
        int16 {
            ty: i16,
            index: 5,
            typevar: T5,
            offset_v1: 18,
            offset_v2: 18,
        },
        int32 {
            ty: i32,
            index: 6,
            typevar: T6,
            offset_v1: 20,
            offset_v2: 20,
        },
        int64 {
            ty: i64,
            index: 7,
            typevar: T7,
            offset_v1: 24,
            offset_v2: 24,
        },
        float32 {
            ty: f32,
            index: 8,
            typevar: T8,
            offset_v1: 32,
            offset_v2: 32,
        },
        float64 {
            ty: f64,
            index: 9,
            typevar: T9,
            offset_v1: 40,
            offset_v2: 40,
        },
        string {
            ty: fidl::encoding::UnboundedString,
            index: 10,
            typevar: T10,
            offset_v1: 48,
            offset_v2: 48,
        },
        opt_string {
            ty: fidl::encoding::Optional<fidl::encoding::UnboundedString>,
            index: 11,
            typevar: T11,
            offset_v1: 64,
            offset_v2: 64,
        },
    ],
    padding_v1: [
        {
            ty: u64,
            offset: 0,
            mask: 0x000000000000ff00u64,
        },
        {
            ty: u64,
            offset: 16,
            mask: 0x000000000000ff00u64,
        },
        {
            ty: u64,
            offset: 32,
            mask: 0xffffffff00000000u64,
        },
    ],
    padding_v2: [
        {
            ty: u64,
            offset: 0,
            mask: 0x000000000000ff00u64,
        },
        {
            ty: u64,
            offset: 16,
            mask: 0x000000000000ff00u64,
        },
        {
            ty: u64,
            offset: 32,
            mask: 0xffffffff00000000u64,
        },
    ],
    size_v1: 80,
    size_v2: 80,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Compound {
    pub bits: Bits,
    pub enum_: Enum,
    pub struct_: Struct,
    pub table: Table,
    pub union: Union,
    pub opt_struct: Option<Box<Struct>>,
    pub opt_union: Option<Box<Union>>,
}
impl fidl::Persistable for Compound {}

fidl_struct! {
    name: Compound,
    members: [
        bits {
            ty: Bits,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        enum_ {
            ty: Enum,
            index: 1,
            typevar: T1,
            offset_v1: 4,
            offset_v2: 4,
        },
        struct_ {
            ty: Struct,
            index: 2,
            typevar: T2,
            offset_v1: 8,
            offset_v2: 8,
        },
        table {
            ty: Table,
            index: 3,
            typevar: T3,
            offset_v1: 16,
            offset_v2: 16,
        },
        union {
            ty: Union,
            index: 4,
            typevar: T4,
            offset_v1: 32,
            offset_v2: 32,
        },
        opt_struct {
            ty: fidl::encoding::Boxed<Struct>,
            index: 5,
            typevar: T5,
            offset_v1: 56,
            offset_v2: 48,
        },
        opt_union {
            ty: fidl::encoding::OptionalUnion<Union>,
            index: 6,
            typevar: T6,
            offset_v1: 64,
            offset_v2: 56,
        },
    ],
    padding_v1: [
        {
            ty: u64,
            offset: 8,
            mask: 0xffffffffffffff00u64,
        },
    ],
    padding_v2: [
        {
            ty: u64,
            offset: 8,
            mask: 0xffffffffffffff00u64,
        },
    ],
    size_v1: 88,
    size_v2: 72,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, PartialEq)]
pub struct Resource {
    pub handle: fidl::Handle,
    pub vmo: fidl::Vmo,
    pub client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
    pub server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
    pub struct_: ResourceStruct,
    pub table: ResourceTable,
    pub union: ResourceUnion,
    pub opt_handle: Option<fidl::Handle>,
    pub opt_vmo: Option<fidl::Vmo>,
    pub opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
    pub opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
    pub opt_struct: Option<Box<ResourceStruct>>,
    pub opt_union: Option<Box<ResourceUnion>>,
    pub array_handle: [fidl::Handle; 5],
    pub array_vmo: [fidl::Vmo; 5],
    pub array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
    pub array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
    pub array_struct: [ResourceStruct; 5],
    pub array_table: [ResourceTable; 5],
    pub array_union: [ResourceUnion; 5],
    pub vector_handle: Vec<fidl::Handle>,
    pub vector_vmo: Vec<fidl::Vmo>,
    pub vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
    pub vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
    pub vector_struct: Vec<ResourceStruct>,
    pub vector_table: Vec<ResourceTable>,
    pub vector_union: Vec<ResourceUnion>,
}
impl fidl::Standalone for Resource {}

fidl_struct! {
    name: Resource,
    resource: true,
    members: [
        handle {
            ty: fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>,
            resource: true,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        vmo {
            ty: fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>,
            resource: true,
            index: 1,
            typevar: T1,
            offset_v1: 4,
            offset_v2: 4,
        },
        client_end {
            ty: fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            resource: true,
            index: 2,
            typevar: T2,
            offset_v1: 8,
            offset_v2: 8,
        },
        server_end {
            ty: fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            resource: true,
            index: 3,
            typevar: T3,
            offset_v1: 12,
            offset_v2: 12,
        },
        struct_ {
            ty: ResourceStruct,
            resource: true,
            index: 4,
            typevar: T4,
            offset_v1: 16,
            offset_v2: 16,
        },
        table {
            ty: ResourceTable,
            resource: true,
            index: 5,
            typevar: T5,
            offset_v1: 24,
            offset_v2: 24,
        },
        union {
            ty: ResourceUnion,
            resource: true,
            index: 6,
            typevar: T6,
            offset_v1: 40,
            offset_v2: 40,
        },
        opt_handle {
            ty: fidl::encoding::Optional<fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>>,
            resource: true,
            index: 7,
            typevar: T7,
            offset_v1: 64,
            offset_v2: 56,
        },
        opt_vmo {
            ty: fidl::encoding::Optional<fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>>,
            resource: true,
            index: 8,
            typevar: T8,
            offset_v1: 68,
            offset_v2: 60,
        },
        opt_client_end {
            ty: fidl::encoding::Optional<fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>>,
            resource: true,
            index: 9,
            typevar: T9,
            offset_v1: 72,
            offset_v2: 64,
        },
        opt_server_end {
            ty: fidl::encoding::Optional<fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>>,
            resource: true,
            index: 10,
            typevar: T10,
            offset_v1: 76,
            offset_v2: 68,
        },
        opt_struct {
            ty: fidl::encoding::Boxed<ResourceStruct>,
            resource: true,
            index: 11,
            typevar: T11,
            offset_v1: 80,
            offset_v2: 72,
        },
        opt_union {
            ty: fidl::encoding::OptionalUnion<ResourceUnion>,
            resource: true,
            index: 12,
            typevar: T12,
            offset_v1: 88,
            offset_v2: 80,
        },
        array_handle {
            ty: fidl::encoding::Array<fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>, 5>,
            resource: true,
            index: 13,
            typevar: T13,
            offset_v1: 112,
            offset_v2: 96,
        },
        array_vmo {
            ty: fidl::encoding::Array<fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>, 5>,
            resource: true,
            index: 14,
            typevar: T14,
            offset_v1: 132,
            offset_v2: 116,
        },
        array_client_end {
            ty: fidl::encoding::Array<fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>, 5>,
            resource: true,
            index: 15,
            typevar: T15,
            offset_v1: 152,
            offset_v2: 136,
        },
        array_server_end {
            ty: fidl::encoding::Array<fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>, 5>,
            resource: true,
            index: 16,
            typevar: T16,
            offset_v1: 172,
            offset_v2: 156,
        },
        array_struct {
            ty: fidl::encoding::Array<ResourceStruct, 5>,
            resource: true,
            index: 17,
            typevar: T17,
            offset_v1: 192,
            offset_v2: 176,
        },
        array_table {
            ty: fidl::encoding::Array<ResourceTable, 5>,
            resource: true,
            index: 18,
            typevar: T18,
            offset_v1: 200,
            offset_v2: 184,
        },
        array_union {
            ty: fidl::encoding::Array<ResourceUnion, 5>,
            resource: true,
            index: 19,
            typevar: T19,
            offset_v1: 280,
            offset_v2: 264,
        },
        vector_handle {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>>,
            resource: true,
            index: 20,
            typevar: T20,
            offset_v1: 400,
            offset_v2: 344,
        },
        vector_vmo {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>>,
            resource: true,
            index: 21,
            typevar: T21,
            offset_v1: 416,
            offset_v2: 360,
        },
        vector_client_end {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>>,
            resource: true,
            index: 22,
            typevar: T22,
            offset_v1: 432,
            offset_v2: 376,
        },
        vector_server_end {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>>,
            resource: true,
            index: 23,
            typevar: T23,
            offset_v1: 448,
            offset_v2: 392,
        },
        vector_struct {
            ty: fidl::encoding::UnboundedVector<ResourceStruct>,
            resource: true,
            index: 24,
            typevar: T24,
            offset_v1: 464,
            offset_v2: 408,
        },
        vector_table {
            ty: fidl::encoding::UnboundedVector<ResourceTable>,
            resource: true,
            index: 25,
            typevar: T25,
            offset_v1: 480,
            offset_v2: 424,
        },
        vector_union {
            ty: fidl::encoding::UnboundedVector<ResourceUnion>,
            resource: true,
            index: 26,
            typevar: T26,
            offset_v1: 496,
            offset_v2: 440,
        },
    ],
    padding_v1: [
        {
            ty: u64,
            offset: 16,
            mask: 0xffffffffffffff00u64,
        },
        {
            ty: u64,
            offset: 192,
            mask: 0xffffff0000000000u64,
        },
    ],
    padding_v2: [
        {
            ty: u64,
            offset: 16,
            mask: 0xffffffffffffff00u64,
        },
        {
            ty: u64,
            offset: 176,
            mask: 0xffffff0000000000u64,
        },
    ],
    size_v1: 512,
    size_v2: 456,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ResourceStruct;
impl fidl::Standalone for ResourceStruct {}

fidl_struct! {
    empty: true,
    name: ResourceStruct,
    resource: true,
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Struct;
impl fidl::Persistable for Struct {}

fidl_struct! {
    empty: true,
    name: Struct,
}

#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct VectorBasic {
    pub vector_uint8: Vec<u8>,
    pub vector_uint16: Vec<u16>,
    pub vector_uint32: Vec<u32>,
    pub vector_uint64: Vec<u64>,
    pub vector_int8: Vec<i8>,
    pub vector_int16: Vec<i16>,
    pub vector_int32: Vec<i32>,
    pub vector_int64: Vec<i64>,
    pub vector_float32: Vec<f32>,
    pub vector_float64: Vec<f64>,
    pub vector_string: Vec<String>,
    pub vector_opt_string: Vec<Option<String>>,
}
impl fidl::Persistable for VectorBasic {}

fidl_struct! {
    name: VectorBasic,
    members: [
        vector_uint8 {
            ty: fidl::encoding::UnboundedVector<u8>,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        vector_uint16 {
            ty: fidl::encoding::UnboundedVector<u16>,
            index: 1,
            typevar: T1,
            offset_v1: 16,
            offset_v2: 16,
        },
        vector_uint32 {
            ty: fidl::encoding::UnboundedVector<u32>,
            index: 2,
            typevar: T2,
            offset_v1: 32,
            offset_v2: 32,
        },
        vector_uint64 {
            ty: fidl::encoding::UnboundedVector<u64>,
            index: 3,
            typevar: T3,
            offset_v1: 48,
            offset_v2: 48,
        },
        vector_int8 {
            ty: fidl::encoding::UnboundedVector<i8>,
            index: 4,
            typevar: T4,
            offset_v1: 64,
            offset_v2: 64,
        },
        vector_int16 {
            ty: fidl::encoding::UnboundedVector<i16>,
            index: 5,
            typevar: T5,
            offset_v1: 80,
            offset_v2: 80,
        },
        vector_int32 {
            ty: fidl::encoding::UnboundedVector<i32>,
            index: 6,
            typevar: T6,
            offset_v1: 96,
            offset_v2: 96,
        },
        vector_int64 {
            ty: fidl::encoding::UnboundedVector<i64>,
            index: 7,
            typevar: T7,
            offset_v1: 112,
            offset_v2: 112,
        },
        vector_float32 {
            ty: fidl::encoding::UnboundedVector<f32>,
            index: 8,
            typevar: T8,
            offset_v1: 128,
            offset_v2: 128,
        },
        vector_float64 {
            ty: fidl::encoding::UnboundedVector<f64>,
            index: 9,
            typevar: T9,
            offset_v1: 144,
            offset_v2: 144,
        },
        vector_string {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>,
            index: 10,
            typevar: T10,
            offset_v1: 160,
            offset_v2: 160,
        },
        vector_opt_string {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::Optional<fidl::encoding::UnboundedString>>,
            index: 11,
            typevar: T11,
            offset_v1: 176,
            offset_v2: 176,
        },
    ],
    padding_v1: [
    ],
    padding_v2: [
    ],
    size_v1: 192,
    size_v2: 192,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Clone, PartialEq)]
pub struct VectorCompound {
    pub vector_bits: Vec<Bits>,
    pub vector_enum: Vec<Enum>,
    pub vector_struct: Vec<Struct>,
    pub vector_table: Vec<Table>,
    pub vector_union: Vec<Union>,
    pub vector_opt_struct: Vec<Option<Box<Struct>>>,
    pub vector_opt_union: Vec<Option<Box<Union>>>,
}
impl fidl::Persistable for VectorCompound {}

fidl_struct! {
    name: VectorCompound,
    members: [
        vector_bits {
            ty: fidl::encoding::UnboundedVector<Bits>,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        vector_enum {
            ty: fidl::encoding::UnboundedVector<Enum>,
            index: 1,
            typevar: T1,
            offset_v1: 16,
            offset_v2: 16,
        },
        vector_struct {
            ty: fidl::encoding::UnboundedVector<Struct>,
            index: 2,
            typevar: T2,
            offset_v1: 32,
            offset_v2: 32,
        },
        vector_table {
            ty: fidl::encoding::UnboundedVector<Table>,
            index: 3,
            typevar: T3,
            offset_v1: 48,
            offset_v2: 48,
        },
        vector_union {
            ty: fidl::encoding::UnboundedVector<Union>,
            index: 4,
            typevar: T4,
            offset_v1: 64,
            offset_v2: 64,
        },
        vector_opt_struct {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>,
            index: 5,
            typevar: T5,
            offset_v1: 80,
            offset_v2: 80,
        },
        vector_opt_union {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::OptionalUnion<Union>>,
            index: 6,
            typevar: T6,
            offset_v1: 96,
            offset_v2: 96,
        },
    ],
    padding_v1: [
    ],
    padding_v2: [
    ],
    size_v1: 112,
    size_v2: 112,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VectorOptional {
    pub opt_vector_uint8: Option<Vec<u8>>,
    pub opt_vector_string: Option<Vec<String>>,
    pub opt_vector_struct: Option<Vec<Struct>>,
    pub opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
}
impl fidl::Persistable for VectorOptional {}

fidl_struct! {
    name: VectorOptional,
    members: [
        opt_vector_uint8 {
            ty: fidl::encoding::Optional<fidl::encoding::UnboundedVector<u8>>,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        opt_vector_string {
            ty: fidl::encoding::Optional<fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>>,
            index: 1,
            typevar: T1,
            offset_v1: 16,
            offset_v2: 16,
        },
        opt_vector_struct {
            ty: fidl::encoding::Optional<fidl::encoding::UnboundedVector<Struct>>,
            index: 2,
            typevar: T2,
            offset_v1: 32,
            offset_v2: 32,
        },
        opt_vector_opt_struct {
            ty: fidl::encoding::Optional<fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>>,
            index: 3,
            typevar: T3,
            offset_v1: 48,
            offset_v2: 48,
        },
    ],
    padding_v1: [
    ],
    padding_v2: [
    ],
    size_v1: 64,
    size_v2: 64,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Default, PartialEq)]
pub struct ResourceTable {
    #[deprecated = "Use `..Default::default()` to construct and `..` to match."]
    #[doc(hidden)]
    pub __non_exhaustive: (),
}
impl fidl::Standalone for ResourceTable {}

fidl_table! {
    name: ResourceTable,
    resource: true,
    members: [
    ],
}

#[derive(Debug, Clone, Default, PartialEq)]
pub struct Table {
    #[deprecated = "Use `..Default::default()` to construct and `..` to match."]
    #[doc(hidden)]
    pub __non_exhaustive: (),
}
impl fidl::Persistable for Table {}

fidl_table! {
    name: Table,
    members: [
    ],
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ProtocolMarker;

impl fidl::endpoints::ProtocolMarker for ProtocolMarker {
    type Proxy = ProtocolProxy;
    type RequestStream = ProtocolRequestStream;
    const DEBUG_NAME: &'static str = "(anonymous) Protocol";
}
pub type ProtocolErrorBasicResult =
    Result<(u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>), u32>;
pub type ProtocolErrorCompoundResult =
    Result<(Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>), u32>;
pub type ProtocolErrorArrayBasicResult = Result<
    (
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
    ),
    u32,
>;
pub type ProtocolErrorArrayCompoundResult =
    Result<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]), u32>;
pub type ProtocolErrorVectorBasicResult = Result<
    (
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
    ),
    u32,
>;
pub type ProtocolErrorVectorCompoundResult = Result<
    (
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
    ),
    u32,
>;
pub type ProtocolErrorVectorOptionalResult = Result<
    (Option<Vec<u8>>, Option<Vec<String>>, Option<Vec<Struct>>, Option<Vec<Option<Box<Struct>>>>),
    u32,
>;
pub type ProtocolErrorArrayVectorNestedResult = Result<(Vec<[u8; 5]>, Vec<Vec<u8>>), u32>;
pub type ProtocolErrorResourceResult = Result<
    (
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
    ),
    u32,
>;

pub trait ProtocolProxyInterface: Send + Sync {
    fn r#one_way_basic(
        &self,
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: &str,
        opt_string: Option<&str>,
    ) -> Result<(), fidl::Error>;
    type TwoWayBasicResponseFut: std::future::Future<
            Output = Result<
                (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_basic(
        &self,
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: &str,
        opt_string: Option<&str>,
    ) -> Self::TwoWayBasicResponseFut;
    type ErrorBasicResponseFut: std::future::Future<Output = Result<ProtocolErrorBasicResult, fidl::Error>>
        + Send;
    fn r#error_basic(&self) -> Self::ErrorBasicResponseFut;
    fn r#one_way_compound(
        &self,
        bits: Bits,
        enum_: Enum,
        struct_: &Struct,
        table: &Table,
        union: &Union,
        opt_struct: Option<&Struct>,
        opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error>;
    type TwoWayCompoundResponseFut: std::future::Future<
            Output = Result<
                (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_compound(
        &self,
        bits: Bits,
        enum_: Enum,
        struct_: &Struct,
        table: &Table,
        union: &Union,
        opt_struct: Option<&Struct>,
        opt_union: Option<&Union>,
    ) -> Self::TwoWayCompoundResponseFut;
    type ErrorCompoundResponseFut: std::future::Future<Output = Result<ProtocolErrorCompoundResult, fidl::Error>>
        + Send;
    fn r#error_compound(&self) -> Self::ErrorCompoundResponseFut;
    fn r#one_way_array_basic(
        &self,
        array_uint8: &[u8; 5],
        array_uint16: &[u16; 5],
        array_uint32: &[u32; 5],
        array_uint64: &[u64; 5],
        array_int8: &[i8; 5],
        array_int16: &[i16; 5],
        array_int32: &[i32; 5],
        array_int64: &[i64; 5],
        array_float32: &[f32; 5],
        array_float64: &[f64; 5],
        array_string: &[String; 5],
        array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error>;
    type TwoWayArrayBasicResponseFut: std::future::Future<
            Output = Result<
                (
                    [u8; 5],
                    [u16; 5],
                    [u32; 5],
                    [u64; 5],
                    [i8; 5],
                    [i16; 5],
                    [i32; 5],
                    [i64; 5],
                    [f32; 5],
                    [f64; 5],
                    [String; 5],
                    [Option<String>; 5],
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_array_basic(
        &self,
        array_uint8: &[u8; 5],
        array_uint16: &[u16; 5],
        array_uint32: &[u32; 5],
        array_uint64: &[u64; 5],
        array_int8: &[i8; 5],
        array_int16: &[i16; 5],
        array_int32: &[i32; 5],
        array_int64: &[i64; 5],
        array_float32: &[f32; 5],
        array_float64: &[f64; 5],
        array_string: &[String; 5],
        array_opt_string: &[Option<String>; 5],
    ) -> Self::TwoWayArrayBasicResponseFut;
    type ErrorArrayBasicResponseFut: std::future::Future<Output = Result<ProtocolErrorArrayBasicResult, fidl::Error>>
        + Send;
    fn r#error_array_basic(&self) -> Self::ErrorArrayBasicResponseFut;
    fn r#one_way_array_compound(
        &self,
        array_bits: &[Bits; 5],
        array_enum: &[Enum; 5],
        array_struct: &[Struct; 5],
        array_table: &[Table; 5],
        array_union: &[Union; 5],
    ) -> Result<(), fidl::Error>;
    type TwoWayArrayCompoundResponseFut: std::future::Future<
            Output = Result<
                ([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_array_compound(
        &self,
        array_bits: &[Bits; 5],
        array_enum: &[Enum; 5],
        array_struct: &[Struct; 5],
        array_table: &[Table; 5],
        array_union: &[Union; 5],
    ) -> Self::TwoWayArrayCompoundResponseFut;
    type ErrorArrayCompoundResponseFut: std::future::Future<Output = Result<ProtocolErrorArrayCompoundResult, fidl::Error>>
        + Send;
    fn r#error_array_compound(&self) -> Self::ErrorArrayCompoundResponseFut;
    fn r#one_way_vector_basic(
        &self,
        vector_uint8: &[u8],
        vector_uint16: &[u16],
        vector_uint32: &[u32],
        vector_uint64: &[u64],
        vector_int8: &[i8],
        vector_int16: &[i16],
        vector_int32: &[i32],
        vector_int64: &[i64],
        vector_float32: &[f32],
        vector_float64: &[f64],
        vector_string: &[String],
        vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error>;
    type TwoWayVectorBasicResponseFut: std::future::Future<
            Output = Result<
                (
                    Vec<u8>,
                    Vec<u16>,
                    Vec<u32>,
                    Vec<u64>,
                    Vec<i8>,
                    Vec<i16>,
                    Vec<i32>,
                    Vec<i64>,
                    Vec<f32>,
                    Vec<f64>,
                    Vec<String>,
                    Vec<Option<String>>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_vector_basic(
        &self,
        vector_uint8: &[u8],
        vector_uint16: &[u16],
        vector_uint32: &[u32],
        vector_uint64: &[u64],
        vector_int8: &[i8],
        vector_int16: &[i16],
        vector_int32: &[i32],
        vector_int64: &[i64],
        vector_float32: &[f32],
        vector_float64: &[f64],
        vector_string: &[String],
        vector_opt_string: &[Option<String>],
    ) -> Self::TwoWayVectorBasicResponseFut;
    type ErrorVectorBasicResponseFut: std::future::Future<Output = Result<ProtocolErrorVectorBasicResult, fidl::Error>>
        + Send;
    fn r#error_vector_basic(&self) -> Self::ErrorVectorBasicResponseFut;
    fn r#one_way_vector_compound(
        &self,
        vector_bits: &[Bits],
        vector_enum: &[Enum],
        vector_struct: &[Struct],
        vector_table: &[Table],
        vector_union: &[Union],
        vector_opt_struct: &[Option<Box<Struct>>],
        vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error>;
    type TwoWayVectorCompoundResponseFut: std::future::Future<
            Output = Result<
                (
                    Vec<Bits>,
                    Vec<Enum>,
                    Vec<Struct>,
                    Vec<Table>,
                    Vec<Union>,
                    Vec<Option<Box<Struct>>>,
                    Vec<Option<Box<Union>>>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_vector_compound(
        &self,
        vector_bits: &[Bits],
        vector_enum: &[Enum],
        vector_struct: &[Struct],
        vector_table: &[Table],
        vector_union: &[Union],
        vector_opt_struct: &[Option<Box<Struct>>],
        vector_opt_union: &[Option<Box<Union>>],
    ) -> Self::TwoWayVectorCompoundResponseFut;
    type ErrorVectorCompoundResponseFut: std::future::Future<Output = Result<ProtocolErrorVectorCompoundResult, fidl::Error>>
        + Send;
    fn r#error_vector_compound(&self) -> Self::ErrorVectorCompoundResponseFut;
    fn r#one_way_vector_optional(
        &self,
        opt_vector_uint8: Option<&[u8]>,
        opt_vector_string: Option<&[String]>,
        opt_vector_struct: Option<&[Struct]>,
        opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error>;
    type TwoWayVectorOptionalResponseFut: std::future::Future<
            Output = Result<
                (
                    Option<Vec<u8>>,
                    Option<Vec<String>>,
                    Option<Vec<Struct>>,
                    Option<Vec<Option<Box<Struct>>>>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_vector_optional(
        &self,
        opt_vector_uint8: Option<&[u8]>,
        opt_vector_string: Option<&[String]>,
        opt_vector_struct: Option<&[Struct]>,
        opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Self::TwoWayVectorOptionalResponseFut;
    type ErrorVectorOptionalResponseFut: std::future::Future<Output = Result<ProtocolErrorVectorOptionalResult, fidl::Error>>
        + Send;
    fn r#error_vector_optional(&self) -> Self::ErrorVectorOptionalResponseFut;
    fn r#one_way_array_vector_nested(
        &self,
        vector_array_uint8: &[[u8; 5]],
        vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error>;
    type TwoWayArrayVectorNestedResponseFut: std::future::Future<Output = Result<(Vec<[u8; 5]>, Vec<Vec<u8>>), fidl::Error>>
        + Send;
    fn r#two_way_array_vector_nested(
        &self,
        vector_array_uint8: &[[u8; 5]],
        vector_vector_uint8: &[Vec<u8>],
    ) -> Self::TwoWayArrayVectorNestedResponseFut;
    type ErrorArrayVectorNestedResponseFut: std::future::Future<Output = Result<ProtocolErrorArrayVectorNestedResult, fidl::Error>>
        + Send;
    fn r#error_array_vector_nested(&self) -> Self::ErrorArrayVectorNestedResponseFut;
    fn r#one_way_resource(
        &self,
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<ResourceStruct>,
        opt_union: Option<ResourceUnion>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error>;
    type TwoWayResourceResponseFut: std::future::Future<
            Output = Result<
                (
                    fidl::Handle,
                    fidl::Vmo,
                    fidl::endpoints::ClientEnd<ProtocolMarker>,
                    fidl::endpoints::ServerEnd<ProtocolMarker>,
                    ResourceStruct,
                    ResourceTable,
                    ResourceUnion,
                    Option<fidl::Handle>,
                    Option<fidl::Vmo>,
                    Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    Option<Box<ResourceStruct>>,
                    Option<Box<ResourceUnion>>,
                    [fidl::Handle; 5],
                    [fidl::Vmo; 5],
                    [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                    [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                    [ResourceStruct; 5],
                    [ResourceTable; 5],
                    [ResourceUnion; 5],
                    Vec<fidl::Handle>,
                    Vec<fidl::Vmo>,
                    Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    Vec<ResourceStruct>,
                    Vec<ResourceTable>,
                    Vec<ResourceUnion>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_resource(
        &self,
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<ResourceStruct>,
        opt_union: Option<ResourceUnion>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
    ) -> Self::TwoWayResourceResponseFut;
    type ErrorResourceResponseFut: std::future::Future<Output = Result<ProtocolErrorResourceResult, fidl::Error>>
        + Send;
    fn r#error_resource(&self) -> Self::ErrorResourceResponseFut;
}

#[derive(Debug)]
#[cfg(target_os = "fuchsia")]
pub struct ProtocolSynchronousProxy {
    client: fidl::client::sync::Client,
}

#[cfg(target_os = "fuchsia")]
impl ProtocolSynchronousProxy {
    pub fn new(channel: fidl::Channel) -> Self {
        let protocol_name = <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME;
        Self { client: fidl::client::sync::Client::new(channel, protocol_name) }
    }

    pub fn into_channel(self) -> fidl::Channel {
        self.client.into_channel()
    }

    /// Waits until an event arrives and returns it. It is safe for other
    /// threads to make concurrent requests while waiting for an event.
    pub fn wait_for_event(&self, deadline: zx::Time) -> Result<ProtocolEvent, fidl::Error> {
        ProtocolEvent::decode(self.client.wait_for_event(deadline)?)
    }
    pub fn r#one_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Basic>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0x7c311f0d9e662df9,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
        ___deadline: zx::Time,
    ) -> Result<(u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>), fidl::Error>
    {
        let _response = self.client.send_query::<Basic, Basic>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0x205b92db5139c88f,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.uint8,
            _response.uint16,
            _response.uint32,
            _response.uint64,
            _response.int8,
            _response.int16,
            _response.int32,
            _response.int64,
            _response.float32,
            _response.float64,
            _response.string,
            _response.opt_string,
        ))
    }
    pub fn r#error_basic(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorBasicResult, fidl::Error> {
        let _response = self
            .client
            .send_query::<fidl::encoding::EmptyPayload, fidl::encoding::ResultType<Basic, u32>>(
                (),
                0x459eaa5d11b9ff93,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?;
        Ok(_response.map(|x| {
            (
                x.uint8,
                x.uint16,
                x.uint32,
                x.uint64,
                x.int8,
                x.int16,
                x.int32,
                x.int64,
                x.float32,
                x.float64,
                x.string,
                x.opt_string,
            )
        }))
    }
    pub fn r#one_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Compound>(
            (bits, enum_, struct_, table, union, opt_struct, opt_union),
            0x2bc2bc3a9237c6cc,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
        ___deadline: zx::Time,
    ) -> Result<
        (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
        fidl::Error,
    > {
        let _response = self.client.send_query::<Compound, Compound>(
            (bits, enum_, struct_, table, union, opt_struct, opt_union),
            0x79f279c7201da131,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.bits,
            _response.enum_,
            _response.struct_,
            _response.table,
            _response.union,
            _response.opt_struct,
            _response.opt_union,
        ))
    }
    pub fn r#error_compound(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorCompoundResult, fidl::Error> {
        let _response = self
            .client
            .send_query::<fidl::encoding::EmptyPayload, fidl::encoding::ResultType<Compound, u32>>(
                (),
                0x29817d89a19ec77d,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?;
        Ok(_response
            .map(|x| (x.bits, x.enum_, x.struct_, x.table, x.union, x.opt_struct, x.opt_union)))
    }
    pub fn r#one_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayBasic>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0x62e2ebcadf35ca19,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
        ___deadline: zx::Time,
    ) -> Result<
        (
            [u8; 5],
            [u16; 5],
            [u32; 5],
            [u64; 5],
            [i8; 5],
            [i16; 5],
            [i32; 5],
            [i64; 5],
            [f32; 5],
            [f64; 5],
            [String; 5],
            [Option<String>; 5],
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<ArrayBasic, ArrayBasic>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0x49ad7a74e28ba114,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.array_uint8,
            _response.array_uint16,
            _response.array_uint32,
            _response.array_uint64,
            _response.array_int8,
            _response.array_int16,
            _response.array_int32,
            _response.array_int64,
            _response.array_float32,
            _response.array_float64,
            _response.array_string,
            _response.array_opt_string,
        ))
    }
    pub fn r#error_array_basic(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorArrayBasicResult, fidl::Error> {
        let _response = self.client.send_query::<
                fidl::encoding::EmptyPayload,
                fidl::encoding::ResultType<ArrayBasic, u32>,
            >(
                (),
                0xf0dbde9626fff79,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?
            ;
        Ok(_response.map(|x| {
            (
                x.array_uint8,
                x.array_uint16,
                x.array_uint32,
                x.array_uint64,
                x.array_int8,
                x.array_int16,
                x.array_int32,
                x.array_int64,
                x.array_float32,
                x.array_float64,
                x.array_string,
                x.array_opt_string,
            )
        }))
    }
    pub fn r#one_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayCompound>(
            (array_bits, array_enum, array_struct, array_table, array_union),
            0x464948bae1bda09d,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
        ___deadline: zx::Time,
    ) -> Result<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]), fidl::Error> {
        let _response = self.client.send_query::<ArrayCompound, ArrayCompound>(
            (array_bits, array_enum, array_struct, array_table, array_union),
            0xbcae616f8e1ea7b,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.array_bits,
            _response.array_enum,
            _response.array_struct,
            _response.array_table,
            _response.array_union,
        ))
    }
    pub fn r#error_array_compound(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorArrayCompoundResult, fidl::Error> {
        let _response = self.client.send_query::<
                fidl::encoding::EmptyPayload,
                fidl::encoding::ResultType<ArrayCompound, u32>,
            >(
                (),
                0x52257f80e29c1a04,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?
            ;
        Ok(_response
            .map(|x| (x.array_bits, x.array_enum, x.array_struct, x.array_table, x.array_union)))
    }
    pub fn r#one_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorBasic>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0x4f907dde77464657,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
        ___deadline: zx::Time,
    ) -> Result<
        (
            Vec<u8>,
            Vec<u16>,
            Vec<u32>,
            Vec<u64>,
            Vec<i8>,
            Vec<i16>,
            Vec<i32>,
            Vec<i64>,
            Vec<f32>,
            Vec<f64>,
            Vec<String>,
            Vec<Option<String>>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<VectorBasic, VectorBasic>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0x7860cb3ed8362e74,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.vector_uint8,
            _response.vector_uint16,
            _response.vector_uint32,
            _response.vector_uint64,
            _response.vector_int8,
            _response.vector_int16,
            _response.vector_int32,
            _response.vector_int64,
            _response.vector_float32,
            _response.vector_float64,
            _response.vector_string,
            _response.vector_opt_string,
        ))
    }
    pub fn r#error_vector_basic(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorVectorBasicResult, fidl::Error> {
        let _response = self.client.send_query::<
                fidl::encoding::EmptyPayload,
                fidl::encoding::ResultType<VectorBasic, u32>,
            >(
                (),
                0xc27f841d6313f72,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?
            ;
        Ok(_response.map(|x| {
            (
                x.vector_uint8,
                x.vector_uint16,
                x.vector_uint32,
                x.vector_uint64,
                x.vector_int8,
                x.vector_int16,
                x.vector_int32,
                x.vector_int64,
                x.vector_float32,
                x.vector_float64,
                x.vector_string,
                x.vector_opt_string,
            )
        }))
    }
    pub fn r#one_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorCompound>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0x19baae42829dbe90,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
        ___deadline: zx::Time,
    ) -> Result<
        (
            Vec<Bits>,
            Vec<Enum>,
            Vec<Struct>,
            Vec<Table>,
            Vec<Union>,
            Vec<Option<Box<Struct>>>,
            Vec<Option<Box<Union>>>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<VectorCompound, VectorCompound>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0x371140db701b23b4,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.vector_bits,
            _response.vector_enum,
            _response.vector_struct,
            _response.vector_table,
            _response.vector_union,
            _response.vector_opt_struct,
            _response.vector_opt_union,
        ))
    }
    pub fn r#error_vector_compound(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorVectorCompoundResult, fidl::Error> {
        let _response = self.client.send_query::<
                fidl::encoding::EmptyPayload,
                fidl::encoding::ResultType<VectorCompound, u32>,
            >(
                (),
                0x760e278628f7a985,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?
            ;
        Ok(_response.map(|x| {
            (
                x.vector_bits,
                x.vector_enum,
                x.vector_struct,
                x.vector_table,
                x.vector_union,
                x.vector_opt_struct,
                x.vector_opt_union,
            )
        }))
    }
    pub fn r#one_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorOptional>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0x153c6b333c21c52f,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
        ___deadline: zx::Time,
    ) -> Result<
        (
            Option<Vec<u8>>,
            Option<Vec<String>>,
            Option<Vec<Struct>>,
            Option<Vec<Option<Box<Struct>>>>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<VectorOptional, VectorOptional>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0xe4b620aaafd73f3,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.opt_vector_uint8,
            _response.opt_vector_string,
            _response.opt_vector_struct,
            _response.opt_vector_opt_struct,
        ))
    }
    pub fn r#error_vector_optional(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorVectorOptionalResult, fidl::Error> {
        let _response = self.client.send_query::<
                fidl::encoding::EmptyPayload,
                fidl::encoding::ResultType<VectorOptional, u32>,
            >(
                (),
                0x58e75cf86e2d715e,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?
            ;
        Ok(_response.map(|x| {
            (x.opt_vector_uint8, x.opt_vector_string, x.opt_vector_struct, x.opt_vector_opt_struct)
        }))
    }
    pub fn r#one_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayVectorNested>(
            (vector_array_uint8, vector_vector_uint8),
            0x520dc9cb9b9b5ed7,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
        ___deadline: zx::Time,
    ) -> Result<(Vec<[u8; 5]>, Vec<Vec<u8>>), fidl::Error> {
        let _response = self.client.send_query::<ArrayVectorNested, ArrayVectorNested>(
            (vector_array_uint8, vector_vector_uint8),
            0x4a438ce0948817dc,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((_response.vector_array_uint8, _response.vector_vector_uint8))
    }
    pub fn r#error_array_vector_nested(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorArrayVectorNestedResult, fidl::Error> {
        let _response = self.client.send_query::<
                fidl::encoding::EmptyPayload,
                fidl::encoding::ResultType<ArrayVectorNested, u32>,
            >(
                (),
                0x7e168d89e1dac8a7,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?
            ;
        Ok(_response.map(|x| (x.vector_array_uint8, x.vector_vector_uint8)))
    }
    pub fn r#one_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Resource>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0x5af4795a9ed3a022,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
        ___deadline: zx::Time,
    ) -> Result<
        (
            fidl::Handle,
            fidl::Vmo,
            fidl::endpoints::ClientEnd<ProtocolMarker>,
            fidl::endpoints::ServerEnd<ProtocolMarker>,
            ResourceStruct,
            ResourceTable,
            ResourceUnion,
            Option<fidl::Handle>,
            Option<fidl::Vmo>,
            Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Option<Box<ResourceStruct>>,
            Option<Box<ResourceUnion>>,
            [fidl::Handle; 5],
            [fidl::Vmo; 5],
            [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
            [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
            [ResourceStruct; 5],
            [ResourceTable; 5],
            [ResourceUnion; 5],
            Vec<fidl::Handle>,
            Vec<fidl::Vmo>,
            Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Vec<ResourceStruct>,
            Vec<ResourceTable>,
            Vec<ResourceUnion>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<Resource, Resource>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0x1904824a11c6ad5b,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.handle,
            _response.vmo,
            _response.client_end,
            _response.server_end,
            _response.struct_,
            _response.table,
            _response.union,
            _response.opt_handle,
            _response.opt_vmo,
            _response.opt_client_end,
            _response.opt_server_end,
            _response.opt_struct,
            _response.opt_union,
            _response.array_handle,
            _response.array_vmo,
            _response.array_client_end,
            _response.array_server_end,
            _response.array_struct,
            _response.array_table,
            _response.array_union,
            _response.vector_handle,
            _response.vector_vmo,
            _response.vector_client_end,
            _response.vector_server_end,
            _response.vector_struct,
            _response.vector_table,
            _response.vector_union,
        ))
    }
    pub fn r#error_resource(
        &self,
        ___deadline: zx::Time,
    ) -> Result<ProtocolErrorResourceResult, fidl::Error> {
        let _response = self
            .client
            .send_query::<fidl::encoding::EmptyPayload, fidl::encoding::ResultType<Resource, u32>>(
                (),
                0x5b28634d603175b6,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?;
        Ok(_response.map(|x| {
            (
                x.handle,
                x.vmo,
                x.client_end,
                x.server_end,
                x.struct_,
                x.table,
                x.union,
                x.opt_handle,
                x.opt_vmo,
                x.opt_client_end,
                x.opt_server_end,
                x.opt_struct,
                x.opt_union,
                x.array_handle,
                x.array_vmo,
                x.array_client_end,
                x.array_server_end,
                x.array_struct,
                x.array_table,
                x.array_union,
                x.vector_handle,
                x.vector_vmo,
                x.vector_client_end,
                x.vector_server_end,
                x.vector_struct,
                x.vector_table,
                x.vector_union,
            )
        }))
    }
}

#[derive(Debug, Clone)]
pub struct ProtocolProxy {
    client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for ProtocolProxy {
    type Protocol = ProtocolMarker;

    fn from_channel(inner: fidl::AsyncChannel) -> Self {
        Self::new(inner)
    }

    fn into_channel(self) -> Result<::fidl::AsyncChannel, Self> {
        self.client.into_channel().map_err(|client| Self { client })
    }

    fn as_channel(&self) -> &::fidl::AsyncChannel {
        self.client.as_channel()
    }
}

impl ProtocolProxy {
    /// Create a new Proxy for Protocol
    pub fn new(channel: fidl::AsyncChannel) -> Self {
        let protocol_name = <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME;
        Self { client: fidl::client::Client::new(channel, protocol_name) }
    }

    /// Get a Stream of events from the remote end of the Protocol protocol
    ///
    /// # Panics
    ///
    /// Panics if the event stream was already taken.
    pub fn take_event_stream(&self) -> ProtocolEventStream {
        ProtocolEventStream { event_receiver: self.client.take_event_receiver() }
    }
    pub fn r#one_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_basic(
            self, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64,
            string, opt_string,
        )
    }
    pub fn r#two_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> fidl::client::QueryResponseFut<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
    )> {
        ProtocolProxyInterface::r#two_way_basic(
            self, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64,
            string, opt_string,
        )
    }
    pub fn r#error_basic(&self) -> fidl::client::QueryResponseFut<ProtocolErrorBasicResult> {
        ProtocolProxyInterface::r#error_basic(self)
    }
    pub fn r#one_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_compound(
            self, bits, enum_, struct_, table, union, opt_struct, opt_union,
        )
    }
    pub fn r#two_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> fidl::client::QueryResponseFut<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
    )> {
        ProtocolProxyInterface::r#two_way_compound(
            self, bits, enum_, struct_, table, union, opt_struct, opt_union,
        )
    }
    pub fn r#error_compound(&self) -> fidl::client::QueryResponseFut<ProtocolErrorCompoundResult> {
        ProtocolProxyInterface::r#error_compound(self)
    }
    pub fn r#one_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_array_basic(
            self,
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        )
    }
    pub fn r#two_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> fidl::client::QueryResponseFut<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
    )> {
        ProtocolProxyInterface::r#two_way_array_basic(
            self,
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        )
    }
    pub fn r#error_array_basic(
        &self,
    ) -> fidl::client::QueryResponseFut<ProtocolErrorArrayBasicResult> {
        ProtocolProxyInterface::r#error_array_basic(self)
    }
    pub fn r#one_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_array_compound(
            self,
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
        )
    }
    pub fn r#two_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> fidl::client::QueryResponseFut<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5])>
    {
        ProtocolProxyInterface::r#two_way_array_compound(
            self,
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
        )
    }
    pub fn r#error_array_compound(
        &self,
    ) -> fidl::client::QueryResponseFut<ProtocolErrorArrayCompoundResult> {
        ProtocolProxyInterface::r#error_array_compound(self)
    }
    pub fn r#one_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_vector_basic(
            self,
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        )
    }
    pub fn r#two_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> fidl::client::QueryResponseFut<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
    )> {
        ProtocolProxyInterface::r#two_way_vector_basic(
            self,
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        )
    }
    pub fn r#error_vector_basic(
        &self,
    ) -> fidl::client::QueryResponseFut<ProtocolErrorVectorBasicResult> {
        ProtocolProxyInterface::r#error_vector_basic(self)
    }
    pub fn r#one_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_vector_compound(
            self,
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        )
    }
    pub fn r#two_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> fidl::client::QueryResponseFut<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
    )> {
        ProtocolProxyInterface::r#two_way_vector_compound(
            self,
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        )
    }
    pub fn r#error_vector_compound(
        &self,
    ) -> fidl::client::QueryResponseFut<ProtocolErrorVectorCompoundResult> {
        ProtocolProxyInterface::r#error_vector_compound(self)
    }
    pub fn r#one_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_vector_optional(
            self,
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        )
    }
    pub fn r#two_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> fidl::client::QueryResponseFut<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
    )> {
        ProtocolProxyInterface::r#two_way_vector_optional(
            self,
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        )
    }
    pub fn r#error_vector_optional(
        &self,
    ) -> fidl::client::QueryResponseFut<ProtocolErrorVectorOptionalResult> {
        ProtocolProxyInterface::r#error_vector_optional(self)
    }
    pub fn r#one_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_array_vector_nested(
            self,
            vector_array_uint8,
            vector_vector_uint8,
        )
    }
    pub fn r#two_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> fidl::client::QueryResponseFut<(Vec<[u8; 5]>, Vec<Vec<u8>>)> {
        ProtocolProxyInterface::r#two_way_array_vector_nested(
            self,
            vector_array_uint8,
            vector_vector_uint8,
        )
    }
    pub fn r#error_array_vector_nested(
        &self,
    ) -> fidl::client::QueryResponseFut<ProtocolErrorArrayVectorNestedResult> {
        ProtocolProxyInterface::r#error_array_vector_nested(self)
    }
    pub fn r#one_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_resource(
            self,
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        )
    }
    pub fn r#two_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> fidl::client::QueryResponseFut<(
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
    )> {
        ProtocolProxyInterface::r#two_way_resource(
            self,
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        )
    }
    pub fn r#error_resource(&self) -> fidl::client::QueryResponseFut<ProtocolErrorResourceResult> {
        ProtocolProxyInterface::r#error_resource(self)
    }
}

impl ProtocolProxyInterface for ProtocolProxy {
    fn r#one_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Basic>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0x7c311f0d9e662df9,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayBasicResponseFut = fidl::client::QueryResponseFut<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
    )>;
    fn r#two_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Self::TwoWayBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<Basic>(_buf?)?;
            Ok((
                _response.uint8,
                _response.uint16,
                _response.uint32,
                _response.uint64,
                _response.int8,
                _response.int16,
                _response.int32,
                _response.int64,
                _response.float32,
                _response.float64,
                _response.string,
                _response.opt_string,
            ))
        }
        self.client.send_query_and_decode::<
            Basic,
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
        >(
            (uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string,),
            0x205b92db5139c88f,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    type ErrorBasicResponseFut = fidl::client::QueryResponseFut<ProtocolErrorBasicResult>;
    fn r#error_basic(&self) -> Self::ErrorBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorBasicResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<Basic, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.uint8,
                    x.uint16,
                    x.uint32,
                    x.uint64,
                    x.int8,
                    x.int16,
                    x.int32,
                    x.int64,
                    x.float32,
                    x.float64,
                    x.string,
                    x.opt_string,
                )
            }))
        }
        self.client.send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorBasicResult>(
            (),
            0x459eaa5d11b9ff93,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    fn r#one_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Compound>(
            (bits, enum_, struct_, table, union, opt_struct, opt_union),
            0x2bc2bc3a9237c6cc,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayCompoundResponseFut = fidl::client::QueryResponseFut<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
    )>;
    fn r#two_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Self::TwoWayCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<Compound>(_buf?)?;
            Ok((
                _response.bits,
                _response.enum_,
                _response.struct_,
                _response.table,
                _response.union,
                _response.opt_struct,
                _response.opt_union,
            ))
        }
        self.client.send_query_and_decode::<
            Compound,
            (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
        >(
            (bits, enum_, struct_, table, union, opt_struct, opt_union,),
            0x79f279c7201da131,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    type ErrorCompoundResponseFut = fidl::client::QueryResponseFut<ProtocolErrorCompoundResult>;
    fn r#error_compound(&self) -> Self::ErrorCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorCompoundResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<Compound, u32>,
            >(_buf?)?;
            Ok(_response
                .map(|x| (x.bits, x.enum_, x.struct_, x.table, x.union, x.opt_struct, x.opt_union)))
        }
        self.client
            .send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorCompoundResult>(
                (),
                0x29817d89a19ec77d,
                fidl::encoding::DynamicFlags::empty(),
                _decode,
            )
    }
    fn r#one_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayBasic>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0x62e2ebcadf35ca19,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayArrayBasicResponseFut = fidl::client::QueryResponseFut<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
    )>;
    fn r#two_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Self::TwoWayArrayBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                [u8; 5],
                [u16; 5],
                [u32; 5],
                [u64; 5],
                [i8; 5],
                [i16; 5],
                [i32; 5],
                [i64; 5],
                [f32; 5],
                [f64; 5],
                [String; 5],
                [Option<String>; 5],
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<ArrayBasic>(_buf?)?;
            Ok((
                _response.array_uint8,
                _response.array_uint16,
                _response.array_uint32,
                _response.array_uint64,
                _response.array_int8,
                _response.array_int16,
                _response.array_int32,
                _response.array_int64,
                _response.array_float32,
                _response.array_float64,
                _response.array_string,
                _response.array_opt_string,
            ))
        }
        self.client.send_query_and_decode::<ArrayBasic, (
            [u8; 5],
            [u16; 5],
            [u32; 5],
            [u64; 5],
            [i8; 5],
            [i16; 5],
            [i32; 5],
            [i64; 5],
            [f32; 5],
            [f64; 5],
            [String; 5],
            [Option<String>; 5],
        )>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0x49ad7a74e28ba114,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    type ErrorArrayBasicResponseFut = fidl::client::QueryResponseFut<ProtocolErrorArrayBasicResult>;
    fn r#error_array_basic(&self) -> Self::ErrorArrayBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorArrayBasicResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<ArrayBasic, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.array_uint8,
                    x.array_uint16,
                    x.array_uint32,
                    x.array_uint64,
                    x.array_int8,
                    x.array_int16,
                    x.array_int32,
                    x.array_int64,
                    x.array_float32,
                    x.array_float64,
                    x.array_string,
                    x.array_opt_string,
                )
            }))
        }
        self.client
            .send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorArrayBasicResult>(
                (),
                0xf0dbde9626fff79,
                fidl::encoding::DynamicFlags::empty(),
                _decode,
            )
    }
    fn r#one_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayCompound>(
            (array_bits, array_enum, array_struct, array_table, array_union),
            0x464948bae1bda09d,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayArrayCompoundResponseFut =
        fidl::client::QueryResponseFut<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5])>;
    fn r#two_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Self::TwoWayArrayCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]), fidl::Error>
        {
            let _response = fidl::client::decode_transaction_body::<ArrayCompound>(_buf?)?;
            Ok((
                _response.array_bits,
                _response.array_enum,
                _response.array_struct,
                _response.array_table,
                _response.array_union,
            ))
        }
        self.client.send_query_and_decode::<
            ArrayCompound,
            ([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]),
        >(
            (array_bits, array_enum, array_struct, array_table, array_union,),
            0xbcae616f8e1ea7b,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    type ErrorArrayCompoundResponseFut =
        fidl::client::QueryResponseFut<ProtocolErrorArrayCompoundResult>;
    fn r#error_array_compound(&self) -> Self::ErrorArrayCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorArrayCompoundResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<ArrayCompound, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (x.array_bits, x.array_enum, x.array_struct, x.array_table, x.array_union)
            }))
        }
        self.client.send_query_and_decode::<
            fidl::encoding::EmptyPayload,
            ProtocolErrorArrayCompoundResult,
        >(
            (),
            0x52257f80e29c1a04,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    fn r#one_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorBasic>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0x4f907dde77464657,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayVectorBasicResponseFut = fidl::client::QueryResponseFut<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
    )>;
    fn r#two_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Self::TwoWayVectorBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                Vec<u8>,
                Vec<u16>,
                Vec<u32>,
                Vec<u64>,
                Vec<i8>,
                Vec<i16>,
                Vec<i32>,
                Vec<i64>,
                Vec<f32>,
                Vec<f64>,
                Vec<String>,
                Vec<Option<String>>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<VectorBasic>(_buf?)?;
            Ok((
                _response.vector_uint8,
                _response.vector_uint16,
                _response.vector_uint32,
                _response.vector_uint64,
                _response.vector_int8,
                _response.vector_int16,
                _response.vector_int32,
                _response.vector_int64,
                _response.vector_float32,
                _response.vector_float64,
                _response.vector_string,
                _response.vector_opt_string,
            ))
        }
        self.client.send_query_and_decode::<VectorBasic, (
            Vec<u8>,
            Vec<u16>,
            Vec<u32>,
            Vec<u64>,
            Vec<i8>,
            Vec<i16>,
            Vec<i32>,
            Vec<i64>,
            Vec<f32>,
            Vec<f64>,
            Vec<String>,
            Vec<Option<String>>,
        )>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0x7860cb3ed8362e74,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    type ErrorVectorBasicResponseFut =
        fidl::client::QueryResponseFut<ProtocolErrorVectorBasicResult>;
    fn r#error_vector_basic(&self) -> Self::ErrorVectorBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorVectorBasicResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<VectorBasic, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.vector_uint8,
                    x.vector_uint16,
                    x.vector_uint32,
                    x.vector_uint64,
                    x.vector_int8,
                    x.vector_int16,
                    x.vector_int32,
                    x.vector_int64,
                    x.vector_float32,
                    x.vector_float64,
                    x.vector_string,
                    x.vector_opt_string,
                )
            }))
        }
        self.client
            .send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorVectorBasicResult>(
                (),
                0xc27f841d6313f72,
                fidl::encoding::DynamicFlags::empty(),
                _decode,
            )
    }
    fn r#one_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorCompound>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0x19baae42829dbe90,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayVectorCompoundResponseFut = fidl::client::QueryResponseFut<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
    )>;
    fn r#two_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Self::TwoWayVectorCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                Vec<Bits>,
                Vec<Enum>,
                Vec<Struct>,
                Vec<Table>,
                Vec<Union>,
                Vec<Option<Box<Struct>>>,
                Vec<Option<Box<Union>>>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<VectorCompound>(_buf?)?;
            Ok((
                _response.vector_bits,
                _response.vector_enum,
                _response.vector_struct,
                _response.vector_table,
                _response.vector_union,
                _response.vector_opt_struct,
                _response.vector_opt_union,
            ))
        }
        self.client.send_query_and_decode::<VectorCompound, (
            Vec<Bits>,
            Vec<Enum>,
            Vec<Struct>,
            Vec<Table>,
            Vec<Union>,
            Vec<Option<Box<Struct>>>,
            Vec<Option<Box<Union>>>,
        )>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0x371140db701b23b4,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    type ErrorVectorCompoundResponseFut =
        fidl::client::QueryResponseFut<ProtocolErrorVectorCompoundResult>;
    fn r#error_vector_compound(&self) -> Self::ErrorVectorCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorVectorCompoundResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<VectorCompound, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.vector_bits,
                    x.vector_enum,
                    x.vector_struct,
                    x.vector_table,
                    x.vector_union,
                    x.vector_opt_struct,
                    x.vector_opt_union,
                )
            }))
        }
        self.client.send_query_and_decode::<
            fidl::encoding::EmptyPayload,
            ProtocolErrorVectorCompoundResult,
        >(
            (),
            0x760e278628f7a985,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    fn r#one_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorOptional>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0x153c6b333c21c52f,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayVectorOptionalResponseFut = fidl::client::QueryResponseFut<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
    )>;
    fn r#two_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Self::TwoWayVectorOptionalResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                Option<Vec<u8>>,
                Option<Vec<String>>,
                Option<Vec<Struct>>,
                Option<Vec<Option<Box<Struct>>>>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<VectorOptional>(_buf?)?;
            Ok((
                _response.opt_vector_uint8,
                _response.opt_vector_string,
                _response.opt_vector_struct,
                _response.opt_vector_opt_struct,
            ))
        }
        self.client.send_query_and_decode::<VectorOptional, (
            Option<Vec<u8>>,
            Option<Vec<String>>,
            Option<Vec<Struct>>,
            Option<Vec<Option<Box<Struct>>>>,
        )>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0xe4b620aaafd73f3,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    type ErrorVectorOptionalResponseFut =
        fidl::client::QueryResponseFut<ProtocolErrorVectorOptionalResult>;
    fn r#error_vector_optional(&self) -> Self::ErrorVectorOptionalResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorVectorOptionalResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<VectorOptional, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.opt_vector_uint8,
                    x.opt_vector_string,
                    x.opt_vector_struct,
                    x.opt_vector_opt_struct,
                )
            }))
        }
        self.client.send_query_and_decode::<
            fidl::encoding::EmptyPayload,
            ProtocolErrorVectorOptionalResult,
        >(
            (),
            0x58e75cf86e2d715e,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    fn r#one_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayVectorNested>(
            (vector_array_uint8, vector_vector_uint8),
            0x520dc9cb9b9b5ed7,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayArrayVectorNestedResponseFut =
        fidl::client::QueryResponseFut<(Vec<[u8; 5]>, Vec<Vec<u8>>)>;
    fn r#two_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Self::TwoWayArrayVectorNestedResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<(Vec<[u8; 5]>, Vec<Vec<u8>>), fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<ArrayVectorNested>(_buf?)?;
            Ok((_response.vector_array_uint8, _response.vector_vector_uint8))
        }
        self.client.send_query_and_decode::<ArrayVectorNested, (Vec<[u8; 5]>, Vec<Vec<u8>>)>(
            (vector_array_uint8, vector_vector_uint8),
            0x4a438ce0948817dc,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    type ErrorArrayVectorNestedResponseFut =
        fidl::client::QueryResponseFut<ProtocolErrorArrayVectorNestedResult>;
    fn r#error_array_vector_nested(&self) -> Self::ErrorArrayVectorNestedResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorArrayVectorNestedResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<ArrayVectorNested, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| (x.vector_array_uint8, x.vector_vector_uint8)))
        }
        self.client.send_query_and_decode::<
            fidl::encoding::EmptyPayload,
            ProtocolErrorArrayVectorNestedResult,
        >(
            (),
            0x7e168d89e1dac8a7,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    fn r#one_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Resource>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0x5af4795a9ed3a022,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayResourceResponseFut = fidl::client::QueryResponseFut<(
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
    )>;
    fn r#two_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Self::TwoWayResourceResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                fidl::Handle,
                fidl::Vmo,
                fidl::endpoints::ClientEnd<ProtocolMarker>,
                fidl::endpoints::ServerEnd<ProtocolMarker>,
                ResourceStruct,
                ResourceTable,
                ResourceUnion,
                Option<fidl::Handle>,
                Option<fidl::Vmo>,
                Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Option<Box<ResourceStruct>>,
                Option<Box<ResourceUnion>>,
                [fidl::Handle; 5],
                [fidl::Vmo; 5],
                [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                [ResourceStruct; 5],
                [ResourceTable; 5],
                [ResourceUnion; 5],
                Vec<fidl::Handle>,
                Vec<fidl::Vmo>,
                Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Vec<ResourceStruct>,
                Vec<ResourceTable>,
                Vec<ResourceUnion>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<Resource>(_buf?)?;
            Ok((
                _response.handle,
                _response.vmo,
                _response.client_end,
                _response.server_end,
                _response.struct_,
                _response.table,
                _response.union,
                _response.opt_handle,
                _response.opt_vmo,
                _response.opt_client_end,
                _response.opt_server_end,
                _response.opt_struct,
                _response.opt_union,
                _response.array_handle,
                _response.array_vmo,
                _response.array_client_end,
                _response.array_server_end,
                _response.array_struct,
                _response.array_table,
                _response.array_union,
                _response.vector_handle,
                _response.vector_vmo,
                _response.vector_client_end,
                _response.vector_server_end,
                _response.vector_struct,
                _response.vector_table,
                _response.vector_union,
            ))
        }
        self.client.send_query_and_decode::<Resource, (
            fidl::Handle,
            fidl::Vmo,
            fidl::endpoints::ClientEnd<ProtocolMarker>,
            fidl::endpoints::ServerEnd<ProtocolMarker>,
            ResourceStruct,
            ResourceTable,
            ResourceUnion,
            Option<fidl::Handle>,
            Option<fidl::Vmo>,
            Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Option<Box<ResourceStruct>>,
            Option<Box<ResourceUnion>>,
            [fidl::Handle; 5],
            [fidl::Vmo; 5],
            [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
            [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
            [ResourceStruct; 5],
            [ResourceTable; 5],
            [ResourceUnion; 5],
            Vec<fidl::Handle>,
            Vec<fidl::Vmo>,
            Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Vec<ResourceStruct>,
            Vec<ResourceTable>,
            Vec<ResourceUnion>,
        )>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0x1904824a11c6ad5b,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    type ErrorResourceResponseFut = fidl::client::QueryResponseFut<ProtocolErrorResourceResult>;
    fn r#error_resource(&self) -> Self::ErrorResourceResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorResourceResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<Resource, u32>,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.handle,
                    x.vmo,
                    x.client_end,
                    x.server_end,
                    x.struct_,
                    x.table,
                    x.union,
                    x.opt_handle,
                    x.opt_vmo,
                    x.opt_client_end,
                    x.opt_server_end,
                    x.opt_struct,
                    x.opt_union,
                    x.array_handle,
                    x.array_vmo,
                    x.array_client_end,
                    x.array_server_end,
                    x.array_struct,
                    x.array_table,
                    x.array_union,
                    x.vector_handle,
                    x.vector_vmo,
                    x.vector_client_end,
                    x.vector_server_end,
                    x.vector_struct,
                    x.vector_table,
                    x.vector_union,
                )
            }))
        }
        self.client
            .send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorResourceResult>(
                (),
                0x5b28634d603175b6,
                fidl::encoding::DynamicFlags::empty(),
                _decode,
            )
    }
}

pub struct ProtocolEventStream {
    event_receiver: fidl::client::EventReceiver,
}

impl std::marker::Unpin for ProtocolEventStream {}

impl futures::stream::FusedStream for ProtocolEventStream {
    fn is_terminated(&self) -> bool {
        self.event_receiver.is_terminated()
    }
}

impl futures::Stream for ProtocolEventStream {
    type Item = Result<ProtocolEvent, fidl::Error>;

    fn poll_next(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Option<Self::Item>> {
        let buf = match futures::ready!(futures::stream::StreamExt::poll_next_unpin(
            &mut self.event_receiver,
            cx
        )?) {
            Some(buf) => buf,
            None => return std::task::Poll::Ready(None),
        };

        std::task::Poll::Ready(Some(ProtocolEvent::decode(buf)))
    }
}

#[derive(Debug)]
pub enum ProtocolEvent {
    EventBasic {
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: String,
        opt_string: Option<String>,
    },
    EventCompound {
        bits: Bits,
        enum_: Enum,
        struct_: Struct,
        table: Table,
        union: Union,
        opt_struct: Option<Box<Struct>>,
        opt_union: Option<Box<Union>>,
    },
    EventArrayBasic {
        array_uint8: [u8; 5],
        array_uint16: [u16; 5],
        array_uint32: [u32; 5],
        array_uint64: [u64; 5],
        array_int8: [i8; 5],
        array_int16: [i16; 5],
        array_int32: [i32; 5],
        array_int64: [i64; 5],
        array_float32: [f32; 5],
        array_float64: [f64; 5],
        array_string: [String; 5],
        array_opt_string: [Option<String>; 5],
    },
    EventArrayCompound {
        array_bits: [Bits; 5],
        array_enum: [Enum; 5],
        array_struct: [Struct; 5],
        array_table: [Table; 5],
        array_union: [Union; 5],
    },
    EventVectorBasic {
        vector_uint8: Vec<u8>,
        vector_uint16: Vec<u16>,
        vector_uint32: Vec<u32>,
        vector_uint64: Vec<u64>,
        vector_int8: Vec<i8>,
        vector_int16: Vec<i16>,
        vector_int32: Vec<i32>,
        vector_int64: Vec<i64>,
        vector_float32: Vec<f32>,
        vector_float64: Vec<f64>,
        vector_string: Vec<String>,
        vector_opt_string: Vec<Option<String>>,
    },
    EventVectorCompound {
        vector_bits: Vec<Bits>,
        vector_enum: Vec<Enum>,
        vector_struct: Vec<Struct>,
        vector_table: Vec<Table>,
        vector_union: Vec<Union>,
        vector_opt_struct: Vec<Option<Box<Struct>>>,
        vector_opt_union: Vec<Option<Box<Union>>>,
    },
    EventVectorOptional {
        opt_vector_uint8: Option<Vec<u8>>,
        opt_vector_string: Option<Vec<String>>,
        opt_vector_struct: Option<Vec<Struct>>,
        opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
    },
    EventArrayVectorNested {
        vector_array_uint8: Vec<[u8; 5]>,
        vector_vector_uint8: Vec<Vec<u8>>,
    },
    EventResource {
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<Box<ResourceStruct>>,
        opt_union: Option<Box<ResourceUnion>>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
    },
}

impl ProtocolEvent {
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_basic(
        self,
    ) -> Option<(u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>)> {
        if let ProtocolEvent::EventBasic {
            uint8,
            uint16,
            uint32,
            uint64,
            int8,
            int16,
            int32,
            int64,
            float32,
            float64,
            string,
            opt_string,
        } = self
        {
            Some((
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_compound(
        self,
    ) -> Option<(Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>)> {
        if let ProtocolEvent::EventCompound {
            bits,
            enum_,
            struct_,
            table,
            union,
            opt_struct,
            opt_union,
        } = self
        {
            Some((bits, enum_, struct_, table, union, opt_struct, opt_union))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_array_basic(
        self,
    ) -> Option<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
    )> {
        if let ProtocolEvent::EventArrayBasic {
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        } = self
        {
            Some((
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_array_compound(
        self,
    ) -> Option<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5])> {
        if let ProtocolEvent::EventArrayCompound {
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
        } = self
        {
            Some((array_bits, array_enum, array_struct, array_table, array_union))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_vector_basic(
        self,
    ) -> Option<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
    )> {
        if let ProtocolEvent::EventVectorBasic {
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        } = self
        {
            Some((
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_vector_compound(
        self,
    ) -> Option<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
    )> {
        if let ProtocolEvent::EventVectorCompound {
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        } = self
        {
            Some((
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_vector_optional(
        self,
    ) -> Option<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
    )> {
        if let ProtocolEvent::EventVectorOptional {
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        } = self
        {
            Some((opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_array_vector_nested(self) -> Option<(Vec<[u8; 5]>, Vec<Vec<u8>>)> {
        if let ProtocolEvent::EventArrayVectorNested { vector_array_uint8, vector_vector_uint8 } =
            self
        {
            Some((vector_array_uint8, vector_vector_uint8))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_resource(
        self,
    ) -> Option<(
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
    )> {
        if let ProtocolEvent::EventResource {
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        } = self
        {
            Some((
                handle,
                vmo,
                client_end,
                server_end,
                struct_,
                table,
                union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,
            ))
        } else {
            None
        }
    }

    /// Decodes a message buffer as a [`ProtocolEvent`]. Transaction
    /// ID in the message must be zero; this method does not check TXID.
    fn decode(mut buf: fidl::MessageBufEtc) -> Result<ProtocolEvent, fidl::Error> {
        let (bytes, _handles) = buf.split_mut();
        let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

        match tx_header.ordinal() {
            0x51c5b06295c10c40 => {
                let mut out = fidl::new_empty!(Basic);
                fidl::encoding::Decoder::decode_into::<Basic>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventBasic {
                    uint8: out.uint8,
                    uint16: out.uint16,
                    uint32: out.uint32,
                    uint64: out.uint64,
                    int8: out.int8,
                    int16: out.int16,
                    int32: out.int32,
                    int64: out.int64,
                    float32: out.float32,
                    float64: out.float64,
                    string: out.string,
                    opt_string: out.opt_string,
                }))
            }
            0x617c5410858734d5 => {
                let mut out = fidl::new_empty!(Compound);
                fidl::encoding::Decoder::decode_into::<Compound>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventCompound {
                    bits: out.bits,
                    enum_: out.enum_,
                    struct_: out.struct_,
                    table: out.table,
                    union: out.union,
                    opt_struct: out.opt_struct,
                    opt_union: out.opt_union,
                }))
            }
            0x51b76208b148f02e => {
                let mut out = fidl::new_empty!(ArrayBasic);
                fidl::encoding::Decoder::decode_into::<ArrayBasic>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventArrayBasic {
                    array_uint8: out.array_uint8,
                    array_uint16: out.array_uint16,
                    array_uint32: out.array_uint32,
                    array_uint64: out.array_uint64,
                    array_int8: out.array_int8,
                    array_int16: out.array_int16,
                    array_int32: out.array_int32,
                    array_int64: out.array_int64,
                    array_float32: out.array_float32,
                    array_float64: out.array_float64,
                    array_string: out.array_string,
                    array_opt_string: out.array_opt_string,
                }))
            }
            0x1e63a00079aa7415 => {
                let mut out = fidl::new_empty!(ArrayCompound);
                fidl::encoding::Decoder::decode_into::<ArrayCompound>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventArrayCompound {
                    array_bits: out.array_bits,
                    array_enum: out.array_enum,
                    array_struct: out.array_struct,
                    array_table: out.array_table,
                    array_union: out.array_union,
                }))
            }
            0x3f9d405e7191eff6 => {
                let mut out = fidl::new_empty!(VectorBasic);
                fidl::encoding::Decoder::decode_into::<VectorBasic>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventVectorBasic {
                    vector_uint8: out.vector_uint8,
                    vector_uint16: out.vector_uint16,
                    vector_uint32: out.vector_uint32,
                    vector_uint64: out.vector_uint64,
                    vector_int8: out.vector_int8,
                    vector_int16: out.vector_int16,
                    vector_int32: out.vector_int32,
                    vector_int64: out.vector_int64,
                    vector_float32: out.vector_float32,
                    vector_float64: out.vector_float64,
                    vector_string: out.vector_string,
                    vector_opt_string: out.vector_opt_string,
                }))
            }
            0x53a1fc56e8b3cff3 => {
                let mut out = fidl::new_empty!(VectorCompound);
                fidl::encoding::Decoder::decode_into::<VectorCompound>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventVectorCompound {
                    vector_bits: out.vector_bits,
                    vector_enum: out.vector_enum,
                    vector_struct: out.vector_struct,
                    vector_table: out.vector_table,
                    vector_union: out.vector_union,
                    vector_opt_struct: out.vector_opt_struct,
                    vector_opt_union: out.vector_opt_union,
                }))
            }
            0x17617b54dfa8d85d => {
                let mut out = fidl::new_empty!(VectorOptional);
                fidl::encoding::Decoder::decode_into::<VectorOptional>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventVectorOptional {
                    opt_vector_uint8: out.opt_vector_uint8,
                    opt_vector_string: out.opt_vector_string,
                    opt_vector_struct: out.opt_vector_struct,
                    opt_vector_opt_struct: out.opt_vector_opt_struct,
                }))
            }
            0x110b72cfebc4037e => {
                let mut out = fidl::new_empty!(ArrayVectorNested);
                fidl::encoding::Decoder::decode_into::<ArrayVectorNested>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventArrayVectorNested {
                    vector_array_uint8: out.vector_array_uint8,
                    vector_vector_uint8: out.vector_vector_uint8,
                }))
            }
            0x4fbde2864601698b => {
                let mut out = fidl::new_empty!(Resource);
                fidl::encoding::Decoder::decode_into::<Resource>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                Ok((ProtocolEvent::EventResource {
                    handle: out.handle,
                    vmo: out.vmo,
                    client_end: out.client_end,
                    server_end: out.server_end,
                    struct_: out.struct_,
                    table: out.table,
                    union: out.union,
                    opt_handle: out.opt_handle,
                    opt_vmo: out.opt_vmo,
                    opt_client_end: out.opt_client_end,
                    opt_server_end: out.opt_server_end,
                    opt_struct: out.opt_struct,
                    opt_union: out.opt_union,
                    array_handle: out.array_handle,
                    array_vmo: out.array_vmo,
                    array_client_end: out.array_client_end,
                    array_server_end: out.array_server_end,
                    array_struct: out.array_struct,
                    array_table: out.array_table,
                    array_union: out.array_union,
                    vector_handle: out.vector_handle,
                    vector_vmo: out.vector_vmo,
                    vector_client_end: out.vector_client_end,
                    vector_server_end: out.vector_server_end,
                    vector_struct: out.vector_struct,
                    vector_table: out.vector_table,
                    vector_union: out.vector_union,
                }))
            }
            _ => Err(fidl::Error::UnknownOrdinal {
                ordinal: tx_header.ordinal(),
                protocol_name: <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME,
            }),
        }
    }
}

/// A Stream of incoming requests for Protocol
pub struct ProtocolRequestStream {
    inner: std::sync::Arc<fidl::ServeInner>,
    is_terminated: bool,
}

impl std::marker::Unpin for ProtocolRequestStream {}

impl futures::stream::FusedStream for ProtocolRequestStream {
    fn is_terminated(&self) -> bool {
        self.is_terminated
    }
}

impl fidl::endpoints::RequestStream for ProtocolRequestStream {
    type Protocol = ProtocolMarker;
    type ControlHandle = ProtocolControlHandle;

    fn from_channel(channel: fidl::AsyncChannel) -> Self {
        Self { inner: std::sync::Arc::new(fidl::ServeInner::new(channel)), is_terminated: false }
    }

    fn control_handle(&self) -> Self::ControlHandle {
        ProtocolControlHandle { inner: self.inner.clone() }
    }

    fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, bool) {
        (self.inner, self.is_terminated)
    }

    fn from_inner(inner: std::sync::Arc<fidl::ServeInner>, is_terminated: bool) -> Self {
        Self { inner, is_terminated }
    }
}

impl futures::Stream for ProtocolRequestStream {
    type Item = Result<ProtocolRequest, fidl::Error>;

    fn poll_next(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Option<Self::Item>> {
        let this = &mut *self;
        if this.inner.poll_shutdown(cx) {
            this.is_terminated = true;
            return std::task::Poll::Ready(None);
        }
        if this.is_terminated {
            panic!("polled ProtocolRequestStream after completion");
        }
        fidl::encoding::with_tls_decode_buf(|bytes, handles| {
            match this.inner.channel().read_etc(cx, bytes, handles) {
                std::task::Poll::Ready(Ok(())) => {}
                std::task::Poll::Pending => return std::task::Poll::Pending,
                std::task::Poll::Ready(Err(zx_status::Status::PEER_CLOSED)) => {
                    this.is_terminated = true;
                    return std::task::Poll::Ready(None);
                }
                std::task::Poll::Ready(Err(e)) => {
                    return std::task::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e))))
                }
            }

            // A message has been received from the channel
            let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;
            if !header.is_compatible() {
                return std::task::Poll::Ready(Some(Err(fidl::Error::IncompatibleMagicNumber(
                    header.magic_number(),
                ))));
            }

            std::task::Poll::Ready(Some(match header.ordinal() {
                0x7c311f0d9e662df9 => {
                    let mut req = fidl::new_empty!(Basic);
                    fidl::encoding::Decoder::decode_into::<Basic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayBasic {
                        uint8: req.uint8,
                        uint16: req.uint16,
                        uint32: req.uint32,
                        uint64: req.uint64,
                        int8: req.int8,
                        int16: req.int16,
                        int32: req.int32,
                        int64: req.int64,
                        float32: req.float32,
                        float64: req.float64,
                        string: req.string,
                        opt_string: req.opt_string,

                        control_handle,
                    })
                }
                0x205b92db5139c88f => {
                    let mut req = fidl::new_empty!(Basic);
                    fidl::encoding::Decoder::decode_into::<Basic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayBasic {
                        uint8: req.uint8,
                        uint16: req.uint16,
                        uint32: req.uint32,
                        uint64: req.uint64,
                        int8: req.int8,
                        int16: req.int16,
                        int32: req.int32,
                        int64: req.int64,
                        float32: req.float32,
                        float64: req.float64,
                        string: req.string,
                        opt_string: req.opt_string,

                        responder: ProtocolTwoWayBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x459eaa5d11b9ff93 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorBasic {
                        responder: ProtocolErrorBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x2bc2bc3a9237c6cc => {
                    let mut req = fidl::new_empty!(Compound);
                    fidl::encoding::Decoder::decode_into::<Compound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayCompound {
                        bits: req.bits,
                        enum_: req.enum_,
                        struct_: req.struct_,
                        table: req.table,
                        union: req.union,
                        opt_struct: req.opt_struct,
                        opt_union: req.opt_union,

                        control_handle,
                    })
                }
                0x79f279c7201da131 => {
                    let mut req = fidl::new_empty!(Compound);
                    fidl::encoding::Decoder::decode_into::<Compound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayCompound {
                        bits: req.bits,
                        enum_: req.enum_,
                        struct_: req.struct_,
                        table: req.table,
                        union: req.union,
                        opt_struct: req.opt_struct,
                        opt_union: req.opt_union,

                        responder: ProtocolTwoWayCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x29817d89a19ec77d => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorCompound {
                        responder: ProtocolErrorCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x62e2ebcadf35ca19 => {
                    let mut req = fidl::new_empty!(ArrayBasic);
                    fidl::encoding::Decoder::decode_into::<ArrayBasic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayArrayBasic {
                        array_uint8: req.array_uint8,
                        array_uint16: req.array_uint16,
                        array_uint32: req.array_uint32,
                        array_uint64: req.array_uint64,
                        array_int8: req.array_int8,
                        array_int16: req.array_int16,
                        array_int32: req.array_int32,
                        array_int64: req.array_int64,
                        array_float32: req.array_float32,
                        array_float64: req.array_float64,
                        array_string: req.array_string,
                        array_opt_string: req.array_opt_string,

                        control_handle,
                    })
                }
                0x49ad7a74e28ba114 => {
                    let mut req = fidl::new_empty!(ArrayBasic);
                    fidl::encoding::Decoder::decode_into::<ArrayBasic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayArrayBasic {
                        array_uint8: req.array_uint8,
                        array_uint16: req.array_uint16,
                        array_uint32: req.array_uint32,
                        array_uint64: req.array_uint64,
                        array_int8: req.array_int8,
                        array_int16: req.array_int16,
                        array_int32: req.array_int32,
                        array_int64: req.array_int64,
                        array_float32: req.array_float32,
                        array_float64: req.array_float64,
                        array_string: req.array_string,
                        array_opt_string: req.array_opt_string,

                        responder: ProtocolTwoWayArrayBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0xf0dbde9626fff79 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorArrayBasic {
                        responder: ProtocolErrorArrayBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x464948bae1bda09d => {
                    let mut req = fidl::new_empty!(ArrayCompound);
                    fidl::encoding::Decoder::decode_into::<ArrayCompound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayArrayCompound {
                        array_bits: req.array_bits,
                        array_enum: req.array_enum,
                        array_struct: req.array_struct,
                        array_table: req.array_table,
                        array_union: req.array_union,

                        control_handle,
                    })
                }
                0xbcae616f8e1ea7b => {
                    let mut req = fidl::new_empty!(ArrayCompound);
                    fidl::encoding::Decoder::decode_into::<ArrayCompound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayArrayCompound {
                        array_bits: req.array_bits,
                        array_enum: req.array_enum,
                        array_struct: req.array_struct,
                        array_table: req.array_table,
                        array_union: req.array_union,

                        responder: ProtocolTwoWayArrayCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x52257f80e29c1a04 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorArrayCompound {
                        responder: ProtocolErrorArrayCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x4f907dde77464657 => {
                    let mut req = fidl::new_empty!(VectorBasic);
                    fidl::encoding::Decoder::decode_into::<VectorBasic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayVectorBasic {
                        vector_uint8: req.vector_uint8,
                        vector_uint16: req.vector_uint16,
                        vector_uint32: req.vector_uint32,
                        vector_uint64: req.vector_uint64,
                        vector_int8: req.vector_int8,
                        vector_int16: req.vector_int16,
                        vector_int32: req.vector_int32,
                        vector_int64: req.vector_int64,
                        vector_float32: req.vector_float32,
                        vector_float64: req.vector_float64,
                        vector_string: req.vector_string,
                        vector_opt_string: req.vector_opt_string,

                        control_handle,
                    })
                }
                0x7860cb3ed8362e74 => {
                    let mut req = fidl::new_empty!(VectorBasic);
                    fidl::encoding::Decoder::decode_into::<VectorBasic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayVectorBasic {
                        vector_uint8: req.vector_uint8,
                        vector_uint16: req.vector_uint16,
                        vector_uint32: req.vector_uint32,
                        vector_uint64: req.vector_uint64,
                        vector_int8: req.vector_int8,
                        vector_int16: req.vector_int16,
                        vector_int32: req.vector_int32,
                        vector_int64: req.vector_int64,
                        vector_float32: req.vector_float32,
                        vector_float64: req.vector_float64,
                        vector_string: req.vector_string,
                        vector_opt_string: req.vector_opt_string,

                        responder: ProtocolTwoWayVectorBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0xc27f841d6313f72 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorVectorBasic {
                        responder: ProtocolErrorVectorBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x19baae42829dbe90 => {
                    let mut req = fidl::new_empty!(VectorCompound);
                    fidl::encoding::Decoder::decode_into::<VectorCompound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayVectorCompound {
                        vector_bits: req.vector_bits,
                        vector_enum: req.vector_enum,
                        vector_struct: req.vector_struct,
                        vector_table: req.vector_table,
                        vector_union: req.vector_union,
                        vector_opt_struct: req.vector_opt_struct,
                        vector_opt_union: req.vector_opt_union,

                        control_handle,
                    })
                }
                0x371140db701b23b4 => {
                    let mut req = fidl::new_empty!(VectorCompound);
                    fidl::encoding::Decoder::decode_into::<VectorCompound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayVectorCompound {
                        vector_bits: req.vector_bits,
                        vector_enum: req.vector_enum,
                        vector_struct: req.vector_struct,
                        vector_table: req.vector_table,
                        vector_union: req.vector_union,
                        vector_opt_struct: req.vector_opt_struct,
                        vector_opt_union: req.vector_opt_union,

                        responder: ProtocolTwoWayVectorCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x760e278628f7a985 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorVectorCompound {
                        responder: ProtocolErrorVectorCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x153c6b333c21c52f => {
                    let mut req = fidl::new_empty!(VectorOptional);
                    fidl::encoding::Decoder::decode_into::<VectorOptional>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayVectorOptional {
                        opt_vector_uint8: req.opt_vector_uint8,
                        opt_vector_string: req.opt_vector_string,
                        opt_vector_struct: req.opt_vector_struct,
                        opt_vector_opt_struct: req.opt_vector_opt_struct,

                        control_handle,
                    })
                }
                0xe4b620aaafd73f3 => {
                    let mut req = fidl::new_empty!(VectorOptional);
                    fidl::encoding::Decoder::decode_into::<VectorOptional>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayVectorOptional {
                        opt_vector_uint8: req.opt_vector_uint8,
                        opt_vector_string: req.opt_vector_string,
                        opt_vector_struct: req.opt_vector_struct,
                        opt_vector_opt_struct: req.opt_vector_opt_struct,

                        responder: ProtocolTwoWayVectorOptionalResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x58e75cf86e2d715e => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorVectorOptional {
                        responder: ProtocolErrorVectorOptionalResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x520dc9cb9b9b5ed7 => {
                    let mut req = fidl::new_empty!(ArrayVectorNested);
                    fidl::encoding::Decoder::decode_into::<ArrayVectorNested>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayArrayVectorNested {
                        vector_array_uint8: req.vector_array_uint8,
                        vector_vector_uint8: req.vector_vector_uint8,

                        control_handle,
                    })
                }
                0x4a438ce0948817dc => {
                    let mut req = fidl::new_empty!(ArrayVectorNested);
                    fidl::encoding::Decoder::decode_into::<ArrayVectorNested>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayArrayVectorNested {
                        vector_array_uint8: req.vector_array_uint8,
                        vector_vector_uint8: req.vector_vector_uint8,

                        responder: ProtocolTwoWayArrayVectorNestedResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x7e168d89e1dac8a7 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorArrayVectorNested {
                        responder: ProtocolErrorArrayVectorNestedResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x5af4795a9ed3a022 => {
                    let mut req = fidl::new_empty!(Resource);
                    fidl::encoding::Decoder::decode_into::<Resource>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayResource {
                        handle: req.handle,
                        vmo: req.vmo,
                        client_end: req.client_end,
                        server_end: req.server_end,
                        struct_: req.struct_,
                        table: req.table,
                        union: req.union,
                        opt_handle: req.opt_handle,
                        opt_vmo: req.opt_vmo,
                        opt_client_end: req.opt_client_end,
                        opt_server_end: req.opt_server_end,
                        opt_struct: req.opt_struct,
                        opt_union: req.opt_union,
                        array_handle: req.array_handle,
                        array_vmo: req.array_vmo,
                        array_client_end: req.array_client_end,
                        array_server_end: req.array_server_end,
                        array_struct: req.array_struct,
                        array_table: req.array_table,
                        array_union: req.array_union,
                        vector_handle: req.vector_handle,
                        vector_vmo: req.vector_vmo,
                        vector_client_end: req.vector_client_end,
                        vector_server_end: req.vector_server_end,
                        vector_struct: req.vector_struct,
                        vector_table: req.vector_table,
                        vector_union: req.vector_union,

                        control_handle,
                    })
                }
                0x1904824a11c6ad5b => {
                    let mut req = fidl::new_empty!(Resource);
                    fidl::encoding::Decoder::decode_into::<Resource>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayResource {
                        handle: req.handle,
                        vmo: req.vmo,
                        client_end: req.client_end,
                        server_end: req.server_end,
                        struct_: req.struct_,
                        table: req.table,
                        union: req.union,
                        opt_handle: req.opt_handle,
                        opt_vmo: req.opt_vmo,
                        opt_client_end: req.opt_client_end,
                        opt_server_end: req.opt_server_end,
                        opt_struct: req.opt_struct,
                        opt_union: req.opt_union,
                        array_handle: req.array_handle,
                        array_vmo: req.array_vmo,
                        array_client_end: req.array_client_end,
                        array_server_end: req.array_server_end,
                        array_struct: req.array_struct,
                        array_table: req.array_table,
                        array_union: req.array_union,
                        vector_handle: req.vector_handle,
                        vector_vmo: req.vector_vmo,
                        vector_client_end: req.vector_client_end,
                        vector_server_end: req.vector_server_end,
                        vector_struct: req.vector_struct,
                        vector_table: req.vector_table,
                        vector_union: req.vector_union,

                        responder: ProtocolTwoWayResourceResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x5b28634d603175b6 => {
                    let mut req = fidl::new_empty!(fidl::encoding::EmptyPayload);
                    fidl::encoding::Decoder::decode_into::<fidl::encoding::EmptyPayload>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::ErrorResource {
                        responder: ProtocolErrorResourceResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                _ => Err(fidl::Error::UnknownOrdinal {
                    ordinal: header.ordinal(),
                    protocol_name: <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME,
                }),
            }))
        })
    }
}
#[derive(Debug)]
pub enum ProtocolRequest {
    OneWayBasic {
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: String,
        opt_string: Option<String>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayBasic {
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: String,
        opt_string: Option<String>,
        responder: ProtocolTwoWayBasicResponder,
    },
    ErrorBasic {
        responder: ProtocolErrorBasicResponder,
    },
    OneWayCompound {
        bits: Bits,
        enum_: Enum,
        struct_: Struct,
        table: Table,
        union: Union,
        opt_struct: Option<Box<Struct>>,
        opt_union: Option<Box<Union>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayCompound {
        bits: Bits,
        enum_: Enum,
        struct_: Struct,
        table: Table,
        union: Union,
        opt_struct: Option<Box<Struct>>,
        opt_union: Option<Box<Union>>,
        responder: ProtocolTwoWayCompoundResponder,
    },
    ErrorCompound {
        responder: ProtocolErrorCompoundResponder,
    },
    OneWayArrayBasic {
        array_uint8: [u8; 5],
        array_uint16: [u16; 5],
        array_uint32: [u32; 5],
        array_uint64: [u64; 5],
        array_int8: [i8; 5],
        array_int16: [i16; 5],
        array_int32: [i32; 5],
        array_int64: [i64; 5],
        array_float32: [f32; 5],
        array_float64: [f64; 5],
        array_string: [String; 5],
        array_opt_string: [Option<String>; 5],
        control_handle: ProtocolControlHandle,
    },
    TwoWayArrayBasic {
        array_uint8: [u8; 5],
        array_uint16: [u16; 5],
        array_uint32: [u32; 5],
        array_uint64: [u64; 5],
        array_int8: [i8; 5],
        array_int16: [i16; 5],
        array_int32: [i32; 5],
        array_int64: [i64; 5],
        array_float32: [f32; 5],
        array_float64: [f64; 5],
        array_string: [String; 5],
        array_opt_string: [Option<String>; 5],
        responder: ProtocolTwoWayArrayBasicResponder,
    },
    ErrorArrayBasic {
        responder: ProtocolErrorArrayBasicResponder,
    },
    OneWayArrayCompound {
        array_bits: [Bits; 5],
        array_enum: [Enum; 5],
        array_struct: [Struct; 5],
        array_table: [Table; 5],
        array_union: [Union; 5],
        control_handle: ProtocolControlHandle,
    },
    TwoWayArrayCompound {
        array_bits: [Bits; 5],
        array_enum: [Enum; 5],
        array_struct: [Struct; 5],
        array_table: [Table; 5],
        array_union: [Union; 5],
        responder: ProtocolTwoWayArrayCompoundResponder,
    },
    ErrorArrayCompound {
        responder: ProtocolErrorArrayCompoundResponder,
    },
    OneWayVectorBasic {
        vector_uint8: Vec<u8>,
        vector_uint16: Vec<u16>,
        vector_uint32: Vec<u32>,
        vector_uint64: Vec<u64>,
        vector_int8: Vec<i8>,
        vector_int16: Vec<i16>,
        vector_int32: Vec<i32>,
        vector_int64: Vec<i64>,
        vector_float32: Vec<f32>,
        vector_float64: Vec<f64>,
        vector_string: Vec<String>,
        vector_opt_string: Vec<Option<String>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayVectorBasic {
        vector_uint8: Vec<u8>,
        vector_uint16: Vec<u16>,
        vector_uint32: Vec<u32>,
        vector_uint64: Vec<u64>,
        vector_int8: Vec<i8>,
        vector_int16: Vec<i16>,
        vector_int32: Vec<i32>,
        vector_int64: Vec<i64>,
        vector_float32: Vec<f32>,
        vector_float64: Vec<f64>,
        vector_string: Vec<String>,
        vector_opt_string: Vec<Option<String>>,
        responder: ProtocolTwoWayVectorBasicResponder,
    },
    ErrorVectorBasic {
        responder: ProtocolErrorVectorBasicResponder,
    },
    OneWayVectorCompound {
        vector_bits: Vec<Bits>,
        vector_enum: Vec<Enum>,
        vector_struct: Vec<Struct>,
        vector_table: Vec<Table>,
        vector_union: Vec<Union>,
        vector_opt_struct: Vec<Option<Box<Struct>>>,
        vector_opt_union: Vec<Option<Box<Union>>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayVectorCompound {
        vector_bits: Vec<Bits>,
        vector_enum: Vec<Enum>,
        vector_struct: Vec<Struct>,
        vector_table: Vec<Table>,
        vector_union: Vec<Union>,
        vector_opt_struct: Vec<Option<Box<Struct>>>,
        vector_opt_union: Vec<Option<Box<Union>>>,
        responder: ProtocolTwoWayVectorCompoundResponder,
    },
    ErrorVectorCompound {
        responder: ProtocolErrorVectorCompoundResponder,
    },
    OneWayVectorOptional {
        opt_vector_uint8: Option<Vec<u8>>,
        opt_vector_string: Option<Vec<String>>,
        opt_vector_struct: Option<Vec<Struct>>,
        opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayVectorOptional {
        opt_vector_uint8: Option<Vec<u8>>,
        opt_vector_string: Option<Vec<String>>,
        opt_vector_struct: Option<Vec<Struct>>,
        opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
        responder: ProtocolTwoWayVectorOptionalResponder,
    },
    ErrorVectorOptional {
        responder: ProtocolErrorVectorOptionalResponder,
    },
    OneWayArrayVectorNested {
        vector_array_uint8: Vec<[u8; 5]>,
        vector_vector_uint8: Vec<Vec<u8>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayArrayVectorNested {
        vector_array_uint8: Vec<[u8; 5]>,
        vector_vector_uint8: Vec<Vec<u8>>,
        responder: ProtocolTwoWayArrayVectorNestedResponder,
    },
    ErrorArrayVectorNested {
        responder: ProtocolErrorArrayVectorNestedResponder,
    },
    OneWayResource {
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<Box<ResourceStruct>>,
        opt_union: Option<Box<ResourceUnion>>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayResource {
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<Box<ResourceStruct>>,
        opt_union: Option<Box<ResourceUnion>>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
        responder: ProtocolTwoWayResourceResponder,
    },
    ErrorResource {
        responder: ProtocolErrorResourceResponder,
    },
}

impl ProtocolRequest {
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_basic(
        self,
    ) -> Option<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayBasic {
            uint8,
            uint16,
            uint32,
            uint64,
            int8,
            int16,
            int32,
            int64,
            float32,
            float64,
            string,
            opt_string,
            control_handle,
        } = self
        {
            Some((
                uint8,
                uint16,
                uint32,
                uint64,
                int8,
                int16,
                int32,
                int64,
                float32,
                float64,
                string,
                opt_string,
                control_handle,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_basic(
        self,
    ) -> Option<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
        ProtocolTwoWayBasicResponder,
    )> {
        if let ProtocolRequest::TwoWayBasic {
            uint8,
            uint16,
            uint32,
            uint64,
            int8,
            int16,
            int32,
            int64,
            float32,
            float64,
            string,
            opt_string,
            responder,
        } = self
        {
            Some((
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string, responder,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_error_basic(self) -> Option<(ProtocolErrorBasicResponder)> {
        if let ProtocolRequest::ErrorBasic { responder } = self {
            Some((responder))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_compound(
        self,
    ) -> Option<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayCompound {
            bits,
            enum_,
            struct_,
            table,
            union,
            opt_struct,
            opt_union,
            control_handle,
        } = self
        {
            Some((bits, enum_, struct_, table, union, opt_struct, opt_union, control_handle))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_compound(
        self,
    ) -> Option<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
        ProtocolTwoWayCompoundResponder,
    )> {
        if let ProtocolRequest::TwoWayCompound {
            bits,
            enum_,
            struct_,
            table,
            union,
            opt_struct,
            opt_union,
            responder,
        } = self
        {
            Some((bits, enum_, struct_, table, union, opt_struct, opt_union, responder))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_error_compound(self) -> Option<(ProtocolErrorCompoundResponder)> {
        if let ProtocolRequest::ErrorCompound { responder } = self {
            Some((responder))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_array_basic(
        self,
    ) -> Option<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayArrayBasic {
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
            control_handle,
        } = self
        {
            Some((
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
                control_handle,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_array_basic(
        self,
    ) -> Option<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
        ProtocolTwoWayArrayBasicResponder,
    )> {
        if let ProtocolRequest::TwoWayArrayBasic {
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
            responder,
        } = self
        {
            Some((
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
                responder,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_error_array_basic(self) -> Option<(ProtocolErrorArrayBasicResponder)> {
        if let ProtocolRequest::ErrorArrayBasic { responder } = self {
            Some((responder))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_array_compound(
        self,
    ) -> Option<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5], ProtocolControlHandle)>
    {
        if let ProtocolRequest::OneWayArrayCompound {
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
            control_handle,
        } = self
        {
            Some((array_bits, array_enum, array_struct, array_table, array_union, control_handle))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_array_compound(
        self,
    ) -> Option<(
        [Bits; 5],
        [Enum; 5],
        [Struct; 5],
        [Table; 5],
        [Union; 5],
        ProtocolTwoWayArrayCompoundResponder,
    )> {
        if let ProtocolRequest::TwoWayArrayCompound {
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
            responder,
        } = self
        {
            Some((array_bits, array_enum, array_struct, array_table, array_union, responder))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_error_array_compound(self) -> Option<(ProtocolErrorArrayCompoundResponder)> {
        if let ProtocolRequest::ErrorArrayCompound { responder } = self {
            Some((responder))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_vector_basic(
        self,
    ) -> Option<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayVectorBasic {
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
            control_handle,
        } = self
        {
            Some((
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
                control_handle,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_vector_basic(
        self,
    ) -> Option<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
        ProtocolTwoWayVectorBasicResponder,
    )> {
        if let ProtocolRequest::TwoWayVectorBasic {
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
            responder,
        } = self
        {
            Some((
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
                responder,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_error_vector_basic(self) -> Option<(ProtocolErrorVectorBasicResponder)> {
        if let ProtocolRequest::ErrorVectorBasic { responder } = self {
            Some((responder))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_vector_compound(
        self,
    ) -> Option<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayVectorCompound {
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
            control_handle,
        } = self
        {
            Some((
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
                control_handle,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_vector_compound(
        self,
    ) -> Option<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
        ProtocolTwoWayVectorCompoundResponder,
    )> {
        if let ProtocolRequest::TwoWayVectorCompound {
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
            responder,
        } = self
        {
            Some((
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
                responder,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_error_vector_compound(self) -> Option<(ProtocolErrorVectorCompoundResponder)> {
        if let ProtocolRequest::ErrorVectorCompound { responder } = self {
            Some((responder))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_vector_optional(
        self,
    ) -> Option<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayVectorOptional {
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
            control_handle,
        } = self
        {
            Some((
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,
                control_handle,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_vector_optional(
        self,
    ) -> Option<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
        ProtocolTwoWayVectorOptionalResponder,
    )> {
        if let ProtocolRequest::TwoWayVectorOptional {
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
            responder,
        } = self
        {
            Some((
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,
                responder,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_error_vector_optional(self) -> Option<(ProtocolErrorVectorOptionalResponder)> {
        if let ProtocolRequest::ErrorVectorOptional { responder } = self {
            Some((responder))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_array_vector_nested(
        self,
    ) -> Option<(Vec<[u8; 5]>, Vec<Vec<u8>>, ProtocolControlHandle)> {
        if let ProtocolRequest::OneWayArrayVectorNested {
            vector_array_uint8,
            vector_vector_uint8,
            control_handle,
        } = self
        {
            Some((vector_array_uint8, vector_vector_uint8, control_handle))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_array_vector_nested(
        self,
    ) -> Option<(Vec<[u8; 5]>, Vec<Vec<u8>>, ProtocolTwoWayArrayVectorNestedResponder)> {
        if let ProtocolRequest::TwoWayArrayVectorNested {
            vector_array_uint8,
            vector_vector_uint8,
            responder,
        } = self
        {
            Some((vector_array_uint8, vector_vector_uint8, responder))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_error_array_vector_nested(
        self,
    ) -> Option<(ProtocolErrorArrayVectorNestedResponder)> {
        if let ProtocolRequest::ErrorArrayVectorNested { responder } = self {
            Some((responder))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_resource(
        self,
    ) -> Option<(
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayResource {
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
            control_handle,
        } = self
        {
            Some((
                handle,
                vmo,
                client_end,
                server_end,
                struct_,
                table,
                union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,
                control_handle,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_resource(
        self,
    ) -> Option<(
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
        ProtocolTwoWayResourceResponder,
    )> {
        if let ProtocolRequest::TwoWayResource {
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
            responder,
        } = self
        {
            Some((
                handle,
                vmo,
                client_end,
                server_end,
                struct_,
                table,
                union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,
                responder,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_error_resource(self) -> Option<(ProtocolErrorResourceResponder)> {
        if let ProtocolRequest::ErrorResource { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    /// Name of the method defined in FIDL
    pub fn method_name(&self) -> &'static str {
        match *self {
            ProtocolRequest::OneWayBasic { .. } => "one_way_basic",
            ProtocolRequest::TwoWayBasic { .. } => "two_way_basic",
            ProtocolRequest::ErrorBasic { .. } => "error_basic",
            ProtocolRequest::OneWayCompound { .. } => "one_way_compound",
            ProtocolRequest::TwoWayCompound { .. } => "two_way_compound",
            ProtocolRequest::ErrorCompound { .. } => "error_compound",
            ProtocolRequest::OneWayArrayBasic { .. } => "one_way_array_basic",
            ProtocolRequest::TwoWayArrayBasic { .. } => "two_way_array_basic",
            ProtocolRequest::ErrorArrayBasic { .. } => "error_array_basic",
            ProtocolRequest::OneWayArrayCompound { .. } => "one_way_array_compound",
            ProtocolRequest::TwoWayArrayCompound { .. } => "two_way_array_compound",
            ProtocolRequest::ErrorArrayCompound { .. } => "error_array_compound",
            ProtocolRequest::OneWayVectorBasic { .. } => "one_way_vector_basic",
            ProtocolRequest::TwoWayVectorBasic { .. } => "two_way_vector_basic",
            ProtocolRequest::ErrorVectorBasic { .. } => "error_vector_basic",
            ProtocolRequest::OneWayVectorCompound { .. } => "one_way_vector_compound",
            ProtocolRequest::TwoWayVectorCompound { .. } => "two_way_vector_compound",
            ProtocolRequest::ErrorVectorCompound { .. } => "error_vector_compound",
            ProtocolRequest::OneWayVectorOptional { .. } => "one_way_vector_optional",
            ProtocolRequest::TwoWayVectorOptional { .. } => "two_way_vector_optional",
            ProtocolRequest::ErrorVectorOptional { .. } => "error_vector_optional",
            ProtocolRequest::OneWayArrayVectorNested { .. } => "one_way_array_vector_nested",
            ProtocolRequest::TwoWayArrayVectorNested { .. } => "two_way_array_vector_nested",
            ProtocolRequest::ErrorArrayVectorNested { .. } => "error_array_vector_nested",
            ProtocolRequest::OneWayResource { .. } => "one_way_resource",
            ProtocolRequest::TwoWayResource { .. } => "two_way_resource",
            ProtocolRequest::ErrorResource { .. } => "error_resource",
        }
    }
}

#[derive(Debug, Clone)]
pub struct ProtocolControlHandle {
    inner: std::sync::Arc<fidl::ServeInner>,
}

impl fidl::endpoints::ControlHandle for ProtocolControlHandle {
    fn shutdown(&self) {
        self.inner.shutdown()
    }

    fn shutdown_with_epitaph(&self, status: zx_status::Status) {
        self.inner.shutdown_with_epitaph(status)
    }

    fn is_closed(&self) -> bool {
        self.inner.channel().is_closed()
    }

    fn on_closed<'a>(&'a self) -> fidl::OnSignals<'a> {
        self.inner.channel().on_closed()
    }
}

impl ProtocolControlHandle {
    pub fn send_event_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<Basic>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0,
            0x51c5b06295c10c40,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<Compound>(
            (bits, enum_, struct_, table, union, opt_struct, opt_union),
            0,
            0x617c5410858734d5,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<ArrayBasic>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0,
            0x51b76208b148f02e,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<ArrayCompound>(
            (array_bits, array_enum, array_struct, array_table, array_union),
            0,
            0x1e63a00079aa7415,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<VectorBasic>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0,
            0x3f9d405e7191eff6,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<VectorCompound>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0,
            0x53a1fc56e8b3cff3,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<VectorOptional>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0,
            0x17617b54dfa8d85d,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_array_vector_nested(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<ArrayVectorNested>(
            (vector_array_uint8, vector_vector_uint8),
            0,
            0x110b72cfebc4037e,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<Resource>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0,
            0x4fbde2864601698b,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
            opt_string,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
            opt_string,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<Basic>>(
                bytes, handles, msg,
            )?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, &str, Option<&str>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, &str, Option<&str>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, &str, Option<&str>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<fidl::encoding::ResultType<Basic, u32>>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(bits, enum_, struct_, table, union, opt_struct, opt_union);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(bits, enum_, struct_, table, union, opt_struct, opt_union);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (bits, enum_, struct_, table, union, opt_struct, opt_union),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<Compound>>(
                bytes, handles, msg,
            )?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (Bits, Enum, &Struct, &Table, &Union, Option<&Struct>, Option<&Union>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (Bits, Enum, &Struct, &Table, &Union, Option<&Struct>, Option<&Union>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (Bits, Enum, &Struct, &Table, &Union, Option<&Struct>, Option<&Union>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<fidl::encoding::ResultType<Compound, u32>>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayArrayBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayArrayBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayArrayBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayArrayBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<ArrayBasic>>(
                bytes, handles, msg,
            )?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorArrayBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorArrayBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorArrayBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorArrayBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (
                &[u8; 5],
                &[u16; 5],
                &[u32; 5],
                &[u64; 5],
                &[i8; 5],
                &[i16; 5],
                &[i32; 5],
                &[i64; 5],
                &[f32; 5],
                &[f64; 5],
                &[String; 5],
                &[Option<String>; 5],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (
                &[u8; 5],
                &[u16; 5],
                &[u32; 5],
                &[u64; 5],
                &[i8; 5],
                &[i16; 5],
                &[i32; 5],
                &[i64; 5],
                &[f32; 5],
                &[f64; 5],
                &[String; 5],
                &[Option<String>; 5],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (
                &[u8; 5],
                &[u16; 5],
                &[u32; 5],
                &[u64; 5],
                &[i8; 5],
                &[i16; 5],
                &[i32; 5],
                &[i64; 5],
                &[f32; 5],
                &[f64; 5],
                &[String; 5],
                &[Option<String>; 5],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<fidl::encoding::ResultType<ArrayBasic, u32>>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayArrayCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayArrayCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayArrayCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayArrayCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(array_bits, array_enum, array_struct, array_table, array_union);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(array_bits, array_enum, array_struct, array_table, array_union);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (array_bits, array_enum, array_struct, array_table, array_union),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<ArrayCompound>>(
                bytes, handles, msg,
            )?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorArrayCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorArrayCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorArrayCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorArrayCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<(&[Bits; 5], &[Enum; 5], &[Struct; 5], &[Table; 5], &[Union; 5]), u32>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<(&[Bits; 5], &[Enum; 5], &[Struct; 5], &[Table; 5], &[Union; 5]), u32>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<(&[Bits; 5], &[Enum; 5], &[Struct; 5], &[Table; 5], &[Union; 5]), u32>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<
                    fidl::encoding::ResultType<ArrayCompound, u32>,
                >,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayVectorBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayVectorBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayVectorBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayVectorBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<VectorBasic>>(
                bytes, handles, msg,
            )?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorVectorBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorVectorBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorVectorBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorVectorBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (
                &[u8],
                &[u16],
                &[u32],
                &[u64],
                &[i8],
                &[i16],
                &[i32],
                &[i64],
                &[f32],
                &[f64],
                &[String],
                &[Option<String>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (
                &[u8],
                &[u16],
                &[u32],
                &[u64],
                &[i8],
                &[i16],
                &[i32],
                &[i64],
                &[f32],
                &[f64],
                &[String],
                &[Option<String>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (
                &[u8],
                &[u16],
                &[u32],
                &[u64],
                &[i8],
                &[i16],
                &[i32],
                &[i64],
                &[f32],
                &[f64],
                &[String],
                &[Option<String>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<
                    fidl::encoding::ResultType<VectorBasic, u32>,
                >,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayVectorCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayVectorCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayVectorCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayVectorCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<VectorCompound>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorVectorCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorVectorCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorVectorCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorVectorCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (
                &[Bits],
                &[Enum],
                &[Struct],
                &[Table],
                &[Union],
                &[Option<Box<Struct>>],
                &[Option<Box<Union>>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (
                &[Bits],
                &[Enum],
                &[Struct],
                &[Table],
                &[Union],
                &[Option<Box<Struct>>],
                &[Option<Box<Union>>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (
                &[Bits],
                &[Enum],
                &[Struct],
                &[Table],
                &[Union],
                &[Option<Box<Struct>>],
                &[Option<Box<Union>>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<
                    fidl::encoding::ResultType<VectorCompound, u32>,
                >,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayVectorOptionalResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayVectorOptionalResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayVectorOptionalResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayVectorOptionalResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<VectorOptional>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorVectorOptionalResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorVectorOptionalResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorVectorOptionalResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorVectorOptionalResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (Option<&[u8]>, Option<&[String]>, Option<&[Struct]>, Option<&[Option<Box<Struct>>]>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (Option<&[u8]>, Option<&[String]>, Option<&[Struct]>, Option<&[Option<Box<Struct>>]>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (Option<&[u8]>, Option<&[String]>, Option<&[Struct]>, Option<&[Option<Box<Struct>>]>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<
                    fidl::encoding::ResultType<VectorOptional, u32>,
                >,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayArrayVectorNestedResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayArrayVectorNestedResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayArrayVectorNestedResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayArrayVectorNestedResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(vector_array_uint8, vector_vector_uint8);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(vector_array_uint8, vector_vector_uint8);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (vector_array_uint8, vector_vector_uint8),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<ArrayVectorNested>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorArrayVectorNestedResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorArrayVectorNestedResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorArrayVectorNestedResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorArrayVectorNestedResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<(&[[u8; 5]], &[Vec<u8>]), u32>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<(&[[u8; 5]], &[Vec<u8>]), u32>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<(&[[u8; 5]], &[Vec<u8>]), u32>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result,
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<
                    fidl::encoding::ResultType<ArrayVectorNested, u32>,
                >,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayResourceResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayResourceResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayResourceResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayResourceResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<Resource>>(
                bytes, handles, msg,
            )?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorResourceResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorResourceResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorResourceResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorResourceResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (
                fidl::Handle,
                fidl::Vmo,
                fidl::endpoints::ClientEnd<ProtocolMarker>,
                fidl::endpoints::ServerEnd<ProtocolMarker>,
                ResourceStruct,
                ResourceTable,
                ResourceUnion,
                Option<fidl::Handle>,
                Option<fidl::Vmo>,
                Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Option<ResourceStruct>,
                Option<ResourceUnion>,
                [fidl::Handle; 5],
                [fidl::Vmo; 5],
                [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                [ResourceStruct; 5],
                [ResourceTable; 5],
                [ResourceUnion; 5],
                Vec<fidl::Handle>,
                Vec<fidl::Vmo>,
                Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Vec<ResourceStruct>,
                Vec<ResourceTable>,
                Vec<ResourceUnion>,
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (
                fidl::Handle,
                fidl::Vmo,
                fidl::endpoints::ClientEnd<ProtocolMarker>,
                fidl::endpoints::ServerEnd<ProtocolMarker>,
                ResourceStruct,
                ResourceTable,
                ResourceUnion,
                Option<fidl::Handle>,
                Option<fidl::Vmo>,
                Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Option<ResourceStruct>,
                Option<ResourceUnion>,
                [fidl::Handle; 5],
                [fidl::Vmo; 5],
                [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                [ResourceStruct; 5],
                [ResourceTable; 5],
                [ResourceUnion; 5],
                Vec<fidl::Handle>,
                Vec<fidl::Vmo>,
                Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Vec<ResourceStruct>,
                Vec<ResourceTable>,
                Vec<ResourceUnion>,
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(result);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut result: Result<
            (
                fidl::Handle,
                fidl::Vmo,
                fidl::endpoints::ClientEnd<ProtocolMarker>,
                fidl::endpoints::ServerEnd<ProtocolMarker>,
                ResourceStruct,
                ResourceTable,
                ResourceUnion,
                Option<fidl::Handle>,
                Option<fidl::Vmo>,
                Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Option<ResourceStruct>,
                Option<ResourceUnion>,
                [fidl::Handle; 5],
                [fidl::Vmo; 5],
                [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                [ResourceStruct; 5],
                [ResourceTable; 5],
                [ResourceUnion; 5],
                Vec<fidl::Handle>,
                Vec<fidl::Vmo>,
                Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Vec<ResourceStruct>,
                Vec<ResourceTable>,
                Vec<ResourceUnion>,
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: result.as_mut().map_err(|e| *e).map(
                |(
                    handle,
                    vmo,
                    client_end,
                    server_end,
                    struct_,
                    table,
                    union,
                    opt_handle,
                    opt_vmo,
                    opt_client_end,
                    opt_server_end,
                    opt_struct,
                    opt_union,
                    array_handle,
                    array_vmo,
                    array_client_end,
                    array_server_end,
                    array_struct,
                    array_table,
                    array_union,
                    vector_handle,
                    vector_vmo,
                    vector_client_end,
                    vector_server_end,
                    vector_struct,
                    vector_table,
                    vector_union,
                )| {
                    (
                        std::mem::replace(handle, fidl::Handle::invalid().into()),
                        std::mem::replace(vmo, fidl::Handle::invalid().into()),
                        std::mem::replace(client_end, fidl::Handle::invalid().into()),
                        std::mem::replace(server_end, fidl::Handle::invalid().into()),
                        struct_,
                        table,
                        union,
                        opt_handle
                            .as_mut()
                            .map(|x| std::mem::replace(x, fidl::Handle::invalid().into())),
                        opt_vmo
                            .as_mut()
                            .map(|x| std::mem::replace(x, fidl::Handle::invalid().into())),
                        opt_client_end
                            .as_mut()
                            .map(|x| std::mem::replace(x, fidl::Handle::invalid().into())),
                        opt_server_end
                            .as_mut()
                            .map(|x| std::mem::replace(x, fidl::Handle::invalid().into())),
                        opt_struct.as_mut(),
                        opt_union.as_mut(),
                        array_handle,
                        array_vmo,
                        array_client_end,
                        array_server_end,
                        array_struct,
                        array_table,
                        array_union,
                        vector_handle.as_mut_slice(),
                        vector_vmo.as_mut_slice(),
                        vector_client_end.as_mut_slice(),
                        vector_server_end.as_mut_slice(),
                        vector_struct.as_mut_slice(),
                        vector_table.as_mut_slice(),
                        vector_union.as_mut_slice(),
                    )
                },
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<fidl::encoding::ResultType<Resource, u32>>,
            >(bytes, handles, msg)?;
            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
