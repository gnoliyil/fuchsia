// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#![allow(
    unused_parens, // one-element-tuple-case is not a tuple
    unused_mut, // not all args require mutation, but many do
    nonstandard_style, // auto-caps does its best, but is not always successful
)]
#![recursion_limit = "512"]

#[cfg(target_os = "fuchsia")]
#[allow(unused_imports)]
use fuchsia_zircon as zx;

#[allow(unused_imports)]
use {
    bitflags::bitflags,
    fidl::{
        client::QueryResponseFut,
        encoding::zerocopy,
        endpoints::{ControlHandle as _, Responder as _},
        fidl_bits, fidl_enum, fidl_struct, fidl_table, fidl_union,
    },
    fuchsia_zircon_status as zx_status,
    futures::future::{self, MaybeDone, TryFutureExt},
};

const _FIDL_TRACE_BINDINGS_RUST: u32 = 6;
bitflags! {
    pub struct Bits: u32 {
        const VAL = 1;
    }
}

impl Bits {
    #[inline(always)]
    pub fn from_bits_allow_unknown(bits: u32) -> Self {
        unsafe { Self::from_bits_unchecked(bits) }
    }

    #[inline(always)]
    pub fn has_unknown_bits(&self) -> bool {
        self.get_unknown_bits() != 0
    }

    #[inline(always)]
    pub fn get_unknown_bits(&self) -> u32 {
        self.bits & !Self::all().bits
    }
}

fidl_bits! {
    name: Bits,
    prim_ty: u32,
    flexible: true,
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[non_exhaustive]
pub enum Enum {
    Val,
    #[deprecated = "Use `Enum::unknown()` to construct and `EnumUnknown!()` to exhaustively match."]
    #[doc(hidden)]
    __Unknown(u32),
}
/// Pattern that matches an unknown `Enum` member.
#[macro_export]
macro_rules! EnumUnknown {
    () => {
        _
    };
}

impl Enum {
    #[inline]
    pub fn from_primitive(prim: u32) -> Option<Self> {
        match prim {
            1 => Some(Self::Val),
            _ => None,
        }
    }

    #[inline]
    pub fn from_primitive_allow_unknown(prim: u32) -> Self {
        match prim {
            1 => Self::Val,
            #[allow(deprecated)]
            x => Self::__Unknown(x),
        }
    }

    #[inline]
    pub fn unknown() -> Self {
        #[allow(deprecated)]
        Self::__Unknown(0xffffffff)
    }

    #[inline]
    pub const fn into_primitive(self) -> u32 {
        match self {
            Self::Val => 1,
            #[allow(deprecated)]
            Self::__Unknown(x) => x,
        }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            #[allow(deprecated)]
            Self::__Unknown(_) => true,
            _ => false,
        }
    }
}

fidl_enum! {
    name: Enum,
    prim_ty: u32,
    flexible: true,
}

#[derive(Debug, Clone)]
pub enum Union {
    B(bool),
    #[deprecated = "Use `Union::unknown()` to construct and `UnionUnknown!()` to exhaustively match."]
    #[doc(hidden)]
    #[non_exhaustive]
    __Unknown {
        ordinal: u64,
    },
}
/// Pattern that matches an unknown `Union` member.
#[macro_export]
macro_rules! UnionUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for Union {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::B(x), Self::B(y)) => *x == *y,
            _ => false,
        }
    }
}

impl Union {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::B(_) => 1,
            #[allow(deprecated)]
            Self::__Unknown { ordinal } => ordinal,
        }
    }
    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        #[allow(deprecated)]
        Self::__Unknown { ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            #[allow(deprecated)]
            Self::__Unknown { .. } => true,
            _ => false,
        }
    }
}

impl fidl::encoding::TopLevel for Union {}

fidl_union! {
    name: Union,
    members: [
        B {
            ty: bool,
            ordinal: 1,
        },
    ],
    unknown_member: __Unknown,
}

#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct ArrayBasic {
    pub array_uint8: [u8; 5],
    pub array_uint16: [u16; 5],
    pub array_uint32: [u32; 5],
    pub array_uint64: [u64; 5],
    pub array_int8: [i8; 5],
    pub array_int16: [i16; 5],
    pub array_int32: [i32; 5],
    pub array_int64: [i64; 5],
    pub array_float32: [f32; 5],
    pub array_float64: [f64; 5],
    pub array_string: [String; 5],
    pub array_opt_string: [Option<String>; 5],
}

impl fidl::encoding::TopLevel for ArrayBasic {}

fidl_struct! {
    name: ArrayBasic,
    members: [
        array_uint8 {
            ty: fidl::encoding::Array<u8, 5>,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        array_uint16 {
            ty: fidl::encoding::Array<u16, 5>,
            index: 1,
            typevar: T1,
            offset_v1: 6,
            offset_v2: 6,
        },
        array_uint32 {
            ty: fidl::encoding::Array<u32, 5>,
            index: 2,
            typevar: T2,
            offset_v1: 16,
            offset_v2: 16,
        },
        array_uint64 {
            ty: fidl::encoding::Array<u64, 5>,
            index: 3,
            typevar: T3,
            offset_v1: 40,
            offset_v2: 40,
        },
        array_int8 {
            ty: fidl::encoding::Array<i8, 5>,
            index: 4,
            typevar: T4,
            offset_v1: 80,
            offset_v2: 80,
        },
        array_int16 {
            ty: fidl::encoding::Array<i16, 5>,
            index: 5,
            typevar: T5,
            offset_v1: 86,
            offset_v2: 86,
        },
        array_int32 {
            ty: fidl::encoding::Array<i32, 5>,
            index: 6,
            typevar: T6,
            offset_v1: 96,
            offset_v2: 96,
        },
        array_int64 {
            ty: fidl::encoding::Array<i64, 5>,
            index: 7,
            typevar: T7,
            offset_v1: 120,
            offset_v2: 120,
        },
        array_float32 {
            ty: fidl::encoding::Array<f32, 5>,
            index: 8,
            typevar: T8,
            offset_v1: 160,
            offset_v2: 160,
        },
        array_float64 {
            ty: fidl::encoding::Array<f64, 5>,
            index: 9,
            typevar: T9,
            offset_v1: 184,
            offset_v2: 184,
        },
        array_string {
            ty: fidl::encoding::Array<fidl::encoding::UnboundedString, 5>,
            index: 10,
            typevar: T10,
            offset_v1: 224,
            offset_v2: 224,
        },
        array_opt_string {
            ty: fidl::encoding::Array<fidl::encoding::Optional<fidl::encoding::UnboundedString>, 5>,
            index: 11,
            typevar: T11,
            offset_v1: 304,
            offset_v2: 304,
        },
    ],
    padding_v1: [
        {
            ty: u64,
            offset: 0,
            mask: 0x0000ff0000000000u64,
        },
        {
            ty: u64,
            offset: 32,
            mask: 0xffffffff00000000u64,
        },
        {
            ty: u64,
            offset: 80,
            mask: 0x0000ff0000000000u64,
        },
        {
            ty: u64,
            offset: 112,
            mask: 0xffffffff00000000u64,
        },
        {
            ty: u64,
            offset: 176,
            mask: 0xffffffff00000000u64,
        },
    ],
    padding_v2: [
        {
            ty: u64,
            offset: 0,
            mask: 0x0000ff0000000000u64,
        },
        {
            ty: u64,
            offset: 32,
            mask: 0xffffffff00000000u64,
        },
        {
            ty: u64,
            offset: 80,
            mask: 0x0000ff0000000000u64,
        },
        {
            ty: u64,
            offset: 112,
            mask: 0xffffffff00000000u64,
        },
        {
            ty: u64,
            offset: 176,
            mask: 0xffffffff00000000u64,
        },
    ],
    size_v1: 384,
    size_v2: 384,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Clone, PartialEq)]
pub struct ArrayCompound {
    pub array_bits: [Bits; 5],
    pub array_enum: [Enum; 5],
    pub array_struct: [Struct; 5],
    pub array_table: [Table; 5],
    pub array_union: [Union; 5],
}

impl fidl::encoding::TopLevel for ArrayCompound {}

fidl_struct! {
    name: ArrayCompound,
    members: [
        array_bits {
            ty: fidl::encoding::Array<Bits, 5>,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        array_enum {
            ty: fidl::encoding::Array<Enum, 5>,
            index: 1,
            typevar: T1,
            offset_v1: 20,
            offset_v2: 20,
        },
        array_struct {
            ty: fidl::encoding::Array<Struct, 5>,
            index: 2,
            typevar: T2,
            offset_v1: 40,
            offset_v2: 40,
        },
        array_table {
            ty: fidl::encoding::Array<Table, 5>,
            index: 3,
            typevar: T3,
            offset_v1: 48,
            offset_v2: 48,
        },
        array_union {
            ty: fidl::encoding::Array<Union, 5>,
            index: 4,
            typevar: T4,
            offset_v1: 128,
            offset_v2: 128,
        },
    ],
    padding_v1: [
        {
            ty: u64,
            offset: 40,
            mask: 0xffffff0000000000u64,
        },
    ],
    padding_v2: [
        {
            ty: u64,
            offset: 40,
            mask: 0xffffff0000000000u64,
        },
    ],
    size_v1: 408,
    size_v2: 328,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ArrayVectorNested {
    pub vector_array_uint8: Vec<[u8; 5]>,
    pub vector_vector_uint8: Vec<Vec<u8>>,
}

impl fidl::encoding::TopLevel for ArrayVectorNested {}

fidl_struct! {
    name: ArrayVectorNested,
    members: [
        vector_array_uint8 {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::Array<u8, 5>>,
            index: 0,
            typevar: T0,
            offset_v1: 112,
            offset_v2: 112,
        },
        vector_vector_uint8 {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::UnboundedVector<u8>>,
            index: 1,
            typevar: T1,
            offset_v1: 128,
            offset_v2: 128,
        },
    ],
    padding_v1: [
    ],
    padding_v2: [
    ],
    size_v1: 144,
    size_v2: 144,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Basic {
    pub uint8: u8,
    pub uint16: u16,
    pub uint32: u32,
    pub uint64: u64,
    pub int8: i8,
    pub int16: i16,
    pub int32: i32,
    pub int64: i64,
    pub float32: f32,
    pub float64: f64,
    pub string: String,
    pub opt_string: Option<String>,
}

impl fidl::encoding::TopLevel for Basic {}

fidl_struct! {
    name: Basic,
    members: [
        uint8 {
            ty: u8,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        uint16 {
            ty: u16,
            index: 1,
            typevar: T1,
            offset_v1: 2,
            offset_v2: 2,
        },
        uint32 {
            ty: u32,
            index: 2,
            typevar: T2,
            offset_v1: 4,
            offset_v2: 4,
        },
        uint64 {
            ty: u64,
            index: 3,
            typevar: T3,
            offset_v1: 8,
            offset_v2: 8,
        },
        int8 {
            ty: i8,
            index: 4,
            typevar: T4,
            offset_v1: 16,
            offset_v2: 16,
        },
        int16 {
            ty: i16,
            index: 5,
            typevar: T5,
            offset_v1: 18,
            offset_v2: 18,
        },
        int32 {
            ty: i32,
            index: 6,
            typevar: T6,
            offset_v1: 20,
            offset_v2: 20,
        },
        int64 {
            ty: i64,
            index: 7,
            typevar: T7,
            offset_v1: 24,
            offset_v2: 24,
        },
        float32 {
            ty: f32,
            index: 8,
            typevar: T8,
            offset_v1: 32,
            offset_v2: 32,
        },
        float64 {
            ty: f64,
            index: 9,
            typevar: T9,
            offset_v1: 40,
            offset_v2: 40,
        },
        string {
            ty: fidl::encoding::UnboundedString,
            index: 10,
            typevar: T10,
            offset_v1: 48,
            offset_v2: 48,
        },
        opt_string {
            ty: fidl::encoding::Optional<fidl::encoding::UnboundedString>,
            index: 11,
            typevar: T11,
            offset_v1: 64,
            offset_v2: 64,
        },
    ],
    padding_v1: [
        {
            ty: u64,
            offset: 0,
            mask: 0x000000000000ff00u64,
        },
        {
            ty: u64,
            offset: 16,
            mask: 0x000000000000ff00u64,
        },
        {
            ty: u64,
            offset: 32,
            mask: 0xffffffff00000000u64,
        },
    ],
    padding_v2: [
        {
            ty: u64,
            offset: 0,
            mask: 0x000000000000ff00u64,
        },
        {
            ty: u64,
            offset: 16,
            mask: 0x000000000000ff00u64,
        },
        {
            ty: u64,
            offset: 32,
            mask: 0xffffffff00000000u64,
        },
    ],
    size_v1: 80,
    size_v2: 80,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Compound {
    pub bits: Bits,
    pub enum_: Enum,
    pub struct_: Struct,
    pub table: Table,
    pub union: Union,
    pub opt_struct: Option<Box<Struct>>,
    pub opt_union: Option<Box<Union>>,
}

impl fidl::encoding::TopLevel for Compound {}

fidl_struct! {
    name: Compound,
    members: [
        bits {
            ty: Bits,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        enum_ {
            ty: Enum,
            index: 1,
            typevar: T1,
            offset_v1: 4,
            offset_v2: 4,
        },
        struct_ {
            ty: Struct,
            index: 2,
            typevar: T2,
            offset_v1: 8,
            offset_v2: 8,
        },
        table {
            ty: Table,
            index: 3,
            typevar: T3,
            offset_v1: 16,
            offset_v2: 16,
        },
        union {
            ty: Union,
            index: 4,
            typevar: T4,
            offset_v1: 32,
            offset_v2: 32,
        },
        opt_struct {
            ty: fidl::encoding::Boxed<Struct>,
            index: 5,
            typevar: T5,
            offset_v1: 56,
            offset_v2: 48,
        },
        opt_union {
            ty: fidl::encoding::OptionalUnion<Union>,
            index: 6,
            typevar: T6,
            offset_v1: 64,
            offset_v2: 56,
        },
    ],
    padding_v1: [
        {
            ty: u64,
            offset: 8,
            mask: 0xffffffffffffff00u64,
        },
    ],
    padding_v2: [
        {
            ty: u64,
            offset: 8,
            mask: 0xffffffffffffff00u64,
        },
    ],
    size_v1: 88,
    size_v2: 72,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Struct;

impl fidl::encoding::TopLevel for Struct {}

fidl_struct! {
    empty: true,
    name: Struct,
}

#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct VectorBasic {
    pub vector_uint8: Vec<u8>,
    pub vector_uint16: Vec<u16>,
    pub vector_uint32: Vec<u32>,
    pub vector_uint64: Vec<u64>,
    pub vector_int8: Vec<i8>,
    pub vector_int16: Vec<i16>,
    pub vector_int32: Vec<i32>,
    pub vector_int64: Vec<i64>,
    pub vector_float32: Vec<f32>,
    pub vector_float64: Vec<f64>,
    pub vector_string: Vec<String>,
    pub vector_opt_string: Vec<Option<String>>,
}

impl fidl::encoding::TopLevel for VectorBasic {}

fidl_struct! {
    name: VectorBasic,
    members: [
        vector_uint8 {
            ty: fidl::encoding::UnboundedVector<u8>,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        vector_uint16 {
            ty: fidl::encoding::UnboundedVector<u16>,
            index: 1,
            typevar: T1,
            offset_v1: 16,
            offset_v2: 16,
        },
        vector_uint32 {
            ty: fidl::encoding::UnboundedVector<u32>,
            index: 2,
            typevar: T2,
            offset_v1: 32,
            offset_v2: 32,
        },
        vector_uint64 {
            ty: fidl::encoding::UnboundedVector<u64>,
            index: 3,
            typevar: T3,
            offset_v1: 48,
            offset_v2: 48,
        },
        vector_int8 {
            ty: fidl::encoding::UnboundedVector<i8>,
            index: 4,
            typevar: T4,
            offset_v1: 64,
            offset_v2: 64,
        },
        vector_int16 {
            ty: fidl::encoding::UnboundedVector<i16>,
            index: 5,
            typevar: T5,
            offset_v1: 80,
            offset_v2: 80,
        },
        vector_int32 {
            ty: fidl::encoding::UnboundedVector<i32>,
            index: 6,
            typevar: T6,
            offset_v1: 96,
            offset_v2: 96,
        },
        vector_int64 {
            ty: fidl::encoding::UnboundedVector<i64>,
            index: 7,
            typevar: T7,
            offset_v1: 112,
            offset_v2: 112,
        },
        vector_float32 {
            ty: fidl::encoding::UnboundedVector<f32>,
            index: 8,
            typevar: T8,
            offset_v1: 128,
            offset_v2: 128,
        },
        vector_float64 {
            ty: fidl::encoding::UnboundedVector<f64>,
            index: 9,
            typevar: T9,
            offset_v1: 144,
            offset_v2: 144,
        },
        vector_string {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>,
            index: 10,
            typevar: T10,
            offset_v1: 160,
            offset_v2: 160,
        },
        vector_opt_string {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::Optional<fidl::encoding::UnboundedString>>,
            index: 11,
            typevar: T11,
            offset_v1: 176,
            offset_v2: 176,
        },
    ],
    padding_v1: [
    ],
    padding_v2: [
    ],
    size_v1: 192,
    size_v2: 192,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Clone, PartialEq)]
pub struct VectorCompound {
    pub vector_bits: Vec<Bits>,
    pub vector_enum: Vec<Enum>,
    pub vector_struct: Vec<Struct>,
    pub vector_table: Vec<Table>,
    pub vector_union: Vec<Union>,
    pub vector_opt_struct: Vec<Option<Box<Struct>>>,
    pub vector_opt_union: Vec<Option<Box<Union>>>,
}

impl fidl::encoding::TopLevel for VectorCompound {}

fidl_struct! {
    name: VectorCompound,
    members: [
        vector_bits {
            ty: fidl::encoding::UnboundedVector<Bits>,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        vector_enum {
            ty: fidl::encoding::UnboundedVector<Enum>,
            index: 1,
            typevar: T1,
            offset_v1: 16,
            offset_v2: 16,
        },
        vector_struct {
            ty: fidl::encoding::UnboundedVector<Struct>,
            index: 2,
            typevar: T2,
            offset_v1: 32,
            offset_v2: 32,
        },
        vector_table {
            ty: fidl::encoding::UnboundedVector<Table>,
            index: 3,
            typevar: T3,
            offset_v1: 48,
            offset_v2: 48,
        },
        vector_union {
            ty: fidl::encoding::UnboundedVector<Union>,
            index: 4,
            typevar: T4,
            offset_v1: 64,
            offset_v2: 64,
        },
        vector_opt_struct {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>,
            index: 5,
            typevar: T5,
            offset_v1: 80,
            offset_v2: 80,
        },
        vector_opt_union {
            ty: fidl::encoding::UnboundedVector<fidl::encoding::OptionalUnion<Union>>,
            index: 6,
            typevar: T6,
            offset_v1: 96,
            offset_v2: 96,
        },
    ],
    padding_v1: [
    ],
    padding_v2: [
    ],
    size_v1: 112,
    size_v2: 112,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct VectorOptional {
    pub opt_vector_uint8: Option<Vec<u8>>,
    pub opt_vector_string: Option<Vec<String>>,
    pub opt_vector_struct: Option<Vec<Struct>>,
    pub opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
}

impl fidl::encoding::TopLevel for VectorOptional {}

fidl_struct! {
    name: VectorOptional,
    members: [
        opt_vector_uint8 {
            ty: fidl::encoding::Optional<fidl::encoding::UnboundedVector<u8>>,
            index: 0,
            typevar: T0,
            offset_v1: 0,
            offset_v2: 0,
        },
        opt_vector_string {
            ty: fidl::encoding::Optional<fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>>,
            index: 1,
            typevar: T1,
            offset_v1: 16,
            offset_v2: 16,
        },
        opt_vector_struct {
            ty: fidl::encoding::Optional<fidl::encoding::UnboundedVector<Struct>>,
            index: 2,
            typevar: T2,
            offset_v1: 32,
            offset_v2: 32,
        },
        opt_vector_opt_struct {
            ty: fidl::encoding::Optional<fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>>,
            index: 3,
            typevar: T3,
            offset_v1: 48,
            offset_v2: 48,
        },
    ],
    padding_v1: [
    ],
    padding_v2: [
    ],
    size_v1: 64,
    size_v2: 64,
    align_v1: 8,
    align_v2: 8,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Table {
    #[deprecated = "Use `..Table::EMPTY` to construct and `..` to match."]
    #[doc(hidden)]
    pub __non_exhaustive: (),
}

impl Table {
    /// An empty table with every field set to `None`.
    #[allow(deprecated)]
    pub const EMPTY: Self = Self { __non_exhaustive: () };
}

impl fidl::encoding::TopLevel for Table {}

fidl_table! {
    name: Table,
    members: [
    ],
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ProtocolMarker;

impl fidl::endpoints::ProtocolMarker for ProtocolMarker {
    type Proxy = ProtocolProxy;
    type RequestStream = ProtocolRequestStream;
    const DEBUG_NAME: &'static str = "(anonymous) Protocol";
}

pub trait ProtocolProxyInterface: Send + Sync {
    fn r#one_way_basic(
        &self,
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: &str,
        opt_string: Option<&str>,
    ) -> Result<(), fidl::Error>;
    type TwoWayBasicResponseFut: std::future::Future<
            Output = Result<
                (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_basic(
        &self,
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: &str,
        opt_string: Option<&str>,
    ) -> Self::TwoWayBasicResponseFut;
    fn r#one_way_compound(
        &self,
        bits: Bits,
        enum_: Enum,
        struct_: &mut Struct,
        table: Table,
        union: &mut Union,
        opt_struct: Option<&mut Struct>,
        opt_union: Option<&mut Union>,
    ) -> Result<(), fidl::Error>;
    type TwoWayCompoundResponseFut: std::future::Future<
            Output = Result<
                (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_compound(
        &self,
        bits: Bits,
        enum_: Enum,
        struct_: &mut Struct,
        table: Table,
        union: &mut Union,
        opt_struct: Option<&mut Struct>,
        opt_union: Option<&mut Union>,
    ) -> Self::TwoWayCompoundResponseFut;
    fn r#one_way_array_basic(
        &self,
        array_uint8: &mut [u8; 5],
        array_uint16: &mut [u16; 5],
        array_uint32: &mut [u32; 5],
        array_uint64: &mut [u64; 5],
        array_int8: &mut [i8; 5],
        array_int16: &mut [i16; 5],
        array_int32: &mut [i32; 5],
        array_int64: &mut [i64; 5],
        array_float32: &mut [f32; 5],
        array_float64: &mut [f64; 5],
        array_string: &mut [&str; 5],
        array_opt_string: &mut [Option<&str>; 5],
    ) -> Result<(), fidl::Error>;
    type TwoWayArrayBasicResponseFut: std::future::Future<
            Output = Result<
                (
                    [u8; 5],
                    [u16; 5],
                    [u32; 5],
                    [u64; 5],
                    [i8; 5],
                    [i16; 5],
                    [i32; 5],
                    [i64; 5],
                    [f32; 5],
                    [f64; 5],
                    [String; 5],
                    [Option<String>; 5],
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_array_basic(
        &self,
        array_uint8: &mut [u8; 5],
        array_uint16: &mut [u16; 5],
        array_uint32: &mut [u32; 5],
        array_uint64: &mut [u64; 5],
        array_int8: &mut [i8; 5],
        array_int16: &mut [i16; 5],
        array_int32: &mut [i32; 5],
        array_int64: &mut [i64; 5],
        array_float32: &mut [f32; 5],
        array_float64: &mut [f64; 5],
        array_string: &mut [&str; 5],
        array_opt_string: &mut [Option<&str>; 5],
    ) -> Self::TwoWayArrayBasicResponseFut;
    fn r#one_way_array_compound(
        &self,
        array_bits: &mut [Bits; 5],
        array_enum: &mut [Enum; 5],
        array_struct: &mut [&mut Struct; 5],
        array_table: &mut [Table; 5],
        array_union: &mut [&mut Union; 5],
    ) -> Result<(), fidl::Error>;
    type TwoWayArrayCompoundResponseFut: std::future::Future<
            Output = Result<
                ([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_array_compound(
        &self,
        array_bits: &mut [Bits; 5],
        array_enum: &mut [Enum; 5],
        array_struct: &mut [&mut Struct; 5],
        array_table: &mut [Table; 5],
        array_union: &mut [&mut Union; 5],
    ) -> Self::TwoWayArrayCompoundResponseFut;
    fn r#one_way_vector_basic(
        &self,
        vector_uint8: &[u8],
        vector_uint16: &[u16],
        vector_uint32: &[u32],
        vector_uint64: &[u64],
        vector_int8: &[i8],
        vector_int16: &[i16],
        vector_int32: &[i32],
        vector_int64: &[i64],
        vector_float32: &[f32],
        vector_float64: &[f64],
        vector_string: &mut dyn ExactSizeIterator<Item = &str>,
        vector_opt_string: &mut dyn ExactSizeIterator<Item = Option<&str>>,
    ) -> Result<(), fidl::Error>;
    type TwoWayVectorBasicResponseFut: std::future::Future<
            Output = Result<
                (
                    Vec<u8>,
                    Vec<u16>,
                    Vec<u32>,
                    Vec<u64>,
                    Vec<i8>,
                    Vec<i16>,
                    Vec<i32>,
                    Vec<i64>,
                    Vec<f32>,
                    Vec<f64>,
                    Vec<String>,
                    Vec<Option<String>>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_vector_basic(
        &self,
        vector_uint8: &[u8],
        vector_uint16: &[u16],
        vector_uint32: &[u32],
        vector_uint64: &[u64],
        vector_int8: &[i8],
        vector_int16: &[i16],
        vector_int32: &[i32],
        vector_int64: &[i64],
        vector_float32: &[f32],
        vector_float64: &[f64],
        vector_string: &mut dyn ExactSizeIterator<Item = &str>,
        vector_opt_string: &mut dyn ExactSizeIterator<Item = Option<&str>>,
    ) -> Self::TwoWayVectorBasicResponseFut;
    fn r#one_way_vector_compound(
        &self,
        vector_bits: &mut dyn ExactSizeIterator<Item = Bits>,
        vector_enum: &mut dyn ExactSizeIterator<Item = Enum>,
        vector_struct: &mut dyn ExactSizeIterator<Item = &mut Struct>,
        vector_table: &mut dyn ExactSizeIterator<Item = Table>,
        vector_union: &mut dyn ExactSizeIterator<Item = &mut Union>,
        vector_opt_struct: &mut dyn ExactSizeIterator<Item = Option<&mut Struct>>,
        vector_opt_union: &mut dyn ExactSizeIterator<Item = Option<&mut Union>>,
    ) -> Result<(), fidl::Error>;
    type TwoWayVectorCompoundResponseFut: std::future::Future<
            Output = Result<
                (
                    Vec<Bits>,
                    Vec<Enum>,
                    Vec<Struct>,
                    Vec<Table>,
                    Vec<Union>,
                    Vec<Option<Box<Struct>>>,
                    Vec<Option<Box<Union>>>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_vector_compound(
        &self,
        vector_bits: &mut dyn ExactSizeIterator<Item = Bits>,
        vector_enum: &mut dyn ExactSizeIterator<Item = Enum>,
        vector_struct: &mut dyn ExactSizeIterator<Item = &mut Struct>,
        vector_table: &mut dyn ExactSizeIterator<Item = Table>,
        vector_union: &mut dyn ExactSizeIterator<Item = &mut Union>,
        vector_opt_struct: &mut dyn ExactSizeIterator<Item = Option<&mut Struct>>,
        vector_opt_union: &mut dyn ExactSizeIterator<Item = Option<&mut Union>>,
    ) -> Self::TwoWayVectorCompoundResponseFut;
    fn r#one_way_vector_optional(
        &self,
        opt_vector_uint8: Option<&[u8]>,
        opt_vector_string: Option<&mut dyn ExactSizeIterator<Item = &str>>,
        opt_vector_struct: Option<&mut dyn ExactSizeIterator<Item = &mut Struct>>,
        opt_vector_opt_struct: Option<&mut dyn ExactSizeIterator<Item = Option<&mut Struct>>>,
    ) -> Result<(), fidl::Error>;
    type TwoWayVectorOptionalResponseFut: std::future::Future<
            Output = Result<
                (
                    Option<Vec<u8>>,
                    Option<Vec<String>>,
                    Option<Vec<Struct>>,
                    Option<Vec<Option<Box<Struct>>>>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_vector_optional(
        &self,
        opt_vector_uint8: Option<&[u8]>,
        opt_vector_string: Option<&mut dyn ExactSizeIterator<Item = &str>>,
        opt_vector_struct: Option<&mut dyn ExactSizeIterator<Item = &mut Struct>>,
        opt_vector_opt_struct: Option<&mut dyn ExactSizeIterator<Item = Option<&mut Struct>>>,
    ) -> Self::TwoWayVectorOptionalResponseFut;
    fn r#one_way_array_vector_nested(
        &self,
        vector_array_uint8: &mut dyn ExactSizeIterator<Item = &mut [u8; 5]>,
        vector_vector_uint8: &mut dyn ExactSizeIterator<Item = &[u8]>,
    ) -> Result<(), fidl::Error>;
    type TwoWayArrayVectorNestedResponseFut: std::future::Future<Output = Result<(Vec<[u8; 5]>, Vec<Vec<u8>>), fidl::Error>>
        + Send;
    fn r#two_way_array_vector_nested(
        &self,
        vector_array_uint8: &mut dyn ExactSizeIterator<Item = &mut [u8; 5]>,
        vector_vector_uint8: &mut dyn ExactSizeIterator<Item = &[u8]>,
    ) -> Self::TwoWayArrayVectorNestedResponseFut;
}

#[derive(Debug)]
#[cfg(target_os = "fuchsia")]
pub struct ProtocolSynchronousProxy {
    client: fidl::client::sync::Client,
}

#[cfg(target_os = "fuchsia")]
impl ProtocolSynchronousProxy {
    pub fn new(channel: fidl::Channel) -> Self {
        let protocol_name = <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME;
        Self { client: fidl::client::sync::Client::new(channel, protocol_name) }
    }

    pub fn into_channel(self) -> fidl::Channel {
        self.client.into_channel()
    }

    /// Waits until an event arrives and returns it. It is safe for other
    /// threads to make concurrent requests while waiting for an event.
    pub fn wait_for_event(&self, deadline: zx::Time) -> Result<ProtocolEvent, fidl::Error> {
        ProtocolEvent::decode(self.client.wait_for_event(deadline)?)
    }
    pub fn r#one_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Basic, false>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0x7c311f0d9e662df9,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
        ___deadline: zx::Time,
    ) -> Result<(u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>), fidl::Error>
    {
        let _response = self.client.send_query::<Basic, Basic, false, true>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0x205b92db5139c88f,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.uint8,
            _response.uint16,
            _response.uint32,
            _response.uint64,
            _response.int8,
            _response.int16,
            _response.int32,
            _response.int64,
            _response.float32,
            _response.float64,
            _response.string,
            _response.opt_string,
        ))
    }
    pub fn r#one_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &mut Struct,
        mut table: Table,
        mut union: &mut Union,
        mut opt_struct: Option<&mut Struct>,
        mut opt_union: Option<&mut Union>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Compound, false>(
            (
                bits,
                enum_,
                &*struct_,
                &table,
                &*union,
                opt_struct.map(|x| &*x),
                opt_union.map(|x| &*x),
            ),
            0x2bc2bc3a9237c6cc,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &mut Struct,
        mut table: Table,
        mut union: &mut Union,
        mut opt_struct: Option<&mut Struct>,
        mut opt_union: Option<&mut Union>,
        ___deadline: zx::Time,
    ) -> Result<
        (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
        fidl::Error,
    > {
        let _response = self.client.send_query::<Compound, Compound, false, true>(
            (
                bits,
                enum_,
                &*struct_,
                &table,
                &*union,
                opt_struct.map(|x| &*x),
                opt_union.map(|x| &*x),
            ),
            0x79f279c7201da131,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.bits,
            _response.enum_,
            _response.struct_,
            _response.table,
            _response.union,
            _response.opt_struct,
            _response.opt_union,
        ))
    }
    pub fn r#one_way_array_basic(
        &self,
        mut array_uint8: &mut [u8; 5],
        mut array_uint16: &mut [u16; 5],
        mut array_uint32: &mut [u32; 5],
        mut array_uint64: &mut [u64; 5],
        mut array_int8: &mut [i8; 5],
        mut array_int16: &mut [i16; 5],
        mut array_int32: &mut [i32; 5],
        mut array_int64: &mut [i64; 5],
        mut array_float32: &mut [f32; 5],
        mut array_float64: &mut [f64; 5],
        mut array_string: &mut [&str; 5],
        mut array_opt_string: &mut [Option<&str>; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayBasic, false>(
            (
                &*array_uint8,
                &*array_uint16,
                &*array_uint32,
                &*array_uint64,
                &*array_int8,
                &*array_int16,
                &*array_int32,
                &*array_int64,
                &*array_float32,
                &*array_float64,
                &{
                    let mut temp: [String; 5] =
                        fidl::new_empty!(fidl::encoding::Array<fidl::encoding::UnboundedString, 5>);
                    for (i, x) in array_string.iter_mut().enumerate() {
                        temp[i] = x.to_string();
                    }
                    temp
                },
                &{
                    let mut temp: [Option<String>; 5] = fidl::new_empty!(
                        fidl::encoding::Array<
                            fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                            5,
                        >
                    );
                    for (i, x) in array_opt_string.iter_mut().enumerate() {
                        temp[i] = x.map(str::to_string);
                    }
                    temp
                },
            ),
            0x62e2ebcadf35ca19,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_array_basic(
        &self,
        mut array_uint8: &mut [u8; 5],
        mut array_uint16: &mut [u16; 5],
        mut array_uint32: &mut [u32; 5],
        mut array_uint64: &mut [u64; 5],
        mut array_int8: &mut [i8; 5],
        mut array_int16: &mut [i16; 5],
        mut array_int32: &mut [i32; 5],
        mut array_int64: &mut [i64; 5],
        mut array_float32: &mut [f32; 5],
        mut array_float64: &mut [f64; 5],
        mut array_string: &mut [&str; 5],
        mut array_opt_string: &mut [Option<&str>; 5],
        ___deadline: zx::Time,
    ) -> Result<
        (
            [u8; 5],
            [u16; 5],
            [u32; 5],
            [u64; 5],
            [i8; 5],
            [i16; 5],
            [i32; 5],
            [i64; 5],
            [f32; 5],
            [f64; 5],
            [String; 5],
            [Option<String>; 5],
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<ArrayBasic, ArrayBasic, false, true>(
            (
                &*array_uint8,
                &*array_uint16,
                &*array_uint32,
                &*array_uint64,
                &*array_int8,
                &*array_int16,
                &*array_int32,
                &*array_int64,
                &*array_float32,
                &*array_float64,
                &{
                    let mut temp: [String; 5] =
                        fidl::new_empty!(fidl::encoding::Array<fidl::encoding::UnboundedString, 5>);
                    for (i, x) in array_string.iter_mut().enumerate() {
                        temp[i] = x.to_string();
                    }
                    temp
                },
                &{
                    let mut temp: [Option<String>; 5] = fidl::new_empty!(
                        fidl::encoding::Array<
                            fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                            5,
                        >
                    );
                    for (i, x) in array_opt_string.iter_mut().enumerate() {
                        temp[i] = x.map(str::to_string);
                    }
                    temp
                },
            ),
            0x49ad7a74e28ba114,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.array_uint8,
            _response.array_uint16,
            _response.array_uint32,
            _response.array_uint64,
            _response.array_int8,
            _response.array_int16,
            _response.array_int32,
            _response.array_int64,
            _response.array_float32,
            _response.array_float64,
            _response.array_string,
            _response.array_opt_string,
        ))
    }
    pub fn r#one_way_array_compound(
        &self,
        mut array_bits: &mut [Bits; 5],
        mut array_enum: &mut [Enum; 5],
        mut array_struct: &mut [&mut Struct; 5],
        mut array_table: &mut [Table; 5],
        mut array_union: &mut [&mut Union; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayCompound, false>(
            (
                &*array_bits,
                &*array_enum,
                &{
                    let mut temp: [Struct; 5] = fidl::new_empty!(fidl::encoding::Array<Struct, 5>);
                    for (i, x) in array_struct.iter_mut().enumerate() {
                        temp[i] = x.clone();
                    }
                    temp
                },
                &*array_table,
                &{
                    let mut temp: [Union; 5] = fidl::new_empty!(fidl::encoding::Array<Union, 5>);
                    for (i, x) in array_union.iter_mut().enumerate() {
                        temp[i] = x.clone();
                    }
                    temp
                },
            ),
            0x464948bae1bda09d,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_array_compound(
        &self,
        mut array_bits: &mut [Bits; 5],
        mut array_enum: &mut [Enum; 5],
        mut array_struct: &mut [&mut Struct; 5],
        mut array_table: &mut [Table; 5],
        mut array_union: &mut [&mut Union; 5],
        ___deadline: zx::Time,
    ) -> Result<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]), fidl::Error> {
        let _response = self.client.send_query::<ArrayCompound, ArrayCompound, false, true>(
            (
                &*array_bits,
                &*array_enum,
                &{
                    let mut temp: [Struct; 5] = fidl::new_empty!(fidl::encoding::Array<Struct, 5>);
                    for (i, x) in array_struct.iter_mut().enumerate() {
                        temp[i] = x.clone();
                    }
                    temp
                },
                &*array_table,
                &{
                    let mut temp: [Union; 5] = fidl::new_empty!(fidl::encoding::Array<Union, 5>);
                    for (i, x) in array_union.iter_mut().enumerate() {
                        temp[i] = x.clone();
                    }
                    temp
                },
            ),
            0xbcae616f8e1ea7b,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.array_bits,
            _response.array_enum,
            _response.array_struct,
            _response.array_table,
            _response.array_union,
        ))
    }
    pub fn r#one_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &mut dyn ExactSizeIterator<Item = &str>,
        mut vector_opt_string: &mut dyn ExactSizeIterator<Item = Option<&str>>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorBasic, false>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                fidl::encoding::Iterator(vector_string),
                fidl::encoding::Iterator(vector_opt_string),
            ),
            0x4f907dde77464657,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &mut dyn ExactSizeIterator<Item = &str>,
        mut vector_opt_string: &mut dyn ExactSizeIterator<Item = Option<&str>>,
        ___deadline: zx::Time,
    ) -> Result<
        (
            Vec<u8>,
            Vec<u16>,
            Vec<u32>,
            Vec<u64>,
            Vec<i8>,
            Vec<i16>,
            Vec<i32>,
            Vec<i64>,
            Vec<f32>,
            Vec<f64>,
            Vec<String>,
            Vec<Option<String>>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<VectorBasic, VectorBasic, false, true>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                fidl::encoding::Iterator(vector_string),
                fidl::encoding::Iterator(vector_opt_string),
            ),
            0x7860cb3ed8362e74,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.vector_uint8,
            _response.vector_uint16,
            _response.vector_uint32,
            _response.vector_uint64,
            _response.vector_int8,
            _response.vector_int16,
            _response.vector_int32,
            _response.vector_int64,
            _response.vector_float32,
            _response.vector_float64,
            _response.vector_string,
            _response.vector_opt_string,
        ))
    }
    pub fn r#one_way_vector_compound(
        &self,
        mut vector_bits: &mut dyn ExactSizeIterator<Item = Bits>,
        mut vector_enum: &mut dyn ExactSizeIterator<Item = Enum>,
        mut vector_struct: &mut dyn ExactSizeIterator<Item = &mut Struct>,
        mut vector_table: &mut dyn ExactSizeIterator<Item = Table>,
        mut vector_union: &mut dyn ExactSizeIterator<Item = &mut Union>,
        mut vector_opt_struct: &mut dyn ExactSizeIterator<Item = Option<&mut Struct>>,
        mut vector_opt_union: &mut dyn ExactSizeIterator<Item = Option<&mut Union>>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorCompound, false>(
            (
                fidl::encoding::Iterator(vector_bits),
                fidl::encoding::Iterator(vector_enum),
                fidl::encoding::Iterator(vector_struct.map(|x| &*x)),
                fidl::encoding::Iterator(vector_table),
                fidl::encoding::Iterator(vector_union.map(|x| &*x)),
                fidl::encoding::Iterator(vector_opt_struct.map(|x| x.map(|x| &*x))),
                fidl::encoding::Iterator(vector_opt_union.map(|x| x.map(|x| &*x))),
            ),
            0x19baae42829dbe90,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_vector_compound(
        &self,
        mut vector_bits: &mut dyn ExactSizeIterator<Item = Bits>,
        mut vector_enum: &mut dyn ExactSizeIterator<Item = Enum>,
        mut vector_struct: &mut dyn ExactSizeIterator<Item = &mut Struct>,
        mut vector_table: &mut dyn ExactSizeIterator<Item = Table>,
        mut vector_union: &mut dyn ExactSizeIterator<Item = &mut Union>,
        mut vector_opt_struct: &mut dyn ExactSizeIterator<Item = Option<&mut Struct>>,
        mut vector_opt_union: &mut dyn ExactSizeIterator<Item = Option<&mut Union>>,
        ___deadline: zx::Time,
    ) -> Result<
        (
            Vec<Bits>,
            Vec<Enum>,
            Vec<Struct>,
            Vec<Table>,
            Vec<Union>,
            Vec<Option<Box<Struct>>>,
            Vec<Option<Box<Union>>>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<VectorCompound, VectorCompound, false, true>(
            (
                fidl::encoding::Iterator(vector_bits),
                fidl::encoding::Iterator(vector_enum),
                fidl::encoding::Iterator(vector_struct.map(|x| &*x)),
                fidl::encoding::Iterator(vector_table),
                fidl::encoding::Iterator(vector_union.map(|x| &*x)),
                fidl::encoding::Iterator(vector_opt_struct.map(|x| x.map(|x| &*x))),
                fidl::encoding::Iterator(vector_opt_union.map(|x| x.map(|x| &*x))),
            ),
            0x371140db701b23b4,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.vector_bits,
            _response.vector_enum,
            _response.vector_struct,
            _response.vector_table,
            _response.vector_union,
            _response.vector_opt_struct,
            _response.vector_opt_union,
        ))
    }
    pub fn r#one_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&mut dyn ExactSizeIterator<Item = &str>>,
        mut opt_vector_struct: Option<&mut dyn ExactSizeIterator<Item = &mut Struct>>,
        mut opt_vector_opt_struct: Option<&mut dyn ExactSizeIterator<Item = Option<&mut Struct>>>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorOptional, false>(
            (
                opt_vector_uint8,
                opt_vector_string.map(fidl::encoding::Iterator),
                opt_vector_struct.map(|x| x.map(|x| &*x)).map(fidl::encoding::Iterator),
                opt_vector_opt_struct
                    .map(|x| x.map(|x| x.map(|x| &*x)))
                    .map(fidl::encoding::Iterator),
            ),
            0x153c6b333c21c52f,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&mut dyn ExactSizeIterator<Item = &str>>,
        mut opt_vector_struct: Option<&mut dyn ExactSizeIterator<Item = &mut Struct>>,
        mut opt_vector_opt_struct: Option<&mut dyn ExactSizeIterator<Item = Option<&mut Struct>>>,
        ___deadline: zx::Time,
    ) -> Result<
        (
            Option<Vec<u8>>,
            Option<Vec<String>>,
            Option<Vec<Struct>>,
            Option<Vec<Option<Box<Struct>>>>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<VectorOptional, VectorOptional, false, true>(
            (
                opt_vector_uint8,
                opt_vector_string.map(fidl::encoding::Iterator),
                opt_vector_struct.map(|x| x.map(|x| &*x)).map(fidl::encoding::Iterator),
                opt_vector_opt_struct
                    .map(|x| x.map(|x| x.map(|x| &*x)))
                    .map(fidl::encoding::Iterator),
            ),
            0xe4b620aaafd73f3,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.opt_vector_uint8,
            _response.opt_vector_string,
            _response.opt_vector_struct,
            _response.opt_vector_opt_struct,
        ))
    }
    pub fn r#one_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &mut dyn ExactSizeIterator<Item = &mut [u8; 5]>,
        mut vector_vector_uint8: &mut dyn ExactSizeIterator<Item = &[u8]>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayVectorNested, false>(
            (
                fidl::encoding::Iterator(vector_array_uint8.map(|x| *x)),
                fidl::encoding::Iterator(vector_vector_uint8),
            ),
            0x520dc9cb9b9b5ed7,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn r#two_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &mut dyn ExactSizeIterator<Item = &mut [u8; 5]>,
        mut vector_vector_uint8: &mut dyn ExactSizeIterator<Item = &[u8]>,
        ___deadline: zx::Time,
    ) -> Result<(Vec<[u8; 5]>, Vec<Vec<u8>>), fidl::Error> {
        let _response =
            self.client.send_query::<ArrayVectorNested, ArrayVectorNested, false, true>(
                (
                    fidl::encoding::Iterator(vector_array_uint8.map(|x| *x)),
                    fidl::encoding::Iterator(vector_vector_uint8),
                ),
                0x4a438ce0948817dc,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?;
        Ok((_response.vector_array_uint8, _response.vector_vector_uint8))
    }
}

#[derive(Debug, Clone)]
pub struct ProtocolProxy {
    client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for ProtocolProxy {
    type Protocol = ProtocolMarker;

    fn from_channel(inner: fidl::AsyncChannel) -> Self {
        Self::new(inner)
    }

    fn into_channel(self) -> Result<::fidl::AsyncChannel, Self> {
        self.client.into_channel().map_err(|client| Self { client })
    }

    fn as_channel(&self) -> &::fidl::AsyncChannel {
        self.client.as_channel()
    }
}

impl ProtocolProxy {
    /// Create a new Proxy for Protocol
    pub fn new(channel: fidl::AsyncChannel) -> Self {
        let protocol_name = <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME;
        Self { client: fidl::client::Client::new(channel, protocol_name) }
    }

    /// Get a Stream of events from the remote end of the Protocol protocol
    ///
    /// # Panics
    ///
    /// Panics if the event stream was already taken.
    pub fn take_event_stream(&self) -> ProtocolEventStream {
        ProtocolEventStream { event_receiver: self.client.take_event_receiver() }
    }
    pub fn r#one_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_basic(
            self, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64,
            string, opt_string,
        )
    }
    pub fn r#two_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> fidl::client::QueryResponseFut<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
    )> {
        ProtocolProxyInterface::r#two_way_basic(
            self, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64,
            string, opt_string,
        )
    }
    pub fn r#one_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &mut Struct,
        mut table: Table,
        mut union: &mut Union,
        mut opt_struct: Option<&mut Struct>,
        mut opt_union: Option<&mut Union>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_compound(
            self, bits, enum_, struct_, table, union, opt_struct, opt_union,
        )
    }
    pub fn r#two_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &mut Struct,
        mut table: Table,
        mut union: &mut Union,
        mut opt_struct: Option<&mut Struct>,
        mut opt_union: Option<&mut Union>,
    ) -> fidl::client::QueryResponseFut<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
    )> {
        ProtocolProxyInterface::r#two_way_compound(
            self, bits, enum_, struct_, table, union, opt_struct, opt_union,
        )
    }
    pub fn r#one_way_array_basic(
        &self,
        mut array_uint8: &mut [u8; 5],
        mut array_uint16: &mut [u16; 5],
        mut array_uint32: &mut [u32; 5],
        mut array_uint64: &mut [u64; 5],
        mut array_int8: &mut [i8; 5],
        mut array_int16: &mut [i16; 5],
        mut array_int32: &mut [i32; 5],
        mut array_int64: &mut [i64; 5],
        mut array_float32: &mut [f32; 5],
        mut array_float64: &mut [f64; 5],
        mut array_string: &mut [&str; 5],
        mut array_opt_string: &mut [Option<&str>; 5],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_array_basic(
            self,
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        )
    }
    pub fn r#two_way_array_basic(
        &self,
        mut array_uint8: &mut [u8; 5],
        mut array_uint16: &mut [u16; 5],
        mut array_uint32: &mut [u32; 5],
        mut array_uint64: &mut [u64; 5],
        mut array_int8: &mut [i8; 5],
        mut array_int16: &mut [i16; 5],
        mut array_int32: &mut [i32; 5],
        mut array_int64: &mut [i64; 5],
        mut array_float32: &mut [f32; 5],
        mut array_float64: &mut [f64; 5],
        mut array_string: &mut [&str; 5],
        mut array_opt_string: &mut [Option<&str>; 5],
    ) -> fidl::client::QueryResponseFut<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
    )> {
        ProtocolProxyInterface::r#two_way_array_basic(
            self,
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        )
    }
    pub fn r#one_way_array_compound(
        &self,
        mut array_bits: &mut [Bits; 5],
        mut array_enum: &mut [Enum; 5],
        mut array_struct: &mut [&mut Struct; 5],
        mut array_table: &mut [Table; 5],
        mut array_union: &mut [&mut Union; 5],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_array_compound(
            self,
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
        )
    }
    pub fn r#two_way_array_compound(
        &self,
        mut array_bits: &mut [Bits; 5],
        mut array_enum: &mut [Enum; 5],
        mut array_struct: &mut [&mut Struct; 5],
        mut array_table: &mut [Table; 5],
        mut array_union: &mut [&mut Union; 5],
    ) -> fidl::client::QueryResponseFut<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5])>
    {
        ProtocolProxyInterface::r#two_way_array_compound(
            self,
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
        )
    }
    pub fn r#one_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &mut dyn ExactSizeIterator<Item = &str>,
        mut vector_opt_string: &mut dyn ExactSizeIterator<Item = Option<&str>>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_vector_basic(
            self,
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        )
    }
    pub fn r#two_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &mut dyn ExactSizeIterator<Item = &str>,
        mut vector_opt_string: &mut dyn ExactSizeIterator<Item = Option<&str>>,
    ) -> fidl::client::QueryResponseFut<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
    )> {
        ProtocolProxyInterface::r#two_way_vector_basic(
            self,
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        )
    }
    pub fn r#one_way_vector_compound(
        &self,
        mut vector_bits: &mut dyn ExactSizeIterator<Item = Bits>,
        mut vector_enum: &mut dyn ExactSizeIterator<Item = Enum>,
        mut vector_struct: &mut dyn ExactSizeIterator<Item = &mut Struct>,
        mut vector_table: &mut dyn ExactSizeIterator<Item = Table>,
        mut vector_union: &mut dyn ExactSizeIterator<Item = &mut Union>,
        mut vector_opt_struct: &mut dyn ExactSizeIterator<Item = Option<&mut Struct>>,
        mut vector_opt_union: &mut dyn ExactSizeIterator<Item = Option<&mut Union>>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_vector_compound(
            self,
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        )
    }
    pub fn r#two_way_vector_compound(
        &self,
        mut vector_bits: &mut dyn ExactSizeIterator<Item = Bits>,
        mut vector_enum: &mut dyn ExactSizeIterator<Item = Enum>,
        mut vector_struct: &mut dyn ExactSizeIterator<Item = &mut Struct>,
        mut vector_table: &mut dyn ExactSizeIterator<Item = Table>,
        mut vector_union: &mut dyn ExactSizeIterator<Item = &mut Union>,
        mut vector_opt_struct: &mut dyn ExactSizeIterator<Item = Option<&mut Struct>>,
        mut vector_opt_union: &mut dyn ExactSizeIterator<Item = Option<&mut Union>>,
    ) -> fidl::client::QueryResponseFut<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
    )> {
        ProtocolProxyInterface::r#two_way_vector_compound(
            self,
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        )
    }
    pub fn r#one_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&mut dyn ExactSizeIterator<Item = &str>>,
        mut opt_vector_struct: Option<&mut dyn ExactSizeIterator<Item = &mut Struct>>,
        mut opt_vector_opt_struct: Option<&mut dyn ExactSizeIterator<Item = Option<&mut Struct>>>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_vector_optional(
            self,
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        )
    }
    pub fn r#two_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&mut dyn ExactSizeIterator<Item = &str>>,
        mut opt_vector_struct: Option<&mut dyn ExactSizeIterator<Item = &mut Struct>>,
        mut opt_vector_opt_struct: Option<&mut dyn ExactSizeIterator<Item = Option<&mut Struct>>>,
    ) -> fidl::client::QueryResponseFut<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
    )> {
        ProtocolProxyInterface::r#two_way_vector_optional(
            self,
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        )
    }
    pub fn r#one_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &mut dyn ExactSizeIterator<Item = &mut [u8; 5]>,
        mut vector_vector_uint8: &mut dyn ExactSizeIterator<Item = &[u8]>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_array_vector_nested(
            self,
            vector_array_uint8,
            vector_vector_uint8,
        )
    }
    pub fn r#two_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &mut dyn ExactSizeIterator<Item = &mut [u8; 5]>,
        mut vector_vector_uint8: &mut dyn ExactSizeIterator<Item = &[u8]>,
    ) -> fidl::client::QueryResponseFut<(Vec<[u8; 5]>, Vec<Vec<u8>>)> {
        ProtocolProxyInterface::r#two_way_array_vector_nested(
            self,
            vector_array_uint8,
            vector_vector_uint8,
        )
    }
}

impl ProtocolProxyInterface for ProtocolProxy {
    fn r#one_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Basic, false>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0x7c311f0d9e662df9,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayBasicResponseFut = fidl::client::QueryResponseFut<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
    )>;
    fn r#two_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Self::TwoWayBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<Basic, true>(_buf?)?;
            Ok((
                _response.uint8,
                _response.uint16,
                _response.uint32,
                _response.uint64,
                _response.int8,
                _response.int16,
                _response.int32,
                _response.int64,
                _response.float32,
                _response.float64,
                _response.string,
                _response.opt_string,
            ))
        }
        self.client.send_query_and_decode::<
            Basic,
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
            false,
        >(
            (uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string,),
            0x205b92db5139c88f,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    fn r#one_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &mut Struct,
        mut table: Table,
        mut union: &mut Union,
        mut opt_struct: Option<&mut Struct>,
        mut opt_union: Option<&mut Union>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Compound, false>(
            (
                bits,
                enum_,
                &*struct_,
                &table,
                &*union,
                opt_struct.map(|x| &*x),
                opt_union.map(|x| &*x),
            ),
            0x2bc2bc3a9237c6cc,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayCompoundResponseFut = fidl::client::QueryResponseFut<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
    )>;
    fn r#two_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &mut Struct,
        mut table: Table,
        mut union: &mut Union,
        mut opt_struct: Option<&mut Struct>,
        mut opt_union: Option<&mut Union>,
    ) -> Self::TwoWayCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<Compound, true>(_buf?)?;
            Ok((
                _response.bits,
                _response.enum_,
                _response.struct_,
                _response.table,
                _response.union,
                _response.opt_struct,
                _response.opt_union,
            ))
        }
        self.client.send_query_and_decode::<
            Compound,
            (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
            false,
        >(
            (bits, enum_, &*struct_, &table, &*union, opt_struct.map(|x| &*x), opt_union.map(|x| &*x),),
            0x79f279c7201da131,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    fn r#one_way_array_basic(
        &self,
        mut array_uint8: &mut [u8; 5],
        mut array_uint16: &mut [u16; 5],
        mut array_uint32: &mut [u32; 5],
        mut array_uint64: &mut [u64; 5],
        mut array_int8: &mut [i8; 5],
        mut array_int16: &mut [i16; 5],
        mut array_int32: &mut [i32; 5],
        mut array_int64: &mut [i64; 5],
        mut array_float32: &mut [f32; 5],
        mut array_float64: &mut [f64; 5],
        mut array_string: &mut [&str; 5],
        mut array_opt_string: &mut [Option<&str>; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayBasic, false>(
            (
                &*array_uint8,
                &*array_uint16,
                &*array_uint32,
                &*array_uint64,
                &*array_int8,
                &*array_int16,
                &*array_int32,
                &*array_int64,
                &*array_float32,
                &*array_float64,
                &{
                    let mut temp: [String; 5] =
                        fidl::new_empty!(fidl::encoding::Array<fidl::encoding::UnboundedString, 5>);
                    for (i, x) in array_string.iter_mut().enumerate() {
                        temp[i] = x.to_string();
                    }
                    temp
                },
                &{
                    let mut temp: [Option<String>; 5] = fidl::new_empty!(
                        fidl::encoding::Array<
                            fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                            5,
                        >
                    );
                    for (i, x) in array_opt_string.iter_mut().enumerate() {
                        temp[i] = x.map(str::to_string);
                    }
                    temp
                },
            ),
            0x62e2ebcadf35ca19,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayArrayBasicResponseFut = fidl::client::QueryResponseFut<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
    )>;
    fn r#two_way_array_basic(
        &self,
        mut array_uint8: &mut [u8; 5],
        mut array_uint16: &mut [u16; 5],
        mut array_uint32: &mut [u32; 5],
        mut array_uint64: &mut [u64; 5],
        mut array_int8: &mut [i8; 5],
        mut array_int16: &mut [i16; 5],
        mut array_int32: &mut [i32; 5],
        mut array_int64: &mut [i64; 5],
        mut array_float32: &mut [f32; 5],
        mut array_float64: &mut [f64; 5],
        mut array_string: &mut [&str; 5],
        mut array_opt_string: &mut [Option<&str>; 5],
    ) -> Self::TwoWayArrayBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                [u8; 5],
                [u16; 5],
                [u32; 5],
                [u64; 5],
                [i8; 5],
                [i16; 5],
                [i32; 5],
                [i64; 5],
                [f32; 5],
                [f64; 5],
                [String; 5],
                [Option<String>; 5],
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<ArrayBasic, true>(_buf?)?;
            Ok((
                _response.array_uint8,
                _response.array_uint16,
                _response.array_uint32,
                _response.array_uint64,
                _response.array_int8,
                _response.array_int16,
                _response.array_int32,
                _response.array_int64,
                _response.array_float32,
                _response.array_float64,
                _response.array_string,
                _response.array_opt_string,
            ))
        }
        self.client.send_query_and_decode::<ArrayBasic, (
            [u8; 5],
            [u16; 5],
            [u32; 5],
            [u64; 5],
            [i8; 5],
            [i16; 5],
            [i32; 5],
            [i64; 5],
            [f32; 5],
            [f64; 5],
            [String; 5],
            [Option<String>; 5],
        ), false>(
            (
                &*array_uint8,
                &*array_uint16,
                &*array_uint32,
                &*array_uint64,
                &*array_int8,
                &*array_int16,
                &*array_int32,
                &*array_int64,
                &*array_float32,
                &*array_float64,
                &{
                    let mut temp: [String; 5] =
                        fidl::new_empty!(fidl::encoding::Array<fidl::encoding::UnboundedString, 5>);
                    for (i, x) in array_string.iter_mut().enumerate() {
                        temp[i] = x.to_string();
                    }
                    temp
                },
                &{
                    let mut temp: [Option<String>; 5] = fidl::new_empty!(
                        fidl::encoding::Array<
                            fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                            5,
                        >
                    );
                    for (i, x) in array_opt_string.iter_mut().enumerate() {
                        temp[i] = x.map(str::to_string);
                    }
                    temp
                },
            ),
            0x49ad7a74e28ba114,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    fn r#one_way_array_compound(
        &self,
        mut array_bits: &mut [Bits; 5],
        mut array_enum: &mut [Enum; 5],
        mut array_struct: &mut [&mut Struct; 5],
        mut array_table: &mut [Table; 5],
        mut array_union: &mut [&mut Union; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayCompound, false>(
            (
                &*array_bits,
                &*array_enum,
                &{
                    let mut temp: [Struct; 5] = fidl::new_empty!(fidl::encoding::Array<Struct, 5>);
                    for (i, x) in array_struct.iter_mut().enumerate() {
                        temp[i] = x.clone();
                    }
                    temp
                },
                &*array_table,
                &{
                    let mut temp: [Union; 5] = fidl::new_empty!(fidl::encoding::Array<Union, 5>);
                    for (i, x) in array_union.iter_mut().enumerate() {
                        temp[i] = x.clone();
                    }
                    temp
                },
            ),
            0x464948bae1bda09d,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayArrayCompoundResponseFut =
        fidl::client::QueryResponseFut<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5])>;
    fn r#two_way_array_compound(
        &self,
        mut array_bits: &mut [Bits; 5],
        mut array_enum: &mut [Enum; 5],
        mut array_struct: &mut [&mut Struct; 5],
        mut array_table: &mut [Table; 5],
        mut array_union: &mut [&mut Union; 5],
    ) -> Self::TwoWayArrayCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]), fidl::Error>
        {
            let _response = fidl::client::decode_transaction_body::<ArrayCompound, true>(_buf?)?;
            Ok((
                _response.array_bits,
                _response.array_enum,
                _response.array_struct,
                _response.array_table,
                _response.array_union,
            ))
        }
        self.client.send_query_and_decode::<
            ArrayCompound,
            ([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5]),
            false,
        >(
            (&*array_bits, &*array_enum, &{
	let mut temp: [Struct; 5] = fidl::new_empty!(fidl::encoding::Array<Struct, 5>);
	for (i, x) in array_struct.iter_mut().enumerate() {
		temp[i] = x.clone();
	}
	temp
}, &*array_table, &{
	let mut temp: [Union; 5] = fidl::new_empty!(fidl::encoding::Array<Union, 5>);
	for (i, x) in array_union.iter_mut().enumerate() {
		temp[i] = x.clone();
	}
	temp
},),
            0xbcae616f8e1ea7b,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    fn r#one_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &mut dyn ExactSizeIterator<Item = &str>,
        mut vector_opt_string: &mut dyn ExactSizeIterator<Item = Option<&str>>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorBasic, false>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                fidl::encoding::Iterator(vector_string),
                fidl::encoding::Iterator(vector_opt_string),
            ),
            0x4f907dde77464657,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayVectorBasicResponseFut = fidl::client::QueryResponseFut<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
    )>;
    fn r#two_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &mut dyn ExactSizeIterator<Item = &str>,
        mut vector_opt_string: &mut dyn ExactSizeIterator<Item = Option<&str>>,
    ) -> Self::TwoWayVectorBasicResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                Vec<u8>,
                Vec<u16>,
                Vec<u32>,
                Vec<u64>,
                Vec<i8>,
                Vec<i16>,
                Vec<i32>,
                Vec<i64>,
                Vec<f32>,
                Vec<f64>,
                Vec<String>,
                Vec<Option<String>>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<VectorBasic, true>(_buf?)?;
            Ok((
                _response.vector_uint8,
                _response.vector_uint16,
                _response.vector_uint32,
                _response.vector_uint64,
                _response.vector_int8,
                _response.vector_int16,
                _response.vector_int32,
                _response.vector_int64,
                _response.vector_float32,
                _response.vector_float64,
                _response.vector_string,
                _response.vector_opt_string,
            ))
        }
        self.client.send_query_and_decode::<VectorBasic, (
            Vec<u8>,
            Vec<u16>,
            Vec<u32>,
            Vec<u64>,
            Vec<i8>,
            Vec<i16>,
            Vec<i32>,
            Vec<i64>,
            Vec<f32>,
            Vec<f64>,
            Vec<String>,
            Vec<Option<String>>,
        ), false>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                fidl::encoding::Iterator(vector_string),
                fidl::encoding::Iterator(vector_opt_string),
            ),
            0x7860cb3ed8362e74,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    fn r#one_way_vector_compound(
        &self,
        mut vector_bits: &mut dyn ExactSizeIterator<Item = Bits>,
        mut vector_enum: &mut dyn ExactSizeIterator<Item = Enum>,
        mut vector_struct: &mut dyn ExactSizeIterator<Item = &mut Struct>,
        mut vector_table: &mut dyn ExactSizeIterator<Item = Table>,
        mut vector_union: &mut dyn ExactSizeIterator<Item = &mut Union>,
        mut vector_opt_struct: &mut dyn ExactSizeIterator<Item = Option<&mut Struct>>,
        mut vector_opt_union: &mut dyn ExactSizeIterator<Item = Option<&mut Union>>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorCompound, false>(
            (
                fidl::encoding::Iterator(vector_bits),
                fidl::encoding::Iterator(vector_enum),
                fidl::encoding::Iterator(vector_struct.map(|x| &*x)),
                fidl::encoding::Iterator(vector_table),
                fidl::encoding::Iterator(vector_union.map(|x| &*x)),
                fidl::encoding::Iterator(vector_opt_struct.map(|x| x.map(|x| &*x))),
                fidl::encoding::Iterator(vector_opt_union.map(|x| x.map(|x| &*x))),
            ),
            0x19baae42829dbe90,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayVectorCompoundResponseFut = fidl::client::QueryResponseFut<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
    )>;
    fn r#two_way_vector_compound(
        &self,
        mut vector_bits: &mut dyn ExactSizeIterator<Item = Bits>,
        mut vector_enum: &mut dyn ExactSizeIterator<Item = Enum>,
        mut vector_struct: &mut dyn ExactSizeIterator<Item = &mut Struct>,
        mut vector_table: &mut dyn ExactSizeIterator<Item = Table>,
        mut vector_union: &mut dyn ExactSizeIterator<Item = &mut Union>,
        mut vector_opt_struct: &mut dyn ExactSizeIterator<Item = Option<&mut Struct>>,
        mut vector_opt_union: &mut dyn ExactSizeIterator<Item = Option<&mut Union>>,
    ) -> Self::TwoWayVectorCompoundResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                Vec<Bits>,
                Vec<Enum>,
                Vec<Struct>,
                Vec<Table>,
                Vec<Union>,
                Vec<Option<Box<Struct>>>,
                Vec<Option<Box<Union>>>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<VectorCompound, true>(_buf?)?;
            Ok((
                _response.vector_bits,
                _response.vector_enum,
                _response.vector_struct,
                _response.vector_table,
                _response.vector_union,
                _response.vector_opt_struct,
                _response.vector_opt_union,
            ))
        }
        self.client.send_query_and_decode::<VectorCompound, (
            Vec<Bits>,
            Vec<Enum>,
            Vec<Struct>,
            Vec<Table>,
            Vec<Union>,
            Vec<Option<Box<Struct>>>,
            Vec<Option<Box<Union>>>,
        ), false>(
            (
                fidl::encoding::Iterator(vector_bits),
                fidl::encoding::Iterator(vector_enum),
                fidl::encoding::Iterator(vector_struct.map(|x| &*x)),
                fidl::encoding::Iterator(vector_table),
                fidl::encoding::Iterator(vector_union.map(|x| &*x)),
                fidl::encoding::Iterator(vector_opt_struct.map(|x| x.map(|x| &*x))),
                fidl::encoding::Iterator(vector_opt_union.map(|x| x.map(|x| &*x))),
            ),
            0x371140db701b23b4,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    fn r#one_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&mut dyn ExactSizeIterator<Item = &str>>,
        mut opt_vector_struct: Option<&mut dyn ExactSizeIterator<Item = &mut Struct>>,
        mut opt_vector_opt_struct: Option<&mut dyn ExactSizeIterator<Item = Option<&mut Struct>>>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorOptional, false>(
            (
                opt_vector_uint8,
                opt_vector_string.map(fidl::encoding::Iterator),
                opt_vector_struct.map(|x| x.map(|x| &*x)).map(fidl::encoding::Iterator),
                opt_vector_opt_struct
                    .map(|x| x.map(|x| x.map(|x| &*x)))
                    .map(fidl::encoding::Iterator),
            ),
            0x153c6b333c21c52f,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayVectorOptionalResponseFut = fidl::client::QueryResponseFut<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
    )>;
    fn r#two_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&mut dyn ExactSizeIterator<Item = &str>>,
        mut opt_vector_struct: Option<&mut dyn ExactSizeIterator<Item = &mut Struct>>,
        mut opt_vector_opt_struct: Option<&mut dyn ExactSizeIterator<Item = Option<&mut Struct>>>,
    ) -> Self::TwoWayVectorOptionalResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                Option<Vec<u8>>,
                Option<Vec<String>>,
                Option<Vec<Struct>>,
                Option<Vec<Option<Box<Struct>>>>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<VectorOptional, true>(_buf?)?;
            Ok((
                _response.opt_vector_uint8,
                _response.opt_vector_string,
                _response.opt_vector_struct,
                _response.opt_vector_opt_struct,
            ))
        }
        self.client.send_query_and_decode::<VectorOptional, (
            Option<Vec<u8>>,
            Option<Vec<String>>,
            Option<Vec<Struct>>,
            Option<Vec<Option<Box<Struct>>>>,
        ), false>(
            (
                opt_vector_uint8,
                opt_vector_string.map(fidl::encoding::Iterator),
                opt_vector_struct.map(|x| x.map(|x| &*x)).map(fidl::encoding::Iterator),
                opt_vector_opt_struct
                    .map(|x| x.map(|x| x.map(|x| &*x)))
                    .map(fidl::encoding::Iterator),
            ),
            0xe4b620aaafd73f3,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
    fn r#one_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &mut dyn ExactSizeIterator<Item = &mut [u8; 5]>,
        mut vector_vector_uint8: &mut dyn ExactSizeIterator<Item = &[u8]>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayVectorNested, false>(
            (
                fidl::encoding::Iterator(vector_array_uint8.map(|x| *x)),
                fidl::encoding::Iterator(vector_vector_uint8),
            ),
            0x520dc9cb9b9b5ed7,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    type TwoWayArrayVectorNestedResponseFut =
        fidl::client::QueryResponseFut<(Vec<[u8; 5]>, Vec<Vec<u8>>)>;
    fn r#two_way_array_vector_nested(
        &self,
        mut vector_array_uint8: &mut dyn ExactSizeIterator<Item = &mut [u8; 5]>,
        mut vector_vector_uint8: &mut dyn ExactSizeIterator<Item = &[u8]>,
    ) -> Self::TwoWayArrayVectorNestedResponseFut {
        fn _decode(
            mut _buf: Result<fidl::MessageBufEtc, fidl::Error>,
        ) -> Result<(Vec<[u8; 5]>, Vec<Vec<u8>>), fidl::Error> {
            let _response =
                fidl::client::decode_transaction_body::<ArrayVectorNested, true>(_buf?)?;
            Ok((_response.vector_array_uint8, _response.vector_vector_uint8))
        }
        self.client.send_query_and_decode::<ArrayVectorNested, (Vec<[u8; 5]>, Vec<Vec<u8>>), false>(
            (
                fidl::encoding::Iterator(vector_array_uint8.map(|x| *x)),
                fidl::encoding::Iterator(vector_vector_uint8),
            ),
            0x4a438ce0948817dc,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }
}

pub struct ProtocolEventStream {
    event_receiver: fidl::client::EventReceiver,
}

impl std::marker::Unpin for ProtocolEventStream {}

impl futures::stream::FusedStream for ProtocolEventStream {
    fn is_terminated(&self) -> bool {
        self.event_receiver.is_terminated()
    }
}

impl futures::Stream for ProtocolEventStream {
    type Item = Result<ProtocolEvent, fidl::Error>;

    fn poll_next(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Option<Self::Item>> {
        let buf = match futures::ready!(futures::stream::StreamExt::poll_next_unpin(
            &mut self.event_receiver,
            cx
        )?) {
            Some(buf) => buf,
            None => return std::task::Poll::Ready(None),
        };

        std::task::Poll::Ready(Some(ProtocolEvent::decode(buf)))
    }
}

#[derive(Debug)]
pub enum ProtocolEvent {
    EventBasic {
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: String,
        opt_string: Option<String>,
    },
    EventCompound {
        bits: Bits,
        enum_: Enum,
        struct_: Struct,
        table: Table,
        union: Union,
        opt_struct: Option<Box<Struct>>,
        opt_union: Option<Box<Union>>,
    },
    EventArrayBasic {
        array_uint8: [u8; 5],
        array_uint16: [u16; 5],
        array_uint32: [u32; 5],
        array_uint64: [u64; 5],
        array_int8: [i8; 5],
        array_int16: [i16; 5],
        array_int32: [i32; 5],
        array_int64: [i64; 5],
        array_float32: [f32; 5],
        array_float64: [f64; 5],
        array_string: [String; 5],
        array_opt_string: [Option<String>; 5],
    },
    EventArrayCompound {
        array_bits: [Bits; 5],
        array_enum: [Enum; 5],
        array_struct: [Struct; 5],
        array_table: [Table; 5],
        array_union: [Union; 5],
    },
    EventVectorBasic {
        vector_uint8: Vec<u8>,
        vector_uint16: Vec<u16>,
        vector_uint32: Vec<u32>,
        vector_uint64: Vec<u64>,
        vector_int8: Vec<i8>,
        vector_int16: Vec<i16>,
        vector_int32: Vec<i32>,
        vector_int64: Vec<i64>,
        vector_float32: Vec<f32>,
        vector_float64: Vec<f64>,
        vector_string: Vec<String>,
        vector_opt_string: Vec<Option<String>>,
    },
    EventVectorCompound {
        vector_bits: Vec<Bits>,
        vector_enum: Vec<Enum>,
        vector_struct: Vec<Struct>,
        vector_table: Vec<Table>,
        vector_union: Vec<Union>,
        vector_opt_struct: Vec<Option<Box<Struct>>>,
        vector_opt_union: Vec<Option<Box<Union>>>,
    },
    EventVectorOptional {
        opt_vector_uint8: Option<Vec<u8>>,
        opt_vector_string: Option<Vec<String>>,
        opt_vector_struct: Option<Vec<Struct>>,
        opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
    },
    EventArrayVectorNested {
        vector_array_uint8: Vec<[u8; 5]>,
        vector_vector_uint8: Vec<Vec<u8>>,
    },
}

impl ProtocolEvent {
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_basic(
        self,
    ) -> Option<(u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>)> {
        if let ProtocolEvent::EventBasic {
            uint8,
            uint16,
            uint32,
            uint64,
            int8,
            int16,
            int32,
            int64,
            float32,
            float64,
            string,
            opt_string,
        } = self
        {
            Some((
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_compound(
        self,
    ) -> Option<(Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>)> {
        if let ProtocolEvent::EventCompound {
            bits,
            enum_,
            struct_,
            table,
            union,
            opt_struct,
            opt_union,
        } = self
        {
            Some((bits, enum_, struct_, table, union, opt_struct, opt_union))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_array_basic(
        self,
    ) -> Option<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
    )> {
        if let ProtocolEvent::EventArrayBasic {
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        } = self
        {
            Some((
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_array_compound(
        self,
    ) -> Option<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5])> {
        if let ProtocolEvent::EventArrayCompound {
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
        } = self
        {
            Some((array_bits, array_enum, array_struct, array_table, array_union))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_vector_basic(
        self,
    ) -> Option<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
    )> {
        if let ProtocolEvent::EventVectorBasic {
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        } = self
        {
            Some((
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_vector_compound(
        self,
    ) -> Option<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
    )> {
        if let ProtocolEvent::EventVectorCompound {
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        } = self
        {
            Some((
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_vector_optional(
        self,
    ) -> Option<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
    )> {
        if let ProtocolEvent::EventVectorOptional {
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        } = self
        {
            Some((opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_array_vector_nested(self) -> Option<(Vec<[u8; 5]>, Vec<Vec<u8>>)> {
        if let ProtocolEvent::EventArrayVectorNested { vector_array_uint8, vector_vector_uint8 } =
            self
        {
            Some((vector_array_uint8, vector_vector_uint8))
        } else {
            None
        }
    }

    /// Decodes a message buffer as a [`ProtocolEvent`]. Transaction
    /// ID in the message must be zero; this method does not check TXID.
    fn decode(mut buf: fidl::MessageBufEtc) -> Result<ProtocolEvent, fidl::Error> {
        let (bytes, _handles) = buf.split_mut();
        let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

        match tx_header.ordinal() {
            0x51c5b06295c10c40 => {
                let mut out = fidl::new_empty!(Basic);
                fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolEventBasicEvent");
                fidl::trace_blob!("fidl:blob", "decode", bytes);
                fidl::encoding::maybe_overflowing_decode::<Basic>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => _handles.len() as u32);
                Ok((ProtocolEvent::EventBasic {
                    uint8: out.uint8,
                    uint16: out.uint16,
                    uint32: out.uint32,
                    uint64: out.uint64,
                    int8: out.int8,
                    int16: out.int16,
                    int32: out.int32,
                    int64: out.int64,
                    float32: out.float32,
                    float64: out.float64,
                    string: out.string,
                    opt_string: out.opt_string,
                }))
            }
            0x617c5410858734d5 => {
                let mut out = fidl::new_empty!(Compound);
                fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolEventCompoundEvent");
                fidl::trace_blob!("fidl:blob", "decode", bytes);
                fidl::encoding::maybe_overflowing_decode::<Compound>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => _handles.len() as u32);
                Ok((ProtocolEvent::EventCompound {
                    bits: out.bits,
                    enum_: out.enum_,
                    struct_: out.struct_,
                    table: out.table,
                    union: out.union,
                    opt_struct: out.opt_struct,
                    opt_union: out.opt_union,
                }))
            }
            0x51b76208b148f02e => {
                let mut out = fidl::new_empty!(ArrayBasic);
                fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolEventArrayBasicEvent");
                fidl::trace_blob!("fidl:blob", "decode", bytes);
                fidl::encoding::maybe_overflowing_decode::<ArrayBasic>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => _handles.len() as u32);
                Ok((ProtocolEvent::EventArrayBasic {
                    array_uint8: out.array_uint8,
                    array_uint16: out.array_uint16,
                    array_uint32: out.array_uint32,
                    array_uint64: out.array_uint64,
                    array_int8: out.array_int8,
                    array_int16: out.array_int16,
                    array_int32: out.array_int32,
                    array_int64: out.array_int64,
                    array_float32: out.array_float32,
                    array_float64: out.array_float64,
                    array_string: out.array_string,
                    array_opt_string: out.array_opt_string,
                }))
            }
            0x1e63a00079aa7415 => {
                let mut out = fidl::new_empty!(ArrayCompound);
                fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolEventArrayCompoundEvent");
                fidl::trace_blob!("fidl:blob", "decode", bytes);
                fidl::encoding::maybe_overflowing_decode::<ArrayCompound>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => _handles.len() as u32);
                Ok((ProtocolEvent::EventArrayCompound {
                    array_bits: out.array_bits,
                    array_enum: out.array_enum,
                    array_struct: out.array_struct,
                    array_table: out.array_table,
                    array_union: out.array_union,
                }))
            }
            0x3f9d405e7191eff6 => {
                let mut out = fidl::new_empty!(VectorBasic);
                fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolEventVectorBasicEvent");
                fidl::trace_blob!("fidl:blob", "decode", bytes);
                fidl::encoding::maybe_overflowing_decode::<VectorBasic>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => _handles.len() as u32);
                Ok((ProtocolEvent::EventVectorBasic {
                    vector_uint8: out.vector_uint8,
                    vector_uint16: out.vector_uint16,
                    vector_uint32: out.vector_uint32,
                    vector_uint64: out.vector_uint64,
                    vector_int8: out.vector_int8,
                    vector_int16: out.vector_int16,
                    vector_int32: out.vector_int32,
                    vector_int64: out.vector_int64,
                    vector_float32: out.vector_float32,
                    vector_float64: out.vector_float64,
                    vector_string: out.vector_string,
                    vector_opt_string: out.vector_opt_string,
                }))
            }
            0x53a1fc56e8b3cff3 => {
                let mut out = fidl::new_empty!(VectorCompound);
                fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolEventVectorCompoundEvent");
                fidl::trace_blob!("fidl:blob", "decode", bytes);
                fidl::encoding::maybe_overflowing_decode::<VectorCompound>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => _handles.len() as u32);
                Ok((ProtocolEvent::EventVectorCompound {
                    vector_bits: out.vector_bits,
                    vector_enum: out.vector_enum,
                    vector_struct: out.vector_struct,
                    vector_table: out.vector_table,
                    vector_union: out.vector_union,
                    vector_opt_struct: out.vector_opt_struct,
                    vector_opt_union: out.vector_opt_union,
                }))
            }
            0x17617b54dfa8d85d => {
                let mut out = fidl::new_empty!(VectorOptional);
                fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolEventVectorOptionalEvent");
                fidl::trace_blob!("fidl:blob", "decode", bytes);
                fidl::encoding::maybe_overflowing_decode::<VectorOptional>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => _handles.len() as u32);
                Ok((ProtocolEvent::EventVectorOptional {
                    opt_vector_uint8: out.opt_vector_uint8,
                    opt_vector_string: out.opt_vector_string,
                    opt_vector_struct: out.opt_vector_struct,
                    opt_vector_opt_struct: out.opt_vector_opt_struct,
                }))
            }
            0x110b72cfebc4037e => {
                let mut out = fidl::new_empty!(ArrayVectorNested);
                fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolEventArrayVectorNestedEvent");
                fidl::trace_blob!("fidl:blob", "decode", bytes);
                fidl::encoding::maybe_overflowing_decode::<ArrayVectorNested>(
                    &tx_header,
                    _body_bytes,
                    _handles,
                    &mut out,
                )?;
                fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => _handles.len() as u32);
                Ok((ProtocolEvent::EventArrayVectorNested {
                    vector_array_uint8: out.vector_array_uint8,
                    vector_vector_uint8: out.vector_vector_uint8,
                }))
            }
            _ => Err(fidl::Error::UnknownOrdinal {
                ordinal: tx_header.ordinal(),
                protocol_name: <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME,
            }),
        }
    }
}

/// A Stream of incoming requests for Protocol
pub struct ProtocolRequestStream {
    inner: std::sync::Arc<fidl::ServeInner>,
    is_terminated: bool,
}

impl std::marker::Unpin for ProtocolRequestStream {}

impl futures::stream::FusedStream for ProtocolRequestStream {
    fn is_terminated(&self) -> bool {
        self.is_terminated
    }
}

impl fidl::endpoints::RequestStream for ProtocolRequestStream {
    type Protocol = ProtocolMarker;
    type ControlHandle = ProtocolControlHandle;

    fn from_channel(channel: fidl::AsyncChannel) -> Self {
        Self { inner: std::sync::Arc::new(fidl::ServeInner::new(channel)), is_terminated: false }
    }

    fn control_handle(&self) -> Self::ControlHandle {
        ProtocolControlHandle { inner: self.inner.clone() }
    }

    fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, bool) {
        (self.inner, self.is_terminated)
    }

    fn from_inner(inner: std::sync::Arc<fidl::ServeInner>, is_terminated: bool) -> Self {
        Self { inner, is_terminated }
    }
}

impl futures::Stream for ProtocolRequestStream {
    type Item = Result<ProtocolRequest, fidl::Error>;

    fn poll_next(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Option<Self::Item>> {
        let this = &mut *self;
        if this.inner.poll_shutdown(cx) {
            this.is_terminated = true;
            return std::task::Poll::Ready(None);
        }
        if this.is_terminated {
            panic!("polled ProtocolRequestStream after completion");
        }
        fidl::encoding::with_tls_decode_buf(|bytes, handles| {
            match this.inner.channel().read_etc(cx, bytes, handles) {
                std::task::Poll::Ready(Ok(())) => {}
                std::task::Poll::Pending => return std::task::Poll::Pending,
                std::task::Poll::Ready(Err(zx_status::Status::PEER_CLOSED)) => {
                    this.is_terminated = true;
                    return std::task::Poll::Ready(None);
                }
                std::task::Poll::Ready(Err(e)) => {
                    return std::task::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e))))
                }
            }

            // A message has been received from the channel
            let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;
            if !header.is_compatible() {
                return std::task::Poll::Ready(Some(Err(fidl::Error::IncompatibleMagicNumber(
                    header.magic_number(),
                ))));
            }

            std::task::Poll::Ready(Some(match header.ordinal() {
                0x7c311f0d9e662df9 => {
                    let mut req = fidl::new_empty!(Basic);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolOneWayBasicRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<Basic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayBasic {
                        uint8: req.uint8,
                        uint16: req.uint16,
                        uint32: req.uint32,
                        uint64: req.uint64,
                        int8: req.int8,
                        int16: req.int16,
                        int32: req.int32,
                        int64: req.int64,
                        float32: req.float32,
                        float64: req.float64,
                        string: req.string,
                        opt_string: req.opt_string,

                        control_handle,
                    })
                }
                0x205b92db5139c88f => {
                    let mut req = fidl::new_empty!(Basic);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayBasicRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<Basic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayBasic {
                        uint8: req.uint8,
                        uint16: req.uint16,
                        uint32: req.uint32,
                        uint64: req.uint64,
                        int8: req.int8,
                        int16: req.int16,
                        int32: req.int32,
                        int64: req.int64,
                        float32: req.float32,
                        float64: req.float64,
                        string: req.string,
                        opt_string: req.opt_string,

                        responder: ProtocolTwoWayBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x2bc2bc3a9237c6cc => {
                    let mut req = fidl::new_empty!(Compound);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolOneWayCompoundRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<Compound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayCompound {
                        bits: req.bits,
                        enum_: req.enum_,
                        struct_: req.struct_,
                        table: req.table,
                        union: req.union,
                        opt_struct: req.opt_struct,
                        opt_union: req.opt_union,

                        control_handle,
                    })
                }
                0x79f279c7201da131 => {
                    let mut req = fidl::new_empty!(Compound);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayCompoundRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<Compound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayCompound {
                        bits: req.bits,
                        enum_: req.enum_,
                        struct_: req.struct_,
                        table: req.table,
                        union: req.union,
                        opt_struct: req.opt_struct,
                        opt_union: req.opt_union,

                        responder: ProtocolTwoWayCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x62e2ebcadf35ca19 => {
                    let mut req = fidl::new_empty!(ArrayBasic);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolOneWayArrayBasicRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<ArrayBasic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayArrayBasic {
                        array_uint8: req.array_uint8,
                        array_uint16: req.array_uint16,
                        array_uint32: req.array_uint32,
                        array_uint64: req.array_uint64,
                        array_int8: req.array_int8,
                        array_int16: req.array_int16,
                        array_int32: req.array_int32,
                        array_int64: req.array_int64,
                        array_float32: req.array_float32,
                        array_float64: req.array_float64,
                        array_string: req.array_string,
                        array_opt_string: req.array_opt_string,

                        control_handle,
                    })
                }
                0x49ad7a74e28ba114 => {
                    let mut req = fidl::new_empty!(ArrayBasic);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayArrayBasicRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<ArrayBasic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayArrayBasic {
                        array_uint8: req.array_uint8,
                        array_uint16: req.array_uint16,
                        array_uint32: req.array_uint32,
                        array_uint64: req.array_uint64,
                        array_int8: req.array_int8,
                        array_int16: req.array_int16,
                        array_int32: req.array_int32,
                        array_int64: req.array_int64,
                        array_float32: req.array_float32,
                        array_float64: req.array_float64,
                        array_string: req.array_string,
                        array_opt_string: req.array_opt_string,

                        responder: ProtocolTwoWayArrayBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x464948bae1bda09d => {
                    let mut req = fidl::new_empty!(ArrayCompound);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolOneWayArrayCompoundRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<ArrayCompound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayArrayCompound {
                        array_bits: req.array_bits,
                        array_enum: req.array_enum,
                        array_struct: req.array_struct,
                        array_table: req.array_table,
                        array_union: req.array_union,

                        control_handle,
                    })
                }
                0xbcae616f8e1ea7b => {
                    let mut req = fidl::new_empty!(ArrayCompound);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayArrayCompoundRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<ArrayCompound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayArrayCompound {
                        array_bits: req.array_bits,
                        array_enum: req.array_enum,
                        array_struct: req.array_struct,
                        array_table: req.array_table,
                        array_union: req.array_union,

                        responder: ProtocolTwoWayArrayCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x4f907dde77464657 => {
                    let mut req = fidl::new_empty!(VectorBasic);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolOneWayVectorBasicRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<VectorBasic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayVectorBasic {
                        vector_uint8: req.vector_uint8,
                        vector_uint16: req.vector_uint16,
                        vector_uint32: req.vector_uint32,
                        vector_uint64: req.vector_uint64,
                        vector_int8: req.vector_int8,
                        vector_int16: req.vector_int16,
                        vector_int32: req.vector_int32,
                        vector_int64: req.vector_int64,
                        vector_float32: req.vector_float32,
                        vector_float64: req.vector_float64,
                        vector_string: req.vector_string,
                        vector_opt_string: req.vector_opt_string,

                        control_handle,
                    })
                }
                0x7860cb3ed8362e74 => {
                    let mut req = fidl::new_empty!(VectorBasic);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayVectorBasicRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<VectorBasic>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayVectorBasic {
                        vector_uint8: req.vector_uint8,
                        vector_uint16: req.vector_uint16,
                        vector_uint32: req.vector_uint32,
                        vector_uint64: req.vector_uint64,
                        vector_int8: req.vector_int8,
                        vector_int16: req.vector_int16,
                        vector_int32: req.vector_int32,
                        vector_int64: req.vector_int64,
                        vector_float32: req.vector_float32,
                        vector_float64: req.vector_float64,
                        vector_string: req.vector_string,
                        vector_opt_string: req.vector_opt_string,

                        responder: ProtocolTwoWayVectorBasicResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x19baae42829dbe90 => {
                    let mut req = fidl::new_empty!(VectorCompound);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolOneWayVectorCompoundRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<VectorCompound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayVectorCompound {
                        vector_bits: req.vector_bits,
                        vector_enum: req.vector_enum,
                        vector_struct: req.vector_struct,
                        vector_table: req.vector_table,
                        vector_union: req.vector_union,
                        vector_opt_struct: req.vector_opt_struct,
                        vector_opt_union: req.vector_opt_union,

                        control_handle,
                    })
                }
                0x371140db701b23b4 => {
                    let mut req = fidl::new_empty!(VectorCompound);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayVectorCompoundRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<VectorCompound>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayVectorCompound {
                        vector_bits: req.vector_bits,
                        vector_enum: req.vector_enum,
                        vector_struct: req.vector_struct,
                        vector_table: req.vector_table,
                        vector_union: req.vector_union,
                        vector_opt_struct: req.vector_opt_struct,
                        vector_opt_union: req.vector_opt_union,

                        responder: ProtocolTwoWayVectorCompoundResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x153c6b333c21c52f => {
                    let mut req = fidl::new_empty!(VectorOptional);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolOneWayVectorOptionalRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<VectorOptional>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayVectorOptional {
                        opt_vector_uint8: req.opt_vector_uint8,
                        opt_vector_string: req.opt_vector_string,
                        opt_vector_struct: req.opt_vector_struct,
                        opt_vector_opt_struct: req.opt_vector_opt_struct,

                        control_handle,
                    })
                }
                0xe4b620aaafd73f3 => {
                    let mut req = fidl::new_empty!(VectorOptional);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayVectorOptionalRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<VectorOptional>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayVectorOptional {
                        opt_vector_uint8: req.opt_vector_uint8,
                        opt_vector_string: req.opt_vector_string,
                        opt_vector_struct: req.opt_vector_struct,
                        opt_vector_opt_struct: req.opt_vector_opt_struct,

                        responder: ProtocolTwoWayVectorOptionalResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                0x520dc9cb9b9b5ed7 => {
                    let mut req = fidl::new_empty!(ArrayVectorNested);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolOneWayArrayVectorNestedRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<ArrayVectorNested>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::OneWayArrayVectorNested {
                        vector_array_uint8: req.vector_array_uint8,
                        vector_vector_uint8: req.vector_vector_uint8,

                        control_handle,
                    })
                }
                0x4a438ce0948817dc => {
                    let mut req = fidl::new_empty!(ArrayVectorNested);
                    fidl::duration_begin!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayArrayVectorNestedRequest");
                    fidl::trace_blob!("fidl:blob", "decode", bytes);
                    fidl::encoding::maybe_overflowing_decode::<ArrayVectorNested>(
                        &header,
                        _body_bytes,
                        handles,
                        &mut req,
                    )?;
                    fidl::duration_end!("fidl", "decode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);
                    let control_handle = ProtocolControlHandle { inner: this.inner.clone() };

                    Ok(ProtocolRequest::TwoWayArrayVectorNested {
                        vector_array_uint8: req.vector_array_uint8,
                        vector_vector_uint8: req.vector_vector_uint8,

                        responder: ProtocolTwoWayArrayVectorNestedResponder {
                            control_handle: std::mem::ManuallyDrop::new(control_handle),
                            tx_id: header.tx_id(),
                            ordinal: header.ordinal(),
                        },
                    })
                }
                _ => Err(fidl::Error::UnknownOrdinal {
                    ordinal: header.ordinal(),
                    protocol_name: <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME,
                }),
            }))
        })
    }
}
#[derive(Debug)]
pub enum ProtocolRequest {
    OneWayBasic {
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: String,
        opt_string: Option<String>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayBasic {
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: String,
        opt_string: Option<String>,
        responder: ProtocolTwoWayBasicResponder,
    },
    OneWayCompound {
        bits: Bits,
        enum_: Enum,
        struct_: Struct,
        table: Table,
        union: Union,
        opt_struct: Option<Box<Struct>>,
        opt_union: Option<Box<Union>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayCompound {
        bits: Bits,
        enum_: Enum,
        struct_: Struct,
        table: Table,
        union: Union,
        opt_struct: Option<Box<Struct>>,
        opt_union: Option<Box<Union>>,
        responder: ProtocolTwoWayCompoundResponder,
    },
    OneWayArrayBasic {
        array_uint8: [u8; 5],
        array_uint16: [u16; 5],
        array_uint32: [u32; 5],
        array_uint64: [u64; 5],
        array_int8: [i8; 5],
        array_int16: [i16; 5],
        array_int32: [i32; 5],
        array_int64: [i64; 5],
        array_float32: [f32; 5],
        array_float64: [f64; 5],
        array_string: [String; 5],
        array_opt_string: [Option<String>; 5],
        control_handle: ProtocolControlHandle,
    },
    TwoWayArrayBasic {
        array_uint8: [u8; 5],
        array_uint16: [u16; 5],
        array_uint32: [u32; 5],
        array_uint64: [u64; 5],
        array_int8: [i8; 5],
        array_int16: [i16; 5],
        array_int32: [i32; 5],
        array_int64: [i64; 5],
        array_float32: [f32; 5],
        array_float64: [f64; 5],
        array_string: [String; 5],
        array_opt_string: [Option<String>; 5],
        responder: ProtocolTwoWayArrayBasicResponder,
    },
    OneWayArrayCompound {
        array_bits: [Bits; 5],
        array_enum: [Enum; 5],
        array_struct: [Struct; 5],
        array_table: [Table; 5],
        array_union: [Union; 5],
        control_handle: ProtocolControlHandle,
    },
    TwoWayArrayCompound {
        array_bits: [Bits; 5],
        array_enum: [Enum; 5],
        array_struct: [Struct; 5],
        array_table: [Table; 5],
        array_union: [Union; 5],
        responder: ProtocolTwoWayArrayCompoundResponder,
    },
    OneWayVectorBasic {
        vector_uint8: Vec<u8>,
        vector_uint16: Vec<u16>,
        vector_uint32: Vec<u32>,
        vector_uint64: Vec<u64>,
        vector_int8: Vec<i8>,
        vector_int16: Vec<i16>,
        vector_int32: Vec<i32>,
        vector_int64: Vec<i64>,
        vector_float32: Vec<f32>,
        vector_float64: Vec<f64>,
        vector_string: Vec<String>,
        vector_opt_string: Vec<Option<String>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayVectorBasic {
        vector_uint8: Vec<u8>,
        vector_uint16: Vec<u16>,
        vector_uint32: Vec<u32>,
        vector_uint64: Vec<u64>,
        vector_int8: Vec<i8>,
        vector_int16: Vec<i16>,
        vector_int32: Vec<i32>,
        vector_int64: Vec<i64>,
        vector_float32: Vec<f32>,
        vector_float64: Vec<f64>,
        vector_string: Vec<String>,
        vector_opt_string: Vec<Option<String>>,
        responder: ProtocolTwoWayVectorBasicResponder,
    },
    OneWayVectorCompound {
        vector_bits: Vec<Bits>,
        vector_enum: Vec<Enum>,
        vector_struct: Vec<Struct>,
        vector_table: Vec<Table>,
        vector_union: Vec<Union>,
        vector_opt_struct: Vec<Option<Box<Struct>>>,
        vector_opt_union: Vec<Option<Box<Union>>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayVectorCompound {
        vector_bits: Vec<Bits>,
        vector_enum: Vec<Enum>,
        vector_struct: Vec<Struct>,
        vector_table: Vec<Table>,
        vector_union: Vec<Union>,
        vector_opt_struct: Vec<Option<Box<Struct>>>,
        vector_opt_union: Vec<Option<Box<Union>>>,
        responder: ProtocolTwoWayVectorCompoundResponder,
    },
    OneWayVectorOptional {
        opt_vector_uint8: Option<Vec<u8>>,
        opt_vector_string: Option<Vec<String>>,
        opt_vector_struct: Option<Vec<Struct>>,
        opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayVectorOptional {
        opt_vector_uint8: Option<Vec<u8>>,
        opt_vector_string: Option<Vec<String>>,
        opt_vector_struct: Option<Vec<Struct>>,
        opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
        responder: ProtocolTwoWayVectorOptionalResponder,
    },
    OneWayArrayVectorNested {
        vector_array_uint8: Vec<[u8; 5]>,
        vector_vector_uint8: Vec<Vec<u8>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayArrayVectorNested {
        vector_array_uint8: Vec<[u8; 5]>,
        vector_vector_uint8: Vec<Vec<u8>>,
        responder: ProtocolTwoWayArrayVectorNestedResponder,
    },
}

impl ProtocolRequest {
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_basic(
        self,
    ) -> Option<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayBasic {
            uint8,
            uint16,
            uint32,
            uint64,
            int8,
            int16,
            int32,
            int64,
            float32,
            float64,
            string,
            opt_string,
            control_handle,
        } = self
        {
            Some((
                uint8,
                uint16,
                uint32,
                uint64,
                int8,
                int16,
                int32,
                int64,
                float32,
                float64,
                string,
                opt_string,
                control_handle,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_basic(
        self,
    ) -> Option<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
        ProtocolTwoWayBasicResponder,
    )> {
        if let ProtocolRequest::TwoWayBasic {
            uint8,
            uint16,
            uint32,
            uint64,
            int8,
            int16,
            int32,
            int64,
            float32,
            float64,
            string,
            opt_string,
            responder,
        } = self
        {
            Some((
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string, responder,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_compound(
        self,
    ) -> Option<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayCompound {
            bits,
            enum_,
            struct_,
            table,
            union,
            opt_struct,
            opt_union,
            control_handle,
        } = self
        {
            Some((bits, enum_, struct_, table, union, opt_struct, opt_union, control_handle))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_compound(
        self,
    ) -> Option<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
        ProtocolTwoWayCompoundResponder,
    )> {
        if let ProtocolRequest::TwoWayCompound {
            bits,
            enum_,
            struct_,
            table,
            union,
            opt_struct,
            opt_union,
            responder,
        } = self
        {
            Some((bits, enum_, struct_, table, union, opt_struct, opt_union, responder))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_array_basic(
        self,
    ) -> Option<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayArrayBasic {
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
            control_handle,
        } = self
        {
            Some((
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
                control_handle,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_array_basic(
        self,
    ) -> Option<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
        ProtocolTwoWayArrayBasicResponder,
    )> {
        if let ProtocolRequest::TwoWayArrayBasic {
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
            responder,
        } = self
        {
            Some((
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
                responder,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_array_compound(
        self,
    ) -> Option<([Bits; 5], [Enum; 5], [Struct; 5], [Table; 5], [Union; 5], ProtocolControlHandle)>
    {
        if let ProtocolRequest::OneWayArrayCompound {
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
            control_handle,
        } = self
        {
            Some((array_bits, array_enum, array_struct, array_table, array_union, control_handle))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_array_compound(
        self,
    ) -> Option<(
        [Bits; 5],
        [Enum; 5],
        [Struct; 5],
        [Table; 5],
        [Union; 5],
        ProtocolTwoWayArrayCompoundResponder,
    )> {
        if let ProtocolRequest::TwoWayArrayCompound {
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
            responder,
        } = self
        {
            Some((array_bits, array_enum, array_struct, array_table, array_union, responder))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_vector_basic(
        self,
    ) -> Option<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayVectorBasic {
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
            control_handle,
        } = self
        {
            Some((
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
                control_handle,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_vector_basic(
        self,
    ) -> Option<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
        ProtocolTwoWayVectorBasicResponder,
    )> {
        if let ProtocolRequest::TwoWayVectorBasic {
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
            responder,
        } = self
        {
            Some((
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
                responder,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_vector_compound(
        self,
    ) -> Option<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayVectorCompound {
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
            control_handle,
        } = self
        {
            Some((
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
                control_handle,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_vector_compound(
        self,
    ) -> Option<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
        ProtocolTwoWayVectorCompoundResponder,
    )> {
        if let ProtocolRequest::TwoWayVectorCompound {
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
            responder,
        } = self
        {
            Some((
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
                responder,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_vector_optional(
        self,
    ) -> Option<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayVectorOptional {
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
            control_handle,
        } = self
        {
            Some((
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,
                control_handle,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_vector_optional(
        self,
    ) -> Option<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
        ProtocolTwoWayVectorOptionalResponder,
    )> {
        if let ProtocolRequest::TwoWayVectorOptional {
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
            responder,
        } = self
        {
            Some((
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,
                responder,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_array_vector_nested(
        self,
    ) -> Option<(Vec<[u8; 5]>, Vec<Vec<u8>>, ProtocolControlHandle)> {
        if let ProtocolRequest::OneWayArrayVectorNested {
            vector_array_uint8,
            vector_vector_uint8,
            control_handle,
        } = self
        {
            Some((vector_array_uint8, vector_vector_uint8, control_handle))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_array_vector_nested(
        self,
    ) -> Option<(Vec<[u8; 5]>, Vec<Vec<u8>>, ProtocolTwoWayArrayVectorNestedResponder)> {
        if let ProtocolRequest::TwoWayArrayVectorNested {
            vector_array_uint8,
            vector_vector_uint8,
            responder,
        } = self
        {
            Some((vector_array_uint8, vector_vector_uint8, responder))
        } else {
            None
        }
    }

    /// Name of the method defined in FIDL
    pub fn method_name(&self) -> &'static str {
        match *self {
            ProtocolRequest::OneWayBasic { .. } => "one_way_basic",
            ProtocolRequest::TwoWayBasic { .. } => "two_way_basic",
            ProtocolRequest::OneWayCompound { .. } => "one_way_compound",
            ProtocolRequest::TwoWayCompound { .. } => "two_way_compound",
            ProtocolRequest::OneWayArrayBasic { .. } => "one_way_array_basic",
            ProtocolRequest::TwoWayArrayBasic { .. } => "two_way_array_basic",
            ProtocolRequest::OneWayArrayCompound { .. } => "one_way_array_compound",
            ProtocolRequest::TwoWayArrayCompound { .. } => "two_way_array_compound",
            ProtocolRequest::OneWayVectorBasic { .. } => "one_way_vector_basic",
            ProtocolRequest::TwoWayVectorBasic { .. } => "two_way_vector_basic",
            ProtocolRequest::OneWayVectorCompound { .. } => "one_way_vector_compound",
            ProtocolRequest::TwoWayVectorCompound { .. } => "two_way_vector_compound",
            ProtocolRequest::OneWayVectorOptional { .. } => "one_way_vector_optional",
            ProtocolRequest::TwoWayVectorOptional { .. } => "two_way_vector_optional",
            ProtocolRequest::OneWayArrayVectorNested { .. } => "one_way_array_vector_nested",
            ProtocolRequest::TwoWayArrayVectorNested { .. } => "two_way_array_vector_nested",
        }
    }
}

#[derive(Debug, Clone)]
pub struct ProtocolControlHandle {
    inner: std::sync::Arc<fidl::ServeInner>,
}

impl fidl::endpoints::ControlHandle for ProtocolControlHandle {
    fn shutdown(&self) {
        self.inner.shutdown()
    }

    fn shutdown_with_epitaph(&self, status: zx_status::Status) {
        self.inner.shutdown_with_epitaph(status)
    }

    fn is_closed(&self) -> bool {
        self.inner.channel().is_closed()
    }

    fn on_closed<'a>(&'a self) -> fidl::OnSignals<'a> {
        self.inner.channel().on_closed()
    }
}

impl ProtocolControlHandle {
    pub fn send_event_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<Basic, false>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0,
            0x51c5b06295c10c40,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &mut Struct,
        mut table: Table,
        mut union: &mut Union,
        mut opt_struct: Option<&mut Struct>,
        mut opt_union: Option<&mut Union>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<Compound, false>(
            (
                bits,
                enum_,
                &*struct_,
                &table,
                &*union,
                opt_struct.map(|x| &*x),
                opt_union.map(|x| &*x),
            ),
            0,
            0x617c5410858734d5,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_array_basic(
        &self,
        mut array_uint8: &mut [u8; 5],
        mut array_uint16: &mut [u16; 5],
        mut array_uint32: &mut [u32; 5],
        mut array_uint64: &mut [u64; 5],
        mut array_int8: &mut [i8; 5],
        mut array_int16: &mut [i16; 5],
        mut array_int32: &mut [i32; 5],
        mut array_int64: &mut [i64; 5],
        mut array_float32: &mut [f32; 5],
        mut array_float64: &mut [f64; 5],
        mut array_string: &mut [&str; 5],
        mut array_opt_string: &mut [Option<&str>; 5],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<ArrayBasic, false>(
            (
                &*array_uint8,
                &*array_uint16,
                &*array_uint32,
                &*array_uint64,
                &*array_int8,
                &*array_int16,
                &*array_int32,
                &*array_int64,
                &*array_float32,
                &*array_float64,
                &{
                    let mut temp: [String; 5] =
                        fidl::new_empty!(fidl::encoding::Array<fidl::encoding::UnboundedString, 5>);
                    for (i, x) in array_string.iter_mut().enumerate() {
                        temp[i] = x.to_string();
                    }
                    temp
                },
                &{
                    let mut temp: [Option<String>; 5] = fidl::new_empty!(
                        fidl::encoding::Array<
                            fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                            5,
                        >
                    );
                    for (i, x) in array_opt_string.iter_mut().enumerate() {
                        temp[i] = x.map(str::to_string);
                    }
                    temp
                },
            ),
            0,
            0x51b76208b148f02e,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_array_compound(
        &self,
        mut array_bits: &mut [Bits; 5],
        mut array_enum: &mut [Enum; 5],
        mut array_struct: &mut [&mut Struct; 5],
        mut array_table: &mut [Table; 5],
        mut array_union: &mut [&mut Union; 5],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<ArrayCompound, false>(
            (
                &*array_bits,
                &*array_enum,
                &{
                    let mut temp: [Struct; 5] = fidl::new_empty!(fidl::encoding::Array<Struct, 5>);
                    for (i, x) in array_struct.iter_mut().enumerate() {
                        temp[i] = x.clone();
                    }
                    temp
                },
                &*array_table,
                &{
                    let mut temp: [Union; 5] = fidl::new_empty!(fidl::encoding::Array<Union, 5>);
                    for (i, x) in array_union.iter_mut().enumerate() {
                        temp[i] = x.clone();
                    }
                    temp
                },
            ),
            0,
            0x1e63a00079aa7415,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &mut dyn ExactSizeIterator<Item = &str>,
        mut vector_opt_string: &mut dyn ExactSizeIterator<Item = Option<&str>>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<VectorBasic, false>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                fidl::encoding::Iterator(vector_string),
                fidl::encoding::Iterator(vector_opt_string),
            ),
            0,
            0x3f9d405e7191eff6,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_vector_compound(
        &self,
        mut vector_bits: &mut dyn ExactSizeIterator<Item = Bits>,
        mut vector_enum: &mut dyn ExactSizeIterator<Item = Enum>,
        mut vector_struct: &mut dyn ExactSizeIterator<Item = &mut Struct>,
        mut vector_table: &mut dyn ExactSizeIterator<Item = Table>,
        mut vector_union: &mut dyn ExactSizeIterator<Item = &mut Union>,
        mut vector_opt_struct: &mut dyn ExactSizeIterator<Item = Option<&mut Struct>>,
        mut vector_opt_union: &mut dyn ExactSizeIterator<Item = Option<&mut Union>>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<VectorCompound, false>(
            (
                fidl::encoding::Iterator(vector_bits),
                fidl::encoding::Iterator(vector_enum),
                fidl::encoding::Iterator(vector_struct.map(|x| &*x)),
                fidl::encoding::Iterator(vector_table),
                fidl::encoding::Iterator(vector_union.map(|x| &*x)),
                fidl::encoding::Iterator(vector_opt_struct.map(|x| x.map(|x| &*x))),
                fidl::encoding::Iterator(vector_opt_union.map(|x| x.map(|x| &*x))),
            ),
            0,
            0x53a1fc56e8b3cff3,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&mut dyn ExactSizeIterator<Item = &str>>,
        mut opt_vector_struct: Option<&mut dyn ExactSizeIterator<Item = &mut Struct>>,
        mut opt_vector_opt_struct: Option<&mut dyn ExactSizeIterator<Item = Option<&mut Struct>>>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<VectorOptional, false>(
            (
                opt_vector_uint8,
                opt_vector_string.map(fidl::encoding::Iterator),
                opt_vector_struct.map(|x| x.map(|x| &*x)).map(fidl::encoding::Iterator),
                opt_vector_opt_struct
                    .map(|x| x.map(|x| x.map(|x| &*x)))
                    .map(fidl::encoding::Iterator),
            ),
            0,
            0x17617b54dfa8d85d,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
    pub fn send_event_array_vector_nested(
        &self,
        mut vector_array_uint8: &mut dyn ExactSizeIterator<Item = &mut [u8; 5]>,
        mut vector_vector_uint8: &mut dyn ExactSizeIterator<Item = &[u8]>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<ArrayVectorNested, false>(
            (
                fidl::encoding::Iterator(vector_array_uint8.map(|x| *x)),
                fidl::encoding::Iterator(vector_vector_uint8),
            ),
            0,
            0x110b72cfebc4037e,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
            opt_string,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
            opt_string,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::duration_begin!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayBasicResponse");
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<Basic>>(
                bytes, handles, msg,
            )?;
            fidl::trace_blob!("fidl:blob", "encode", bytes.as_slice());
            fidl::duration_end!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);

            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &mut Struct,
        mut table: Table,
        mut union: &mut Union,
        mut opt_struct: Option<&mut Struct>,
        mut opt_union: Option<&mut Union>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(bits, enum_, struct_, table, union, opt_struct, opt_union);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &mut Struct,
        mut table: Table,
        mut union: &mut Union,
        mut opt_struct: Option<&mut Struct>,
        mut opt_union: Option<&mut Union>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(bits, enum_, struct_, table, union, opt_struct, opt_union);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &mut Struct,
        mut table: Table,
        mut union: &mut Union,
        mut opt_struct: Option<&mut Struct>,
        mut opt_union: Option<&mut Union>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                bits,
                enum_,
                &*struct_,
                &table,
                &*union,
                opt_struct.map(|x| &*x),
                opt_union.map(|x| &*x),
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::duration_begin!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayCompoundResponse");
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<Compound>>(
                bytes, handles, msg,
            )?;
            fidl::trace_blob!("fidl:blob", "encode", bytes.as_slice());
            fidl::duration_end!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);

            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayArrayBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayArrayBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayArrayBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayArrayBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut array_uint8: &mut [u8; 5],
        mut array_uint16: &mut [u16; 5],
        mut array_uint32: &mut [u32; 5],
        mut array_uint64: &mut [u64; 5],
        mut array_int8: &mut [i8; 5],
        mut array_int16: &mut [i16; 5],
        mut array_int32: &mut [i32; 5],
        mut array_int64: &mut [i64; 5],
        mut array_float32: &mut [f32; 5],
        mut array_float64: &mut [f64; 5],
        mut array_string: &mut [&str; 5],
        mut array_opt_string: &mut [Option<&str>; 5],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut array_uint8: &mut [u8; 5],
        mut array_uint16: &mut [u16; 5],
        mut array_uint32: &mut [u32; 5],
        mut array_uint64: &mut [u64; 5],
        mut array_int8: &mut [i8; 5],
        mut array_int16: &mut [i16; 5],
        mut array_int32: &mut [i32; 5],
        mut array_int64: &mut [i64; 5],
        mut array_float32: &mut [f32; 5],
        mut array_float64: &mut [f64; 5],
        mut array_string: &mut [&str; 5],
        mut array_opt_string: &mut [Option<&str>; 5],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut array_uint8: &mut [u8; 5],
        mut array_uint16: &mut [u16; 5],
        mut array_uint32: &mut [u32; 5],
        mut array_uint64: &mut [u64; 5],
        mut array_int8: &mut [i8; 5],
        mut array_int16: &mut [i16; 5],
        mut array_int32: &mut [i32; 5],
        mut array_int64: &mut [i64; 5],
        mut array_float32: &mut [f32; 5],
        mut array_float64: &mut [f64; 5],
        mut array_string: &mut [&str; 5],
        mut array_opt_string: &mut [Option<&str>; 5],
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                &*array_uint8,
                &*array_uint16,
                &*array_uint32,
                &*array_uint64,
                &*array_int8,
                &*array_int16,
                &*array_int32,
                &*array_int64,
                &*array_float32,
                &*array_float64,
                &{
                    let mut temp: [String; 5] =
                        fidl::new_empty!(fidl::encoding::Array<fidl::encoding::UnboundedString, 5>);
                    for (i, x) in array_string.iter_mut().enumerate() {
                        temp[i] = x.to_string();
                    }
                    temp
                },
                &{
                    let mut temp: [Option<String>; 5] = fidl::new_empty!(
                        fidl::encoding::Array<
                            fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                            5,
                        >
                    );
                    for (i, x) in array_opt_string.iter_mut().enumerate() {
                        temp[i] = x.map(str::to_string);
                    }
                    temp
                },
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::duration_begin!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayArrayBasicResponse");
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<ArrayBasic>>(
                bytes, handles, msg,
            )?;
            fidl::trace_blob!("fidl:blob", "encode", bytes.as_slice());
            fidl::duration_end!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);

            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayArrayCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayArrayCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayArrayCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayArrayCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut array_bits: &mut [Bits; 5],
        mut array_enum: &mut [Enum; 5],
        mut array_struct: &mut [&mut Struct; 5],
        mut array_table: &mut [Table; 5],
        mut array_union: &mut [&mut Union; 5],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(array_bits, array_enum, array_struct, array_table, array_union);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut array_bits: &mut [Bits; 5],
        mut array_enum: &mut [Enum; 5],
        mut array_struct: &mut [&mut Struct; 5],
        mut array_table: &mut [Table; 5],
        mut array_union: &mut [&mut Union; 5],
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(array_bits, array_enum, array_struct, array_table, array_union);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut array_bits: &mut [Bits; 5],
        mut array_enum: &mut [Enum; 5],
        mut array_struct: &mut [&mut Struct; 5],
        mut array_table: &mut [Table; 5],
        mut array_union: &mut [&mut Union; 5],
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                &*array_bits,
                &*array_enum,
                &{
                    let mut temp: [Struct; 5] = fidl::new_empty!(fidl::encoding::Array<Struct, 5>);
                    for (i, x) in array_struct.iter_mut().enumerate() {
                        temp[i] = x.clone();
                    }
                    temp
                },
                &*array_table,
                &{
                    let mut temp: [Union; 5] = fidl::new_empty!(fidl::encoding::Array<Union, 5>);
                    for (i, x) in array_union.iter_mut().enumerate() {
                        temp[i] = x.clone();
                    }
                    temp
                },
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::duration_begin!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayArrayCompoundResponse");
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<ArrayCompound>>(
                bytes, handles, msg,
            )?;
            fidl::trace_blob!("fidl:blob", "encode", bytes.as_slice());
            fidl::duration_end!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);

            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayVectorBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayVectorBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayVectorBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayVectorBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &mut dyn ExactSizeIterator<Item = &str>,
        mut vector_opt_string: &mut dyn ExactSizeIterator<Item = Option<&str>>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &mut dyn ExactSizeIterator<Item = &str>,
        mut vector_opt_string: &mut dyn ExactSizeIterator<Item = Option<&str>>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &mut dyn ExactSizeIterator<Item = &str>,
        mut vector_opt_string: &mut dyn ExactSizeIterator<Item = Option<&str>>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                fidl::encoding::Iterator(vector_string),
                fidl::encoding::Iterator(vector_opt_string),
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::duration_begin!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayVectorBasicResponse");
            fidl::encoding::Encoder::encode::<fidl::encoding::TransactionMessageType<VectorBasic>>(
                bytes, handles, msg,
            )?;
            fidl::trace_blob!("fidl:blob", "encode", bytes.as_slice());
            fidl::duration_end!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);

            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayVectorCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayVectorCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayVectorCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayVectorCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut vector_bits: &mut dyn ExactSizeIterator<Item = Bits>,
        mut vector_enum: &mut dyn ExactSizeIterator<Item = Enum>,
        mut vector_struct: &mut dyn ExactSizeIterator<Item = &mut Struct>,
        mut vector_table: &mut dyn ExactSizeIterator<Item = Table>,
        mut vector_union: &mut dyn ExactSizeIterator<Item = &mut Union>,
        mut vector_opt_struct: &mut dyn ExactSizeIterator<Item = Option<&mut Struct>>,
        mut vector_opt_union: &mut dyn ExactSizeIterator<Item = Option<&mut Union>>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut vector_bits: &mut dyn ExactSizeIterator<Item = Bits>,
        mut vector_enum: &mut dyn ExactSizeIterator<Item = Enum>,
        mut vector_struct: &mut dyn ExactSizeIterator<Item = &mut Struct>,
        mut vector_table: &mut dyn ExactSizeIterator<Item = Table>,
        mut vector_union: &mut dyn ExactSizeIterator<Item = &mut Union>,
        mut vector_opt_struct: &mut dyn ExactSizeIterator<Item = Option<&mut Struct>>,
        mut vector_opt_union: &mut dyn ExactSizeIterator<Item = Option<&mut Union>>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut vector_bits: &mut dyn ExactSizeIterator<Item = Bits>,
        mut vector_enum: &mut dyn ExactSizeIterator<Item = Enum>,
        mut vector_struct: &mut dyn ExactSizeIterator<Item = &mut Struct>,
        mut vector_table: &mut dyn ExactSizeIterator<Item = Table>,
        mut vector_union: &mut dyn ExactSizeIterator<Item = &mut Union>,
        mut vector_opt_struct: &mut dyn ExactSizeIterator<Item = Option<&mut Struct>>,
        mut vector_opt_union: &mut dyn ExactSizeIterator<Item = Option<&mut Union>>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                fidl::encoding::Iterator(vector_bits),
                fidl::encoding::Iterator(vector_enum),
                fidl::encoding::Iterator(vector_struct.map(|x| &*x)),
                fidl::encoding::Iterator(vector_table),
                fidl::encoding::Iterator(vector_union.map(|x| &*x)),
                fidl::encoding::Iterator(vector_opt_struct.map(|x| x.map(|x| &*x))),
                fidl::encoding::Iterator(vector_opt_union.map(|x| x.map(|x| &*x))),
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::duration_begin!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayVectorCompoundResponse");
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<VectorCompound>,
            >(bytes, handles, msg)?;
            fidl::trace_blob!("fidl:blob", "encode", bytes.as_slice());
            fidl::duration_end!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);

            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayVectorOptionalResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayVectorOptionalResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayVectorOptionalResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayVectorOptionalResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&mut dyn ExactSizeIterator<Item = &str>>,
        mut opt_vector_struct: Option<&mut dyn ExactSizeIterator<Item = &mut Struct>>,
        mut opt_vector_opt_struct: Option<&mut dyn ExactSizeIterator<Item = Option<&mut Struct>>>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        );
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&mut dyn ExactSizeIterator<Item = &str>>,
        mut opt_vector_struct: Option<&mut dyn ExactSizeIterator<Item = &mut Struct>>,
        mut opt_vector_opt_struct: Option<&mut dyn ExactSizeIterator<Item = Option<&mut Struct>>>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        );
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&mut dyn ExactSizeIterator<Item = &str>>,
        mut opt_vector_struct: Option<&mut dyn ExactSizeIterator<Item = &mut Struct>>,
        mut opt_vector_opt_struct: Option<&mut dyn ExactSizeIterator<Item = Option<&mut Struct>>>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                opt_vector_uint8,
                opt_vector_string.map(fidl::encoding::Iterator),
                opt_vector_struct.map(|x| x.map(|x| &*x)).map(fidl::encoding::Iterator),
                opt_vector_opt_struct
                    .map(|x| x.map(|x| x.map(|x| &*x)))
                    .map(fidl::encoding::Iterator),
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::duration_begin!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayVectorOptionalResponse");
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<VectorOptional>,
            >(bytes, handles, msg)?;
            fidl::trace_blob!("fidl:blob", "encode", bytes.as_slice());
            fidl::duration_end!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);

            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayArrayVectorNestedResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
    ordinal: u64,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayArrayVectorNestedResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayArrayVectorNestedResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayArrayVectorNestedResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut vector_array_uint8: &mut dyn ExactSizeIterator<Item = &mut [u8; 5]>,
        mut vector_vector_uint8: &mut dyn ExactSizeIterator<Item = &[u8]>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(vector_array_uint8, vector_vector_uint8);
        if r.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        r
    }

    /// Similar to "send" but does not shutdown the channel if
    /// an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut vector_array_uint8: &mut dyn ExactSizeIterator<Item = &mut [u8; 5]>,
        mut vector_vector_uint8: &mut dyn ExactSizeIterator<Item = &[u8]>,
    ) -> Result<(), fidl::Error> {
        let r = self.send_raw(vector_array_uint8, vector_vector_uint8);
        self.drop_without_shutdown();
        r
    }

    fn send_raw(
        &self,
        mut vector_array_uint8: &mut dyn ExactSizeIterator<Item = &mut [u8; 5]>,
        mut vector_vector_uint8: &mut dyn ExactSizeIterator<Item = &[u8]>,
    ) -> Result<(), fidl::Error> {
        let msg = fidl::encoding::TransactionMessage {
            header: fidl::encoding::TransactionHeader::new(
                self.tx_id,
                self.ordinal,
                fidl::encoding::DynamicFlags::empty(),
            ),
            body: (
                fidl::encoding::Iterator(vector_array_uint8.map(|x| *x)),
                fidl::encoding::Iterator(vector_vector_uint8),
            ),
        };

        fidl::encoding::with_tls_encode_buf(|bytes, handles| {
            fidl::duration_begin!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "name" => "test.typesinprotocols/ProtocolTwoWayArrayVectorNestedResponse");
            fidl::encoding::Encoder::encode::<
                fidl::encoding::TransactionMessageType<ArrayVectorNested>,
            >(bytes, handles, msg)?;
            fidl::trace_blob!("fidl:blob", "encode", bytes.as_slice());
            fidl::duration_end!("fidl", "encode", "bindings" => _FIDL_TRACE_BINDINGS_RUST, "size" => bytes.len() as u32, "handle_count" => handles.len() as u32);

            self.control_handle.inner.send_raw_msg(&*bytes, &mut *handles)
        })
    }
}
