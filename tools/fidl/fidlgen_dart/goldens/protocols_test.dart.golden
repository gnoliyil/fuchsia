// WARNING: This file is machine generated by fidlgen.
// @dart = 2.12

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = zx_select_case_sensitivity

library fidl_test_protocols_test;

import 'dart:async' as $async;
import 'dart:core' hide Error, Future, Match, Set, Stream, Type;
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zircon;

import 'package:fidl_zx/fidl_async.dart' as lib$zx;
import './fidl_async.dart';

// ignore_for_file: always_specify_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: directives_ordering
// ignore_for_file: one_member_abstracts
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: library_prefixes
// ignore_for_file: unused_shown_name
// ignore_for_file: annotate_overrides

class AnotherDiscoverableProtocol$TestBase
    extends AnotherDiscoverableProtocol {}

class ChannelProtocol$TestBase extends ChannelProtocol {
  @override
  $async.Future<void> methodA(int a, int b) {
    return $async.Future.error(
        UnimplementedError(
            r'methodA not implemented on ChannelProtocol test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Stream<ChannelProtocol$EventA$Response> get eventA {
    return $async.Stream.fromFuture($async.Future.error(
        UnimplementedError(
            r'eventA not implemented on ChannelProtocol test base. Please implement.'),
        StackTrace.current));
  }

  @override
  $async.Future<int> methodB(int a, int b) {
    return $async.Future.error(
        UnimplementedError(
            r'methodB not implemented on ChannelProtocol test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<void> takeHandle($zircon.Handle h) {
    return $async.Future.error(
        UnimplementedError(
            r'takeHandle not implemented on ChannelProtocol test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<$zircon.Socket> mutateSocket($zircon.Socket a) {
    return $async.Future.error(
        UnimplementedError(
            r'mutateSocket not implemented on ChannelProtocol test base. Please implement.'),
        StackTrace.current);
  }
}

class DiscoverableProtocol$TestBase extends DiscoverableProtocol {
  @override
  $async.Future<void> method() {
    return $async.Future.error(
        UnimplementedError(
            r'method not implemented on DiscoverableProtocol test base. Please implement.'),
        StackTrace.current);
  }
}

class HandleRightsProtocol$TestBase extends HandleRightsProtocol {
  @override
  $async.Future<void> noResponseMethod($zircon.Socket h) {
    return $async.Future.error(
        UnimplementedError(
            r'noResponseMethod not implemented on HandleRightsProtocol test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<$zircon.Socket> responseMethod($zircon.Socket h) {
    return $async.Future.error(
        UnimplementedError(
            r'responseMethod not implemented on HandleRightsProtocol test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Stream<$zircon.Socket> get anEvent {
    return $async.Stream.fromFuture($async.Future.error(
        UnimplementedError(
            r'anEvent not implemented on HandleRightsProtocol test base. Please implement.'),
        StackTrace.current));
  }
}

class ManyParameters$TestBase extends ManyParameters {
  @override
  $async.Future<void> fifteen(
      bool p1,
      bool p2,
      bool p3,
      bool p4,
      bool p5,
      bool p6,
      bool p7,
      bool p8,
      bool p9,
      bool p10,
      bool p11,
      bool p12,
      bool p13,
      bool p14,
      bool p15) {
    return $async.Future.error(
        UnimplementedError(
            r'fifteen not implemented on ManyParameters test base. Please implement.'),
        StackTrace.current);
  }
}

class MethodWithUnion$TestBase extends MethodWithUnion {
  @override
  $async.Future<TheUnion?> unionMethod(TheUnion u) {
    return $async.Future.error(
        UnimplementedError(
            r'unionMethod not implemented on MethodWithUnion test base. Please implement.'),
        StackTrace.current);
  }
}

class Transitional$TestBase extends Transitional {
  @override
  $async.Future<int> request(int x) {
    return $async.Future.error(
        UnimplementedError(
            r'request not implemented on Transitional test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<void> oneWay(int x) {
    return $async.Future.error(
        UnimplementedError(
            r'oneWay not implemented on Transitional test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Stream<int> get event {
    return $async.Stream.fromFuture($async.Future.error(
        UnimplementedError(
            r'event not implemented on Transitional test base. Please implement.'),
        StackTrace.current));
  }
}

class WithAndWithoutRequestResponse$TestBase
    extends WithAndWithoutRequestResponse {
  @override
  $async.Future<void> noRequestNoResponse() {
    return $async.Future.error(
        UnimplementedError(
            r'noRequestNoResponse not implemented on WithAndWithoutRequestResponse test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<void> noRequestEmptyResponse() {
    return $async.Future.error(
        UnimplementedError(
            r'noRequestEmptyResponse not implemented on WithAndWithoutRequestResponse test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<String> noRequestWithResponse() {
    return $async.Future.error(
        UnimplementedError(
            r'noRequestWithResponse not implemented on WithAndWithoutRequestResponse test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<void> withRequestNoResponse(String arg) {
    return $async.Future.error(
        UnimplementedError(
            r'withRequestNoResponse not implemented on WithAndWithoutRequestResponse test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<void> withRequestEmptyResponse(String arg) {
    return $async.Future.error(
        UnimplementedError(
            r'withRequestEmptyResponse not implemented on WithAndWithoutRequestResponse test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<String> withRequestWithResponse(String arg) {
    return $async.Future.error(
        UnimplementedError(
            r'withRequestWithResponse not implemented on WithAndWithoutRequestResponse test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Stream<void> get onEmptyResponse {
    return $async.Stream.fromFuture($async.Future.error(
        UnimplementedError(
            r'onEmptyResponse not implemented on WithAndWithoutRequestResponse test base. Please implement.'),
        StackTrace.current));
  }

  @override
  $async.Stream<String> get onWithResponse {
    return $async.Stream.fromFuture($async.Future.error(
        UnimplementedError(
            r'onWithResponse not implemented on WithAndWithoutRequestResponse test base. Please implement.'),
        StackTrace.current));
  }
}

class WithErrorSyntax$TestBase extends WithErrorSyntax {
  @override
  $async.Future<WithErrorSyntax$ResponseAsStruct$Response> responseAsStruct() {
    return $async.Future.error(
        UnimplementedError(
            r'responseAsStruct not implemented on WithErrorSyntax test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<void> errorAsPrimitive() {
    return $async.Future.error(
        UnimplementedError(
            r'errorAsPrimitive not implemented on WithErrorSyntax test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<void> errorAsEnum() {
    return $async.Future.error(
        UnimplementedError(
            r'errorAsEnum not implemented on WithErrorSyntax test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<$zircon.Handle> handleInResult() {
    return $async.Future.error(
        UnimplementedError(
            r'handleInResult not implemented on WithErrorSyntax test base. Please implement.'),
        StackTrace.current);
  }
}

class WithProtocolEnds$TestBase extends WithProtocolEnds {
  @override
  $async.Future<$fidl.InterfaceHandle<DiscoverableProtocol>?> clientEnds(
      $fidl.InterfaceHandle<DiscoverableProtocol> in$) {
    return $async.Future.error(
        UnimplementedError(
            r'clientEnds not implemented on WithProtocolEnds test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<$fidl.InterfaceRequest<DiscoverableProtocol>> serverEnds(
      $fidl.InterfaceRequest<DiscoverableProtocol>? in$) {
    return $async.Future.error(
        UnimplementedError(
            r'serverEnds not implemented on WithProtocolEnds test base. Please implement.'),
        StackTrace.current);
  }

  @override
  $async.Future<ProtocolEnds> structContainingEnds(ProtocolEnds in$) {
    return $async.Future.error(
        UnimplementedError(
            r'structContainingEnds not implemented on WithProtocolEnds test base. Please implement.'),
        StackTrace.current);
  }
}
