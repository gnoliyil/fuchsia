// WARNING: This file is machine generated by fidlgen.
// @dart = 2.12

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = zx_select_case_sensitivity

library fidl_test_handlesintypes_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zircon;

// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: directives_ordering
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: override_on_non_overriding_member

class ObjType extends $fidl.Enum {
  static const Map<int, ObjType> _values = {
    0x0: none,
    0x3: vmo,
  };
  factory ObjType(int _v) {
    if (!_values.containsKey(_v)) {
      throw $fidl.FidlError('Invalid strict enum value: $_v',
          $fidl.FidlErrorCode.fidlInvalidEnumValue);
    }
    return _values[_v]!;
  }
  static const ObjType none = ObjType._(0x0);
  static const ObjType vmo = ObjType._(0x3);

  const ObjType._(this.$value);

  @override
  final int $value;

  static const Map<String, ObjType> $valuesMap = {
    r'none': none,
    r'vmo': vmo,
  };

  static const List<ObjType> $values = [
    none,
    vmo,
  ];

  static ObjType? $valueOf(String name) => $valuesMap[name];

  @override
  bool isUnknown() {
    return false;
  }

  static ObjType _ctor(int v) => ObjType(v);
}

const $fidl.EnumType<ObjType> kobj_type_Type = $fidl.EnumType<ObjType>(
    type: $fidl.Uint32Type(),
    values: {0x0: null, 0x3: null},
    ctor: ObjType._ctor);

enum EmptyResourceUnionTag {
  $unknown,
}

const Map<int, EmptyResourceUnionTag> _EmptyResourceUnionTag_map = {};

class EmptyResourceUnion extends $fidl.Union {
  const EmptyResourceUnion.with$UnknownData(
      this._ordinal, $fidl.UnknownRawData data)
      : _data = data;

  EmptyResourceUnion._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  EmptyResourceUnionTag get $tag =>
      _EmptyResourceUnionTag_map[_ordinal] ?? EmptyResourceUnionTag.$unknown;

  $fidl.UnknownRawData? get $unknownData {
    return _data;
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static EmptyResourceUnion _ctor(int ordinal, Object data) {
    return EmptyResourceUnion._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<EmptyResourceUnion> kEmptyResourceUnion_Type =
    $fidl.UnionType<EmptyResourceUnion>(
  members: <int, $fidl.FidlType>{},
  ctor: EmptyResourceUnion._ctor,
  flexible: true,
  resource: true,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<EmptyResourceUnion> kEmptyResourceUnion_OptType =
    $fidl.NullableUnionType<EmptyResourceUnion>(
  members: <int, $fidl.FidlType>{},
  ctor: EmptyResourceUnion._ctor,
  flexible: true,
  resource: true,
);

enum UnionWithHandleTag {
  $unknown,
  h, // 0x1
}

const Map<int, UnionWithHandleTag> _UnionWithHandleTag_map = {
  1: UnionWithHandleTag.h,
};

class UnionWithHandle extends $fidl.Union {
  const UnionWithHandle.withH($zircon.Vmo value)
      : _ordinal = 1,
        _data = value;
  const UnionWithHandle.with$UnknownData(
      this._ordinal, $fidl.UnknownRawData data)
      : _data = data;

  UnionWithHandle._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  UnionWithHandleTag get $tag =>
      _UnionWithHandleTag_map[_ordinal] ?? UnionWithHandleTag.$unknown;

  $zircon.Vmo? get h {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static UnionWithHandle _ctor(int ordinal, Object data) {
    return UnionWithHandle._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<UnionWithHandle> kUnionWithHandle_Type =
    $fidl.UnionType<UnionWithHandle>(
  members: <int, $fidl.FidlType>{
    1: $fidl.VmoType(objectType: 3, rights: 2147483648),
  },
  ctor: UnionWithHandle._ctor,
  flexible: true,
  resource: true,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<UnionWithHandle> kUnionWithHandle_OptType =
    $fidl.NullableUnionType<UnionWithHandle>(
  members: <int, $fidl.FidlType>{
    1: $fidl.VmoType(objectType: 3, rights: 2147483648),
  },
  ctor: UnionWithHandle._ctor,
  flexible: true,
  resource: true,
);

class EmptyResourceStruct extends $fidl.Struct {
  const EmptyResourceStruct({
    this.reserved = 0x0,
  });
  EmptyResourceStruct.clone(
    EmptyResourceStruct $orig, {
    int? reserved,
  }) : this(
          reserved: reserved ?? $orig.reserved,
        );

  EmptyResourceStruct $cloneWith({
    int? reserved,
  }) {
    return EmptyResourceStruct(
      reserved: reserved ?? this.reserved,
    );
  }

  final int reserved;

  @override
  List<Object?> get $fields {
    return <Object?>[
      reserved,
    ];
  }

  static const $fieldType0 = $fidl.Uint8Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, reserved, $offset + 0, $depth);
  }

  static EmptyResourceStruct _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 0, 1);
        return EmptyResourceStruct(
            reserved: $fieldType0.decode($decoder, $offset + 0, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<EmptyResourceStruct> kEmptyResourceStruct_Type =
    $fidl.StructType<EmptyResourceStruct>(
        inlineSize: 1, structDecode: EmptyResourceStruct._structDecode);

class HandlesInTypes extends $fidl.Struct {
  const HandlesInTypes({
    required this.normalHandle,
    required this.handleInVec,
    required this.handleInArray,
    required this.handleInMixedVecArray,
    required this.tableWithHandle,
    required this.unionWithHandle,
  });
  HandlesInTypes.clone(
    HandlesInTypes $orig, {
    $zircon.Vmo? normalHandle,
    List<$zircon.Vmo>? handleInVec,
    List<$zircon.Vmo>? handleInArray,
    List<List<$zircon.Vmo>>? handleInMixedVecArray,
    TableWithHandle? tableWithHandle,
    UnionWithHandle? unionWithHandle,
  }) : this(
          normalHandle: normalHandle ?? $orig.normalHandle,
          handleInVec: handleInVec ?? $orig.handleInVec,
          handleInArray: handleInArray ?? $orig.handleInArray,
          handleInMixedVecArray:
              handleInMixedVecArray ?? $orig.handleInMixedVecArray,
          tableWithHandle: tableWithHandle ?? $orig.tableWithHandle,
          unionWithHandle: unionWithHandle ?? $orig.unionWithHandle,
        );

  HandlesInTypes $cloneWith({
    $zircon.Vmo? normalHandle,
    List<$zircon.Vmo>? handleInVec,
    List<$zircon.Vmo>? handleInArray,
    List<List<$zircon.Vmo>>? handleInMixedVecArray,
    TableWithHandle? tableWithHandle,
    UnionWithHandle? unionWithHandle,
  }) {
    return HandlesInTypes(
      normalHandle: normalHandle ?? this.normalHandle,
      handleInVec: handleInVec ?? this.handleInVec,
      handleInArray: handleInArray ?? this.handleInArray,
      handleInMixedVecArray:
          handleInMixedVecArray ?? this.handleInMixedVecArray,
      tableWithHandle: tableWithHandle ?? this.tableWithHandle,
      unionWithHandle: unionWithHandle ?? this.unionWithHandle,
    );
  }

  final $zircon.Vmo normalHandle;
  final List<$zircon.Vmo> handleInVec;
  final List<$zircon.Vmo> handleInArray;
  final List<List<$zircon.Vmo>> handleInMixedVecArray;
  final TableWithHandle tableWithHandle;
  final UnionWithHandle unionWithHandle;

  @override
  List<Object?> get $fields {
    return <Object?>[
      normalHandle,
      handleInVec,
      handleInArray,
      handleInMixedVecArray,
      tableWithHandle,
      unionWithHandle,
    ];
  }

  static const $fieldType0 = $fidl.VmoType(objectType: 3, rights: 2147483648);
  static const $fieldType1 = $fidl.VectorType<$zircon.Vmo, List<$zircon.Vmo>>(
      element: $fidl.VmoType(objectType: 3, rights: 2147483648),
      maybeElementCount: null);
  static const $fieldType2 = $fidl.ArrayType<$zircon.Vmo, List<$zircon.Vmo>>(
      element: $fidl.VmoType(objectType: 3, rights: 2147483648),
      elementCount: 5);
  static const $fieldType3 =
      $fidl.VectorType<List<$zircon.Vmo>, List<List<$zircon.Vmo>>>(
          element: $fidl.ArrayType<$zircon.Vmo, List<$zircon.Vmo>>(
              element: $fidl.VmoType(objectType: 3, rights: 2147483648),
              elementCount: 5),
          maybeElementCount: null);
  static const $fieldType4 = kTableWithHandle_Type;
  static const $fieldType5 = kUnionWithHandle_Type;

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, normalHandle, $offset + 0, $depth);
    $fieldType1.encode($encoder, handleInVec, $offset + 8, $depth);
    $fieldType2.encode($encoder, handleInArray, $offset + 24, $depth);
    $fieldType3.encode($encoder, handleInMixedVecArray, $offset + 48, $depth);
    $fieldType4.encode($encoder, tableWithHandle, $offset + 64, $depth);
    $fieldType5.encode($encoder, unionWithHandle, $offset + 80, $depth);
  }

  static HandlesInTypes _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 4, 4);

        $decoder.checkPadding($offset + 44, 4);
        return HandlesInTypes(
            normalHandle: $fieldType0.decode($decoder, $offset + 0, $depth),
            handleInVec: $fieldType1.decode($decoder, $offset + 8, $depth),
            handleInArray: $fieldType2.decode($decoder, $offset + 24, $depth),
            handleInMixedVecArray:
                $fieldType3.decode($decoder, $offset + 48, $depth),
            tableWithHandle: $fieldType4.decode($decoder, $offset + 64, $depth),
            unionWithHandle:
                $fieldType5.decode($decoder, $offset + 80, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<HandlesInTypes> kHandlesInTypes_Type =
    $fidl.StructType<HandlesInTypes>(
        inlineSize: 96, structDecode: HandlesInTypes._structDecode);

class EmptyResourceTable extends $fidl.Table {
  const EmptyResourceTable({
    this.$unknownData,
  });

  EmptyResourceTable._(Map<int, dynamic> argv, this.$unknownData);

  EmptyResourceTable $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
  }) {
    return EmptyResourceTable();
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;

  @override
  dynamic $field(int index) {
    switch (index) {
      
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {};
  }

  static EmptyResourceTable _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      EmptyResourceTable._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<EmptyResourceTable> kEmptyResourceTable_Type =
    $fidl.TableType<EmptyResourceTable>(
  inlineSize: 16,
  members: [],
  ctor: EmptyResourceTable._ctor,
  resource: true,
);

class TableWithHandle extends $fidl.Table {
  const TableWithHandle({
    this.$unknownData,
    this.h,
  });

  TableWithHandle._(Map<int, dynamic> argv, this.$unknownData) : h = argv[1];

  TableWithHandle $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<$zircon.Vmo> h =
        const $fidl.OptionalNullable.undefined(),
  }) {
    return TableWithHandle(
      h: h.or(this.h),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final $zircon.Vmo? h;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return h;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: h,
    };
  }

  static TableWithHandle _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      TableWithHandle._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<TableWithHandle> kTableWithHandle_Type =
    $fidl.TableType<TableWithHandle>(
  inlineSize: 16,
  members: [
    $fidl.VmoType(objectType: 3, rights: 2147483648),
  ],
  ctor: TableWithHandle._ctor,
  resource: true,
);
