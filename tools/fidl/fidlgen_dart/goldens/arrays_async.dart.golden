// WARNING: This file is machine generated by fidlgen.
// @dart = 2.12

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = zx_select_case_sensitivity

library fidl_test_arrays_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zircon;

// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: directives_ordering
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: override_on_non_overriding_member

enum UnionLargeArrayTag {
  a, // 0x1
}

const Map<int, UnionLargeArrayTag> _UnionLargeArrayTag_map = {
  1: UnionLargeArrayTag.a,
};

class UnionLargeArray extends $fidl.Union {
  const UnionLargeArray.withA(Uint32List value)
      : _ordinal = 1,
        _data = value;

  UnionLargeArray._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  UnionLargeArrayTag get $tag => _UnionLargeArrayTag_map[_ordinal]!;

  Uint32List? get a {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static UnionLargeArray _ctor(int ordinal, Object data) {
    return UnionLargeArray._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<UnionLargeArray> kUnionLargeArray_Type =
    $fidl.UnionType<UnionLargeArray>(
  members: <int, $fidl.FidlType>{
    1: $fidl.ArrayType<int, Uint32List>(
        element: $fidl.Uint32Type(), elementCount: 100),
  },
  ctor: UnionLargeArray._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<UnionLargeArray> kUnionLargeArray_OptType =
    $fidl.NullableUnionType<UnionLargeArray>(
  members: <int, $fidl.FidlType>{
    1: $fidl.ArrayType<int, Uint32List>(
        element: $fidl.Uint32Type(), elementCount: 100),
  },
  ctor: UnionLargeArray._ctor,
  flexible: false,
  resource: false,
);

enum UnionSmallArrayTag {
  a, // 0x1
}

const Map<int, UnionSmallArrayTag> _UnionSmallArrayTag_map = {
  1: UnionSmallArrayTag.a,
};

class UnionSmallArray extends $fidl.Union {
  const UnionSmallArray.withA(Uint32List value)
      : _ordinal = 1,
        _data = value;

  UnionSmallArray._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  UnionSmallArrayTag get $tag => _UnionSmallArrayTag_map[_ordinal]!;

  Uint32List? get a {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static UnionSmallArray _ctor(int ordinal, Object data) {
    return UnionSmallArray._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<UnionSmallArray> kUnionSmallArray_Type =
    $fidl.UnionType<UnionSmallArray>(
  members: <int, $fidl.FidlType>{
    1: $fidl.ArrayType<int, Uint32List>(
        element: $fidl.Uint32Type(), elementCount: 2),
  },
  ctor: UnionSmallArray._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<UnionSmallArray> kUnionSmallArray_OptType =
    $fidl.NullableUnionType<UnionSmallArray>(
  members: <int, $fidl.FidlType>{
    1: $fidl.ArrayType<int, Uint32List>(
        element: $fidl.Uint32Type(), elementCount: 2),
  },
  ctor: UnionSmallArray._ctor,
  flexible: false,
  resource: false,
);

class StructLargeArray extends $fidl.Struct {
  const StructLargeArray({
    required this.a,
  });
  StructLargeArray.clone(
    StructLargeArray $orig, {
    Uint32List? a,
  }) : this(
          a: a ?? $orig.a,
        );

  StructLargeArray $cloneWith({
    Uint32List? a,
  }) {
    return StructLargeArray(
      a: a ?? this.a,
    );
  }

  final Uint32List a;

  @override
  List<Object?> get $fields {
    return <Object?>[
      a,
    ];
  }

  static const $fieldType0 = $fidl.ArrayType<int, Uint32List>(
      element: $fidl.Uint32Type(), elementCount: 100);

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, a, $offset + 0, $depth);
  }

  static StructLargeArray _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        return StructLargeArray(
            a: $fieldType0.decode($decoder, $offset + 0, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<StructLargeArray> kStructLargeArray_Type =
    $fidl.StructType<StructLargeArray>(
        inlineSize: 400, structDecode: StructLargeArray._structDecode);

class StructSmallArray extends $fidl.Struct {
  const StructSmallArray({
    required this.a,
  });
  StructSmallArray.clone(
    StructSmallArray $orig, {
    Uint32List? a,
  }) : this(
          a: a ?? $orig.a,
        );

  StructSmallArray $cloneWith({
    Uint32List? a,
  }) {
    return StructSmallArray(
      a: a ?? this.a,
    );
  }

  final Uint32List a;

  @override
  List<Object?> get $fields {
    return <Object?>[
      a,
    ];
  }

  static const $fieldType0 = $fidl.ArrayType<int, Uint32List>(
      element: $fidl.Uint32Type(), elementCount: 2);

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, a, $offset + 0, $depth);
  }

  static StructSmallArray _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        return StructSmallArray(
            a: $fieldType0.decode($decoder, $offset + 0, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<StructSmallArray> kStructSmallArray_Type =
    $fidl.StructType<StructSmallArray>(
        inlineSize: 8, structDecode: StructSmallArray._structDecode);

class TableLargeArray extends $fidl.Table {
  const TableLargeArray({
    this.$unknownData,
    this.a,
  });

  TableLargeArray._(Map<int, dynamic> argv, this.$unknownData) : a = argv[1];

  TableLargeArray $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<Uint32List> a =
        const $fidl.OptionalNullable.undefined(),
  }) {
    return TableLargeArray(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final Uint32List? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static TableLargeArray _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      TableLargeArray._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<TableLargeArray> kTableLargeArray_Type =
    $fidl.TableType<TableLargeArray>(
  inlineSize: 16,
  members: [
    $fidl.ArrayType<int, Uint32List>(
        element: $fidl.Uint32Type(), elementCount: 100),
  ],
  ctor: TableLargeArray._ctor,
  resource: false,
);

class TableSmallArray extends $fidl.Table {
  const TableSmallArray({
    this.$unknownData,
    this.a,
  });

  TableSmallArray._(Map<int, dynamic> argv, this.$unknownData) : a = argv[1];

  TableSmallArray $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<Uint32List> a =
        const $fidl.OptionalNullable.undefined(),
  }) {
    return TableSmallArray(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final Uint32List? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static TableSmallArray _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      TableSmallArray._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<TableSmallArray> kTableSmallArray_Type =
    $fidl.TableType<TableSmallArray>(
  inlineSize: 16,
  members: [
    $fidl.ArrayType<int, Uint32List>(
        element: $fidl.Uint32Type(), elementCount: 2),
  ],
  ctor: TableSmallArray._ctor,
  resource: false,
);
