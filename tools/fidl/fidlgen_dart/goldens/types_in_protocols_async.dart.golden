// WARNING: This file is machine generated by fidlgen.
// @dart = 2.12

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

library fidl_test_typesinprotocols_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zircon;

import 'package:fidl_zx/fidl_async.dart' as lib$zx;
// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: directives_ordering
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: override_on_non_overriding_member

class Enum extends $fidl.Enum {
  static final Map<int, Enum> _values = {
    0x1: val,
  };
  factory Enum(int _v) {
    if (!_values.containsKey(_v)) {
      _values[_v] = Enum._(_v, true);
    }
    return _values[_v]!;
  }
  static const Enum val = Enum._(0x1, false);

  /// Default unknown placeholder.
  static const Enum $unknown = Enum._(0xffffffff, true);

  const Enum._(this.$value, this._isUnknown);

  @override
  final int $value;

  final bool _isUnknown;

  static const Map<String, Enum> $valuesMap = {
    r'val': val,
  };

  static const List<Enum> $values = [
    val,
  ];

  static Enum? $valueOf(String name) => $valuesMap[name];

  @override
  bool isUnknown() {
    return _isUnknown;
  }

  static Enum _ctor(int v) => Enum(v);
}

const $fidl.EnumType<Enum> kEnum_Type = $fidl.EnumType<Enum>(
    type: $fidl.Uint32Type(), values: {0x1: null}, ctor: Enum._ctor);

class Bits extends $fidl.Bits {
  factory Bits(int _v) {
    return Bits._(_v);
  }
  static const Bits val = Bits._(0x1);
  static const Bits $none = Bits._(0);
  static const Bits $mask = Bits._(0x1);

  const Bits._(this.$value);

  Bits operator |(Bits other) {
    return Bits._($value | other.$value);
  }

  Bits operator &(Bits other) {
    return Bits._($value & other.$value);
  }

  Bits operator ~() {
    return Bits._(~$value & $mask.$value);
  }

  @override
  final int $value;

  @override
  bool hasUnknownBits() {
    return getUnknownBits() != 0;
  }

  @override
  int getUnknownBits() {
    return $value & ~$mask.$value;
  }

  static Bits _ctor(int v) => Bits(v);
}

const $fidl.BitsType<Bits> kBits_Type =
    $fidl.BitsType<Bits>(type: $fidl.Uint32Type(), ctor: Bits._ctor);

enum ProtocolErrorArrayBasicResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, ProtocolErrorArrayBasicResultTag>
    _ProtocolErrorArrayBasicResultTag_map = {
  1: ProtocolErrorArrayBasicResultTag.response,
  2: ProtocolErrorArrayBasicResultTag.err,
};

class ProtocolErrorArrayBasicResult extends $fidl.Union {
  const ProtocolErrorArrayBasicResult.withResponse(ArrayBasic value)
      : _ordinal = 1,
        _data = value;

  const ProtocolErrorArrayBasicResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  ProtocolErrorArrayBasicResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ProtocolErrorArrayBasicResultTag get $tag =>
      _ProtocolErrorArrayBasicResultTag_map[_ordinal]!;

  ArrayBasic? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ProtocolErrorArrayBasicResult _ctor(int ordinal, Object data) {
    return ProtocolErrorArrayBasicResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ProtocolErrorArrayBasicResult>
    kProtocol_ErrorArrayBasic_Result_Type =
    $fidl.UnionType<ProtocolErrorArrayBasicResult>(
  members: <int, $fidl.FidlType>{
    1: kArrayBasic_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorArrayBasicResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ProtocolErrorArrayBasicResult>
    kProtocol_ErrorArrayBasic_Result_OptType =
    $fidl.NullableUnionType<ProtocolErrorArrayBasicResult>(
  members: <int, $fidl.FidlType>{
    1: kArrayBasic_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorArrayBasicResult._ctor,
  flexible: false,
  resource: false,
);

enum ProtocolErrorArrayCompoundResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, ProtocolErrorArrayCompoundResultTag>
    _ProtocolErrorArrayCompoundResultTag_map = {
  1: ProtocolErrorArrayCompoundResultTag.response,
  2: ProtocolErrorArrayCompoundResultTag.err,
};

class ProtocolErrorArrayCompoundResult extends $fidl.Union {
  const ProtocolErrorArrayCompoundResult.withResponse(ArrayCompound value)
      : _ordinal = 1,
        _data = value;

  const ProtocolErrorArrayCompoundResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  ProtocolErrorArrayCompoundResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ProtocolErrorArrayCompoundResultTag get $tag =>
      _ProtocolErrorArrayCompoundResultTag_map[_ordinal]!;

  ArrayCompound? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ProtocolErrorArrayCompoundResult _ctor(int ordinal, Object data) {
    return ProtocolErrorArrayCompoundResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ProtocolErrorArrayCompoundResult>
    kProtocol_ErrorArrayCompound_Result_Type =
    $fidl.UnionType<ProtocolErrorArrayCompoundResult>(
  members: <int, $fidl.FidlType>{
    1: kArrayCompound_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorArrayCompoundResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ProtocolErrorArrayCompoundResult>
    kProtocol_ErrorArrayCompound_Result_OptType =
    $fidl.NullableUnionType<ProtocolErrorArrayCompoundResult>(
  members: <int, $fidl.FidlType>{
    1: kArrayCompound_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorArrayCompoundResult._ctor,
  flexible: false,
  resource: false,
);

enum ProtocolErrorArrayVectorNestedResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, ProtocolErrorArrayVectorNestedResultTag>
    _ProtocolErrorArrayVectorNestedResultTag_map = {
  1: ProtocolErrorArrayVectorNestedResultTag.response,
  2: ProtocolErrorArrayVectorNestedResultTag.err,
};

class ProtocolErrorArrayVectorNestedResult extends $fidl.Union {
  const ProtocolErrorArrayVectorNestedResult.withResponse(
      ArrayVectorNested value)
      : _ordinal = 1,
        _data = value;

  const ProtocolErrorArrayVectorNestedResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  ProtocolErrorArrayVectorNestedResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ProtocolErrorArrayVectorNestedResultTag get $tag =>
      _ProtocolErrorArrayVectorNestedResultTag_map[_ordinal]!;

  ArrayVectorNested? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ProtocolErrorArrayVectorNestedResult _ctor(int ordinal, Object data) {
    return ProtocolErrorArrayVectorNestedResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ProtocolErrorArrayVectorNestedResult>
    kProtocol_ErrorArrayVectorNested_Result_Type =
    $fidl.UnionType<ProtocolErrorArrayVectorNestedResult>(
  members: <int, $fidl.FidlType>{
    1: kArrayVectorNested_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorArrayVectorNestedResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ProtocolErrorArrayVectorNestedResult>
    kProtocol_ErrorArrayVectorNested_Result_OptType =
    $fidl.NullableUnionType<ProtocolErrorArrayVectorNestedResult>(
  members: <int, $fidl.FidlType>{
    1: kArrayVectorNested_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorArrayVectorNestedResult._ctor,
  flexible: false,
  resource: false,
);

enum ProtocolErrorBasicResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, ProtocolErrorBasicResultTag> _ProtocolErrorBasicResultTag_map = {
  1: ProtocolErrorBasicResultTag.response,
  2: ProtocolErrorBasicResultTag.err,
};

class ProtocolErrorBasicResult extends $fidl.Union {
  const ProtocolErrorBasicResult.withResponse(Basic value)
      : _ordinal = 1,
        _data = value;

  const ProtocolErrorBasicResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  ProtocolErrorBasicResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ProtocolErrorBasicResultTag get $tag =>
      _ProtocolErrorBasicResultTag_map[_ordinal]!;

  Basic? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ProtocolErrorBasicResult _ctor(int ordinal, Object data) {
    return ProtocolErrorBasicResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ProtocolErrorBasicResult>
    kProtocol_ErrorBasic_Result_Type =
    $fidl.UnionType<ProtocolErrorBasicResult>(
  members: <int, $fidl.FidlType>{
    1: kBasic_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorBasicResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ProtocolErrorBasicResult>
    kProtocol_ErrorBasic_Result_OptType =
    $fidl.NullableUnionType<ProtocolErrorBasicResult>(
  members: <int, $fidl.FidlType>{
    1: kBasic_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorBasicResult._ctor,
  flexible: false,
  resource: false,
);

enum ProtocolErrorCompoundResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, ProtocolErrorCompoundResultTag>
    _ProtocolErrorCompoundResultTag_map = {
  1: ProtocolErrorCompoundResultTag.response,
  2: ProtocolErrorCompoundResultTag.err,
};

class ProtocolErrorCompoundResult extends $fidl.Union {
  const ProtocolErrorCompoundResult.withResponse(Compound value)
      : _ordinal = 1,
        _data = value;

  const ProtocolErrorCompoundResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  ProtocolErrorCompoundResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ProtocolErrorCompoundResultTag get $tag =>
      _ProtocolErrorCompoundResultTag_map[_ordinal]!;

  Compound? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ProtocolErrorCompoundResult _ctor(int ordinal, Object data) {
    return ProtocolErrorCompoundResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ProtocolErrorCompoundResult>
    kProtocol_ErrorCompound_Result_Type =
    $fidl.UnionType<ProtocolErrorCompoundResult>(
  members: <int, $fidl.FidlType>{
    1: kCompound_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorCompoundResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ProtocolErrorCompoundResult>
    kProtocol_ErrorCompound_Result_OptType =
    $fidl.NullableUnionType<ProtocolErrorCompoundResult>(
  members: <int, $fidl.FidlType>{
    1: kCompound_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorCompoundResult._ctor,
  flexible: false,
  resource: false,
);

enum ProtocolErrorResourceResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, ProtocolErrorResourceResultTag>
    _ProtocolErrorResourceResultTag_map = {
  1: ProtocolErrorResourceResultTag.response,
  2: ProtocolErrorResourceResultTag.err,
};

class ProtocolErrorResourceResult extends $fidl.Union {
  const ProtocolErrorResourceResult.withResponse(Resource value)
      : _ordinal = 1,
        _data = value;

  const ProtocolErrorResourceResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  ProtocolErrorResourceResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ProtocolErrorResourceResultTag get $tag =>
      _ProtocolErrorResourceResultTag_map[_ordinal]!;

  Resource? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ProtocolErrorResourceResult _ctor(int ordinal, Object data) {
    return ProtocolErrorResourceResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ProtocolErrorResourceResult>
    kProtocol_ErrorResource_Result_Type =
    $fidl.UnionType<ProtocolErrorResourceResult>(
  members: <int, $fidl.FidlType>{
    1: kResource_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorResourceResult._ctor,
  flexible: false,
  resource: true,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ProtocolErrorResourceResult>
    kProtocol_ErrorResource_Result_OptType =
    $fidl.NullableUnionType<ProtocolErrorResourceResult>(
  members: <int, $fidl.FidlType>{
    1: kResource_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorResourceResult._ctor,
  flexible: false,
  resource: true,
);

enum ProtocolErrorVectorBasicResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, ProtocolErrorVectorBasicResultTag>
    _ProtocolErrorVectorBasicResultTag_map = {
  1: ProtocolErrorVectorBasicResultTag.response,
  2: ProtocolErrorVectorBasicResultTag.err,
};

class ProtocolErrorVectorBasicResult extends $fidl.Union {
  const ProtocolErrorVectorBasicResult.withResponse(VectorBasic value)
      : _ordinal = 1,
        _data = value;

  const ProtocolErrorVectorBasicResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  ProtocolErrorVectorBasicResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ProtocolErrorVectorBasicResultTag get $tag =>
      _ProtocolErrorVectorBasicResultTag_map[_ordinal]!;

  VectorBasic? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ProtocolErrorVectorBasicResult _ctor(int ordinal, Object data) {
    return ProtocolErrorVectorBasicResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ProtocolErrorVectorBasicResult>
    kProtocol_ErrorVectorBasic_Result_Type =
    $fidl.UnionType<ProtocolErrorVectorBasicResult>(
  members: <int, $fidl.FidlType>{
    1: kVectorBasic_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorVectorBasicResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ProtocolErrorVectorBasicResult>
    kProtocol_ErrorVectorBasic_Result_OptType =
    $fidl.NullableUnionType<ProtocolErrorVectorBasicResult>(
  members: <int, $fidl.FidlType>{
    1: kVectorBasic_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorVectorBasicResult._ctor,
  flexible: false,
  resource: false,
);

enum ProtocolErrorVectorCompoundResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, ProtocolErrorVectorCompoundResultTag>
    _ProtocolErrorVectorCompoundResultTag_map = {
  1: ProtocolErrorVectorCompoundResultTag.response,
  2: ProtocolErrorVectorCompoundResultTag.err,
};

class ProtocolErrorVectorCompoundResult extends $fidl.Union {
  const ProtocolErrorVectorCompoundResult.withResponse(VectorCompound value)
      : _ordinal = 1,
        _data = value;

  const ProtocolErrorVectorCompoundResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  ProtocolErrorVectorCompoundResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ProtocolErrorVectorCompoundResultTag get $tag =>
      _ProtocolErrorVectorCompoundResultTag_map[_ordinal]!;

  VectorCompound? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ProtocolErrorVectorCompoundResult _ctor(int ordinal, Object data) {
    return ProtocolErrorVectorCompoundResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ProtocolErrorVectorCompoundResult>
    kProtocol_ErrorVectorCompound_Result_Type =
    $fidl.UnionType<ProtocolErrorVectorCompoundResult>(
  members: <int, $fidl.FidlType>{
    1: kVectorCompound_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorVectorCompoundResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ProtocolErrorVectorCompoundResult>
    kProtocol_ErrorVectorCompound_Result_OptType =
    $fidl.NullableUnionType<ProtocolErrorVectorCompoundResult>(
  members: <int, $fidl.FidlType>{
    1: kVectorCompound_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorVectorCompoundResult._ctor,
  flexible: false,
  resource: false,
);

enum ProtocolErrorVectorOptionalResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, ProtocolErrorVectorOptionalResultTag>
    _ProtocolErrorVectorOptionalResultTag_map = {
  1: ProtocolErrorVectorOptionalResultTag.response,
  2: ProtocolErrorVectorOptionalResultTag.err,
};

class ProtocolErrorVectorOptionalResult extends $fidl.Union {
  const ProtocolErrorVectorOptionalResult.withResponse(VectorOptional value)
      : _ordinal = 1,
        _data = value;

  const ProtocolErrorVectorOptionalResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  ProtocolErrorVectorOptionalResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ProtocolErrorVectorOptionalResultTag get $tag =>
      _ProtocolErrorVectorOptionalResultTag_map[_ordinal]!;

  VectorOptional? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ProtocolErrorVectorOptionalResult _ctor(int ordinal, Object data) {
    return ProtocolErrorVectorOptionalResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ProtocolErrorVectorOptionalResult>
    kProtocol_ErrorVectorOptional_Result_Type =
    $fidl.UnionType<ProtocolErrorVectorOptionalResult>(
  members: <int, $fidl.FidlType>{
    1: kVectorOptional_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorVectorOptionalResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ProtocolErrorVectorOptionalResult>
    kProtocol_ErrorVectorOptional_Result_OptType =
    $fidl.NullableUnionType<ProtocolErrorVectorOptionalResult>(
  members: <int, $fidl.FidlType>{
    1: kVectorOptional_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ProtocolErrorVectorOptionalResult._ctor,
  flexible: false,
  resource: false,
);

enum ResourceUnionTag {
  $unknown,
  b, // 0x1
}

const Map<int, ResourceUnionTag> _ResourceUnionTag_map = {
  1: ResourceUnionTag.b,
};

class ResourceUnion extends $fidl.Union {
  const ResourceUnion.withB(bool value)
      : _ordinal = 1,
        _data = value;
  const ResourceUnion.with$UnknownData(this._ordinal, $fidl.UnknownRawData data)
      : _data = data;

  ResourceUnion._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ResourceUnionTag get $tag =>
      _ResourceUnionTag_map[_ordinal] ?? ResourceUnionTag.$unknown;

  bool? get b {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ResourceUnion _ctor(int ordinal, Object data) {
    return ResourceUnion._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ResourceUnion> kResourceUnion_Type =
    $fidl.UnionType<ResourceUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: ResourceUnion._ctor,
  flexible: true,
  resource: true,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ResourceUnion> kResourceUnion_OptType =
    $fidl.NullableUnionType<ResourceUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: ResourceUnion._ctor,
  flexible: true,
  resource: true,
);

enum UnionTag {
  $unknown,
  b, // 0x1
}

const Map<int, UnionTag> _UnionTag_map = {
  1: UnionTag.b,
};

class Union extends $fidl.Union {
  const Union.withB(bool value)
      : _ordinal = 1,
        _data = value;
  const Union.with$UnknownData(this._ordinal, $fidl.UnknownRawData data)
      : _data = data;

  Union._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  UnionTag get $tag => _UnionTag_map[_ordinal] ?? UnionTag.$unknown;

  bool? get b {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static Union _ctor(int ordinal, Object data) {
    return Union._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<Union> kUnion_Type = $fidl.UnionType<Union>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: Union._ctor,
  flexible: true,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<Union> kUnion_OptType =
    $fidl.NullableUnionType<Union>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: Union._ctor,
  flexible: true,
  resource: false,
);

class ArrayBasic extends $fidl.Struct {
  const ArrayBasic({
    required this.arrayUint8,
    required this.arrayUint16,
    required this.arrayUint32,
    required this.arrayUint64,
    required this.arrayInt8,
    required this.arrayInt16,
    required this.arrayInt32,
    required this.arrayInt64,
    required this.arrayFloat32,
    required this.arrayFloat64,
    required this.arrayString,
    required this.arrayOptString,
  });
  ArrayBasic.clone(
    ArrayBasic $orig, {
    Uint8List? arrayUint8,
    Uint16List? arrayUint16,
    Uint32List? arrayUint32,
    Uint64List? arrayUint64,
    Int8List? arrayInt8,
    Int16List? arrayInt16,
    Int32List? arrayInt32,
    Int64List? arrayInt64,
    Float32List? arrayFloat32,
    Float64List? arrayFloat64,
    List<String>? arrayString,
    List<String?>? arrayOptString,
  }) : this(
          arrayUint8: arrayUint8 ?? $orig.arrayUint8,
          arrayUint16: arrayUint16 ?? $orig.arrayUint16,
          arrayUint32: arrayUint32 ?? $orig.arrayUint32,
          arrayUint64: arrayUint64 ?? $orig.arrayUint64,
          arrayInt8: arrayInt8 ?? $orig.arrayInt8,
          arrayInt16: arrayInt16 ?? $orig.arrayInt16,
          arrayInt32: arrayInt32 ?? $orig.arrayInt32,
          arrayInt64: arrayInt64 ?? $orig.arrayInt64,
          arrayFloat32: arrayFloat32 ?? $orig.arrayFloat32,
          arrayFloat64: arrayFloat64 ?? $orig.arrayFloat64,
          arrayString: arrayString ?? $orig.arrayString,
          arrayOptString: arrayOptString ?? $orig.arrayOptString,
        );

  ArrayBasic $cloneWith({
    Uint8List? arrayUint8,
    Uint16List? arrayUint16,
    Uint32List? arrayUint32,
    Uint64List? arrayUint64,
    Int8List? arrayInt8,
    Int16List? arrayInt16,
    Int32List? arrayInt32,
    Int64List? arrayInt64,
    Float32List? arrayFloat32,
    Float64List? arrayFloat64,
    List<String>? arrayString,
    List<String?>? arrayOptString,
  }) {
    return ArrayBasic(
      arrayUint8: arrayUint8 ?? this.arrayUint8,
      arrayUint16: arrayUint16 ?? this.arrayUint16,
      arrayUint32: arrayUint32 ?? this.arrayUint32,
      arrayUint64: arrayUint64 ?? this.arrayUint64,
      arrayInt8: arrayInt8 ?? this.arrayInt8,
      arrayInt16: arrayInt16 ?? this.arrayInt16,
      arrayInt32: arrayInt32 ?? this.arrayInt32,
      arrayInt64: arrayInt64 ?? this.arrayInt64,
      arrayFloat32: arrayFloat32 ?? this.arrayFloat32,
      arrayFloat64: arrayFloat64 ?? this.arrayFloat64,
      arrayString: arrayString ?? this.arrayString,
      arrayOptString: arrayOptString ?? this.arrayOptString,
    );
  }

  final Uint8List arrayUint8;
  final Uint16List arrayUint16;
  final Uint32List arrayUint32;
  final Uint64List arrayUint64;
  final Int8List arrayInt8;
  final Int16List arrayInt16;
  final Int32List arrayInt32;
  final Int64List arrayInt64;
  final Float32List arrayFloat32;
  final Float64List arrayFloat64;
  final List<String> arrayString;
  final List<String?> arrayOptString;

  @override
  List<Object?> get $fields {
    return <Object?>[
      arrayUint8,
      arrayUint16,
      arrayUint32,
      arrayUint64,
      arrayInt8,
      arrayInt16,
      arrayInt32,
      arrayInt64,
      arrayFloat32,
      arrayFloat64,
      arrayString,
      arrayOptString,
    ];
  }

  static const $fieldType0 = $fidl.ArrayType<int, Uint8List>(
      element: $fidl.Uint8Type(), elementCount: 5);
  static const $fieldType1 = $fidl.ArrayType<int, Uint16List>(
      element: $fidl.Uint16Type(), elementCount: 5);
  static const $fieldType2 = $fidl.ArrayType<int, Uint32List>(
      element: $fidl.Uint32Type(), elementCount: 5);
  static const $fieldType3 = $fidl.ArrayType<int, Uint64List>(
      element: $fidl.Uint64Type(), elementCount: 5);
  static const $fieldType4 = $fidl.ArrayType<int, Int8List>(
      element: $fidl.Int8Type(), elementCount: 5);
  static const $fieldType5 = $fidl.ArrayType<int, Int16List>(
      element: $fidl.Int16Type(), elementCount: 5);
  static const $fieldType6 = $fidl.ArrayType<int, Int32List>(
      element: $fidl.Int32Type(), elementCount: 5);
  static const $fieldType7 = $fidl.ArrayType<int, Int64List>(
      element: $fidl.Int64Type(), elementCount: 5);
  static const $fieldType8 = $fidl.ArrayType<double, Float32List>(
      element: $fidl.Float32Type(), elementCount: 5);
  static const $fieldType9 = $fidl.ArrayType<double, Float64List>(
      element: $fidl.Float64Type(), elementCount: 5);
  static const $fieldType10 = $fidl.ArrayType<String, List<String>>(
      element: $fidl.StringType(maybeElementCount: null), elementCount: 5);
  static const $fieldType11 = $fidl.ArrayType<String?, List<String?>>(
      element: $fidl.NullableStringType(maybeElementCount: null),
      elementCount: 5);

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, arrayUint8, $offset + 0, $depth);
    $fieldType1.encode($encoder, arrayUint16, $offset + 6, $depth);
    $fieldType2.encode($encoder, arrayUint32, $offset + 16, $depth);
    $fieldType3.encode($encoder, arrayUint64, $offset + 40, $depth);
    $fieldType4.encode($encoder, arrayInt8, $offset + 80, $depth);
    $fieldType5.encode($encoder, arrayInt16, $offset + 86, $depth);
    $fieldType6.encode($encoder, arrayInt32, $offset + 96, $depth);
    $fieldType7.encode($encoder, arrayInt64, $offset + 120, $depth);
    $fieldType8.encode($encoder, arrayFloat32, $offset + 160, $depth);
    $fieldType9.encode($encoder, arrayFloat64, $offset + 184, $depth);
    $fieldType10.encode($encoder, arrayString, $offset + 224, $depth);
    $fieldType11.encode($encoder, arrayOptString, $offset + 304, $depth);
  }

  static ArrayBasic _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 5, 1);

        $decoder.checkPadding($offset + 36, 4);

        $decoder.checkPadding($offset + 85, 1);

        $decoder.checkPadding($offset + 116, 4);

        $decoder.checkPadding($offset + 180, 4);
        return ArrayBasic(
            arrayUint8: $fieldType0.decode($decoder, $offset + 0, $depth),
            arrayUint16: $fieldType1.decode($decoder, $offset + 6, $depth),
            arrayUint32: $fieldType2.decode($decoder, $offset + 16, $depth),
            arrayUint64: $fieldType3.decode($decoder, $offset + 40, $depth),
            arrayInt8: $fieldType4.decode($decoder, $offset + 80, $depth),
            arrayInt16: $fieldType5.decode($decoder, $offset + 86, $depth),
            arrayInt32: $fieldType6.decode($decoder, $offset + 96, $depth),
            arrayInt64: $fieldType7.decode($decoder, $offset + 120, $depth),
            arrayFloat32: $fieldType8.decode($decoder, $offset + 160, $depth),
            arrayFloat64: $fieldType9.decode($decoder, $offset + 184, $depth),
            arrayString: $fieldType10.decode($decoder, $offset + 224, $depth),
            arrayOptString:
                $fieldType11.decode($decoder, $offset + 304, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<ArrayBasic> kArrayBasic_Type =
    $fidl.StructType<ArrayBasic>(
        inlineSize: 384, structDecode: ArrayBasic._structDecode);

class ArrayCompound extends $fidl.Struct {
  const ArrayCompound({
    required this.arrayBits,
    required this.arrayEnum,
    required this.arrayStruct,
    required this.arrayTable,
    required this.arrayUnion,
    required this.arrayOptStruct,
    required this.arrayOptUnion,
  });
  ArrayCompound.clone(
    ArrayCompound $orig, {
    List<Bits>? arrayBits,
    List<Enum>? arrayEnum,
    List<Struct>? arrayStruct,
    List<Table>? arrayTable,
    List<Union>? arrayUnion,
    List<Struct?>? arrayOptStruct,
    List<Union?>? arrayOptUnion,
  }) : this(
          arrayBits: arrayBits ?? $orig.arrayBits,
          arrayEnum: arrayEnum ?? $orig.arrayEnum,
          arrayStruct: arrayStruct ?? $orig.arrayStruct,
          arrayTable: arrayTable ?? $orig.arrayTable,
          arrayUnion: arrayUnion ?? $orig.arrayUnion,
          arrayOptStruct: arrayOptStruct ?? $orig.arrayOptStruct,
          arrayOptUnion: arrayOptUnion ?? $orig.arrayOptUnion,
        );

  ArrayCompound $cloneWith({
    List<Bits>? arrayBits,
    List<Enum>? arrayEnum,
    List<Struct>? arrayStruct,
    List<Table>? arrayTable,
    List<Union>? arrayUnion,
    List<Struct?>? arrayOptStruct,
    List<Union?>? arrayOptUnion,
  }) {
    return ArrayCompound(
      arrayBits: arrayBits ?? this.arrayBits,
      arrayEnum: arrayEnum ?? this.arrayEnum,
      arrayStruct: arrayStruct ?? this.arrayStruct,
      arrayTable: arrayTable ?? this.arrayTable,
      arrayUnion: arrayUnion ?? this.arrayUnion,
      arrayOptStruct: arrayOptStruct ?? this.arrayOptStruct,
      arrayOptUnion: arrayOptUnion ?? this.arrayOptUnion,
    );
  }

  final List<Bits> arrayBits;
  final List<Enum> arrayEnum;
  final List<Struct> arrayStruct;
  final List<Table> arrayTable;
  final List<Union> arrayUnion;
  final List<Struct?> arrayOptStruct;
  final List<Union?> arrayOptUnion;

  @override
  List<Object?> get $fields {
    return <Object?>[
      arrayBits,
      arrayEnum,
      arrayStruct,
      arrayTable,
      arrayUnion,
      arrayOptStruct,
      arrayOptUnion,
    ];
  }

  static const $fieldType0 =
      $fidl.ArrayType<Bits, List<Bits>>(element: kBits_Type, elementCount: 5);
  static const $fieldType1 =
      $fidl.ArrayType<Enum, List<Enum>>(element: kEnum_Type, elementCount: 5);
  static const $fieldType2 = $fidl.ArrayType<Struct, List<Struct>>(
      element: kStruct_Type, elementCount: 5);
  static const $fieldType3 = $fidl.ArrayType<Table, List<Table>>(
      element: kTable_Type, elementCount: 5);
  static const $fieldType4 = $fidl.ArrayType<Union, List<Union>>(
      element: kUnion_Type, elementCount: 5);
  static const $fieldType5 = $fidl.ArrayType<Struct?, List<Struct?>>(
      element: $fidl.PointerType<Struct>(element: kStruct_Type),
      elementCount: 5);
  static const $fieldType6 = $fidl.ArrayType<Union?, List<Union?>>(
      element: kUnion_OptType, elementCount: 5);

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, arrayBits, $offset + 0, $depth);
    $fieldType1.encode($encoder, arrayEnum, $offset + 20, $depth);
    $fieldType2.encode($encoder, arrayStruct, $offset + 40, $depth);
    $fieldType3.encode($encoder, arrayTable, $offset + 48, $depth);
    $fieldType4.encode($encoder, arrayUnion, $offset + 128, $depth);
    $fieldType5.encode($encoder, arrayOptStruct, $offset + 208, $depth);
    $fieldType6.encode($encoder, arrayOptUnion, $offset + 248, $depth);
  }

  static ArrayCompound _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 45, 3);
        return ArrayCompound(
            arrayBits: $fieldType0.decode($decoder, $offset + 0, $depth),
            arrayEnum: $fieldType1.decode($decoder, $offset + 20, $depth),
            arrayStruct: $fieldType2.decode($decoder, $offset + 40, $depth),
            arrayTable: $fieldType3.decode($decoder, $offset + 48, $depth),
            arrayUnion: $fieldType4.decode($decoder, $offset + 128, $depth),
            arrayOptStruct: $fieldType5.decode($decoder, $offset + 208, $depth),
            arrayOptUnion: $fieldType6.decode($decoder, $offset + 248, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<ArrayCompound> kArrayCompound_Type =
    $fidl.StructType<ArrayCompound>(
        inlineSize: 328, structDecode: ArrayCompound._structDecode);

class ArrayVectorNested extends $fidl.Struct {
  const ArrayVectorNested({
    required this.arrayArrayUint8,
    required this.arrayVectorUint8,
    required this.vectorArrayUint8,
    required this.vectorVectorUint8,
  });
  ArrayVectorNested.clone(
    ArrayVectorNested $orig, {
    List<Uint8List>? arrayArrayUint8,
    List<Uint8List>? arrayVectorUint8,
    List<Uint8List>? vectorArrayUint8,
    List<Uint8List>? vectorVectorUint8,
  }) : this(
          arrayArrayUint8: arrayArrayUint8 ?? $orig.arrayArrayUint8,
          arrayVectorUint8: arrayVectorUint8 ?? $orig.arrayVectorUint8,
          vectorArrayUint8: vectorArrayUint8 ?? $orig.vectorArrayUint8,
          vectorVectorUint8: vectorVectorUint8 ?? $orig.vectorVectorUint8,
        );

  ArrayVectorNested $cloneWith({
    List<Uint8List>? arrayArrayUint8,
    List<Uint8List>? arrayVectorUint8,
    List<Uint8List>? vectorArrayUint8,
    List<Uint8List>? vectorVectorUint8,
  }) {
    return ArrayVectorNested(
      arrayArrayUint8: arrayArrayUint8 ?? this.arrayArrayUint8,
      arrayVectorUint8: arrayVectorUint8 ?? this.arrayVectorUint8,
      vectorArrayUint8: vectorArrayUint8 ?? this.vectorArrayUint8,
      vectorVectorUint8: vectorVectorUint8 ?? this.vectorVectorUint8,
    );
  }

  final List<Uint8List> arrayArrayUint8;
  final List<Uint8List> arrayVectorUint8;
  final List<Uint8List> vectorArrayUint8;
  final List<Uint8List> vectorVectorUint8;

  @override
  List<Object?> get $fields {
    return <Object?>[
      arrayArrayUint8,
      arrayVectorUint8,
      vectorArrayUint8,
      vectorVectorUint8,
    ];
  }

  static const $fieldType0 = $fidl.ArrayType<Uint8List, List<Uint8List>>(
      element: $fidl.ArrayType<int, Uint8List>(
          element: $fidl.Uint8Type(), elementCount: 5),
      elementCount: 5);
  static const $fieldType1 = $fidl.ArrayType<Uint8List, List<Uint8List>>(
      element: $fidl.VectorType<int, Uint8List>(
          element: $fidl.Uint8Type(), maybeElementCount: null),
      elementCount: 5);
  static const $fieldType2 = $fidl.VectorType<Uint8List, List<Uint8List>>(
      element: $fidl.ArrayType<int, Uint8List>(
          element: $fidl.Uint8Type(), elementCount: 5),
      maybeElementCount: null);
  static const $fieldType3 = $fidl.VectorType<Uint8List, List<Uint8List>>(
      element: $fidl.VectorType<int, Uint8List>(
          element: $fidl.Uint8Type(), maybeElementCount: null),
      maybeElementCount: null);

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, arrayArrayUint8, $offset + 0, $depth);
    $fieldType1.encode($encoder, arrayVectorUint8, $offset + 32, $depth);
    $fieldType2.encode($encoder, vectorArrayUint8, $offset + 112, $depth);
    $fieldType3.encode($encoder, vectorVectorUint8, $offset + 128, $depth);
  }

  static ArrayVectorNested _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 25, 7);
        return ArrayVectorNested(
            arrayArrayUint8: $fieldType0.decode($decoder, $offset + 0, $depth),
            arrayVectorUint8:
                $fieldType1.decode($decoder, $offset + 32, $depth),
            vectorArrayUint8:
                $fieldType2.decode($decoder, $offset + 112, $depth),
            vectorVectorUint8:
                $fieldType3.decode($decoder, $offset + 128, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<ArrayVectorNested> kArrayVectorNested_Type =
    $fidl.StructType<ArrayVectorNested>(
        inlineSize: 144, structDecode: ArrayVectorNested._structDecode);

class Basic extends $fidl.Struct {
  const Basic({
    required this.uint8,
    required this.uint16,
    required this.uint32,
    required this.uint64,
    required this.int8,
    required this.int16,
    required this.int32,
    required this.int64,
    required this.float32,
    required this.float64,
    required this.string,
    this.optString,
  });
  Basic.clone(
    Basic $orig, {
    int? uint8,
    int? uint16,
    int? uint32,
    int? uint64,
    int? int8,
    int? int16,
    int? int32,
    int? int64,
    double? float32,
    double? float64,
    String? string,
    String? optString,
  }) : this(
          uint8: uint8 ?? $orig.uint8,
          uint16: uint16 ?? $orig.uint16,
          uint32: uint32 ?? $orig.uint32,
          uint64: uint64 ?? $orig.uint64,
          int8: int8 ?? $orig.int8,
          int16: int16 ?? $orig.int16,
          int32: int32 ?? $orig.int32,
          int64: int64 ?? $orig.int64,
          float32: float32 ?? $orig.float32,
          float64: float64 ?? $orig.float64,
          string: string ?? $orig.string,
          optString: optString ?? $orig.optString,
        );

  Basic.cloneWithout(
    Basic $orig, {
    bool optString = false,
  }) : this(
          uint8: $orig.uint8,
          uint16: $orig.uint16,
          uint32: $orig.uint32,
          uint64: $orig.uint64,
          int8: $orig.int8,
          int16: $orig.int16,
          int32: $orig.int32,
          int64: $orig.int64,
          float32: $orig.float32,
          float64: $orig.float64,
          string: $orig.string,
          optString: optString ? null : $orig.optString,
        );

  Basic $cloneWith({
    int? uint8,
    int? uint16,
    int? uint32,
    int? uint64,
    int? int8,
    int? int16,
    int? int32,
    int? int64,
    double? float32,
    double? float64,
    String? string,
    $fidl.OptionalNullable<String?> optString =
        const $fidl.OptionalNullable.undefined(),
  }) {
    return Basic(
      uint8: uint8 ?? this.uint8,
      uint16: uint16 ?? this.uint16,
      uint32: uint32 ?? this.uint32,
      uint64: uint64 ?? this.uint64,
      int8: int8 ?? this.int8,
      int16: int16 ?? this.int16,
      int32: int32 ?? this.int32,
      int64: int64 ?? this.int64,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      string: string ?? this.string,
      optString: optString.or(this.optString),
    );
  }

  final int uint8;
  final int uint16;
  final int uint32;
  final int uint64;
  final int int8;
  final int int16;
  final int int32;
  final int int64;
  final double float32;
  final double float64;
  final String string;
  final String? optString;

  @override
  List<Object?> get $fields {
    return <Object?>[
      uint8,
      uint16,
      uint32,
      uint64,
      int8,
      int16,
      int32,
      int64,
      float32,
      float64,
      string,
      optString,
    ];
  }

  static const $fieldType0 = $fidl.Uint8Type();
  static const $fieldType1 = $fidl.Uint16Type();
  static const $fieldType2 = $fidl.Uint32Type();
  static const $fieldType3 = $fidl.Uint64Type();
  static const $fieldType4 = $fidl.Int8Type();
  static const $fieldType5 = $fidl.Int16Type();
  static const $fieldType6 = $fidl.Int32Type();
  static const $fieldType7 = $fidl.Int64Type();
  static const $fieldType8 = $fidl.Float32Type();
  static const $fieldType9 = $fidl.Float64Type();
  static const $fieldType10 = $fidl.StringType(maybeElementCount: null);
  static const $fieldType11 = $fidl.NullableStringType(maybeElementCount: null);

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, uint8, $offset + 0, $depth);
    $fieldType1.encode($encoder, uint16, $offset + 2, $depth);
    $fieldType2.encode($encoder, uint32, $offset + 4, $depth);
    $fieldType3.encode($encoder, uint64, $offset + 8, $depth);
    $fieldType4.encode($encoder, int8, $offset + 16, $depth);
    $fieldType5.encode($encoder, int16, $offset + 18, $depth);
    $fieldType6.encode($encoder, int32, $offset + 20, $depth);
    $fieldType7.encode($encoder, int64, $offset + 24, $depth);
    $fieldType8.encode($encoder, float32, $offset + 32, $depth);
    $fieldType9.encode($encoder, float64, $offset + 40, $depth);
    $fieldType10.encode($encoder, string, $offset + 48, $depth);
    $fieldType11.encode($encoder, optString, $offset + 64, $depth);
  }

  static Basic _structDecode($fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 1, 1);

        $decoder.checkPadding($offset + 17, 1);

        $decoder.checkPadding($offset + 36, 4);
        return Basic(
            uint8: $fieldType0.decode($decoder, $offset + 0, $depth),
            uint16: $fieldType1.decode($decoder, $offset + 2, $depth),
            uint32: $fieldType2.decode($decoder, $offset + 4, $depth),
            uint64: $fieldType3.decode($decoder, $offset + 8, $depth),
            int8: $fieldType4.decode($decoder, $offset + 16, $depth),
            int16: $fieldType5.decode($decoder, $offset + 18, $depth),
            int32: $fieldType6.decode($decoder, $offset + 20, $depth),
            int64: $fieldType7.decode($decoder, $offset + 24, $depth),
            float32: $fieldType8.decode($decoder, $offset + 32, $depth),
            float64: $fieldType9.decode($decoder, $offset + 40, $depth),
            string: $fieldType10.decode($decoder, $offset + 48, $depth),
            optString: $fieldType11.decode($decoder, $offset + 64, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Basic> kBasic_Type =
    $fidl.StructType<Basic>(inlineSize: 80, structDecode: Basic._structDecode);

class Compound extends $fidl.Struct {
  const Compound({
    required this.bits,
    required this.enum$,
    required this.struct,
    required this.table,
    required this.union,
    this.optStruct,
    this.optUnion,
  });
  Compound.clone(
    Compound $orig, {
    Bits? bits,
    Enum? enum$,
    Struct? struct,
    Table? table,
    Union? union,
    Struct? optStruct,
    Union? optUnion,
  }) : this(
          bits: bits ?? $orig.bits,
          enum$: enum$ ?? $orig.enum$,
          struct: struct ?? $orig.struct,
          table: table ?? $orig.table,
          union: union ?? $orig.union,
          optStruct: optStruct ?? $orig.optStruct,
          optUnion: optUnion ?? $orig.optUnion,
        );

  Compound.cloneWithout(
    Compound $orig, {
    bool optStruct = false,
    bool optUnion = false,
  }) : this(
          bits: $orig.bits,
          enum$: $orig.enum$,
          struct: $orig.struct,
          table: $orig.table,
          union: $orig.union,
          optStruct: optStruct ? null : $orig.optStruct,
          optUnion: optUnion ? null : $orig.optUnion,
        );

  Compound $cloneWith({
    Bits? bits,
    Enum? enum$,
    Struct? struct,
    Table? table,
    Union? union,
    $fidl.OptionalNullable<Struct?> optStruct =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<Union?> optUnion =
        const $fidl.OptionalNullable.undefined(),
  }) {
    return Compound(
      bits: bits ?? this.bits,
      enum$: enum$ ?? this.enum$,
      struct: struct ?? this.struct,
      table: table ?? this.table,
      union: union ?? this.union,
      optStruct: optStruct.or(this.optStruct),
      optUnion: optUnion.or(this.optUnion),
    );
  }

  final Bits bits;
  final Enum enum$;
  final Struct struct;
  final Table table;
  final Union union;
  final Struct? optStruct;
  final Union? optUnion;

  @override
  List<Object?> get $fields {
    return <Object?>[
      bits,
      enum$,
      struct,
      table,
      union,
      optStruct,
      optUnion,
    ];
  }

  static const $fieldType0 = kBits_Type;
  static const $fieldType1 = kEnum_Type;
  static const $fieldType2 = kStruct_Type;
  static const $fieldType3 = kTable_Type;
  static const $fieldType4 = kUnion_Type;
  static const $fieldType5 = $fidl.PointerType<Struct>(element: kStruct_Type);
  static const $fieldType6 = kUnion_OptType;

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, bits, $offset + 0, $depth);
    $fieldType1.encode($encoder, enum$, $offset + 4, $depth);
    $fieldType2.encode($encoder, struct, $offset + 8, $depth);
    $fieldType3.encode($encoder, table, $offset + 16, $depth);
    $fieldType4.encode($encoder, union, $offset + 32, $depth);
    $fieldType5.encode($encoder, optStruct, $offset + 48, $depth);
    $fieldType6.encode($encoder, optUnion, $offset + 56, $depth);
  }

  static Compound _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 9, 7);
        return Compound(
            bits: $fieldType0.decode($decoder, $offset + 0, $depth),
            enum$: $fieldType1.decode($decoder, $offset + 4, $depth),
            struct: $fieldType2.decode($decoder, $offset + 8, $depth),
            table: $fieldType3.decode($decoder, $offset + 16, $depth),
            union: $fieldType4.decode($decoder, $offset + 32, $depth),
            optStruct: $fieldType5.decode($decoder, $offset + 48, $depth),
            optUnion: $fieldType6.decode($decoder, $offset + 56, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Compound> kCompound_Type = $fidl.StructType<Compound>(
    inlineSize: 72, structDecode: Compound._structDecode);

class Resource extends $fidl.Struct {
  const Resource({
    required this.handle,
    required this.vmo,
    required this.clientEnd,
    required this.serverEnd,
    required this.struct,
    required this.table,
    required this.union,
    this.optHandle,
    this.optVmo,
    this.optClientEnd,
    this.optServerEnd,
    this.optStruct,
    this.optUnion,
    required this.arrayHandle,
    required this.arrayVmo,
    required this.arrayClientEnd,
    required this.arrayServerEnd,
    required this.arrayStruct,
    required this.arrayTable,
    required this.arrayUnion,
    required this.vectorHandle,
    required this.vectorVmo,
    required this.vectorClientEnd,
    required this.vectorServerEnd,
    required this.vectorStruct,
    required this.vectorTable,
    required this.vectorUnion,
  });
  Resource.clone(
    Resource $orig, {
    $zircon.Handle? handle,
    $zircon.Vmo? vmo,
    $fidl.InterfaceHandle<Protocol>? clientEnd,
    $fidl.InterfaceRequest<Protocol>? serverEnd,
    ResourceStruct? struct,
    ResourceTable? table,
    ResourceUnion? union,
    $zircon.Handle? optHandle,
    $zircon.Vmo? optVmo,
    $fidl.InterfaceHandle<Protocol>? optClientEnd,
    $fidl.InterfaceRequest<Protocol>? optServerEnd,
    ResourceStruct? optStruct,
    ResourceUnion? optUnion,
    List<$zircon.Handle>? arrayHandle,
    List<$zircon.Vmo>? arrayVmo,
    List<$fidl.InterfaceHandle<Protocol>>? arrayClientEnd,
    List<$fidl.InterfaceRequest<Protocol>>? arrayServerEnd,
    List<ResourceStruct>? arrayStruct,
    List<ResourceTable>? arrayTable,
    List<ResourceUnion>? arrayUnion,
    List<$zircon.Handle>? vectorHandle,
    List<$zircon.Vmo>? vectorVmo,
    List<$fidl.InterfaceHandle<Protocol>>? vectorClientEnd,
    List<$fidl.InterfaceRequest<Protocol>>? vectorServerEnd,
    List<ResourceStruct>? vectorStruct,
    List<ResourceTable>? vectorTable,
    List<ResourceUnion>? vectorUnion,
  }) : this(
          handle: handle ?? $orig.handle,
          vmo: vmo ?? $orig.vmo,
          clientEnd: clientEnd ?? $orig.clientEnd,
          serverEnd: serverEnd ?? $orig.serverEnd,
          struct: struct ?? $orig.struct,
          table: table ?? $orig.table,
          union: union ?? $orig.union,
          optHandle: optHandle ?? $orig.optHandle,
          optVmo: optVmo ?? $orig.optVmo,
          optClientEnd: optClientEnd ?? $orig.optClientEnd,
          optServerEnd: optServerEnd ?? $orig.optServerEnd,
          optStruct: optStruct ?? $orig.optStruct,
          optUnion: optUnion ?? $orig.optUnion,
          arrayHandle: arrayHandle ?? $orig.arrayHandle,
          arrayVmo: arrayVmo ?? $orig.arrayVmo,
          arrayClientEnd: arrayClientEnd ?? $orig.arrayClientEnd,
          arrayServerEnd: arrayServerEnd ?? $orig.arrayServerEnd,
          arrayStruct: arrayStruct ?? $orig.arrayStruct,
          arrayTable: arrayTable ?? $orig.arrayTable,
          arrayUnion: arrayUnion ?? $orig.arrayUnion,
          vectorHandle: vectorHandle ?? $orig.vectorHandle,
          vectorVmo: vectorVmo ?? $orig.vectorVmo,
          vectorClientEnd: vectorClientEnd ?? $orig.vectorClientEnd,
          vectorServerEnd: vectorServerEnd ?? $orig.vectorServerEnd,
          vectorStruct: vectorStruct ?? $orig.vectorStruct,
          vectorTable: vectorTable ?? $orig.vectorTable,
          vectorUnion: vectorUnion ?? $orig.vectorUnion,
        );

  Resource.cloneWithout(
    Resource $orig, {
    bool optHandle = false,
    bool optVmo = false,
    bool optClientEnd = false,
    bool optServerEnd = false,
    bool optStruct = false,
    bool optUnion = false,
  }) : this(
          handle: $orig.handle,
          vmo: $orig.vmo,
          clientEnd: $orig.clientEnd,
          serverEnd: $orig.serverEnd,
          struct: $orig.struct,
          table: $orig.table,
          union: $orig.union,
          optHandle: optHandle ? null : $orig.optHandle,
          optVmo: optVmo ? null : $orig.optVmo,
          optClientEnd: optClientEnd ? null : $orig.optClientEnd,
          optServerEnd: optServerEnd ? null : $orig.optServerEnd,
          optStruct: optStruct ? null : $orig.optStruct,
          optUnion: optUnion ? null : $orig.optUnion,
          arrayHandle: $orig.arrayHandle,
          arrayVmo: $orig.arrayVmo,
          arrayClientEnd: $orig.arrayClientEnd,
          arrayServerEnd: $orig.arrayServerEnd,
          arrayStruct: $orig.arrayStruct,
          arrayTable: $orig.arrayTable,
          arrayUnion: $orig.arrayUnion,
          vectorHandle: $orig.vectorHandle,
          vectorVmo: $orig.vectorVmo,
          vectorClientEnd: $orig.vectorClientEnd,
          vectorServerEnd: $orig.vectorServerEnd,
          vectorStruct: $orig.vectorStruct,
          vectorTable: $orig.vectorTable,
          vectorUnion: $orig.vectorUnion,
        );

  Resource $cloneWith({
    $zircon.Handle? handle,
    $zircon.Vmo? vmo,
    $fidl.InterfaceHandle<Protocol>? clientEnd,
    $fidl.InterfaceRequest<Protocol>? serverEnd,
    ResourceStruct? struct,
    ResourceTable? table,
    ResourceUnion? union,
    $fidl.OptionalNullable<$zircon.Handle?> optHandle =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<$zircon.Vmo?> optVmo =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<$fidl.InterfaceHandle<Protocol>?> optClientEnd =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<$fidl.InterfaceRequest<Protocol>?> optServerEnd =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<ResourceStruct?> optStruct =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<ResourceUnion?> optUnion =
        const $fidl.OptionalNullable.undefined(),
    List<$zircon.Handle>? arrayHandle,
    List<$zircon.Vmo>? arrayVmo,
    List<$fidl.InterfaceHandle<Protocol>>? arrayClientEnd,
    List<$fidl.InterfaceRequest<Protocol>>? arrayServerEnd,
    List<ResourceStruct>? arrayStruct,
    List<ResourceTable>? arrayTable,
    List<ResourceUnion>? arrayUnion,
    List<$zircon.Handle>? vectorHandle,
    List<$zircon.Vmo>? vectorVmo,
    List<$fidl.InterfaceHandle<Protocol>>? vectorClientEnd,
    List<$fidl.InterfaceRequest<Protocol>>? vectorServerEnd,
    List<ResourceStruct>? vectorStruct,
    List<ResourceTable>? vectorTable,
    List<ResourceUnion>? vectorUnion,
  }) {
    return Resource(
      handle: handle ?? this.handle,
      vmo: vmo ?? this.vmo,
      clientEnd: clientEnd ?? this.clientEnd,
      serverEnd: serverEnd ?? this.serverEnd,
      struct: struct ?? this.struct,
      table: table ?? this.table,
      union: union ?? this.union,
      optHandle: optHandle.or(this.optHandle),
      optVmo: optVmo.or(this.optVmo),
      optClientEnd: optClientEnd.or(this.optClientEnd),
      optServerEnd: optServerEnd.or(this.optServerEnd),
      optStruct: optStruct.or(this.optStruct),
      optUnion: optUnion.or(this.optUnion),
      arrayHandle: arrayHandle ?? this.arrayHandle,
      arrayVmo: arrayVmo ?? this.arrayVmo,
      arrayClientEnd: arrayClientEnd ?? this.arrayClientEnd,
      arrayServerEnd: arrayServerEnd ?? this.arrayServerEnd,
      arrayStruct: arrayStruct ?? this.arrayStruct,
      arrayTable: arrayTable ?? this.arrayTable,
      arrayUnion: arrayUnion ?? this.arrayUnion,
      vectorHandle: vectorHandle ?? this.vectorHandle,
      vectorVmo: vectorVmo ?? this.vectorVmo,
      vectorClientEnd: vectorClientEnd ?? this.vectorClientEnd,
      vectorServerEnd: vectorServerEnd ?? this.vectorServerEnd,
      vectorStruct: vectorStruct ?? this.vectorStruct,
      vectorTable: vectorTable ?? this.vectorTable,
      vectorUnion: vectorUnion ?? this.vectorUnion,
    );
  }

  final $zircon.Handle handle;
  final $zircon.Vmo vmo;
  final $fidl.InterfaceHandle<Protocol> clientEnd;
  final $fidl.InterfaceRequest<Protocol> serverEnd;
  final ResourceStruct struct;
  final ResourceTable table;
  final ResourceUnion union;
  final $zircon.Handle? optHandle;
  final $zircon.Vmo? optVmo;
  final $fidl.InterfaceHandle<Protocol>? optClientEnd;
  final $fidl.InterfaceRequest<Protocol>? optServerEnd;
  final ResourceStruct? optStruct;
  final ResourceUnion? optUnion;
  final List<$zircon.Handle> arrayHandle;
  final List<$zircon.Vmo> arrayVmo;
  final List<$fidl.InterfaceHandle<Protocol>> arrayClientEnd;
  final List<$fidl.InterfaceRequest<Protocol>> arrayServerEnd;
  final List<ResourceStruct> arrayStruct;
  final List<ResourceTable> arrayTable;
  final List<ResourceUnion> arrayUnion;
  final List<$zircon.Handle> vectorHandle;
  final List<$zircon.Vmo> vectorVmo;
  final List<$fidl.InterfaceHandle<Protocol>> vectorClientEnd;
  final List<$fidl.InterfaceRequest<Protocol>> vectorServerEnd;
  final List<ResourceStruct> vectorStruct;
  final List<ResourceTable> vectorTable;
  final List<ResourceUnion> vectorUnion;

  @override
  List<Object?> get $fields {
    return <Object?>[
      handle,
      vmo,
      clientEnd,
      serverEnd,
      struct,
      table,
      union,
      optHandle,
      optVmo,
      optClientEnd,
      optServerEnd,
      optStruct,
      optUnion,
      arrayHandle,
      arrayVmo,
      arrayClientEnd,
      arrayServerEnd,
      arrayStruct,
      arrayTable,
      arrayUnion,
      vectorHandle,
      vectorVmo,
      vectorClientEnd,
      vectorServerEnd,
      vectorStruct,
      vectorTable,
      vectorUnion,
    ];
  }

  static const $fieldType0 =
      $fidl.HandleType(objectType: 0, rights: 2147483648);
  static const $fieldType1 = $fidl.VmoType(objectType: 3, rights: 2147483648);
  static const $fieldType2 = $fidl.InterfaceHandleType<Protocol>();
  static const $fieldType3 = $fidl.InterfaceRequestType<Protocol>();
  static const $fieldType4 = kResourceStruct_Type;
  static const $fieldType5 = kResourceTable_Type;
  static const $fieldType6 = kResourceUnion_Type;
  static const $fieldType7 = $fidl.NullableHandleType(
      $fidl.HandleType(objectType: 0, rights: 2147483648));
  static const $fieldType8 = $fidl.NullableHandleType(
      $fidl.VmoType(objectType: 3, rights: 2147483648));
  static const $fieldType9 = $fidl.NullableInterfaceHandleType<Protocol>();
  static const $fieldType10 = $fidl.NullableInterfaceRequestType<Protocol>();
  static const $fieldType11 =
      $fidl.PointerType<ResourceStruct>(element: kResourceStruct_Type);
  static const $fieldType12 = kResourceUnion_OptType;
  static const $fieldType13 =
      $fidl.ArrayType<$zircon.Handle, List<$zircon.Handle>>(
          element: $fidl.HandleType(objectType: 0, rights: 2147483648),
          elementCount: 5);
  static const $fieldType14 = $fidl.ArrayType<$zircon.Vmo, List<$zircon.Vmo>>(
      element: $fidl.VmoType(objectType: 3, rights: 2147483648),
      elementCount: 5);
  static const $fieldType15 = $fidl.ArrayType<$fidl.InterfaceHandle<Protocol>,
          List<$fidl.InterfaceHandle<Protocol>>>(
      element: $fidl.InterfaceHandleType<Protocol>(), elementCount: 5);
  static const $fieldType16 = $fidl.ArrayType<$fidl.InterfaceRequest<Protocol>,
          List<$fidl.InterfaceRequest<Protocol>>>(
      element: $fidl.InterfaceRequestType<Protocol>(), elementCount: 5);
  static const $fieldType17 =
      $fidl.ArrayType<ResourceStruct, List<ResourceStruct>>(
          element: kResourceStruct_Type, elementCount: 5);
  static const $fieldType18 =
      $fidl.ArrayType<ResourceTable, List<ResourceTable>>(
          element: kResourceTable_Type, elementCount: 5);
  static const $fieldType19 =
      $fidl.ArrayType<ResourceUnion, List<ResourceUnion>>(
          element: kResourceUnion_Type, elementCount: 5);
  static const $fieldType20 =
      $fidl.VectorType<$zircon.Handle, List<$zircon.Handle>>(
          element: $fidl.HandleType(objectType: 0, rights: 2147483648),
          maybeElementCount: null);
  static const $fieldType21 = $fidl.VectorType<$zircon.Vmo, List<$zircon.Vmo>>(
      element: $fidl.VmoType(objectType: 3, rights: 2147483648),
      maybeElementCount: null);
  static const $fieldType22 = $fidl.VectorType<$fidl.InterfaceHandle<Protocol>,
          List<$fidl.InterfaceHandle<Protocol>>>(
      element: $fidl.InterfaceHandleType<Protocol>(), maybeElementCount: null);
  static const $fieldType23 = $fidl.VectorType<$fidl.InterfaceRequest<Protocol>,
          List<$fidl.InterfaceRequest<Protocol>>>(
      element: $fidl.InterfaceRequestType<Protocol>(), maybeElementCount: null);
  static const $fieldType24 =
      $fidl.VectorType<ResourceStruct, List<ResourceStruct>>(
          element: kResourceStruct_Type, maybeElementCount: null);
  static const $fieldType25 =
      $fidl.VectorType<ResourceTable, List<ResourceTable>>(
          element: kResourceTable_Type, maybeElementCount: null);
  static const $fieldType26 =
      $fidl.VectorType<ResourceUnion, List<ResourceUnion>>(
          element: kResourceUnion_Type, maybeElementCount: null);

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, handle, $offset + 0, $depth);
    $fieldType1.encode($encoder, vmo, $offset + 4, $depth);
    $fieldType2.encode($encoder, clientEnd, $offset + 8, $depth);
    $fieldType3.encode($encoder, serverEnd, $offset + 12, $depth);
    $fieldType4.encode($encoder, struct, $offset + 16, $depth);
    $fieldType5.encode($encoder, table, $offset + 24, $depth);
    $fieldType6.encode($encoder, union, $offset + 40, $depth);
    $fieldType7.encode($encoder, optHandle, $offset + 56, $depth);
    $fieldType8.encode($encoder, optVmo, $offset + 60, $depth);
    $fieldType9.encode($encoder, optClientEnd, $offset + 64, $depth);
    $fieldType10.encode($encoder, optServerEnd, $offset + 68, $depth);
    $fieldType11.encode($encoder, optStruct, $offset + 72, $depth);
    $fieldType12.encode($encoder, optUnion, $offset + 80, $depth);
    $fieldType13.encode($encoder, arrayHandle, $offset + 96, $depth);
    $fieldType14.encode($encoder, arrayVmo, $offset + 116, $depth);
    $fieldType15.encode($encoder, arrayClientEnd, $offset + 136, $depth);
    $fieldType16.encode($encoder, arrayServerEnd, $offset + 156, $depth);
    $fieldType17.encode($encoder, arrayStruct, $offset + 176, $depth);
    $fieldType18.encode($encoder, arrayTable, $offset + 184, $depth);
    $fieldType19.encode($encoder, arrayUnion, $offset + 264, $depth);
    $fieldType20.encode($encoder, vectorHandle, $offset + 344, $depth);
    $fieldType21.encode($encoder, vectorVmo, $offset + 360, $depth);
    $fieldType22.encode($encoder, vectorClientEnd, $offset + 376, $depth);
    $fieldType23.encode($encoder, vectorServerEnd, $offset + 392, $depth);
    $fieldType24.encode($encoder, vectorStruct, $offset + 408, $depth);
    $fieldType25.encode($encoder, vectorTable, $offset + 424, $depth);
    $fieldType26.encode($encoder, vectorUnion, $offset + 440, $depth);
  }

  static Resource _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 17, 7);

        $decoder.checkPadding($offset + 181, 3);
        return Resource(
            handle: $fieldType0.decode($decoder, $offset + 0, $depth),
            vmo: $fieldType1.decode($decoder, $offset + 4, $depth),
            clientEnd: $fieldType2.decode($decoder, $offset + 8, $depth),
            serverEnd: $fieldType3.decode($decoder, $offset + 12, $depth),
            struct: $fieldType4.decode($decoder, $offset + 16, $depth),
            table: $fieldType5.decode($decoder, $offset + 24, $depth),
            union: $fieldType6.decode($decoder, $offset + 40, $depth),
            optHandle: $fieldType7.decode($decoder, $offset + 56, $depth),
            optVmo: $fieldType8.decode($decoder, $offset + 60, $depth),
            optClientEnd: $fieldType9.decode($decoder, $offset + 64, $depth),
            optServerEnd: $fieldType10.decode($decoder, $offset + 68, $depth),
            optStruct: $fieldType11.decode($decoder, $offset + 72, $depth),
            optUnion: $fieldType12.decode($decoder, $offset + 80, $depth),
            arrayHandle: $fieldType13.decode($decoder, $offset + 96, $depth),
            arrayVmo: $fieldType14.decode($decoder, $offset + 116, $depth),
            arrayClientEnd:
                $fieldType15.decode($decoder, $offset + 136, $depth),
            arrayServerEnd:
                $fieldType16.decode($decoder, $offset + 156, $depth),
            arrayStruct: $fieldType17.decode($decoder, $offset + 176, $depth),
            arrayTable: $fieldType18.decode($decoder, $offset + 184, $depth),
            arrayUnion: $fieldType19.decode($decoder, $offset + 264, $depth),
            vectorHandle: $fieldType20.decode($decoder, $offset + 344, $depth),
            vectorVmo: $fieldType21.decode($decoder, $offset + 360, $depth),
            vectorClientEnd:
                $fieldType22.decode($decoder, $offset + 376, $depth),
            vectorServerEnd:
                $fieldType23.decode($decoder, $offset + 392, $depth),
            vectorStruct: $fieldType24.decode($decoder, $offset + 408, $depth),
            vectorTable: $fieldType25.decode($decoder, $offset + 424, $depth),
            vectorUnion: $fieldType26.decode($decoder, $offset + 440, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Resource> kResource_Type = $fidl.StructType<Resource>(
    inlineSize: 456, structDecode: Resource._structDecode);

class ResourceStruct extends $fidl.Struct {
  const ResourceStruct({
    this.reserved = 0x0,
  });
  ResourceStruct.clone(
    ResourceStruct $orig, {
    int? reserved,
  }) : this(
          reserved: reserved ?? $orig.reserved,
        );

  ResourceStruct $cloneWith({
    int? reserved,
  }) {
    return ResourceStruct(
      reserved: reserved ?? this.reserved,
    );
  }

  final int reserved;

  @override
  List<Object?> get $fields {
    return <Object?>[
      reserved,
    ];
  }

  static const $fieldType0 = $fidl.Uint8Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, reserved, $offset + 0, $depth);
  }

  static ResourceStruct _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 0, 1);
        return ResourceStruct(
            reserved: $fieldType0.decode($decoder, $offset + 0, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<ResourceStruct> kResourceStruct_Type =
    $fidl.StructType<ResourceStruct>(
        inlineSize: 1, structDecode: ResourceStruct._structDecode);

class Struct extends $fidl.Struct {
  const Struct({
    this.reserved = 0x0,
  });
  Struct.clone(
    Struct $orig, {
    int? reserved,
  }) : this(
          reserved: reserved ?? $orig.reserved,
        );

  Struct $cloneWith({
    int? reserved,
  }) {
    return Struct(
      reserved: reserved ?? this.reserved,
    );
  }

  final int reserved;

  @override
  List<Object?> get $fields {
    return <Object?>[
      reserved,
    ];
  }

  static const $fieldType0 = $fidl.Uint8Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, reserved, $offset + 0, $depth);
  }

  static Struct _structDecode($fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 0, 1);
        return Struct(
            reserved: $fieldType0.decode($decoder, $offset + 0, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Struct> kStruct_Type =
    $fidl.StructType<Struct>(inlineSize: 1, structDecode: Struct._structDecode);

class VectorBasic extends $fidl.Struct {
  const VectorBasic({
    required this.vectorUint8,
    required this.vectorUint16,
    required this.vectorUint32,
    required this.vectorUint64,
    required this.vectorInt8,
    required this.vectorInt16,
    required this.vectorInt32,
    required this.vectorInt64,
    required this.vectorFloat32,
    required this.vectorFloat64,
    required this.vectorString,
    required this.vectorOptString,
  });
  VectorBasic.clone(
    VectorBasic $orig, {
    Uint8List? vectorUint8,
    Uint16List? vectorUint16,
    Uint32List? vectorUint32,
    Uint64List? vectorUint64,
    Int8List? vectorInt8,
    Int16List? vectorInt16,
    Int32List? vectorInt32,
    Int64List? vectorInt64,
    Float32List? vectorFloat32,
    Float64List? vectorFloat64,
    List<String>? vectorString,
    List<String?>? vectorOptString,
  }) : this(
          vectorUint8: vectorUint8 ?? $orig.vectorUint8,
          vectorUint16: vectorUint16 ?? $orig.vectorUint16,
          vectorUint32: vectorUint32 ?? $orig.vectorUint32,
          vectorUint64: vectorUint64 ?? $orig.vectorUint64,
          vectorInt8: vectorInt8 ?? $orig.vectorInt8,
          vectorInt16: vectorInt16 ?? $orig.vectorInt16,
          vectorInt32: vectorInt32 ?? $orig.vectorInt32,
          vectorInt64: vectorInt64 ?? $orig.vectorInt64,
          vectorFloat32: vectorFloat32 ?? $orig.vectorFloat32,
          vectorFloat64: vectorFloat64 ?? $orig.vectorFloat64,
          vectorString: vectorString ?? $orig.vectorString,
          vectorOptString: vectorOptString ?? $orig.vectorOptString,
        );

  VectorBasic $cloneWith({
    Uint8List? vectorUint8,
    Uint16List? vectorUint16,
    Uint32List? vectorUint32,
    Uint64List? vectorUint64,
    Int8List? vectorInt8,
    Int16List? vectorInt16,
    Int32List? vectorInt32,
    Int64List? vectorInt64,
    Float32List? vectorFloat32,
    Float64List? vectorFloat64,
    List<String>? vectorString,
    List<String?>? vectorOptString,
  }) {
    return VectorBasic(
      vectorUint8: vectorUint8 ?? this.vectorUint8,
      vectorUint16: vectorUint16 ?? this.vectorUint16,
      vectorUint32: vectorUint32 ?? this.vectorUint32,
      vectorUint64: vectorUint64 ?? this.vectorUint64,
      vectorInt8: vectorInt8 ?? this.vectorInt8,
      vectorInt16: vectorInt16 ?? this.vectorInt16,
      vectorInt32: vectorInt32 ?? this.vectorInt32,
      vectorInt64: vectorInt64 ?? this.vectorInt64,
      vectorFloat32: vectorFloat32 ?? this.vectorFloat32,
      vectorFloat64: vectorFloat64 ?? this.vectorFloat64,
      vectorString: vectorString ?? this.vectorString,
      vectorOptString: vectorOptString ?? this.vectorOptString,
    );
  }

  final Uint8List vectorUint8;
  final Uint16List vectorUint16;
  final Uint32List vectorUint32;
  final Uint64List vectorUint64;
  final Int8List vectorInt8;
  final Int16List vectorInt16;
  final Int32List vectorInt32;
  final Int64List vectorInt64;
  final Float32List vectorFloat32;
  final Float64List vectorFloat64;
  final List<String> vectorString;
  final List<String?> vectorOptString;

  @override
  List<Object?> get $fields {
    return <Object?>[
      vectorUint8,
      vectorUint16,
      vectorUint32,
      vectorUint64,
      vectorInt8,
      vectorInt16,
      vectorInt32,
      vectorInt64,
      vectorFloat32,
      vectorFloat64,
      vectorString,
      vectorOptString,
    ];
  }

  static const $fieldType0 = $fidl.VectorType<int, Uint8List>(
      element: $fidl.Uint8Type(), maybeElementCount: null);
  static const $fieldType1 = $fidl.VectorType<int, Uint16List>(
      element: $fidl.Uint16Type(), maybeElementCount: null);
  static const $fieldType2 = $fidl.VectorType<int, Uint32List>(
      element: $fidl.Uint32Type(), maybeElementCount: null);
  static const $fieldType3 = $fidl.VectorType<int, Uint64List>(
      element: $fidl.Uint64Type(), maybeElementCount: null);
  static const $fieldType4 = $fidl.VectorType<int, Int8List>(
      element: $fidl.Int8Type(), maybeElementCount: null);
  static const $fieldType5 = $fidl.VectorType<int, Int16List>(
      element: $fidl.Int16Type(), maybeElementCount: null);
  static const $fieldType6 = $fidl.VectorType<int, Int32List>(
      element: $fidl.Int32Type(), maybeElementCount: null);
  static const $fieldType7 = $fidl.VectorType<int, Int64List>(
      element: $fidl.Int64Type(), maybeElementCount: null);
  static const $fieldType8 = $fidl.VectorType<double, Float32List>(
      element: $fidl.Float32Type(), maybeElementCount: null);
  static const $fieldType9 = $fidl.VectorType<double, Float64List>(
      element: $fidl.Float64Type(), maybeElementCount: null);
  static const $fieldType10 = $fidl.VectorType<String, List<String>>(
      element: $fidl.StringType(maybeElementCount: null),
      maybeElementCount: null);
  static const $fieldType11 = $fidl.VectorType<String?, List<String?>>(
      element: $fidl.NullableStringType(maybeElementCount: null),
      maybeElementCount: null);

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, vectorUint8, $offset + 0, $depth);
    $fieldType1.encode($encoder, vectorUint16, $offset + 16, $depth);
    $fieldType2.encode($encoder, vectorUint32, $offset + 32, $depth);
    $fieldType3.encode($encoder, vectorUint64, $offset + 48, $depth);
    $fieldType4.encode($encoder, vectorInt8, $offset + 64, $depth);
    $fieldType5.encode($encoder, vectorInt16, $offset + 80, $depth);
    $fieldType6.encode($encoder, vectorInt32, $offset + 96, $depth);
    $fieldType7.encode($encoder, vectorInt64, $offset + 112, $depth);
    $fieldType8.encode($encoder, vectorFloat32, $offset + 128, $depth);
    $fieldType9.encode($encoder, vectorFloat64, $offset + 144, $depth);
    $fieldType10.encode($encoder, vectorString, $offset + 160, $depth);
    $fieldType11.encode($encoder, vectorOptString, $offset + 176, $depth);
  }

  static VectorBasic _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        return VectorBasic(
            vectorUint8: $fieldType0.decode($decoder, $offset + 0, $depth),
            vectorUint16: $fieldType1.decode($decoder, $offset + 16, $depth),
            vectorUint32: $fieldType2.decode($decoder, $offset + 32, $depth),
            vectorUint64: $fieldType3.decode($decoder, $offset + 48, $depth),
            vectorInt8: $fieldType4.decode($decoder, $offset + 64, $depth),
            vectorInt16: $fieldType5.decode($decoder, $offset + 80, $depth),
            vectorInt32: $fieldType6.decode($decoder, $offset + 96, $depth),
            vectorInt64: $fieldType7.decode($decoder, $offset + 112, $depth),
            vectorFloat32: $fieldType8.decode($decoder, $offset + 128, $depth),
            vectorFloat64: $fieldType9.decode($decoder, $offset + 144, $depth),
            vectorString: $fieldType10.decode($decoder, $offset + 160, $depth),
            vectorOptString:
                $fieldType11.decode($decoder, $offset + 176, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<VectorBasic> kVectorBasic_Type =
    $fidl.StructType<VectorBasic>(
        inlineSize: 192, structDecode: VectorBasic._structDecode);

class VectorCompound extends $fidl.Struct {
  const VectorCompound({
    required this.vectorBits,
    required this.vectorEnum,
    required this.vectorStruct,
    required this.vectorTable,
    required this.vectorUnion,
    required this.vectorOptStruct,
    required this.vectorOptUnion,
  });
  VectorCompound.clone(
    VectorCompound $orig, {
    List<Bits>? vectorBits,
    List<Enum>? vectorEnum,
    List<Struct>? vectorStruct,
    List<Table>? vectorTable,
    List<Union>? vectorUnion,
    List<Struct?>? vectorOptStruct,
    List<Union?>? vectorOptUnion,
  }) : this(
          vectorBits: vectorBits ?? $orig.vectorBits,
          vectorEnum: vectorEnum ?? $orig.vectorEnum,
          vectorStruct: vectorStruct ?? $orig.vectorStruct,
          vectorTable: vectorTable ?? $orig.vectorTable,
          vectorUnion: vectorUnion ?? $orig.vectorUnion,
          vectorOptStruct: vectorOptStruct ?? $orig.vectorOptStruct,
          vectorOptUnion: vectorOptUnion ?? $orig.vectorOptUnion,
        );

  VectorCompound $cloneWith({
    List<Bits>? vectorBits,
    List<Enum>? vectorEnum,
    List<Struct>? vectorStruct,
    List<Table>? vectorTable,
    List<Union>? vectorUnion,
    List<Struct?>? vectorOptStruct,
    List<Union?>? vectorOptUnion,
  }) {
    return VectorCompound(
      vectorBits: vectorBits ?? this.vectorBits,
      vectorEnum: vectorEnum ?? this.vectorEnum,
      vectorStruct: vectorStruct ?? this.vectorStruct,
      vectorTable: vectorTable ?? this.vectorTable,
      vectorUnion: vectorUnion ?? this.vectorUnion,
      vectorOptStruct: vectorOptStruct ?? this.vectorOptStruct,
      vectorOptUnion: vectorOptUnion ?? this.vectorOptUnion,
    );
  }

  final List<Bits> vectorBits;
  final List<Enum> vectorEnum;
  final List<Struct> vectorStruct;
  final List<Table> vectorTable;
  final List<Union> vectorUnion;
  final List<Struct?> vectorOptStruct;
  final List<Union?> vectorOptUnion;

  @override
  List<Object?> get $fields {
    return <Object?>[
      vectorBits,
      vectorEnum,
      vectorStruct,
      vectorTable,
      vectorUnion,
      vectorOptStruct,
      vectorOptUnion,
    ];
  }

  static const $fieldType0 = $fidl.VectorType<Bits, List<Bits>>(
      element: kBits_Type, maybeElementCount: null);
  static const $fieldType1 = $fidl.VectorType<Enum, List<Enum>>(
      element: kEnum_Type, maybeElementCount: null);
  static const $fieldType2 = $fidl.VectorType<Struct, List<Struct>>(
      element: kStruct_Type, maybeElementCount: null);
  static const $fieldType3 = $fidl.VectorType<Table, List<Table>>(
      element: kTable_Type, maybeElementCount: null);
  static const $fieldType4 = $fidl.VectorType<Union, List<Union>>(
      element: kUnion_Type, maybeElementCount: null);
  static const $fieldType5 = $fidl.VectorType<Struct?, List<Struct?>>(
      element: $fidl.PointerType<Struct>(element: kStruct_Type),
      maybeElementCount: null);
  static const $fieldType6 = $fidl.VectorType<Union?, List<Union?>>(
      element: kUnion_OptType, maybeElementCount: null);

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, vectorBits, $offset + 0, $depth);
    $fieldType1.encode($encoder, vectorEnum, $offset + 16, $depth);
    $fieldType2.encode($encoder, vectorStruct, $offset + 32, $depth);
    $fieldType3.encode($encoder, vectorTable, $offset + 48, $depth);
    $fieldType4.encode($encoder, vectorUnion, $offset + 64, $depth);
    $fieldType5.encode($encoder, vectorOptStruct, $offset + 80, $depth);
    $fieldType6.encode($encoder, vectorOptUnion, $offset + 96, $depth);
  }

  static VectorCompound _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        return VectorCompound(
            vectorBits: $fieldType0.decode($decoder, $offset + 0, $depth),
            vectorEnum: $fieldType1.decode($decoder, $offset + 16, $depth),
            vectorStruct: $fieldType2.decode($decoder, $offset + 32, $depth),
            vectorTable: $fieldType3.decode($decoder, $offset + 48, $depth),
            vectorUnion: $fieldType4.decode($decoder, $offset + 64, $depth),
            vectorOptStruct: $fieldType5.decode($decoder, $offset + 80, $depth),
            vectorOptUnion: $fieldType6.decode($decoder, $offset + 96, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<VectorCompound> kVectorCompound_Type =
    $fidl.StructType<VectorCompound>(
        inlineSize: 112, structDecode: VectorCompound._structDecode);

class VectorOptional extends $fidl.Struct {
  const VectorOptional({
    this.optVectorUint8,
    this.optVectorString,
    this.optVectorStruct,
    this.optVectorOptStruct,
  });
  VectorOptional.clone(
    VectorOptional $orig, {
    Uint8List? optVectorUint8,
    List<String>? optVectorString,
    List<Struct>? optVectorStruct,
    List<Struct?>? optVectorOptStruct,
  }) : this(
          optVectorUint8: optVectorUint8 ?? $orig.optVectorUint8,
          optVectorString: optVectorString ?? $orig.optVectorString,
          optVectorStruct: optVectorStruct ?? $orig.optVectorStruct,
          optVectorOptStruct: optVectorOptStruct ?? $orig.optVectorOptStruct,
        );

  VectorOptional.cloneWithout(
    VectorOptional $orig, {
    bool optVectorUint8 = false,
    bool optVectorString = false,
    bool optVectorStruct = false,
    bool optVectorOptStruct = false,
  }) : this(
          optVectorUint8: optVectorUint8 ? null : $orig.optVectorUint8,
          optVectorString: optVectorString ? null : $orig.optVectorString,
          optVectorStruct: optVectorStruct ? null : $orig.optVectorStruct,
          optVectorOptStruct:
              optVectorOptStruct ? null : $orig.optVectorOptStruct,
        );

  VectorOptional $cloneWith({
    $fidl.OptionalNullable<Uint8List?> optVectorUint8 =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<List<String>?> optVectorString =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<List<Struct>?> optVectorStruct =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<List<Struct?>?> optVectorOptStruct =
        const $fidl.OptionalNullable.undefined(),
  }) {
    return VectorOptional(
      optVectorUint8: optVectorUint8.or(this.optVectorUint8),
      optVectorString: optVectorString.or(this.optVectorString),
      optVectorStruct: optVectorStruct.or(this.optVectorStruct),
      optVectorOptStruct: optVectorOptStruct.or(this.optVectorOptStruct),
    );
  }

  final Uint8List? optVectorUint8;
  final List<String>? optVectorString;
  final List<Struct>? optVectorStruct;
  final List<Struct?>? optVectorOptStruct;

  @override
  List<Object?> get $fields {
    return <Object?>[
      optVectorUint8,
      optVectorString,
      optVectorStruct,
      optVectorOptStruct,
    ];
  }

  static const $fieldType0 = $fidl.NullableVectorType<int, Uint8List>(
      element: $fidl.Uint8Type(), maybeElementCount: null);
  static const $fieldType1 = $fidl.NullableVectorType<String, List<String>>(
      element: $fidl.StringType(maybeElementCount: null),
      maybeElementCount: null);
  static const $fieldType2 = $fidl.NullableVectorType<Struct, List<Struct>>(
      element: kStruct_Type, maybeElementCount: null);
  static const $fieldType3 = $fidl.NullableVectorType<Struct?, List<Struct?>>(
      element: $fidl.PointerType<Struct>(element: kStruct_Type),
      maybeElementCount: null);

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, optVectorUint8, $offset + 0, $depth);
    $fieldType1.encode($encoder, optVectorString, $offset + 16, $depth);
    $fieldType2.encode($encoder, optVectorStruct, $offset + 32, $depth);
    $fieldType3.encode($encoder, optVectorOptStruct, $offset + 48, $depth);
  }

  static VectorOptional _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        return VectorOptional(
            optVectorUint8: $fieldType0.decode($decoder, $offset + 0, $depth),
            optVectorString: $fieldType1.decode($decoder, $offset + 16, $depth),
            optVectorStruct: $fieldType2.decode($decoder, $offset + 32, $depth),
            optVectorOptStruct:
                $fieldType3.decode($decoder, $offset + 48, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<VectorOptional> kVectorOptional_Type =
    $fidl.StructType<VectorOptional>(
        inlineSize: 64, structDecode: VectorOptional._structDecode);

class ResourceTable extends $fidl.Table {
  const ResourceTable({
    this.$unknownData,
  });

  ResourceTable._(Map<int, dynamic> argv, this.$unknownData);

  ResourceTable $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
  }) {
    return ResourceTable();
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;

  @override
  dynamic $field(int index) {
    switch (index) {
      
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {};
  }

  static ResourceTable _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      ResourceTable._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<ResourceTable> kResourceTable_Type =
    $fidl.TableType<ResourceTable>(
  inlineSize: 16,
  members: [],
  ctor: ResourceTable._ctor,
  resource: true,
);

class Table extends $fidl.Table {
  const Table({
    this.$unknownData,
  });

  Table._(Map<int, dynamic> argv, this.$unknownData);

  Table $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
  }) {
    return Table();
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;

  @override
  dynamic $field(int index) {
    switch (index) {
      
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {};
  }

  static Table _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      Table._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<Table> kTable_Type = $fidl.TableType<Table>(
  inlineSize: 16,
  members: [],
  ctor: Table._ctor,
  resource: false,
);

// oneWayBasic: (int uint8, int uint16, int uint32, int uint64, int int8, int int16, int int32, int int64, double float32, double float64, String string, String? optString)
const int _kProtocol_OneWayBasic_Ordinal = 0x7c311f0d9e662df9;
const $fidl.MethodType _kProtocol_OneWayBasic_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint8Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint16Type(), offset: 2),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
    $fidl.MemberType<int>(type: $fidl.Uint64Type(), offset: 8),
    $fidl.MemberType<int>(type: $fidl.Int8Type(), offset: 16),
    $fidl.MemberType<int>(type: $fidl.Int16Type(), offset: 18),
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 20),
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 24),
    $fidl.MemberType<double>(type: $fidl.Float32Type(), offset: 32),
    $fidl.MemberType<double>(type: $fidl.Float64Type(), offset: 40),
    $fidl.MemberType<String>(
        type: $fidl.StringType(maybeElementCount: null), offset: 48),
    $fidl.MemberType<String?>(
        type: $fidl.NullableStringType(maybeElementCount: null), offset: 64),
  ],
  response: [],
  name: r"Protocol.OneWayBasic",
  requestInlineSizeV2: 80,
  responseInlineSizeV2: 0,
);
// twoWayBasic: (int uint8, int uint16, int uint32, int uint64, int int8, int int16, int int32, int int64, double float32, double float64, String string, String? optString) -> (int uint8, int uint16, int uint32, int uint64, int int8, int int16, int int32, int int64, double float32, double float64, String string, String? optString)
const int _kProtocol_TwoWayBasic_Ordinal = 0x205b92db5139c88f;
const $fidl.MethodType _kProtocol_TwoWayBasic_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint8Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint16Type(), offset: 2),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
    $fidl.MemberType<int>(type: $fidl.Uint64Type(), offset: 8),
    $fidl.MemberType<int>(type: $fidl.Int8Type(), offset: 16),
    $fidl.MemberType<int>(type: $fidl.Int16Type(), offset: 18),
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 20),
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 24),
    $fidl.MemberType<double>(type: $fidl.Float32Type(), offset: 32),
    $fidl.MemberType<double>(type: $fidl.Float64Type(), offset: 40),
    $fidl.MemberType<String>(
        type: $fidl.StringType(maybeElementCount: null), offset: 48),
    $fidl.MemberType<String?>(
        type: $fidl.NullableStringType(maybeElementCount: null), offset: 64),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint8Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint16Type(), offset: 2),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
    $fidl.MemberType<int>(type: $fidl.Uint64Type(), offset: 8),
    $fidl.MemberType<int>(type: $fidl.Int8Type(), offset: 16),
    $fidl.MemberType<int>(type: $fidl.Int16Type(), offset: 18),
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 20),
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 24),
    $fidl.MemberType<double>(type: $fidl.Float32Type(), offset: 32),
    $fidl.MemberType<double>(type: $fidl.Float64Type(), offset: 40),
    $fidl.MemberType<String>(
        type: $fidl.StringType(maybeElementCount: null), offset: 48),
    $fidl.MemberType<String?>(
        type: $fidl.NullableStringType(maybeElementCount: null), offset: 64),
  ],
  name: r"Protocol.TwoWayBasic",
  requestInlineSizeV2: 80,
  responseInlineSizeV2: 80,
);
// errorBasic: () -> (int uint8, int uint16, int uint32, int uint64, int int8, int int16, int int32, int int64, double float32, double float64, String string, String? optString)
const int _kProtocol_ErrorBasic_Ordinal = 0x459eaa5d11b9ff93;
const $fidl.MethodType _kProtocol_ErrorBasic_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ProtocolErrorBasicResult>(
        type: kProtocol_ErrorBasic_Result_Type, offset: 0),
  ],
  name: r"Protocol.ErrorBasic",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// eventBasic:  -> (int uint8, int uint16, int uint32, int uint64, int int8, int int16, int int32, int int64, double float32, double float64, String string, String? optString)
const int _kProtocol_EventBasic_Ordinal = 0x51c5b06295c10c40;
const $fidl.MethodType _kProtocol_EventBasic_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<int>(type: $fidl.Uint8Type(), offset: 0),
    $fidl.MemberType<int>(type: $fidl.Uint16Type(), offset: 2),
    $fidl.MemberType<int>(type: $fidl.Uint32Type(), offset: 4),
    $fidl.MemberType<int>(type: $fidl.Uint64Type(), offset: 8),
    $fidl.MemberType<int>(type: $fidl.Int8Type(), offset: 16),
    $fidl.MemberType<int>(type: $fidl.Int16Type(), offset: 18),
    $fidl.MemberType<int>(type: $fidl.Int32Type(), offset: 20),
    $fidl.MemberType<int>(type: $fidl.Int64Type(), offset: 24),
    $fidl.MemberType<double>(type: $fidl.Float32Type(), offset: 32),
    $fidl.MemberType<double>(type: $fidl.Float64Type(), offset: 40),
    $fidl.MemberType<String>(
        type: $fidl.StringType(maybeElementCount: null), offset: 48),
    $fidl.MemberType<String?>(
        type: $fidl.NullableStringType(maybeElementCount: null), offset: 64),
  ],
  name: r"Protocol.EventBasic",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 80,
);
// oneWayCompound: (Bits bits, Enum enum$, Struct struct, Table table, Union union, Struct? optStruct, Union? optUnion)
const int _kProtocol_OneWayCompound_Ordinal = 0x2bc2bc3a9237c6cc;
const $fidl.MethodType _kProtocol_OneWayCompound_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<Bits>(type: kBits_Type, offset: 0),
    $fidl.MemberType<Enum>(type: kEnum_Type, offset: 4),
    $fidl.MemberType<Struct>(type: kStruct_Type, offset: 8),
    $fidl.MemberType<Table>(type: kTable_Type, offset: 16),
    $fidl.MemberType<Union>(type: kUnion_Type, offset: 32),
    $fidl.MemberType<Struct?>(
        type: $fidl.PointerType<Struct>(element: kStruct_Type), offset: 48),
    $fidl.MemberType<Union?>(type: kUnion_OptType, offset: 56),
  ],
  response: [],
  name: r"Protocol.OneWayCompound",
  requestInlineSizeV2: 72,
  responseInlineSizeV2: 0,
);
// twoWayCompound: (Bits bits, Enum enum$, Struct struct, Table table, Union union, Struct? optStruct, Union? optUnion) -> (Bits bits, Enum enum$, Struct struct, Table table, Union union, Struct? optStruct, Union? optUnion)
const int _kProtocol_TwoWayCompound_Ordinal = 0x79f279c7201da131;
const $fidl.MethodType _kProtocol_TwoWayCompound_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<Bits>(type: kBits_Type, offset: 0),
    $fidl.MemberType<Enum>(type: kEnum_Type, offset: 4),
    $fidl.MemberType<Struct>(type: kStruct_Type, offset: 8),
    $fidl.MemberType<Table>(type: kTable_Type, offset: 16),
    $fidl.MemberType<Union>(type: kUnion_Type, offset: 32),
    $fidl.MemberType<Struct?>(
        type: $fidl.PointerType<Struct>(element: kStruct_Type), offset: 48),
    $fidl.MemberType<Union?>(type: kUnion_OptType, offset: 56),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<Bits>(type: kBits_Type, offset: 0),
    $fidl.MemberType<Enum>(type: kEnum_Type, offset: 4),
    $fidl.MemberType<Struct>(type: kStruct_Type, offset: 8),
    $fidl.MemberType<Table>(type: kTable_Type, offset: 16),
    $fidl.MemberType<Union>(type: kUnion_Type, offset: 32),
    $fidl.MemberType<Struct?>(
        type: $fidl.PointerType<Struct>(element: kStruct_Type), offset: 48),
    $fidl.MemberType<Union?>(type: kUnion_OptType, offset: 56),
  ],
  name: r"Protocol.TwoWayCompound",
  requestInlineSizeV2: 72,
  responseInlineSizeV2: 72,
);
// errorCompound: () -> (Bits bits, Enum enum$, Struct struct, Table table, Union union, Struct? optStruct, Union? optUnion)
const int _kProtocol_ErrorCompound_Ordinal = 0x29817d89a19ec77d;
const $fidl.MethodType _kProtocol_ErrorCompound_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ProtocolErrorCompoundResult>(
        type: kProtocol_ErrorCompound_Result_Type, offset: 0),
  ],
  name: r"Protocol.ErrorCompound",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// eventCompound:  -> (Bits bits, Enum enum$, Struct struct, Table table, Union union, Struct? optStruct, Union? optUnion)
const int _kProtocol_EventCompound_Ordinal = 0x617c5410858734d5;
const $fidl.MethodType _kProtocol_EventCompound_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<Bits>(type: kBits_Type, offset: 0),
    $fidl.MemberType<Enum>(type: kEnum_Type, offset: 4),
    $fidl.MemberType<Struct>(type: kStruct_Type, offset: 8),
    $fidl.MemberType<Table>(type: kTable_Type, offset: 16),
    $fidl.MemberType<Union>(type: kUnion_Type, offset: 32),
    $fidl.MemberType<Struct?>(
        type: $fidl.PointerType<Struct>(element: kStruct_Type), offset: 48),
    $fidl.MemberType<Union?>(type: kUnion_OptType, offset: 56),
  ],
  name: r"Protocol.EventCompound",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 72,
);
// oneWayArrayBasic: (Uint8List arrayUint8, Uint16List arrayUint16, Uint32List arrayUint32, Uint64List arrayUint64, Int8List arrayInt8, Int16List arrayInt16, Int32List arrayInt32, Int64List arrayInt64, Float32List arrayFloat32, Float64List arrayFloat64, List<String> arrayString, List<String?> arrayOptString)
const int _kProtocol_OneWayArrayBasic_Ordinal = 0x62e2ebcadf35ca19;
const $fidl.MethodType _kProtocol_OneWayArrayBasic_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<Uint8List>(
        type: $fidl.ArrayType<int, Uint8List>(
            element: $fidl.Uint8Type(), elementCount: 5),
        offset: 0),
    $fidl.MemberType<Uint16List>(
        type: $fidl.ArrayType<int, Uint16List>(
            element: $fidl.Uint16Type(), elementCount: 5),
        offset: 6),
    $fidl.MemberType<Uint32List>(
        type: $fidl.ArrayType<int, Uint32List>(
            element: $fidl.Uint32Type(), elementCount: 5),
        offset: 16),
    $fidl.MemberType<Uint64List>(
        type: $fidl.ArrayType<int, Uint64List>(
            element: $fidl.Uint64Type(), elementCount: 5),
        offset: 40),
    $fidl.MemberType<Int8List>(
        type: $fidl.ArrayType<int, Int8List>(
            element: $fidl.Int8Type(), elementCount: 5),
        offset: 80),
    $fidl.MemberType<Int16List>(
        type: $fidl.ArrayType<int, Int16List>(
            element: $fidl.Int16Type(), elementCount: 5),
        offset: 86),
    $fidl.MemberType<Int32List>(
        type: $fidl.ArrayType<int, Int32List>(
            element: $fidl.Int32Type(), elementCount: 5),
        offset: 96),
    $fidl.MemberType<Int64List>(
        type: $fidl.ArrayType<int, Int64List>(
            element: $fidl.Int64Type(), elementCount: 5),
        offset: 120),
    $fidl.MemberType<Float32List>(
        type: $fidl.ArrayType<double, Float32List>(
            element: $fidl.Float32Type(), elementCount: 5),
        offset: 160),
    $fidl.MemberType<Float64List>(
        type: $fidl.ArrayType<double, Float64List>(
            element: $fidl.Float64Type(), elementCount: 5),
        offset: 184),
    $fidl.MemberType<List<String>>(
        type: $fidl.ArrayType<String, List<String>>(
            element: $fidl.StringType(maybeElementCount: null),
            elementCount: 5),
        offset: 224),
    $fidl.MemberType<List<String?>>(
        type: $fidl.ArrayType<String?, List<String?>>(
            element: $fidl.NullableStringType(maybeElementCount: null),
            elementCount: 5),
        offset: 304),
  ],
  response: [],
  name: r"Protocol.OneWayArrayBasic",
  requestInlineSizeV2: 384,
  responseInlineSizeV2: 0,
);
// twoWayArrayBasic: (Uint8List arrayUint8, Uint16List arrayUint16, Uint32List arrayUint32, Uint64List arrayUint64, Int8List arrayInt8, Int16List arrayInt16, Int32List arrayInt32, Int64List arrayInt64, Float32List arrayFloat32, Float64List arrayFloat64, List<String> arrayString, List<String?> arrayOptString) -> (Uint8List arrayUint8, Uint16List arrayUint16, Uint32List arrayUint32, Uint64List arrayUint64, Int8List arrayInt8, Int16List arrayInt16, Int32List arrayInt32, Int64List arrayInt64, Float32List arrayFloat32, Float64List arrayFloat64, List<String> arrayString, List<String?> arrayOptString)
const int _kProtocol_TwoWayArrayBasic_Ordinal = 0x49ad7a74e28ba114;
const $fidl.MethodType _kProtocol_TwoWayArrayBasic_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<Uint8List>(
        type: $fidl.ArrayType<int, Uint8List>(
            element: $fidl.Uint8Type(), elementCount: 5),
        offset: 0),
    $fidl.MemberType<Uint16List>(
        type: $fidl.ArrayType<int, Uint16List>(
            element: $fidl.Uint16Type(), elementCount: 5),
        offset: 6),
    $fidl.MemberType<Uint32List>(
        type: $fidl.ArrayType<int, Uint32List>(
            element: $fidl.Uint32Type(), elementCount: 5),
        offset: 16),
    $fidl.MemberType<Uint64List>(
        type: $fidl.ArrayType<int, Uint64List>(
            element: $fidl.Uint64Type(), elementCount: 5),
        offset: 40),
    $fidl.MemberType<Int8List>(
        type: $fidl.ArrayType<int, Int8List>(
            element: $fidl.Int8Type(), elementCount: 5),
        offset: 80),
    $fidl.MemberType<Int16List>(
        type: $fidl.ArrayType<int, Int16List>(
            element: $fidl.Int16Type(), elementCount: 5),
        offset: 86),
    $fidl.MemberType<Int32List>(
        type: $fidl.ArrayType<int, Int32List>(
            element: $fidl.Int32Type(), elementCount: 5),
        offset: 96),
    $fidl.MemberType<Int64List>(
        type: $fidl.ArrayType<int, Int64List>(
            element: $fidl.Int64Type(), elementCount: 5),
        offset: 120),
    $fidl.MemberType<Float32List>(
        type: $fidl.ArrayType<double, Float32List>(
            element: $fidl.Float32Type(), elementCount: 5),
        offset: 160),
    $fidl.MemberType<Float64List>(
        type: $fidl.ArrayType<double, Float64List>(
            element: $fidl.Float64Type(), elementCount: 5),
        offset: 184),
    $fidl.MemberType<List<String>>(
        type: $fidl.ArrayType<String, List<String>>(
            element: $fidl.StringType(maybeElementCount: null),
            elementCount: 5),
        offset: 224),
    $fidl.MemberType<List<String?>>(
        type: $fidl.ArrayType<String?, List<String?>>(
            element: $fidl.NullableStringType(maybeElementCount: null),
            elementCount: 5),
        offset: 304),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<Uint8List>(
        type: $fidl.ArrayType<int, Uint8List>(
            element: $fidl.Uint8Type(), elementCount: 5),
        offset: 0),
    $fidl.MemberType<Uint16List>(
        type: $fidl.ArrayType<int, Uint16List>(
            element: $fidl.Uint16Type(), elementCount: 5),
        offset: 6),
    $fidl.MemberType<Uint32List>(
        type: $fidl.ArrayType<int, Uint32List>(
            element: $fidl.Uint32Type(), elementCount: 5),
        offset: 16),
    $fidl.MemberType<Uint64List>(
        type: $fidl.ArrayType<int, Uint64List>(
            element: $fidl.Uint64Type(), elementCount: 5),
        offset: 40),
    $fidl.MemberType<Int8List>(
        type: $fidl.ArrayType<int, Int8List>(
            element: $fidl.Int8Type(), elementCount: 5),
        offset: 80),
    $fidl.MemberType<Int16List>(
        type: $fidl.ArrayType<int, Int16List>(
            element: $fidl.Int16Type(), elementCount: 5),
        offset: 86),
    $fidl.MemberType<Int32List>(
        type: $fidl.ArrayType<int, Int32List>(
            element: $fidl.Int32Type(), elementCount: 5),
        offset: 96),
    $fidl.MemberType<Int64List>(
        type: $fidl.ArrayType<int, Int64List>(
            element: $fidl.Int64Type(), elementCount: 5),
        offset: 120),
    $fidl.MemberType<Float32List>(
        type: $fidl.ArrayType<double, Float32List>(
            element: $fidl.Float32Type(), elementCount: 5),
        offset: 160),
    $fidl.MemberType<Float64List>(
        type: $fidl.ArrayType<double, Float64List>(
            element: $fidl.Float64Type(), elementCount: 5),
        offset: 184),
    $fidl.MemberType<List<String>>(
        type: $fidl.ArrayType<String, List<String>>(
            element: $fidl.StringType(maybeElementCount: null),
            elementCount: 5),
        offset: 224),
    $fidl.MemberType<List<String?>>(
        type: $fidl.ArrayType<String?, List<String?>>(
            element: $fidl.NullableStringType(maybeElementCount: null),
            elementCount: 5),
        offset: 304),
  ],
  name: r"Protocol.TwoWayArrayBasic",
  requestInlineSizeV2: 384,
  responseInlineSizeV2: 384,
);
// errorArrayBasic: () -> (Uint8List arrayUint8, Uint16List arrayUint16, Uint32List arrayUint32, Uint64List arrayUint64, Int8List arrayInt8, Int16List arrayInt16, Int32List arrayInt32, Int64List arrayInt64, Float32List arrayFloat32, Float64List arrayFloat64, List<String> arrayString, List<String?> arrayOptString)
const int _kProtocol_ErrorArrayBasic_Ordinal = 0xf0dbde9626fff79;
const $fidl.MethodType _kProtocol_ErrorArrayBasic_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ProtocolErrorArrayBasicResult>(
        type: kProtocol_ErrorArrayBasic_Result_Type, offset: 0),
  ],
  name: r"Protocol.ErrorArrayBasic",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// eventArrayBasic:  -> (Uint8List arrayUint8, Uint16List arrayUint16, Uint32List arrayUint32, Uint64List arrayUint64, Int8List arrayInt8, Int16List arrayInt16, Int32List arrayInt32, Int64List arrayInt64, Float32List arrayFloat32, Float64List arrayFloat64, List<String> arrayString, List<String?> arrayOptString)
const int _kProtocol_EventArrayBasic_Ordinal = 0x51b76208b148f02e;
const $fidl.MethodType _kProtocol_EventArrayBasic_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<Uint8List>(
        type: $fidl.ArrayType<int, Uint8List>(
            element: $fidl.Uint8Type(), elementCount: 5),
        offset: 0),
    $fidl.MemberType<Uint16List>(
        type: $fidl.ArrayType<int, Uint16List>(
            element: $fidl.Uint16Type(), elementCount: 5),
        offset: 6),
    $fidl.MemberType<Uint32List>(
        type: $fidl.ArrayType<int, Uint32List>(
            element: $fidl.Uint32Type(), elementCount: 5),
        offset: 16),
    $fidl.MemberType<Uint64List>(
        type: $fidl.ArrayType<int, Uint64List>(
            element: $fidl.Uint64Type(), elementCount: 5),
        offset: 40),
    $fidl.MemberType<Int8List>(
        type: $fidl.ArrayType<int, Int8List>(
            element: $fidl.Int8Type(), elementCount: 5),
        offset: 80),
    $fidl.MemberType<Int16List>(
        type: $fidl.ArrayType<int, Int16List>(
            element: $fidl.Int16Type(), elementCount: 5),
        offset: 86),
    $fidl.MemberType<Int32List>(
        type: $fidl.ArrayType<int, Int32List>(
            element: $fidl.Int32Type(), elementCount: 5),
        offset: 96),
    $fidl.MemberType<Int64List>(
        type: $fidl.ArrayType<int, Int64List>(
            element: $fidl.Int64Type(), elementCount: 5),
        offset: 120),
    $fidl.MemberType<Float32List>(
        type: $fidl.ArrayType<double, Float32List>(
            element: $fidl.Float32Type(), elementCount: 5),
        offset: 160),
    $fidl.MemberType<Float64List>(
        type: $fidl.ArrayType<double, Float64List>(
            element: $fidl.Float64Type(), elementCount: 5),
        offset: 184),
    $fidl.MemberType<List<String>>(
        type: $fidl.ArrayType<String, List<String>>(
            element: $fidl.StringType(maybeElementCount: null),
            elementCount: 5),
        offset: 224),
    $fidl.MemberType<List<String?>>(
        type: $fidl.ArrayType<String?, List<String?>>(
            element: $fidl.NullableStringType(maybeElementCount: null),
            elementCount: 5),
        offset: 304),
  ],
  name: r"Protocol.EventArrayBasic",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 384,
);
// oneWayArrayCompound: (List<Bits> arrayBits, List<Enum> arrayEnum, List<Struct> arrayStruct, List<Table> arrayTable, List<Union> arrayUnion, List<Struct?> arrayOptStruct, List<Union?> arrayOptUnion)
const int _kProtocol_OneWayArrayCompound_Ordinal = 0x464948bae1bda09d;
const $fidl.MethodType _kProtocol_OneWayArrayCompound_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<List<Bits>>(
        type: $fidl.ArrayType<Bits, List<Bits>>(
            element: kBits_Type, elementCount: 5),
        offset: 0),
    $fidl.MemberType<List<Enum>>(
        type: $fidl.ArrayType<Enum, List<Enum>>(
            element: kEnum_Type, elementCount: 5),
        offset: 20),
    $fidl.MemberType<List<Struct>>(
        type: $fidl.ArrayType<Struct, List<Struct>>(
            element: kStruct_Type, elementCount: 5),
        offset: 40),
    $fidl.MemberType<List<Table>>(
        type: $fidl.ArrayType<Table, List<Table>>(
            element: kTable_Type, elementCount: 5),
        offset: 48),
    $fidl.MemberType<List<Union>>(
        type: $fidl.ArrayType<Union, List<Union>>(
            element: kUnion_Type, elementCount: 5),
        offset: 128),
    $fidl.MemberType<List<Struct?>>(
        type: $fidl.ArrayType<Struct?, List<Struct?>>(
            element: $fidl.PointerType<Struct>(element: kStruct_Type),
            elementCount: 5),
        offset: 208),
    $fidl.MemberType<List<Union?>>(
        type: $fidl.ArrayType<Union?, List<Union?>>(
            element: kUnion_OptType, elementCount: 5),
        offset: 248),
  ],
  response: [],
  name: r"Protocol.OneWayArrayCompound",
  requestInlineSizeV2: 328,
  responseInlineSizeV2: 0,
);
// twoWayArrayCompound: (List<Bits> arrayBits, List<Enum> arrayEnum, List<Struct> arrayStruct, List<Table> arrayTable, List<Union> arrayUnion, List<Struct?> arrayOptStruct, List<Union?> arrayOptUnion) -> (List<Bits> arrayBits, List<Enum> arrayEnum, List<Struct> arrayStruct, List<Table> arrayTable, List<Union> arrayUnion, List<Struct?> arrayOptStruct, List<Union?> arrayOptUnion)
const int _kProtocol_TwoWayArrayCompound_Ordinal = 0xbcae616f8e1ea7b;
const $fidl.MethodType _kProtocol_TwoWayArrayCompound_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<List<Bits>>(
        type: $fidl.ArrayType<Bits, List<Bits>>(
            element: kBits_Type, elementCount: 5),
        offset: 0),
    $fidl.MemberType<List<Enum>>(
        type: $fidl.ArrayType<Enum, List<Enum>>(
            element: kEnum_Type, elementCount: 5),
        offset: 20),
    $fidl.MemberType<List<Struct>>(
        type: $fidl.ArrayType<Struct, List<Struct>>(
            element: kStruct_Type, elementCount: 5),
        offset: 40),
    $fidl.MemberType<List<Table>>(
        type: $fidl.ArrayType<Table, List<Table>>(
            element: kTable_Type, elementCount: 5),
        offset: 48),
    $fidl.MemberType<List<Union>>(
        type: $fidl.ArrayType<Union, List<Union>>(
            element: kUnion_Type, elementCount: 5),
        offset: 128),
    $fidl.MemberType<List<Struct?>>(
        type: $fidl.ArrayType<Struct?, List<Struct?>>(
            element: $fidl.PointerType<Struct>(element: kStruct_Type),
            elementCount: 5),
        offset: 208),
    $fidl.MemberType<List<Union?>>(
        type: $fidl.ArrayType<Union?, List<Union?>>(
            element: kUnion_OptType, elementCount: 5),
        offset: 248),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<List<Bits>>(
        type: $fidl.ArrayType<Bits, List<Bits>>(
            element: kBits_Type, elementCount: 5),
        offset: 0),
    $fidl.MemberType<List<Enum>>(
        type: $fidl.ArrayType<Enum, List<Enum>>(
            element: kEnum_Type, elementCount: 5),
        offset: 20),
    $fidl.MemberType<List<Struct>>(
        type: $fidl.ArrayType<Struct, List<Struct>>(
            element: kStruct_Type, elementCount: 5),
        offset: 40),
    $fidl.MemberType<List<Table>>(
        type: $fidl.ArrayType<Table, List<Table>>(
            element: kTable_Type, elementCount: 5),
        offset: 48),
    $fidl.MemberType<List<Union>>(
        type: $fidl.ArrayType<Union, List<Union>>(
            element: kUnion_Type, elementCount: 5),
        offset: 128),
    $fidl.MemberType<List<Struct?>>(
        type: $fidl.ArrayType<Struct?, List<Struct?>>(
            element: $fidl.PointerType<Struct>(element: kStruct_Type),
            elementCount: 5),
        offset: 208),
    $fidl.MemberType<List<Union?>>(
        type: $fidl.ArrayType<Union?, List<Union?>>(
            element: kUnion_OptType, elementCount: 5),
        offset: 248),
  ],
  name: r"Protocol.TwoWayArrayCompound",
  requestInlineSizeV2: 328,
  responseInlineSizeV2: 328,
);
// errorArrayCompound: () -> (List<Bits> arrayBits, List<Enum> arrayEnum, List<Struct> arrayStruct, List<Table> arrayTable, List<Union> arrayUnion, List<Struct?> arrayOptStruct, List<Union?> arrayOptUnion)
const int _kProtocol_ErrorArrayCompound_Ordinal = 0x52257f80e29c1a04;
const $fidl.MethodType _kProtocol_ErrorArrayCompound_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ProtocolErrorArrayCompoundResult>(
        type: kProtocol_ErrorArrayCompound_Result_Type, offset: 0),
  ],
  name: r"Protocol.ErrorArrayCompound",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// eventArrayCompound:  -> (List<Bits> arrayBits, List<Enum> arrayEnum, List<Struct> arrayStruct, List<Table> arrayTable, List<Union> arrayUnion, List<Struct?> arrayOptStruct, List<Union?> arrayOptUnion)
const int _kProtocol_EventArrayCompound_Ordinal = 0x1e63a00079aa7415;
const $fidl.MethodType _kProtocol_EventArrayCompound_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<List<Bits>>(
        type: $fidl.ArrayType<Bits, List<Bits>>(
            element: kBits_Type, elementCount: 5),
        offset: 0),
    $fidl.MemberType<List<Enum>>(
        type: $fidl.ArrayType<Enum, List<Enum>>(
            element: kEnum_Type, elementCount: 5),
        offset: 20),
    $fidl.MemberType<List<Struct>>(
        type: $fidl.ArrayType<Struct, List<Struct>>(
            element: kStruct_Type, elementCount: 5),
        offset: 40),
    $fidl.MemberType<List<Table>>(
        type: $fidl.ArrayType<Table, List<Table>>(
            element: kTable_Type, elementCount: 5),
        offset: 48),
    $fidl.MemberType<List<Union>>(
        type: $fidl.ArrayType<Union, List<Union>>(
            element: kUnion_Type, elementCount: 5),
        offset: 128),
    $fidl.MemberType<List<Struct?>>(
        type: $fidl.ArrayType<Struct?, List<Struct?>>(
            element: $fidl.PointerType<Struct>(element: kStruct_Type),
            elementCount: 5),
        offset: 208),
    $fidl.MemberType<List<Union?>>(
        type: $fidl.ArrayType<Union?, List<Union?>>(
            element: kUnion_OptType, elementCount: 5),
        offset: 248),
  ],
  name: r"Protocol.EventArrayCompound",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 328,
);
// oneWayVectorBasic: (Uint8List vectorUint8, Uint16List vectorUint16, Uint32List vectorUint32, Uint64List vectorUint64, Int8List vectorInt8, Int16List vectorInt16, Int32List vectorInt32, Int64List vectorInt64, Float32List vectorFloat32, Float64List vectorFloat64, List<String> vectorString, List<String?> vectorOptString)
const int _kProtocol_OneWayVectorBasic_Ordinal = 0x4f907dde77464657;
const $fidl.MethodType _kProtocol_OneWayVectorBasic_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<Uint8List>(
        type: $fidl.VectorType<int, Uint8List>(
            element: $fidl.Uint8Type(), maybeElementCount: null),
        offset: 0),
    $fidl.MemberType<Uint16List>(
        type: $fidl.VectorType<int, Uint16List>(
            element: $fidl.Uint16Type(), maybeElementCount: null),
        offset: 16),
    $fidl.MemberType<Uint32List>(
        type: $fidl.VectorType<int, Uint32List>(
            element: $fidl.Uint32Type(), maybeElementCount: null),
        offset: 32),
    $fidl.MemberType<Uint64List>(
        type: $fidl.VectorType<int, Uint64List>(
            element: $fidl.Uint64Type(), maybeElementCount: null),
        offset: 48),
    $fidl.MemberType<Int8List>(
        type: $fidl.VectorType<int, Int8List>(
            element: $fidl.Int8Type(), maybeElementCount: null),
        offset: 64),
    $fidl.MemberType<Int16List>(
        type: $fidl.VectorType<int, Int16List>(
            element: $fidl.Int16Type(), maybeElementCount: null),
        offset: 80),
    $fidl.MemberType<Int32List>(
        type: $fidl.VectorType<int, Int32List>(
            element: $fidl.Int32Type(), maybeElementCount: null),
        offset: 96),
    $fidl.MemberType<Int64List>(
        type: $fidl.VectorType<int, Int64List>(
            element: $fidl.Int64Type(), maybeElementCount: null),
        offset: 112),
    $fidl.MemberType<Float32List>(
        type: $fidl.VectorType<double, Float32List>(
            element: $fidl.Float32Type(), maybeElementCount: null),
        offset: 128),
    $fidl.MemberType<Float64List>(
        type: $fidl.VectorType<double, Float64List>(
            element: $fidl.Float64Type(), maybeElementCount: null),
        offset: 144),
    $fidl.MemberType<List<String>>(
        type: $fidl.VectorType<String, List<String>>(
            element: $fidl.StringType(maybeElementCount: null),
            maybeElementCount: null),
        offset: 160),
    $fidl.MemberType<List<String?>>(
        type: $fidl.VectorType<String?, List<String?>>(
            element: $fidl.NullableStringType(maybeElementCount: null),
            maybeElementCount: null),
        offset: 176),
  ],
  response: [],
  name: r"Protocol.OneWayVectorBasic",
  requestInlineSizeV2: 192,
  responseInlineSizeV2: 0,
);
// twoWayVectorBasic: (Uint8List vectorUint8, Uint16List vectorUint16, Uint32List vectorUint32, Uint64List vectorUint64, Int8List vectorInt8, Int16List vectorInt16, Int32List vectorInt32, Int64List vectorInt64, Float32List vectorFloat32, Float64List vectorFloat64, List<String> vectorString, List<String?> vectorOptString) -> (Uint8List vectorUint8, Uint16List vectorUint16, Uint32List vectorUint32, Uint64List vectorUint64, Int8List vectorInt8, Int16List vectorInt16, Int32List vectorInt32, Int64List vectorInt64, Float32List vectorFloat32, Float64List vectorFloat64, List<String> vectorString, List<String?> vectorOptString)
const int _kProtocol_TwoWayVectorBasic_Ordinal = 0x7860cb3ed8362e74;
const $fidl.MethodType _kProtocol_TwoWayVectorBasic_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<Uint8List>(
        type: $fidl.VectorType<int, Uint8List>(
            element: $fidl.Uint8Type(), maybeElementCount: null),
        offset: 0),
    $fidl.MemberType<Uint16List>(
        type: $fidl.VectorType<int, Uint16List>(
            element: $fidl.Uint16Type(), maybeElementCount: null),
        offset: 16),
    $fidl.MemberType<Uint32List>(
        type: $fidl.VectorType<int, Uint32List>(
            element: $fidl.Uint32Type(), maybeElementCount: null),
        offset: 32),
    $fidl.MemberType<Uint64List>(
        type: $fidl.VectorType<int, Uint64List>(
            element: $fidl.Uint64Type(), maybeElementCount: null),
        offset: 48),
    $fidl.MemberType<Int8List>(
        type: $fidl.VectorType<int, Int8List>(
            element: $fidl.Int8Type(), maybeElementCount: null),
        offset: 64),
    $fidl.MemberType<Int16List>(
        type: $fidl.VectorType<int, Int16List>(
            element: $fidl.Int16Type(), maybeElementCount: null),
        offset: 80),
    $fidl.MemberType<Int32List>(
        type: $fidl.VectorType<int, Int32List>(
            element: $fidl.Int32Type(), maybeElementCount: null),
        offset: 96),
    $fidl.MemberType<Int64List>(
        type: $fidl.VectorType<int, Int64List>(
            element: $fidl.Int64Type(), maybeElementCount: null),
        offset: 112),
    $fidl.MemberType<Float32List>(
        type: $fidl.VectorType<double, Float32List>(
            element: $fidl.Float32Type(), maybeElementCount: null),
        offset: 128),
    $fidl.MemberType<Float64List>(
        type: $fidl.VectorType<double, Float64List>(
            element: $fidl.Float64Type(), maybeElementCount: null),
        offset: 144),
    $fidl.MemberType<List<String>>(
        type: $fidl.VectorType<String, List<String>>(
            element: $fidl.StringType(maybeElementCount: null),
            maybeElementCount: null),
        offset: 160),
    $fidl.MemberType<List<String?>>(
        type: $fidl.VectorType<String?, List<String?>>(
            element: $fidl.NullableStringType(maybeElementCount: null),
            maybeElementCount: null),
        offset: 176),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<Uint8List>(
        type: $fidl.VectorType<int, Uint8List>(
            element: $fidl.Uint8Type(), maybeElementCount: null),
        offset: 0),
    $fidl.MemberType<Uint16List>(
        type: $fidl.VectorType<int, Uint16List>(
            element: $fidl.Uint16Type(), maybeElementCount: null),
        offset: 16),
    $fidl.MemberType<Uint32List>(
        type: $fidl.VectorType<int, Uint32List>(
            element: $fidl.Uint32Type(), maybeElementCount: null),
        offset: 32),
    $fidl.MemberType<Uint64List>(
        type: $fidl.VectorType<int, Uint64List>(
            element: $fidl.Uint64Type(), maybeElementCount: null),
        offset: 48),
    $fidl.MemberType<Int8List>(
        type: $fidl.VectorType<int, Int8List>(
            element: $fidl.Int8Type(), maybeElementCount: null),
        offset: 64),
    $fidl.MemberType<Int16List>(
        type: $fidl.VectorType<int, Int16List>(
            element: $fidl.Int16Type(), maybeElementCount: null),
        offset: 80),
    $fidl.MemberType<Int32List>(
        type: $fidl.VectorType<int, Int32List>(
            element: $fidl.Int32Type(), maybeElementCount: null),
        offset: 96),
    $fidl.MemberType<Int64List>(
        type: $fidl.VectorType<int, Int64List>(
            element: $fidl.Int64Type(), maybeElementCount: null),
        offset: 112),
    $fidl.MemberType<Float32List>(
        type: $fidl.VectorType<double, Float32List>(
            element: $fidl.Float32Type(), maybeElementCount: null),
        offset: 128),
    $fidl.MemberType<Float64List>(
        type: $fidl.VectorType<double, Float64List>(
            element: $fidl.Float64Type(), maybeElementCount: null),
        offset: 144),
    $fidl.MemberType<List<String>>(
        type: $fidl.VectorType<String, List<String>>(
            element: $fidl.StringType(maybeElementCount: null),
            maybeElementCount: null),
        offset: 160),
    $fidl.MemberType<List<String?>>(
        type: $fidl.VectorType<String?, List<String?>>(
            element: $fidl.NullableStringType(maybeElementCount: null),
            maybeElementCount: null),
        offset: 176),
  ],
  name: r"Protocol.TwoWayVectorBasic",
  requestInlineSizeV2: 192,
  responseInlineSizeV2: 192,
);
// errorVectorBasic: () -> (Uint8List vectorUint8, Uint16List vectorUint16, Uint32List vectorUint32, Uint64List vectorUint64, Int8List vectorInt8, Int16List vectorInt16, Int32List vectorInt32, Int64List vectorInt64, Float32List vectorFloat32, Float64List vectorFloat64, List<String> vectorString, List<String?> vectorOptString)
const int _kProtocol_ErrorVectorBasic_Ordinal = 0xc27f841d6313f72;
const $fidl.MethodType _kProtocol_ErrorVectorBasic_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ProtocolErrorVectorBasicResult>(
        type: kProtocol_ErrorVectorBasic_Result_Type, offset: 0),
  ],
  name: r"Protocol.ErrorVectorBasic",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// eventVectorBasic:  -> (Uint8List vectorUint8, Uint16List vectorUint16, Uint32List vectorUint32, Uint64List vectorUint64, Int8List vectorInt8, Int16List vectorInt16, Int32List vectorInt32, Int64List vectorInt64, Float32List vectorFloat32, Float64List vectorFloat64, List<String> vectorString, List<String?> vectorOptString)
const int _kProtocol_EventVectorBasic_Ordinal = 0x3f9d405e7191eff6;
const $fidl.MethodType _kProtocol_EventVectorBasic_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<Uint8List>(
        type: $fidl.VectorType<int, Uint8List>(
            element: $fidl.Uint8Type(), maybeElementCount: null),
        offset: 0),
    $fidl.MemberType<Uint16List>(
        type: $fidl.VectorType<int, Uint16List>(
            element: $fidl.Uint16Type(), maybeElementCount: null),
        offset: 16),
    $fidl.MemberType<Uint32List>(
        type: $fidl.VectorType<int, Uint32List>(
            element: $fidl.Uint32Type(), maybeElementCount: null),
        offset: 32),
    $fidl.MemberType<Uint64List>(
        type: $fidl.VectorType<int, Uint64List>(
            element: $fidl.Uint64Type(), maybeElementCount: null),
        offset: 48),
    $fidl.MemberType<Int8List>(
        type: $fidl.VectorType<int, Int8List>(
            element: $fidl.Int8Type(), maybeElementCount: null),
        offset: 64),
    $fidl.MemberType<Int16List>(
        type: $fidl.VectorType<int, Int16List>(
            element: $fidl.Int16Type(), maybeElementCount: null),
        offset: 80),
    $fidl.MemberType<Int32List>(
        type: $fidl.VectorType<int, Int32List>(
            element: $fidl.Int32Type(), maybeElementCount: null),
        offset: 96),
    $fidl.MemberType<Int64List>(
        type: $fidl.VectorType<int, Int64List>(
            element: $fidl.Int64Type(), maybeElementCount: null),
        offset: 112),
    $fidl.MemberType<Float32List>(
        type: $fidl.VectorType<double, Float32List>(
            element: $fidl.Float32Type(), maybeElementCount: null),
        offset: 128),
    $fidl.MemberType<Float64List>(
        type: $fidl.VectorType<double, Float64List>(
            element: $fidl.Float64Type(), maybeElementCount: null),
        offset: 144),
    $fidl.MemberType<List<String>>(
        type: $fidl.VectorType<String, List<String>>(
            element: $fidl.StringType(maybeElementCount: null),
            maybeElementCount: null),
        offset: 160),
    $fidl.MemberType<List<String?>>(
        type: $fidl.VectorType<String?, List<String?>>(
            element: $fidl.NullableStringType(maybeElementCount: null),
            maybeElementCount: null),
        offset: 176),
  ],
  name: r"Protocol.EventVectorBasic",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 192,
);
// oneWayVectorCompound: (List<Bits> vectorBits, List<Enum> vectorEnum, List<Struct> vectorStruct, List<Table> vectorTable, List<Union> vectorUnion, List<Struct?> vectorOptStruct, List<Union?> vectorOptUnion)
const int _kProtocol_OneWayVectorCompound_Ordinal = 0x19baae42829dbe90;
const $fidl.MethodType _kProtocol_OneWayVectorCompound_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<List<Bits>>(
        type: $fidl.VectorType<Bits, List<Bits>>(
            element: kBits_Type, maybeElementCount: null),
        offset: 0),
    $fidl.MemberType<List<Enum>>(
        type: $fidl.VectorType<Enum, List<Enum>>(
            element: kEnum_Type, maybeElementCount: null),
        offset: 16),
    $fidl.MemberType<List<Struct>>(
        type: $fidl.VectorType<Struct, List<Struct>>(
            element: kStruct_Type, maybeElementCount: null),
        offset: 32),
    $fidl.MemberType<List<Table>>(
        type: $fidl.VectorType<Table, List<Table>>(
            element: kTable_Type, maybeElementCount: null),
        offset: 48),
    $fidl.MemberType<List<Union>>(
        type: $fidl.VectorType<Union, List<Union>>(
            element: kUnion_Type, maybeElementCount: null),
        offset: 64),
    $fidl.MemberType<List<Struct?>>(
        type: $fidl.VectorType<Struct?, List<Struct?>>(
            element: $fidl.PointerType<Struct>(element: kStruct_Type),
            maybeElementCount: null),
        offset: 80),
    $fidl.MemberType<List<Union?>>(
        type: $fidl.VectorType<Union?, List<Union?>>(
            element: kUnion_OptType, maybeElementCount: null),
        offset: 96),
  ],
  response: [],
  name: r"Protocol.OneWayVectorCompound",
  requestInlineSizeV2: 112,
  responseInlineSizeV2: 0,
);
// twoWayVectorCompound: (List<Bits> vectorBits, List<Enum> vectorEnum, List<Struct> vectorStruct, List<Table> vectorTable, List<Union> vectorUnion, List<Struct?> vectorOptStruct, List<Union?> vectorOptUnion) -> (List<Bits> vectorBits, List<Enum> vectorEnum, List<Struct> vectorStruct, List<Table> vectorTable, List<Union> vectorUnion, List<Struct?> vectorOptStruct, List<Union?> vectorOptUnion)
const int _kProtocol_TwoWayVectorCompound_Ordinal = 0x371140db701b23b4;
const $fidl.MethodType _kProtocol_TwoWayVectorCompound_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<List<Bits>>(
        type: $fidl.VectorType<Bits, List<Bits>>(
            element: kBits_Type, maybeElementCount: null),
        offset: 0),
    $fidl.MemberType<List<Enum>>(
        type: $fidl.VectorType<Enum, List<Enum>>(
            element: kEnum_Type, maybeElementCount: null),
        offset: 16),
    $fidl.MemberType<List<Struct>>(
        type: $fidl.VectorType<Struct, List<Struct>>(
            element: kStruct_Type, maybeElementCount: null),
        offset: 32),
    $fidl.MemberType<List<Table>>(
        type: $fidl.VectorType<Table, List<Table>>(
            element: kTable_Type, maybeElementCount: null),
        offset: 48),
    $fidl.MemberType<List<Union>>(
        type: $fidl.VectorType<Union, List<Union>>(
            element: kUnion_Type, maybeElementCount: null),
        offset: 64),
    $fidl.MemberType<List<Struct?>>(
        type: $fidl.VectorType<Struct?, List<Struct?>>(
            element: $fidl.PointerType<Struct>(element: kStruct_Type),
            maybeElementCount: null),
        offset: 80),
    $fidl.MemberType<List<Union?>>(
        type: $fidl.VectorType<Union?, List<Union?>>(
            element: kUnion_OptType, maybeElementCount: null),
        offset: 96),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<List<Bits>>(
        type: $fidl.VectorType<Bits, List<Bits>>(
            element: kBits_Type, maybeElementCount: null),
        offset: 0),
    $fidl.MemberType<List<Enum>>(
        type: $fidl.VectorType<Enum, List<Enum>>(
            element: kEnum_Type, maybeElementCount: null),
        offset: 16),
    $fidl.MemberType<List<Struct>>(
        type: $fidl.VectorType<Struct, List<Struct>>(
            element: kStruct_Type, maybeElementCount: null),
        offset: 32),
    $fidl.MemberType<List<Table>>(
        type: $fidl.VectorType<Table, List<Table>>(
            element: kTable_Type, maybeElementCount: null),
        offset: 48),
    $fidl.MemberType<List<Union>>(
        type: $fidl.VectorType<Union, List<Union>>(
            element: kUnion_Type, maybeElementCount: null),
        offset: 64),
    $fidl.MemberType<List<Struct?>>(
        type: $fidl.VectorType<Struct?, List<Struct?>>(
            element: $fidl.PointerType<Struct>(element: kStruct_Type),
            maybeElementCount: null),
        offset: 80),
    $fidl.MemberType<List<Union?>>(
        type: $fidl.VectorType<Union?, List<Union?>>(
            element: kUnion_OptType, maybeElementCount: null),
        offset: 96),
  ],
  name: r"Protocol.TwoWayVectorCompound",
  requestInlineSizeV2: 112,
  responseInlineSizeV2: 112,
);
// errorVectorCompound: () -> (List<Bits> vectorBits, List<Enum> vectorEnum, List<Struct> vectorStruct, List<Table> vectorTable, List<Union> vectorUnion, List<Struct?> vectorOptStruct, List<Union?> vectorOptUnion)
const int _kProtocol_ErrorVectorCompound_Ordinal = 0x760e278628f7a985;
const $fidl.MethodType _kProtocol_ErrorVectorCompound_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ProtocolErrorVectorCompoundResult>(
        type: kProtocol_ErrorVectorCompound_Result_Type, offset: 0),
  ],
  name: r"Protocol.ErrorVectorCompound",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// eventVectorCompound:  -> (List<Bits> vectorBits, List<Enum> vectorEnum, List<Struct> vectorStruct, List<Table> vectorTable, List<Union> vectorUnion, List<Struct?> vectorOptStruct, List<Union?> vectorOptUnion)
const int _kProtocol_EventVectorCompound_Ordinal = 0x53a1fc56e8b3cff3;
const $fidl.MethodType _kProtocol_EventVectorCompound_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<List<Bits>>(
        type: $fidl.VectorType<Bits, List<Bits>>(
            element: kBits_Type, maybeElementCount: null),
        offset: 0),
    $fidl.MemberType<List<Enum>>(
        type: $fidl.VectorType<Enum, List<Enum>>(
            element: kEnum_Type, maybeElementCount: null),
        offset: 16),
    $fidl.MemberType<List<Struct>>(
        type: $fidl.VectorType<Struct, List<Struct>>(
            element: kStruct_Type, maybeElementCount: null),
        offset: 32),
    $fidl.MemberType<List<Table>>(
        type: $fidl.VectorType<Table, List<Table>>(
            element: kTable_Type, maybeElementCount: null),
        offset: 48),
    $fidl.MemberType<List<Union>>(
        type: $fidl.VectorType<Union, List<Union>>(
            element: kUnion_Type, maybeElementCount: null),
        offset: 64),
    $fidl.MemberType<List<Struct?>>(
        type: $fidl.VectorType<Struct?, List<Struct?>>(
            element: $fidl.PointerType<Struct>(element: kStruct_Type),
            maybeElementCount: null),
        offset: 80),
    $fidl.MemberType<List<Union?>>(
        type: $fidl.VectorType<Union?, List<Union?>>(
            element: kUnion_OptType, maybeElementCount: null),
        offset: 96),
  ],
  name: r"Protocol.EventVectorCompound",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 112,
);
// oneWayVectorOptional: (Uint8List? optVectorUint8, List<String>? optVectorString, List<Struct>? optVectorStruct, List<Struct?>? optVectorOptStruct)
const int _kProtocol_OneWayVectorOptional_Ordinal = 0x153c6b333c21c52f;
const $fidl.MethodType _kProtocol_OneWayVectorOptional_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<Uint8List?>(
        type: $fidl.NullableVectorType<int, Uint8List>(
            element: $fidl.Uint8Type(), maybeElementCount: null),
        offset: 0),
    $fidl.MemberType<List<String>?>(
        type: $fidl.NullableVectorType<String, List<String>>(
            element: $fidl.StringType(maybeElementCount: null),
            maybeElementCount: null),
        offset: 16),
    $fidl.MemberType<List<Struct>?>(
        type: $fidl.NullableVectorType<Struct, List<Struct>>(
            element: kStruct_Type, maybeElementCount: null),
        offset: 32),
    $fidl.MemberType<List<Struct?>?>(
        type: $fidl.NullableVectorType<Struct?, List<Struct?>>(
            element: $fidl.PointerType<Struct>(element: kStruct_Type),
            maybeElementCount: null),
        offset: 48),
  ],
  response: [],
  name: r"Protocol.OneWayVectorOptional",
  requestInlineSizeV2: 64,
  responseInlineSizeV2: 0,
);
// twoWayVectorOptional: (Uint8List? optVectorUint8, List<String>? optVectorString, List<Struct>? optVectorStruct, List<Struct?>? optVectorOptStruct) -> (Uint8List? optVectorUint8, List<String>? optVectorString, List<Struct>? optVectorStruct, List<Struct?>? optVectorOptStruct)
const int _kProtocol_TwoWayVectorOptional_Ordinal = 0xe4b620aaafd73f3;
const $fidl.MethodType _kProtocol_TwoWayVectorOptional_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<Uint8List?>(
        type: $fidl.NullableVectorType<int, Uint8List>(
            element: $fidl.Uint8Type(), maybeElementCount: null),
        offset: 0),
    $fidl.MemberType<List<String>?>(
        type: $fidl.NullableVectorType<String, List<String>>(
            element: $fidl.StringType(maybeElementCount: null),
            maybeElementCount: null),
        offset: 16),
    $fidl.MemberType<List<Struct>?>(
        type: $fidl.NullableVectorType<Struct, List<Struct>>(
            element: kStruct_Type, maybeElementCount: null),
        offset: 32),
    $fidl.MemberType<List<Struct?>?>(
        type: $fidl.NullableVectorType<Struct?, List<Struct?>>(
            element: $fidl.PointerType<Struct>(element: kStruct_Type),
            maybeElementCount: null),
        offset: 48),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<Uint8List?>(
        type: $fidl.NullableVectorType<int, Uint8List>(
            element: $fidl.Uint8Type(), maybeElementCount: null),
        offset: 0),
    $fidl.MemberType<List<String>?>(
        type: $fidl.NullableVectorType<String, List<String>>(
            element: $fidl.StringType(maybeElementCount: null),
            maybeElementCount: null),
        offset: 16),
    $fidl.MemberType<List<Struct>?>(
        type: $fidl.NullableVectorType<Struct, List<Struct>>(
            element: kStruct_Type, maybeElementCount: null),
        offset: 32),
    $fidl.MemberType<List<Struct?>?>(
        type: $fidl.NullableVectorType<Struct?, List<Struct?>>(
            element: $fidl.PointerType<Struct>(element: kStruct_Type),
            maybeElementCount: null),
        offset: 48),
  ],
  name: r"Protocol.TwoWayVectorOptional",
  requestInlineSizeV2: 64,
  responseInlineSizeV2: 64,
);
// errorVectorOptional: () -> (Uint8List? optVectorUint8, List<String>? optVectorString, List<Struct>? optVectorStruct, List<Struct?>? optVectorOptStruct)
const int _kProtocol_ErrorVectorOptional_Ordinal = 0x58e75cf86e2d715e;
const $fidl.MethodType _kProtocol_ErrorVectorOptional_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ProtocolErrorVectorOptionalResult>(
        type: kProtocol_ErrorVectorOptional_Result_Type, offset: 0),
  ],
  name: r"Protocol.ErrorVectorOptional",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// eventVectorOptional:  -> (Uint8List? optVectorUint8, List<String>? optVectorString, List<Struct>? optVectorStruct, List<Struct?>? optVectorOptStruct)
const int _kProtocol_EventVectorOptional_Ordinal = 0x17617b54dfa8d85d;
const $fidl.MethodType _kProtocol_EventVectorOptional_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<Uint8List?>(
        type: $fidl.NullableVectorType<int, Uint8List>(
            element: $fidl.Uint8Type(), maybeElementCount: null),
        offset: 0),
    $fidl.MemberType<List<String>?>(
        type: $fidl.NullableVectorType<String, List<String>>(
            element: $fidl.StringType(maybeElementCount: null),
            maybeElementCount: null),
        offset: 16),
    $fidl.MemberType<List<Struct>?>(
        type: $fidl.NullableVectorType<Struct, List<Struct>>(
            element: kStruct_Type, maybeElementCount: null),
        offset: 32),
    $fidl.MemberType<List<Struct?>?>(
        type: $fidl.NullableVectorType<Struct?, List<Struct?>>(
            element: $fidl.PointerType<Struct>(element: kStruct_Type),
            maybeElementCount: null),
        offset: 48),
  ],
  name: r"Protocol.EventVectorOptional",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 64,
);
// oneWayArrayVectorNested: (List<Uint8List> arrayArrayUint8, List<Uint8List> arrayVectorUint8, List<Uint8List> vectorArrayUint8, List<Uint8List> vectorVectorUint8)
const int _kProtocol_OneWayArrayVectorNested_Ordinal = 0x520dc9cb9b9b5ed7;
const $fidl.MethodType _kProtocol_OneWayArrayVectorNested_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.ArrayType<Uint8List, List<Uint8List>>(
            element: $fidl.ArrayType<int, Uint8List>(
                element: $fidl.Uint8Type(), elementCount: 5),
            elementCount: 5),
        offset: 0),
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.ArrayType<Uint8List, List<Uint8List>>(
            element: $fidl.VectorType<int, Uint8List>(
                element: $fidl.Uint8Type(), maybeElementCount: null),
            elementCount: 5),
        offset: 32),
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.VectorType<Uint8List, List<Uint8List>>(
            element: $fidl.ArrayType<int, Uint8List>(
                element: $fidl.Uint8Type(), elementCount: 5),
            maybeElementCount: null),
        offset: 112),
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.VectorType<Uint8List, List<Uint8List>>(
            element: $fidl.VectorType<int, Uint8List>(
                element: $fidl.Uint8Type(), maybeElementCount: null),
            maybeElementCount: null),
        offset: 128),
  ],
  response: [],
  name: r"Protocol.OneWayArrayVectorNested",
  requestInlineSizeV2: 144,
  responseInlineSizeV2: 0,
);
// twoWayArrayVectorNested: (List<Uint8List> arrayArrayUint8, List<Uint8List> arrayVectorUint8, List<Uint8List> vectorArrayUint8, List<Uint8List> vectorVectorUint8) -> (List<Uint8List> arrayArrayUint8, List<Uint8List> arrayVectorUint8, List<Uint8List> vectorArrayUint8, List<Uint8List> vectorVectorUint8)
const int _kProtocol_TwoWayArrayVectorNested_Ordinal = 0x4a438ce0948817dc;
const $fidl.MethodType _kProtocol_TwoWayArrayVectorNested_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.ArrayType<Uint8List, List<Uint8List>>(
            element: $fidl.ArrayType<int, Uint8List>(
                element: $fidl.Uint8Type(), elementCount: 5),
            elementCount: 5),
        offset: 0),
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.ArrayType<Uint8List, List<Uint8List>>(
            element: $fidl.VectorType<int, Uint8List>(
                element: $fidl.Uint8Type(), maybeElementCount: null),
            elementCount: 5),
        offset: 32),
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.VectorType<Uint8List, List<Uint8List>>(
            element: $fidl.ArrayType<int, Uint8List>(
                element: $fidl.Uint8Type(), elementCount: 5),
            maybeElementCount: null),
        offset: 112),
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.VectorType<Uint8List, List<Uint8List>>(
            element: $fidl.VectorType<int, Uint8List>(
                element: $fidl.Uint8Type(), maybeElementCount: null),
            maybeElementCount: null),
        offset: 128),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.ArrayType<Uint8List, List<Uint8List>>(
            element: $fidl.ArrayType<int, Uint8List>(
                element: $fidl.Uint8Type(), elementCount: 5),
            elementCount: 5),
        offset: 0),
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.ArrayType<Uint8List, List<Uint8List>>(
            element: $fidl.VectorType<int, Uint8List>(
                element: $fidl.Uint8Type(), maybeElementCount: null),
            elementCount: 5),
        offset: 32),
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.VectorType<Uint8List, List<Uint8List>>(
            element: $fidl.ArrayType<int, Uint8List>(
                element: $fidl.Uint8Type(), elementCount: 5),
            maybeElementCount: null),
        offset: 112),
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.VectorType<Uint8List, List<Uint8List>>(
            element: $fidl.VectorType<int, Uint8List>(
                element: $fidl.Uint8Type(), maybeElementCount: null),
            maybeElementCount: null),
        offset: 128),
  ],
  name: r"Protocol.TwoWayArrayVectorNested",
  requestInlineSizeV2: 144,
  responseInlineSizeV2: 144,
);
// errorArrayVectorNested: () -> (List<Uint8List> arrayArrayUint8, List<Uint8List> arrayVectorUint8, List<Uint8List> vectorArrayUint8, List<Uint8List> vectorVectorUint8)
const int _kProtocol_ErrorArrayVectorNested_Ordinal = 0x7e168d89e1dac8a7;
const $fidl.MethodType _kProtocol_ErrorArrayVectorNested_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ProtocolErrorArrayVectorNestedResult>(
        type: kProtocol_ErrorArrayVectorNested_Result_Type, offset: 0),
  ],
  name: r"Protocol.ErrorArrayVectorNested",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// eventArrayVectorNested:  -> (List<Uint8List> arrayArrayUint8, List<Uint8List> arrayVectorUint8, List<Uint8List> vectorArrayUint8, List<Uint8List> vectorVectorUint8)
const int _kProtocol_EventArrayVectorNested_Ordinal = 0x110b72cfebc4037e;
const $fidl.MethodType _kProtocol_EventArrayVectorNested_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.ArrayType<Uint8List, List<Uint8List>>(
            element: $fidl.ArrayType<int, Uint8List>(
                element: $fidl.Uint8Type(), elementCount: 5),
            elementCount: 5),
        offset: 0),
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.ArrayType<Uint8List, List<Uint8List>>(
            element: $fidl.VectorType<int, Uint8List>(
                element: $fidl.Uint8Type(), maybeElementCount: null),
            elementCount: 5),
        offset: 32),
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.VectorType<Uint8List, List<Uint8List>>(
            element: $fidl.ArrayType<int, Uint8List>(
                element: $fidl.Uint8Type(), elementCount: 5),
            maybeElementCount: null),
        offset: 112),
    $fidl.MemberType<List<Uint8List>>(
        type: $fidl.VectorType<Uint8List, List<Uint8List>>(
            element: $fidl.VectorType<int, Uint8List>(
                element: $fidl.Uint8Type(), maybeElementCount: null),
            maybeElementCount: null),
        offset: 128),
  ],
  name: r"Protocol.EventArrayVectorNested",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 144,
);
// oneWayResource: ($zircon.Handle handle, $zircon.Vmo vmo, $fidl.InterfaceHandle<Protocol> clientEnd, $fidl.InterfaceRequest<Protocol> serverEnd, ResourceStruct struct, ResourceTable table, ResourceUnion union, $zircon.Handle? optHandle, $zircon.Vmo? optVmo, $fidl.InterfaceHandle<Protocol>? optClientEnd, $fidl.InterfaceRequest<Protocol>? optServerEnd, ResourceStruct? optStruct, ResourceUnion? optUnion, List<$zircon.Handle> arrayHandle, List<$zircon.Vmo> arrayVmo, List<$fidl.InterfaceHandle<Protocol>> arrayClientEnd, List<$fidl.InterfaceRequest<Protocol>> arrayServerEnd, List<ResourceStruct> arrayStruct, List<ResourceTable> arrayTable, List<ResourceUnion> arrayUnion, List<$zircon.Handle> vectorHandle, List<$zircon.Vmo> vectorVmo, List<$fidl.InterfaceHandle<Protocol>> vectorClientEnd, List<$fidl.InterfaceRequest<Protocol>> vectorServerEnd, List<ResourceStruct> vectorStruct, List<ResourceTable> vectorTable, List<ResourceUnion> vectorUnion)
const int _kProtocol_OneWayResource_Ordinal = 0x5af4795a9ed3a022;
const $fidl.MethodType _kProtocol_OneWayResource_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<$zircon.Handle>(
        type: $fidl.HandleType(objectType: 0, rights: 2147483648), offset: 0),
    $fidl.MemberType<$zircon.Vmo>(
        type: $fidl.VmoType(objectType: 3, rights: 2147483648), offset: 4),
    $fidl.MemberType<$fidl.InterfaceHandle<Protocol>>(
        type: $fidl.InterfaceHandleType<Protocol>(), offset: 8),
    $fidl.MemberType<$fidl.InterfaceRequest<Protocol>>(
        type: $fidl.InterfaceRequestType<Protocol>(), offset: 12),
    $fidl.MemberType<ResourceStruct>(type: kResourceStruct_Type, offset: 16),
    $fidl.MemberType<ResourceTable>(type: kResourceTable_Type, offset: 24),
    $fidl.MemberType<ResourceUnion>(type: kResourceUnion_Type, offset: 40),
    $fidl.MemberType<$zircon.Handle?>(
        type: $fidl.NullableHandleType(
            $fidl.HandleType(objectType: 0, rights: 2147483648)),
        offset: 56),
    $fidl.MemberType<$zircon.Vmo?>(
        type: $fidl.NullableHandleType(
            $fidl.VmoType(objectType: 3, rights: 2147483648)),
        offset: 60),
    $fidl.MemberType<$fidl.InterfaceHandle<Protocol>?>(
        type: $fidl.NullableInterfaceHandleType<Protocol>(), offset: 64),
    $fidl.MemberType<$fidl.InterfaceRequest<Protocol>?>(
        type: $fidl.NullableInterfaceRequestType<Protocol>(), offset: 68),
    $fidl.MemberType<ResourceStruct?>(
        type: $fidl.PointerType<ResourceStruct>(element: kResourceStruct_Type),
        offset: 72),
    $fidl.MemberType<ResourceUnion?>(type: kResourceUnion_OptType, offset: 80),
    $fidl.MemberType<List<$zircon.Handle>>(
        type: $fidl.ArrayType<$zircon.Handle, List<$zircon.Handle>>(
            element: $fidl.HandleType(objectType: 0, rights: 2147483648),
            elementCount: 5),
        offset: 96),
    $fidl.MemberType<List<$zircon.Vmo>>(
        type: $fidl.ArrayType<$zircon.Vmo, List<$zircon.Vmo>>(
            element: $fidl.VmoType(objectType: 3, rights: 2147483648),
            elementCount: 5),
        offset: 116),
    $fidl.MemberType<List<$fidl.InterfaceHandle<Protocol>>>(
        type: $fidl.ArrayType<$fidl.InterfaceHandle<Protocol>,
                List<$fidl.InterfaceHandle<Protocol>>>(
            element: $fidl.InterfaceHandleType<Protocol>(), elementCount: 5),
        offset: 136),
    $fidl.MemberType<List<$fidl.InterfaceRequest<Protocol>>>(
        type: $fidl.ArrayType<$fidl.InterfaceRequest<Protocol>,
                List<$fidl.InterfaceRequest<Protocol>>>(
            element: $fidl.InterfaceRequestType<Protocol>(), elementCount: 5),
        offset: 156),
    $fidl.MemberType<List<ResourceStruct>>(
        type: $fidl.ArrayType<ResourceStruct, List<ResourceStruct>>(
            element: kResourceStruct_Type, elementCount: 5),
        offset: 176),
    $fidl.MemberType<List<ResourceTable>>(
        type: $fidl.ArrayType<ResourceTable, List<ResourceTable>>(
            element: kResourceTable_Type, elementCount: 5),
        offset: 184),
    $fidl.MemberType<List<ResourceUnion>>(
        type: $fidl.ArrayType<ResourceUnion, List<ResourceUnion>>(
            element: kResourceUnion_Type, elementCount: 5),
        offset: 264),
    $fidl.MemberType<List<$zircon.Handle>>(
        type: $fidl.VectorType<$zircon.Handle, List<$zircon.Handle>>(
            element: $fidl.HandleType(objectType: 0, rights: 2147483648),
            maybeElementCount: null),
        offset: 344),
    $fidl.MemberType<List<$zircon.Vmo>>(
        type: $fidl.VectorType<$zircon.Vmo, List<$zircon.Vmo>>(
            element: $fidl.VmoType(objectType: 3, rights: 2147483648),
            maybeElementCount: null),
        offset: 360),
    $fidl.MemberType<List<$fidl.InterfaceHandle<Protocol>>>(
        type: $fidl.VectorType<$fidl.InterfaceHandle<Protocol>,
                List<$fidl.InterfaceHandle<Protocol>>>(
            element: $fidl.InterfaceHandleType<Protocol>(),
            maybeElementCount: null),
        offset: 376),
    $fidl.MemberType<List<$fidl.InterfaceRequest<Protocol>>>(
        type: $fidl.VectorType<$fidl.InterfaceRequest<Protocol>,
                List<$fidl.InterfaceRequest<Protocol>>>(
            element: $fidl.InterfaceRequestType<Protocol>(),
            maybeElementCount: null),
        offset: 392),
    $fidl.MemberType<List<ResourceStruct>>(
        type: $fidl.VectorType<ResourceStruct, List<ResourceStruct>>(
            element: kResourceStruct_Type, maybeElementCount: null),
        offset: 408),
    $fidl.MemberType<List<ResourceTable>>(
        type: $fidl.VectorType<ResourceTable, List<ResourceTable>>(
            element: kResourceTable_Type, maybeElementCount: null),
        offset: 424),
    $fidl.MemberType<List<ResourceUnion>>(
        type: $fidl.VectorType<ResourceUnion, List<ResourceUnion>>(
            element: kResourceUnion_Type, maybeElementCount: null),
        offset: 440),
  ],
  response: [],
  name: r"Protocol.OneWayResource",
  requestInlineSizeV2: 456,
  responseInlineSizeV2: 0,
);
// twoWayResource: ($zircon.Handle handle, $zircon.Vmo vmo, $fidl.InterfaceHandle<Protocol> clientEnd, $fidl.InterfaceRequest<Protocol> serverEnd, ResourceStruct struct, ResourceTable table, ResourceUnion union, $zircon.Handle? optHandle, $zircon.Vmo? optVmo, $fidl.InterfaceHandle<Protocol>? optClientEnd, $fidl.InterfaceRequest<Protocol>? optServerEnd, ResourceStruct? optStruct, ResourceUnion? optUnion, List<$zircon.Handle> arrayHandle, List<$zircon.Vmo> arrayVmo, List<$fidl.InterfaceHandle<Protocol>> arrayClientEnd, List<$fidl.InterfaceRequest<Protocol>> arrayServerEnd, List<ResourceStruct> arrayStruct, List<ResourceTable> arrayTable, List<ResourceUnion> arrayUnion, List<$zircon.Handle> vectorHandle, List<$zircon.Vmo> vectorVmo, List<$fidl.InterfaceHandle<Protocol>> vectorClientEnd, List<$fidl.InterfaceRequest<Protocol>> vectorServerEnd, List<ResourceStruct> vectorStruct, List<ResourceTable> vectorTable, List<ResourceUnion> vectorUnion) -> ($zircon.Handle handle, $zircon.Vmo vmo, $fidl.InterfaceHandle<Protocol> clientEnd, $fidl.InterfaceRequest<Protocol> serverEnd, ResourceStruct struct, ResourceTable table, ResourceUnion union, $zircon.Handle? optHandle, $zircon.Vmo? optVmo, $fidl.InterfaceHandle<Protocol>? optClientEnd, $fidl.InterfaceRequest<Protocol>? optServerEnd, ResourceStruct? optStruct, ResourceUnion? optUnion, List<$zircon.Handle> arrayHandle, List<$zircon.Vmo> arrayVmo, List<$fidl.InterfaceHandle<Protocol>> arrayClientEnd, List<$fidl.InterfaceRequest<Protocol>> arrayServerEnd, List<ResourceStruct> arrayStruct, List<ResourceTable> arrayTable, List<ResourceUnion> arrayUnion, List<$zircon.Handle> vectorHandle, List<$zircon.Vmo> vectorVmo, List<$fidl.InterfaceHandle<Protocol>> vectorClientEnd, List<$fidl.InterfaceRequest<Protocol>> vectorServerEnd, List<ResourceStruct> vectorStruct, List<ResourceTable> vectorTable, List<ResourceUnion> vectorUnion)
const int _kProtocol_TwoWayResource_Ordinal = 0x1904824a11c6ad5b;
const $fidl.MethodType _kProtocol_TwoWayResource_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<$zircon.Handle>(
        type: $fidl.HandleType(objectType: 0, rights: 2147483648), offset: 0),
    $fidl.MemberType<$zircon.Vmo>(
        type: $fidl.VmoType(objectType: 3, rights: 2147483648), offset: 4),
    $fidl.MemberType<$fidl.InterfaceHandle<Protocol>>(
        type: $fidl.InterfaceHandleType<Protocol>(), offset: 8),
    $fidl.MemberType<$fidl.InterfaceRequest<Protocol>>(
        type: $fidl.InterfaceRequestType<Protocol>(), offset: 12),
    $fidl.MemberType<ResourceStruct>(type: kResourceStruct_Type, offset: 16),
    $fidl.MemberType<ResourceTable>(type: kResourceTable_Type, offset: 24),
    $fidl.MemberType<ResourceUnion>(type: kResourceUnion_Type, offset: 40),
    $fidl.MemberType<$zircon.Handle?>(
        type: $fidl.NullableHandleType(
            $fidl.HandleType(objectType: 0, rights: 2147483648)),
        offset: 56),
    $fidl.MemberType<$zircon.Vmo?>(
        type: $fidl.NullableHandleType(
            $fidl.VmoType(objectType: 3, rights: 2147483648)),
        offset: 60),
    $fidl.MemberType<$fidl.InterfaceHandle<Protocol>?>(
        type: $fidl.NullableInterfaceHandleType<Protocol>(), offset: 64),
    $fidl.MemberType<$fidl.InterfaceRequest<Protocol>?>(
        type: $fidl.NullableInterfaceRequestType<Protocol>(), offset: 68),
    $fidl.MemberType<ResourceStruct?>(
        type: $fidl.PointerType<ResourceStruct>(element: kResourceStruct_Type),
        offset: 72),
    $fidl.MemberType<ResourceUnion?>(type: kResourceUnion_OptType, offset: 80),
    $fidl.MemberType<List<$zircon.Handle>>(
        type: $fidl.ArrayType<$zircon.Handle, List<$zircon.Handle>>(
            element: $fidl.HandleType(objectType: 0, rights: 2147483648),
            elementCount: 5),
        offset: 96),
    $fidl.MemberType<List<$zircon.Vmo>>(
        type: $fidl.ArrayType<$zircon.Vmo, List<$zircon.Vmo>>(
            element: $fidl.VmoType(objectType: 3, rights: 2147483648),
            elementCount: 5),
        offset: 116),
    $fidl.MemberType<List<$fidl.InterfaceHandle<Protocol>>>(
        type: $fidl.ArrayType<$fidl.InterfaceHandle<Protocol>,
                List<$fidl.InterfaceHandle<Protocol>>>(
            element: $fidl.InterfaceHandleType<Protocol>(), elementCount: 5),
        offset: 136),
    $fidl.MemberType<List<$fidl.InterfaceRequest<Protocol>>>(
        type: $fidl.ArrayType<$fidl.InterfaceRequest<Protocol>,
                List<$fidl.InterfaceRequest<Protocol>>>(
            element: $fidl.InterfaceRequestType<Protocol>(), elementCount: 5),
        offset: 156),
    $fidl.MemberType<List<ResourceStruct>>(
        type: $fidl.ArrayType<ResourceStruct, List<ResourceStruct>>(
            element: kResourceStruct_Type, elementCount: 5),
        offset: 176),
    $fidl.MemberType<List<ResourceTable>>(
        type: $fidl.ArrayType<ResourceTable, List<ResourceTable>>(
            element: kResourceTable_Type, elementCount: 5),
        offset: 184),
    $fidl.MemberType<List<ResourceUnion>>(
        type: $fidl.ArrayType<ResourceUnion, List<ResourceUnion>>(
            element: kResourceUnion_Type, elementCount: 5),
        offset: 264),
    $fidl.MemberType<List<$zircon.Handle>>(
        type: $fidl.VectorType<$zircon.Handle, List<$zircon.Handle>>(
            element: $fidl.HandleType(objectType: 0, rights: 2147483648),
            maybeElementCount: null),
        offset: 344),
    $fidl.MemberType<List<$zircon.Vmo>>(
        type: $fidl.VectorType<$zircon.Vmo, List<$zircon.Vmo>>(
            element: $fidl.VmoType(objectType: 3, rights: 2147483648),
            maybeElementCount: null),
        offset: 360),
    $fidl.MemberType<List<$fidl.InterfaceHandle<Protocol>>>(
        type: $fidl.VectorType<$fidl.InterfaceHandle<Protocol>,
                List<$fidl.InterfaceHandle<Protocol>>>(
            element: $fidl.InterfaceHandleType<Protocol>(),
            maybeElementCount: null),
        offset: 376),
    $fidl.MemberType<List<$fidl.InterfaceRequest<Protocol>>>(
        type: $fidl.VectorType<$fidl.InterfaceRequest<Protocol>,
                List<$fidl.InterfaceRequest<Protocol>>>(
            element: $fidl.InterfaceRequestType<Protocol>(),
            maybeElementCount: null),
        offset: 392),
    $fidl.MemberType<List<ResourceStruct>>(
        type: $fidl.VectorType<ResourceStruct, List<ResourceStruct>>(
            element: kResourceStruct_Type, maybeElementCount: null),
        offset: 408),
    $fidl.MemberType<List<ResourceTable>>(
        type: $fidl.VectorType<ResourceTable, List<ResourceTable>>(
            element: kResourceTable_Type, maybeElementCount: null),
        offset: 424),
    $fidl.MemberType<List<ResourceUnion>>(
        type: $fidl.VectorType<ResourceUnion, List<ResourceUnion>>(
            element: kResourceUnion_Type, maybeElementCount: null),
        offset: 440),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<$zircon.Handle>(
        type: $fidl.HandleType(objectType: 0, rights: 2147483648), offset: 0),
    $fidl.MemberType<$zircon.Vmo>(
        type: $fidl.VmoType(objectType: 3, rights: 2147483648), offset: 4),
    $fidl.MemberType<$fidl.InterfaceHandle<Protocol>>(
        type: $fidl.InterfaceHandleType<Protocol>(), offset: 8),
    $fidl.MemberType<$fidl.InterfaceRequest<Protocol>>(
        type: $fidl.InterfaceRequestType<Protocol>(), offset: 12),
    $fidl.MemberType<ResourceStruct>(type: kResourceStruct_Type, offset: 16),
    $fidl.MemberType<ResourceTable>(type: kResourceTable_Type, offset: 24),
    $fidl.MemberType<ResourceUnion>(type: kResourceUnion_Type, offset: 40),
    $fidl.MemberType<$zircon.Handle?>(
        type: $fidl.NullableHandleType(
            $fidl.HandleType(objectType: 0, rights: 2147483648)),
        offset: 56),
    $fidl.MemberType<$zircon.Vmo?>(
        type: $fidl.NullableHandleType(
            $fidl.VmoType(objectType: 3, rights: 2147483648)),
        offset: 60),
    $fidl.MemberType<$fidl.InterfaceHandle<Protocol>?>(
        type: $fidl.NullableInterfaceHandleType<Protocol>(), offset: 64),
    $fidl.MemberType<$fidl.InterfaceRequest<Protocol>?>(
        type: $fidl.NullableInterfaceRequestType<Protocol>(), offset: 68),
    $fidl.MemberType<ResourceStruct?>(
        type: $fidl.PointerType<ResourceStruct>(element: kResourceStruct_Type),
        offset: 72),
    $fidl.MemberType<ResourceUnion?>(type: kResourceUnion_OptType, offset: 80),
    $fidl.MemberType<List<$zircon.Handle>>(
        type: $fidl.ArrayType<$zircon.Handle, List<$zircon.Handle>>(
            element: $fidl.HandleType(objectType: 0, rights: 2147483648),
            elementCount: 5),
        offset: 96),
    $fidl.MemberType<List<$zircon.Vmo>>(
        type: $fidl.ArrayType<$zircon.Vmo, List<$zircon.Vmo>>(
            element: $fidl.VmoType(objectType: 3, rights: 2147483648),
            elementCount: 5),
        offset: 116),
    $fidl.MemberType<List<$fidl.InterfaceHandle<Protocol>>>(
        type: $fidl.ArrayType<$fidl.InterfaceHandle<Protocol>,
                List<$fidl.InterfaceHandle<Protocol>>>(
            element: $fidl.InterfaceHandleType<Protocol>(), elementCount: 5),
        offset: 136),
    $fidl.MemberType<List<$fidl.InterfaceRequest<Protocol>>>(
        type: $fidl.ArrayType<$fidl.InterfaceRequest<Protocol>,
                List<$fidl.InterfaceRequest<Protocol>>>(
            element: $fidl.InterfaceRequestType<Protocol>(), elementCount: 5),
        offset: 156),
    $fidl.MemberType<List<ResourceStruct>>(
        type: $fidl.ArrayType<ResourceStruct, List<ResourceStruct>>(
            element: kResourceStruct_Type, elementCount: 5),
        offset: 176),
    $fidl.MemberType<List<ResourceTable>>(
        type: $fidl.ArrayType<ResourceTable, List<ResourceTable>>(
            element: kResourceTable_Type, elementCount: 5),
        offset: 184),
    $fidl.MemberType<List<ResourceUnion>>(
        type: $fidl.ArrayType<ResourceUnion, List<ResourceUnion>>(
            element: kResourceUnion_Type, elementCount: 5),
        offset: 264),
    $fidl.MemberType<List<$zircon.Handle>>(
        type: $fidl.VectorType<$zircon.Handle, List<$zircon.Handle>>(
            element: $fidl.HandleType(objectType: 0, rights: 2147483648),
            maybeElementCount: null),
        offset: 344),
    $fidl.MemberType<List<$zircon.Vmo>>(
        type: $fidl.VectorType<$zircon.Vmo, List<$zircon.Vmo>>(
            element: $fidl.VmoType(objectType: 3, rights: 2147483648),
            maybeElementCount: null),
        offset: 360),
    $fidl.MemberType<List<$fidl.InterfaceHandle<Protocol>>>(
        type: $fidl.VectorType<$fidl.InterfaceHandle<Protocol>,
                List<$fidl.InterfaceHandle<Protocol>>>(
            element: $fidl.InterfaceHandleType<Protocol>(),
            maybeElementCount: null),
        offset: 376),
    $fidl.MemberType<List<$fidl.InterfaceRequest<Protocol>>>(
        type: $fidl.VectorType<$fidl.InterfaceRequest<Protocol>,
                List<$fidl.InterfaceRequest<Protocol>>>(
            element: $fidl.InterfaceRequestType<Protocol>(),
            maybeElementCount: null),
        offset: 392),
    $fidl.MemberType<List<ResourceStruct>>(
        type: $fidl.VectorType<ResourceStruct, List<ResourceStruct>>(
            element: kResourceStruct_Type, maybeElementCount: null),
        offset: 408),
    $fidl.MemberType<List<ResourceTable>>(
        type: $fidl.VectorType<ResourceTable, List<ResourceTable>>(
            element: kResourceTable_Type, maybeElementCount: null),
        offset: 424),
    $fidl.MemberType<List<ResourceUnion>>(
        type: $fidl.VectorType<ResourceUnion, List<ResourceUnion>>(
            element: kResourceUnion_Type, maybeElementCount: null),
        offset: 440),
  ],
  name: r"Protocol.TwoWayResource",
  requestInlineSizeV2: 456,
  responseInlineSizeV2: 456,
);
// errorResource: () -> ($zircon.Handle handle, $zircon.Vmo vmo, $fidl.InterfaceHandle<Protocol> clientEnd, $fidl.InterfaceRequest<Protocol> serverEnd, ResourceStruct struct, ResourceTable table, ResourceUnion union, $zircon.Handle? optHandle, $zircon.Vmo? optVmo, $fidl.InterfaceHandle<Protocol>? optClientEnd, $fidl.InterfaceRequest<Protocol>? optServerEnd, ResourceStruct? optStruct, ResourceUnion? optUnion, List<$zircon.Handle> arrayHandle, List<$zircon.Vmo> arrayVmo, List<$fidl.InterfaceHandle<Protocol>> arrayClientEnd, List<$fidl.InterfaceRequest<Protocol>> arrayServerEnd, List<ResourceStruct> arrayStruct, List<ResourceTable> arrayTable, List<ResourceUnion> arrayUnion, List<$zircon.Handle> vectorHandle, List<$zircon.Vmo> vectorVmo, List<$fidl.InterfaceHandle<Protocol>> vectorClientEnd, List<$fidl.InterfaceRequest<Protocol>> vectorServerEnd, List<ResourceStruct> vectorStruct, List<ResourceTable> vectorTable, List<ResourceUnion> vectorUnion)
const int _kProtocol_ErrorResource_Ordinal = 0x5b28634d603175b6;
const $fidl.MethodType _kProtocol_ErrorResource_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ProtocolErrorResourceResult>(
        type: kProtocol_ErrorResource_Result_Type, offset: 0),
  ],
  name: r"Protocol.ErrorResource",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// eventResource:  -> ($zircon.Handle handle, $zircon.Vmo vmo, $fidl.InterfaceHandle<Protocol> clientEnd, $fidl.InterfaceRequest<Protocol> serverEnd, ResourceStruct struct, ResourceTable table, ResourceUnion union, $zircon.Handle? optHandle, $zircon.Vmo? optVmo, $fidl.InterfaceHandle<Protocol>? optClientEnd, $fidl.InterfaceRequest<Protocol>? optServerEnd, ResourceStruct? optStruct, ResourceUnion? optUnion, List<$zircon.Handle> arrayHandle, List<$zircon.Vmo> arrayVmo, List<$fidl.InterfaceHandle<Protocol>> arrayClientEnd, List<$fidl.InterfaceRequest<Protocol>> arrayServerEnd, List<ResourceStruct> arrayStruct, List<ResourceTable> arrayTable, List<ResourceUnion> arrayUnion, List<$zircon.Handle> vectorHandle, List<$zircon.Vmo> vectorVmo, List<$fidl.InterfaceHandle<Protocol>> vectorClientEnd, List<$fidl.InterfaceRequest<Protocol>> vectorServerEnd, List<ResourceStruct> vectorStruct, List<ResourceTable> vectorTable, List<ResourceUnion> vectorUnion)
const int _kProtocol_EventResource_Ordinal = 0x4fbde2864601698b;
const $fidl.MethodType _kProtocol_EventResource_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<$zircon.Handle>(
        type: $fidl.HandleType(objectType: 0, rights: 2147483648), offset: 0),
    $fidl.MemberType<$zircon.Vmo>(
        type: $fidl.VmoType(objectType: 3, rights: 2147483648), offset: 4),
    $fidl.MemberType<$fidl.InterfaceHandle<Protocol>>(
        type: $fidl.InterfaceHandleType<Protocol>(), offset: 8),
    $fidl.MemberType<$fidl.InterfaceRequest<Protocol>>(
        type: $fidl.InterfaceRequestType<Protocol>(), offset: 12),
    $fidl.MemberType<ResourceStruct>(type: kResourceStruct_Type, offset: 16),
    $fidl.MemberType<ResourceTable>(type: kResourceTable_Type, offset: 24),
    $fidl.MemberType<ResourceUnion>(type: kResourceUnion_Type, offset: 40),
    $fidl.MemberType<$zircon.Handle?>(
        type: $fidl.NullableHandleType(
            $fidl.HandleType(objectType: 0, rights: 2147483648)),
        offset: 56),
    $fidl.MemberType<$zircon.Vmo?>(
        type: $fidl.NullableHandleType(
            $fidl.VmoType(objectType: 3, rights: 2147483648)),
        offset: 60),
    $fidl.MemberType<$fidl.InterfaceHandle<Protocol>?>(
        type: $fidl.NullableInterfaceHandleType<Protocol>(), offset: 64),
    $fidl.MemberType<$fidl.InterfaceRequest<Protocol>?>(
        type: $fidl.NullableInterfaceRequestType<Protocol>(), offset: 68),
    $fidl.MemberType<ResourceStruct?>(
        type: $fidl.PointerType<ResourceStruct>(element: kResourceStruct_Type),
        offset: 72),
    $fidl.MemberType<ResourceUnion?>(type: kResourceUnion_OptType, offset: 80),
    $fidl.MemberType<List<$zircon.Handle>>(
        type: $fidl.ArrayType<$zircon.Handle, List<$zircon.Handle>>(
            element: $fidl.HandleType(objectType: 0, rights: 2147483648),
            elementCount: 5),
        offset: 96),
    $fidl.MemberType<List<$zircon.Vmo>>(
        type: $fidl.ArrayType<$zircon.Vmo, List<$zircon.Vmo>>(
            element: $fidl.VmoType(objectType: 3, rights: 2147483648),
            elementCount: 5),
        offset: 116),
    $fidl.MemberType<List<$fidl.InterfaceHandle<Protocol>>>(
        type: $fidl.ArrayType<$fidl.InterfaceHandle<Protocol>,
                List<$fidl.InterfaceHandle<Protocol>>>(
            element: $fidl.InterfaceHandleType<Protocol>(), elementCount: 5),
        offset: 136),
    $fidl.MemberType<List<$fidl.InterfaceRequest<Protocol>>>(
        type: $fidl.ArrayType<$fidl.InterfaceRequest<Protocol>,
                List<$fidl.InterfaceRequest<Protocol>>>(
            element: $fidl.InterfaceRequestType<Protocol>(), elementCount: 5),
        offset: 156),
    $fidl.MemberType<List<ResourceStruct>>(
        type: $fidl.ArrayType<ResourceStruct, List<ResourceStruct>>(
            element: kResourceStruct_Type, elementCount: 5),
        offset: 176),
    $fidl.MemberType<List<ResourceTable>>(
        type: $fidl.ArrayType<ResourceTable, List<ResourceTable>>(
            element: kResourceTable_Type, elementCount: 5),
        offset: 184),
    $fidl.MemberType<List<ResourceUnion>>(
        type: $fidl.ArrayType<ResourceUnion, List<ResourceUnion>>(
            element: kResourceUnion_Type, elementCount: 5),
        offset: 264),
    $fidl.MemberType<List<$zircon.Handle>>(
        type: $fidl.VectorType<$zircon.Handle, List<$zircon.Handle>>(
            element: $fidl.HandleType(objectType: 0, rights: 2147483648),
            maybeElementCount: null),
        offset: 344),
    $fidl.MemberType<List<$zircon.Vmo>>(
        type: $fidl.VectorType<$zircon.Vmo, List<$zircon.Vmo>>(
            element: $fidl.VmoType(objectType: 3, rights: 2147483648),
            maybeElementCount: null),
        offset: 360),
    $fidl.MemberType<List<$fidl.InterfaceHandle<Protocol>>>(
        type: $fidl.VectorType<$fidl.InterfaceHandle<Protocol>,
                List<$fidl.InterfaceHandle<Protocol>>>(
            element: $fidl.InterfaceHandleType<Protocol>(),
            maybeElementCount: null),
        offset: 376),
    $fidl.MemberType<List<$fidl.InterfaceRequest<Protocol>>>(
        type: $fidl.VectorType<$fidl.InterfaceRequest<Protocol>,
                List<$fidl.InterfaceRequest<Protocol>>>(
            element: $fidl.InterfaceRequestType<Protocol>(),
            maybeElementCount: null),
        offset: 392),
    $fidl.MemberType<List<ResourceStruct>>(
        type: $fidl.VectorType<ResourceStruct, List<ResourceStruct>>(
            element: kResourceStruct_Type, maybeElementCount: null),
        offset: 408),
    $fidl.MemberType<List<ResourceTable>>(
        type: $fidl.VectorType<ResourceTable, List<ResourceTable>>(
            element: kResourceTable_Type, maybeElementCount: null),
        offset: 424),
    $fidl.MemberType<List<ResourceUnion>>(
        type: $fidl.VectorType<ResourceUnion, List<ResourceUnion>>(
            element: kResourceUnion_Type, maybeElementCount: null),
        offset: 440),
  ],
  name: r"Protocol.EventResource",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 456,
);

class Protocol$TwoWayBasic$Response {
  final int uint8;
  final int uint16;
  final int uint32;
  final int uint64;
  final int int8;
  final int int16;
  final int int32;
  final int int64;
  final double float32;
  final double float64;
  final String string;
  final String? optString;
  Protocol$TwoWayBasic$Response(
    this.uint8,
    this.uint16,
    this.uint32,
    this.uint64,
    this.int8,
    this.int16,
    this.int32,
    this.int64,
    this.float32,
    this.float64,
    this.string,
    this.optString,
  );
}

class Protocol$ErrorBasic$Response {
  final int uint8;
  final int uint16;
  final int uint32;
  final int uint64;
  final int int8;
  final int int16;
  final int int32;
  final int int64;
  final double float32;
  final double float64;
  final String string;
  final String? optString;
  Protocol$ErrorBasic$Response(
    this.uint8,
    this.uint16,
    this.uint32,
    this.uint64,
    this.int8,
    this.int16,
    this.int32,
    this.int64,
    this.float32,
    this.float64,
    this.string,
    this.optString,
  );
}

class Protocol$EventBasic$Response {
  final int uint8;
  final int uint16;
  final int uint32;
  final int uint64;
  final int int8;
  final int int16;
  final int int32;
  final int int64;
  final double float32;
  final double float64;
  final String string;
  final String? optString;
  Protocol$EventBasic$Response(
    this.uint8,
    this.uint16,
    this.uint32,
    this.uint64,
    this.int8,
    this.int16,
    this.int32,
    this.int64,
    this.float32,
    this.float64,
    this.string,
    this.optString,
  );
}

class Protocol$TwoWayCompound$Response {
  final Bits bits;
  final Enum enum$;
  final Struct struct;
  final Table table;
  final Union union;
  final Struct? optStruct;
  final Union? optUnion;
  Protocol$TwoWayCompound$Response(
    this.bits,
    this.enum$,
    this.struct,
    this.table,
    this.union,
    this.optStruct,
    this.optUnion,
  );
}

class Protocol$ErrorCompound$Response {
  final Bits bits;
  final Enum enum$;
  final Struct struct;
  final Table table;
  final Union union;
  final Struct? optStruct;
  final Union? optUnion;
  Protocol$ErrorCompound$Response(
    this.bits,
    this.enum$,
    this.struct,
    this.table,
    this.union,
    this.optStruct,
    this.optUnion,
  );
}

class Protocol$EventCompound$Response {
  final Bits bits;
  final Enum enum$;
  final Struct struct;
  final Table table;
  final Union union;
  final Struct? optStruct;
  final Union? optUnion;
  Protocol$EventCompound$Response(
    this.bits,
    this.enum$,
    this.struct,
    this.table,
    this.union,
    this.optStruct,
    this.optUnion,
  );
}

class Protocol$TwoWayArrayBasic$Response {
  final Uint8List arrayUint8;
  final Uint16List arrayUint16;
  final Uint32List arrayUint32;
  final Uint64List arrayUint64;
  final Int8List arrayInt8;
  final Int16List arrayInt16;
  final Int32List arrayInt32;
  final Int64List arrayInt64;
  final Float32List arrayFloat32;
  final Float64List arrayFloat64;
  final List<String> arrayString;
  final List<String?> arrayOptString;
  Protocol$TwoWayArrayBasic$Response(
    this.arrayUint8,
    this.arrayUint16,
    this.arrayUint32,
    this.arrayUint64,
    this.arrayInt8,
    this.arrayInt16,
    this.arrayInt32,
    this.arrayInt64,
    this.arrayFloat32,
    this.arrayFloat64,
    this.arrayString,
    this.arrayOptString,
  );
}

class Protocol$ErrorArrayBasic$Response {
  final Uint8List arrayUint8;
  final Uint16List arrayUint16;
  final Uint32List arrayUint32;
  final Uint64List arrayUint64;
  final Int8List arrayInt8;
  final Int16List arrayInt16;
  final Int32List arrayInt32;
  final Int64List arrayInt64;
  final Float32List arrayFloat32;
  final Float64List arrayFloat64;
  final List<String> arrayString;
  final List<String?> arrayOptString;
  Protocol$ErrorArrayBasic$Response(
    this.arrayUint8,
    this.arrayUint16,
    this.arrayUint32,
    this.arrayUint64,
    this.arrayInt8,
    this.arrayInt16,
    this.arrayInt32,
    this.arrayInt64,
    this.arrayFloat32,
    this.arrayFloat64,
    this.arrayString,
    this.arrayOptString,
  );
}

class Protocol$EventArrayBasic$Response {
  final Uint8List arrayUint8;
  final Uint16List arrayUint16;
  final Uint32List arrayUint32;
  final Uint64List arrayUint64;
  final Int8List arrayInt8;
  final Int16List arrayInt16;
  final Int32List arrayInt32;
  final Int64List arrayInt64;
  final Float32List arrayFloat32;
  final Float64List arrayFloat64;
  final List<String> arrayString;
  final List<String?> arrayOptString;
  Protocol$EventArrayBasic$Response(
    this.arrayUint8,
    this.arrayUint16,
    this.arrayUint32,
    this.arrayUint64,
    this.arrayInt8,
    this.arrayInt16,
    this.arrayInt32,
    this.arrayInt64,
    this.arrayFloat32,
    this.arrayFloat64,
    this.arrayString,
    this.arrayOptString,
  );
}

class Protocol$TwoWayArrayCompound$Response {
  final List<Bits> arrayBits;
  final List<Enum> arrayEnum;
  final List<Struct> arrayStruct;
  final List<Table> arrayTable;
  final List<Union> arrayUnion;
  final List<Struct?> arrayOptStruct;
  final List<Union?> arrayOptUnion;
  Protocol$TwoWayArrayCompound$Response(
    this.arrayBits,
    this.arrayEnum,
    this.arrayStruct,
    this.arrayTable,
    this.arrayUnion,
    this.arrayOptStruct,
    this.arrayOptUnion,
  );
}

class Protocol$ErrorArrayCompound$Response {
  final List<Bits> arrayBits;
  final List<Enum> arrayEnum;
  final List<Struct> arrayStruct;
  final List<Table> arrayTable;
  final List<Union> arrayUnion;
  final List<Struct?> arrayOptStruct;
  final List<Union?> arrayOptUnion;
  Protocol$ErrorArrayCompound$Response(
    this.arrayBits,
    this.arrayEnum,
    this.arrayStruct,
    this.arrayTable,
    this.arrayUnion,
    this.arrayOptStruct,
    this.arrayOptUnion,
  );
}

class Protocol$EventArrayCompound$Response {
  final List<Bits> arrayBits;
  final List<Enum> arrayEnum;
  final List<Struct> arrayStruct;
  final List<Table> arrayTable;
  final List<Union> arrayUnion;
  final List<Struct?> arrayOptStruct;
  final List<Union?> arrayOptUnion;
  Protocol$EventArrayCompound$Response(
    this.arrayBits,
    this.arrayEnum,
    this.arrayStruct,
    this.arrayTable,
    this.arrayUnion,
    this.arrayOptStruct,
    this.arrayOptUnion,
  );
}

class Protocol$TwoWayVectorBasic$Response {
  final Uint8List vectorUint8;
  final Uint16List vectorUint16;
  final Uint32List vectorUint32;
  final Uint64List vectorUint64;
  final Int8List vectorInt8;
  final Int16List vectorInt16;
  final Int32List vectorInt32;
  final Int64List vectorInt64;
  final Float32List vectorFloat32;
  final Float64List vectorFloat64;
  final List<String> vectorString;
  final List<String?> vectorOptString;
  Protocol$TwoWayVectorBasic$Response(
    this.vectorUint8,
    this.vectorUint16,
    this.vectorUint32,
    this.vectorUint64,
    this.vectorInt8,
    this.vectorInt16,
    this.vectorInt32,
    this.vectorInt64,
    this.vectorFloat32,
    this.vectorFloat64,
    this.vectorString,
    this.vectorOptString,
  );
}

class Protocol$ErrorVectorBasic$Response {
  final Uint8List vectorUint8;
  final Uint16List vectorUint16;
  final Uint32List vectorUint32;
  final Uint64List vectorUint64;
  final Int8List vectorInt8;
  final Int16List vectorInt16;
  final Int32List vectorInt32;
  final Int64List vectorInt64;
  final Float32List vectorFloat32;
  final Float64List vectorFloat64;
  final List<String> vectorString;
  final List<String?> vectorOptString;
  Protocol$ErrorVectorBasic$Response(
    this.vectorUint8,
    this.vectorUint16,
    this.vectorUint32,
    this.vectorUint64,
    this.vectorInt8,
    this.vectorInt16,
    this.vectorInt32,
    this.vectorInt64,
    this.vectorFloat32,
    this.vectorFloat64,
    this.vectorString,
    this.vectorOptString,
  );
}

class Protocol$EventVectorBasic$Response {
  final Uint8List vectorUint8;
  final Uint16List vectorUint16;
  final Uint32List vectorUint32;
  final Uint64List vectorUint64;
  final Int8List vectorInt8;
  final Int16List vectorInt16;
  final Int32List vectorInt32;
  final Int64List vectorInt64;
  final Float32List vectorFloat32;
  final Float64List vectorFloat64;
  final List<String> vectorString;
  final List<String?> vectorOptString;
  Protocol$EventVectorBasic$Response(
    this.vectorUint8,
    this.vectorUint16,
    this.vectorUint32,
    this.vectorUint64,
    this.vectorInt8,
    this.vectorInt16,
    this.vectorInt32,
    this.vectorInt64,
    this.vectorFloat32,
    this.vectorFloat64,
    this.vectorString,
    this.vectorOptString,
  );
}

class Protocol$TwoWayVectorCompound$Response {
  final List<Bits> vectorBits;
  final List<Enum> vectorEnum;
  final List<Struct> vectorStruct;
  final List<Table> vectorTable;
  final List<Union> vectorUnion;
  final List<Struct?> vectorOptStruct;
  final List<Union?> vectorOptUnion;
  Protocol$TwoWayVectorCompound$Response(
    this.vectorBits,
    this.vectorEnum,
    this.vectorStruct,
    this.vectorTable,
    this.vectorUnion,
    this.vectorOptStruct,
    this.vectorOptUnion,
  );
}

class Protocol$ErrorVectorCompound$Response {
  final List<Bits> vectorBits;
  final List<Enum> vectorEnum;
  final List<Struct> vectorStruct;
  final List<Table> vectorTable;
  final List<Union> vectorUnion;
  final List<Struct?> vectorOptStruct;
  final List<Union?> vectorOptUnion;
  Protocol$ErrorVectorCompound$Response(
    this.vectorBits,
    this.vectorEnum,
    this.vectorStruct,
    this.vectorTable,
    this.vectorUnion,
    this.vectorOptStruct,
    this.vectorOptUnion,
  );
}

class Protocol$EventVectorCompound$Response {
  final List<Bits> vectorBits;
  final List<Enum> vectorEnum;
  final List<Struct> vectorStruct;
  final List<Table> vectorTable;
  final List<Union> vectorUnion;
  final List<Struct?> vectorOptStruct;
  final List<Union?> vectorOptUnion;
  Protocol$EventVectorCompound$Response(
    this.vectorBits,
    this.vectorEnum,
    this.vectorStruct,
    this.vectorTable,
    this.vectorUnion,
    this.vectorOptStruct,
    this.vectorOptUnion,
  );
}

class Protocol$TwoWayVectorOptional$Response {
  final Uint8List? optVectorUint8;
  final List<String>? optVectorString;
  final List<Struct>? optVectorStruct;
  final List<Struct?>? optVectorOptStruct;
  Protocol$TwoWayVectorOptional$Response(
    this.optVectorUint8,
    this.optVectorString,
    this.optVectorStruct,
    this.optVectorOptStruct,
  );
}

class Protocol$ErrorVectorOptional$Response {
  final Uint8List? optVectorUint8;
  final List<String>? optVectorString;
  final List<Struct>? optVectorStruct;
  final List<Struct?>? optVectorOptStruct;
  Protocol$ErrorVectorOptional$Response(
    this.optVectorUint8,
    this.optVectorString,
    this.optVectorStruct,
    this.optVectorOptStruct,
  );
}

class Protocol$EventVectorOptional$Response {
  final Uint8List? optVectorUint8;
  final List<String>? optVectorString;
  final List<Struct>? optVectorStruct;
  final List<Struct?>? optVectorOptStruct;
  Protocol$EventVectorOptional$Response(
    this.optVectorUint8,
    this.optVectorString,
    this.optVectorStruct,
    this.optVectorOptStruct,
  );
}

class Protocol$TwoWayArrayVectorNested$Response {
  final List<Uint8List> arrayArrayUint8;
  final List<Uint8List> arrayVectorUint8;
  final List<Uint8List> vectorArrayUint8;
  final List<Uint8List> vectorVectorUint8;
  Protocol$TwoWayArrayVectorNested$Response(
    this.arrayArrayUint8,
    this.arrayVectorUint8,
    this.vectorArrayUint8,
    this.vectorVectorUint8,
  );
}

class Protocol$ErrorArrayVectorNested$Response {
  final List<Uint8List> arrayArrayUint8;
  final List<Uint8List> arrayVectorUint8;
  final List<Uint8List> vectorArrayUint8;
  final List<Uint8List> vectorVectorUint8;
  Protocol$ErrorArrayVectorNested$Response(
    this.arrayArrayUint8,
    this.arrayVectorUint8,
    this.vectorArrayUint8,
    this.vectorVectorUint8,
  );
}

class Protocol$EventArrayVectorNested$Response {
  final List<Uint8List> arrayArrayUint8;
  final List<Uint8List> arrayVectorUint8;
  final List<Uint8List> vectorArrayUint8;
  final List<Uint8List> vectorVectorUint8;
  Protocol$EventArrayVectorNested$Response(
    this.arrayArrayUint8,
    this.arrayVectorUint8,
    this.vectorArrayUint8,
    this.vectorVectorUint8,
  );
}

class Protocol$TwoWayResource$Response {
  final $zircon.Handle handle;
  final $zircon.Vmo vmo;
  final $fidl.InterfaceHandle<Protocol> clientEnd;
  final $fidl.InterfaceRequest<Protocol> serverEnd;
  final ResourceStruct struct;
  final ResourceTable table;
  final ResourceUnion union;
  final $zircon.Handle? optHandle;
  final $zircon.Vmo? optVmo;
  final $fidl.InterfaceHandle<Protocol>? optClientEnd;
  final $fidl.InterfaceRequest<Protocol>? optServerEnd;
  final ResourceStruct? optStruct;
  final ResourceUnion? optUnion;
  final List<$zircon.Handle> arrayHandle;
  final List<$zircon.Vmo> arrayVmo;
  final List<$fidl.InterfaceHandle<Protocol>> arrayClientEnd;
  final List<$fidl.InterfaceRequest<Protocol>> arrayServerEnd;
  final List<ResourceStruct> arrayStruct;
  final List<ResourceTable> arrayTable;
  final List<ResourceUnion> arrayUnion;
  final List<$zircon.Handle> vectorHandle;
  final List<$zircon.Vmo> vectorVmo;
  final List<$fidl.InterfaceHandle<Protocol>> vectorClientEnd;
  final List<$fidl.InterfaceRequest<Protocol>> vectorServerEnd;
  final List<ResourceStruct> vectorStruct;
  final List<ResourceTable> vectorTable;
  final List<ResourceUnion> vectorUnion;
  Protocol$TwoWayResource$Response(
    this.handle,
    this.vmo,
    this.clientEnd,
    this.serverEnd,
    this.struct,
    this.table,
    this.union,
    this.optHandle,
    this.optVmo,
    this.optClientEnd,
    this.optServerEnd,
    this.optStruct,
    this.optUnion,
    this.arrayHandle,
    this.arrayVmo,
    this.arrayClientEnd,
    this.arrayServerEnd,
    this.arrayStruct,
    this.arrayTable,
    this.arrayUnion,
    this.vectorHandle,
    this.vectorVmo,
    this.vectorClientEnd,
    this.vectorServerEnd,
    this.vectorStruct,
    this.vectorTable,
    this.vectorUnion,
  );
}

class Protocol$ErrorResource$Response {
  final $zircon.Handle handle;
  final $zircon.Vmo vmo;
  final $fidl.InterfaceHandle<Protocol> clientEnd;
  final $fidl.InterfaceRequest<Protocol> serverEnd;
  final ResourceStruct struct;
  final ResourceTable table;
  final ResourceUnion union;
  final $zircon.Handle? optHandle;
  final $zircon.Vmo? optVmo;
  final $fidl.InterfaceHandle<Protocol>? optClientEnd;
  final $fidl.InterfaceRequest<Protocol>? optServerEnd;
  final ResourceStruct? optStruct;
  final ResourceUnion? optUnion;
  final List<$zircon.Handle> arrayHandle;
  final List<$zircon.Vmo> arrayVmo;
  final List<$fidl.InterfaceHandle<Protocol>> arrayClientEnd;
  final List<$fidl.InterfaceRequest<Protocol>> arrayServerEnd;
  final List<ResourceStruct> arrayStruct;
  final List<ResourceTable> arrayTable;
  final List<ResourceUnion> arrayUnion;
  final List<$zircon.Handle> vectorHandle;
  final List<$zircon.Vmo> vectorVmo;
  final List<$fidl.InterfaceHandle<Protocol>> vectorClientEnd;
  final List<$fidl.InterfaceRequest<Protocol>> vectorServerEnd;
  final List<ResourceStruct> vectorStruct;
  final List<ResourceTable> vectorTable;
  final List<ResourceUnion> vectorUnion;
  Protocol$ErrorResource$Response(
    this.handle,
    this.vmo,
    this.clientEnd,
    this.serverEnd,
    this.struct,
    this.table,
    this.union,
    this.optHandle,
    this.optVmo,
    this.optClientEnd,
    this.optServerEnd,
    this.optStruct,
    this.optUnion,
    this.arrayHandle,
    this.arrayVmo,
    this.arrayClientEnd,
    this.arrayServerEnd,
    this.arrayStruct,
    this.arrayTable,
    this.arrayUnion,
    this.vectorHandle,
    this.vectorVmo,
    this.vectorClientEnd,
    this.vectorServerEnd,
    this.vectorStruct,
    this.vectorTable,
    this.vectorUnion,
  );
}

class Protocol$EventResource$Response {
  final $zircon.Handle handle;
  final $zircon.Vmo vmo;
  final $fidl.InterfaceHandle<Protocol> clientEnd;
  final $fidl.InterfaceRequest<Protocol> serverEnd;
  final ResourceStruct struct;
  final ResourceTable table;
  final ResourceUnion union;
  final $zircon.Handle? optHandle;
  final $zircon.Vmo? optVmo;
  final $fidl.InterfaceHandle<Protocol>? optClientEnd;
  final $fidl.InterfaceRequest<Protocol>? optServerEnd;
  final ResourceStruct? optStruct;
  final ResourceUnion? optUnion;
  final List<$zircon.Handle> arrayHandle;
  final List<$zircon.Vmo> arrayVmo;
  final List<$fidl.InterfaceHandle<Protocol>> arrayClientEnd;
  final List<$fidl.InterfaceRequest<Protocol>> arrayServerEnd;
  final List<ResourceStruct> arrayStruct;
  final List<ResourceTable> arrayTable;
  final List<ResourceUnion> arrayUnion;
  final List<$zircon.Handle> vectorHandle;
  final List<$zircon.Vmo> vectorVmo;
  final List<$fidl.InterfaceHandle<Protocol>> vectorClientEnd;
  final List<$fidl.InterfaceRequest<Protocol>> vectorServerEnd;
  final List<ResourceStruct> vectorStruct;
  final List<ResourceTable> vectorTable;
  final List<ResourceUnion> vectorUnion;
  Protocol$EventResource$Response(
    this.handle,
    this.vmo,
    this.clientEnd,
    this.serverEnd,
    this.struct,
    this.table,
    this.union,
    this.optHandle,
    this.optVmo,
    this.optClientEnd,
    this.optServerEnd,
    this.optStruct,
    this.optUnion,
    this.arrayHandle,
    this.arrayVmo,
    this.arrayClientEnd,
    this.arrayServerEnd,
    this.arrayStruct,
    this.arrayTable,
    this.arrayUnion,
    this.vectorHandle,
    this.vectorVmo,
    this.vectorClientEnd,
    this.vectorServerEnd,
    this.vectorStruct,
    this.vectorTable,
    this.vectorUnion,
  );
}

abstract class Protocol {
  $fidl.ServiceData? get $serviceData => ProtocolData();
  $async.Future<void> oneWayBasic(
      int uint8,
      int uint16,
      int uint32,
      int uint64,
      int int8,
      int int16,
      int int32,
      int int64,
      double float32,
      double float64,
      String string,
      String? optString);
  $async.Future<Protocol$TwoWayBasic$Response> twoWayBasic(
      int uint8,
      int uint16,
      int uint32,
      int uint64,
      int int8,
      int int16,
      int int32,
      int int64,
      double float32,
      double float64,
      String string,
      String? optString);
  $async.Future<Protocol$ErrorBasic$Response> errorBasic();
  $async.Stream<Protocol$EventBasic$Response>? get eventBasic;
  $async.Future<void> oneWayCompound(Bits bits, Enum enum$, Struct struct,
      Table table, Union union, Struct? optStruct, Union? optUnion);
  $async.Future<Protocol$TwoWayCompound$Response> twoWayCompound(
      Bits bits,
      Enum enum$,
      Struct struct,
      Table table,
      Union union,
      Struct? optStruct,
      Union? optUnion);
  $async.Future<Protocol$ErrorCompound$Response> errorCompound();
  $async.Stream<Protocol$EventCompound$Response>? get eventCompound;
  $async.Future<void> oneWayArrayBasic(
      Uint8List arrayUint8,
      Uint16List arrayUint16,
      Uint32List arrayUint32,
      Uint64List arrayUint64,
      Int8List arrayInt8,
      Int16List arrayInt16,
      Int32List arrayInt32,
      Int64List arrayInt64,
      Float32List arrayFloat32,
      Float64List arrayFloat64,
      List<String> arrayString,
      List<String?> arrayOptString);
  $async.Future<Protocol$TwoWayArrayBasic$Response> twoWayArrayBasic(
      Uint8List arrayUint8,
      Uint16List arrayUint16,
      Uint32List arrayUint32,
      Uint64List arrayUint64,
      Int8List arrayInt8,
      Int16List arrayInt16,
      Int32List arrayInt32,
      Int64List arrayInt64,
      Float32List arrayFloat32,
      Float64List arrayFloat64,
      List<String> arrayString,
      List<String?> arrayOptString);
  $async.Future<Protocol$ErrorArrayBasic$Response> errorArrayBasic();
  $async.Stream<Protocol$EventArrayBasic$Response>? get eventArrayBasic;
  $async.Future<void> oneWayArrayCompound(
      List<Bits> arrayBits,
      List<Enum> arrayEnum,
      List<Struct> arrayStruct,
      List<Table> arrayTable,
      List<Union> arrayUnion,
      List<Struct?> arrayOptStruct,
      List<Union?> arrayOptUnion);
  $async.Future<Protocol$TwoWayArrayCompound$Response> twoWayArrayCompound(
      List<Bits> arrayBits,
      List<Enum> arrayEnum,
      List<Struct> arrayStruct,
      List<Table> arrayTable,
      List<Union> arrayUnion,
      List<Struct?> arrayOptStruct,
      List<Union?> arrayOptUnion);
  $async.Future<Protocol$ErrorArrayCompound$Response> errorArrayCompound();
  $async.Stream<Protocol$EventArrayCompound$Response>? get eventArrayCompound;
  $async.Future<void> oneWayVectorBasic(
      Uint8List vectorUint8,
      Uint16List vectorUint16,
      Uint32List vectorUint32,
      Uint64List vectorUint64,
      Int8List vectorInt8,
      Int16List vectorInt16,
      Int32List vectorInt32,
      Int64List vectorInt64,
      Float32List vectorFloat32,
      Float64List vectorFloat64,
      List<String> vectorString,
      List<String?> vectorOptString);
  $async.Future<Protocol$TwoWayVectorBasic$Response> twoWayVectorBasic(
      Uint8List vectorUint8,
      Uint16List vectorUint16,
      Uint32List vectorUint32,
      Uint64List vectorUint64,
      Int8List vectorInt8,
      Int16List vectorInt16,
      Int32List vectorInt32,
      Int64List vectorInt64,
      Float32List vectorFloat32,
      Float64List vectorFloat64,
      List<String> vectorString,
      List<String?> vectorOptString);
  $async.Future<Protocol$ErrorVectorBasic$Response> errorVectorBasic();
  $async.Stream<Protocol$EventVectorBasic$Response>? get eventVectorBasic;
  $async.Future<void> oneWayVectorCompound(
      List<Bits> vectorBits,
      List<Enum> vectorEnum,
      List<Struct> vectorStruct,
      List<Table> vectorTable,
      List<Union> vectorUnion,
      List<Struct?> vectorOptStruct,
      List<Union?> vectorOptUnion);
  $async.Future<Protocol$TwoWayVectorCompound$Response> twoWayVectorCompound(
      List<Bits> vectorBits,
      List<Enum> vectorEnum,
      List<Struct> vectorStruct,
      List<Table> vectorTable,
      List<Union> vectorUnion,
      List<Struct?> vectorOptStruct,
      List<Union?> vectorOptUnion);
  $async.Future<Protocol$ErrorVectorCompound$Response> errorVectorCompound();
  $async.Stream<Protocol$EventVectorCompound$Response>? get eventVectorCompound;
  $async.Future<void> oneWayVectorOptional(
      Uint8List? optVectorUint8,
      List<String>? optVectorString,
      List<Struct>? optVectorStruct,
      List<Struct?>? optVectorOptStruct);
  $async.Future<Protocol$TwoWayVectorOptional$Response> twoWayVectorOptional(
      Uint8List? optVectorUint8,
      List<String>? optVectorString,
      List<Struct>? optVectorStruct,
      List<Struct?>? optVectorOptStruct);
  $async.Future<Protocol$ErrorVectorOptional$Response> errorVectorOptional();
  $async.Stream<Protocol$EventVectorOptional$Response>? get eventVectorOptional;
  $async.Future<void> oneWayArrayVectorNested(
      List<Uint8List> arrayArrayUint8,
      List<Uint8List> arrayVectorUint8,
      List<Uint8List> vectorArrayUint8,
      List<Uint8List> vectorVectorUint8);
  $async.Future<Protocol$TwoWayArrayVectorNested$Response>
      twoWayArrayVectorNested(
          List<Uint8List> arrayArrayUint8,
          List<Uint8List> arrayVectorUint8,
          List<Uint8List> vectorArrayUint8,
          List<Uint8List> vectorVectorUint8);
  $async.Future<Protocol$ErrorArrayVectorNested$Response>
      errorArrayVectorNested();
  $async.Stream<Protocol$EventArrayVectorNested$Response>?
      get eventArrayVectorNested;
  $async.Future<void> oneWayResource(
      $zircon.Handle handle,
      $zircon.Vmo vmo,
      $fidl.InterfaceHandle<Protocol> clientEnd,
      $fidl.InterfaceRequest<Protocol> serverEnd,
      ResourceStruct struct,
      ResourceTable table,
      ResourceUnion union,
      $zircon.Handle? optHandle,
      $zircon.Vmo? optVmo,
      $fidl.InterfaceHandle<Protocol>? optClientEnd,
      $fidl.InterfaceRequest<Protocol>? optServerEnd,
      ResourceStruct? optStruct,
      ResourceUnion? optUnion,
      List<$zircon.Handle> arrayHandle,
      List<$zircon.Vmo> arrayVmo,
      List<$fidl.InterfaceHandle<Protocol>> arrayClientEnd,
      List<$fidl.InterfaceRequest<Protocol>> arrayServerEnd,
      List<ResourceStruct> arrayStruct,
      List<ResourceTable> arrayTable,
      List<ResourceUnion> arrayUnion,
      List<$zircon.Handle> vectorHandle,
      List<$zircon.Vmo> vectorVmo,
      List<$fidl.InterfaceHandle<Protocol>> vectorClientEnd,
      List<$fidl.InterfaceRequest<Protocol>> vectorServerEnd,
      List<ResourceStruct> vectorStruct,
      List<ResourceTable> vectorTable,
      List<ResourceUnion> vectorUnion);
  $async.Future<Protocol$TwoWayResource$Response> twoWayResource(
      $zircon.Handle handle,
      $zircon.Vmo vmo,
      $fidl.InterfaceHandle<Protocol> clientEnd,
      $fidl.InterfaceRequest<Protocol> serverEnd,
      ResourceStruct struct,
      ResourceTable table,
      ResourceUnion union,
      $zircon.Handle? optHandle,
      $zircon.Vmo? optVmo,
      $fidl.InterfaceHandle<Protocol>? optClientEnd,
      $fidl.InterfaceRequest<Protocol>? optServerEnd,
      ResourceStruct? optStruct,
      ResourceUnion? optUnion,
      List<$zircon.Handle> arrayHandle,
      List<$zircon.Vmo> arrayVmo,
      List<$fidl.InterfaceHandle<Protocol>> arrayClientEnd,
      List<$fidl.InterfaceRequest<Protocol>> arrayServerEnd,
      List<ResourceStruct> arrayStruct,
      List<ResourceTable> arrayTable,
      List<ResourceUnion> arrayUnion,
      List<$zircon.Handle> vectorHandle,
      List<$zircon.Vmo> vectorVmo,
      List<$fidl.InterfaceHandle<Protocol>> vectorClientEnd,
      List<$fidl.InterfaceRequest<Protocol>> vectorServerEnd,
      List<ResourceStruct> vectorStruct,
      List<ResourceTable> vectorTable,
      List<ResourceUnion> vectorUnion);
  $async.Future<Protocol$ErrorResource$Response> errorResource();
  $async.Stream<Protocol$EventResource$Response>? get eventResource;
} // TODO: Remove ServiceData for non-service

class ProtocolData implements $fidl.ServiceData<Protocol> {
  const ProtocolData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return ProtocolBinding();
  }
}

class ProtocolProxy extends $fidl.AsyncProxy<Protocol> implements Protocol {
  ProtocolProxy()
      : super(
            $fidl.AsyncProxyController<Protocol>($interfaceName: r'Protocol')) {
    ctrl.onResponse = _handleResponse;
    ctrl.whenClosed.then((_) {
      _eventBasicEventStreamController.close();
      _eventCompoundEventStreamController.close();
      _eventArrayBasicEventStreamController.close();
      _eventArrayCompoundEventStreamController.close();
      _eventVectorBasicEventStreamController.close();
      _eventVectorCompoundEventStreamController.close();
      _eventVectorOptionalEventStreamController.close();
      _eventArrayVectorNestedEventStreamController.close();
      _eventResourceEventStreamController.close();
    }, onError: (_) {});
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      case _kProtocol_EventBasic_Ordinal:
        final String _name = _kProtocol_EventBasic_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _eventBasicEventStreamController.addError,
            () {
          final List<$fidl.MemberType> $types =
              _kProtocol_EventBasic_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_EventBasic_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final Protocol$EventBasic$Response $response = $fidl
              .decodeMessageWithCallback<Protocol$EventBasic$Response>($message,
                  _kProtocol_EventBasic_Type.responseInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return Protocol$EventBasic$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
            );
          });
          _eventBasicEventStreamController.add($response);
        });
        break;
      case _kProtocol_EventCompound_Ordinal:
        final String _name = _kProtocol_EventCompound_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _eventCompoundEventStreamController.addError,
            () {
          final List<$fidl.MemberType> $types =
              _kProtocol_EventCompound_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_EventCompound_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final Protocol$EventCompound$Response $response = $fidl
              .decodeMessageWithCallback<Protocol$EventCompound$Response>(
                  $message,
                  _kProtocol_EventCompound_Type.responseInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return Protocol$EventCompound$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
            );
          });
          _eventCompoundEventStreamController.add($response);
        });
        break;
      case _kProtocol_EventArrayBasic_Ordinal:
        final String _name = _kProtocol_EventArrayBasic_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _eventArrayBasicEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_EventArrayBasic_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_EventArrayBasic_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final Protocol$EventArrayBasic$Response $response = $fidl
              .decodeMessageWithCallback<Protocol$EventArrayBasic$Response>(
                  $message,
                  _kProtocol_EventArrayBasic_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$EventArrayBasic$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
            );
          });
          _eventArrayBasicEventStreamController.add($response);
        });
        break;
      case _kProtocol_EventArrayCompound_Ordinal:
        final String _name = _kProtocol_EventArrayCompound_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _eventArrayCompoundEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_EventArrayCompound_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_EventArrayCompound_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final Protocol$EventArrayCompound$Response $response = $fidl
              .decodeMessageWithCallback<Protocol$EventArrayCompound$Response>(
                  $message,
                  _kProtocol_EventArrayCompound_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$EventArrayCompound$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
            );
          });
          _eventArrayCompoundEventStreamController.add($response);
        });
        break;
      case _kProtocol_EventVectorBasic_Ordinal:
        final String _name = _kProtocol_EventVectorBasic_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _eventVectorBasicEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_EventVectorBasic_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_EventVectorBasic_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final Protocol$EventVectorBasic$Response $response = $fidl
              .decodeMessageWithCallback<Protocol$EventVectorBasic$Response>(
                  $message,
                  _kProtocol_EventVectorBasic_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$EventVectorBasic$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
            );
          });
          _eventVectorBasicEventStreamController.add($response);
        });
        break;
      case _kProtocol_EventVectorCompound_Ordinal:
        final String _name = _kProtocol_EventVectorCompound_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _eventVectorCompoundEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_EventVectorCompound_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_EventVectorCompound_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final Protocol$EventVectorCompound$Response $response = $fidl
              .decodeMessageWithCallback<Protocol$EventVectorCompound$Response>(
                  $message,
                  _kProtocol_EventVectorCompound_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$EventVectorCompound$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
            );
          });
          _eventVectorCompoundEventStreamController.add($response);
        });
        break;
      case _kProtocol_EventVectorOptional_Ordinal:
        final String _name = _kProtocol_EventVectorOptional_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _eventVectorOptionalEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_EventVectorOptional_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_EventVectorOptional_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final Protocol$EventVectorOptional$Response $response = $fidl
              .decodeMessageWithCallback<Protocol$EventVectorOptional$Response>(
                  $message,
                  _kProtocol_EventVectorOptional_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$EventVectorOptional$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
            );
          });
          _eventVectorOptionalEventStreamController.add($response);
        });
        break;
      case _kProtocol_EventArrayVectorNested_Ordinal:
        final String _name = _kProtocol_EventArrayVectorNested_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _eventArrayVectorNestedEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_EventArrayVectorNested_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_EventArrayVectorNested_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final Protocol$EventArrayVectorNested$Response $response = $fidl
              .decodeMessageWithCallback<
                      Protocol$EventArrayVectorNested$Response>(
                  $message,
                  _kProtocol_EventArrayVectorNested_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$EventArrayVectorNested$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
            );
          });
          _eventArrayVectorNestedEventStreamController.add($response);
        });
        break;
      case _kProtocol_EventResource_Ordinal:
        final String _name = _kProtocol_EventResource_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _eventResourceEventStreamController.addError,
            () {
          final List<$fidl.MemberType> $types =
              _kProtocol_EventResource_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_EventResource_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final Protocol$EventResource$Response $response = $fidl
              .decodeMessageWithCallback<Protocol$EventResource$Response>(
                  $message,
                  _kProtocol_EventResource_Type.responseInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return Protocol$EventResource$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
              $types[12].decode($decoder, $offset, 1),
              $types[13].decode($decoder, $offset, 1),
              $types[14].decode($decoder, $offset, 1),
              $types[15].decode($decoder, $offset, 1),
              $types[16].decode($decoder, $offset, 1),
              $types[17].decode($decoder, $offset, 1),
              $types[18].decode($decoder, $offset, 1),
              $types[19].decode($decoder, $offset, 1),
              $types[20].decode($decoder, $offset, 1),
              $types[21].decode($decoder, $offset, 1),
              $types[22].decode($decoder, $offset, 1),
              $types[23].decode($decoder, $offset, 1),
              $types[24].decode($decoder, $offset, 1),
              $types[25].decode($decoder, $offset, 1),
              $types[26].decode($decoder, $offset, 1),
            );
          });
          _eventResourceEventStreamController.add($response);
        });
        break;
      default:
        $message.closeHandles();
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      case _kProtocol_TwoWayBasic_Ordinal:
        final String _name = _kProtocol_TwoWayBasic_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayBasic_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final Protocol$TwoWayBasic$Response $response = $fidl
              .decodeMaybeLargeMessageWithCallback<
                      Protocol$TwoWayBasic$Response>($message,
                  _kProtocol_TwoWayBasic_Type.responseInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return Protocol$TwoWayBasic$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
            );
          });
          $completer.complete($response);
        });
        break;
      case _kProtocol_ErrorBasic_Ordinal:
        final String _name = _kProtocol_ErrorBasic_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorBasic_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorBasic_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final ProtocolErrorBasicResult $response = $fidl.decodeMessage(
              $message,
              _kProtocol_ErrorBasic_Type.responseInlineSize($wireFormat),
              $types[0]);
          if ($response.$tag == ProtocolErrorBasicResultTag.response) {
            $completer.complete(Protocol$ErrorBasic$Response(
              $response.response!.uint8,
              $response.response!.uint16,
              $response.response!.uint32,
              $response.response!.uint64,
              $response.response!.int8,
              $response.response!.int16,
              $response.response!.int32,
              $response.response!.int64,
              $response.response!.float32,
              $response.response!.float64,
              $response.response!.string,
              $response.response!.optString,
            ));
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kProtocol_TwoWayCompound_Ordinal:
        final String _name = _kProtocol_TwoWayCompound_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayCompound_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final Protocol$TwoWayCompound$Response $response = $fidl
              .decodeMaybeLargeMessageWithCallback<
                      Protocol$TwoWayCompound$Response>(
                  $message,
                  _kProtocol_TwoWayCompound_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$TwoWayCompound$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
            );
          });
          $completer.complete($response);
        });
        break;
      case _kProtocol_ErrorCompound_Ordinal:
        final String _name = _kProtocol_ErrorCompound_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorCompound_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorCompound_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final ProtocolErrorCompoundResult $response = $fidl.decodeMessage(
              $message,
              _kProtocol_ErrorCompound_Type.responseInlineSize($wireFormat),
              $types[0]);
          if ($response.$tag == ProtocolErrorCompoundResultTag.response) {
            $completer.complete(Protocol$ErrorCompound$Response(
              $response.response!.bits,
              $response.response!.enum$,
              $response.response!.struct,
              $response.response!.table,
              $response.response!.union,
              $response.response!.optStruct,
              $response.response!.optUnion,
            ));
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kProtocol_TwoWayArrayBasic_Ordinal:
        final String _name = _kProtocol_TwoWayArrayBasic_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayArrayBasic_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final Protocol$TwoWayArrayBasic$Response $response = $fidl
              .decodeMaybeLargeMessageWithCallback<
                      Protocol$TwoWayArrayBasic$Response>(
                  $message,
                  _kProtocol_TwoWayArrayBasic_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$TwoWayArrayBasic$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
            );
          });
          $completer.complete($response);
        });
        break;
      case _kProtocol_ErrorArrayBasic_Ordinal:
        final String _name = _kProtocol_ErrorArrayBasic_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorArrayBasic_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorArrayBasic_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final ProtocolErrorArrayBasicResult $response = $fidl.decodeMessage(
              $message,
              _kProtocol_ErrorArrayBasic_Type.responseInlineSize($wireFormat),
              $types[0]);
          if ($response.$tag == ProtocolErrorArrayBasicResultTag.response) {
            $completer.complete(Protocol$ErrorArrayBasic$Response(
              $response.response!.arrayUint8,
              $response.response!.arrayUint16,
              $response.response!.arrayUint32,
              $response.response!.arrayUint64,
              $response.response!.arrayInt8,
              $response.response!.arrayInt16,
              $response.response!.arrayInt32,
              $response.response!.arrayInt64,
              $response.response!.arrayFloat32,
              $response.response!.arrayFloat64,
              $response.response!.arrayString,
              $response.response!.arrayOptString,
            ));
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kProtocol_TwoWayArrayCompound_Ordinal:
        final String _name = _kProtocol_TwoWayArrayCompound_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayArrayCompound_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final Protocol$TwoWayArrayCompound$Response $response = $fidl
              .decodeMaybeLargeMessageWithCallback<
                      Protocol$TwoWayArrayCompound$Response>(
                  $message,
                  _kProtocol_TwoWayArrayCompound_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$TwoWayArrayCompound$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
            );
          });
          $completer.complete($response);
        });
        break;
      case _kProtocol_ErrorArrayCompound_Ordinal:
        final String _name = _kProtocol_ErrorArrayCompound_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorArrayCompound_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorArrayCompound_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final ProtocolErrorArrayCompoundResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kProtocol_ErrorArrayCompound_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag == ProtocolErrorArrayCompoundResultTag.response) {
            $completer.complete(Protocol$ErrorArrayCompound$Response(
              $response.response!.arrayBits,
              $response.response!.arrayEnum,
              $response.response!.arrayStruct,
              $response.response!.arrayTable,
              $response.response!.arrayUnion,
              $response.response!.arrayOptStruct,
              $response.response!.arrayOptUnion,
            ));
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kProtocol_TwoWayVectorBasic_Ordinal:
        final String _name = _kProtocol_TwoWayVectorBasic_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayVectorBasic_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final Protocol$TwoWayVectorBasic$Response $response = $fidl
              .decodeMaybeLargeMessageWithCallback<
                      Protocol$TwoWayVectorBasic$Response>(
                  $message,
                  _kProtocol_TwoWayVectorBasic_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$TwoWayVectorBasic$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
            );
          });
          $completer.complete($response);
        });
        break;
      case _kProtocol_ErrorVectorBasic_Ordinal:
        final String _name = _kProtocol_ErrorVectorBasic_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorVectorBasic_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorVectorBasic_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final ProtocolErrorVectorBasicResult $response = $fidl.decodeMessage(
              $message,
              _kProtocol_ErrorVectorBasic_Type.responseInlineSize($wireFormat),
              $types[0]);
          if ($response.$tag == ProtocolErrorVectorBasicResultTag.response) {
            $completer.complete(Protocol$ErrorVectorBasic$Response(
              $response.response!.vectorUint8,
              $response.response!.vectorUint16,
              $response.response!.vectorUint32,
              $response.response!.vectorUint64,
              $response.response!.vectorInt8,
              $response.response!.vectorInt16,
              $response.response!.vectorInt32,
              $response.response!.vectorInt64,
              $response.response!.vectorFloat32,
              $response.response!.vectorFloat64,
              $response.response!.vectorString,
              $response.response!.vectorOptString,
            ));
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kProtocol_TwoWayVectorCompound_Ordinal:
        final String _name = _kProtocol_TwoWayVectorCompound_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayVectorCompound_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final Protocol$TwoWayVectorCompound$Response $response = $fidl
              .decodeMaybeLargeMessageWithCallback<
                      Protocol$TwoWayVectorCompound$Response>(
                  $message,
                  _kProtocol_TwoWayVectorCompound_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$TwoWayVectorCompound$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
            );
          });
          $completer.complete($response);
        });
        break;
      case _kProtocol_ErrorVectorCompound_Ordinal:
        final String _name = _kProtocol_ErrorVectorCompound_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorVectorCompound_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorVectorCompound_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final ProtocolErrorVectorCompoundResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kProtocol_ErrorVectorCompound_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag == ProtocolErrorVectorCompoundResultTag.response) {
            $completer.complete(Protocol$ErrorVectorCompound$Response(
              $response.response!.vectorBits,
              $response.response!.vectorEnum,
              $response.response!.vectorStruct,
              $response.response!.vectorTable,
              $response.response!.vectorUnion,
              $response.response!.vectorOptStruct,
              $response.response!.vectorOptUnion,
            ));
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kProtocol_TwoWayVectorOptional_Ordinal:
        final String _name = _kProtocol_TwoWayVectorOptional_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayVectorOptional_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final Protocol$TwoWayVectorOptional$Response $response = $fidl
              .decodeMaybeLargeMessageWithCallback<
                      Protocol$TwoWayVectorOptional$Response>(
                  $message,
                  _kProtocol_TwoWayVectorOptional_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$TwoWayVectorOptional$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
            );
          });
          $completer.complete($response);
        });
        break;
      case _kProtocol_ErrorVectorOptional_Ordinal:
        final String _name = _kProtocol_ErrorVectorOptional_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorVectorOptional_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorVectorOptional_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final ProtocolErrorVectorOptionalResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kProtocol_ErrorVectorOptional_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag == ProtocolErrorVectorOptionalResultTag.response) {
            $completer.complete(Protocol$ErrorVectorOptional$Response(
              $response.response!.optVectorUint8,
              $response.response!.optVectorString,
              $response.response!.optVectorStruct,
              $response.response!.optVectorOptStruct,
            ));
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kProtocol_TwoWayArrayVectorNested_Ordinal:
        final String _name = _kProtocol_TwoWayArrayVectorNested_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayArrayVectorNested_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final Protocol$TwoWayArrayVectorNested$Response $response = $fidl
              .decodeMaybeLargeMessageWithCallback<
                      Protocol$TwoWayArrayVectorNested$Response>(
                  $message,
                  _kProtocol_TwoWayArrayVectorNested_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$TwoWayArrayVectorNested$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
            );
          });
          $completer.complete($response);
        });
        break;
      case _kProtocol_ErrorArrayVectorNested_Ordinal:
        final String _name = _kProtocol_ErrorArrayVectorNested_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorArrayVectorNested_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorArrayVectorNested_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final ProtocolErrorArrayVectorNestedResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kProtocol_ErrorArrayVectorNested_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              ProtocolErrorArrayVectorNestedResultTag.response) {
            $completer.complete(Protocol$ErrorArrayVectorNested$Response(
              $response.response!.arrayArrayUint8,
              $response.response!.arrayVectorUint8,
              $response.response!.vectorArrayUint8,
              $response.response!.vectorVectorUint8,
            ));
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kProtocol_TwoWayResource_Ordinal:
        final String _name = _kProtocol_TwoWayResource_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayResource_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final Protocol$TwoWayResource$Response $response = $fidl
              .decodeMaybeLargeMessageWithCallback<
                      Protocol$TwoWayResource$Response>(
                  $message,
                  _kProtocol_TwoWayResource_Type.responseInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return Protocol$TwoWayResource$Response(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
              $types[12].decode($decoder, $offset, 1),
              $types[13].decode($decoder, $offset, 1),
              $types[14].decode($decoder, $offset, 1),
              $types[15].decode($decoder, $offset, 1),
              $types[16].decode($decoder, $offset, 1),
              $types[17].decode($decoder, $offset, 1),
              $types[18].decode($decoder, $offset, 1),
              $types[19].decode($decoder, $offset, 1),
              $types[20].decode($decoder, $offset, 1),
              $types[21].decode($decoder, $offset, 1),
              $types[22].decode($decoder, $offset, 1),
              $types[23].decode($decoder, $offset, 1),
              $types[24].decode($decoder, $offset, 1),
              $types[25].decode($decoder, $offset, 1),
              $types[26].decode($decoder, $offset, 1),
            );
          });
          $completer.complete($response);
        });
        break;
      case _kProtocol_ErrorResource_Ordinal:
        final String _name = _kProtocol_ErrorResource_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorResource_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorResource_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final ProtocolErrorResourceResult $response = $fidl.decodeMessage(
              $message,
              _kProtocol_ErrorResource_Type.responseInlineSize($wireFormat),
              $types[0]);
          if ($response.$tag == ProtocolErrorResourceResultTag.response) {
            $completer.complete(Protocol$ErrorResource$Response(
              $response.response!.handle,
              $response.response!.vmo,
              $response.response!.clientEnd,
              $response.response!.serverEnd,
              $response.response!.struct,
              $response.response!.table,
              $response.response!.union,
              $response.response!.optHandle,
              $response.response!.optVmo,
              $response.response!.optClientEnd,
              $response.response!.optServerEnd,
              $response.response!.optStruct,
              $response.response!.optUnion,
              $response.response!.arrayHandle,
              $response.response!.arrayVmo,
              $response.response!.arrayClientEnd,
              $response.response!.arrayServerEnd,
              $response.response!.arrayStruct,
              $response.response!.arrayTable,
              $response.response!.arrayUnion,
              $response.response!.vectorHandle,
              $response.response!.vectorVmo,
              $response.response!.vectorClientEnd,
              $response.response!.vectorServerEnd,
              $response.response!.vectorStruct,
              $response.response!.vectorTable,
              $response.response!.vectorUnion,
            ));
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<void> oneWayBasic(
      int uint8,
      int uint16,
      int uint32,
      int uint64,
      int int8,
      int int16,
      int int32,
      int int64,
      double float32,
      double float64,
      String string,
      String? optString) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_OneWayBasic_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types = _kProtocol_OneWayBasic_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kProtocol_OneWayBasic_Type.requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, uint8, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, uint16, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, uint32, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, uint64, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, int8, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, int16, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, int32, $fidl.kMessageHeaderSize, 1);
      $types[7].encode($encoder, int64, $fidl.kMessageHeaderSize, 1);
      $types[8].encode($encoder, float32, $fidl.kMessageHeaderSize, 1);
      $types[9].encode($encoder, float64, $fidl.kMessageHeaderSize, 1);
      $types[10].encode($encoder, string, $fidl.kMessageHeaderSize, 1);
      $types[11].encode($encoder, optString, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<Protocol$TwoWayBasic$Response> twoWayBasic(
      int uint8,
      int uint16,
      int uint32,
      int uint64,
      int int8,
      int int16,
      int int32,
      int int64,
      double float32,
      double float64,
      String string,
      String? optString) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_TwoWayBasic_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types = _kProtocol_TwoWayBasic_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kProtocol_TwoWayBasic_Type.requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, uint8, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, uint16, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, uint32, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, uint64, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, int8, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, int16, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, int32, $fidl.kMessageHeaderSize, 1);
      $types[7].encode($encoder, int64, $fidl.kMessageHeaderSize, 1);
      $types[8].encode($encoder, float32, $fidl.kMessageHeaderSize, 1);
      $types[9].encode($encoder, float64, $fidl.kMessageHeaderSize, 1);
      $types[10].encode($encoder, string, $fidl.kMessageHeaderSize, 1);
      $types[11].encode($encoder, optString, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<Protocol$TwoWayBasic$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<Protocol$ErrorBasic$Response> errorBasic() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_ErrorBasic_Ordinal, 0, $fidl.CallStrictness.strict);
    final $completer = $async.Completer<Protocol$ErrorBasic$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _eventBasicEventStreamController =
      $async.StreamController<Protocol$EventBasic$Response>.broadcast();
  @override
  $async.Stream<Protocol$EventBasic$Response> get eventBasic =>
      _eventBasicEventStreamController.stream;

  @override
  $async.Future<void> oneWayCompound(Bits bits, Enum enum$, Struct struct,
      Table table, Union union, Struct? optStruct, Union? optUnion) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_OneWayCompound_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_OneWayCompound_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kProtocol_OneWayCompound_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, bits, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, enum$, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, struct, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, table, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, union, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, optStruct, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, optUnion, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<Protocol$TwoWayCompound$Response> twoWayCompound(
      Bits bits,
      Enum enum$,
      Struct struct,
      Table table,
      Union union,
      Struct? optStruct,
      Union? optUnion) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_TwoWayCompound_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_TwoWayCompound_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kProtocol_TwoWayCompound_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, bits, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, enum$, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, struct, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, table, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, union, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, optStruct, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, optUnion, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<Protocol$TwoWayCompound$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<Protocol$ErrorCompound$Response> errorCompound() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_ErrorCompound_Ordinal, 0, $fidl.CallStrictness.strict);
    final $completer = $async.Completer<Protocol$ErrorCompound$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _eventCompoundEventStreamController =
      $async.StreamController<Protocol$EventCompound$Response>.broadcast();
  @override
  $async.Stream<Protocol$EventCompound$Response> get eventCompound =>
      _eventCompoundEventStreamController.stream;

  @override
  $async.Future<void> oneWayArrayBasic(
      Uint8List arrayUint8,
      Uint16List arrayUint16,
      Uint32List arrayUint32,
      Uint64List arrayUint64,
      Int8List arrayInt8,
      Int16List arrayInt16,
      Int32List arrayInt32,
      Int64List arrayInt64,
      Float32List arrayFloat32,
      Float64List arrayFloat64,
      List<String> arrayString,
      List<String?> arrayOptString) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_OneWayArrayBasic_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_OneWayArrayBasic_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kProtocol_OneWayArrayBasic_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, arrayUint8, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, arrayUint16, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, arrayUint32, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, arrayUint64, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, arrayInt8, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, arrayInt16, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, arrayInt32, $fidl.kMessageHeaderSize, 1);
      $types[7].encode($encoder, arrayInt64, $fidl.kMessageHeaderSize, 1);
      $types[8].encode($encoder, arrayFloat32, $fidl.kMessageHeaderSize, 1);
      $types[9].encode($encoder, arrayFloat64, $fidl.kMessageHeaderSize, 1);
      $types[10].encode($encoder, arrayString, $fidl.kMessageHeaderSize, 1);
      $types[11].encode($encoder, arrayOptString, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<Protocol$TwoWayArrayBasic$Response> twoWayArrayBasic(
      Uint8List arrayUint8,
      Uint16List arrayUint16,
      Uint32List arrayUint32,
      Uint64List arrayUint64,
      Int8List arrayInt8,
      Int16List arrayInt16,
      Int32List arrayInt32,
      Int64List arrayInt64,
      Float32List arrayFloat32,
      Float64List arrayFloat64,
      List<String> arrayString,
      List<String?> arrayOptString) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_TwoWayArrayBasic_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_TwoWayArrayBasic_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kProtocol_TwoWayArrayBasic_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, arrayUint8, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, arrayUint16, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, arrayUint32, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, arrayUint64, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, arrayInt8, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, arrayInt16, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, arrayInt32, $fidl.kMessageHeaderSize, 1);
      $types[7].encode($encoder, arrayInt64, $fidl.kMessageHeaderSize, 1);
      $types[8].encode($encoder, arrayFloat32, $fidl.kMessageHeaderSize, 1);
      $types[9].encode($encoder, arrayFloat64, $fidl.kMessageHeaderSize, 1);
      $types[10].encode($encoder, arrayString, $fidl.kMessageHeaderSize, 1);
      $types[11].encode($encoder, arrayOptString, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<Protocol$TwoWayArrayBasic$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<Protocol$ErrorArrayBasic$Response> errorArrayBasic() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_ErrorArrayBasic_Ordinal, 0, $fidl.CallStrictness.strict);
    final $completer = $async.Completer<Protocol$ErrorArrayBasic$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _eventArrayBasicEventStreamController =
      $async.StreamController<Protocol$EventArrayBasic$Response>.broadcast();
  @override
  $async.Stream<Protocol$EventArrayBasic$Response> get eventArrayBasic =>
      _eventArrayBasicEventStreamController.stream;

  @override
  $async.Future<void> oneWayArrayCompound(
      List<Bits> arrayBits,
      List<Enum> arrayEnum,
      List<Struct> arrayStruct,
      List<Table> arrayTable,
      List<Union> arrayUnion,
      List<Struct?> arrayOptStruct,
      List<Union?> arrayOptUnion) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_OneWayArrayCompound_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_OneWayArrayCompound_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kProtocol_OneWayArrayCompound_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, arrayBits, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, arrayEnum, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, arrayStruct, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, arrayTable, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, arrayUnion, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, arrayOptStruct, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, arrayOptUnion, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<Protocol$TwoWayArrayCompound$Response> twoWayArrayCompound(
      List<Bits> arrayBits,
      List<Enum> arrayEnum,
      List<Struct> arrayStruct,
      List<Table> arrayTable,
      List<Union> arrayUnion,
      List<Struct?> arrayOptStruct,
      List<Union?> arrayOptUnion) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_TwoWayArrayCompound_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_TwoWayArrayCompound_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kProtocol_TwoWayArrayCompound_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, arrayBits, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, arrayEnum, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, arrayStruct, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, arrayTable, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, arrayUnion, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, arrayOptStruct, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, arrayOptUnion, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<Protocol$TwoWayArrayCompound$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<Protocol$ErrorArrayCompound$Response> errorArrayCompound() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_ErrorArrayCompound_Ordinal, 0, $fidl.CallStrictness.strict);
    final $completer = $async.Completer<Protocol$ErrorArrayCompound$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _eventArrayCompoundEventStreamController =
      $async.StreamController<Protocol$EventArrayCompound$Response>.broadcast();
  @override
  $async.Stream<Protocol$EventArrayCompound$Response> get eventArrayCompound =>
      _eventArrayCompoundEventStreamController.stream;

  @override
  $async.Future<void> oneWayVectorBasic(
      Uint8List vectorUint8,
      Uint16List vectorUint16,
      Uint32List vectorUint32,
      Uint64List vectorUint64,
      Int8List vectorInt8,
      Int16List vectorInt16,
      Int32List vectorInt32,
      Int64List vectorInt64,
      Float32List vectorFloat32,
      Float64List vectorFloat64,
      List<String> vectorString,
      List<String?> vectorOptString) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_OneWayVectorBasic_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_OneWayVectorBasic_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kProtocol_OneWayVectorBasic_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, vectorUint8, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, vectorUint16, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, vectorUint32, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, vectorUint64, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, vectorInt8, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, vectorInt16, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, vectorInt32, $fidl.kMessageHeaderSize, 1);
      $types[7].encode($encoder, vectorInt64, $fidl.kMessageHeaderSize, 1);
      $types[8].encode($encoder, vectorFloat32, $fidl.kMessageHeaderSize, 1);
      $types[9].encode($encoder, vectorFloat64, $fidl.kMessageHeaderSize, 1);
      $types[10].encode($encoder, vectorString, $fidl.kMessageHeaderSize, 1);
      $types[11].encode($encoder, vectorOptString, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<Protocol$TwoWayVectorBasic$Response> twoWayVectorBasic(
      Uint8List vectorUint8,
      Uint16List vectorUint16,
      Uint32List vectorUint32,
      Uint64List vectorUint64,
      Int8List vectorInt8,
      Int16List vectorInt16,
      Int32List vectorInt32,
      Int64List vectorInt64,
      Float32List vectorFloat32,
      Float64List vectorFloat64,
      List<String> vectorString,
      List<String?> vectorOptString) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_TwoWayVectorBasic_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_TwoWayVectorBasic_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kProtocol_TwoWayVectorBasic_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, vectorUint8, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, vectorUint16, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, vectorUint32, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, vectorUint64, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, vectorInt8, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, vectorInt16, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, vectorInt32, $fidl.kMessageHeaderSize, 1);
      $types[7].encode($encoder, vectorInt64, $fidl.kMessageHeaderSize, 1);
      $types[8].encode($encoder, vectorFloat32, $fidl.kMessageHeaderSize, 1);
      $types[9].encode($encoder, vectorFloat64, $fidl.kMessageHeaderSize, 1);
      $types[10].encode($encoder, vectorString, $fidl.kMessageHeaderSize, 1);
      $types[11].encode($encoder, vectorOptString, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<Protocol$TwoWayVectorBasic$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<Protocol$ErrorVectorBasic$Response> errorVectorBasic() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_ErrorVectorBasic_Ordinal, 0, $fidl.CallStrictness.strict);
    final $completer = $async.Completer<Protocol$ErrorVectorBasic$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _eventVectorBasicEventStreamController =
      $async.StreamController<Protocol$EventVectorBasic$Response>.broadcast();
  @override
  $async.Stream<Protocol$EventVectorBasic$Response> get eventVectorBasic =>
      _eventVectorBasicEventStreamController.stream;

  @override
  $async.Future<void> oneWayVectorCompound(
      List<Bits> vectorBits,
      List<Enum> vectorEnum,
      List<Struct> vectorStruct,
      List<Table> vectorTable,
      List<Union> vectorUnion,
      List<Struct?> vectorOptStruct,
      List<Union?> vectorOptUnion) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kProtocol_OneWayVectorCompound_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_OneWayVectorCompound_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kProtocol_OneWayVectorCompound_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, vectorBits, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, vectorEnum, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, vectorStruct, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, vectorTable, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, vectorUnion, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, vectorOptStruct, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, vectorOptUnion, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<Protocol$TwoWayVectorCompound$Response> twoWayVectorCompound(
      List<Bits> vectorBits,
      List<Enum> vectorEnum,
      List<Struct> vectorStruct,
      List<Table> vectorTable,
      List<Union> vectorUnion,
      List<Struct?> vectorOptStruct,
      List<Union?> vectorOptUnion) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kProtocol_TwoWayVectorCompound_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_TwoWayVectorCompound_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kProtocol_TwoWayVectorCompound_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, vectorBits, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, vectorEnum, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, vectorStruct, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, vectorTable, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, vectorUnion, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, vectorOptStruct, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, vectorOptUnion, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<Protocol$TwoWayVectorCompound$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<Protocol$ErrorVectorCompound$Response> errorVectorCompound() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_ErrorVectorCompound_Ordinal, 0, $fidl.CallStrictness.strict);
    final $completer =
        $async.Completer<Protocol$ErrorVectorCompound$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _eventVectorCompoundEventStreamController = $async
      .StreamController<Protocol$EventVectorCompound$Response>.broadcast();
  @override
  $async.Stream<Protocol$EventVectorCompound$Response>
      get eventVectorCompound =>
          _eventVectorCompoundEventStreamController.stream;

  @override
  $async.Future<void> oneWayVectorOptional(
      Uint8List? optVectorUint8,
      List<String>? optVectorString,
      List<Struct>? optVectorStruct,
      List<Struct?>? optVectorOptStruct) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kProtocol_OneWayVectorOptional_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_OneWayVectorOptional_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kProtocol_OneWayVectorOptional_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, optVectorUint8, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, optVectorString, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, optVectorStruct, $fidl.kMessageHeaderSize, 1);
      $types[3]
          .encode($encoder, optVectorOptStruct, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<Protocol$TwoWayVectorOptional$Response> twoWayVectorOptional(
      Uint8List? optVectorUint8,
      List<String>? optVectorString,
      List<Struct>? optVectorStruct,
      List<Struct?>? optVectorOptStruct) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kProtocol_TwoWayVectorOptional_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_TwoWayVectorOptional_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kProtocol_TwoWayVectorOptional_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, optVectorUint8, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, optVectorString, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, optVectorStruct, $fidl.kMessageHeaderSize, 1);
      $types[3]
          .encode($encoder, optVectorOptStruct, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<Protocol$TwoWayVectorOptional$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<Protocol$ErrorVectorOptional$Response> errorVectorOptional() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_ErrorVectorOptional_Ordinal, 0, $fidl.CallStrictness.strict);
    final $completer =
        $async.Completer<Protocol$ErrorVectorOptional$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _eventVectorOptionalEventStreamController = $async
      .StreamController<Protocol$EventVectorOptional$Response>.broadcast();
  @override
  $async.Stream<Protocol$EventVectorOptional$Response>
      get eventVectorOptional =>
          _eventVectorOptionalEventStreamController.stream;

  @override
  $async.Future<void> oneWayArrayVectorNested(
      List<Uint8List> arrayArrayUint8,
      List<Uint8List> arrayVectorUint8,
      List<Uint8List> vectorArrayUint8,
      List<Uint8List> vectorVectorUint8) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kProtocol_OneWayArrayVectorNested_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_OneWayArrayVectorNested_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kProtocol_OneWayArrayVectorNested_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, arrayArrayUint8, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, arrayVectorUint8, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, vectorArrayUint8, $fidl.kMessageHeaderSize, 1);
      $types[3]
          .encode($encoder, vectorVectorUint8, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<Protocol$TwoWayArrayVectorNested$Response>
      twoWayArrayVectorNested(
          List<Uint8List> arrayArrayUint8,
          List<Uint8List> arrayVectorUint8,
          List<Uint8List> vectorArrayUint8,
          List<Uint8List> vectorVectorUint8) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kProtocol_TwoWayArrayVectorNested_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_TwoWayArrayVectorNested_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kProtocol_TwoWayArrayVectorNested_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, arrayArrayUint8, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, arrayVectorUint8, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, vectorArrayUint8, $fidl.kMessageHeaderSize, 1);
      $types[3]
          .encode($encoder, vectorVectorUint8, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<Protocol$TwoWayArrayVectorNested$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<Protocol$ErrorArrayVectorNested$Response>
      errorArrayVectorNested() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kProtocol_ErrorArrayVectorNested_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final $completer =
        $async.Completer<Protocol$ErrorArrayVectorNested$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _eventArrayVectorNestedEventStreamController = $async
      .StreamController<Protocol$EventArrayVectorNested$Response>.broadcast();
  @override
  $async.Stream<Protocol$EventArrayVectorNested$Response>
      get eventArrayVectorNested =>
          _eventArrayVectorNestedEventStreamController.stream;

  @override
  $async.Future<void> oneWayResource(
      $zircon.Handle handle,
      $zircon.Vmo vmo,
      $fidl.InterfaceHandle<Protocol> clientEnd,
      $fidl.InterfaceRequest<Protocol> serverEnd,
      ResourceStruct struct,
      ResourceTable table,
      ResourceUnion union,
      $zircon.Handle? optHandle,
      $zircon.Vmo? optVmo,
      $fidl.InterfaceHandle<Protocol>? optClientEnd,
      $fidl.InterfaceRequest<Protocol>? optServerEnd,
      ResourceStruct? optStruct,
      ResourceUnion? optUnion,
      List<$zircon.Handle> arrayHandle,
      List<$zircon.Vmo> arrayVmo,
      List<$fidl.InterfaceHandle<Protocol>> arrayClientEnd,
      List<$fidl.InterfaceRequest<Protocol>> arrayServerEnd,
      List<ResourceStruct> arrayStruct,
      List<ResourceTable> arrayTable,
      List<ResourceUnion> arrayUnion,
      List<$zircon.Handle> vectorHandle,
      List<$zircon.Vmo> vectorVmo,
      List<$fidl.InterfaceHandle<Protocol>> vectorClientEnd,
      List<$fidl.InterfaceRequest<Protocol>> vectorServerEnd,
      List<ResourceStruct> vectorStruct,
      List<ResourceTable> vectorTable,
      List<ResourceUnion> vectorUnion) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_OneWayResource_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_OneWayResource_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kProtocol_OneWayResource_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, handle, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, vmo, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, clientEnd, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, serverEnd, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, struct, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, table, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, union, $fidl.kMessageHeaderSize, 1);
      $types[7].encode($encoder, optHandle, $fidl.kMessageHeaderSize, 1);
      $types[8].encode($encoder, optVmo, $fidl.kMessageHeaderSize, 1);
      $types[9].encode($encoder, optClientEnd, $fidl.kMessageHeaderSize, 1);
      $types[10].encode($encoder, optServerEnd, $fidl.kMessageHeaderSize, 1);
      $types[11].encode($encoder, optStruct, $fidl.kMessageHeaderSize, 1);
      $types[12].encode($encoder, optUnion, $fidl.kMessageHeaderSize, 1);
      $types[13].encode($encoder, arrayHandle, $fidl.kMessageHeaderSize, 1);
      $types[14].encode($encoder, arrayVmo, $fidl.kMessageHeaderSize, 1);
      $types[15].encode($encoder, arrayClientEnd, $fidl.kMessageHeaderSize, 1);
      $types[16].encode($encoder, arrayServerEnd, $fidl.kMessageHeaderSize, 1);
      $types[17].encode($encoder, arrayStruct, $fidl.kMessageHeaderSize, 1);
      $types[18].encode($encoder, arrayTable, $fidl.kMessageHeaderSize, 1);
      $types[19].encode($encoder, arrayUnion, $fidl.kMessageHeaderSize, 1);
      $types[20].encode($encoder, vectorHandle, $fidl.kMessageHeaderSize, 1);
      $types[21].encode($encoder, vectorVmo, $fidl.kMessageHeaderSize, 1);
      $types[22].encode($encoder, vectorClientEnd, $fidl.kMessageHeaderSize, 1);
      $types[23].encode($encoder, vectorServerEnd, $fidl.kMessageHeaderSize, 1);
      $types[24].encode($encoder, vectorStruct, $fidl.kMessageHeaderSize, 1);
      $types[25].encode($encoder, vectorTable, $fidl.kMessageHeaderSize, 1);
      $types[26].encode($encoder, vectorUnion, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<Protocol$TwoWayResource$Response> twoWayResource(
      $zircon.Handle handle,
      $zircon.Vmo vmo,
      $fidl.InterfaceHandle<Protocol> clientEnd,
      $fidl.InterfaceRequest<Protocol> serverEnd,
      ResourceStruct struct,
      ResourceTable table,
      ResourceUnion union,
      $zircon.Handle? optHandle,
      $zircon.Vmo? optVmo,
      $fidl.InterfaceHandle<Protocol>? optClientEnd,
      $fidl.InterfaceRequest<Protocol>? optServerEnd,
      ResourceStruct? optStruct,
      ResourceUnion? optUnion,
      List<$zircon.Handle> arrayHandle,
      List<$zircon.Vmo> arrayVmo,
      List<$fidl.InterfaceHandle<Protocol>> arrayClientEnd,
      List<$fidl.InterfaceRequest<Protocol>> arrayServerEnd,
      List<ResourceStruct> arrayStruct,
      List<ResourceTable> arrayTable,
      List<ResourceUnion> arrayUnion,
      List<$zircon.Handle> vectorHandle,
      List<$zircon.Vmo> vectorVmo,
      List<$fidl.InterfaceHandle<Protocol>> vectorClientEnd,
      List<$fidl.InterfaceRequest<Protocol>> vectorServerEnd,
      List<ResourceStruct> vectorStruct,
      List<ResourceTable> vectorTable,
      List<ResourceUnion> vectorUnion) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_TwoWayResource_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kProtocol_TwoWayResource_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kProtocol_TwoWayResource_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, handle, $fidl.kMessageHeaderSize, 1);
      $types[1].encode($encoder, vmo, $fidl.kMessageHeaderSize, 1);
      $types[2].encode($encoder, clientEnd, $fidl.kMessageHeaderSize, 1);
      $types[3].encode($encoder, serverEnd, $fidl.kMessageHeaderSize, 1);
      $types[4].encode($encoder, struct, $fidl.kMessageHeaderSize, 1);
      $types[5].encode($encoder, table, $fidl.kMessageHeaderSize, 1);
      $types[6].encode($encoder, union, $fidl.kMessageHeaderSize, 1);
      $types[7].encode($encoder, optHandle, $fidl.kMessageHeaderSize, 1);
      $types[8].encode($encoder, optVmo, $fidl.kMessageHeaderSize, 1);
      $types[9].encode($encoder, optClientEnd, $fidl.kMessageHeaderSize, 1);
      $types[10].encode($encoder, optServerEnd, $fidl.kMessageHeaderSize, 1);
      $types[11].encode($encoder, optStruct, $fidl.kMessageHeaderSize, 1);
      $types[12].encode($encoder, optUnion, $fidl.kMessageHeaderSize, 1);
      $types[13].encode($encoder, arrayHandle, $fidl.kMessageHeaderSize, 1);
      $types[14].encode($encoder, arrayVmo, $fidl.kMessageHeaderSize, 1);
      $types[15].encode($encoder, arrayClientEnd, $fidl.kMessageHeaderSize, 1);
      $types[16].encode($encoder, arrayServerEnd, $fidl.kMessageHeaderSize, 1);
      $types[17].encode($encoder, arrayStruct, $fidl.kMessageHeaderSize, 1);
      $types[18].encode($encoder, arrayTable, $fidl.kMessageHeaderSize, 1);
      $types[19].encode($encoder, arrayUnion, $fidl.kMessageHeaderSize, 1);
      $types[20].encode($encoder, vectorHandle, $fidl.kMessageHeaderSize, 1);
      $types[21].encode($encoder, vectorVmo, $fidl.kMessageHeaderSize, 1);
      $types[22].encode($encoder, vectorClientEnd, $fidl.kMessageHeaderSize, 1);
      $types[23].encode($encoder, vectorServerEnd, $fidl.kMessageHeaderSize, 1);
      $types[24].encode($encoder, vectorStruct, $fidl.kMessageHeaderSize, 1);
      $types[25].encode($encoder, vectorTable, $fidl.kMessageHeaderSize, 1);
      $types[26].encode($encoder, vectorUnion, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<Protocol$TwoWayResource$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<Protocol$ErrorResource$Response> errorResource() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kProtocol_ErrorResource_Ordinal, 0, $fidl.CallStrictness.strict);
    final $completer = $async.Completer<Protocol$ErrorResource$Response>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _eventResourceEventStreamController =
      $async.StreamController<Protocol$EventResource$Response>.broadcast();
  @override
  $async.Stream<Protocol$EventResource$Response> get eventResource =>
      _eventResourceEventStreamController.stream;
}

class ProtocolBinding extends $fidl.AsyncBinding<Protocol> {
  ProtocolBinding() : super(r"Protocol") {
    final List<$async.StreamSubscription<dynamic>> $subscriptions = [];
    void $unsubscribe() {
      for (final $sub in $subscriptions) {
        $sub.cancel();
      }
      $subscriptions.clear();
    }

    whenBound.then((_) {
      final impl = this.impl;
      if (impl != null) {
        final _eventBasic_stream = impl.eventBasic;
        if (_eventBasic_stream != null) {
          $subscriptions.add(_eventBasic_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kProtocol_EventBasic_Ordinal, 0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_EventBasic_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_EventBasic_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.uint8, $fidl.kMessageHeaderSize, 1);
              $types[1].encode(
                  $encoder, $response.uint16, $fidl.kMessageHeaderSize, 1);
              $types[2].encode(
                  $encoder, $response.uint32, $fidl.kMessageHeaderSize, 1);
              $types[3].encode(
                  $encoder, $response.uint64, $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.int8, $fidl.kMessageHeaderSize, 1);
              $types[5].encode(
                  $encoder, $response.int16, $fidl.kMessageHeaderSize, 1);
              $types[6].encode(
                  $encoder, $response.int32, $fidl.kMessageHeaderSize, 1);
              $types[7].encode(
                  $encoder, $response.int64, $fidl.kMessageHeaderSize, 1);
              $types[8].encode(
                  $encoder, $response.float32, $fidl.kMessageHeaderSize, 1);
              $types[9].encode(
                  $encoder, $response.float64, $fidl.kMessageHeaderSize, 1);
              $types[10].encode(
                  $encoder, $response.string, $fidl.kMessageHeaderSize, 1);
              $types[11].encode(
                  $encoder, $response.optString, $fidl.kMessageHeaderSize, 1);
            });
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(_kProtocol_EventBasic_Type.name, _e, close);
          }));
        }
        final _eventCompound_stream = impl.eventCompound;
        if (_eventCompound_stream != null) {
          $subscriptions.add(_eventCompound_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_EventCompound_Ordinal, 0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_EventCompound_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_EventCompound_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.bits, $fidl.kMessageHeaderSize, 1);
              $types[1].encode(
                  $encoder, $response.enum$, $fidl.kMessageHeaderSize, 1);
              $types[2].encode(
                  $encoder, $response.struct, $fidl.kMessageHeaderSize, 1);
              $types[3].encode(
                  $encoder, $response.table, $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.union, $fidl.kMessageHeaderSize, 1);
              $types[5].encode(
                  $encoder, $response.optStruct, $fidl.kMessageHeaderSize, 1);
              $types[6].encode(
                  $encoder, $response.optUnion, $fidl.kMessageHeaderSize, 1);
            });
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kProtocol_EventCompound_Type.name, _e, close);
          }));
        }
        final _eventArrayBasic_stream = impl.eventArrayBasic;
        if (_eventArrayBasic_stream != null) {
          $subscriptions.add(_eventArrayBasic_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_EventArrayBasic_Ordinal, 0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_EventArrayBasic_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_EventArrayBasic_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.arrayUint8, $fidl.kMessageHeaderSize, 1);
              $types[1].encode(
                  $encoder, $response.arrayUint16, $fidl.kMessageHeaderSize, 1);
              $types[2].encode(
                  $encoder, $response.arrayUint32, $fidl.kMessageHeaderSize, 1);
              $types[3].encode(
                  $encoder, $response.arrayUint64, $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.arrayInt8, $fidl.kMessageHeaderSize, 1);
              $types[5].encode(
                  $encoder, $response.arrayInt16, $fidl.kMessageHeaderSize, 1);
              $types[6].encode(
                  $encoder, $response.arrayInt32, $fidl.kMessageHeaderSize, 1);
              $types[7].encode(
                  $encoder, $response.arrayInt64, $fidl.kMessageHeaderSize, 1);
              $types[8].encode($encoder, $response.arrayFloat32,
                  $fidl.kMessageHeaderSize, 1);
              $types[9].encode($encoder, $response.arrayFloat64,
                  $fidl.kMessageHeaderSize, 1);
              $types[10].encode(
                  $encoder, $response.arrayString, $fidl.kMessageHeaderSize, 1);
              $types[11].encode($encoder, $response.arrayOptString,
                  $fidl.kMessageHeaderSize, 1);
            });
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kProtocol_EventArrayBasic_Type.name, _e, close);
          }));
        }
        final _eventArrayCompound_stream = impl.eventArrayCompound;
        if (_eventArrayCompound_stream != null) {
          $subscriptions.add(_eventArrayCompound_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_EventArrayCompound_Ordinal,
                0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_EventArrayCompound_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_EventArrayCompound_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.arrayBits, $fidl.kMessageHeaderSize, 1);
              $types[1].encode(
                  $encoder, $response.arrayEnum, $fidl.kMessageHeaderSize, 1);
              $types[2].encode(
                  $encoder, $response.arrayStruct, $fidl.kMessageHeaderSize, 1);
              $types[3].encode(
                  $encoder, $response.arrayTable, $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.arrayUnion, $fidl.kMessageHeaderSize, 1);
              $types[5].encode($encoder, $response.arrayOptStruct,
                  $fidl.kMessageHeaderSize, 1);
              $types[6].encode($encoder, $response.arrayOptUnion,
                  $fidl.kMessageHeaderSize, 1);
            });
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kProtocol_EventArrayCompound_Type.name, _e, close);
          }));
        }
        final _eventVectorBasic_stream = impl.eventVectorBasic;
        if (_eventVectorBasic_stream != null) {
          $subscriptions.add(_eventVectorBasic_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_EventVectorBasic_Ordinal, 0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_EventVectorBasic_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_EventVectorBasic_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.vectorUint8, $fidl.kMessageHeaderSize, 1);
              $types[1].encode($encoder, $response.vectorUint16,
                  $fidl.kMessageHeaderSize, 1);
              $types[2].encode($encoder, $response.vectorUint32,
                  $fidl.kMessageHeaderSize, 1);
              $types[3].encode($encoder, $response.vectorUint64,
                  $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.vectorInt8, $fidl.kMessageHeaderSize, 1);
              $types[5].encode(
                  $encoder, $response.vectorInt16, $fidl.kMessageHeaderSize, 1);
              $types[6].encode(
                  $encoder, $response.vectorInt32, $fidl.kMessageHeaderSize, 1);
              $types[7].encode(
                  $encoder, $response.vectorInt64, $fidl.kMessageHeaderSize, 1);
              $types[8].encode($encoder, $response.vectorFloat32,
                  $fidl.kMessageHeaderSize, 1);
              $types[9].encode($encoder, $response.vectorFloat64,
                  $fidl.kMessageHeaderSize, 1);
              $types[10].encode($encoder, $response.vectorString,
                  $fidl.kMessageHeaderSize, 1);
              $types[11].encode($encoder, $response.vectorOptString,
                  $fidl.kMessageHeaderSize, 1);
            });
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kProtocol_EventVectorBasic_Type.name, _e, close);
          }));
        }
        final _eventVectorCompound_stream = impl.eventVectorCompound;
        if (_eventVectorCompound_stream != null) {
          $subscriptions.add(_eventVectorCompound_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_EventVectorCompound_Ordinal,
                0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_EventVectorCompound_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_EventVectorCompound_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.vectorBits, $fidl.kMessageHeaderSize, 1);
              $types[1].encode(
                  $encoder, $response.vectorEnum, $fidl.kMessageHeaderSize, 1);
              $types[2].encode($encoder, $response.vectorStruct,
                  $fidl.kMessageHeaderSize, 1);
              $types[3].encode(
                  $encoder, $response.vectorTable, $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.vectorUnion, $fidl.kMessageHeaderSize, 1);
              $types[5].encode($encoder, $response.vectorOptStruct,
                  $fidl.kMessageHeaderSize, 1);
              $types[6].encode($encoder, $response.vectorOptUnion,
                  $fidl.kMessageHeaderSize, 1);
            });
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kProtocol_EventVectorCompound_Type.name, _e, close);
          }));
        }
        final _eventVectorOptional_stream = impl.eventVectorOptional;
        if (_eventVectorOptional_stream != null) {
          $subscriptions.add(_eventVectorOptional_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_EventVectorOptional_Ordinal,
                0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_EventVectorOptional_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_EventVectorOptional_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode($encoder, $response.optVectorUint8,
                  $fidl.kMessageHeaderSize, 1);
              $types[1].encode($encoder, $response.optVectorString,
                  $fidl.kMessageHeaderSize, 1);
              $types[2].encode($encoder, $response.optVectorStruct,
                  $fidl.kMessageHeaderSize, 1);
              $types[3].encode($encoder, $response.optVectorOptStruct,
                  $fidl.kMessageHeaderSize, 1);
            });
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kProtocol_EventVectorOptional_Type.name, _e, close);
          }));
        }
        final _eventArrayVectorNested_stream = impl.eventArrayVectorNested;
        if (_eventArrayVectorNested_stream != null) {
          $subscriptions.add(_eventArrayVectorNested_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kProtocol_EventArrayVectorNested_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_EventArrayVectorNested_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_EventArrayVectorNested_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode($encoder, $response.arrayArrayUint8,
                  $fidl.kMessageHeaderSize, 1);
              $types[1].encode($encoder, $response.arrayVectorUint8,
                  $fidl.kMessageHeaderSize, 1);
              $types[2].encode($encoder, $response.vectorArrayUint8,
                  $fidl.kMessageHeaderSize, 1);
              $types[3].encode($encoder, $response.vectorVectorUint8,
                  $fidl.kMessageHeaderSize, 1);
            });
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kProtocol_EventArrayVectorNested_Type.name, _e, close);
          }));
        }
        final _eventResource_stream = impl.eventResource;
        if (_eventResource_stream != null) {
          $subscriptions.add(_eventResource_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_EventResource_Ordinal, 0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_EventResource_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_EventResource_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.handle, $fidl.kMessageHeaderSize, 1);
              $types[1]
                  .encode($encoder, $response.vmo, $fidl.kMessageHeaderSize, 1);
              $types[2].encode(
                  $encoder, $response.clientEnd, $fidl.kMessageHeaderSize, 1);
              $types[3].encode(
                  $encoder, $response.serverEnd, $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.struct, $fidl.kMessageHeaderSize, 1);
              $types[5].encode(
                  $encoder, $response.table, $fidl.kMessageHeaderSize, 1);
              $types[6].encode(
                  $encoder, $response.union, $fidl.kMessageHeaderSize, 1);
              $types[7].encode(
                  $encoder, $response.optHandle, $fidl.kMessageHeaderSize, 1);
              $types[8].encode(
                  $encoder, $response.optVmo, $fidl.kMessageHeaderSize, 1);
              $types[9].encode($encoder, $response.optClientEnd,
                  $fidl.kMessageHeaderSize, 1);
              $types[10].encode($encoder, $response.optServerEnd,
                  $fidl.kMessageHeaderSize, 1);
              $types[11].encode(
                  $encoder, $response.optStruct, $fidl.kMessageHeaderSize, 1);
              $types[12].encode(
                  $encoder, $response.optUnion, $fidl.kMessageHeaderSize, 1);
              $types[13].encode(
                  $encoder, $response.arrayHandle, $fidl.kMessageHeaderSize, 1);
              $types[14].encode(
                  $encoder, $response.arrayVmo, $fidl.kMessageHeaderSize, 1);
              $types[15].encode($encoder, $response.arrayClientEnd,
                  $fidl.kMessageHeaderSize, 1);
              $types[16].encode($encoder, $response.arrayServerEnd,
                  $fidl.kMessageHeaderSize, 1);
              $types[17].encode(
                  $encoder, $response.arrayStruct, $fidl.kMessageHeaderSize, 1);
              $types[18].encode(
                  $encoder, $response.arrayTable, $fidl.kMessageHeaderSize, 1);
              $types[19].encode(
                  $encoder, $response.arrayUnion, $fidl.kMessageHeaderSize, 1);
              $types[20].encode($encoder, $response.vectorHandle,
                  $fidl.kMessageHeaderSize, 1);
              $types[21].encode(
                  $encoder, $response.vectorVmo, $fidl.kMessageHeaderSize, 1);
              $types[22].encode($encoder, $response.vectorClientEnd,
                  $fidl.kMessageHeaderSize, 1);
              $types[23].encode($encoder, $response.vectorServerEnd,
                  $fidl.kMessageHeaderSize, 1);
              $types[24].encode($encoder, $response.vectorStruct,
                  $fidl.kMessageHeaderSize, 1);
              $types[25].encode(
                  $encoder, $response.vectorTable, $fidl.kMessageHeaderSize, 1);
              $types[26].encode(
                  $encoder, $response.vectorUnion, $fidl.kMessageHeaderSize, 1);
            });
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kProtocol_EventResource_Type.name, _e, close);
          }));
        }
      }
    });
    whenClosed.then((_) => $unsubscribe());
  }

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    final $wireFormat = $message.parseWireFormat();
    switch ($message.ordinal) {
      case _kProtocol_OneWayBasic_Ordinal:
        final String _name = _kProtocol_OneWayBasic_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_OneWayBasic_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kProtocol_OneWayBasic_Type.requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayBasic(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kProtocol_TwoWayBasic_Ordinal:
        final String _name = _kProtocol_TwoWayBasic_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayBasic_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<Protocol$TwoWayBasic$Response> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<
                      $async.Future<Protocol$TwoWayBasic$Response>>($message,
                  _kProtocol_TwoWayBasic_Type.requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayBasic(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_TwoWayBasic_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_TwoWayBasic_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_TwoWayBasic_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.uint8, $fidl.kMessageHeaderSize, 1);
              $types[1].encode(
                  $encoder, $response.uint16, $fidl.kMessageHeaderSize, 1);
              $types[2].encode(
                  $encoder, $response.uint32, $fidl.kMessageHeaderSize, 1);
              $types[3].encode(
                  $encoder, $response.uint64, $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.int8, $fidl.kMessageHeaderSize, 1);
              $types[5].encode(
                  $encoder, $response.int16, $fidl.kMessageHeaderSize, 1);
              $types[6].encode(
                  $encoder, $response.int32, $fidl.kMessageHeaderSize, 1);
              $types[7].encode(
                  $encoder, $response.int64, $fidl.kMessageHeaderSize, 1);
              $types[8].encode(
                  $encoder, $response.float32, $fidl.kMessageHeaderSize, 1);
              $types[9].encode(
                  $encoder, $response.float64, $fidl.kMessageHeaderSize, 1);
              $types[10].encode(
                  $encoder, $response.string, $fidl.kMessageHeaderSize, 1);
              $types[11].encode(
                  $encoder, $response.optString, $fidl.kMessageHeaderSize, 1);
            });
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_ErrorBasic_Ordinal:
        final String _name = _kProtocol_ErrorBasic_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorBasic_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorBasic_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<Protocol$ErrorBasic$Response> $future = $fidl
              .decodeMessageWithCallback<
                      $async.Future<Protocol$ErrorBasic$Response>>($message,
                  _kProtocol_ErrorBasic_Type.requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.errorBasic();
          });
          $future.then(($responseValue) {
            return ProtocolErrorBasicResult.withResponse(Basic(
              uint8: $responseValue.uint8,
              uint16: $responseValue.uint16,
              uint32: $responseValue.uint32,
              uint64: $responseValue.uint64,
              int8: $responseValue.int8,
              int16: $responseValue.int16,
              int32: $responseValue.int32,
              int64: $responseValue.int64,
              float32: $responseValue.float32,
              float64: $responseValue.float64,
              string: $responseValue.string,
              optString: $responseValue.optString,
            ));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return ProtocolErrorBasicResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_ErrorBasic_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_ErrorBasic_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kProtocol_ErrorBasic_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_OneWayCompound_Ordinal:
        final String _name = _kProtocol_OneWayCompound_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_OneWayCompound_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kProtocol_OneWayCompound_Type.requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayCompound(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kProtocol_TwoWayCompound_Ordinal:
        final String _name = _kProtocol_TwoWayCompound_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayCompound_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<Protocol$TwoWayCompound$Response> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<
                      $async.Future<Protocol$TwoWayCompound$Response>>($message,
                  _kProtocol_TwoWayCompound_Type.requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayCompound(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_TwoWayCompound_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_TwoWayCompound_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_TwoWayCompound_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.bits, $fidl.kMessageHeaderSize, 1);
              $types[1].encode(
                  $encoder, $response.enum$, $fidl.kMessageHeaderSize, 1);
              $types[2].encode(
                  $encoder, $response.struct, $fidl.kMessageHeaderSize, 1);
              $types[3].encode(
                  $encoder, $response.table, $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.union, $fidl.kMessageHeaderSize, 1);
              $types[5].encode(
                  $encoder, $response.optStruct, $fidl.kMessageHeaderSize, 1);
              $types[6].encode(
                  $encoder, $response.optUnion, $fidl.kMessageHeaderSize, 1);
            });
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_ErrorCompound_Ordinal:
        final String _name = _kProtocol_ErrorCompound_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorCompound_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorCompound_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<Protocol$ErrorCompound$Response> $future = $fidl
              .decodeMessageWithCallback<
                      $async.Future<Protocol$ErrorCompound$Response>>($message,
                  _kProtocol_ErrorCompound_Type.requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.errorCompound();
          });
          $future.then(($responseValue) {
            return ProtocolErrorCompoundResult.withResponse(Compound(
              bits: $responseValue.bits,
              enum$: $responseValue.enum$,
              struct: $responseValue.struct,
              table: $responseValue.table,
              union: $responseValue.union,
              optStruct: $responseValue.optStruct,
              optUnion: $responseValue.optUnion,
            ));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return ProtocolErrorCompoundResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_ErrorCompound_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_ErrorCompound_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kProtocol_ErrorCompound_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_OneWayArrayBasic_Ordinal:
        final String _name = _kProtocol_OneWayArrayBasic_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_OneWayArrayBasic_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kProtocol_OneWayArrayBasic_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayArrayBasic(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kProtocol_TwoWayArrayBasic_Ordinal:
        final String _name = _kProtocol_TwoWayArrayBasic_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayArrayBasic_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<Protocol$TwoWayArrayBasic$Response> $future =
              $fidl.decodeMaybeLargeMessageWithCallback<
                      $async.Future<Protocol$TwoWayArrayBasic$Response>>(
                  $message,
                  _kProtocol_TwoWayArrayBasic_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayArrayBasic(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_TwoWayArrayBasic_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_TwoWayArrayBasic_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_TwoWayArrayBasic_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.arrayUint8, $fidl.kMessageHeaderSize, 1);
              $types[1].encode(
                  $encoder, $response.arrayUint16, $fidl.kMessageHeaderSize, 1);
              $types[2].encode(
                  $encoder, $response.arrayUint32, $fidl.kMessageHeaderSize, 1);
              $types[3].encode(
                  $encoder, $response.arrayUint64, $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.arrayInt8, $fidl.kMessageHeaderSize, 1);
              $types[5].encode(
                  $encoder, $response.arrayInt16, $fidl.kMessageHeaderSize, 1);
              $types[6].encode(
                  $encoder, $response.arrayInt32, $fidl.kMessageHeaderSize, 1);
              $types[7].encode(
                  $encoder, $response.arrayInt64, $fidl.kMessageHeaderSize, 1);
              $types[8].encode($encoder, $response.arrayFloat32,
                  $fidl.kMessageHeaderSize, 1);
              $types[9].encode($encoder, $response.arrayFloat64,
                  $fidl.kMessageHeaderSize, 1);
              $types[10].encode(
                  $encoder, $response.arrayString, $fidl.kMessageHeaderSize, 1);
              $types[11].encode($encoder, $response.arrayOptString,
                  $fidl.kMessageHeaderSize, 1);
            });
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_ErrorArrayBasic_Ordinal:
        final String _name = _kProtocol_ErrorArrayBasic_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorArrayBasic_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorArrayBasic_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<Protocol$ErrorArrayBasic$Response> $future = $fidl
              .decodeMessageWithCallback<
                      $async.Future<Protocol$ErrorArrayBasic$Response>>(
                  $message,
                  _kProtocol_ErrorArrayBasic_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.errorArrayBasic();
          });
          $future.then(($responseValue) {
            return ProtocolErrorArrayBasicResult.withResponse(ArrayBasic(
              arrayUint8: $responseValue.arrayUint8,
              arrayUint16: $responseValue.arrayUint16,
              arrayUint32: $responseValue.arrayUint32,
              arrayUint64: $responseValue.arrayUint64,
              arrayInt8: $responseValue.arrayInt8,
              arrayInt16: $responseValue.arrayInt16,
              arrayInt32: $responseValue.arrayInt32,
              arrayInt64: $responseValue.arrayInt64,
              arrayFloat32: $responseValue.arrayFloat32,
              arrayFloat64: $responseValue.arrayFloat64,
              arrayString: $responseValue.arrayString,
              arrayOptString: $responseValue.arrayOptString,
            ));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return ProtocolErrorArrayBasicResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_ErrorArrayBasic_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_ErrorArrayBasic_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kProtocol_ErrorArrayBasic_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_OneWayArrayCompound_Ordinal:
        final String _name = _kProtocol_OneWayArrayCompound_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_OneWayArrayCompound_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kProtocol_OneWayArrayCompound_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayArrayCompound(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kProtocol_TwoWayArrayCompound_Ordinal:
        final String _name = _kProtocol_TwoWayArrayCompound_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayArrayCompound_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<Protocol$TwoWayArrayCompound$Response> $future =
              $fidl.decodeMaybeLargeMessageWithCallback<
                      $async.Future<Protocol$TwoWayArrayCompound$Response>>(
                  $message,
                  _kProtocol_TwoWayArrayCompound_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayArrayCompound(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_TwoWayArrayCompound_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_TwoWayArrayCompound_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_TwoWayArrayCompound_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.arrayBits, $fidl.kMessageHeaderSize, 1);
              $types[1].encode(
                  $encoder, $response.arrayEnum, $fidl.kMessageHeaderSize, 1);
              $types[2].encode(
                  $encoder, $response.arrayStruct, $fidl.kMessageHeaderSize, 1);
              $types[3].encode(
                  $encoder, $response.arrayTable, $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.arrayUnion, $fidl.kMessageHeaderSize, 1);
              $types[5].encode($encoder, $response.arrayOptStruct,
                  $fidl.kMessageHeaderSize, 1);
              $types[6].encode($encoder, $response.arrayOptUnion,
                  $fidl.kMessageHeaderSize, 1);
            });
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_ErrorArrayCompound_Ordinal:
        final String _name = _kProtocol_ErrorArrayCompound_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorArrayCompound_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorArrayCompound_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<Protocol$ErrorArrayCompound$Response> $future =
              $fidl.decodeMessageWithCallback<
                      $async.Future<Protocol$ErrorArrayCompound$Response>>(
                  $message,
                  _kProtocol_ErrorArrayCompound_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.errorArrayCompound();
          });
          $future.then(($responseValue) {
            return ProtocolErrorArrayCompoundResult.withResponse(ArrayCompound(
              arrayBits: $responseValue.arrayBits,
              arrayEnum: $responseValue.arrayEnum,
              arrayStruct: $responseValue.arrayStruct,
              arrayTable: $responseValue.arrayTable,
              arrayUnion: $responseValue.arrayUnion,
              arrayOptStruct: $responseValue.arrayOptStruct,
              arrayOptUnion: $responseValue.arrayOptUnion,
            ));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return ProtocolErrorArrayCompoundResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_ErrorArrayCompound_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_ErrorArrayCompound_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kProtocol_ErrorArrayCompound_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_OneWayVectorBasic_Ordinal:
        final String _name = _kProtocol_OneWayVectorBasic_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_OneWayVectorBasic_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kProtocol_OneWayVectorBasic_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayVectorBasic(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kProtocol_TwoWayVectorBasic_Ordinal:
        final String _name = _kProtocol_TwoWayVectorBasic_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayVectorBasic_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<Protocol$TwoWayVectorBasic$Response> $future =
              $fidl.decodeMaybeLargeMessageWithCallback<
                      $async.Future<Protocol$TwoWayVectorBasic$Response>>(
                  $message,
                  _kProtocol_TwoWayVectorBasic_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayVectorBasic(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_TwoWayVectorBasic_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_TwoWayVectorBasic_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_TwoWayVectorBasic_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.vectorUint8, $fidl.kMessageHeaderSize, 1);
              $types[1].encode($encoder, $response.vectorUint16,
                  $fidl.kMessageHeaderSize, 1);
              $types[2].encode($encoder, $response.vectorUint32,
                  $fidl.kMessageHeaderSize, 1);
              $types[3].encode($encoder, $response.vectorUint64,
                  $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.vectorInt8, $fidl.kMessageHeaderSize, 1);
              $types[5].encode(
                  $encoder, $response.vectorInt16, $fidl.kMessageHeaderSize, 1);
              $types[6].encode(
                  $encoder, $response.vectorInt32, $fidl.kMessageHeaderSize, 1);
              $types[7].encode(
                  $encoder, $response.vectorInt64, $fidl.kMessageHeaderSize, 1);
              $types[8].encode($encoder, $response.vectorFloat32,
                  $fidl.kMessageHeaderSize, 1);
              $types[9].encode($encoder, $response.vectorFloat64,
                  $fidl.kMessageHeaderSize, 1);
              $types[10].encode($encoder, $response.vectorString,
                  $fidl.kMessageHeaderSize, 1);
              $types[11].encode($encoder, $response.vectorOptString,
                  $fidl.kMessageHeaderSize, 1);
            });
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_ErrorVectorBasic_Ordinal:
        final String _name = _kProtocol_ErrorVectorBasic_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorVectorBasic_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorVectorBasic_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<Protocol$ErrorVectorBasic$Response> $future =
              $fidl.decodeMessageWithCallback<
                      $async.Future<Protocol$ErrorVectorBasic$Response>>(
                  $message,
                  _kProtocol_ErrorVectorBasic_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.errorVectorBasic();
          });
          $future.then(($responseValue) {
            return ProtocolErrorVectorBasicResult.withResponse(VectorBasic(
              vectorUint8: $responseValue.vectorUint8,
              vectorUint16: $responseValue.vectorUint16,
              vectorUint32: $responseValue.vectorUint32,
              vectorUint64: $responseValue.vectorUint64,
              vectorInt8: $responseValue.vectorInt8,
              vectorInt16: $responseValue.vectorInt16,
              vectorInt32: $responseValue.vectorInt32,
              vectorInt64: $responseValue.vectorInt64,
              vectorFloat32: $responseValue.vectorFloat32,
              vectorFloat64: $responseValue.vectorFloat64,
              vectorString: $responseValue.vectorString,
              vectorOptString: $responseValue.vectorOptString,
            ));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return ProtocolErrorVectorBasicResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_ErrorVectorBasic_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_ErrorVectorBasic_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kProtocol_ErrorVectorBasic_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_OneWayVectorCompound_Ordinal:
        final String _name = _kProtocol_OneWayVectorCompound_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_OneWayVectorCompound_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kProtocol_OneWayVectorCompound_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayVectorCompound(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kProtocol_TwoWayVectorCompound_Ordinal:
        final String _name = _kProtocol_TwoWayVectorCompound_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayVectorCompound_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<Protocol$TwoWayVectorCompound$Response> $future =
              $fidl.decodeMaybeLargeMessageWithCallback<
                      $async.Future<Protocol$TwoWayVectorCompound$Response>>(
                  $message,
                  _kProtocol_TwoWayVectorCompound_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayVectorCompound(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kProtocol_TwoWayVectorCompound_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_TwoWayVectorCompound_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_TwoWayVectorCompound_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.vectorBits, $fidl.kMessageHeaderSize, 1);
              $types[1].encode(
                  $encoder, $response.vectorEnum, $fidl.kMessageHeaderSize, 1);
              $types[2].encode($encoder, $response.vectorStruct,
                  $fidl.kMessageHeaderSize, 1);
              $types[3].encode(
                  $encoder, $response.vectorTable, $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.vectorUnion, $fidl.kMessageHeaderSize, 1);
              $types[5].encode($encoder, $response.vectorOptStruct,
                  $fidl.kMessageHeaderSize, 1);
              $types[6].encode($encoder, $response.vectorOptUnion,
                  $fidl.kMessageHeaderSize, 1);
            });
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_ErrorVectorCompound_Ordinal:
        final String _name = _kProtocol_ErrorVectorCompound_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorVectorCompound_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorVectorCompound_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<Protocol$ErrorVectorCompound$Response> $future =
              $fidl.decodeMessageWithCallback<
                      $async.Future<Protocol$ErrorVectorCompound$Response>>(
                  $message,
                  _kProtocol_ErrorVectorCompound_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.errorVectorCompound();
          });
          $future.then(($responseValue) {
            return ProtocolErrorVectorCompoundResult.withResponse(
                VectorCompound(
              vectorBits: $responseValue.vectorBits,
              vectorEnum: $responseValue.vectorEnum,
              vectorStruct: $responseValue.vectorStruct,
              vectorTable: $responseValue.vectorTable,
              vectorUnion: $responseValue.vectorUnion,
              vectorOptStruct: $responseValue.vectorOptStruct,
              vectorOptUnion: $responseValue.vectorOptUnion,
            ));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return ProtocolErrorVectorCompoundResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_ErrorVectorCompound_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_ErrorVectorCompound_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kProtocol_ErrorVectorCompound_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_OneWayVectorOptional_Ordinal:
        final String _name = _kProtocol_OneWayVectorOptional_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_OneWayVectorOptional_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kProtocol_OneWayVectorOptional_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayVectorOptional(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kProtocol_TwoWayVectorOptional_Ordinal:
        final String _name = _kProtocol_TwoWayVectorOptional_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayVectorOptional_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<Protocol$TwoWayVectorOptional$Response> $future =
              $fidl.decodeMaybeLargeMessageWithCallback<
                      $async.Future<Protocol$TwoWayVectorOptional$Response>>(
                  $message,
                  _kProtocol_TwoWayVectorOptional_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayVectorOptional(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kProtocol_TwoWayVectorOptional_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_TwoWayVectorOptional_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_TwoWayVectorOptional_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode($encoder, $response.optVectorUint8,
                  $fidl.kMessageHeaderSize, 1);
              $types[1].encode($encoder, $response.optVectorString,
                  $fidl.kMessageHeaderSize, 1);
              $types[2].encode($encoder, $response.optVectorStruct,
                  $fidl.kMessageHeaderSize, 1);
              $types[3].encode($encoder, $response.optVectorOptStruct,
                  $fidl.kMessageHeaderSize, 1);
            });
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_ErrorVectorOptional_Ordinal:
        final String _name = _kProtocol_ErrorVectorOptional_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorVectorOptional_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorVectorOptional_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<Protocol$ErrorVectorOptional$Response> $future =
              $fidl.decodeMessageWithCallback<
                      $async.Future<Protocol$ErrorVectorOptional$Response>>(
                  $message,
                  _kProtocol_ErrorVectorOptional_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.errorVectorOptional();
          });
          $future.then(($responseValue) {
            return ProtocolErrorVectorOptionalResult.withResponse(
                VectorOptional(
              optVectorUint8: $responseValue.optVectorUint8,
              optVectorString: $responseValue.optVectorString,
              optVectorStruct: $responseValue.optVectorStruct,
              optVectorOptStruct: $responseValue.optVectorOptStruct,
            ));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return ProtocolErrorVectorOptionalResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_ErrorVectorOptional_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_ErrorVectorOptional_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kProtocol_ErrorVectorOptional_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_OneWayArrayVectorNested_Ordinal:
        final String _name = _kProtocol_OneWayArrayVectorNested_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_OneWayArrayVectorNested_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kProtocol_OneWayArrayVectorNested_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayArrayVectorNested(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kProtocol_TwoWayArrayVectorNested_Ordinal:
        final String _name = _kProtocol_TwoWayArrayVectorNested_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayArrayVectorNested_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<Protocol$TwoWayArrayVectorNested$Response>
              $future = $fidl.decodeMaybeLargeMessageWithCallback<
                      $async.Future<Protocol$TwoWayArrayVectorNested$Response>>(
                  $message,
                  _kProtocol_TwoWayArrayVectorNested_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayArrayVectorNested(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kProtocol_TwoWayArrayVectorNested_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_TwoWayArrayVectorNested_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_TwoWayArrayVectorNested_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode($encoder, $response.arrayArrayUint8,
                  $fidl.kMessageHeaderSize, 1);
              $types[1].encode($encoder, $response.arrayVectorUint8,
                  $fidl.kMessageHeaderSize, 1);
              $types[2].encode($encoder, $response.vectorArrayUint8,
                  $fidl.kMessageHeaderSize, 1);
              $types[3].encode($encoder, $response.vectorVectorUint8,
                  $fidl.kMessageHeaderSize, 1);
            });
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_ErrorArrayVectorNested_Ordinal:
        final String _name = _kProtocol_ErrorArrayVectorNested_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorArrayVectorNested_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorArrayVectorNested_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<Protocol$ErrorArrayVectorNested$Response>
              $future = $fidl.decodeMessageWithCallback<
                      $async.Future<Protocol$ErrorArrayVectorNested$Response>>(
                  $message,
                  _kProtocol_ErrorArrayVectorNested_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.errorArrayVectorNested();
          });
          $future.then(($responseValue) {
            return ProtocolErrorArrayVectorNestedResult.withResponse(
                ArrayVectorNested(
              arrayArrayUint8: $responseValue.arrayArrayUint8,
              arrayVectorUint8: $responseValue.arrayVectorUint8,
              vectorArrayUint8: $responseValue.vectorArrayUint8,
              vectorVectorUint8: $responseValue.vectorVectorUint8,
            ));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return ProtocolErrorArrayVectorNestedResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kProtocol_ErrorArrayVectorNested_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_ErrorArrayVectorNested_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kProtocol_ErrorArrayVectorNested_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_OneWayResource_Ordinal:
        final String _name = _kProtocol_OneWayResource_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_OneWayResource_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kProtocol_OneWayResource_Type.requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayResource(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
              $types[12].decode($decoder, $offset, 1),
              $types[13].decode($decoder, $offset, 1),
              $types[14].decode($decoder, $offset, 1),
              $types[15].decode($decoder, $offset, 1),
              $types[16].decode($decoder, $offset, 1),
              $types[17].decode($decoder, $offset, 1),
              $types[18].decode($decoder, $offset, 1),
              $types[19].decode($decoder, $offset, 1),
              $types[20].decode($decoder, $offset, 1),
              $types[21].decode($decoder, $offset, 1),
              $types[22].decode($decoder, $offset, 1),
              $types[23].decode($decoder, $offset, 1),
              $types[24].decode($decoder, $offset, 1),
              $types[25].decode($decoder, $offset, 1),
              $types[26].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kProtocol_TwoWayResource_Ordinal:
        final String _name = _kProtocol_TwoWayResource_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_TwoWayResource_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<Protocol$TwoWayResource$Response> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<
                      $async.Future<Protocol$TwoWayResource$Response>>($message,
                  _kProtocol_TwoWayResource_Type.requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayResource(
              $types[0].decode($decoder, $offset, 1),
              $types[1].decode($decoder, $offset, 1),
              $types[2].decode($decoder, $offset, 1),
              $types[3].decode($decoder, $offset, 1),
              $types[4].decode($decoder, $offset, 1),
              $types[5].decode($decoder, $offset, 1),
              $types[6].decode($decoder, $offset, 1),
              $types[7].decode($decoder, $offset, 1),
              $types[8].decode($decoder, $offset, 1),
              $types[9].decode($decoder, $offset, 1),
              $types[10].decode($decoder, $offset, 1),
              $types[11].decode($decoder, $offset, 1),
              $types[12].decode($decoder, $offset, 1),
              $types[13].decode($decoder, $offset, 1),
              $types[14].decode($decoder, $offset, 1),
              $types[15].decode($decoder, $offset, 1),
              $types[16].decode($decoder, $offset, 1),
              $types[17].decode($decoder, $offset, 1),
              $types[18].decode($decoder, $offset, 1),
              $types[19].decode($decoder, $offset, 1),
              $types[20].decode($decoder, $offset, 1),
              $types[21].decode($decoder, $offset, 1),
              $types[22].decode($decoder, $offset, 1),
              $types[23].decode($decoder, $offset, 1),
              $types[24].decode($decoder, $offset, 1),
              $types[25].decode($decoder, $offset, 1),
              $types[26].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_TwoWayResource_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_TwoWayResource_Type.response!;
            $fidl.encodeMessageWithCallback(
                $encoder,
                _kProtocol_TwoWayResource_Type
                    .responseInlineSize($encoder.wireFormat), () {
              $types[0].encode(
                  $encoder, $response.handle, $fidl.kMessageHeaderSize, 1);
              $types[1]
                  .encode($encoder, $response.vmo, $fidl.kMessageHeaderSize, 1);
              $types[2].encode(
                  $encoder, $response.clientEnd, $fidl.kMessageHeaderSize, 1);
              $types[3].encode(
                  $encoder, $response.serverEnd, $fidl.kMessageHeaderSize, 1);
              $types[4].encode(
                  $encoder, $response.struct, $fidl.kMessageHeaderSize, 1);
              $types[5].encode(
                  $encoder, $response.table, $fidl.kMessageHeaderSize, 1);
              $types[6].encode(
                  $encoder, $response.union, $fidl.kMessageHeaderSize, 1);
              $types[7].encode(
                  $encoder, $response.optHandle, $fidl.kMessageHeaderSize, 1);
              $types[8].encode(
                  $encoder, $response.optVmo, $fidl.kMessageHeaderSize, 1);
              $types[9].encode($encoder, $response.optClientEnd,
                  $fidl.kMessageHeaderSize, 1);
              $types[10].encode($encoder, $response.optServerEnd,
                  $fidl.kMessageHeaderSize, 1);
              $types[11].encode(
                  $encoder, $response.optStruct, $fidl.kMessageHeaderSize, 1);
              $types[12].encode(
                  $encoder, $response.optUnion, $fidl.kMessageHeaderSize, 1);
              $types[13].encode(
                  $encoder, $response.arrayHandle, $fidl.kMessageHeaderSize, 1);
              $types[14].encode(
                  $encoder, $response.arrayVmo, $fidl.kMessageHeaderSize, 1);
              $types[15].encode($encoder, $response.arrayClientEnd,
                  $fidl.kMessageHeaderSize, 1);
              $types[16].encode($encoder, $response.arrayServerEnd,
                  $fidl.kMessageHeaderSize, 1);
              $types[17].encode(
                  $encoder, $response.arrayStruct, $fidl.kMessageHeaderSize, 1);
              $types[18].encode(
                  $encoder, $response.arrayTable, $fidl.kMessageHeaderSize, 1);
              $types[19].encode(
                  $encoder, $response.arrayUnion, $fidl.kMessageHeaderSize, 1);
              $types[20].encode($encoder, $response.vectorHandle,
                  $fidl.kMessageHeaderSize, 1);
              $types[21].encode(
                  $encoder, $response.vectorVmo, $fidl.kMessageHeaderSize, 1);
              $types[22].encode($encoder, $response.vectorClientEnd,
                  $fidl.kMessageHeaderSize, 1);
              $types[23].encode($encoder, $response.vectorServerEnd,
                  $fidl.kMessageHeaderSize, 1);
              $types[24].encode($encoder, $response.vectorStruct,
                  $fidl.kMessageHeaderSize, 1);
              $types[25].encode(
                  $encoder, $response.vectorTable, $fidl.kMessageHeaderSize, 1);
              $types[26].encode(
                  $encoder, $response.vectorUnion, $fidl.kMessageHeaderSize, 1);
            });
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kProtocol_ErrorResource_Ordinal:
        final String _name = _kProtocol_ErrorResource_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kProtocol_ErrorResource_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kProtocol_ErrorResource_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<Protocol$ErrorResource$Response> $future = $fidl
              .decodeMessageWithCallback<
                      $async.Future<Protocol$ErrorResource$Response>>($message,
                  _kProtocol_ErrorResource_Type.requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.errorResource();
          });
          $future.then(($responseValue) {
            return ProtocolErrorResourceResult.withResponse(Resource(
              handle: $responseValue.handle,
              vmo: $responseValue.vmo,
              clientEnd: $responseValue.clientEnd,
              serverEnd: $responseValue.serverEnd,
              struct: $responseValue.struct,
              table: $responseValue.table,
              union: $responseValue.union,
              optHandle: $responseValue.optHandle,
              optVmo: $responseValue.optVmo,
              optClientEnd: $responseValue.optClientEnd,
              optServerEnd: $responseValue.optServerEnd,
              optStruct: $responseValue.optStruct,
              optUnion: $responseValue.optUnion,
              arrayHandle: $responseValue.arrayHandle,
              arrayVmo: $responseValue.arrayVmo,
              arrayClientEnd: $responseValue.arrayClientEnd,
              arrayServerEnd: $responseValue.arrayServerEnd,
              arrayStruct: $responseValue.arrayStruct,
              arrayTable: $responseValue.arrayTable,
              arrayUnion: $responseValue.arrayUnion,
              vectorHandle: $responseValue.vectorHandle,
              vectorVmo: $responseValue.vectorVmo,
              vectorClientEnd: $responseValue.vectorClientEnd,
              vectorServerEnd: $responseValue.vectorServerEnd,
              vectorStruct: $responseValue.vectorStruct,
              vectorTable: $responseValue.vectorTable,
              vectorUnion: $responseValue.vectorUnion,
            ));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return ProtocolErrorResourceResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kProtocol_ErrorResource_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kProtocol_ErrorResource_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kProtocol_ErrorResource_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      default:
        $message.closeHandles();
        throw $fidl.FidlError(r'Unexpected message name for ProtocolBinding');
    }
  }
}
