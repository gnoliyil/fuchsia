// WARNING: This file is machine generated by fidlgen.
// @dart = 2.12

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = zx_select_case_sensitivity

library fidl_test_unionsandwich_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zircon;

// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: directives_ordering
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: override_on_non_overriding_member

enum UnionSize12Alignment4Tag {
  variant, // 0x1
}

const Map<int, UnionSize12Alignment4Tag> _UnionSize12Alignment4Tag_map = {
  1: UnionSize12Alignment4Tag.variant,
};

class UnionSize12Alignment4 extends $fidl.Union {
  const UnionSize12Alignment4.withVariant(Uint8List value)
      : _ordinal = 1,
        _data = value;

  UnionSize12Alignment4._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  UnionSize12Alignment4Tag get $tag => _UnionSize12Alignment4Tag_map[_ordinal]!;

  Uint8List? get variant {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static UnionSize12Alignment4 _ctor(int ordinal, Object data) {
    return UnionSize12Alignment4._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<UnionSize12Alignment4> kUnionSize12Alignment4_Type =
    $fidl.UnionType<UnionSize12Alignment4>(
  members: <int, $fidl.FidlType>{
    1: $fidl.ArrayType<int, Uint8List>(
        element: $fidl.Uint8Type(), elementCount: 6),
  },
  ctor: UnionSize12Alignment4._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<UnionSize12Alignment4>
    kUnionSize12Alignment4_OptType =
    $fidl.NullableUnionType<UnionSize12Alignment4>(
  members: <int, $fidl.FidlType>{
    1: $fidl.ArrayType<int, Uint8List>(
        element: $fidl.Uint8Type(), elementCount: 6),
  },
  ctor: UnionSize12Alignment4._ctor,
  flexible: false,
  resource: false,
);

enum UnionSize24Alignment8Tag {
  variant, // 0x1
}

const Map<int, UnionSize24Alignment8Tag> _UnionSize24Alignment8Tag_map = {
  1: UnionSize24Alignment8Tag.variant,
};

class UnionSize24Alignment8 extends $fidl.Union {
  const UnionSize24Alignment8.withVariant(StructSize16Alignment8 value)
      : _ordinal = 1,
        _data = value;

  UnionSize24Alignment8._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  UnionSize24Alignment8Tag get $tag => _UnionSize24Alignment8Tag_map[_ordinal]!;

  StructSize16Alignment8? get variant {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static UnionSize24Alignment8 _ctor(int ordinal, Object data) {
    return UnionSize24Alignment8._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<UnionSize24Alignment8> kUnionSize24Alignment8_Type =
    $fidl.UnionType<UnionSize24Alignment8>(
  members: <int, $fidl.FidlType>{
    1: kStructSize16Alignment8_Type,
  },
  ctor: UnionSize24Alignment8._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<UnionSize24Alignment8>
    kUnionSize24Alignment8_OptType =
    $fidl.NullableUnionType<UnionSize24Alignment8>(
  members: <int, $fidl.FidlType>{
    1: kStructSize16Alignment8_Type,
  },
  ctor: UnionSize24Alignment8._ctor,
  flexible: false,
  resource: false,
);

enum UnionSize36Alignment4Tag {
  variant, // 0x1
}

const Map<int, UnionSize36Alignment4Tag> _UnionSize36Alignment4Tag_map = {
  1: UnionSize36Alignment4Tag.variant,
};

class UnionSize36Alignment4 extends $fidl.Union {
  const UnionSize36Alignment4.withVariant(Uint8List value)
      : _ordinal = 1,
        _data = value;

  UnionSize36Alignment4._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  UnionSize36Alignment4Tag get $tag => _UnionSize36Alignment4Tag_map[_ordinal]!;

  Uint8List? get variant {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static UnionSize36Alignment4 _ctor(int ordinal, Object data) {
    return UnionSize36Alignment4._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<UnionSize36Alignment4> kUnionSize36Alignment4_Type =
    $fidl.UnionType<UnionSize36Alignment4>(
  members: <int, $fidl.FidlType>{
    1: $fidl.ArrayType<int, Uint8List>(
        element: $fidl.Uint8Type(), elementCount: 32),
  },
  ctor: UnionSize36Alignment4._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<UnionSize36Alignment4>
    kUnionSize36Alignment4_OptType =
    $fidl.NullableUnionType<UnionSize36Alignment4>(
  members: <int, $fidl.FidlType>{
    1: $fidl.ArrayType<int, Uint8List>(
        element: $fidl.Uint8Type(), elementCount: 32),
  },
  ctor: UnionSize36Alignment4._ctor,
  flexible: false,
  resource: false,
);

enum UnionSize8Alignment4Tag {
  variant, // 0x1
}

const Map<int, UnionSize8Alignment4Tag> _UnionSize8Alignment4Tag_map = {
  1: UnionSize8Alignment4Tag.variant,
};

class UnionSize8Alignment4 extends $fidl.Union {
  const UnionSize8Alignment4.withVariant(int value)
      : _ordinal = 1,
        _data = value;

  UnionSize8Alignment4._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  UnionSize8Alignment4Tag get $tag => _UnionSize8Alignment4Tag_map[_ordinal]!;

  int? get variant {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static UnionSize8Alignment4 _ctor(int ordinal, Object data) {
    return UnionSize8Alignment4._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<UnionSize8Alignment4> kUnionSize8Alignment4_Type =
    $fidl.UnionType<UnionSize8Alignment4>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Uint32Type(),
  },
  ctor: UnionSize8Alignment4._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<UnionSize8Alignment4>
    kUnionSize8Alignment4_OptType =
    $fidl.NullableUnionType<UnionSize8Alignment4>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Uint32Type(),
  },
  ctor: UnionSize8Alignment4._ctor,
  flexible: false,
  resource: false,
);

class SandwichUnionSize12Alignment4 extends $fidl.Struct {
  const SandwichUnionSize12Alignment4({
    required this.before,
    required this.union,
    required this.after,
  });
  SandwichUnionSize12Alignment4.clone(
    SandwichUnionSize12Alignment4 $orig, {
    int? before,
    UnionSize12Alignment4? union,
    int? after,
  }) : this(
          before: before ?? $orig.before,
          union: union ?? $orig.union,
          after: after ?? $orig.after,
        );

  SandwichUnionSize12Alignment4 $cloneWith({
    int? before,
    UnionSize12Alignment4? union,
    int? after,
  }) {
    return SandwichUnionSize12Alignment4(
      before: before ?? this.before,
      union: union ?? this.union,
      after: after ?? this.after,
    );
  }

  final int before;
  final UnionSize12Alignment4 union;
  final int after;

  @override
  List<Object?> get $fields {
    return <Object?>[
      before,
      union,
      after,
    ];
  }

  static const $fieldType0 = $fidl.Uint32Type();
  static const $fieldType1 = kUnionSize12Alignment4_Type;
  static const $fieldType2 = $fidl.Int32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, before, $offset + 0, $depth);
    $fieldType1.encode($encoder, union, $offset + 8, $depth);
    $fieldType2.encode($encoder, after, $offset + 24, $depth);
  }

  static SandwichUnionSize12Alignment4 _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 4, 4);

        $decoder.checkPadding($offset + 28, 4);
        return SandwichUnionSize12Alignment4(
            before: $fieldType0.decode($decoder, $offset + 0, $depth),
            union: $fieldType1.decode($decoder, $offset + 8, $depth),
            after: $fieldType2.decode($decoder, $offset + 24, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<SandwichUnionSize12Alignment4>
    kSandwichUnionSize12Alignment4_Type =
    $fidl.StructType<SandwichUnionSize12Alignment4>(
        inlineSize: 32,
        structDecode: SandwichUnionSize12Alignment4._structDecode);

class SandwichUnionSize24Alignment8 extends $fidl.Struct {
  const SandwichUnionSize24Alignment8({
    required this.before,
    required this.union,
    required this.after,
  });
  SandwichUnionSize24Alignment8.clone(
    SandwichUnionSize24Alignment8 $orig, {
    int? before,
    UnionSize24Alignment8? union,
    int? after,
  }) : this(
          before: before ?? $orig.before,
          union: union ?? $orig.union,
          after: after ?? $orig.after,
        );

  SandwichUnionSize24Alignment8 $cloneWith({
    int? before,
    UnionSize24Alignment8? union,
    int? after,
  }) {
    return SandwichUnionSize24Alignment8(
      before: before ?? this.before,
      union: union ?? this.union,
      after: after ?? this.after,
    );
  }

  final int before;
  final UnionSize24Alignment8 union;
  final int after;

  @override
  List<Object?> get $fields {
    return <Object?>[
      before,
      union,
      after,
    ];
  }

  static const $fieldType0 = $fidl.Uint32Type();
  static const $fieldType1 = kUnionSize24Alignment8_Type;
  static const $fieldType2 = $fidl.Uint32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, before, $offset + 0, $depth);
    $fieldType1.encode($encoder, union, $offset + 8, $depth);
    $fieldType2.encode($encoder, after, $offset + 24, $depth);
  }

  static SandwichUnionSize24Alignment8 _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 4, 4);

        $decoder.checkPadding($offset + 28, 4);
        return SandwichUnionSize24Alignment8(
            before: $fieldType0.decode($decoder, $offset + 0, $depth),
            union: $fieldType1.decode($decoder, $offset + 8, $depth),
            after: $fieldType2.decode($decoder, $offset + 24, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<SandwichUnionSize24Alignment8>
    kSandwichUnionSize24Alignment8_Type =
    $fidl.StructType<SandwichUnionSize24Alignment8>(
        inlineSize: 32,
        structDecode: SandwichUnionSize24Alignment8._structDecode);

class SandwichUnionSize36Alignment4 extends $fidl.Struct {
  const SandwichUnionSize36Alignment4({
    required this.before,
    required this.union,
    required this.after,
  });
  SandwichUnionSize36Alignment4.clone(
    SandwichUnionSize36Alignment4 $orig, {
    int? before,
    UnionSize36Alignment4? union,
    int? after,
  }) : this(
          before: before ?? $orig.before,
          union: union ?? $orig.union,
          after: after ?? $orig.after,
        );

  SandwichUnionSize36Alignment4 $cloneWith({
    int? before,
    UnionSize36Alignment4? union,
    int? after,
  }) {
    return SandwichUnionSize36Alignment4(
      before: before ?? this.before,
      union: union ?? this.union,
      after: after ?? this.after,
    );
  }

  final int before;
  final UnionSize36Alignment4 union;
  final int after;

  @override
  List<Object?> get $fields {
    return <Object?>[
      before,
      union,
      after,
    ];
  }

  static const $fieldType0 = $fidl.Uint32Type();
  static const $fieldType1 = kUnionSize36Alignment4_Type;
  static const $fieldType2 = $fidl.Uint32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, before, $offset + 0, $depth);
    $fieldType1.encode($encoder, union, $offset + 8, $depth);
    $fieldType2.encode($encoder, after, $offset + 24, $depth);
  }

  static SandwichUnionSize36Alignment4 _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 4, 4);

        $decoder.checkPadding($offset + 28, 4);
        return SandwichUnionSize36Alignment4(
            before: $fieldType0.decode($decoder, $offset + 0, $depth),
            union: $fieldType1.decode($decoder, $offset + 8, $depth),
            after: $fieldType2.decode($decoder, $offset + 24, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<SandwichUnionSize36Alignment4>
    kSandwichUnionSize36Alignment4_Type =
    $fidl.StructType<SandwichUnionSize36Alignment4>(
        inlineSize: 32,
        structDecode: SandwichUnionSize36Alignment4._structDecode);

class SandwichUnionSize8Alignment4 extends $fidl.Struct {
  const SandwichUnionSize8Alignment4({
    required this.before,
    required this.union,
    required this.after,
  });
  SandwichUnionSize8Alignment4.clone(
    SandwichUnionSize8Alignment4 $orig, {
    int? before,
    UnionSize8Alignment4? union,
    int? after,
  }) : this(
          before: before ?? $orig.before,
          union: union ?? $orig.union,
          after: after ?? $orig.after,
        );

  SandwichUnionSize8Alignment4 $cloneWith({
    int? before,
    UnionSize8Alignment4? union,
    int? after,
  }) {
    return SandwichUnionSize8Alignment4(
      before: before ?? this.before,
      union: union ?? this.union,
      after: after ?? this.after,
    );
  }

  final int before;
  final UnionSize8Alignment4 union;
  final int after;

  @override
  List<Object?> get $fields {
    return <Object?>[
      before,
      union,
      after,
    ];
  }

  static const $fieldType0 = $fidl.Uint32Type();
  static const $fieldType1 = kUnionSize8Alignment4_Type;
  static const $fieldType2 = $fidl.Uint32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, before, $offset + 0, $depth);
    $fieldType1.encode($encoder, union, $offset + 8, $depth);
    $fieldType2.encode($encoder, after, $offset + 24, $depth);
  }

  static SandwichUnionSize8Alignment4 _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        $decoder.checkPadding($offset + 4, 4);

        $decoder.checkPadding($offset + 28, 4);
        return SandwichUnionSize8Alignment4(
            before: $fieldType0.decode($decoder, $offset + 0, $depth),
            union: $fieldType1.decode($decoder, $offset + 8, $depth),
            after: $fieldType2.decode($decoder, $offset + 24, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<SandwichUnionSize8Alignment4>
    kSandwichUnionSize8Alignment4_Type =
    $fidl.StructType<SandwichUnionSize8Alignment4>(
        inlineSize: 32,
        structDecode: SandwichUnionSize8Alignment4._structDecode);

class StructSize16Alignment8 extends $fidl.Struct {
  const StructSize16Alignment8({
    required this.f1,
    required this.f2,
  });
  StructSize16Alignment8.clone(
    StructSize16Alignment8 $orig, {
    int? f1,
    int? f2,
  }) : this(
          f1: f1 ?? $orig.f1,
          f2: f2 ?? $orig.f2,
        );

  StructSize16Alignment8 $cloneWith({
    int? f1,
    int? f2,
  }) {
    return StructSize16Alignment8(
      f1: f1 ?? this.f1,
      f2: f2 ?? this.f2,
    );
  }

  final int f1;
  final int f2;

  @override
  List<Object?> get $fields {
    return <Object?>[
      f1,
      f2,
    ];
  }

  static const $fieldType0 = $fidl.Uint64Type();
  static const $fieldType1 = $fidl.Uint64Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, f1, $offset + 0, $depth);
    $fieldType1.encode($encoder, f2, $offset + 8, $depth);
  }

  static StructSize16Alignment8 _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        return StructSize16Alignment8(
            f1: $fieldType0.decode($decoder, $offset + 0, $depth),
            f2: $fieldType1.decode($decoder, $offset + 8, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<StructSize16Alignment8> kStructSize16Alignment8_Type =
    $fidl.StructType<StructSize16Alignment8>(
        inlineSize: 16, structDecode: StructSize16Alignment8._structDecode);
