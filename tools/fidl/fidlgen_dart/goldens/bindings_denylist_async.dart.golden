// WARNING: This file is machine generated by fidlgen.
// @dart = 2.12

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

library fidl_test_bindingsdenylist_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zircon;

import 'package:fidl_test_dependent/fidl_async.dart' as lib$test_dependent;
// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: directives_ordering
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: override_on_non_overriding_member

const int allBindings = 0x0;

class OnlyDart extends $fidl.Enum {
  static const Map<int, OnlyDart> _values = {
    0x1: a,
  };
  factory OnlyDart(int _v) {
    if (!_values.containsKey(_v)) {
      throw $fidl.FidlError('Invalid strict enum value: $_v',
          $fidl.FidlErrorCode.fidlInvalidEnumValue);
    }
    return _values[_v]!;
  }
  static const OnlyDart a = OnlyDart._(0x1);

  const OnlyDart._(this.$value);

  @override
  final int $value;

  static const Map<String, OnlyDart> $valuesMap = {
    r'a': a,
  };

  static const List<OnlyDart> $values = [
    a,
  ];

  static OnlyDart? $valueOf(String name) => $valuesMap[name];

  @override
  bool isUnknown() {
    return false;
  }

  static OnlyDart _ctor(int v) => OnlyDart(v);
}

const $fidl.EnumType<OnlyDart> kOnlyDart_Type = $fidl.EnumType<OnlyDart>(
    type: $fidl.Uint32Type(), values: {0x1: null}, ctor: OnlyDart._ctor);

enum DenyEachBindingOnlyDenyCppResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, DenyEachBindingOnlyDenyCppResultTag>
    _DenyEachBindingOnlyDenyCppResultTag_map = {
  1: DenyEachBindingOnlyDenyCppResultTag.response,
  2: DenyEachBindingOnlyDenyCppResultTag.err,
};

class DenyEachBindingOnlyDenyCppResult extends $fidl.Union {
  const DenyEachBindingOnlyDenyCppResult.withResponse(
      DenyEachBindingOnlyDenyCppResponse value)
      : _ordinal = 1,
        _data = value;

  const DenyEachBindingOnlyDenyCppResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  DenyEachBindingOnlyDenyCppResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  DenyEachBindingOnlyDenyCppResultTag get $tag =>
      _DenyEachBindingOnlyDenyCppResultTag_map[_ordinal]!;

  DenyEachBindingOnlyDenyCppResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static DenyEachBindingOnlyDenyCppResult _ctor(int ordinal, Object data) {
    return DenyEachBindingOnlyDenyCppResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<DenyEachBindingOnlyDenyCppResult>
    kDenyEachBinding_OnlyDenyCpp_Result_Type =
    $fidl.UnionType<DenyEachBindingOnlyDenyCppResult>(
  members: <int, $fidl.FidlType>{
    1: kDenyEachBinding_OnlyDenyCpp_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: DenyEachBindingOnlyDenyCppResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<DenyEachBindingOnlyDenyCppResult>
    kDenyEachBinding_OnlyDenyCpp_Result_OptType =
    $fidl.NullableUnionType<DenyEachBindingOnlyDenyCppResult>(
  members: <int, $fidl.FidlType>{
    1: kDenyEachBinding_OnlyDenyCpp_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: DenyEachBindingOnlyDenyCppResult._ctor,
  flexible: false,
  resource: false,
);

enum DenyEachBindingOnlyDenyGoResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, DenyEachBindingOnlyDenyGoResultTag>
    _DenyEachBindingOnlyDenyGoResultTag_map = {
  1: DenyEachBindingOnlyDenyGoResultTag.response,
  2: DenyEachBindingOnlyDenyGoResultTag.err,
};

class DenyEachBindingOnlyDenyGoResult extends $fidl.Union {
  const DenyEachBindingOnlyDenyGoResult.withResponse(
      DenyEachBindingOnlyDenyGoResponse value)
      : _ordinal = 1,
        _data = value;

  const DenyEachBindingOnlyDenyGoResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  DenyEachBindingOnlyDenyGoResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  DenyEachBindingOnlyDenyGoResultTag get $tag =>
      _DenyEachBindingOnlyDenyGoResultTag_map[_ordinal]!;

  DenyEachBindingOnlyDenyGoResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static DenyEachBindingOnlyDenyGoResult _ctor(int ordinal, Object data) {
    return DenyEachBindingOnlyDenyGoResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<DenyEachBindingOnlyDenyGoResult>
    kDenyEachBinding_OnlyDenyGo_Result_Type =
    $fidl.UnionType<DenyEachBindingOnlyDenyGoResult>(
  members: <int, $fidl.FidlType>{
    1: kDenyEachBinding_OnlyDenyGo_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: DenyEachBindingOnlyDenyGoResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<DenyEachBindingOnlyDenyGoResult>
    kDenyEachBinding_OnlyDenyGo_Result_OptType =
    $fidl.NullableUnionType<DenyEachBindingOnlyDenyGoResult>(
  members: <int, $fidl.FidlType>{
    1: kDenyEachBinding_OnlyDenyGo_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: DenyEachBindingOnlyDenyGoResult._ctor,
  flexible: false,
  resource: false,
);

enum DenyEachBindingOnlyDenyLibfuzzerResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, DenyEachBindingOnlyDenyLibfuzzerResultTag>
    _DenyEachBindingOnlyDenyLibfuzzerResultTag_map = {
  1: DenyEachBindingOnlyDenyLibfuzzerResultTag.response,
  2: DenyEachBindingOnlyDenyLibfuzzerResultTag.err,
};

class DenyEachBindingOnlyDenyLibfuzzerResult extends $fidl.Union {
  const DenyEachBindingOnlyDenyLibfuzzerResult.withResponse(
      DenyEachBindingOnlyDenyLibfuzzerResponse value)
      : _ordinal = 1,
        _data = value;

  const DenyEachBindingOnlyDenyLibfuzzerResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  DenyEachBindingOnlyDenyLibfuzzerResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  DenyEachBindingOnlyDenyLibfuzzerResultTag get $tag =>
      _DenyEachBindingOnlyDenyLibfuzzerResultTag_map[_ordinal]!;

  DenyEachBindingOnlyDenyLibfuzzerResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static DenyEachBindingOnlyDenyLibfuzzerResult _ctor(
      int ordinal, Object data) {
    return DenyEachBindingOnlyDenyLibfuzzerResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<DenyEachBindingOnlyDenyLibfuzzerResult>
    kDenyEachBinding_OnlyDenyLibfuzzer_Result_Type =
    $fidl.UnionType<DenyEachBindingOnlyDenyLibfuzzerResult>(
  members: <int, $fidl.FidlType>{
    1: kDenyEachBinding_OnlyDenyLibfuzzer_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: DenyEachBindingOnlyDenyLibfuzzerResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<DenyEachBindingOnlyDenyLibfuzzerResult>
    kDenyEachBinding_OnlyDenyLibfuzzer_Result_OptType =
    $fidl.NullableUnionType<DenyEachBindingOnlyDenyLibfuzzerResult>(
  members: <int, $fidl.FidlType>{
    1: kDenyEachBinding_OnlyDenyLibfuzzer_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: DenyEachBindingOnlyDenyLibfuzzerResult._ctor,
  flexible: false,
  resource: false,
);

enum DenyEachBindingOnlyDenyRustResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, DenyEachBindingOnlyDenyRustResultTag>
    _DenyEachBindingOnlyDenyRustResultTag_map = {
  1: DenyEachBindingOnlyDenyRustResultTag.response,
  2: DenyEachBindingOnlyDenyRustResultTag.err,
};

class DenyEachBindingOnlyDenyRustResult extends $fidl.Union {
  const DenyEachBindingOnlyDenyRustResult.withResponse(
      DenyEachBindingOnlyDenyRustResponse value)
      : _ordinal = 1,
        _data = value;

  const DenyEachBindingOnlyDenyRustResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  DenyEachBindingOnlyDenyRustResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  DenyEachBindingOnlyDenyRustResultTag get $tag =>
      _DenyEachBindingOnlyDenyRustResultTag_map[_ordinal]!;

  DenyEachBindingOnlyDenyRustResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static DenyEachBindingOnlyDenyRustResult _ctor(int ordinal, Object data) {
    return DenyEachBindingOnlyDenyRustResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<DenyEachBindingOnlyDenyRustResult>
    kDenyEachBinding_OnlyDenyRust_Result_Type =
    $fidl.UnionType<DenyEachBindingOnlyDenyRustResult>(
  members: <int, $fidl.FidlType>{
    1: kDenyEachBinding_OnlyDenyRust_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: DenyEachBindingOnlyDenyRustResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<DenyEachBindingOnlyDenyRustResult>
    kDenyEachBinding_OnlyDenyRust_Result_OptType =
    $fidl.NullableUnionType<DenyEachBindingOnlyDenyRustResult>(
  members: <int, $fidl.FidlType>{
    1: kDenyEachBinding_OnlyDenyRust_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: DenyEachBindingOnlyDenyRustResult._ctor,
  flexible: false,
  resource: false,
);

enum DenyEachBindingOnlyDenySyzkallerResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, DenyEachBindingOnlyDenySyzkallerResultTag>
    _DenyEachBindingOnlyDenySyzkallerResultTag_map = {
  1: DenyEachBindingOnlyDenySyzkallerResultTag.response,
  2: DenyEachBindingOnlyDenySyzkallerResultTag.err,
};

class DenyEachBindingOnlyDenySyzkallerResult extends $fidl.Union {
  const DenyEachBindingOnlyDenySyzkallerResult.withResponse(
      DenyEachBindingOnlyDenySyzkallerResponse value)
      : _ordinal = 1,
        _data = value;

  const DenyEachBindingOnlyDenySyzkallerResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  DenyEachBindingOnlyDenySyzkallerResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  DenyEachBindingOnlyDenySyzkallerResultTag get $tag =>
      _DenyEachBindingOnlyDenySyzkallerResultTag_map[_ordinal]!;

  DenyEachBindingOnlyDenySyzkallerResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static DenyEachBindingOnlyDenySyzkallerResult _ctor(
      int ordinal, Object data) {
    return DenyEachBindingOnlyDenySyzkallerResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<DenyEachBindingOnlyDenySyzkallerResult>
    kDenyEachBinding_OnlyDenySyzkaller_Result_Type =
    $fidl.UnionType<DenyEachBindingOnlyDenySyzkallerResult>(
  members: <int, $fidl.FidlType>{
    1: kDenyEachBinding_OnlyDenySyzkaller_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: DenyEachBindingOnlyDenySyzkallerResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<DenyEachBindingOnlyDenySyzkallerResult>
    kDenyEachBinding_OnlyDenySyzkaller_Result_OptType =
    $fidl.NullableUnionType<DenyEachBindingOnlyDenySyzkallerResult>(
  members: <int, $fidl.FidlType>{
    1: kDenyEachBinding_OnlyDenySyzkaller_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: DenyEachBindingOnlyDenySyzkallerResult._ctor,
  flexible: false,
  resource: false,
);

class DenyEachBindingOnlyDenyCppResponse extends $fidl.Struct {
  const DenyEachBindingOnlyDenyCppResponse({
    required this.b,
  });
  DenyEachBindingOnlyDenyCppResponse.clone(
    DenyEachBindingOnlyDenyCppResponse $orig, {
    int? b,
  }) : this(
          b: b ?? $orig.b,
        );

  DenyEachBindingOnlyDenyCppResponse $cloneWith({
    int? b,
  }) {
    return DenyEachBindingOnlyDenyCppResponse(
      b: b ?? this.b,
    );
  }

  final int b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      b,
    ];
  }

  static const $fieldType0 = $fidl.Int32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, b, $offset + 0, $depth);
  }

  static DenyEachBindingOnlyDenyCppResponse _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        return DenyEachBindingOnlyDenyCppResponse(
            b: $fieldType0.decode($decoder, $offset + 0, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<DenyEachBindingOnlyDenyCppResponse>
    kDenyEachBinding_OnlyDenyCpp_Response_Type =
    $fidl.StructType<DenyEachBindingOnlyDenyCppResponse>(
        inlineSize: 4,
        structDecode: DenyEachBindingOnlyDenyCppResponse._structDecode);

class DenyEachBindingOnlyDenyGoResponse extends $fidl.Struct {
  const DenyEachBindingOnlyDenyGoResponse({
    required this.b,
  });
  DenyEachBindingOnlyDenyGoResponse.clone(
    DenyEachBindingOnlyDenyGoResponse $orig, {
    int? b,
  }) : this(
          b: b ?? $orig.b,
        );

  DenyEachBindingOnlyDenyGoResponse $cloneWith({
    int? b,
  }) {
    return DenyEachBindingOnlyDenyGoResponse(
      b: b ?? this.b,
    );
  }

  final int b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      b,
    ];
  }

  static const $fieldType0 = $fidl.Int32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, b, $offset + 0, $depth);
  }

  static DenyEachBindingOnlyDenyGoResponse _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        return DenyEachBindingOnlyDenyGoResponse(
            b: $fieldType0.decode($decoder, $offset + 0, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<DenyEachBindingOnlyDenyGoResponse>
    kDenyEachBinding_OnlyDenyGo_Response_Type =
    $fidl.StructType<DenyEachBindingOnlyDenyGoResponse>(
        inlineSize: 4,
        structDecode: DenyEachBindingOnlyDenyGoResponse._structDecode);

class DenyEachBindingOnlyDenyLibfuzzerResponse extends $fidl.Struct {
  const DenyEachBindingOnlyDenyLibfuzzerResponse({
    required this.b,
  });
  DenyEachBindingOnlyDenyLibfuzzerResponse.clone(
    DenyEachBindingOnlyDenyLibfuzzerResponse $orig, {
    int? b,
  }) : this(
          b: b ?? $orig.b,
        );

  DenyEachBindingOnlyDenyLibfuzzerResponse $cloneWith({
    int? b,
  }) {
    return DenyEachBindingOnlyDenyLibfuzzerResponse(
      b: b ?? this.b,
    );
  }

  final int b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      b,
    ];
  }

  static const $fieldType0 = $fidl.Int32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, b, $offset + 0, $depth);
  }

  static DenyEachBindingOnlyDenyLibfuzzerResponse _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        return DenyEachBindingOnlyDenyLibfuzzerResponse(
            b: $fieldType0.decode($decoder, $offset + 0, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<DenyEachBindingOnlyDenyLibfuzzerResponse>
    kDenyEachBinding_OnlyDenyLibfuzzer_Response_Type =
    $fidl.StructType<DenyEachBindingOnlyDenyLibfuzzerResponse>(
        inlineSize: 4,
        structDecode: DenyEachBindingOnlyDenyLibfuzzerResponse._structDecode);

class DenyEachBindingOnlyDenyRustResponse extends $fidl.Struct {
  const DenyEachBindingOnlyDenyRustResponse({
    required this.b,
  });
  DenyEachBindingOnlyDenyRustResponse.clone(
    DenyEachBindingOnlyDenyRustResponse $orig, {
    int? b,
  }) : this(
          b: b ?? $orig.b,
        );

  DenyEachBindingOnlyDenyRustResponse $cloneWith({
    int? b,
  }) {
    return DenyEachBindingOnlyDenyRustResponse(
      b: b ?? this.b,
    );
  }

  final int b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      b,
    ];
  }

  static const $fieldType0 = $fidl.Int32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, b, $offset + 0, $depth);
  }

  static DenyEachBindingOnlyDenyRustResponse _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        return DenyEachBindingOnlyDenyRustResponse(
            b: $fieldType0.decode($decoder, $offset + 0, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<DenyEachBindingOnlyDenyRustResponse>
    kDenyEachBinding_OnlyDenyRust_Response_Type =
    $fidl.StructType<DenyEachBindingOnlyDenyRustResponse>(
        inlineSize: 4,
        structDecode: DenyEachBindingOnlyDenyRustResponse._structDecode);

class DenyEachBindingOnlyDenySyzkallerResponse extends $fidl.Struct {
  const DenyEachBindingOnlyDenySyzkallerResponse({
    required this.b,
  });
  DenyEachBindingOnlyDenySyzkallerResponse.clone(
    DenyEachBindingOnlyDenySyzkallerResponse $orig, {
    int? b,
  }) : this(
          b: b ?? $orig.b,
        );

  DenyEachBindingOnlyDenySyzkallerResponse $cloneWith({
    int? b,
  }) {
    return DenyEachBindingOnlyDenySyzkallerResponse(
      b: b ?? this.b,
    );
  }

  final int b;

  @override
  List<Object?> get $fields {
    return <Object?>[
      b,
    ];
  }

  static const $fieldType0 = $fidl.Int32Type();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, b, $offset + 0, $depth);
  }

  static DenyEachBindingOnlyDenySyzkallerResponse _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        return DenyEachBindingOnlyDenySyzkallerResponse(
            b: $fieldType0.decode($decoder, $offset + 0, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<DenyEachBindingOnlyDenySyzkallerResponse>
    kDenyEachBinding_OnlyDenySyzkaller_Response_Type =
    $fidl.StructType<DenyEachBindingOnlyDenySyzkallerResponse>(
        inlineSize: 4,
        structDecode: DenyEachBindingOnlyDenySyzkallerResponse._structDecode);

class MemberOnlyAppearsInImportingLibrary extends $fidl.Struct {
  const MemberOnlyAppearsInImportingLibrary({
    required this.a,
  });
  MemberOnlyAppearsInImportingLibrary.clone(
    MemberOnlyAppearsInImportingLibrary $orig, {
    bool? a,
  }) : this(
          a: a ?? $orig.a,
        );

  MemberOnlyAppearsInImportingLibrary $cloneWith({
    bool? a,
  }) {
    return MemberOnlyAppearsInImportingLibrary(
      a: a ?? this.a,
    );
  }

  final bool a;

  @override
  List<Object?> get $fields {
    return <Object?>[
      a,
    ];
  }

  static const $fieldType0 = $fidl.BoolType();

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode($encoder, a, $offset + 0, $depth);
  }

  static MemberOnlyAppearsInImportingLibrary _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        return MemberOnlyAppearsInImportingLibrary(
            a: $fieldType0.decode($decoder, $offset + 0, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<MemberOnlyAppearsInImportingLibrary>
    kMemberOnlyAppearsInImportingLibrary_Type =
    $fidl.StructType<MemberOnlyAppearsInImportingLibrary>(
        inlineSize: 1,
        structDecode: MemberOnlyAppearsInImportingLibrary._structDecode);

class OnlyAppearsInImportingLibrary extends $fidl.Struct {
  const OnlyAppearsInImportingLibrary({
    required this.memberOnlyAppearsInImportingLibrary,
  });
  OnlyAppearsInImportingLibrary.clone(
    OnlyAppearsInImportingLibrary $orig, {
    MemberOnlyAppearsInImportingLibrary? memberOnlyAppearsInImportingLibrary,
  }) : this(
          memberOnlyAppearsInImportingLibrary:
              memberOnlyAppearsInImportingLibrary ??
                  $orig.memberOnlyAppearsInImportingLibrary,
        );

  OnlyAppearsInImportingLibrary $cloneWith({
    MemberOnlyAppearsInImportingLibrary? memberOnlyAppearsInImportingLibrary,
  }) {
    return OnlyAppearsInImportingLibrary(
      memberOnlyAppearsInImportingLibrary:
          memberOnlyAppearsInImportingLibrary ??
              this.memberOnlyAppearsInImportingLibrary,
    );
  }

  final MemberOnlyAppearsInImportingLibrary memberOnlyAppearsInImportingLibrary;

  @override
  List<Object?> get $fields {
    return <Object?>[
      memberOnlyAppearsInImportingLibrary,
    ];
  }

  static const $fieldType0 = kMemberOnlyAppearsInImportingLibrary_Type;

  @override
  void $encode($fidl.Encoder $encoder, int $offset, int $depth) {
    $fieldType0.encode(
        $encoder, memberOnlyAppearsInImportingLibrary, $offset + 0, $depth);
  }

  static OnlyAppearsInImportingLibrary _structDecode(
      $fidl.Decoder $decoder, int $offset, int $depth) {
    switch ($decoder.wireFormat) {
      case $fidl.WireFormat.v2:
        return OnlyAppearsInImportingLibrary(
            memberOnlyAppearsInImportingLibrary:
                $fieldType0.decode($decoder, $offset + 0, $depth));
    }
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.StructType<OnlyAppearsInImportingLibrary>
    kOnlyAppearsInImportingLibrary_Type =
    $fidl.StructType<OnlyAppearsInImportingLibrary>(
        inlineSize: 1,
        structDecode: OnlyAppearsInImportingLibrary._structDecode);

abstract class Allowed {
  $fidl.ServiceData? get $serviceData => AllowedData();
} // TODO: Remove ServiceData for non-service

class AllowedData implements $fidl.ServiceData<Allowed> {
  const AllowedData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return AllowedBinding();
  }
}

class AllowedProxy extends $fidl.AsyncProxy<Allowed> implements Allowed {
  AllowedProxy()
      : super($fidl.AsyncProxyController<Allowed>($interfaceName: r'Allowed')) {
    ctrl.onResponse = _handleResponse;
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      default:
        $message.closeHandles();
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }
}

class AllowedBinding extends $fidl.AsyncBinding<Allowed> {
  AllowedBinding() : super(r"Allowed");

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    final $wireFormat = $message.parseWireFormat();
    switch ($message.ordinal) {
      default:
        $message.closeHandles();
        throw $fidl.FidlError(r'Unexpected message name for AllowedBinding');
    }
  }
}

// onlyDenyCpp: (bool a) -> (int b)
const int _kDenyEachBinding_OnlyDenyCpp_Ordinal = 0x290bad96051b1b92;
const $fidl.MethodType _kDenyEachBinding_OnlyDenyCpp_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<DenyEachBindingOnlyDenyCppResult>(
        type: kDenyEachBinding_OnlyDenyCpp_Result_Type, offset: 0),
  ],
  name: r"DenyEachBinding.OnlyDenyCpp",
  requestInlineSizeV2: 1,
  responseInlineSizeV2: 16,
);
// onlyDenyGo: (bool a) -> (int b)
const int _kDenyEachBinding_OnlyDenyGo_Ordinal = 0x657655b981478d99;
const $fidl.MethodType _kDenyEachBinding_OnlyDenyGo_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<DenyEachBindingOnlyDenyGoResult>(
        type: kDenyEachBinding_OnlyDenyGo_Result_Type, offset: 0),
  ],
  name: r"DenyEachBinding.OnlyDenyGo",
  requestInlineSizeV2: 1,
  responseInlineSizeV2: 16,
);
// onlyDenyLibfuzzer: (bool a) -> (int b)
const int _kDenyEachBinding_OnlyDenyLibfuzzer_Ordinal = 0x1e4f89c329617b1e;
const $fidl.MethodType _kDenyEachBinding_OnlyDenyLibfuzzer_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<DenyEachBindingOnlyDenyLibfuzzerResult>(
        type: kDenyEachBinding_OnlyDenyLibfuzzer_Result_Type, offset: 0),
  ],
  name: r"DenyEachBinding.OnlyDenyLibfuzzer",
  requestInlineSizeV2: 1,
  responseInlineSizeV2: 16,
);
// onlyDenyRust: (bool a) -> (int b)
const int _kDenyEachBinding_OnlyDenyRust_Ordinal = 0x339f67244edd5cb6;
const $fidl.MethodType _kDenyEachBinding_OnlyDenyRust_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<DenyEachBindingOnlyDenyRustResult>(
        type: kDenyEachBinding_OnlyDenyRust_Result_Type, offset: 0),
  ],
  name: r"DenyEachBinding.OnlyDenyRust",
  requestInlineSizeV2: 1,
  responseInlineSizeV2: 16,
);
// onlyDenySyzkaller: (bool a) -> (int b)
const int _kDenyEachBinding_OnlyDenySyzkaller_Ordinal = 0x202ee614a749e98a;
const $fidl.MethodType _kDenyEachBinding_OnlyDenySyzkaller_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<bool>(type: $fidl.BoolType(), offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<DenyEachBindingOnlyDenySyzkallerResult>(
        type: kDenyEachBinding_OnlyDenySyzkaller_Result_Type, offset: 0),
  ],
  name: r"DenyEachBinding.OnlyDenySyzkaller",
  requestInlineSizeV2: 1,
  responseInlineSizeV2: 16,
);

abstract class DenyEachBinding {
  $fidl.ServiceData? get $serviceData => DenyEachBindingData();
  $async.Future<int> onlyDenyCpp(bool a);
  $async.Future<int> onlyDenyGo(bool a);
  $async.Future<int> onlyDenyLibfuzzer(bool a);
  $async.Future<int> onlyDenyRust(bool a);
  $async.Future<int> onlyDenySyzkaller(bool a);
} // TODO: Remove ServiceData for non-service

class DenyEachBindingData implements $fidl.ServiceData<DenyEachBinding> {
  const DenyEachBindingData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return DenyEachBindingBinding();
  }
}

class DenyEachBindingProxy extends $fidl.AsyncProxy<DenyEachBinding>
    implements DenyEachBinding {
  DenyEachBindingProxy()
      : super($fidl.AsyncProxyController<DenyEachBinding>(
            $interfaceName: r'DenyEachBinding')) {
    ctrl.onResponse = _handleResponse;
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      default:
        $message.closeHandles();
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      case _kDenyEachBinding_OnlyDenyCpp_Ordinal:
        final String _name = _kDenyEachBinding_OnlyDenyCpp_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kDenyEachBinding_OnlyDenyCpp_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kDenyEachBinding_OnlyDenyCpp_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final DenyEachBindingOnlyDenyCppResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kDenyEachBinding_OnlyDenyCpp_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag == DenyEachBindingOnlyDenyCppResultTag.response) {
            $completer.complete($response.response!.b);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kDenyEachBinding_OnlyDenyGo_Ordinal:
        final String _name = _kDenyEachBinding_OnlyDenyGo_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kDenyEachBinding_OnlyDenyGo_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kDenyEachBinding_OnlyDenyGo_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final DenyEachBindingOnlyDenyGoResult $response = $fidl.decodeMessage(
              $message,
              _kDenyEachBinding_OnlyDenyGo_Type.responseInlineSize($wireFormat),
              $types[0]);
          if ($response.$tag == DenyEachBindingOnlyDenyGoResultTag.response) {
            $completer.complete($response.response!.b);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kDenyEachBinding_OnlyDenyLibfuzzer_Ordinal:
        final String _name = _kDenyEachBinding_OnlyDenyLibfuzzer_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kDenyEachBinding_OnlyDenyLibfuzzer_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kDenyEachBinding_OnlyDenyLibfuzzer_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final DenyEachBindingOnlyDenyLibfuzzerResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kDenyEachBinding_OnlyDenyLibfuzzer_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              DenyEachBindingOnlyDenyLibfuzzerResultTag.response) {
            $completer.complete($response.response!.b);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kDenyEachBinding_OnlyDenyRust_Ordinal:
        final String _name = _kDenyEachBinding_OnlyDenyRust_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kDenyEachBinding_OnlyDenyRust_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kDenyEachBinding_OnlyDenyRust_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final DenyEachBindingOnlyDenyRustResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kDenyEachBinding_OnlyDenyRust_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag == DenyEachBindingOnlyDenyRustResultTag.response) {
            $completer.complete($response.response!.b);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kDenyEachBinding_OnlyDenySyzkaller_Ordinal:
        final String _name = _kDenyEachBinding_OnlyDenySyzkaller_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kDenyEachBinding_OnlyDenySyzkaller_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kDenyEachBinding_OnlyDenySyzkaller_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final DenyEachBindingOnlyDenySyzkallerResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kDenyEachBinding_OnlyDenySyzkaller_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              DenyEachBindingOnlyDenySyzkallerResultTag.response) {
            $completer.complete($response.response!.b);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<int> onlyDenyCpp(bool a) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kDenyEachBinding_OnlyDenyCpp_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kDenyEachBinding_OnlyDenyCpp_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kDenyEachBinding_OnlyDenyCpp_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<int>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<int> onlyDenyGo(bool a) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kDenyEachBinding_OnlyDenyGo_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kDenyEachBinding_OnlyDenyGo_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kDenyEachBinding_OnlyDenyGo_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<int>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<int> onlyDenyLibfuzzer(bool a) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kDenyEachBinding_OnlyDenyLibfuzzer_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kDenyEachBinding_OnlyDenyLibfuzzer_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kDenyEachBinding_OnlyDenyLibfuzzer_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<int>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<int> onlyDenyRust(bool a) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kDenyEachBinding_OnlyDenyRust_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kDenyEachBinding_OnlyDenyRust_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kDenyEachBinding_OnlyDenyRust_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<int>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<int> onlyDenySyzkaller(bool a) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kDenyEachBinding_OnlyDenySyzkaller_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kDenyEachBinding_OnlyDenySyzkaller_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kDenyEachBinding_OnlyDenySyzkaller_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, a, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<int>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }
}

class DenyEachBindingBinding extends $fidl.AsyncBinding<DenyEachBinding> {
  DenyEachBindingBinding() : super(r"DenyEachBinding");

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    final $wireFormat = $message.parseWireFormat();
    switch ($message.ordinal) {
      case _kDenyEachBinding_OnlyDenyCpp_Ordinal:
        final String _name = _kDenyEachBinding_OnlyDenyCpp_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kDenyEachBinding_OnlyDenyCpp_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kDenyEachBinding_OnlyDenyCpp_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<int> $future = $fidl
              .decodeMessageWithCallback<$async.Future<int>>(
                  $message,
                  _kDenyEachBinding_OnlyDenyCpp_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.onlyDenyCpp(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($responseValue) {
            return DenyEachBindingOnlyDenyCppResult.withResponse(
                DenyEachBindingOnlyDenyCppResponse(b: $responseValue));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return DenyEachBindingOnlyDenyCppResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kDenyEachBinding_OnlyDenyCpp_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kDenyEachBinding_OnlyDenyCpp_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kDenyEachBinding_OnlyDenyCpp_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kDenyEachBinding_OnlyDenyGo_Ordinal:
        final String _name = _kDenyEachBinding_OnlyDenyGo_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kDenyEachBinding_OnlyDenyGo_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kDenyEachBinding_OnlyDenyGo_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<int> $future = $fidl
              .decodeMessageWithCallback<$async.Future<int>>(
                  $message,
                  _kDenyEachBinding_OnlyDenyGo_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.onlyDenyGo(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($responseValue) {
            return DenyEachBindingOnlyDenyGoResult.withResponse(
                DenyEachBindingOnlyDenyGoResponse(b: $responseValue));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return DenyEachBindingOnlyDenyGoResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kDenyEachBinding_OnlyDenyGo_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kDenyEachBinding_OnlyDenyGo_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kDenyEachBinding_OnlyDenyGo_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kDenyEachBinding_OnlyDenyLibfuzzer_Ordinal:
        final String _name = _kDenyEachBinding_OnlyDenyLibfuzzer_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kDenyEachBinding_OnlyDenyLibfuzzer_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kDenyEachBinding_OnlyDenyLibfuzzer_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<int> $future = $fidl
              .decodeMessageWithCallback<$async.Future<int>>(
                  $message,
                  _kDenyEachBinding_OnlyDenyLibfuzzer_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.onlyDenyLibfuzzer(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($responseValue) {
            return DenyEachBindingOnlyDenyLibfuzzerResult.withResponse(
                DenyEachBindingOnlyDenyLibfuzzerResponse(b: $responseValue));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return DenyEachBindingOnlyDenyLibfuzzerResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kDenyEachBinding_OnlyDenyLibfuzzer_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kDenyEachBinding_OnlyDenyLibfuzzer_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kDenyEachBinding_OnlyDenyLibfuzzer_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kDenyEachBinding_OnlyDenyRust_Ordinal:
        final String _name = _kDenyEachBinding_OnlyDenyRust_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kDenyEachBinding_OnlyDenyRust_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kDenyEachBinding_OnlyDenyRust_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<int> $future = $fidl
              .decodeMessageWithCallback<$async.Future<int>>(
                  $message,
                  _kDenyEachBinding_OnlyDenyRust_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.onlyDenyRust(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($responseValue) {
            return DenyEachBindingOnlyDenyRustResult.withResponse(
                DenyEachBindingOnlyDenyRustResponse(b: $responseValue));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return DenyEachBindingOnlyDenyRustResult.withErr($error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kDenyEachBinding_OnlyDenyRust_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kDenyEachBinding_OnlyDenyRust_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kDenyEachBinding_OnlyDenyRust_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kDenyEachBinding_OnlyDenySyzkaller_Ordinal:
        final String _name = _kDenyEachBinding_OnlyDenySyzkaller_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kDenyEachBinding_OnlyDenySyzkaller_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kDenyEachBinding_OnlyDenySyzkaller_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<int> $future = $fidl
              .decodeMessageWithCallback<$async.Future<int>>(
                  $message,
                  _kDenyEachBinding_OnlyDenySyzkaller_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.onlyDenySyzkaller(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($responseValue) {
            return DenyEachBindingOnlyDenySyzkallerResult.withResponse(
                DenyEachBindingOnlyDenySyzkallerResponse(b: $responseValue));
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return DenyEachBindingOnlyDenySyzkallerResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kDenyEachBinding_OnlyDenySyzkaller_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kDenyEachBinding_OnlyDenySyzkaller_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kDenyEachBinding_OnlyDenySyzkaller_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      default:
        $message.closeHandles();
        throw $fidl.FidlError(
            r'Unexpected message name for DenyEachBindingBinding');
    }
  }
}

// unattributed: ()
const int _kImportsSameNameContext_Unattributed_Ordinal = 0x698380acfd29e8f;
const $fidl.MethodType _kImportsSameNameContext_Unattributed_Type =
    $fidl.MethodType(
  request: [],
  response: [],
  name: r"ImportsSameNameContext.Unattributed",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 0,
);
// alwaysAppearsInImportingLibrary: ()
const int _kImportsSameNameContext_AlwaysAppearsInImportingLibrary_Ordinal =
    0x2874096c521236f8;
const $fidl.MethodType
    _kImportsSameNameContext_AlwaysAppearsInImportingLibrary_Type =
    $fidl.MethodType(
  request: [],
  response: [],
  name: r"ImportsSameNameContext.AlwaysAppearsInImportingLibrary",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 0,
);

abstract class ImportsSameNameContext {
  $fidl.ServiceData? get $serviceData => ImportsSameNameContextData();
  $async.Future<void> unattributed();
  $async.Future<void> alwaysAppearsInImportingLibrary();
} // TODO: Remove ServiceData for non-service

class ImportsSameNameContextData
    implements $fidl.ServiceData<ImportsSameNameContext> {
  const ImportsSameNameContextData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return ImportsSameNameContextBinding();
  }
}

class ImportsSameNameContextProxy extends $fidl
    .AsyncProxy<ImportsSameNameContext> implements ImportsSameNameContext {
  ImportsSameNameContextProxy()
      : super($fidl.AsyncProxyController<ImportsSameNameContext>(
            $interfaceName: r'ImportsSameNameContext')) {
    ctrl.onResponse = _handleResponse;
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      default:
        $message.closeHandles();
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<void> unattributed() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kImportsSameNameContext_Unattributed_Ordinal,
        0, $fidl.CallStrictness.strict);
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<void> alwaysAppearsInImportingLibrary() {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kImportsSameNameContext_AlwaysAppearsInImportingLibrary_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }
}

class ImportsSameNameContextBinding
    extends $fidl.AsyncBinding<ImportsSameNameContext> {
  ImportsSameNameContextBinding() : super(r"ImportsSameNameContext");

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    final $wireFormat = $message.parseWireFormat();
    switch ($message.ordinal) {
      case _kImportsSameNameContext_Unattributed_Ordinal:
        final String _name = _kImportsSameNameContext_Unattributed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kImportsSameNameContext_Unattributed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kImportsSameNameContext_Unattributed_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kImportsSameNameContext_Unattributed_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.unattributed();
          });
        }, close);
        break;
      case _kImportsSameNameContext_AlwaysAppearsInImportingLibrary_Ordinal:
        final String _name =
            _kImportsSameNameContext_AlwaysAppearsInImportingLibrary_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kImportsSameNameContext_AlwaysAppearsInImportingLibrary_Type
                  .request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kImportsSameNameContext_AlwaysAppearsInImportingLibrary_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<void> $future = $fidl
              .decodeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kImportsSameNameContext_AlwaysAppearsInImportingLibrary_Type
                      .requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.alwaysAppearsInImportingLibrary();
          });
        }, close);
        break;
      default:
        $message.closeHandles();
        throw $fidl.FidlError(
            r'Unexpected message name for ImportsSameNameContextBinding');
    }
  }
}
