// WARNING: This file is machine generated by fidlgen.
// @dart = 2.12

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

library fidl_test_protocollayoutssamelibrary_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zircon;

// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: directives_ordering
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: override_on_non_overriding_member

enum ComposedProtocolOnAnonComposedRequestTag {
  b, // 0x1
}

const Map<int, ComposedProtocolOnAnonComposedRequestTag>
    _ComposedProtocolOnAnonComposedRequestTag_map = {
  1: ComposedProtocolOnAnonComposedRequestTag.b,
};

class ComposedProtocolOnAnonComposedRequest extends $fidl.Union {
  const ComposedProtocolOnAnonComposedRequest.withB(bool value)
      : _ordinal = 1,
        _data = value;

  ComposedProtocolOnAnonComposedRequest._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ComposedProtocolOnAnonComposedRequestTag get $tag =>
      _ComposedProtocolOnAnonComposedRequestTag_map[_ordinal]!;

  bool? get b {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ComposedProtocolOnAnonComposedRequest _ctor(int ordinal, Object data) {
    return ComposedProtocolOnAnonComposedRequest._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ComposedProtocolOnAnonComposedRequest>
    kComposedProtocolOnAnonComposedRequest_Type =
    $fidl.UnionType<ComposedProtocolOnAnonComposedRequest>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: ComposedProtocolOnAnonComposedRequest._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ComposedProtocolOnAnonComposedRequest>
    kComposedProtocolOnAnonComposedRequest_OptType =
    $fidl.NullableUnionType<ComposedProtocolOnAnonComposedRequest>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: ComposedProtocolOnAnonComposedRequest._ctor,
  flexible: false,
  resource: false,
);

enum ComposedProtocolTwoWayAnonComposedRequestTag {
  b, // 0x1
}

const Map<int, ComposedProtocolTwoWayAnonComposedRequestTag>
    _ComposedProtocolTwoWayAnonComposedRequestTag_map = {
  1: ComposedProtocolTwoWayAnonComposedRequestTag.b,
};

class ComposedProtocolTwoWayAnonComposedRequest extends $fidl.Union {
  const ComposedProtocolTwoWayAnonComposedRequest.withB(bool value)
      : _ordinal = 1,
        _data = value;

  ComposedProtocolTwoWayAnonComposedRequest._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ComposedProtocolTwoWayAnonComposedRequestTag get $tag =>
      _ComposedProtocolTwoWayAnonComposedRequestTag_map[_ordinal]!;

  bool? get b {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ComposedProtocolTwoWayAnonComposedRequest _ctor(
      int ordinal, Object data) {
    return ComposedProtocolTwoWayAnonComposedRequest._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ComposedProtocolTwoWayAnonComposedRequest>
    kComposedProtocolTwoWayAnonComposedRequest_Type =
    $fidl.UnionType<ComposedProtocolTwoWayAnonComposedRequest>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: ComposedProtocolTwoWayAnonComposedRequest._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ComposedProtocolTwoWayAnonComposedRequest>
    kComposedProtocolTwoWayAnonComposedRequest_OptType =
    $fidl.NullableUnionType<ComposedProtocolTwoWayAnonComposedRequest>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: ComposedProtocolTwoWayAnonComposedRequest._ctor,
  flexible: false,
  resource: false,
);

enum ComposedProtocolOnAnonComposedWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, ComposedProtocolOnAnonComposedWithErrorResultTag>
    _ComposedProtocolOnAnonComposedWithErrorResultTag_map = {
  1: ComposedProtocolOnAnonComposedWithErrorResultTag.response,
  2: ComposedProtocolOnAnonComposedWithErrorResultTag.err,
};

class ComposedProtocolOnAnonComposedWithErrorResult extends $fidl.Union {
  const ComposedProtocolOnAnonComposedWithErrorResult.withResponse(
      ComposedProtocolOnAnonComposedWithErrorResponse value)
      : _ordinal = 1,
        _data = value;

  const ComposedProtocolOnAnonComposedWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  ComposedProtocolOnAnonComposedWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ComposedProtocolOnAnonComposedWithErrorResultTag get $tag =>
      _ComposedProtocolOnAnonComposedWithErrorResultTag_map[_ordinal]!;

  ComposedProtocolOnAnonComposedWithErrorResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ComposedProtocolOnAnonComposedWithErrorResult _ctor(
      int ordinal, Object data) {
    return ComposedProtocolOnAnonComposedWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ComposedProtocolOnAnonComposedWithErrorResult>
    kComposedProtocol_OnAnonComposedWithError_Result_Type =
    $fidl.UnionType<ComposedProtocolOnAnonComposedWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kComposedProtocol_OnAnonComposedWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ComposedProtocolOnAnonComposedWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ComposedProtocolOnAnonComposedWithErrorResult>
    kComposedProtocol_OnAnonComposedWithError_Result_OptType =
    $fidl.NullableUnionType<ComposedProtocolOnAnonComposedWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kComposedProtocol_OnAnonComposedWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ComposedProtocolOnAnonComposedWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum ComposedProtocolOnNamedComposedWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, ComposedProtocolOnNamedComposedWithErrorResultTag>
    _ComposedProtocolOnNamedComposedWithErrorResultTag_map = {
  1: ComposedProtocolOnNamedComposedWithErrorResultTag.response,
  2: ComposedProtocolOnNamedComposedWithErrorResultTag.err,
};

class ComposedProtocolOnNamedComposedWithErrorResult extends $fidl.Union {
  const ComposedProtocolOnNamedComposedWithErrorResult.withResponse(
      TablePayload value)
      : _ordinal = 1,
        _data = value;

  const ComposedProtocolOnNamedComposedWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  ComposedProtocolOnNamedComposedWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ComposedProtocolOnNamedComposedWithErrorResultTag get $tag =>
      _ComposedProtocolOnNamedComposedWithErrorResultTag_map[_ordinal]!;

  TablePayload? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ComposedProtocolOnNamedComposedWithErrorResult _ctor(
      int ordinal, Object data) {
    return ComposedProtocolOnNamedComposedWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ComposedProtocolOnNamedComposedWithErrorResult>
    kComposedProtocol_OnNamedComposedWithError_Result_Type =
    $fidl.UnionType<ComposedProtocolOnNamedComposedWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kTablePayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ComposedProtocolOnNamedComposedWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ComposedProtocolOnNamedComposedWithErrorResult>
    kComposedProtocol_OnNamedComposedWithError_Result_OptType =
    $fidl.NullableUnionType<ComposedProtocolOnNamedComposedWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kTablePayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ComposedProtocolOnNamedComposedWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum ComposedProtocolTwoWayAnonComposedWithErrorResponseTag {
  b, // 0x1
}

const Map<int, ComposedProtocolTwoWayAnonComposedWithErrorResponseTag>
    _ComposedProtocolTwoWayAnonComposedWithErrorResponseTag_map = {
  1: ComposedProtocolTwoWayAnonComposedWithErrorResponseTag.b,
};

class ComposedProtocolTwoWayAnonComposedWithErrorResponse extends $fidl.Union {
  const ComposedProtocolTwoWayAnonComposedWithErrorResponse.withB(bool value)
      : _ordinal = 1,
        _data = value;

  ComposedProtocolTwoWayAnonComposedWithErrorResponse._(
      int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ComposedProtocolTwoWayAnonComposedWithErrorResponseTag get $tag =>
      _ComposedProtocolTwoWayAnonComposedWithErrorResponseTag_map[_ordinal]!;

  bool? get b {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ComposedProtocolTwoWayAnonComposedWithErrorResponse _ctor(
      int ordinal, Object data) {
    return ComposedProtocolTwoWayAnonComposedWithErrorResponse._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ComposedProtocolTwoWayAnonComposedWithErrorResponse>
    kComposedProtocol_TwoWayAnonComposedWithError_Response_Type =
    $fidl.UnionType<ComposedProtocolTwoWayAnonComposedWithErrorResponse>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: ComposedProtocolTwoWayAnonComposedWithErrorResponse._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl
        .NullableUnionType<ComposedProtocolTwoWayAnonComposedWithErrorResponse>
    kComposedProtocol_TwoWayAnonComposedWithError_Response_OptType = $fidl
        .NullableUnionType<ComposedProtocolTwoWayAnonComposedWithErrorResponse>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: ComposedProtocolTwoWayAnonComposedWithErrorResponse._ctor,
  flexible: false,
  resource: false,
);

enum ComposedProtocolTwoWayAnonComposedWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, ComposedProtocolTwoWayAnonComposedWithErrorResultTag>
    _ComposedProtocolTwoWayAnonComposedWithErrorResultTag_map = {
  1: ComposedProtocolTwoWayAnonComposedWithErrorResultTag.response,
  2: ComposedProtocolTwoWayAnonComposedWithErrorResultTag.err,
};

class ComposedProtocolTwoWayAnonComposedWithErrorResult extends $fidl.Union {
  const ComposedProtocolTwoWayAnonComposedWithErrorResult.withResponse(
      ComposedProtocolTwoWayAnonComposedWithErrorResponse value)
      : _ordinal = 1,
        _data = value;

  const ComposedProtocolTwoWayAnonComposedWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  ComposedProtocolTwoWayAnonComposedWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ComposedProtocolTwoWayAnonComposedWithErrorResultTag get $tag =>
      _ComposedProtocolTwoWayAnonComposedWithErrorResultTag_map[_ordinal]!;

  ComposedProtocolTwoWayAnonComposedWithErrorResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ComposedProtocolTwoWayAnonComposedWithErrorResult _ctor(
      int ordinal, Object data) {
    return ComposedProtocolTwoWayAnonComposedWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ComposedProtocolTwoWayAnonComposedWithErrorResult>
    kComposedProtocol_TwoWayAnonComposedWithError_Result_Type =
    $fidl.UnionType<ComposedProtocolTwoWayAnonComposedWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kComposedProtocol_TwoWayAnonComposedWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ComposedProtocolTwoWayAnonComposedWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<ComposedProtocolTwoWayAnonComposedWithErrorResult>
    kComposedProtocol_TwoWayAnonComposedWithError_Result_OptType =
    $fidl.NullableUnionType<ComposedProtocolTwoWayAnonComposedWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kComposedProtocol_TwoWayAnonComposedWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ComposedProtocolTwoWayAnonComposedWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum ComposedProtocolTwoWayNamedComposedWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, ComposedProtocolTwoWayNamedComposedWithErrorResultTag>
    _ComposedProtocolTwoWayNamedComposedWithErrorResultTag_map = {
  1: ComposedProtocolTwoWayNamedComposedWithErrorResultTag.response,
  2: ComposedProtocolTwoWayNamedComposedWithErrorResultTag.err,
};

class ComposedProtocolTwoWayNamedComposedWithErrorResult extends $fidl.Union {
  const ComposedProtocolTwoWayNamedComposedWithErrorResult.withResponse(
      UnionPayload value)
      : _ordinal = 1,
        _data = value;

  const ComposedProtocolTwoWayNamedComposedWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  ComposedProtocolTwoWayNamedComposedWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ComposedProtocolTwoWayNamedComposedWithErrorResultTag get $tag =>
      _ComposedProtocolTwoWayNamedComposedWithErrorResultTag_map[_ordinal]!;

  UnionPayload? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ComposedProtocolTwoWayNamedComposedWithErrorResult _ctor(
      int ordinal, Object data) {
    return ComposedProtocolTwoWayNamedComposedWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ComposedProtocolTwoWayNamedComposedWithErrorResult>
    kComposedProtocol_TwoWayNamedComposedWithError_Result_Type =
    $fidl.UnionType<ComposedProtocolTwoWayNamedComposedWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kUnionPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ComposedProtocolTwoWayNamedComposedWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl
        .NullableUnionType<ComposedProtocolTwoWayNamedComposedWithErrorResult>
    kComposedProtocol_TwoWayNamedComposedWithError_Result_OptType =
    $fidl.NullableUnionType<ComposedProtocolTwoWayNamedComposedWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kUnionPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: ComposedProtocolTwoWayNamedComposedWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolOnAnonRequestTag {
  $unknown,
  b, // 0x1
}

const Map<int, MainProtocolOnAnonRequestTag> _MainProtocolOnAnonRequestTag_map =
    {
  1: MainProtocolOnAnonRequestTag.b,
};

class MainProtocolOnAnonRequest extends $fidl.Union {
  const MainProtocolOnAnonRequest.withB(bool value)
      : _ordinal = 1,
        _data = value;
  const MainProtocolOnAnonRequest.with$UnknownData(
      this._ordinal, $fidl.UnknownRawData data)
      : _data = data;

  MainProtocolOnAnonRequest._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolOnAnonRequestTag get $tag =>
      _MainProtocolOnAnonRequestTag_map[_ordinal] ??
      MainProtocolOnAnonRequestTag.$unknown;

  bool? get b {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolOnAnonRequest _ctor(int ordinal, Object data) {
    return MainProtocolOnAnonRequest._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolOnAnonRequest>
    kMainProtocolOnAnonRequest_Type =
    $fidl.UnionType<MainProtocolOnAnonRequest>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: MainProtocolOnAnonRequest._ctor,
  flexible: true,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolOnAnonRequest>
    kMainProtocolOnAnonRequest_OptType =
    $fidl.NullableUnionType<MainProtocolOnAnonRequest>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: MainProtocolOnAnonRequest._ctor,
  flexible: true,
  resource: false,
);

enum MainProtocolTwoWayAnonRequestTag {
  $unknown,
  b, // 0x1
}

const Map<int, MainProtocolTwoWayAnonRequestTag>
    _MainProtocolTwoWayAnonRequestTag_map = {
  1: MainProtocolTwoWayAnonRequestTag.b,
};

class MainProtocolTwoWayAnonRequest extends $fidl.Union {
  const MainProtocolTwoWayAnonRequest.withB(bool value)
      : _ordinal = 1,
        _data = value;
  const MainProtocolTwoWayAnonRequest.with$UnknownData(
      this._ordinal, $fidl.UnknownRawData data)
      : _data = data;

  MainProtocolTwoWayAnonRequest._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolTwoWayAnonRequestTag get $tag =>
      _MainProtocolTwoWayAnonRequestTag_map[_ordinal] ??
      MainProtocolTwoWayAnonRequestTag.$unknown;

  bool? get b {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolTwoWayAnonRequest _ctor(int ordinal, Object data) {
    return MainProtocolTwoWayAnonRequest._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolTwoWayAnonRequest>
    kMainProtocolTwoWayAnonRequest_Type =
    $fidl.UnionType<MainProtocolTwoWayAnonRequest>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: MainProtocolTwoWayAnonRequest._ctor,
  flexible: true,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolTwoWayAnonRequest>
    kMainProtocolTwoWayAnonRequest_OptType =
    $fidl.NullableUnionType<MainProtocolTwoWayAnonRequest>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: MainProtocolTwoWayAnonRequest._ctor,
  flexible: true,
  resource: false,
);

enum MainProtocolOnAnonWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolOnAnonWithErrorResultTag>
    _MainProtocolOnAnonWithErrorResultTag_map = {
  1: MainProtocolOnAnonWithErrorResultTag.response,
  2: MainProtocolOnAnonWithErrorResultTag.err,
};

class MainProtocolOnAnonWithErrorResult extends $fidl.Union {
  const MainProtocolOnAnonWithErrorResult.withResponse(
      MainProtocolOnAnonWithErrorResponse value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolOnAnonWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolOnAnonWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolOnAnonWithErrorResultTag get $tag =>
      _MainProtocolOnAnonWithErrorResultTag_map[_ordinal]!;

  MainProtocolOnAnonWithErrorResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolOnAnonWithErrorResult _ctor(int ordinal, Object data) {
    return MainProtocolOnAnonWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolOnAnonWithErrorResult>
    kMainProtocol_OnAnonWithError_Result_Type =
    $fidl.UnionType<MainProtocolOnAnonWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kMainProtocol_OnAnonWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnAnonWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolOnAnonWithErrorResult>
    kMainProtocol_OnAnonWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolOnAnonWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kMainProtocol_OnAnonWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnAnonWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolOnLocalWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolOnLocalWithErrorResultTag>
    _MainProtocolOnLocalWithErrorResultTag_map = {
  1: MainProtocolOnLocalWithErrorResultTag.response,
  2: MainProtocolOnLocalWithErrorResultTag.err,
};

class MainProtocolOnLocalWithErrorResult extends $fidl.Union {
  const MainProtocolOnLocalWithErrorResult.withResponse(TablePayload value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolOnLocalWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolOnLocalWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolOnLocalWithErrorResultTag get $tag =>
      _MainProtocolOnLocalWithErrorResultTag_map[_ordinal]!;

  TablePayload? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolOnLocalWithErrorResult _ctor(int ordinal, Object data) {
    return MainProtocolOnLocalWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolOnLocalWithErrorResult>
    kMainProtocol_OnLocalWithError_Result_Type =
    $fidl.UnionType<MainProtocolOnLocalWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kTablePayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnLocalWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolOnLocalWithErrorResult>
    kMainProtocol_OnLocalWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolOnLocalWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kTablePayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolOnLocalWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolTwoWayAnonWithErrorResponseTag {
  $unknown,
  b, // 0x1
}

const Map<int, MainProtocolTwoWayAnonWithErrorResponseTag>
    _MainProtocolTwoWayAnonWithErrorResponseTag_map = {
  1: MainProtocolTwoWayAnonWithErrorResponseTag.b,
};

class MainProtocolTwoWayAnonWithErrorResponse extends $fidl.Union {
  const MainProtocolTwoWayAnonWithErrorResponse.withB(bool value)
      : _ordinal = 1,
        _data = value;
  const MainProtocolTwoWayAnonWithErrorResponse.with$UnknownData(
      this._ordinal, $fidl.UnknownRawData data)
      : _data = data;

  MainProtocolTwoWayAnonWithErrorResponse._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolTwoWayAnonWithErrorResponseTag get $tag =>
      _MainProtocolTwoWayAnonWithErrorResponseTag_map[_ordinal] ??
      MainProtocolTwoWayAnonWithErrorResponseTag.$unknown;

  bool? get b {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolTwoWayAnonWithErrorResponse _ctor(
      int ordinal, Object data) {
    return MainProtocolTwoWayAnonWithErrorResponse._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolTwoWayAnonWithErrorResponse>
    kMainProtocol_TwoWayAnonWithError_Response_Type =
    $fidl.UnionType<MainProtocolTwoWayAnonWithErrorResponse>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: MainProtocolTwoWayAnonWithErrorResponse._ctor,
  flexible: true,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolTwoWayAnonWithErrorResponse>
    kMainProtocol_TwoWayAnonWithError_Response_OptType =
    $fidl.NullableUnionType<MainProtocolTwoWayAnonWithErrorResponse>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: MainProtocolTwoWayAnonWithErrorResponse._ctor,
  flexible: true,
  resource: false,
);

enum MainProtocolTwoWayAnonWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolTwoWayAnonWithErrorResultTag>
    _MainProtocolTwoWayAnonWithErrorResultTag_map = {
  1: MainProtocolTwoWayAnonWithErrorResultTag.response,
  2: MainProtocolTwoWayAnonWithErrorResultTag.err,
};

class MainProtocolTwoWayAnonWithErrorResult extends $fidl.Union {
  const MainProtocolTwoWayAnonWithErrorResult.withResponse(
      MainProtocolTwoWayAnonWithErrorResponse value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolTwoWayAnonWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolTwoWayAnonWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolTwoWayAnonWithErrorResultTag get $tag =>
      _MainProtocolTwoWayAnonWithErrorResultTag_map[_ordinal]!;

  MainProtocolTwoWayAnonWithErrorResponse? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolTwoWayAnonWithErrorResult _ctor(int ordinal, Object data) {
    return MainProtocolTwoWayAnonWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolTwoWayAnonWithErrorResult>
    kMainProtocol_TwoWayAnonWithError_Result_Type =
    $fidl.UnionType<MainProtocolTwoWayAnonWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kMainProtocol_TwoWayAnonWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayAnonWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolTwoWayAnonWithErrorResult>
    kMainProtocol_TwoWayAnonWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolTwoWayAnonWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kMainProtocol_TwoWayAnonWithError_Response_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayAnonWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum MainProtocolTwoWayLocalWithErrorResultTag {
  response, // 0x1
  err, // 0x2
}

const Map<int, MainProtocolTwoWayLocalWithErrorResultTag>
    _MainProtocolTwoWayLocalWithErrorResultTag_map = {
  1: MainProtocolTwoWayLocalWithErrorResultTag.response,
  2: MainProtocolTwoWayLocalWithErrorResultTag.err,
};

class MainProtocolTwoWayLocalWithErrorResult extends $fidl.Union {
  const MainProtocolTwoWayLocalWithErrorResult.withResponse(UnionPayload value)
      : _ordinal = 1,
        _data = value;

  const MainProtocolTwoWayLocalWithErrorResult.withErr(int value)
      : _ordinal = 2,
        _data = value;

  MainProtocolTwoWayLocalWithErrorResult._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  MainProtocolTwoWayLocalWithErrorResultTag get $tag =>
      _MainProtocolTwoWayLocalWithErrorResultTag_map[_ordinal]!;

  UnionPayload? get response {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int? get err {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
      case 2:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static MainProtocolTwoWayLocalWithErrorResult _ctor(
      int ordinal, Object data) {
    return MainProtocolTwoWayLocalWithErrorResult._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<MainProtocolTwoWayLocalWithErrorResult>
    kMainProtocol_TwoWayLocalWithError_Result_Type =
    $fidl.UnionType<MainProtocolTwoWayLocalWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kUnionPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayLocalWithErrorResult._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<MainProtocolTwoWayLocalWithErrorResult>
    kMainProtocol_TwoWayLocalWithError_Result_OptType =
    $fidl.NullableUnionType<MainProtocolTwoWayLocalWithErrorResult>(
  members: <int, $fidl.FidlType>{
    1: kUnionPayload_Type,
    2: $fidl.Uint32Type(),
  },
  ctor: MainProtocolTwoWayLocalWithErrorResult._ctor,
  flexible: false,
  resource: false,
);

enum UnionPayloadTag {
  b, // 0x1
}

const Map<int, UnionPayloadTag> _UnionPayloadTag_map = {
  1: UnionPayloadTag.b,
};

class UnionPayload extends $fidl.Union {
  const UnionPayload.withB(bool value)
      : _ordinal = 1,
        _data = value;

  UnionPayload._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  UnionPayloadTag get $tag => _UnionPayloadTag_map[_ordinal]!;

  bool? get b {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  $fidl.UnknownRawData? get $unknownData {
    switch (_ordinal) {
      case 1:
        return null;
      default:
        return _data;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static UnionPayload _ctor(int ordinal, Object data) {
    return UnionPayload._(ordinal, data);
  }
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<UnionPayload> kUnionPayload_Type =
    $fidl.UnionType<UnionPayload>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: UnionPayload._ctor,
  flexible: false,
  resource: false,
);
// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.NullableUnionType<UnionPayload> kUnionPayload_OptType =
    $fidl.NullableUnionType<UnionPayload>(
  members: <int, $fidl.FidlType>{
    1: $fidl.BoolType(),
  },
  ctor: UnionPayload._ctor,
  flexible: false,
  resource: false,
);

class ComposedProtocolOneWayAnonComposedRequest extends $fidl.Table {
  const ComposedProtocolOneWayAnonComposedRequest({
    this.$unknownData,
    this.a,
  });

  ComposedProtocolOneWayAnonComposedRequest._(
      Map<int, dynamic> argv, this.$unknownData)
      : a = argv[1];

  ComposedProtocolOneWayAnonComposedRequest $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return ComposedProtocolOneWayAnonComposedRequest(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static ComposedProtocolOneWayAnonComposedRequest _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      ComposedProtocolOneWayAnonComposedRequest._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<ComposedProtocolOneWayAnonComposedRequest>
    kComposedProtocolOneWayAnonComposedRequest_Type =
    $fidl.TableType<ComposedProtocolOneWayAnonComposedRequest>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: ComposedProtocolOneWayAnonComposedRequest._ctor,
  resource: false,
);

class ComposedProtocolTwoWayAnonComposedResponse extends $fidl.Table {
  const ComposedProtocolTwoWayAnonComposedResponse({
    this.$unknownData,
    this.a,
  });

  ComposedProtocolTwoWayAnonComposedResponse._(
      Map<int, dynamic> argv, this.$unknownData)
      : a = argv[1];

  ComposedProtocolTwoWayAnonComposedResponse $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return ComposedProtocolTwoWayAnonComposedResponse(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static ComposedProtocolTwoWayAnonComposedResponse _ctor(
          Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      ComposedProtocolTwoWayAnonComposedResponse._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<ComposedProtocolTwoWayAnonComposedResponse>
    kComposedProtocolTwoWayAnonComposedResponse_Type =
    $fidl.TableType<ComposedProtocolTwoWayAnonComposedResponse>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: ComposedProtocolTwoWayAnonComposedResponse._ctor,
  resource: false,
);

class ComposedProtocolTwoWayAnonComposedWithErrorRequest extends $fidl.Table {
  const ComposedProtocolTwoWayAnonComposedWithErrorRequest({
    this.$unknownData,
    this.a,
  });

  ComposedProtocolTwoWayAnonComposedWithErrorRequest._(
      Map<int, dynamic> argv, this.$unknownData)
      : a = argv[1];

  ComposedProtocolTwoWayAnonComposedWithErrorRequest $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return ComposedProtocolTwoWayAnonComposedWithErrorRequest(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static ComposedProtocolTwoWayAnonComposedWithErrorRequest _ctor(
          Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      ComposedProtocolTwoWayAnonComposedWithErrorRequest._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<ComposedProtocolTwoWayAnonComposedWithErrorRequest>
    kComposedProtocolTwoWayAnonComposedWithErrorRequest_Type =
    $fidl.TableType<ComposedProtocolTwoWayAnonComposedWithErrorRequest>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: ComposedProtocolTwoWayAnonComposedWithErrorRequest._ctor,
  resource: false,
);

class ComposedProtocolOnAnonComposedWithErrorResponse extends $fidl.Table {
  const ComposedProtocolOnAnonComposedWithErrorResponse({
    this.$unknownData,
    this.a,
  });

  ComposedProtocolOnAnonComposedWithErrorResponse._(
      Map<int, dynamic> argv, this.$unknownData)
      : a = argv[1];

  ComposedProtocolOnAnonComposedWithErrorResponse $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return ComposedProtocolOnAnonComposedWithErrorResponse(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static ComposedProtocolOnAnonComposedWithErrorResponse _ctor(
          Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      ComposedProtocolOnAnonComposedWithErrorResponse._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<ComposedProtocolOnAnonComposedWithErrorResponse>
    kComposedProtocol_OnAnonComposedWithError_Response_Type =
    $fidl.TableType<ComposedProtocolOnAnonComposedWithErrorResponse>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: ComposedProtocolOnAnonComposedWithErrorResponse._ctor,
  resource: false,
);

class MainProtocolOneWayAnonRequest extends $fidl.Table {
  const MainProtocolOneWayAnonRequest({
    this.$unknownData,
    this.a,
  });

  MainProtocolOneWayAnonRequest._(Map<int, dynamic> argv, this.$unknownData)
      : a = argv[1];

  MainProtocolOneWayAnonRequest $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return MainProtocolOneWayAnonRequest(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static MainProtocolOneWayAnonRequest _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      MainProtocolOneWayAnonRequest._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<MainProtocolOneWayAnonRequest>
    kMainProtocolOneWayAnonRequest_Type =
    $fidl.TableType<MainProtocolOneWayAnonRequest>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: MainProtocolOneWayAnonRequest._ctor,
  resource: false,
);

class MainProtocolTwoWayAnonResponse extends $fidl.Table {
  const MainProtocolTwoWayAnonResponse({
    this.$unknownData,
    this.a,
  });

  MainProtocolTwoWayAnonResponse._(Map<int, dynamic> argv, this.$unknownData)
      : a = argv[1];

  MainProtocolTwoWayAnonResponse $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return MainProtocolTwoWayAnonResponse(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static MainProtocolTwoWayAnonResponse _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      MainProtocolTwoWayAnonResponse._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<MainProtocolTwoWayAnonResponse>
    kMainProtocolTwoWayAnonResponse_Type =
    $fidl.TableType<MainProtocolTwoWayAnonResponse>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: MainProtocolTwoWayAnonResponse._ctor,
  resource: false,
);

class MainProtocolTwoWayAnonWithErrorRequest extends $fidl.Table {
  const MainProtocolTwoWayAnonWithErrorRequest({
    this.$unknownData,
    this.a,
  });

  MainProtocolTwoWayAnonWithErrorRequest._(
      Map<int, dynamic> argv, this.$unknownData)
      : a = argv[1];

  MainProtocolTwoWayAnonWithErrorRequest $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return MainProtocolTwoWayAnonWithErrorRequest(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static MainProtocolTwoWayAnonWithErrorRequest _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      MainProtocolTwoWayAnonWithErrorRequest._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<MainProtocolTwoWayAnonWithErrorRequest>
    kMainProtocolTwoWayAnonWithErrorRequest_Type =
    $fidl.TableType<MainProtocolTwoWayAnonWithErrorRequest>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: MainProtocolTwoWayAnonWithErrorRequest._ctor,
  resource: false,
);

class MainProtocolOnAnonWithErrorResponse extends $fidl.Table {
  const MainProtocolOnAnonWithErrorResponse({
    this.$unknownData,
    this.a,
  });

  MainProtocolOnAnonWithErrorResponse._(
      Map<int, dynamic> argv, this.$unknownData)
      : a = argv[1];

  MainProtocolOnAnonWithErrorResponse $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return MainProtocolOnAnonWithErrorResponse(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static MainProtocolOnAnonWithErrorResponse _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      MainProtocolOnAnonWithErrorResponse._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<MainProtocolOnAnonWithErrorResponse>
    kMainProtocol_OnAnonWithError_Response_Type =
    $fidl.TableType<MainProtocolOnAnonWithErrorResponse>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: MainProtocolOnAnonWithErrorResponse._ctor,
  resource: false,
);

class TablePayload extends $fidl.Table {
  const TablePayload({
    this.$unknownData,
    this.a,
  });

  TablePayload._(Map<int, dynamic> argv, this.$unknownData) : a = argv[1];

  TablePayload $cloneWith({
    $fidl.OptionalNullable<Map<int, $fidl.UnknownRawData>> $unknownData =
        const $fidl.OptionalNullable.undefined(),
    $fidl.OptionalNullable<int> a = const $fidl.OptionalNullable.undefined(),
  }) {
    return TablePayload(
      a: a.or(this.a),
    );
  }

  @override
  final Map<int, $fidl.UnknownRawData>? $unknownData;
  final int? a;

  @override
  dynamic $field(int index) {
    switch (index) {
      case 0:
        return a;
    }
    return null;
  }

  @override
  Map<int, dynamic> get $fields {
    return {
      1: a,
    };
  }

  static TablePayload _ctor(Map<int, dynamic> argv,
          [Map<int, $fidl.UnknownRawData>? unknownData]) =>
      TablePayload._(argv, unknownData);
}

// See fxbug.dev/7644:
// ignore: recursive_compile_time_constant
const $fidl.TableType<TablePayload> kTablePayload_Type =
    $fidl.TableType<TablePayload>(
  inlineSize: 16,
  members: [
    $fidl.Uint16Type(),
  ],
  ctor: TablePayload._ctor,
  resource: false,
);

// oneWayAnonComposed: (ComposedProtocolOneWayAnonComposedRequest payload)
const int _kComposedProtocol_OneWayAnonComposed_Ordinal = 0x6e7a205bdad7941f;
const $fidl.MethodType _kComposedProtocol_OneWayAnonComposed_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolOneWayAnonComposedRequest>(
        type: kComposedProtocolOneWayAnonComposedRequest_Type, offset: 0),
  ],
  response: [],
  name: r"ComposedProtocol.OneWayAnonComposed",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// twoWayAnonComposed: (ComposedProtocolTwoWayAnonComposedRequest payload) -> (ComposedProtocolTwoWayAnonComposedResponse payload)
const int _kComposedProtocol_TwoWayAnonComposed_Ordinal = 0x7083713dee9435f4;
const $fidl.MethodType _kComposedProtocol_TwoWayAnonComposed_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolTwoWayAnonComposedRequest>(
        type: kComposedProtocolTwoWayAnonComposedRequest_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolTwoWayAnonComposedResponse>(
        type: kComposedProtocolTwoWayAnonComposedResponse_Type, offset: 0),
  ],
  name: r"ComposedProtocol.TwoWayAnonComposed",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// twoWayAnonComposedWithError: (ComposedProtocolTwoWayAnonComposedWithErrorRequest payload) -> (ComposedProtocolTwoWayAnonComposedWithErrorResponse payload)
const int _kComposedProtocol_TwoWayAnonComposedWithError_Ordinal =
    0x4fd32c5e2ffa6828;
const $fidl.MethodType _kComposedProtocol_TwoWayAnonComposedWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolTwoWayAnonComposedWithErrorRequest>(
        type: kComposedProtocolTwoWayAnonComposedWithErrorRequest_Type,
        offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolTwoWayAnonComposedWithErrorResult>(
        type: kComposedProtocol_TwoWayAnonComposedWithError_Result_Type,
        offset: 0),
  ],
  name: r"ComposedProtocol.TwoWayAnonComposedWithError",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// onAnonComposed:  -> (ComposedProtocolOnAnonComposedRequest payload)
const int _kComposedProtocol_OnAnonComposed_Ordinal = 0x49a6eee3a0300e28;
const $fidl.MethodType _kComposedProtocol_OnAnonComposed_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolOnAnonComposedRequest>(
        type: kComposedProtocolOnAnonComposedRequest_Type, offset: 0),
  ],
  name: r"ComposedProtocol.OnAnonComposed",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// onAnonComposedWithError:  -> (ComposedProtocolOnAnonComposedWithErrorResponse payload)
const int _kComposedProtocol_OnAnonComposedWithError_Ordinal =
    0x297a909727d08a60;
const $fidl.MethodType _kComposedProtocol_OnAnonComposedWithError_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolOnAnonComposedWithErrorResult>(
        type: kComposedProtocol_OnAnonComposedWithError_Result_Type, offset: 0),
  ],
  name: r"ComposedProtocol.OnAnonComposedWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// oneWayNamedComposed: (TablePayload payload)
const int _kComposedProtocol_OneWayNamedComposed_Ordinal = 0x101636a8fa3e69b8;
const $fidl.MethodType _kComposedProtocol_OneWayNamedComposed_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<TablePayload>(type: kTablePayload_Type, offset: 0),
  ],
  response: [],
  name: r"ComposedProtocol.OneWayNamedComposed",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// twoWayNamedComposed: (UnionPayload payload) -> (TablePayload payload)
const int _kComposedProtocol_TwoWayNamedComposed_Ordinal = 0x45b4d3d31b374054;
const $fidl.MethodType _kComposedProtocol_TwoWayNamedComposed_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<UnionPayload>(type: kUnionPayload_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<TablePayload>(type: kTablePayload_Type, offset: 0),
  ],
  name: r"ComposedProtocol.TwoWayNamedComposed",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// twoWayNamedComposedWithError: (TablePayload payload) -> (UnionPayload payload)
const int _kComposedProtocol_TwoWayNamedComposedWithError_Ordinal =
    0x450531e2d20c52ef;
const $fidl.MethodType _kComposedProtocol_TwoWayNamedComposedWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<TablePayload>(type: kTablePayload_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolTwoWayNamedComposedWithErrorResult>(
        type: kComposedProtocol_TwoWayNamedComposedWithError_Result_Type,
        offset: 0),
  ],
  name: r"ComposedProtocol.TwoWayNamedComposedWithError",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// onNamedComposed:  -> (UnionPayload payload)
const int _kComposedProtocol_OnNamedComposed_Ordinal = 0x17c4edb4a4a36d7b;
const $fidl.MethodType _kComposedProtocol_OnNamedComposed_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<UnionPayload>(type: kUnionPayload_Type, offset: 0),
  ],
  name: r"ComposedProtocol.OnNamedComposed",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// onNamedComposedWithError:  -> (TablePayload payload)
const int _kComposedProtocol_OnNamedComposedWithError_Ordinal =
    0x3ff74c1cafdbabcf;
const $fidl.MethodType _kComposedProtocol_OnNamedComposedWithError_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolOnNamedComposedWithErrorResult>(
        type: kComposedProtocol_OnNamedComposedWithError_Result_Type,
        offset: 0),
  ],
  name: r"ComposedProtocol.OnNamedComposedWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);

abstract class ComposedProtocol {
  $fidl.ServiceData? get $serviceData => ComposedProtocolData();
  $async.Future<void> oneWayAnonComposed(
      ComposedProtocolOneWayAnonComposedRequest payload);
  $async.Future<ComposedProtocolTwoWayAnonComposedResponse> twoWayAnonComposed(
      ComposedProtocolTwoWayAnonComposedRequest payload);
  $async.Future<ComposedProtocolTwoWayAnonComposedWithErrorResponse>
      twoWayAnonComposedWithError(
          ComposedProtocolTwoWayAnonComposedWithErrorRequest payload);
  $async.Stream<ComposedProtocolOnAnonComposedRequest>? get onAnonComposed;
  $async.Stream<ComposedProtocolOnAnonComposedWithErrorResponse>?
      get onAnonComposedWithError;
  $async.Future<void> oneWayNamedComposed(TablePayload payload);
  $async.Future<TablePayload> twoWayNamedComposed(UnionPayload payload);
  $async.Future<UnionPayload> twoWayNamedComposedWithError(
      TablePayload payload);
  $async.Stream<UnionPayload>? get onNamedComposed;
  $async.Stream<TablePayload>? get onNamedComposedWithError;
} // TODO: Remove ServiceData for non-service

class ComposedProtocolData implements $fidl.ServiceData<ComposedProtocol> {
  const ComposedProtocolData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return ComposedProtocolBinding();
  }
}

class ComposedProtocolProxy extends $fidl.AsyncProxy<ComposedProtocol>
    implements ComposedProtocol {
  ComposedProtocolProxy()
      : super($fidl.AsyncProxyController<ComposedProtocol>(
            $interfaceName: r'ComposedProtocol')) {
    ctrl.onResponse = _handleResponse;
    ctrl.whenClosed.then((_) {
      _onAnonComposedEventStreamController.close();
      _onAnonComposedWithErrorEventStreamController.close();
      _onNamedComposedEventStreamController.close();
      _onNamedComposedWithErrorEventStreamController.close();
    }, onError: (_) {});
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      case _kComposedProtocol_OnAnonComposed_Ordinal:
        final String _name = _kComposedProtocol_OnAnonComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _onAnonComposedEventStreamController.addError,
            () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_OnAnonComposed_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kComposedProtocol_OnAnonComposed_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $response = $fidl.decodeMessage(
              $message,
              _kComposedProtocol_OnAnonComposed_Type
                  .responseInlineSize($wireFormat),
              $types[0]);
          _onAnonComposedEventStreamController.add($response);
        });
        break;
      case _kComposedProtocol_OnAnonComposedWithError_Ordinal:
        final String _name =
            _kComposedProtocol_OnAnonComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onAnonComposedWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_OnAnonComposedWithError_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kComposedProtocol_OnAnonComposedWithError_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final ComposedProtocolOnAnonComposedWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kComposedProtocol_OnAnonComposedWithError_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              ComposedProtocolOnAnonComposedWithErrorResultTag.response) {
            _onAnonComposedWithErrorEventStreamController
                .add($response.response!);
          } else {
            _onAnonComposedWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kComposedProtocol_OnNamedComposed_Ordinal:
        final String _name = _kComposedProtocol_OnNamedComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onNamedComposedEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_OnNamedComposed_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kComposedProtocol_OnNamedComposed_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $response = $fidl.decodeMessage(
              $message,
              _kComposedProtocol_OnNamedComposed_Type
                  .responseInlineSize($wireFormat),
              $types[0]);
          _onNamedComposedEventStreamController.add($response);
        });
        break;
      case _kComposedProtocol_OnNamedComposedWithError_Ordinal:
        final String _name =
            _kComposedProtocol_OnNamedComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onNamedComposedWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_OnNamedComposedWithError_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kComposedProtocol_OnNamedComposedWithError_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final ComposedProtocolOnNamedComposedWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kComposedProtocol_OnNamedComposedWithError_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              ComposedProtocolOnNamedComposedWithErrorResultTag.response) {
            _onNamedComposedWithErrorEventStreamController
                .add($response.response!);
          } else {
            _onNamedComposedWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      default:
        $message.closeHandles();
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      case _kComposedProtocol_TwoWayAnonComposed_Ordinal:
        final String _name = _kComposedProtocol_TwoWayAnonComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_TwoWayAnonComposed_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kComposedProtocol_TwoWayAnonComposed_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $response = $fidl.decodeMessage(
              $message,
              _kComposedProtocol_TwoWayAnonComposed_Type
                  .responseInlineSize($wireFormat),
              $types[0]);
          $completer.complete($response);
        });
        break;
      case _kComposedProtocol_TwoWayAnonComposedWithError_Ordinal:
        final String _name =
            _kComposedProtocol_TwoWayAnonComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_TwoWayAnonComposedWithError_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final ComposedProtocolTwoWayAnonComposedWithErrorResult $response =
              $fidl.decodeMaybeLargeMessage(
                  $message,
                  _kComposedProtocol_TwoWayAnonComposedWithError_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              ComposedProtocolTwoWayAnonComposedWithErrorResultTag.response) {
            $completer.complete($response.response!);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kComposedProtocol_TwoWayNamedComposed_Ordinal:
        final String _name = _kComposedProtocol_TwoWayNamedComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_TwoWayNamedComposed_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kComposedProtocol_TwoWayNamedComposed_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $response = $fidl.decodeMessage(
              $message,
              _kComposedProtocol_TwoWayNamedComposed_Type
                  .responseInlineSize($wireFormat),
              $types[0]);
          $completer.complete($response);
        });
        break;
      case _kComposedProtocol_TwoWayNamedComposedWithError_Ordinal:
        final String _name =
            _kComposedProtocol_TwoWayNamedComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_TwoWayNamedComposedWithError_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final ComposedProtocolTwoWayNamedComposedWithErrorResult $response =
              $fidl.decodeMaybeLargeMessage(
                  $message,
                  _kComposedProtocol_TwoWayNamedComposedWithError_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              ComposedProtocolTwoWayNamedComposedWithErrorResultTag.response) {
            $completer.complete($response.response!);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<void> oneWayAnonComposed(
      ComposedProtocolOneWayAnonComposedRequest payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kComposedProtocol_OneWayAnonComposed_Ordinal,
        0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kComposedProtocol_OneWayAnonComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kComposedProtocol_OneWayAnonComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<ComposedProtocolTwoWayAnonComposedResponse> twoWayAnonComposed(
      ComposedProtocolTwoWayAnonComposedRequest payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kComposedProtocol_TwoWayAnonComposed_Ordinal,
        0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kComposedProtocol_TwoWayAnonComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kComposedProtocol_TwoWayAnonComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<ComposedProtocolTwoWayAnonComposedResponse>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<ComposedProtocolTwoWayAnonComposedWithErrorResponse>
      twoWayAnonComposedWithError(
          ComposedProtocolTwoWayAnonComposedWithErrorRequest payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kComposedProtocol_TwoWayAnonComposedWithError_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kComposedProtocol_TwoWayAnonComposedWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kComposedProtocol_TwoWayAnonComposedWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<ComposedProtocolTwoWayAnonComposedWithErrorResponse>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onAnonComposedEventStreamController = $async
      .StreamController<ComposedProtocolOnAnonComposedRequest>.broadcast();
  @override
  $async.Stream<ComposedProtocolOnAnonComposedRequest> get onAnonComposed =>
      _onAnonComposedEventStreamController.stream;

  final _onAnonComposedWithErrorEventStreamController = $async.StreamController<
      ComposedProtocolOnAnonComposedWithErrorResponse>.broadcast();
  @override
  $async.Stream<ComposedProtocolOnAnonComposedWithErrorResponse>
      get onAnonComposedWithError =>
          _onAnonComposedWithErrorEventStreamController.stream;

  @override
  $async.Future<void> oneWayNamedComposed(TablePayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kComposedProtocol_OneWayNamedComposed_Ordinal,
        0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kComposedProtocol_OneWayNamedComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kComposedProtocol_OneWayNamedComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<TablePayload> twoWayNamedComposed(UnionPayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kComposedProtocol_TwoWayNamedComposed_Ordinal,
        0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kComposedProtocol_TwoWayNamedComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kComposedProtocol_TwoWayNamedComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<TablePayload>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<UnionPayload> twoWayNamedComposedWithError(
      TablePayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kComposedProtocol_TwoWayNamedComposedWithError_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kComposedProtocol_TwoWayNamedComposedWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kComposedProtocol_TwoWayNamedComposedWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<UnionPayload>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onNamedComposedEventStreamController =
      $async.StreamController<UnionPayload>.broadcast();
  @override
  $async.Stream<UnionPayload> get onNamedComposed =>
      _onNamedComposedEventStreamController.stream;

  final _onNamedComposedWithErrorEventStreamController =
      $async.StreamController<TablePayload>.broadcast();
  @override
  $async.Stream<TablePayload> get onNamedComposedWithError =>
      _onNamedComposedWithErrorEventStreamController.stream;
}

class ComposedProtocolBinding extends $fidl.AsyncBinding<ComposedProtocol> {
  ComposedProtocolBinding() : super(r"ComposedProtocol") {
    final List<$async.StreamSubscription<dynamic>> $subscriptions = [];
    void $unsubscribe() {
      for (final $sub in $subscriptions) {
        $sub.cancel();
      }
      $subscriptions.clear();
    }

    whenBound.then((_) {
      final impl = this.impl;
      if (impl != null) {
        final _onAnonComposed_stream = impl.onAnonComposed;
        if (_onAnonComposed_stream != null) {
          $subscriptions.add(_onAnonComposed_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kComposedProtocol_OnAnonComposed_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kComposedProtocol_OnAnonComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kComposedProtocol_OnAnonComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kComposedProtocol_OnAnonComposed_Type.name, _e, close);
          }));
        }
        final _onAnonComposedWithError_stream = impl.onAnonComposedWithError;
        if (_onAnonComposedWithError_stream != null) {
          $subscriptions.add(_onAnonComposedWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (ComposedProtocolOnAnonComposedWithErrorResponse
                          $responseValue,
                      $async.EventSink<
                              ComposedProtocolOnAnonComposedWithErrorResult>
                          $sink) {
            $sink.add(
                ComposedProtocolOnAnonComposedWithErrorResult.withResponse(
                    $responseValue));
          }, handleError: (Object $error,
                  StackTrace $stackTrace,
                  $async.EventSink<
                          ComposedProtocolOnAnonComposedWithErrorResult>
                      $sink) {
            if ($error is $fidl.MethodException) {
              $sink.add(ComposedProtocolOnAnonComposedWithErrorResult.withErr(
                  $error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kComposedProtocol_OnAnonComposedWithError_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kComposedProtocol_OnAnonComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kComposedProtocol_OnAnonComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kComposedProtocol_OnAnonComposedWithError_Type.name,
                _e,
                close);
          }));
        }
        final _onNamedComposed_stream = impl.onNamedComposed;
        if (_onNamedComposed_stream != null) {
          $subscriptions.add(_onNamedComposed_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kComposedProtocol_OnNamedComposed_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kComposedProtocol_OnNamedComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kComposedProtocol_OnNamedComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kComposedProtocol_OnNamedComposed_Type.name, _e, close);
          }));
        }
        final _onNamedComposedWithError_stream = impl.onNamedComposedWithError;
        if (_onNamedComposedWithError_stream != null) {
          $subscriptions.add(_onNamedComposedWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (TablePayload $responseValue,
                      $async.EventSink<
                              ComposedProtocolOnNamedComposedWithErrorResult>
                          $sink) {
            $sink.add(
                ComposedProtocolOnNamedComposedWithErrorResult.withResponse(
                    $responseValue));
          }, handleError: (Object $error,
                  StackTrace $stackTrace,
                  $async.EventSink<
                          ComposedProtocolOnNamedComposedWithErrorResult>
                      $sink) {
            if ($error is $fidl.MethodException) {
              $sink.add(ComposedProtocolOnNamedComposedWithErrorResult.withErr(
                  $error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kComposedProtocol_OnNamedComposedWithError_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kComposedProtocol_OnNamedComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kComposedProtocol_OnNamedComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kComposedProtocol_OnNamedComposedWithError_Type.name,
                _e,
                close);
          }));
        }
      }
    });
    whenClosed.then((_) => $unsubscribe());
  }

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    final $wireFormat = $message.parseWireFormat();
    switch ($message.ordinal) {
      case _kComposedProtocol_OneWayAnonComposed_Ordinal:
        final String _name = _kComposedProtocol_OneWayAnonComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_OneWayAnonComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kComposedProtocol_OneWayAnonComposed_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayAnonComposed(
              $types[0].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kComposedProtocol_TwoWayAnonComposed_Ordinal:
        final String _name = _kComposedProtocol_TwoWayAnonComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_TwoWayAnonComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kComposedProtocol_TwoWayAnonComposed_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<ComposedProtocolTwoWayAnonComposedResponse>
              $future = $fidl.decodeMessageWithCallback<
                      $async
                          .Future<ComposedProtocolTwoWayAnonComposedResponse>>(
                  $message,
                  _kComposedProtocol_TwoWayAnonComposed_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayAnonComposed(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kComposedProtocol_TwoWayAnonComposed_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kComposedProtocol_TwoWayAnonComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kComposedProtocol_TwoWayAnonComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kComposedProtocol_TwoWayAnonComposedWithError_Ordinal:
        final String _name =
            _kComposedProtocol_TwoWayAnonComposedWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_TwoWayAnonComposedWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async
                  .Future<ComposedProtocolTwoWayAnonComposedWithErrorResponse>
              $future = $fidl.decodeMaybeLargeMessageWithCallback<
                      $async.Future<
                          ComposedProtocolTwoWayAnonComposedWithErrorResponse>>(
                  $message,
                  _kComposedProtocol_TwoWayAnonComposedWithError_Type
                      .requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayAnonComposedWithError(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($responseValue) {
            return ComposedProtocolTwoWayAnonComposedWithErrorResult
                .withResponse($responseValue);
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return ComposedProtocolTwoWayAnonComposedWithErrorResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kComposedProtocol_TwoWayAnonComposedWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kComposedProtocol_TwoWayAnonComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kComposedProtocol_TwoWayAnonComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kComposedProtocol_OneWayNamedComposed_Ordinal:
        final String _name = _kComposedProtocol_OneWayNamedComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_OneWayNamedComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kComposedProtocol_OneWayNamedComposed_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayNamedComposed(
              $types[0].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kComposedProtocol_TwoWayNamedComposed_Ordinal:
        final String _name = _kComposedProtocol_TwoWayNamedComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_TwoWayNamedComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kComposedProtocol_TwoWayNamedComposed_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<TablePayload> $future = $fidl
              .decodeMessageWithCallback<$async.Future<TablePayload>>(
                  $message,
                  _kComposedProtocol_TwoWayNamedComposed_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayNamedComposed(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kComposedProtocol_TwoWayNamedComposed_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kComposedProtocol_TwoWayNamedComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kComposedProtocol_TwoWayNamedComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kComposedProtocol_TwoWayNamedComposedWithError_Ordinal:
        final String _name =
            _kComposedProtocol_TwoWayNamedComposedWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kComposedProtocol_TwoWayNamedComposedWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<UnionPayload> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<UnionPayload>>(
                  $message,
                  _kComposedProtocol_TwoWayNamedComposedWithError_Type
                      .requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayNamedComposedWithError(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($responseValue) {
            return ComposedProtocolTwoWayNamedComposedWithErrorResult
                .withResponse($responseValue);
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return ComposedProtocolTwoWayNamedComposedWithErrorResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kComposedProtocol_TwoWayNamedComposedWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kComposedProtocol_TwoWayNamedComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kComposedProtocol_TwoWayNamedComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      default:
        $message.closeHandles();
        throw $fidl.FidlError(
            r'Unexpected message name for ComposedProtocolBinding');
    }
  }
}

// oneWayAnonComposed: (ComposedProtocolOneWayAnonComposedRequest payload)
const int _kMainProtocol_OneWayAnonComposed_Ordinal = 0x6e7a205bdad7941f;
const $fidl.MethodType _kMainProtocol_OneWayAnonComposed_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolOneWayAnonComposedRequest>(
        type: kComposedProtocolOneWayAnonComposedRequest_Type, offset: 0),
  ],
  response: [],
  name: r"MainProtocol.OneWayAnonComposed",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// twoWayAnonComposed: (ComposedProtocolTwoWayAnonComposedRequest payload) -> (ComposedProtocolTwoWayAnonComposedResponse payload)
const int _kMainProtocol_TwoWayAnonComposed_Ordinal = 0x7083713dee9435f4;
const $fidl.MethodType _kMainProtocol_TwoWayAnonComposed_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolTwoWayAnonComposedRequest>(
        type: kComposedProtocolTwoWayAnonComposedRequest_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolTwoWayAnonComposedResponse>(
        type: kComposedProtocolTwoWayAnonComposedResponse_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayAnonComposed",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// twoWayAnonComposedWithError: (ComposedProtocolTwoWayAnonComposedWithErrorRequest payload) -> (ComposedProtocolTwoWayAnonComposedWithErrorResponse payload)
const int _kMainProtocol_TwoWayAnonComposedWithError_Ordinal =
    0x4fd32c5e2ffa6828;
const $fidl.MethodType _kMainProtocol_TwoWayAnonComposedWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolTwoWayAnonComposedWithErrorRequest>(
        type: kComposedProtocolTwoWayAnonComposedWithErrorRequest_Type,
        offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolTwoWayAnonComposedWithErrorResult>(
        type: kComposedProtocol_TwoWayAnonComposedWithError_Result_Type,
        offset: 0),
  ],
  name: r"MainProtocol.TwoWayAnonComposedWithError",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// onAnonComposed:  -> (ComposedProtocolOnAnonComposedRequest payload)
const int _kMainProtocol_OnAnonComposed_Ordinal = 0x49a6eee3a0300e28;
const $fidl.MethodType _kMainProtocol_OnAnonComposed_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolOnAnonComposedRequest>(
        type: kComposedProtocolOnAnonComposedRequest_Type, offset: 0),
  ],
  name: r"MainProtocol.OnAnonComposed",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// onAnonComposedWithError:  -> (ComposedProtocolOnAnonComposedWithErrorResponse payload)
const int _kMainProtocol_OnAnonComposedWithError_Ordinal = 0x297a909727d08a60;
const $fidl.MethodType _kMainProtocol_OnAnonComposedWithError_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolOnAnonComposedWithErrorResult>(
        type: kComposedProtocol_OnAnonComposedWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.OnAnonComposedWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// oneWayNamedComposed: (TablePayload payload)
const int _kMainProtocol_OneWayNamedComposed_Ordinal = 0x101636a8fa3e69b8;
const $fidl.MethodType _kMainProtocol_OneWayNamedComposed_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<TablePayload>(type: kTablePayload_Type, offset: 0),
  ],
  response: [],
  name: r"MainProtocol.OneWayNamedComposed",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// twoWayNamedComposed: (UnionPayload payload) -> (TablePayload payload)
const int _kMainProtocol_TwoWayNamedComposed_Ordinal = 0x45b4d3d31b374054;
const $fidl.MethodType _kMainProtocol_TwoWayNamedComposed_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<UnionPayload>(type: kUnionPayload_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<TablePayload>(type: kTablePayload_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayNamedComposed",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// twoWayNamedComposedWithError: (TablePayload payload) -> (UnionPayload payload)
const int _kMainProtocol_TwoWayNamedComposedWithError_Ordinal =
    0x450531e2d20c52ef;
const $fidl.MethodType _kMainProtocol_TwoWayNamedComposedWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<TablePayload>(type: kTablePayload_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolTwoWayNamedComposedWithErrorResult>(
        type: kComposedProtocol_TwoWayNamedComposedWithError_Result_Type,
        offset: 0),
  ],
  name: r"MainProtocol.TwoWayNamedComposedWithError",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// onNamedComposed:  -> (UnionPayload payload)
const int _kMainProtocol_OnNamedComposed_Ordinal = 0x17c4edb4a4a36d7b;
const $fidl.MethodType _kMainProtocol_OnNamedComposed_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<UnionPayload>(type: kUnionPayload_Type, offset: 0),
  ],
  name: r"MainProtocol.OnNamedComposed",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// onNamedComposedWithError:  -> (TablePayload payload)
const int _kMainProtocol_OnNamedComposedWithError_Ordinal = 0x3ff74c1cafdbabcf;
const $fidl.MethodType _kMainProtocol_OnNamedComposedWithError_Type =
    $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<ComposedProtocolOnNamedComposedWithErrorResult>(
        type: kComposedProtocol_OnNamedComposedWithError_Result_Type,
        offset: 0),
  ],
  name: r"MainProtocol.OnNamedComposedWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// oneWayLocal: (TablePayload payload)
const int _kMainProtocol_OneWayLocal_Ordinal = 0x3954b4c6b80956c1;
const $fidl.MethodType _kMainProtocol_OneWayLocal_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<TablePayload>(type: kTablePayload_Type, offset: 0),
  ],
  response: [],
  name: r"MainProtocol.OneWayLocal",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// twoWayLocal: (UnionPayload payload) -> (TablePayload payload)
const int _kMainProtocol_TwoWayLocal_Ordinal = 0x26998b4c1e8a9a57;
const $fidl.MethodType _kMainProtocol_TwoWayLocal_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<UnionPayload>(type: kUnionPayload_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<TablePayload>(type: kTablePayload_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayLocal",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// twoWayLocalWithError: (TablePayload payload) -> (UnionPayload payload)
const int _kMainProtocol_TwoWayLocalWithError_Ordinal = 0x4a7bf9ce881afde7;
const $fidl.MethodType _kMainProtocol_TwoWayLocalWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<TablePayload>(type: kTablePayload_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayLocalWithErrorResult>(
        type: kMainProtocol_TwoWayLocalWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayLocalWithError",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// onLocal:  -> (UnionPayload payload)
const int _kMainProtocol_OnLocal_Ordinal = 0x71e90a3d364d2e8d;
const $fidl.MethodType _kMainProtocol_OnLocal_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<UnionPayload>(type: kUnionPayload_Type, offset: 0),
  ],
  name: r"MainProtocol.OnLocal",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// onLocalWithError:  -> (TablePayload payload)
const int _kMainProtocol_OnLocalWithError_Ordinal = 0x2dac7e32bd351bdb;
const $fidl.MethodType _kMainProtocol_OnLocalWithError_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolOnLocalWithErrorResult>(
        type: kMainProtocol_OnLocalWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.OnLocalWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// oneWayAnon: (MainProtocolOneWayAnonRequest payload)
const int _kMainProtocol_OneWayAnon_Ordinal = 0x774bf445f584ce2c;
const $fidl.MethodType _kMainProtocol_OneWayAnon_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolOneWayAnonRequest>(
        type: kMainProtocolOneWayAnonRequest_Type, offset: 0),
  ],
  response: [],
  name: r"MainProtocol.OneWayAnon",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 0,
);
// twoWayAnon: (MainProtocolTwoWayAnonRequest payload) -> (MainProtocolTwoWayAnonResponse payload)
const int _kMainProtocol_TwoWayAnon_Ordinal = 0x3fd7ad8e52b07e2e;
const $fidl.MethodType _kMainProtocol_TwoWayAnon_Type = $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayAnonRequest>(
        type: kMainProtocolTwoWayAnonRequest_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayAnonResponse>(
        type: kMainProtocolTwoWayAnonResponse_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayAnon",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// twoWayAnonWithError: (MainProtocolTwoWayAnonWithErrorRequest payload) -> (MainProtocolTwoWayAnonWithErrorResponse payload)
const int _kMainProtocol_TwoWayAnonWithError_Ordinal = 0x1d33061a424eb245;
const $fidl.MethodType _kMainProtocol_TwoWayAnonWithError_Type =
    $fidl.MethodType(
  request: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayAnonWithErrorRequest>(
        type: kMainProtocolTwoWayAnonWithErrorRequest_Type, offset: 0),
  ],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolTwoWayAnonWithErrorResult>(
        type: kMainProtocol_TwoWayAnonWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.TwoWayAnonWithError",
  requestInlineSizeV2: 16,
  responseInlineSizeV2: 16,
);
// onAnon:  -> (MainProtocolOnAnonRequest payload)
const int _kMainProtocol_OnAnon_Ordinal = 0xd8fa6d0f5fabb94;
const $fidl.MethodType _kMainProtocol_OnAnon_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolOnAnonRequest>(
        type: kMainProtocolOnAnonRequest_Type, offset: 0),
  ],
  name: r"MainProtocol.OnAnon",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);
// onAnonWithError:  -> (MainProtocolOnAnonWithErrorResponse payload)
const int _kMainProtocol_OnAnonWithError_Ordinal = 0x6658cf43e550fa02;
const $fidl.MethodType _kMainProtocol_OnAnonWithError_Type = $fidl.MethodType(
  request: [],
  response: <$fidl.MemberType>[
    $fidl.MemberType<MainProtocolOnAnonWithErrorResult>(
        type: kMainProtocol_OnAnonWithError_Result_Type, offset: 0),
  ],
  name: r"MainProtocol.OnAnonWithError",
  requestInlineSizeV2: 0,
  responseInlineSizeV2: 16,
);

abstract class MainProtocol {
  $fidl.ServiceData? get $serviceData => MainProtocolData();
  $async.Future<void> oneWayAnonComposed(
      ComposedProtocolOneWayAnonComposedRequest payload);
  $async.Future<ComposedProtocolTwoWayAnonComposedResponse> twoWayAnonComposed(
      ComposedProtocolTwoWayAnonComposedRequest payload);
  $async.Future<ComposedProtocolTwoWayAnonComposedWithErrorResponse>
      twoWayAnonComposedWithError(
          ComposedProtocolTwoWayAnonComposedWithErrorRequest payload);
  $async.Stream<ComposedProtocolOnAnonComposedRequest>? get onAnonComposed;
  $async.Stream<ComposedProtocolOnAnonComposedWithErrorResponse>?
      get onAnonComposedWithError;
  $async.Future<void> oneWayNamedComposed(TablePayload payload);
  $async.Future<TablePayload> twoWayNamedComposed(UnionPayload payload);
  $async.Future<UnionPayload> twoWayNamedComposedWithError(
      TablePayload payload);
  $async.Stream<UnionPayload>? get onNamedComposed;
  $async.Stream<TablePayload>? get onNamedComposedWithError;
  $async.Future<void> oneWayLocal(TablePayload payload);
  $async.Future<TablePayload> twoWayLocal(UnionPayload payload);
  $async.Future<UnionPayload> twoWayLocalWithError(TablePayload payload);
  $async.Stream<UnionPayload>? get onLocal;
  $async.Stream<TablePayload>? get onLocalWithError;
  $async.Future<void> oneWayAnon(MainProtocolOneWayAnonRequest payload);
  $async.Future<MainProtocolTwoWayAnonResponse> twoWayAnon(
      MainProtocolTwoWayAnonRequest payload);
  $async.Future<MainProtocolTwoWayAnonWithErrorResponse> twoWayAnonWithError(
      MainProtocolTwoWayAnonWithErrorRequest payload);
  $async.Stream<MainProtocolOnAnonRequest>? get onAnon;
  $async.Stream<MainProtocolOnAnonWithErrorResponse>? get onAnonWithError;
} // TODO: Remove ServiceData for non-service

class MainProtocolData implements $fidl.ServiceData<MainProtocol> {
  const MainProtocolData();

  @override
  String getName() {
    return "";
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return MainProtocolBinding();
  }
}

class MainProtocolProxy extends $fidl.AsyncProxy<MainProtocol>
    implements MainProtocol {
  MainProtocolProxy()
      : super($fidl.AsyncProxyController<MainProtocol>(
            $interfaceName: r'MainProtocol')) {
    ctrl.onResponse = _handleResponse;
    ctrl.whenClosed.then((_) {
      _onAnonComposedEventStreamController.close();
      _onAnonComposedWithErrorEventStreamController.close();
      _onNamedComposedEventStreamController.close();
      _onNamedComposedWithErrorEventStreamController.close();
      _onLocalEventStreamController.close();
      _onLocalWithErrorEventStreamController.close();
      _onAnonEventStreamController.close();
      _onAnonWithErrorEventStreamController.close();
    }, onError: (_) {});
  }
  @override
  Null get $serviceData => null;

  void _handleEvent($fidl.IncomingMessage $message) {
    switch ($message.ordinal) {
      case _kMainProtocol_OnAnonComposed_Ordinal:
        final String _name = _kMainProtocol_OnAnonComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _onAnonComposedEventStreamController.addError,
            () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnAnonComposed_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_OnAnonComposed_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_OnAnonComposed_Type
                  .responseInlineSize($wireFormat),
              $types[0]);
          _onAnonComposedEventStreamController.add($response);
        });
        break;
      case _kMainProtocol_OnAnonComposedWithError_Ordinal:
        final String _name = _kMainProtocol_OnAnonComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onAnonComposedWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnAnonComposedWithError_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_OnAnonComposedWithError_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final ComposedProtocolOnAnonComposedWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_OnAnonComposedWithError_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              ComposedProtocolOnAnonComposedWithErrorResultTag.response) {
            _onAnonComposedWithErrorEventStreamController
                .add($response.response!);
          } else {
            _onAnonComposedWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_OnNamedComposed_Ordinal:
        final String _name = _kMainProtocol_OnNamedComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onNamedComposedEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnNamedComposed_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_OnNamedComposed_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_OnNamedComposed_Type
                  .responseInlineSize($wireFormat),
              $types[0]);
          _onNamedComposedEventStreamController.add($response);
        });
        break;
      case _kMainProtocol_OnNamedComposedWithError_Ordinal:
        final String _name = _kMainProtocol_OnNamedComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onNamedComposedWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnNamedComposedWithError_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_OnNamedComposedWithError_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final ComposedProtocolOnNamedComposedWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_OnNamedComposedWithError_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              ComposedProtocolOnNamedComposedWithErrorResultTag.response) {
            _onNamedComposedWithErrorEventStreamController
                .add($response.response!);
          } else {
            _onNamedComposedWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_OnLocal_Ordinal:
        final String _name = _kMainProtocol_OnLocal_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _onLocalEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnLocal_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_OnLocal_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_OnLocal_Type.responseInlineSize($wireFormat),
              $types[0]);
          _onLocalEventStreamController.add($response);
        });
        break;
      case _kMainProtocol_OnLocalWithError_Ordinal:
        final String _name = _kMainProtocol_OnLocalWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onLocalWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnLocalWithError_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_OnLocalWithError_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final MainProtocolOnLocalWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_OnLocalWithError_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              MainProtocolOnLocalWithErrorResultTag.response) {
            _onLocalWithErrorEventStreamController.add($response.response!);
          } else {
            _onLocalWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_OnAnon_Ordinal:
        final String _name = _kMainProtocol_OnAnon_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'event', _onAnonEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnAnon_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_OnAnon_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_OnAnon_Type.responseInlineSize($wireFormat),
              $types[0]);
          _onAnonEventStreamController.add($response);
        });
        break;
      case _kMainProtocol_OnAnonWithError_Ordinal:
        final String _name = _kMainProtocol_OnAnonWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(_name, ctrl, 'event',
            _onAnonWithErrorEventStreamController.addError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OnAnonWithError_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_OnAnonWithError_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final MainProtocolOnAnonWithErrorResult $response =
              $fidl.decodeMessage(
                  $message,
                  _kMainProtocol_OnAnonWithError_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag == MainProtocolOnAnonWithErrorResultTag.response) {
            _onAnonWithErrorEventStreamController.add($response.response!);
          } else {
            _onAnonWithErrorEventStreamController
                .addError($fidl.MethodException($response.err));
          }
        });
        break;
      default:
        $message.closeHandles();
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  void _handleResponse($fidl.IncomingMessage $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer? $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    switch ($message.ordinal) {
      case _kMainProtocol_TwoWayAnonComposed_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnonComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonComposed_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_TwoWayAnonComposed_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_TwoWayAnonComposed_Type
                  .responseInlineSize($wireFormat),
              $types[0]);
          $completer.complete($response);
        });
        break;
      case _kMainProtocol_TwoWayAnonComposedWithError_Ordinal:
        final String _name =
            _kMainProtocol_TwoWayAnonComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonComposedWithError_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final ComposedProtocolTwoWayAnonComposedWithErrorResult $response =
              $fidl.decodeMaybeLargeMessage(
                  $message,
                  _kMainProtocol_TwoWayAnonComposedWithError_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              ComposedProtocolTwoWayAnonComposedWithErrorResultTag.response) {
            $completer.complete($response.response!);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_TwoWayNamedComposed_Ordinal:
        final String _name = _kMainProtocol_TwoWayNamedComposed_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayNamedComposed_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_TwoWayNamedComposed_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_TwoWayNamedComposed_Type
                  .responseInlineSize($wireFormat),
              $types[0]);
          $completer.complete($response);
        });
        break;
      case _kMainProtocol_TwoWayNamedComposedWithError_Ordinal:
        final String _name =
            _kMainProtocol_TwoWayNamedComposedWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayNamedComposedWithError_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final ComposedProtocolTwoWayNamedComposedWithErrorResult $response =
              $fidl.decodeMaybeLargeMessage(
                  $message,
                  _kMainProtocol_TwoWayNamedComposedWithError_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              ComposedProtocolTwoWayNamedComposedWithErrorResultTag.response) {
            $completer.complete($response.response!);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_TwoWayLocal_Ordinal:
        final String _name = _kMainProtocol_TwoWayLocal_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayLocal_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_TwoWayLocal_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $response = $fidl.decodeMessage(
              $message,
              _kMainProtocol_TwoWayLocal_Type.responseInlineSize($wireFormat),
              $types[0]);
          $completer.complete($response);
        });
        break;
      case _kMainProtocol_TwoWayLocalWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayLocalWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayLocalWithError_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final MainProtocolTwoWayLocalWithErrorResult $response =
              $fidl.decodeMaybeLargeMessage(
                  $message,
                  _kMainProtocol_TwoWayLocalWithError_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              MainProtocolTwoWayLocalWithErrorResultTag.response) {
            $completer.complete($response.response!);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      case _kMainProtocol_TwoWayAnon_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnon_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnon_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final $response = $fidl.decodeMaybeLargeMessage(
              $message,
              _kMainProtocol_TwoWayAnon_Type.responseInlineSize($wireFormat),
              $types[0]);
          $completer.complete($response);
        });
        break;
      case _kMainProtocol_TwoWayAnonWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnonWithError_Type.name;
        $fidl.performCtrlWithExceptionHandling(
            _name, ctrl, 'method response', $completer.completeError, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonWithError_Type.response!;
          final $wireFormat = $message.parseWireFormat();
          // ignore: prefer_const_declarations

          final MainProtocolTwoWayAnonWithErrorResult $response =
              $fidl.decodeMaybeLargeMessage(
                  $message,
                  _kMainProtocol_TwoWayAnonWithError_Type
                      .responseInlineSize($wireFormat),
                  $types[0]);
          if ($response.$tag ==
              MainProtocolTwoWayAnonWithErrorResultTag.response) {
            $completer.complete($response.response!);
          } else {
            $completer.completeError($fidl.MethodException($response.err));
          }
        });
        break;
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        break;
    }
  }

  @override
  $async.Future<void> oneWayAnonComposed(
      ComposedProtocolOneWayAnonComposedRequest payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_OneWayAnonComposed_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_OneWayAnonComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_OneWayAnonComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<ComposedProtocolTwoWayAnonComposedResponse> twoWayAnonComposed(
      ComposedProtocolTwoWayAnonComposedRequest payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_TwoWayAnonComposed_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayAnonComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayAnonComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<ComposedProtocolTwoWayAnonComposedResponse>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<ComposedProtocolTwoWayAnonComposedWithErrorResponse>
      twoWayAnonComposedWithError(
          ComposedProtocolTwoWayAnonComposedWithErrorRequest payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_TwoWayAnonComposedWithError_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayAnonComposedWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayAnonComposedWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<ComposedProtocolTwoWayAnonComposedWithErrorResponse>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onAnonComposedEventStreamController = $async
      .StreamController<ComposedProtocolOnAnonComposedRequest>.broadcast();
  @override
  $async.Stream<ComposedProtocolOnAnonComposedRequest> get onAnonComposed =>
      _onAnonComposedEventStreamController.stream;

  final _onAnonComposedWithErrorEventStreamController = $async.StreamController<
      ComposedProtocolOnAnonComposedWithErrorResponse>.broadcast();
  @override
  $async.Stream<ComposedProtocolOnAnonComposedWithErrorResponse>
      get onAnonComposedWithError =>
          _onAnonComposedWithErrorEventStreamController.stream;

  @override
  $async.Future<void> oneWayNamedComposed(TablePayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_OneWayNamedComposed_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_OneWayNamedComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_OneWayNamedComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<TablePayload> twoWayNamedComposed(UnionPayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_TwoWayNamedComposed_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayNamedComposed_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayNamedComposed_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<TablePayload>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<UnionPayload> twoWayNamedComposedWithError(
      TablePayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_TwoWayNamedComposedWithError_Ordinal,
        0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayNamedComposedWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayNamedComposedWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<UnionPayload>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onNamedComposedEventStreamController =
      $async.StreamController<UnionPayload>.broadcast();
  @override
  $async.Stream<UnionPayload> get onNamedComposed =>
      _onNamedComposedEventStreamController.stream;

  final _onNamedComposedWithErrorEventStreamController =
      $async.StreamController<TablePayload>.broadcast();
  @override
  $async.Stream<TablePayload> get onNamedComposedWithError =>
      _onNamedComposedWithErrorEventStreamController.stream;

  @override
  $async.Future<void> oneWayLocal(TablePayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_OneWayLocal_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_OneWayLocal_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_OneWayLocal_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<TablePayload> twoWayLocal(UnionPayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_TwoWayLocal_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayLocal_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_TwoWayLocal_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<TablePayload>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<UnionPayload> twoWayLocalWithError(TablePayload payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_TwoWayLocalWithError_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayLocalWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayLocalWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<UnionPayload>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onLocalEventStreamController =
      $async.StreamController<UnionPayload>.broadcast();
  @override
  $async.Stream<UnionPayload> get onLocal =>
      _onLocalEventStreamController.stream;

  final _onLocalWithErrorEventStreamController =
      $async.StreamController<TablePayload>.broadcast();
  @override
  $async.Stream<TablePayload> get onLocalWithError =>
      _onLocalWithErrorEventStreamController.stream;

  @override
  $async.Future<void> oneWayAnon(MainProtocolOneWayAnonRequest payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_OneWayAnon_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_OneWayAnon_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_OneWayAnon_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }

  @override
  $async.Future<MainProtocolTwoWayAnonResponse> twoWayAnon(
      MainProtocolTwoWayAnonRequest payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(
        _kMainProtocol_TwoWayAnon_Ordinal, 0, $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayAnon_Type.request!;
    $fidl.encodeMessageWithCallback($encoder,
        _kMainProtocol_TwoWayAnon_Type.requestInlineSize($encoder.wireFormat),
        () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer = $async.Completer<MainProtocolTwoWayAnonResponse>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  @override
  $async.Future<MainProtocolTwoWayAnonWithErrorResponse> twoWayAnonWithError(
      MainProtocolTwoWayAnonWithErrorRequest payload) {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder($fidl.kWireFormatDefault);
    $encoder.encodeMessageHeader(_kMainProtocol_TwoWayAnonWithError_Ordinal, 0,
        $fidl.CallStrictness.strict);
    final List<$fidl.MemberType> $types =
        _kMainProtocol_TwoWayAnonWithError_Type.request!;
    $fidl.encodeMessageWithCallback(
        $encoder,
        _kMainProtocol_TwoWayAnonWithError_Type
            .requestInlineSize($encoder.wireFormat), () {
      $types[0].encode($encoder, payload, $fidl.kMessageHeaderSize, 1);
    });
    final $completer =
        $async.Completer<MainProtocolTwoWayAnonWithErrorResponse>();
    ctrl.sendMessageWithResponse($encoder.message, $completer);
    return $completer.future;
  }

  final _onAnonEventStreamController =
      $async.StreamController<MainProtocolOnAnonRequest>.broadcast();
  @override
  $async.Stream<MainProtocolOnAnonRequest> get onAnon =>
      _onAnonEventStreamController.stream;

  final _onAnonWithErrorEventStreamController =
      $async.StreamController<MainProtocolOnAnonWithErrorResponse>.broadcast();
  @override
  $async.Stream<MainProtocolOnAnonWithErrorResponse> get onAnonWithError =>
      _onAnonWithErrorEventStreamController.stream;
}

class MainProtocolBinding extends $fidl.AsyncBinding<MainProtocol> {
  MainProtocolBinding() : super(r"MainProtocol") {
    final List<$async.StreamSubscription<dynamic>> $subscriptions = [];
    void $unsubscribe() {
      for (final $sub in $subscriptions) {
        $sub.cancel();
      }
      $subscriptions.clear();
    }

    whenBound.then((_) {
      final impl = this.impl;
      if (impl != null) {
        final _onAnonComposed_stream = impl.onAnonComposed;
        if (_onAnonComposed_stream != null) {
          $subscriptions.add(_onAnonComposed_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_OnAnonComposed_Ordinal,
                0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnAnonComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnAnonComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnAnonComposed_Type.name, _e, close);
          }));
        }
        final _onAnonComposedWithError_stream = impl.onAnonComposedWithError;
        if (_onAnonComposedWithError_stream != null) {
          $subscriptions.add(_onAnonComposedWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (ComposedProtocolOnAnonComposedWithErrorResponse
                          $responseValue,
                      $async.EventSink<
                              ComposedProtocolOnAnonComposedWithErrorResult>
                          $sink) {
            $sink.add(
                ComposedProtocolOnAnonComposedWithErrorResult.withResponse(
                    $responseValue));
          }, handleError: (Object $error,
                  StackTrace $stackTrace,
                  $async.EventSink<
                          ComposedProtocolOnAnonComposedWithErrorResult>
                      $sink) {
            if ($error is $fidl.MethodException) {
              $sink.add(ComposedProtocolOnAnonComposedWithErrorResult.withErr(
                  $error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnAnonComposedWithError_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnAnonComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnAnonComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnAnonComposedWithError_Type.name, _e, close);
          }));
        }
        final _onNamedComposed_stream = impl.onNamedComposed;
        if (_onNamedComposed_stream != null) {
          $subscriptions.add(_onNamedComposed_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_OnNamedComposed_Ordinal,
                0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnNamedComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnNamedComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnNamedComposed_Type.name, _e, close);
          }));
        }
        final _onNamedComposedWithError_stream = impl.onNamedComposedWithError;
        if (_onNamedComposedWithError_stream != null) {
          $subscriptions.add(_onNamedComposedWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (TablePayload $responseValue,
                      $async.EventSink<
                              ComposedProtocolOnNamedComposedWithErrorResult>
                          $sink) {
            $sink.add(
                ComposedProtocolOnNamedComposedWithErrorResult.withResponse(
                    $responseValue));
          }, handleError: (Object $error,
                  StackTrace $stackTrace,
                  $async.EventSink<
                          ComposedProtocolOnNamedComposedWithErrorResult>
                      $sink) {
            if ($error is $fidl.MethodException) {
              $sink.add(ComposedProtocolOnNamedComposedWithErrorResult.withErr(
                  $error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnNamedComposedWithError_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnNamedComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnNamedComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnNamedComposedWithError_Type.name, _e, close);
          }));
        }
        final _onLocal_stream = impl.onLocal;
        if (_onLocal_stream != null) {
          $subscriptions.add(_onLocal_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnLocal_Ordinal, 0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnLocal_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnLocal_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(_kMainProtocol_OnLocal_Type.name, _e, close);
          }));
        }
        final _onLocalWithError_stream = impl.onLocalWithError;
        if (_onLocalWithError_stream != null) {
          $subscriptions.add(_onLocalWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (TablePayload $responseValue,
                      $async.EventSink<MainProtocolOnLocalWithErrorResult>
                          $sink) {
            $sink.add(MainProtocolOnLocalWithErrorResult.withResponse(
                $responseValue));
          }, handleError: (Object $error, StackTrace $stackTrace,
                  $async.EventSink<MainProtocolOnLocalWithErrorResult> $sink) {
            if ($error is $fidl.MethodException) {
              $sink.add(
                  MainProtocolOnLocalWithErrorResult.withErr($error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnLocalWithError_Ordinal,
                0,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnLocalWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnLocalWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnLocalWithError_Type.name, _e, close);
          }));
        }
        final _onAnon_stream = impl.onAnon;
        if (_onAnon_stream != null) {
          $subscriptions.add(_onAnon_stream.listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_OnAnon_Ordinal, 0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnAnon_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnAnon_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
              // TODO: was ignoring errors intentional here? For methods, the
              // channel gets closed on error.
              onError: (_e) {
            $fidl.handleException(_kMainProtocol_OnAnon_Type.name, _e, close);
          }));
        }
        final _onAnonWithError_stream = impl.onAnonWithError;
        if (_onAnonWithError_stream != null) {
          $subscriptions.add(_onAnonWithError_stream
              .transform($async.StreamTransformer.fromHandlers(handleData:
                  (MainProtocolOnAnonWithErrorResponse $responseValue,
                      $async.EventSink<MainProtocolOnAnonWithErrorResult>
                          $sink) {
            $sink.add(
                MainProtocolOnAnonWithErrorResult.withResponse($responseValue));
          }, handleError: (Object $error, StackTrace $stackTrace,
                  $async.EventSink<MainProtocolOnAnonWithErrorResult> $sink) {
            if ($error is $fidl.MethodException) {
              $sink
                  .add(MainProtocolOnAnonWithErrorResult.withErr($error.value));
            } else {
              $sink.addError($error, $stackTrace);
            }
          }))
              .listen(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_OnAnonWithError_Ordinal,
                0, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_OnAnonWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_OnAnonWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            sendMessage($encoder.message);
          },
                  // TODO: was ignoring errors intentional here? For methods, the
                  // channel gets closed on error.
                  onError: (_e) {
            $fidl.handleException(
                _kMainProtocol_OnAnonWithError_Type.name, _e, close);
          }));
        }
      }
    });
    whenClosed.then((_) => $unsubscribe());
  }

  @override
  void handleMessage(
      $fidl.IncomingMessage $message, $fidl.OutgoingMessageSink $respond) {
    final $wireFormat = $message.parseWireFormat();
    switch ($message.ordinal) {
      case _kMainProtocol_OneWayAnonComposed_Ordinal:
        final String _name = _kMainProtocol_OneWayAnonComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OneWayAnonComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kMainProtocol_OneWayAnonComposed_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayAnonComposed(
              $types[0].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayAnonComposed_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnonComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_TwoWayAnonComposed_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<ComposedProtocolTwoWayAnonComposedResponse>
              $future = $fidl.decodeMessageWithCallback<
                      $async
                          .Future<ComposedProtocolTwoWayAnonComposedResponse>>(
                  $message,
                  _kMainProtocol_TwoWayAnonComposed_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayAnonComposed(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayAnonComposed_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayAnonComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayAnonComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayAnonComposedWithError_Ordinal:
        final String _name =
            _kMainProtocol_TwoWayAnonComposedWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonComposedWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async
                  .Future<ComposedProtocolTwoWayAnonComposedWithErrorResponse>
              $future = $fidl.decodeMaybeLargeMessageWithCallback<
                      $async.Future<
                          ComposedProtocolTwoWayAnonComposedWithErrorResponse>>(
                  $message,
                  _kMainProtocol_TwoWayAnonComposedWithError_Type
                      .requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayAnonComposedWithError(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($responseValue) {
            return ComposedProtocolTwoWayAnonComposedWithErrorResult
                .withResponse($responseValue);
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return ComposedProtocolTwoWayAnonComposedWithErrorResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayAnonComposedWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayAnonComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayAnonComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_OneWayNamedComposed_Ordinal:
        final String _name = _kMainProtocol_OneWayNamedComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OneWayNamedComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kMainProtocol_OneWayNamedComposed_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayNamedComposed(
              $types[0].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayNamedComposed_Ordinal:
        final String _name = _kMainProtocol_TwoWayNamedComposed_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayNamedComposed_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_TwoWayNamedComposed_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<TablePayload> $future = $fidl
              .decodeMessageWithCallback<$async.Future<TablePayload>>(
                  $message,
                  _kMainProtocol_TwoWayNamedComposed_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayNamedComposed(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayNamedComposed_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayNamedComposed_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayNamedComposed_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayNamedComposedWithError_Ordinal:
        final String _name =
            _kMainProtocol_TwoWayNamedComposedWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayNamedComposedWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<UnionPayload> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<UnionPayload>>(
                  $message,
                  _kMainProtocol_TwoWayNamedComposedWithError_Type
                      .requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayNamedComposedWithError(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($responseValue) {
            return ComposedProtocolTwoWayNamedComposedWithErrorResult
                .withResponse($responseValue);
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return ComposedProtocolTwoWayNamedComposedWithErrorResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayNamedComposedWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayNamedComposedWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayNamedComposedWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_OneWayLocal_Ordinal:
        final String _name = _kMainProtocol_OneWayLocal_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OneWayLocal_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kMainProtocol_OneWayLocal_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayLocal(
              $types[0].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayLocal_Ordinal:
        final String _name = _kMainProtocol_TwoWayLocal_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayLocal_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          if ($message.overflowing == $fidl.CallOverflowing.large) {
            throw $fidl.FidlError(
                r'Unexpected byte overflow for _kMainProtocol_TwoWayLocal_Ordinal',
                $fidl.FidlErrorCode.fidlLargeMessageImpossible);
          }
          final $async.Future<TablePayload> $future = $fidl
              .decodeMessageWithCallback<$async.Future<TablePayload>>(
                  $message,
                  _kMainProtocol_TwoWayLocal_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayLocal(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_TwoWayLocal_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayLocal_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayLocal_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayLocalWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayLocalWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayLocalWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<UnionPayload> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<UnionPayload>>(
                  $message,
                  _kMainProtocol_TwoWayLocalWithError_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayLocalWithError(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($responseValue) {
            return MainProtocolTwoWayLocalWithErrorResult.withResponse(
                $responseValue);
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return MainProtocolTwoWayLocalWithErrorResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayLocalWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayLocalWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayLocalWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_OneWayAnon_Ordinal:
        final String _name = _kMainProtocol_OneWayAnon_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_OneWayAnon_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<void> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<$async.Future<void>>(
                  $message,
                  _kMainProtocol_OneWayAnon_Type.requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.oneWayAnon(
              $types[0].decode($decoder, $offset, 1),
            );
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayAnon_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnon_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnon_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<MainProtocolTwoWayAnonResponse> $future = $fidl
              .decodeMaybeLargeMessageWithCallback<
                      $async.Future<MainProtocolTwoWayAnonResponse>>($message,
                  _kMainProtocol_TwoWayAnon_Type.requestInlineSize($wireFormat),
                  ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayAnon(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(_kMainProtocol_TwoWayAnon_Ordinal,
                $message.txid, $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayAnon_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayAnon_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      case _kMainProtocol_TwoWayAnonWithError_Ordinal:
        final String _name = _kMainProtocol_TwoWayAnonWithError_Type.name;
        $fidl.performWithExceptionHandling(_name, () {
          final List<$fidl.MemberType> $types =
              _kMainProtocol_TwoWayAnonWithError_Type.request!;
          // ignore: prefer_const_declarations
          final _impl = impl!;
          final $async.Future<MainProtocolTwoWayAnonWithErrorResponse> $future =
              $fidl.decodeMaybeLargeMessageWithCallback<
                      $async.Future<MainProtocolTwoWayAnonWithErrorResponse>>(
                  $message,
                  _kMainProtocol_TwoWayAnonWithError_Type.requestInlineSize(
                      $wireFormat), ($fidl.Decoder $decoder, int $offset) {
            return _impl.twoWayAnonWithError(
              $types[0].decode($decoder, $offset, 1),
            );
          });
          $future.then(($responseValue) {
            return MainProtocolTwoWayAnonWithErrorResult.withResponse(
                $responseValue);
          }, onError: ($error) {
            if ($error is $fidl.MethodException) {
              return MainProtocolTwoWayAnonWithErrorResult.withErr(
                  $error.value);
            } else {
              return Future.error($error, StackTrace.current);
            }
          }).then(($response) {
            final $fidl.Encoder $encoder =
                $fidl.Encoder($fidl.kWireFormatDefault);
            $encoder.encodeMessageHeader(
                _kMainProtocol_TwoWayAnonWithError_Ordinal,
                $message.txid,
                $fidl.CallStrictness.strict);
            final List<$fidl.MemberType> $types =
                _kMainProtocol_TwoWayAnonWithError_Type.response!;
            $fidl.encodeMessage(
                $encoder,
                _kMainProtocol_TwoWayAnonWithError_Type
                    .responseInlineSize($encoder.wireFormat),
                $types[0],
                $response);
            $respond($encoder.message);
          }, onError: (_e) {
            $fidl.handleException(_name, _e, close);
          });
        }, close);
        break;
      default:
        $message.closeHandles();
        throw $fidl.FidlError(
            r'Unexpected message name for MainProtocolBinding');
    }
  }
}
