

#![cfg(test)]
#![allow(unused_imports)]

use {
    assert_matches::assert_matches,
    fidl::{AsHandleRef, Error, Handle, HandleDisposition, HandleInfo, HandleOp, ObjectType, Rights},
    fidl::encoding::{Context, Decodable, Decoder, Encoder, WireFormatVersion},
    fidl_test_conformance as test_conformance,
    fuchsia_zircon_status::Status,
    fuchsia_zircon_types as zx_types,
    gidl_util::{HandleDef, HandleSubtype, copy_handle, create_handles, get_info_handle_valid, select_handle_infos, to_zx_handle_t, to_zx_handle_disposition_t},
};

const _V1_CONTEXT: &Context = &Context { wire_format_version: WireFormatVersion::V1 };
const _V2_CONTEXT: &Context = &Context { wire_format_version: WireFormatVersion::V2 };


#[test]
fn test_golden_bool_struct_v1_encode() {
    let value = &mut test_conformance::GoldenBoolStruct { v: true };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_bool_struct_v2_encode() {
    let value = &mut test_conformance::GoldenBoolStruct { v: true };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_int_struct_v1_encode() {
    let value = &mut test_conformance::GoldenIntStruct { v: 1i16 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_int_struct_v2_encode() {
    let value = &mut test_conformance::GoldenIntStruct { v: 1i16 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_uint_struct_v1_encode() {
    let value = &mut test_conformance::GoldenUintStruct { v: 1u16 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_uint_struct_v2_encode() {
    let value = &mut test_conformance::GoldenUintStruct { v: 1u16 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_float_struct_v1_encode() {
    let value = &mut test_conformance::GoldenFloatStruct { v: 0f32 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_float_struct_v2_encode() {
    let value = &mut test_conformance::GoldenFloatStruct { v: 0f32 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_double_struct_v1_encode() {
    let value = &mut test_conformance::GoldenDoubleStruct { v: 0f64 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_double_struct_v2_encode() {
    let value = &mut test_conformance::GoldenDoubleStruct { v: 0f64 };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_string_struct_v1_encode() {
    let value = &mut test_conformance::GoldenStringStruct { v: String::from("abcd") };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_string_struct_v2_encode() {
    let value = &mut test_conformance::GoldenStringStruct { v: String::from("abcd") };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_string_struct_non_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableStringStruct { v: Some(String::from("abcd")) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_string_struct_non_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableStringStruct { v: Some(String::from("abcd")) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_string_struct_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableStringStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_string_struct_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableStringStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_enum_struct_v1_encode() {
    let value = &mut test_conformance::GoldenEnumStruct { v: test_conformance::GoldenEnum::from_primitive(1u16).unwrap() };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_enum_struct_v2_encode() {
    let value = &mut test_conformance::GoldenEnumStruct { v: test_conformance::GoldenEnum::from_primitive(1u16).unwrap() };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_bits_struct_v1_encode() {
    let value = &mut test_conformance::GoldenBitsStruct { v: unsafe { test_conformance::GoldenBits::from_bits_unchecked(1u16) } };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_bits_struct_v2_encode() {
    let value = &mut test_conformance::GoldenBitsStruct { v: unsafe { test_conformance::GoldenBits::from_bits_unchecked(1u16) } };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_table_struct_v1_encode() {
    let value = &mut test_conformance::GoldenTableStruct { v: test_conformance::GoldenTable { v: Some(1i16), ..test_conformance::GoldenTable::EMPTY } };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_table_struct_v2_encode() {
    let value = &mut test_conformance::GoldenTableStruct { v: test_conformance::GoldenTable { v: Some(1i16), ..test_conformance::GoldenTable::EMPTY } };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_union_struct_v1_encode() {
    let value = &mut test_conformance::GoldenUnionStruct { v: test_conformance::GoldenUnion::V(1i16) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_union_struct_v2_encode() {
    let value = &mut test_conformance::GoldenUnionStruct { v: test_conformance::GoldenUnion::V(1i16) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_union_struct_non_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableUnionStruct { v: Some(Box::new(test_conformance::GoldenUnion::V(1i16))) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_union_struct_non_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableUnionStruct { v: Some(Box::new(test_conformance::GoldenUnion::V(1i16))) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_union_struct_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableUnionStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_union_struct_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableUnionStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_byte_array_struct_v1_encode() {
    let value = &mut test_conformance::GoldenByteArrayStruct { v: [1u8, 2u8, 3u8, 4u8] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_byte_array_struct_v2_encode() {
    let value = &mut test_conformance::GoldenByteArrayStruct { v: [1u8, 2u8, 3u8, 4u8] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_struct_array_struct_v1_encode() {
    let value = &mut test_conformance::GoldenStructArrayStruct { v: [test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_struct_array_struct_v2_encode() {
    let value = &mut test_conformance::GoldenStructArrayStruct { v: [test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_byte_vector_struct_v1_encode() {
    let value = &mut test_conformance::GoldenByteVectorStruct { v: vec![1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x01,0x02,0x03,0x04,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_byte_vector_struct_v2_encode() {
    let value = &mut test_conformance::GoldenByteVectorStruct { v: vec![1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x01,0x02,0x03,0x04,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_byte_nullable_vector_struct_non_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableByteVectorStruct { v: Some(vec![1u8, 2u8, 3u8, 4u8]) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_byte_nullable_vector_struct_non_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableByteVectorStruct { v: Some(vec![1u8, 2u8, 3u8, 4u8]) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_byte_vector_struct_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableByteVectorStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_byte_vector_struct_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableByteVectorStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_struct_vector_struct_v1_encode() {
    let value = &mut test_conformance::GoldenStructVectorStruct { v: vec![test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_struct_vector_struct_v2_encode() {
    let value = &mut test_conformance::GoldenStructVectorStruct { v: vec![test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_struct_non_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableStruct { v: Some(Box::new(test_conformance::GoldenBoolStruct { v: true })) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_struct_non_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableStruct { v: Some(Box::new(test_conformance::GoldenBoolStruct { v: true })) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_struct_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_struct_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_handle_basic_rights_struct_v1_encode() {
    let handle_defs = create_handles(&[
// #0
HandleDef{
	subtype: HandleSubtype::Channel,
	rights: Rights::from_bits(61454).unwrap(),
},
]);
    let value = &mut test_conformance::GoldenHandleBasicRightsStruct { v: copy_handle(&handle_defs[0]) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
]);
    assert_eq!(
        handle_dispositions.iter().map(to_zx_handle_disposition_t).collect::<Vec<_>>(),
        &[
zx_types::zx_handle_disposition_t {
   operation: zx_types::ZX_HANDLE_OP_MOVE,
   handle: handle_defs[0].handle,
   type_: 5,
   rights: 49155,
   result: zx_types::ZX_OK,
},]
    );
}

#[test]
fn test_golden_handle_basic_rights_struct_v2_encode() {
    let handle_defs = create_handles(&[
// #0
HandleDef{
	subtype: HandleSubtype::Channel,
	rights: Rights::from_bits(61454).unwrap(),
},
]);
    let value = &mut test_conformance::GoldenHandleBasicRightsStruct { v: copy_handle(&handle_defs[0]) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
]);
    assert_eq!(
        handle_dispositions.iter().map(to_zx_handle_disposition_t).collect::<Vec<_>>(),
        &[
zx_types::zx_handle_disposition_t {
   operation: zx_types::ZX_HANDLE_OP_MOVE,
   handle: handle_defs[0].handle,
   type_: 5,
   rights: 49155,
   result: zx_types::ZX_OK,
},]
    );
}

#[test]
fn test_golden_nullable_handle_struct_non_null_v1_encode() {
    let handle_defs = create_handles(&[
// #0
HandleDef{
	subtype: HandleSubtype::Event,
	rights: Rights::from_bits(2147483648).unwrap(),
},
]);
    let value = &mut test_conformance::GoldenNullableHandleStruct { v: Some(copy_handle(&handle_defs[0])) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
]);
    assert_eq!(
        handle_dispositions.iter().map(to_zx_handle_t).collect::<Vec<_>>(),
        &[handle_defs[0].handle,
]
    );
}

#[test]
fn test_golden_nullable_handle_struct_non_null_v2_encode() {
    let handle_defs = create_handles(&[
// #0
HandleDef{
	subtype: HandleSubtype::Event,
	rights: Rights::from_bits(2147483648).unwrap(),
},
]);
    let value = &mut test_conformance::GoldenNullableHandleStruct { v: Some(copy_handle(&handle_defs[0])) };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
]);
    assert_eq!(
        handle_dispositions.iter().map(to_zx_handle_t).collect::<Vec<_>>(),
        &[handle_defs[0].handle,
]
    );
}

#[test]
fn test_golden_nullable_handle_struct_null_v1_encode() {
    let value = &mut test_conformance::GoldenNullableHandleStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V1_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}

#[test]
fn test_golden_nullable_handle_struct_null_v2_encode() {
    let value = &mut test_conformance::GoldenNullableHandleStruct { v: None };
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context(_V2_CONTEXT, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
]);
    assert_eq!(handle_dispositions, &[]);
}



#[test]
fn test_golden_bool_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenBoolStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenBoolStruct { v: true });
}

#[test]
fn test_golden_bool_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenBoolStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenBoolStruct { v: true });
}

#[test]
fn test_golden_int_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenIntStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenIntStruct { v: 1i16 });
}

#[test]
fn test_golden_int_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenIntStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenIntStruct { v: 1i16 });
}

#[test]
fn test_golden_uint_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenUintStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenUintStruct { v: 1u16 });
}

#[test]
fn test_golden_uint_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenUintStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenUintStruct { v: 1u16 });
}

#[test]
fn test_golden_float_struct_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenFloatStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenFloatStruct { v: 0f32 });
}

#[test]
fn test_golden_float_struct_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenFloatStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenFloatStruct { v: 0f32 });
}

#[test]
fn test_golden_double_struct_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenDoubleStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenDoubleStruct { v: 0f64 });
}

#[test]
fn test_golden_double_struct_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenDoubleStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenDoubleStruct { v: 0f64 });
}

#[test]
fn test_golden_string_struct_v1_decode() {
    let bytes = &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenStringStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenStringStruct { v: String::from("abcd") });
}

#[test]
fn test_golden_string_struct_v2_decode() {
    let bytes = &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenStringStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenStringStruct { v: String::from("abcd") });
}

#[test]
fn test_golden_nullable_string_struct_non_null_v1_decode() {
    let bytes = &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableStringStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStringStruct { v: Some(String::from("abcd")) });
}

#[test]
fn test_golden_nullable_string_struct_non_null_v2_decode() {
    let bytes = &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x61,0x62,0x63,0x64,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableStringStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStringStruct { v: Some(String::from("abcd")) });
}

#[test]
fn test_golden_nullable_string_struct_null_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableStringStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStringStruct { v: None });
}

#[test]
fn test_golden_nullable_string_struct_null_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableStringStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStringStruct { v: None });
}

#[test]
fn test_golden_enum_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenEnumStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenEnumStruct { v: test_conformance::GoldenEnum::from_primitive(1u16).unwrap() });
}

#[test]
fn test_golden_enum_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenEnumStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenEnumStruct { v: test_conformance::GoldenEnum::from_primitive(1u16).unwrap() });
}

#[test]
fn test_golden_bits_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenBitsStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenBitsStruct { v: unsafe { test_conformance::GoldenBits::from_bits_unchecked(1u16) } });
}

#[test]
fn test_golden_bits_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenBitsStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenBitsStruct { v: unsafe { test_conformance::GoldenBits::from_bits_unchecked(1u16) } });
}

#[test]
fn test_golden_table_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenTableStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenTableStruct { v: test_conformance::GoldenTable { v: Some(1i16), ..test_conformance::GoldenTable::EMPTY } });
}

#[test]
fn test_golden_table_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenTableStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenTableStruct { v: test_conformance::GoldenTable { v: Some(1i16), ..test_conformance::GoldenTable::EMPTY } });
}

#[test]
fn test_golden_union_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenUnionStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenUnionStruct { v: test_conformance::GoldenUnion::V(1i16) });
}

#[test]
fn test_golden_union_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenUnionStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenUnionStruct { v: test_conformance::GoldenUnion::V(1i16) });
}

#[test]
fn test_golden_nullable_union_struct_non_null_v1_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableUnionStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableUnionStruct { v: Some(Box::new(test_conformance::GoldenUnion::V(1i16))) });
}

#[test]
fn test_golden_nullable_union_struct_non_null_v2_decode() {
    let bytes = &[
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableUnionStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableUnionStruct { v: Some(Box::new(test_conformance::GoldenUnion::V(1i16))) });
}

#[test]
fn test_golden_nullable_union_struct_null_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableUnionStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableUnionStruct { v: None });
}

#[test]
fn test_golden_nullable_union_struct_null_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableUnionStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableUnionStruct { v: None });
}

#[test]
fn test_golden_byte_array_struct_v1_decode() {
    let bytes = &[
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenByteArrayStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenByteArrayStruct { v: [1u8, 2u8, 3u8, 4u8] });
}

#[test]
fn test_golden_byte_array_struct_v2_decode() {
    let bytes = &[
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenByteArrayStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenByteArrayStruct { v: [1u8, 2u8, 3u8, 4u8] });
}

#[test]
fn test_golden_struct_array_struct_v1_decode() {
    let bytes = &[
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenStructArrayStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenStructArrayStruct { v: [test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] });
}

#[test]
fn test_golden_struct_array_struct_v2_decode() {
    let bytes = &[
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenStructArrayStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenStructArrayStruct { v: [test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] });
}

#[test]
fn test_golden_byte_vector_struct_v1_decode() {
    let bytes = &[
0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x01,0x02,0x03,0x04,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenByteVectorStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenByteVectorStruct { v: vec![1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8] });
}

#[test]
fn test_golden_byte_vector_struct_v2_decode() {
    let bytes = &[
0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x01,0x02,0x03,0x04,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenByteVectorStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenByteVectorStruct { v: vec![1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8, 1u8, 2u8, 3u8, 4u8] });
}

#[test]
fn test_golden_byte_nullable_vector_struct_non_null_v1_decode() {
    let bytes = &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableByteVectorStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableByteVectorStruct { v: Some(vec![1u8, 2u8, 3u8, 4u8]) });
}

#[test]
fn test_golden_byte_nullable_vector_struct_non_null_v2_decode() {
    let bytes = &[
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x02,0x03,0x04,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableByteVectorStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableByteVectorStruct { v: Some(vec![1u8, 2u8, 3u8, 4u8]) });
}

#[test]
fn test_golden_nullable_byte_vector_struct_null_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableByteVectorStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableByteVectorStruct { v: None });
}

#[test]
fn test_golden_nullable_byte_vector_struct_null_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableByteVectorStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableByteVectorStruct { v: None });
}

#[test]
fn test_golden_struct_vector_struct_v1_decode() {
    let bytes = &[
0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenStructVectorStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenStructVectorStruct { v: vec![test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] });
}

#[test]
fn test_golden_struct_vector_struct_v2_decode() {
    let bytes = &[
0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenStructVectorStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenStructVectorStruct { v: vec![test_conformance::GoldenIntStruct { v: 1i16 }, test_conformance::GoldenIntStruct { v: 2i16 }] });
}

#[test]
fn test_golden_nullable_struct_non_null_v1_decode() {
    let bytes = &[
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStruct { v: Some(Box::new(test_conformance::GoldenBoolStruct { v: true })) });
}

#[test]
fn test_golden_nullable_struct_non_null_v2_decode() {
    let bytes = &[
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStruct { v: Some(Box::new(test_conformance::GoldenBoolStruct { v: true })) });
}

#[test]
fn test_golden_nullable_struct_null_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStruct { v: None });
}

#[test]
fn test_golden_nullable_struct_null_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableStruct { v: None });
}

#[test]
fn test_golden_nullable_handle_struct_non_null_v1_decode() {
    let bytes = &[
0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
];
    let handle_defs = create_handles(&[
// #0
HandleDef{
	subtype: HandleSubtype::Event,
	rights: Rights::from_bits(2147483648).unwrap(),
},
]);
    let handle_infos = &mut select_handle_infos(&handle_defs, &[
0,]);
    let value = &mut test_conformance::GoldenNullableHandleStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    // Forget handles before dropping the expected value, to avoid double closing them.
    struct ForgetHandles(test_conformance::GoldenNullableHandleStruct);
    impl std::ops::Drop for ForgetHandles {
        #[allow(unused_parens)]
        fn drop(&mut self) {
            std::mem::forget(std::mem::replace((&mut self.0.v).as_mut().unwrap(), Handle::invalid().into()));
        }
    }
    let expected_value = ForgetHandles(test_conformance::GoldenNullableHandleStruct { v: Some(copy_handle(&handle_defs[0])) });
    assert_eq!(value, &expected_value.0);
}

#[test]
fn test_golden_nullable_handle_struct_non_null_v2_decode() {
    let bytes = &[
0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
];
    let handle_defs = create_handles(&[
// #0
HandleDef{
	subtype: HandleSubtype::Event,
	rights: Rights::from_bits(2147483648).unwrap(),
},
]);
    let handle_infos = &mut select_handle_infos(&handle_defs, &[
0,]);
    let value = &mut test_conformance::GoldenNullableHandleStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    // Forget handles before dropping the expected value, to avoid double closing them.
    struct ForgetHandles(test_conformance::GoldenNullableHandleStruct);
    impl std::ops::Drop for ForgetHandles {
        #[allow(unused_parens)]
        fn drop(&mut self) {
            std::mem::forget(std::mem::replace((&mut self.0.v).as_mut().unwrap(), Handle::invalid().into()));
        }
    }
    let expected_value = ForgetHandles(test_conformance::GoldenNullableHandleStruct { v: Some(copy_handle(&handle_defs[0])) });
    assert_eq!(value, &expected_value.0);
}

#[test]
fn test_golden_nullable_handle_struct_null_v1_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableHandleStruct::new_empty();
    Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableHandleStruct { v: None });
}

#[test]
fn test_golden_nullable_handle_struct_null_v2_decode() {
    let bytes = &[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenNullableHandleStruct::new_empty();
    Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value).unwrap();
    assert_eq!(value, &test_conformance::GoldenNullableHandleStruct { v: None });
}





#[test]
fn test_golden_string_struct_null_body_v1_decode_failure() {
    let bytes = &[
0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenStringStruct::new_empty();
    match Decoder::decode_with_context(_V1_CONTEXT, bytes, handle_infos, value) {
        Err(err) => assert_matches!(err, Error::UnexpectedNullRef { .. }),
        Ok(_) => panic!("unexpected successful decoding"),
    }
}

#[test]
fn test_golden_string_struct_null_body_v2_decode_failure() {
    let bytes = &[
0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];
    let handle_infos = &mut Vec::new();
    let value = &mut test_conformance::GoldenStringStruct::new_empty();
    match Decoder::decode_with_context(_V2_CONTEXT, bytes, handle_infos, value) {
        Err(err) => assert_matches!(err, Error::UnexpectedNullRef { .. }),
        Ok(_) => panic!("unexpected successful decoding"),
    }
}

