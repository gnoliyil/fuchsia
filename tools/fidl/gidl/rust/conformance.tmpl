{{/*
// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
*/}}

#![cfg(test)]
#![allow(unused_imports)]

use {
    assert_matches::assert_matches,
    fidl::{AsHandleRef, Error, Handle, HandleDisposition, HandleInfo, HandleOp, ObjectType, Rights},
    fidl::encoding::{Context, Decodable, Decoder, Encoder, WireFormatVersion},
    fidl_test_conformance as test_conformance,
    fuchsia_zircon_status::Status,
    fuchsia_zircon_types as zx_types,
    gidl_util::{HandleDef, HandleSubtype, copy_handle, create_handles, get_info_handle_valid, select_handle_infos, to_zx_handle_t, to_zx_handle_disposition_t},
};

const _V1_CONTEXT: &Context = &Context { wire_format_version: WireFormatVersion::V1 };
const _V2_CONTEXT: &Context = &Context { wire_format_version: WireFormatVersion::V2 };

{{ range .EncodeSuccessCases }}
{{- if .HandleDefs }}#[cfg(target_os = "fuchsia")]{{ end }}
#[test]
fn test_{{ .Name }}_encode() {
    {{- if .HandleDefs }}
    let handle_defs = create_handles(&{{ .HandleDefs }});
    {{- end }}
    let value = &mut {{ .Value }};
    let bytes = &mut Vec::new();
    let handle_dispositions = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    Encoder::encode_with_context({{ .Context }}, bytes, handle_dispositions, value).unwrap();
    assert_eq!(bytes, &{{ .Bytes }});
    {{- if .HandleDispositions }}
    assert_eq!(
        handle_dispositions.iter().map(to_zx_handle_disposition_t).collect::<Vec<_>>(),
        &{{ .HandleDispositions }}
    );
    {{- else if .Handles }}
    assert_eq!(
        handle_dispositions.iter().map(to_zx_handle_t).collect::<Vec<_>>(),
        &{{ .Handles }}
    );
    {{- else }}
    assert_eq!(handle_dispositions, &[]);
    {{- end }}
}
{{ end }}

{{ range .DecodeSuccessCases }}
{{- if .HandleDefs }}#[cfg(target_os = "fuchsia")]{{ end }}
#[test]
fn test_{{ .Name }}_decode() {
    let bytes = &{{ .Bytes }};
    {{- if .HandleDefs }}
    let handle_defs = create_handles(&{{ .HandleDefs }});
    let handle_infos = &mut select_handle_infos(&handle_defs, &{{ .Handles }});
    {{- else }}
    let handle_infos = &mut Vec::new();
    {{- end }}
    let value = &mut {{ .ValueType }}::new_empty();
    Decoder::decode_with_context({{ .Context }}, bytes, handle_infos, value).unwrap();
    {{- if .ForgetHandles }}
    // Forget handles before dropping the expected value, to avoid double closing them.
    struct ForgetHandles({{ .ValueType }});
    impl std::ops::Drop for ForgetHandles {
        #[allow(unused_parens)]
        fn drop(&mut self) {
            {{ .ForgetHandles }}
        }
    }
    let expected_value = ForgetHandles({{ .Value }});
    assert_eq!(value, &expected_value.0);
    {{- else }}
    assert_eq!(value, &{{ .Value }});
    {{- end }}
}
{{ end }}

{{ range .EncodeFailureCases }}
{{- if .HandleDefs }}#[cfg(target_os = "fuchsia")]{{ end }}
#[test]
fn test_{{ .Name }}_encode_failure() {
    {{- if .HandleDefs }}
    let handle_defs = create_handles(&{{ .HandleDefs }});
    {{- end }}
    let value = &mut {{ .Value }};
    let bytes = &mut Vec::new();
    let handles = &mut Vec::new();
    bytes.resize(65536, 0xcd); // fill with junk data
    match Encoder::encode_with_context({{ .Context }}, bytes, handles, value) {
        Err(err) => assert_matches!(err, {{ .ErrorCode }} { .. }),
        Ok(_) => panic!("unexpected successful encoding"),
    }
    {{- if .HandleDefs }}
    assert_eq!(
        handle_defs.iter().map(get_info_handle_valid).collect::<Vec<_>>(),
        std::iter::repeat(Err(Status::BAD_HANDLE)).take(handle_defs.len()).collect::<Vec<_>>(),
    );
    {{- end }}
}
{{ end }}

{{ range .DecodeFailureCases }}
{{- if .HandleDefs }}#[cfg(target_os = "fuchsia")]{{ end }}
#[test]
fn test_{{ .Name }}_decode_failure() {
    let bytes = &{{ .Bytes }};
    {{- if .HandleDefs }}
    let handle_defs = create_handles(&{{ .HandleDefs }});
    let handle_infos = &mut select_handle_infos(&handle_defs, &{{ .Handles }});
    {{- else }}
    let handle_infos = &mut Vec::new();
    {{- end }}
    let value = &mut {{ .ValueType }}::new_empty();
    match Decoder::decode_with_context({{ .Context }}, bytes, handle_infos, value) {
        Err(err) => assert_matches!(err, {{ .ErrorCode }} { .. }),
        Ok(_) => panic!("unexpected successful decoding"),
    }
}
{{ end }}
