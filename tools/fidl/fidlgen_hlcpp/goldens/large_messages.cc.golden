// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = allow_overflowing
// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#include <test/largemessages/cpp/fidl.h>

#include "lib/fidl/cpp/internal/implementation.h"

//
// Domain objects definitions
//
namespace test {
namespace largemessages {

extern "C" const fidl_type_t test_largemessages_BoundedKnownToBeSmallTable;
const fidl_type_t* BoundedKnownToBeSmall::FidlType = &test_largemessages_BoundedKnownToBeSmallTable;

void BoundedKnownToBeSmall::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                   cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<BoundedKnownToBeSmall>::value) {
    memcpy(_encoder->template GetPtr<BoundedKnownToBeSmall>(_offset), this, sizeof(BoundedKnownToBeSmall));
  } else {
    ::fidl::Encode(_encoder, &bytes, _offset + 0);
  }
}

void BoundedKnownToBeSmall::Decode(::fidl::Decoder* _decoder, BoundedKnownToBeSmall* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<BoundedKnownToBeSmall>::value) {
    memcpy(_value, _decoder->template GetPtr<BoundedKnownToBeSmall>(_offset), sizeof(BoundedKnownToBeSmall));
  } else {
    ::fidl::Decode(_decoder, &_value->bytes, _offset + 0);
  }
}

zx_status_t BoundedKnownToBeSmall::Clone(BoundedKnownToBeSmall* _result) const {
  zx_status_t _status = ::fidl::Clone(bytes, &_result->bytes);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_largemessages_BoundedMaybeLargeTable;
const fidl_type_t* BoundedMaybeLarge::FidlType = &test_largemessages_BoundedMaybeLargeTable;

void BoundedMaybeLarge::Encode(::fidl::Encoder* _encoder, size_t _offset,
                               cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<BoundedMaybeLarge>::value) {
    memcpy(_encoder->template GetPtr<BoundedMaybeLarge>(_offset), this, sizeof(BoundedMaybeLarge));
  } else {
    ::fidl::Encode(_encoder, &bytes, _offset + 0);
  }
}

void BoundedMaybeLarge::Decode(::fidl::Decoder* _decoder, BoundedMaybeLarge* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<BoundedMaybeLarge>::value) {
    memcpy(_value, _decoder->template GetPtr<BoundedMaybeLarge>(_offset), sizeof(BoundedMaybeLarge));
  } else {
    ::fidl::Decode(_decoder, &_value->bytes, _offset + 0);
  }
}

zx_status_t BoundedMaybeLarge::Clone(BoundedMaybeLarge* _result) const {
  zx_status_t _status = ::fidl::Clone(bytes, &_result->bytes);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_largemessages_SemiBoundedBelievedToBeSmallTable;
const fidl_type_t* SemiBoundedBelievedToBeSmall::FidlType = &test_largemessages_SemiBoundedBelievedToBeSmallTable;

SemiBoundedBelievedToBeSmall::SemiBoundedBelievedToBeSmall() {}

SemiBoundedBelievedToBeSmall::~SemiBoundedBelievedToBeSmall() {
  Destroy();
}

SemiBoundedBelievedToBeSmall::SemiBoundedBelievedToBeSmall(SemiBoundedBelievedToBeSmall&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::kBytes:
      new (&bytes_)::std::vector<uint8_t>();
      bytes_ = std::move(other.bytes_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::Invalid):
      break;
    default:
      new (&unknown_data_) decltype(unknown_data_);
      unknown_data_ = std::move(other.unknown_data_);
      break;
  }
}

SemiBoundedBelievedToBeSmall& SemiBoundedBelievedToBeSmall::operator=(SemiBoundedBelievedToBeSmall&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::kBytes:
        new (&bytes_)::std::vector<uint8_t>();
        bytes_ = std::move(other.bytes_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::Invalid):
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        unknown_data_ = std::move(other.unknown_data_);
        break;
    }
  }
  return *this;
}

SemiBoundedBelievedToBeSmall SemiBoundedBelievedToBeSmall::WithBytes(::std::vector<uint8_t>&& val) {
  SemiBoundedBelievedToBeSmall result;
  result.set_bytes(std::move(val));
  return result;
}

void SemiBoundedBelievedToBeSmall::Encode(::fidl::Encoder* encoder, size_t offset,
                                          cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::kBytes: {
      if (::fidl::EncodingInlineSize<::std::vector<uint8_t>>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &bytes_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
          encoder,
          &bytes_,
          encoder->Alloc(::fidl::EncodingInlineSize<::std::vector<uint8_t>, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::kUnknown: {
      ::fidl::EncodeUnknownBytes(encoder, &unknown_data_, offset + offsetof(fidl_xunion_t, envelope));
      *encoder->GetPtr<uint64_t>(offset) = tag_;
      break;
    }
    default:
      break;
  }
}

void SemiBoundedBelievedToBeSmall::Decode(::fidl::Decoder* _decoder, SemiBoundedBelievedToBeSmall* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);

  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::kBytes: {
      new (&value->bytes_)::std::vector<uint8_t>();
      ::fidl::Decode(_decoder, &value->bytes_, value_offset);
      break;
    }
    default: {
      auto unknown_info = _decoder->EnvelopeUnknownDataInfo(&xunion->envelope);
      value->unknown_data_.resize(unknown_info.num_bytes);
      ::fidl::DecodeUnknownBytesContents(_decoder, &value->unknown_data_, unknown_info.value_offset);
      break;
    }
  }
}

zx_status_t SemiBoundedBelievedToBeSmall::Clone(SemiBoundedBelievedToBeSmall* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::Invalid:
      return ZX_OK;
    case ::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::kBytes:
      new (&result->bytes_)::std::vector<uint8_t>();
      return ::fidl::Clone(bytes_, &result->bytes_);
    default:
      new (&result->unknown_data_) decltype(unknown_data_);
      return ::fidl::Clone(unknown_data_, &result->unknown_data_);
      return ZX_OK;
  }
}

SemiBoundedBelievedToBeSmall& SemiBoundedBelievedToBeSmall::set_bytes(::std::vector<uint8_t> value) {
  EnsureStorageInitialized(::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::kBytes);
  bytes_ = std::move(value);
  return *this;
}
SemiBoundedBelievedToBeSmall& SemiBoundedBelievedToBeSmall::SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes) {
  EnsureStorageInitialized(ordinal);
  unknown_data_ = std::move(bytes);
  return *this;
}

void SemiBoundedBelievedToBeSmall::Destroy() {
  switch (tag_) {
    case ::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::kBytes:
      bytes_.~decltype(bytes_)();
      break;

    case static_cast<fidl_xunion_tag_t>(::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::Invalid):
      break;
    default:
      unknown_data_.~decltype(unknown_data_)();
      break;
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::Invalid);
}

void SemiBoundedBelievedToBeSmall::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::Invalid):
        break;
      case ::test::largemessages::SemiBoundedBelievedToBeSmall::Tag::kBytes:
        new (&bytes_)::std::vector<uint8_t>();
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        break;
    }
  }
}

extern "C" const fidl_type_t test_largemessages_SemiBoundedMaybeLargeTable;
const fidl_type_t* SemiBoundedMaybeLarge::FidlType = &test_largemessages_SemiBoundedMaybeLargeTable;

SemiBoundedMaybeLarge::SemiBoundedMaybeLarge() {}

SemiBoundedMaybeLarge::~SemiBoundedMaybeLarge() {
  Destroy();
}

SemiBoundedMaybeLarge::SemiBoundedMaybeLarge(SemiBoundedMaybeLarge&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::largemessages::SemiBoundedMaybeLarge::Tag::kBytes:
      new (&bytes_)::std::vector<uint8_t>();
      bytes_ = std::move(other.bytes_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::largemessages::SemiBoundedMaybeLarge::Tag::Invalid):
      break;
    default:
      new (&unknown_data_) decltype(unknown_data_);
      unknown_data_ = std::move(other.unknown_data_);
      break;
  }
}

SemiBoundedMaybeLarge& SemiBoundedMaybeLarge::operator=(SemiBoundedMaybeLarge&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::largemessages::SemiBoundedMaybeLarge::Tag::kBytes:
        new (&bytes_)::std::vector<uint8_t>();
        bytes_ = std::move(other.bytes_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::largemessages::SemiBoundedMaybeLarge::Tag::Invalid):
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        unknown_data_ = std::move(other.unknown_data_);
        break;
    }
  }
  return *this;
}

SemiBoundedMaybeLarge SemiBoundedMaybeLarge::WithBytes(::std::vector<uint8_t>&& val) {
  SemiBoundedMaybeLarge result;
  result.set_bytes(std::move(val));
  return result;
}

void SemiBoundedMaybeLarge::Encode(::fidl::Encoder* encoder, size_t offset,
                                   cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::largemessages::SemiBoundedMaybeLarge::Tag::kBytes: {
      if (::fidl::EncodingInlineSize<::std::vector<uint8_t>>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &bytes_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
          encoder,
          &bytes_,
          encoder->Alloc(::fidl::EncodingInlineSize<::std::vector<uint8_t>, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::largemessages::SemiBoundedMaybeLarge::Tag::kUnknown: {
      ::fidl::EncodeUnknownBytes(encoder, &unknown_data_, offset + offsetof(fidl_xunion_t, envelope));
      *encoder->GetPtr<uint64_t>(offset) = tag_;
      break;
    }
    default:
      break;
  }
}

void SemiBoundedMaybeLarge::Decode(::fidl::Decoder* _decoder, SemiBoundedMaybeLarge* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::largemessages::SemiBoundedMaybeLarge::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);

  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::largemessages::SemiBoundedMaybeLarge::Tag::kBytes: {
      new (&value->bytes_)::std::vector<uint8_t>();
      ::fidl::Decode(_decoder, &value->bytes_, value_offset);
      break;
    }
    default: {
      auto unknown_info = _decoder->EnvelopeUnknownDataInfo(&xunion->envelope);
      value->unknown_data_.resize(unknown_info.num_bytes);
      ::fidl::DecodeUnknownBytesContents(_decoder, &value->unknown_data_, unknown_info.value_offset);
      break;
    }
  }
}

zx_status_t SemiBoundedMaybeLarge::Clone(SemiBoundedMaybeLarge* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::largemessages::SemiBoundedMaybeLarge::Tag::Invalid:
      return ZX_OK;
    case ::test::largemessages::SemiBoundedMaybeLarge::Tag::kBytes:
      new (&result->bytes_)::std::vector<uint8_t>();
      return ::fidl::Clone(bytes_, &result->bytes_);
    default:
      new (&result->unknown_data_) decltype(unknown_data_);
      return ::fidl::Clone(unknown_data_, &result->unknown_data_);
      return ZX_OK;
  }
}

SemiBoundedMaybeLarge& SemiBoundedMaybeLarge::set_bytes(::std::vector<uint8_t> value) {
  EnsureStorageInitialized(::test::largemessages::SemiBoundedMaybeLarge::Tag::kBytes);
  bytes_ = std::move(value);
  return *this;
}
SemiBoundedMaybeLarge& SemiBoundedMaybeLarge::SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes) {
  EnsureStorageInitialized(ordinal);
  unknown_data_ = std::move(bytes);
  return *this;
}

void SemiBoundedMaybeLarge::Destroy() {
  switch (tag_) {
    case ::test::largemessages::SemiBoundedMaybeLarge::Tag::kBytes:
      bytes_.~decltype(bytes_)();
      break;

    case static_cast<fidl_xunion_tag_t>(::test::largemessages::SemiBoundedMaybeLarge::Tag::Invalid):
      break;
    default:
      unknown_data_.~decltype(unknown_data_)();
      break;
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::largemessages::SemiBoundedMaybeLarge::Tag::Invalid);
}

void SemiBoundedMaybeLarge::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::largemessages::SemiBoundedMaybeLarge::Tag::Invalid):
        break;
      case ::test::largemessages::SemiBoundedMaybeLarge::Tag::kBytes:
        new (&bytes_)::std::vector<uint8_t>();
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        break;
    }
  }
}

extern "C" const fidl_type_t test_largemessages_UnboundedMaybeLargeValueTable;
const fidl_type_t* UnboundedMaybeLargeValue::FidlType = &test_largemessages_UnboundedMaybeLargeValueTable;

void UnboundedMaybeLargeValue::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<UnboundedMaybeLargeValue>::value) {
    memcpy(_encoder->template GetPtr<UnboundedMaybeLargeValue>(_offset), this, sizeof(UnboundedMaybeLargeValue));
  } else {
    ::fidl::Encode(_encoder, &bytes, _offset + 0);
  }
}

void UnboundedMaybeLargeValue::Decode(::fidl::Decoder* _decoder, UnboundedMaybeLargeValue* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<UnboundedMaybeLargeValue>::value) {
    memcpy(_value, _decoder->template GetPtr<UnboundedMaybeLargeValue>(_offset), sizeof(UnboundedMaybeLargeValue));
  } else {
    ::fidl::Decode(_decoder, &_value->bytes, _offset + 0);
  }
}

zx_status_t UnboundedMaybeLargeValue::Clone(UnboundedMaybeLargeValue* _result) const {
  zx_status_t _status = ::fidl::Clone(bytes, &_result->bytes);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_largemessages_ElementsTable;
const fidl_type_t* Elements::FidlType = &test_largemessages_ElementsTable;

void Elements::Encode(::fidl::Encoder* _encoder, size_t _offset,
                      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Elements>::value) {
    memcpy(_encoder->template GetPtr<Elements>(_offset), this, sizeof(Elements));
  } else {
    ::fidl::Encode(_encoder, &handle, _offset + 0, ::fidl::HandleInformation{
                                                       .object_type = ZX_OBJ_TYPE_NONE,
                                                       .rights = 0x80000000,
                                                   });
    ::fidl::Encode(_encoder, &bytes, _offset + 8);
  }
}

void Elements::Decode(::fidl::Decoder* _decoder, Elements* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Elements>::value) {
    memcpy(_value, _decoder->template GetPtr<Elements>(_offset), sizeof(Elements));
  } else {
    ::fidl::Decode(_decoder, &_value->handle, _offset + 0);
    ::fidl::Decode(_decoder, &_value->bytes, _offset + 8);
  }
}

zx_status_t Elements::Clone(Elements* _result) const {
  zx_status_t _status = ::fidl::Clone(handle, &_result->handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(bytes, &_result->bytes);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_largemessages_UnboundedMaybeLargeResourceTable;
const fidl_type_t* UnboundedMaybeLargeResource::FidlType = &test_largemessages_UnboundedMaybeLargeResourceTable;

void UnboundedMaybeLargeResource::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<UnboundedMaybeLargeResource>::value) {
    memcpy(_encoder->template GetPtr<UnboundedMaybeLargeResource>(_offset), this, sizeof(UnboundedMaybeLargeResource));
  } else {
    ::fidl::Encode(_encoder, &elements, _offset + 0);
  }
}

void UnboundedMaybeLargeResource::Decode(::fidl::Decoder* _decoder, UnboundedMaybeLargeResource* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<UnboundedMaybeLargeResource>::value) {
    memcpy(_value, _decoder->template GetPtr<UnboundedMaybeLargeResource>(_offset), sizeof(UnboundedMaybeLargeResource));
  } else {
    ::fidl::Decode(_decoder, &_value->elements, _offset + 0);
  }
}

zx_status_t UnboundedMaybeLargeResource::Clone(UnboundedMaybeLargeResource* _result) const {
  zx_status_t _status = ::fidl::Clone(elements, &_result->elements);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

#endif  // __Fuchsia__

//
// Proxies and stubs definitions
//
#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t test_largemessages_BoundedKnownToBeSmallTable;

__LOCAL extern "C" const fidl_type_t test_largemessages_BoundedMaybeLargeTable;

__LOCAL extern "C" const fidl_type_t test_largemessages_SemiBoundedBelievedToBeSmallTable;

__LOCAL extern "C" const fidl_type_t test_largemessages_SemiBoundedMaybeLargeTable;

__LOCAL extern "C" const fidl_type_t test_largemessages_UnboundedMaybeLargeValueTable;

__LOCAL extern "C" const fidl_type_t test_largemessages_UnboundedMaybeLargeResourceTable;

}  // namespace _internal

Overflowing::~Overflowing() = default;

const fidl_type_t* ::test::largemessages::Overflowing_RequestDecoder::GetType(uint64_t ordinal, bool* out_needs_response, bool* out_is_known) {
  *out_needs_response = false;
  *out_is_known = false;
  switch (ordinal) {
    case ::test::largemessages::internal::kOverflowing_DecodeBoundedKnownToBeSmall_Ordinal:
      *out_is_known = true;
      return &::test::largemessages::_internal::test_largemessages_BoundedKnownToBeSmallTable;
      ;
    case ::test::largemessages::internal::kOverflowing_DecodeBoundedMaybeLarge_Ordinal:
      *out_is_known = true;
      return &::test::largemessages::_internal::test_largemessages_BoundedMaybeLargeTable;
      ;
    case ::test::largemessages::internal::kOverflowing_DecodeSemiBoundedBelievedToBeSmall_Ordinal:
      *out_is_known = true;
      return &::test::largemessages::_internal::test_largemessages_SemiBoundedBelievedToBeSmallTable;
      ;
    case ::test::largemessages::internal::kOverflowing_DecodeSemiBoundedMaybeLarge_Ordinal:
      *out_is_known = true;
      return &::test::largemessages::_internal::test_largemessages_SemiBoundedMaybeLargeTable;
      ;
    case ::test::largemessages::internal::kOverflowing_DecodeUnboundedMaybeLargeValue_Ordinal:
      *out_is_known = true;
      return &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeValueTable;
      ;
    case ::test::largemessages::internal::kOverflowing_DecodeUnboundedMaybeLargeResource_Ordinal:
      *out_is_known = true;
      return &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeResourceTable;
      ;
    case ::test::largemessages::internal::kOverflowing_EncodeBoundedKnownToBeSmall_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::largemessages::_internal::test_largemessages_BoundedKnownToBeSmallTable;
      ;
    case ::test::largemessages::internal::kOverflowing_EncodeBoundedMaybeLarge_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::largemessages::_internal::test_largemessages_BoundedMaybeLargeTable;
      ;
    case ::test::largemessages::internal::kOverflowing_EncodeSemiBoundedBelievedToBeSmall_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::largemessages::_internal::test_largemessages_SemiBoundedBelievedToBeSmallTable;
      ;
    case ::test::largemessages::internal::kOverflowing_EncodeSemiBoundedMaybeLarge_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::largemessages::_internal::test_largemessages_SemiBoundedMaybeLargeTable;
      ;
    case ::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeValue_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeValueTable;
      ;
    case ::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeResource_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeResourceTable;
      ;
    default:
      return nullptr;
  }
}

const fidl_type_t* Overflowing_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    case ::test::largemessages::internal::kOverflowing_EncodeBoundedKnownToBeSmall_Ordinal:
      return &::test::largemessages::_internal::test_largemessages_BoundedKnownToBeSmallTable;
      ;
    case ::test::largemessages::internal::kOverflowing_EncodeBoundedMaybeLarge_Ordinal:
      return &::test::largemessages::_internal::test_largemessages_BoundedMaybeLargeTable;
      ;
    case ::test::largemessages::internal::kOverflowing_EncodeSemiBoundedBelievedToBeSmall_Ordinal:
      return &::test::largemessages::_internal::test_largemessages_SemiBoundedBelievedToBeSmallTable;
      ;
    case ::test::largemessages::internal::kOverflowing_EncodeSemiBoundedMaybeLarge_Ordinal:
      return &::test::largemessages::_internal::test_largemessages_SemiBoundedMaybeLargeTable;
      ;
    case ::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeValue_Ordinal:
      return &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeValueTable;
      ;
    case ::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeResource_Ordinal:
      return &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeResourceTable;
      ;
    default:
      return nullptr;
  }
}

Overflowing_EventSender::~Overflowing_EventSender() = default;

Overflowing_Sync::~Overflowing_Sync() = default;

Overflowing_Proxy::Overflowing_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

Overflowing_Proxy::~Overflowing_Proxy() = default;

zx_status_t Overflowing_Proxy::Dispatch_(::fidl::HLCPPIncomingMessage message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    default: {
      auto txid = message.txid();
      auto is_flexible = message.is_flexible();
      auto ordinal = message.ordinal();
      // To satisfy RFC-0138, move the message so it is destructed before
      // calling the unknown event handler.
      { auto message_ = std::move(message); }
      if (txid == 0 && is_flexible) {
        handle_unknown_event(ordinal);
        break;
      }
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

void Overflowing_Proxy::DecodeBoundedKnownToBeSmall(::std::vector<uint8_t> bytes) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_DecodeBoundedKnownToBeSmall_Ordinal, ::test::largemessages::internal::kOverflowing_DecodeBoundedKnownToBeSmall_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_BoundedKnownToBeSmallTable;
  controller_->Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::DecodeBoundedKnownToBeSmall(&_encoder, &bytes), nullptr);
}
void Overflowing_Proxy::DecodeBoundedMaybeLarge(::std::vector<uint8_t> bytes) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_DecodeBoundedMaybeLarge_Ordinal, ::test::largemessages::internal::kOverflowing_DecodeBoundedMaybeLarge_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_BoundedMaybeLargeTable;
  controller_->Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::DecodeBoundedMaybeLarge(&_encoder, &bytes), nullptr);
}
void Overflowing_Proxy::DecodeSemiBoundedBelievedToBeSmall(::test::largemessages::SemiBoundedBelievedToBeSmall SemiBoundedBelievedToBeSmall) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_DecodeSemiBoundedBelievedToBeSmall_Ordinal, ::test::largemessages::internal::kOverflowing_DecodeSemiBoundedBelievedToBeSmall_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_SemiBoundedBelievedToBeSmallTable;
  controller_->Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::DecodeSemiBoundedBelievedToBeSmall(&_encoder, &SemiBoundedBelievedToBeSmall), nullptr);
}
void Overflowing_Proxy::DecodeSemiBoundedMaybeLarge(::test::largemessages::SemiBoundedMaybeLarge SemiBoundedMaybeLarge) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_DecodeSemiBoundedMaybeLarge_Ordinal, ::test::largemessages::internal::kOverflowing_DecodeSemiBoundedMaybeLarge_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_SemiBoundedMaybeLargeTable;
  controller_->Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::DecodeSemiBoundedMaybeLarge(&_encoder, &SemiBoundedMaybeLarge), nullptr);
}
void Overflowing_Proxy::DecodeUnboundedMaybeLargeValue(::std::vector<uint8_t> bytes) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_DecodeUnboundedMaybeLargeValue_Ordinal, ::test::largemessages::internal::kOverflowing_DecodeUnboundedMaybeLargeValue_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeValueTable;
  controller_->Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::DecodeUnboundedMaybeLargeValue(&_encoder, &bytes), nullptr);
}
void Overflowing_Proxy::DecodeUnboundedMaybeLargeResource(::std::array<::test::largemessages::Elements, 64> elements) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_DecodeUnboundedMaybeLargeResource_Ordinal, ::test::largemessages::internal::kOverflowing_DecodeUnboundedMaybeLargeResource_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeResourceTable;
  controller_->Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::DecodeUnboundedMaybeLargeResource(&_encoder, &elements), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Overflowing_EncodeBoundedKnownToBeSmall_ResponseHandler(Overflowing::EncodeBoundedKnownToBeSmallCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Overflowing::EncodeBoundedKnownToBeSmall\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::largemessages::_internal::test_largemessages_BoundedKnownToBeSmallTable);
}

}  // namespace
void Overflowing_Proxy::EncodeBoundedKnownToBeSmall(::std::vector<uint8_t> bytes, EncodeBoundedKnownToBeSmallCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeBoundedKnownToBeSmall_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeBoundedKnownToBeSmall_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_BoundedKnownToBeSmallTable;
  controller_->Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::EncodeBoundedKnownToBeSmall(&_encoder, &bytes), Overflowing_EncodeBoundedKnownToBeSmall_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Overflowing_EncodeBoundedMaybeLarge_ResponseHandler(Overflowing::EncodeBoundedMaybeLargeCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Overflowing::EncodeBoundedMaybeLarge\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::largemessages::_internal::test_largemessages_BoundedMaybeLargeTable);
}

}  // namespace
void Overflowing_Proxy::EncodeBoundedMaybeLarge(::std::vector<uint8_t> bytes, EncodeBoundedMaybeLargeCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeBoundedMaybeLarge_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeBoundedMaybeLarge_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_BoundedMaybeLargeTable;
  controller_->Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::EncodeBoundedMaybeLarge(&_encoder, &bytes), Overflowing_EncodeBoundedMaybeLarge_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Overflowing_EncodeSemiBoundedBelievedToBeSmall_ResponseHandler(Overflowing::EncodeSemiBoundedBelievedToBeSmallCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Overflowing::EncodeSemiBoundedBelievedToBeSmall\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::largemessages::SemiBoundedBelievedToBeSmall>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::largemessages::_internal::test_largemessages_SemiBoundedBelievedToBeSmallTable);
}

}  // namespace
void Overflowing_Proxy::EncodeSemiBoundedBelievedToBeSmall(::test::largemessages::SemiBoundedBelievedToBeSmall SemiBoundedBelievedToBeSmall, EncodeSemiBoundedBelievedToBeSmallCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeSemiBoundedBelievedToBeSmall_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeSemiBoundedBelievedToBeSmall_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_SemiBoundedBelievedToBeSmallTable;
  controller_->Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::EncodeSemiBoundedBelievedToBeSmall(&_encoder, &SemiBoundedBelievedToBeSmall), Overflowing_EncodeSemiBoundedBelievedToBeSmall_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Overflowing_EncodeSemiBoundedMaybeLarge_ResponseHandler(Overflowing::EncodeSemiBoundedMaybeLargeCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Overflowing::EncodeSemiBoundedMaybeLarge\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::largemessages::SemiBoundedMaybeLarge>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::largemessages::_internal::test_largemessages_SemiBoundedMaybeLargeTable);
}

}  // namespace
void Overflowing_Proxy::EncodeSemiBoundedMaybeLarge(::test::largemessages::SemiBoundedMaybeLarge SemiBoundedMaybeLarge, EncodeSemiBoundedMaybeLargeCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeSemiBoundedMaybeLarge_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeSemiBoundedMaybeLarge_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_SemiBoundedMaybeLargeTable;
  controller_->Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::EncodeSemiBoundedMaybeLarge(&_encoder, &SemiBoundedMaybeLarge), Overflowing_EncodeSemiBoundedMaybeLarge_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Overflowing_EncodeUnboundedMaybeLargeValue_ResponseHandler(Overflowing::EncodeUnboundedMaybeLargeValueCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Overflowing::EncodeUnboundedMaybeLargeValue\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeValueTable);
}

}  // namespace
void Overflowing_Proxy::EncodeUnboundedMaybeLargeValue(::std::vector<uint8_t> bytes, EncodeUnboundedMaybeLargeValueCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeValue_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeValue_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeValueTable;
  controller_->Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::EncodeUnboundedMaybeLargeValue(&_encoder, &bytes), Overflowing_EncodeUnboundedMaybeLargeValue_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Overflowing_EncodeUnboundedMaybeLargeResource_ResponseHandler(Overflowing::EncodeUnboundedMaybeLargeResourceCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Overflowing::EncodeUnboundedMaybeLargeResource\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::std::array<::test::largemessages::Elements, 64>>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      },
      &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeResourceTable);
}

}  // namespace
void Overflowing_Proxy::EncodeUnboundedMaybeLargeResource(::std::array<::test::largemessages::Elements, 64> elements, EncodeUnboundedMaybeLargeResourceCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeResource_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeResource_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeResourceTable;
  controller_->Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::EncodeUnboundedMaybeLargeResource(&_encoder, &elements), Overflowing_EncodeUnboundedMaybeLargeResource_ResponseHandler(std::move(callback)));
}

Overflowing_Stub::Overflowing_Stub(::test::largemessages::Overflowing_Stub::Overflowing_clazz* impl) : impl_(impl) {
  (void)impl_;
}

Overflowing_Stub::~Overflowing_Stub() = default;

namespace {

class Overflowing_EncodeBoundedKnownToBeSmall_Responder final {
 public:
  Overflowing_EncodeBoundedKnownToBeSmall_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::std::vector<uint8_t> bytes) {
    ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeBoundedKnownToBeSmall_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeBoundedKnownToBeSmall_DynamicFlags);
    const fidl_type_t* resp_type = &::test::largemessages::_internal::test_largemessages_BoundedKnownToBeSmallTable;
    response_.Send(resp_type, ::test::largemessages::Overflowing_ResponseEncoder::EncodeBoundedKnownToBeSmall(&_encoder, &bytes));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Overflowing_EncodeBoundedMaybeLarge_Responder final {
 public:
  Overflowing_EncodeBoundedMaybeLarge_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::std::vector<uint8_t> bytes) {
    ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeBoundedMaybeLarge_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeBoundedMaybeLarge_DynamicFlags);
    const fidl_type_t* resp_type = &::test::largemessages::_internal::test_largemessages_BoundedMaybeLargeTable;
    response_.Send(resp_type, ::test::largemessages::Overflowing_ResponseEncoder::EncodeBoundedMaybeLarge(&_encoder, &bytes));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Overflowing_EncodeSemiBoundedBelievedToBeSmall_Responder final {
 public:
  Overflowing_EncodeSemiBoundedBelievedToBeSmall_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::largemessages::SemiBoundedBelievedToBeSmall SemiBoundedBelievedToBeSmall) {
    ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeSemiBoundedBelievedToBeSmall_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeSemiBoundedBelievedToBeSmall_DynamicFlags);
    const fidl_type_t* resp_type = &::test::largemessages::_internal::test_largemessages_SemiBoundedBelievedToBeSmallTable;
    response_.Send(resp_type, ::test::largemessages::Overflowing_ResponseEncoder::EncodeSemiBoundedBelievedToBeSmall(&_encoder, &SemiBoundedBelievedToBeSmall));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Overflowing_EncodeSemiBoundedMaybeLarge_Responder final {
 public:
  Overflowing_EncodeSemiBoundedMaybeLarge_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::largemessages::SemiBoundedMaybeLarge SemiBoundedMaybeLarge) {
    ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeSemiBoundedMaybeLarge_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeSemiBoundedMaybeLarge_DynamicFlags);
    const fidl_type_t* resp_type = &::test::largemessages::_internal::test_largemessages_SemiBoundedMaybeLargeTable;
    response_.Send(resp_type, ::test::largemessages::Overflowing_ResponseEncoder::EncodeSemiBoundedMaybeLarge(&_encoder, &SemiBoundedMaybeLarge));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Overflowing_EncodeUnboundedMaybeLargeValue_Responder final {
 public:
  Overflowing_EncodeUnboundedMaybeLargeValue_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::std::vector<uint8_t> bytes) {
    ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeValue_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeValue_DynamicFlags);
    const fidl_type_t* resp_type = &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeValueTable;
    response_.Send(resp_type, ::test::largemessages::Overflowing_ResponseEncoder::EncodeUnboundedMaybeLargeValue(&_encoder, &bytes));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Overflowing_EncodeUnboundedMaybeLargeResource_Responder final {
 public:
  Overflowing_EncodeUnboundedMaybeLargeResource_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::std::array<::test::largemessages::Elements, 64> elements) {
    ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeResource_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeResource_DynamicFlags);
    const fidl_type_t* resp_type = &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeResourceTable;
    response_.Send(resp_type, ::test::largemessages::Overflowing_ResponseEncoder::EncodeUnboundedMaybeLargeResource(&_encoder, &elements));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

}  // namespace

zx_status_t Overflowing_Stub::Dispatch_(
    ::fidl::HLCPPIncomingMessage message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  bool is_known;
  const fidl_type_t* request_type = ::test::largemessages::Overflowing_RequestDecoder::GetType(message.ordinal(), &needs_response, &is_known);

  if (!is_known) {
    auto is_flexible = message.is_flexible();
    auto ordinal = message.ordinal();
    // To satisfy RFC-0138, move the message so it is destructed before sending
    // a reply or calling the unknown method handler.
    { auto message_ = std::move(message); }
    if (is_flexible) {
      if (response.needs_response()) {
        ::fidl::MessageEncoder encoder(ordinal, ::fidl::MessageDynamicFlags::kFlexibleMethod);
        const fidl_type_t* resp_type = &kFidlInternalUnknownMethodResponseTable;
        response.Send(resp_type, ::fidl::internal::EncodeUnknownMethodResponse(&encoder));
        impl_->handle_unknown_method(ordinal, true);
      } else {
        impl_->handle_unknown_method(ordinal, false);
      }
      return ZX_OK;
    }
    return ZX_ERR_NOT_SUPPORTED;
  }

  if (!message.has_only_header()) {
    if (request_type == nullptr) {
      return ZX_ERR_NOT_SUPPORTED;
    }
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(request_type, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
      return status;
    }
  }

  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type, "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }

  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case ::test::largemessages::internal::kOverflowing_DecodeBoundedKnownToBeSmall_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->DecodeBoundedKnownToBeSmall(::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::largemessages::internal::kOverflowing_DecodeBoundedMaybeLarge_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->DecodeBoundedMaybeLarge(::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::largemessages::internal::kOverflowing_DecodeSemiBoundedBelievedToBeSmall_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->DecodeSemiBoundedBelievedToBeSmall(::fidl::DecodeAs<::test::largemessages::SemiBoundedBelievedToBeSmall>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::largemessages::internal::kOverflowing_DecodeSemiBoundedMaybeLarge_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->DecodeSemiBoundedMaybeLarge(::fidl::DecodeAs<::test::largemessages::SemiBoundedMaybeLarge>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::largemessages::internal::kOverflowing_DecodeUnboundedMaybeLargeValue_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->DecodeUnboundedMaybeLargeValue(::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::largemessages::internal::kOverflowing_DecodeUnboundedMaybeLargeResource_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->DecodeUnboundedMaybeLargeResource(::fidl::DecodeAs<::std::array<::test::largemessages::Elements, 64>>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::largemessages::internal::kOverflowing_EncodeBoundedKnownToBeSmall_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->EncodeBoundedKnownToBeSmall(::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)), Overflowing_EncodeBoundedKnownToBeSmall_Responder(std::move(response)));
      break;
    }
    case ::test::largemessages::internal::kOverflowing_EncodeBoundedMaybeLarge_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->EncodeBoundedMaybeLarge(::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)), Overflowing_EncodeBoundedMaybeLarge_Responder(std::move(response)));
      break;
    }
    case ::test::largemessages::internal::kOverflowing_EncodeSemiBoundedBelievedToBeSmall_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->EncodeSemiBoundedBelievedToBeSmall(::fidl::DecodeAs<::test::largemessages::SemiBoundedBelievedToBeSmall>(&decoder, 0 + sizeof(fidl_message_header_t)), Overflowing_EncodeSemiBoundedBelievedToBeSmall_Responder(std::move(response)));
      break;
    }
    case ::test::largemessages::internal::kOverflowing_EncodeSemiBoundedMaybeLarge_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->EncodeSemiBoundedMaybeLarge(::fidl::DecodeAs<::test::largemessages::SemiBoundedMaybeLarge>(&decoder, 0 + sizeof(fidl_message_header_t)), Overflowing_EncodeSemiBoundedMaybeLarge_Responder(std::move(response)));
      break;
    }
    case ::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeValue_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->EncodeUnboundedMaybeLargeValue(::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)), Overflowing_EncodeUnboundedMaybeLargeValue_Responder(std::move(response)));
      break;
    }
    case ::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeResource_Ordinal: {
      ::fidl::Decoder decoder(std::move(message));
      impl_->EncodeUnboundedMaybeLargeResource(::fidl::DecodeAs<::std::array<::test::largemessages::Elements, 64>>(&decoder, 0 + sizeof(fidl_message_header_t)), Overflowing_EncodeUnboundedMaybeLargeResource_Responder(std::move(response)));
      break;
    }
    default: {
      // Unknown ordinals are handled at the beginning of dispatching, so this
      // should be unreachable.
      ZX_PANIC("Unreachable: unknown ordinals handled earlier.");
    }
  }
  return ZX_OK;
}

Overflowing_SyncProxy::Overflowing_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

Overflowing_SyncProxy::~Overflowing_SyncProxy() = default;

zx_status_t Overflowing_SyncProxy::DecodeBoundedKnownToBeSmall(::std::vector<uint8_t> bytes) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_DecodeBoundedKnownToBeSmall_Ordinal, ::test::largemessages::internal::kOverflowing_DecodeBoundedKnownToBeSmall_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_BoundedKnownToBeSmallTable;
  return proxy_.Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::DecodeBoundedKnownToBeSmall(&_encoder, &bytes));
}

zx_status_t Overflowing_SyncProxy::DecodeBoundedMaybeLarge(::std::vector<uint8_t> bytes) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_DecodeBoundedMaybeLarge_Ordinal, ::test::largemessages::internal::kOverflowing_DecodeBoundedMaybeLarge_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_BoundedMaybeLargeTable;
  return proxy_.Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::DecodeBoundedMaybeLarge(&_encoder, &bytes));
}

zx_status_t Overflowing_SyncProxy::DecodeSemiBoundedBelievedToBeSmall(::test::largemessages::SemiBoundedBelievedToBeSmall SemiBoundedBelievedToBeSmall) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_DecodeSemiBoundedBelievedToBeSmall_Ordinal, ::test::largemessages::internal::kOverflowing_DecodeSemiBoundedBelievedToBeSmall_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_SemiBoundedBelievedToBeSmallTable;
  return proxy_.Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::DecodeSemiBoundedBelievedToBeSmall(&_encoder, &SemiBoundedBelievedToBeSmall));
}

zx_status_t Overflowing_SyncProxy::DecodeSemiBoundedMaybeLarge(::test::largemessages::SemiBoundedMaybeLarge SemiBoundedMaybeLarge) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_DecodeSemiBoundedMaybeLarge_Ordinal, ::test::largemessages::internal::kOverflowing_DecodeSemiBoundedMaybeLarge_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_SemiBoundedMaybeLargeTable;
  return proxy_.Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::DecodeSemiBoundedMaybeLarge(&_encoder, &SemiBoundedMaybeLarge));
}

zx_status_t Overflowing_SyncProxy::DecodeUnboundedMaybeLargeValue(::std::vector<uint8_t> bytes) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_DecodeUnboundedMaybeLargeValue_Ordinal, ::test::largemessages::internal::kOverflowing_DecodeUnboundedMaybeLargeValue_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeValueTable;
  return proxy_.Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::DecodeUnboundedMaybeLargeValue(&_encoder, &bytes));
}

zx_status_t Overflowing_SyncProxy::DecodeUnboundedMaybeLargeResource(::std::array<::test::largemessages::Elements, 64> elements) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_DecodeUnboundedMaybeLargeResource_Ordinal, ::test::largemessages::internal::kOverflowing_DecodeUnboundedMaybeLargeResource_DynamicFlags);
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeResourceTable;
  return proxy_.Send(req_type, ::test::largemessages::Overflowing_RequestEncoder::DecodeUnboundedMaybeLargeResource(&_encoder, &elements));
}

zx_status_t Overflowing_SyncProxy::EncodeBoundedKnownToBeSmall(::std::vector<uint8_t> bytes, ::std::vector<uint8_t>* out_bytes) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeBoundedKnownToBeSmall_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeBoundedKnownToBeSmall_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_BoundedKnownToBeSmallTable;
  const fidl_type_t* resp_type = &::test::largemessages::_internal::test_largemessages_BoundedKnownToBeSmallTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::largemessages::Overflowing_RequestEncoder::EncodeBoundedKnownToBeSmall(&_encoder, &bytes), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_bytes = ::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Overflowing_SyncProxy::EncodeBoundedMaybeLarge(::std::vector<uint8_t> bytes, ::std::vector<uint8_t>* out_bytes) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeBoundedMaybeLarge_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeBoundedMaybeLarge_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_BoundedMaybeLargeTable;
  const fidl_type_t* resp_type = &::test::largemessages::_internal::test_largemessages_BoundedMaybeLargeTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::largemessages::Overflowing_RequestEncoder::EncodeBoundedMaybeLarge(&_encoder, &bytes), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_bytes = ::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Overflowing_SyncProxy::EncodeSemiBoundedBelievedToBeSmall(::test::largemessages::SemiBoundedBelievedToBeSmall SemiBoundedBelievedToBeSmall, ::test::largemessages::SemiBoundedBelievedToBeSmall* out_SemiBoundedBelievedToBeSmall) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeSemiBoundedBelievedToBeSmall_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeSemiBoundedBelievedToBeSmall_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_SemiBoundedBelievedToBeSmallTable;
  const fidl_type_t* resp_type = &::test::largemessages::_internal::test_largemessages_SemiBoundedBelievedToBeSmallTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::largemessages::Overflowing_RequestEncoder::EncodeSemiBoundedBelievedToBeSmall(&_encoder, &SemiBoundedBelievedToBeSmall), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_SemiBoundedBelievedToBeSmall = ::fidl::DecodeAs<::test::largemessages::SemiBoundedBelievedToBeSmall>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Overflowing_SyncProxy::EncodeSemiBoundedMaybeLarge(::test::largemessages::SemiBoundedMaybeLarge SemiBoundedMaybeLarge, ::test::largemessages::SemiBoundedMaybeLarge* out_SemiBoundedMaybeLarge) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeSemiBoundedMaybeLarge_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeSemiBoundedMaybeLarge_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_SemiBoundedMaybeLargeTable;
  const fidl_type_t* resp_type = &::test::largemessages::_internal::test_largemessages_SemiBoundedMaybeLargeTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::largemessages::Overflowing_RequestEncoder::EncodeSemiBoundedMaybeLarge(&_encoder, &SemiBoundedMaybeLarge), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_SemiBoundedMaybeLarge = ::fidl::DecodeAs<::test::largemessages::SemiBoundedMaybeLarge>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Overflowing_SyncProxy::EncodeUnboundedMaybeLargeValue(::std::vector<uint8_t> bytes, ::std::vector<uint8_t>* out_bytes) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeValue_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeValue_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeValueTable;
  const fidl_type_t* resp_type = &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeValueTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::largemessages::Overflowing_RequestEncoder::EncodeUnboundedMaybeLargeValue(&_encoder, &bytes), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_bytes = ::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Overflowing_SyncProxy::EncodeUnboundedMaybeLargeResource(::std::array<::test::largemessages::Elements, 64> elements, ::std::array<::test::largemessages::Elements, 64>* out_elements) {
  ::fidl::MessageEncoder _encoder(::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeResource_Ordinal, ::test::largemessages::internal::kOverflowing_EncodeUnboundedMaybeLargeResource_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type = &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeResourceTable;
  const fidl_type_t* resp_type = &::test::largemessages::_internal::test_largemessages_UnboundedMaybeLargeResourceTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::largemessages::Overflowing_RequestEncoder::EncodeUnboundedMaybeLargeResource(&_encoder, &elements), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_elements = ::fidl::DecodeAs<::std::array<::test::largemessages::Elements, 64>>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

#endif  // __Fuchsia__

}  // namespace largemessages
}  // namespace test
