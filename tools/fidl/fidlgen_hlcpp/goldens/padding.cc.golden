// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = zx_select_case_sensitivity

#include <test/padding/cpp/fidl.h>

#include "lib/fidl/cpp/internal/implementation.h"

//
// Domain objects definitions
//
namespace test {
namespace padding {

extern "C" const fidl_type_t test_padding_Padding1ByteEndTable;
const fidl_type_t* Padding1ByteEnd::FidlType = &test_padding_Padding1ByteEndTable;

void Padding1ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset,
                             cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding1ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding1ByteEnd>(_offset), this, sizeof(Padding1ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 2);
  }
}

void Padding1ByteEnd::Decode(::fidl::Decoder* _decoder, Padding1ByteEnd* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding1ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding1ByteEnd>(_offset), sizeof(Padding1ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 2);
  }
}

zx_status_t Padding1ByteEnd::Clone(Padding1ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding2ByteEndTable;
const fidl_type_t* Padding2ByteEnd::FidlType = &test_padding_Padding2ByteEndTable;

void Padding2ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset,
                             cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding2ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding2ByteEnd>(_offset), this, sizeof(Padding2ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 4);
  }
}

void Padding2ByteEnd::Decode(::fidl::Decoder* _decoder, Padding2ByteEnd* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding2ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding2ByteEnd>(_offset), sizeof(Padding2ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 4);
  }
}

zx_status_t Padding2ByteEnd::Clone(Padding2ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding3ByteEndTable;
const fidl_type_t* Padding3ByteEnd::FidlType = &test_padding_Padding3ByteEndTable;

void Padding3ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset,
                             cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding3ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding3ByteEnd>(_offset), this, sizeof(Padding3ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 4);
  }
}

void Padding3ByteEnd::Decode(::fidl::Decoder* _decoder, Padding3ByteEnd* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding3ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding3ByteEnd>(_offset), sizeof(Padding3ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 4);
  }
}

zx_status_t Padding3ByteEnd::Clone(Padding3ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding4ByteEndTable;
const fidl_type_t* Padding4ByteEnd::FidlType = &test_padding_Padding4ByteEndTable;

void Padding4ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset,
                             cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding4ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding4ByteEnd>(_offset), this, sizeof(Padding4ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
  }
}

void Padding4ByteEnd::Decode(::fidl::Decoder* _decoder, Padding4ByteEnd* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding4ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding4ByteEnd>(_offset), sizeof(Padding4ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
  }
}

zx_status_t Padding4ByteEnd::Clone(Padding4ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding5ByteEndTable;
const fidl_type_t* Padding5ByteEnd::FidlType = &test_padding_Padding5ByteEndTable;

void Padding5ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset,
                             cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding5ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding5ByteEnd>(_offset), this, sizeof(Padding5ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
    ::fidl::Encode(_encoder, &c, _offset + 10);
  }
}

void Padding5ByteEnd::Decode(::fidl::Decoder* _decoder, Padding5ByteEnd* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding5ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding5ByteEnd>(_offset), sizeof(Padding5ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
    ::fidl::Decode(_decoder, &_value->c, _offset + 10);
  }
}

zx_status_t Padding5ByteEnd::Clone(Padding5ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(c, &_result->c);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding6ByteEndTable;
const fidl_type_t* Padding6ByteEnd::FidlType = &test_padding_Padding6ByteEndTable;

void Padding6ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset,
                             cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding6ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding6ByteEnd>(_offset), this, sizeof(Padding6ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
  }
}

void Padding6ByteEnd::Decode(::fidl::Decoder* _decoder, Padding6ByteEnd* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding6ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding6ByteEnd>(_offset), sizeof(Padding6ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
  }
}

zx_status_t Padding6ByteEnd::Clone(Padding6ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding7ByteEndTable;
const fidl_type_t* Padding7ByteEnd::FidlType = &test_padding_Padding7ByteEndTable;

void Padding7ByteEnd::Encode(::fidl::Encoder* _encoder, size_t _offset,
                             cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding7ByteEnd>::value) {
    memcpy(_encoder->template GetPtr<Padding7ByteEnd>(_offset), this, sizeof(Padding7ByteEnd));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
  }
}

void Padding7ByteEnd::Decode(::fidl::Decoder* _decoder, Padding7ByteEnd* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding7ByteEnd>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding7ByteEnd>(_offset), sizeof(Padding7ByteEnd));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
  }
}

zx_status_t Padding7ByteEnd::Clone(Padding7ByteEnd* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding1ByteMiddleTable;
const fidl_type_t* Padding1ByteMiddle::FidlType = &test_padding_Padding1ByteMiddleTable;

void Padding1ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding1ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding1ByteMiddle>(_offset), this, sizeof(Padding1ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 2);
  }
}

void Padding1ByteMiddle::Decode(::fidl::Decoder* _decoder, Padding1ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding1ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding1ByteMiddle>(_offset), sizeof(Padding1ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 2);
  }
}

zx_status_t Padding1ByteMiddle::Clone(Padding1ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding2ByteMiddleTable;
const fidl_type_t* Padding2ByteMiddle::FidlType = &test_padding_Padding2ByteMiddleTable;

void Padding2ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding2ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding2ByteMiddle>(_offset), this, sizeof(Padding2ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 4);
  }
}

void Padding2ByteMiddle::Decode(::fidl::Decoder* _decoder, Padding2ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding2ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding2ByteMiddle>(_offset), sizeof(Padding2ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 4);
  }
}

zx_status_t Padding2ByteMiddle::Clone(Padding2ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding3ByteMiddleTable;
const fidl_type_t* Padding3ByteMiddle::FidlType = &test_padding_Padding3ByteMiddleTable;

void Padding3ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding3ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding3ByteMiddle>(_offset), this, sizeof(Padding3ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 4);
  }
}

void Padding3ByteMiddle::Decode(::fidl::Decoder* _decoder, Padding3ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding3ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding3ByteMiddle>(_offset), sizeof(Padding3ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 4);
  }
}

zx_status_t Padding3ByteMiddle::Clone(Padding3ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding4ByteMiddleTable;
const fidl_type_t* Padding4ByteMiddle::FidlType = &test_padding_Padding4ByteMiddleTable;

void Padding4ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding4ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding4ByteMiddle>(_offset), this, sizeof(Padding4ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
  }
}

void Padding4ByteMiddle::Decode(::fidl::Decoder* _decoder, Padding4ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding4ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding4ByteMiddle>(_offset), sizeof(Padding4ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
  }
}

zx_status_t Padding4ByteMiddle::Clone(Padding4ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding5ByteMiddleTable;
const fidl_type_t* Padding5ByteMiddle::FidlType = &test_padding_Padding5ByteMiddleTable;

void Padding5ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding5ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding5ByteMiddle>(_offset), this, sizeof(Padding5ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 2);
    ::fidl::Encode(_encoder, &c, _offset + 8);
  }
}

void Padding5ByteMiddle::Decode(::fidl::Decoder* _decoder, Padding5ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding5ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding5ByteMiddle>(_offset), sizeof(Padding5ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 2);
    ::fidl::Decode(_decoder, &_value->c, _offset + 8);
  }
}

zx_status_t Padding5ByteMiddle::Clone(Padding5ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(c, &_result->c);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding6ByteMiddleTable;
const fidl_type_t* Padding6ByteMiddle::FidlType = &test_padding_Padding6ByteMiddleTable;

void Padding6ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding6ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding6ByteMiddle>(_offset), this, sizeof(Padding6ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
  }
}

void Padding6ByteMiddle::Decode(::fidl::Decoder* _decoder, Padding6ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding6ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding6ByteMiddle>(_offset), sizeof(Padding6ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
  }
}

zx_status_t Padding6ByteMiddle::Clone(Padding6ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding7ByteMiddleTable;
const fidl_type_t* Padding7ByteMiddle::FidlType = &test_padding_Padding7ByteMiddleTable;

void Padding7ByteMiddle::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding7ByteMiddle>::value) {
    memcpy(_encoder->template GetPtr<Padding7ByteMiddle>(_offset), this, sizeof(Padding7ByteMiddle));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 8);
  }
}

void Padding7ByteMiddle::Decode(::fidl::Decoder* _decoder, Padding7ByteMiddle* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding7ByteMiddle>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding7ByteMiddle>(_offset), sizeof(Padding7ByteMiddle));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 8);
  }
}

zx_status_t Padding7ByteMiddle::Clone(Padding7ByteMiddle* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding4ByteAlignmentLength12Table;
const fidl_type_t* Padding4ByteAlignmentLength12::FidlType = &test_padding_Padding4ByteAlignmentLength12Table;

void Padding4ByteAlignmentLength12::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                           cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding4ByteAlignmentLength12>::value) {
    memcpy(_encoder->template GetPtr<Padding4ByteAlignmentLength12>(_offset), this, sizeof(Padding4ByteAlignmentLength12));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 4);
    ::fidl::Encode(_encoder, &c, _offset + 6);
    ::fidl::Encode(_encoder, &d, _offset + 8);
  }
}

void Padding4ByteAlignmentLength12::Decode(::fidl::Decoder* _decoder, Padding4ByteAlignmentLength12* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding4ByteAlignmentLength12>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding4ByteAlignmentLength12>(_offset), sizeof(Padding4ByteAlignmentLength12));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 4);
    ::fidl::Decode(_decoder, &_value->c, _offset + 6);
    ::fidl::Decode(_decoder, &_value->d, _offset + 8);
  }
}

zx_status_t Padding4ByteAlignmentLength12::Clone(Padding4ByteAlignmentLength12* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(c, &_result->c);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(d, &_result->d);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_padding_Padding2ByteAlignmentLength6Table;
const fidl_type_t* Padding2ByteAlignmentLength6::FidlType = &test_padding_Padding2ByteAlignmentLength6Table;

void Padding2ByteAlignmentLength6::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                          cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Padding2ByteAlignmentLength6>::value) {
    memcpy(_encoder->template GetPtr<Padding2ByteAlignmentLength6>(_offset), this, sizeof(Padding2ByteAlignmentLength6));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 2);
    ::fidl::Encode(_encoder, &c, _offset + 4);
  }
}

void Padding2ByteAlignmentLength6::Decode(::fidl::Decoder* _decoder, Padding2ByteAlignmentLength6* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Padding2ByteAlignmentLength6>::value) {
    memcpy(_value, _decoder->template GetPtr<Padding2ByteAlignmentLength6>(_offset), sizeof(Padding2ByteAlignmentLength6));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 2);
    ::fidl::Decode(_decoder, &_value->c, _offset + 4);
  }
}

zx_status_t Padding2ByteAlignmentLength6::Clone(Padding2ByteAlignmentLength6* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(c, &_result->c);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

//
// Proxies and stubs definitions
//

}  // namespace padding
}  // namespace test
