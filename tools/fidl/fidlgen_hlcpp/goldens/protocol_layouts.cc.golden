// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = zx_select_case_sensitivity

#include <test/protocollayouts/cpp/fidl.h>

#include "lib/fidl/cpp/internal/implementation.h"


//
// Domain objects definitions
//
namespace test {
namespace protocollayouts {

extern "C" const fidl_type_t test_protocollayouts_LocalTablePayloadTable;
const fidl_type_t* LocalTablePayload::FidlType = &test_protocollayouts_LocalTablePayloadTable;

LocalTablePayload::LocalTablePayload() {}

LocalTablePayload::LocalTablePayload(LocalTablePayload&& other) {
  field_presence_ = other.field_presence_;
  if (field_presence_.IsSet<0>()) {
    Construct(&a_value_.value, std::move(other.a_value_.value));
  }
}

LocalTablePayload::~LocalTablePayload() {
  if (field_presence_.IsSet<0>()) {
    Destruct(&a_value_.value);
  }
}

LocalTablePayload& LocalTablePayload::operator=(LocalTablePayload&& other) {
  if (other.field_presence_.IsSet<0>()) {
    if (field_presence_.IsSet<0>()) {
      a_value_.value = std::move(other.a_value_.value);
    } else {
      field_presence_.Set<0>();
      Construct(&a_value_.value, std::move(other.a_value_.value));
    }
  } else if (field_presence_.IsSet<0>()) {
    field_presence_.Clear<0>();
    Destruct(&a_value_.value);
  }
  return *this;
}

bool LocalTablePayload::IsEmpty() const {
  return field_presence_.IsEmpty();
}
LocalTablePayload& LocalTablePayload::set_a(uint16_t _value) {
  if (!field_presence_.IsSet<0>()) {
    field_presence_.Set<0>();
    Construct(&a_value_.value, std::move(_value));
  } else {
    a_value_.value = std::move(_value);
  }
  return *this;
}

void LocalTablePayload::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
  if (field_presence_.IsSet<0>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<uint16_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &a_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &a_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<uint16_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
}

void LocalTablePayload::Decode(::fidl::Decoder* _decoder, LocalTablePayload* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_a(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_a();
    }
  } else {
    goto done_1;
  }

  

  return;

  // Clear unset values.
clear_all:
done_1:
  _value->clear_a();
  return;
}

zx_status_t LocalTablePayload::Clone(LocalTablePayload* result) const {
  if (field_presence_.IsSet<0>()) {
    zx_status_t _status = ::fidl::Clone(a_value_.value, result->mutable_a());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_a();
  }
  return ZX_OK;
}


extern "C" const fidl_type_t test_protocollayouts_LocalUnionPayloadTable;
const fidl_type_t* LocalUnionPayload::FidlType = &test_protocollayouts_LocalUnionPayloadTable;

LocalUnionPayload::LocalUnionPayload() {}

LocalUnionPayload::~LocalUnionPayload() {
  Destroy();
}

LocalUnionPayload::LocalUnionPayload(LocalUnionPayload&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocollayouts::LocalUnionPayload::Tag::kB:
      b_ = std::move(other.b_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::LocalUnionPayload::Tag::Invalid):
      break;
    default:
      new (&unknown_data_) decltype(unknown_data_);
      unknown_data_ = std::move(other.unknown_data_);
      break;
  }
}

LocalUnionPayload& LocalUnionPayload::operator=(LocalUnionPayload&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocollayouts::LocalUnionPayload::Tag::kB:
        b_ = std::move(other.b_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::LocalUnionPayload::Tag::Invalid):
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        unknown_data_= std::move(other.unknown_data_);
        break;
    }
  }
  return *this;
}

LocalUnionPayload LocalUnionPayload::WithB(bool&& val) {
  LocalUnionPayload result;
  result.set_b(std::move(val));
  return result;
}


void LocalUnionPayload::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocollayouts::LocalUnionPayload::Tag::kB: {
      if (::fidl::EncodingInlineSize<bool>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &b_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &b_,
        encoder->Alloc(::fidl::EncodingInlineSize<bool, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::protocollayouts::LocalUnionPayload::Tag::kUnknown: {
      ::fidl::EncodeUnknownBytes(encoder, &unknown_data_, offset + offsetof(fidl_xunion_t, envelope));
      *encoder->GetPtr<uint64_t>(offset) = tag_;
      break;
    }
    default:
      break;
  }
}

void LocalUnionPayload::Decode(::fidl::Decoder* _decoder, LocalUnionPayload* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::protocollayouts::LocalUnionPayload::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocollayouts::LocalUnionPayload::Tag::kB: {
      ::fidl::Decode(_decoder, &value->b_, value_offset);
      break;
    }
    default: {
  auto unknown_info = _decoder->EnvelopeUnknownDataInfo(&xunion->envelope);
      value->unknown_data_.resize(unknown_info.num_bytes);
      ::fidl::DecodeUnknownBytesContents(_decoder, &value->unknown_data_, unknown_info.value_offset);
  break;
    }
  }

}

zx_status_t LocalUnionPayload::Clone(LocalUnionPayload* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocollayouts::LocalUnionPayload::Tag::Invalid:
      return ZX_OK;
    case ::test::protocollayouts::LocalUnionPayload::Tag::kB:
      return ::fidl::Clone(b_, &result->b_);
    default:
      new (&result->unknown_data_) decltype(unknown_data_);
      return ::fidl::Clone(unknown_data_, &result->unknown_data_);
    return ZX_OK;
  }
}

LocalUnionPayload& LocalUnionPayload::set_b(bool value) {
  EnsureStorageInitialized(::test::protocollayouts::LocalUnionPayload::Tag::kB);
  b_ = std::move(value);
  return *this;
}
LocalUnionPayload& LocalUnionPayload::SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes) {
  EnsureStorageInitialized(ordinal);
  unknown_data_ = std::move(bytes);
  return *this;
}

void LocalUnionPayload::Destroy() {
  switch (tag_) {
    case ::test::protocollayouts::LocalUnionPayload::Tag::kB:
      break;
  
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::LocalUnionPayload::Tag::Invalid):
      break;
    default:
      unknown_data_.~decltype(unknown_data_)();
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::protocollayouts::LocalUnionPayload::Tag::Invalid);
}

void LocalUnionPayload::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::LocalUnionPayload::Tag::Invalid):
        break;
      case ::test::protocollayouts::LocalUnionPayload::Tag::kB:
        new (&b_) bool();
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        break;
    }
  }
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocol_TwoWayImportWithError_ResultTable;
const fidl_type_t* MainProtocol_TwoWayImportWithError_Result::FidlType = &test_protocollayouts_MainProtocol_TwoWayImportWithError_ResultTable;

MainProtocol_TwoWayImportWithError_Result::MainProtocol_TwoWayImportWithError_Result() {}

MainProtocol_TwoWayImportWithError_Result::~MainProtocol_TwoWayImportWithError_Result() {
  Destroy();
}

MainProtocol_TwoWayImportWithError_Result::MainProtocol_TwoWayImportWithError_Result(MainProtocol_TwoWayImportWithError_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kResponse:
      new (&response_) ::test::protocollayouts::imported::ImportUnionPayload();
      response_ = std::move(other.response_);
      break;
    case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::Invalid):
      break;
  }
}

MainProtocol_TwoWayImportWithError_Result& MainProtocol_TwoWayImportWithError_Result::operator=(MainProtocol_TwoWayImportWithError_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kResponse:
        new (&response_) ::test::protocollayouts::imported::ImportUnionPayload();
        response_ = std::move(other.response_);
        break;
      case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

MainProtocol_TwoWayImportWithError_Result MainProtocol_TwoWayImportWithError_Result::WithResponse(::test::protocollayouts::imported::ImportUnionPayload&& val) {
  MainProtocol_TwoWayImportWithError_Result result;
  result.set_response(std::move(val));
  return result;
}
MainProtocol_TwoWayImportWithError_Result MainProtocol_TwoWayImportWithError_Result::WithErr(uint32_t&& val) {
  MainProtocol_TwoWayImportWithError_Result result;
  result.set_err(std::move(val));
  return result;
}


void MainProtocol_TwoWayImportWithError_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::protocollayouts::imported::ImportUnionPayload>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::protocollayouts::imported::ImportUnionPayload, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void MainProtocol_TwoWayImportWithError_Result::Decode(::fidl::Decoder* _decoder, MainProtocol_TwoWayImportWithError_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kResponse: {
      new (&value->response_) ::test::protocollayouts::imported::ImportUnionPayload();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t MainProtocol_TwoWayImportWithError_Result::Clone(MainProtocol_TwoWayImportWithError_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kResponse:
      new (&result->response_) ::test::protocollayouts::imported::ImportUnionPayload();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

MainProtocol_TwoWayImportWithError_Result& MainProtocol_TwoWayImportWithError_Result::set_response(::test::protocollayouts::imported::ImportUnionPayload value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

MainProtocol_TwoWayImportWithError_Result& MainProtocol_TwoWayImportWithError_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void MainProtocol_TwoWayImportWithError_Result::Destroy() {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::Invalid);
}

void MainProtocol_TwoWayImportWithError_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::Invalid):
        break;
      case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kResponse:
        new (&response_) ::test::protocollayouts::imported::ImportUnionPayload();
        break;
      case ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocolTwoWayImportWithErrorTopResponseTable;
const fidl_type_t* MainProtocolTwoWayImportWithErrorTopResponse::FidlType = &test_protocollayouts_MainProtocolTwoWayImportWithErrorTopResponseTable;

void MainProtocolTwoWayImportWithErrorTopResponse::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<MainProtocolTwoWayImportWithErrorTopResponse>::value) {
    memcpy(_encoder->template GetPtr<MainProtocolTwoWayImportWithErrorTopResponse>(_offset), this, sizeof(MainProtocolTwoWayImportWithErrorTopResponse));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void MainProtocolTwoWayImportWithErrorTopResponse::Decode(::fidl::Decoder* _decoder, MainProtocolTwoWayImportWithErrorTopResponse* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<MainProtocolTwoWayImportWithErrorTopResponse>::value) {
    memcpy(_value, _decoder->template GetPtr<MainProtocolTwoWayImportWithErrorTopResponse>(_offset), sizeof(MainProtocolTwoWayImportWithErrorTopResponse));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t MainProtocolTwoWayImportWithErrorTopResponse::Clone(MainProtocolTwoWayImportWithErrorTopResponse* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocol_OnImportWithError_ResultTable;
const fidl_type_t* MainProtocol_OnImportWithError_Result::FidlType = &test_protocollayouts_MainProtocol_OnImportWithError_ResultTable;

MainProtocol_OnImportWithError_Result::MainProtocol_OnImportWithError_Result() {}

MainProtocol_OnImportWithError_Result::~MainProtocol_OnImportWithError_Result() {
  Destroy();
}

MainProtocol_OnImportWithError_Result::MainProtocol_OnImportWithError_Result(MainProtocol_OnImportWithError_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kResponse:
      new (&response_) ::test::protocollayouts::imported::ImportTablePayload();
      response_ = std::move(other.response_);
      break;
    case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::Invalid):
      break;
  }
}

MainProtocol_OnImportWithError_Result& MainProtocol_OnImportWithError_Result::operator=(MainProtocol_OnImportWithError_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kResponse:
        new (&response_) ::test::protocollayouts::imported::ImportTablePayload();
        response_ = std::move(other.response_);
        break;
      case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

MainProtocol_OnImportWithError_Result MainProtocol_OnImportWithError_Result::WithResponse(::test::protocollayouts::imported::ImportTablePayload&& val) {
  MainProtocol_OnImportWithError_Result result;
  result.set_response(std::move(val));
  return result;
}
MainProtocol_OnImportWithError_Result MainProtocol_OnImportWithError_Result::WithErr(uint32_t&& val) {
  MainProtocol_OnImportWithError_Result result;
  result.set_err(std::move(val));
  return result;
}


void MainProtocol_OnImportWithError_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::protocollayouts::imported::ImportTablePayload>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::protocollayouts::imported::ImportTablePayload, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void MainProtocol_OnImportWithError_Result::Decode(::fidl::Decoder* _decoder, MainProtocol_OnImportWithError_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kResponse: {
      new (&value->response_) ::test::protocollayouts::imported::ImportTablePayload();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t MainProtocol_OnImportWithError_Result::Clone(MainProtocol_OnImportWithError_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kResponse:
      new (&result->response_) ::test::protocollayouts::imported::ImportTablePayload();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

MainProtocol_OnImportWithError_Result& MainProtocol_OnImportWithError_Result::set_response(::test::protocollayouts::imported::ImportTablePayload value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

MainProtocol_OnImportWithError_Result& MainProtocol_OnImportWithError_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void MainProtocol_OnImportWithError_Result::Destroy() {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::Invalid);
}

void MainProtocol_OnImportWithError_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::Invalid):
        break;
      case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kResponse:
        new (&response_) ::test::protocollayouts::imported::ImportTablePayload();
        break;
      case ::test::protocollayouts::MainProtocol_OnImportWithError_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocolOnImportWithErrorRequestTable;
const fidl_type_t* MainProtocolOnImportWithErrorRequest::FidlType = &test_protocollayouts_MainProtocolOnImportWithErrorRequestTable;

void MainProtocolOnImportWithErrorRequest::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<MainProtocolOnImportWithErrorRequest>::value) {
    memcpy(_encoder->template GetPtr<MainProtocolOnImportWithErrorRequest>(_offset), this, sizeof(MainProtocolOnImportWithErrorRequest));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void MainProtocolOnImportWithErrorRequest::Decode(::fidl::Decoder* _decoder, MainProtocolOnImportWithErrorRequest* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<MainProtocolOnImportWithErrorRequest>::value) {
    memcpy(_value, _decoder->template GetPtr<MainProtocolOnImportWithErrorRequest>(_offset), sizeof(MainProtocolOnImportWithErrorRequest));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t MainProtocolOnImportWithErrorRequest::Clone(MainProtocolOnImportWithErrorRequest* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocol_TwoWayLocalWithError_ResultTable;
const fidl_type_t* MainProtocol_TwoWayLocalWithError_Result::FidlType = &test_protocollayouts_MainProtocol_TwoWayLocalWithError_ResultTable;

MainProtocol_TwoWayLocalWithError_Result::MainProtocol_TwoWayLocalWithError_Result() {}

MainProtocol_TwoWayLocalWithError_Result::~MainProtocol_TwoWayLocalWithError_Result() {
  Destroy();
}

MainProtocol_TwoWayLocalWithError_Result::MainProtocol_TwoWayLocalWithError_Result(MainProtocol_TwoWayLocalWithError_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kResponse:
      new (&response_) ::test::protocollayouts::LocalUnionPayload();
      response_ = std::move(other.response_);
      break;
    case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::Invalid):
      break;
  }
}

MainProtocol_TwoWayLocalWithError_Result& MainProtocol_TwoWayLocalWithError_Result::operator=(MainProtocol_TwoWayLocalWithError_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kResponse:
        new (&response_) ::test::protocollayouts::LocalUnionPayload();
        response_ = std::move(other.response_);
        break;
      case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

MainProtocol_TwoWayLocalWithError_Result MainProtocol_TwoWayLocalWithError_Result::WithResponse(::test::protocollayouts::LocalUnionPayload&& val) {
  MainProtocol_TwoWayLocalWithError_Result result;
  result.set_response(std::move(val));
  return result;
}
MainProtocol_TwoWayLocalWithError_Result MainProtocol_TwoWayLocalWithError_Result::WithErr(uint32_t&& val) {
  MainProtocol_TwoWayLocalWithError_Result result;
  result.set_err(std::move(val));
  return result;
}


void MainProtocol_TwoWayLocalWithError_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::protocollayouts::LocalUnionPayload>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::protocollayouts::LocalUnionPayload, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void MainProtocol_TwoWayLocalWithError_Result::Decode(::fidl::Decoder* _decoder, MainProtocol_TwoWayLocalWithError_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kResponse: {
      new (&value->response_) ::test::protocollayouts::LocalUnionPayload();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t MainProtocol_TwoWayLocalWithError_Result::Clone(MainProtocol_TwoWayLocalWithError_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kResponse:
      new (&result->response_) ::test::protocollayouts::LocalUnionPayload();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

MainProtocol_TwoWayLocalWithError_Result& MainProtocol_TwoWayLocalWithError_Result::set_response(::test::protocollayouts::LocalUnionPayload value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

MainProtocol_TwoWayLocalWithError_Result& MainProtocol_TwoWayLocalWithError_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void MainProtocol_TwoWayLocalWithError_Result::Destroy() {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::Invalid);
}

void MainProtocol_TwoWayLocalWithError_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::Invalid):
        break;
      case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kResponse:
        new (&response_) ::test::protocollayouts::LocalUnionPayload();
        break;
      case ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocolTwoWayLocalWithErrorTopResponseTable;
const fidl_type_t* MainProtocolTwoWayLocalWithErrorTopResponse::FidlType = &test_protocollayouts_MainProtocolTwoWayLocalWithErrorTopResponseTable;

void MainProtocolTwoWayLocalWithErrorTopResponse::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<MainProtocolTwoWayLocalWithErrorTopResponse>::value) {
    memcpy(_encoder->template GetPtr<MainProtocolTwoWayLocalWithErrorTopResponse>(_offset), this, sizeof(MainProtocolTwoWayLocalWithErrorTopResponse));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void MainProtocolTwoWayLocalWithErrorTopResponse::Decode(::fidl::Decoder* _decoder, MainProtocolTwoWayLocalWithErrorTopResponse* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<MainProtocolTwoWayLocalWithErrorTopResponse>::value) {
    memcpy(_value, _decoder->template GetPtr<MainProtocolTwoWayLocalWithErrorTopResponse>(_offset), sizeof(MainProtocolTwoWayLocalWithErrorTopResponse));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t MainProtocolTwoWayLocalWithErrorTopResponse::Clone(MainProtocolTwoWayLocalWithErrorTopResponse* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocol_OnLocalWithError_ResultTable;
const fidl_type_t* MainProtocol_OnLocalWithError_Result::FidlType = &test_protocollayouts_MainProtocol_OnLocalWithError_ResultTable;

MainProtocol_OnLocalWithError_Result::MainProtocol_OnLocalWithError_Result() {}

MainProtocol_OnLocalWithError_Result::~MainProtocol_OnLocalWithError_Result() {
  Destroy();
}

MainProtocol_OnLocalWithError_Result::MainProtocol_OnLocalWithError_Result(MainProtocol_OnLocalWithError_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kResponse:
      new (&response_) ::test::protocollayouts::LocalTablePayload();
      response_ = std::move(other.response_);
      break;
    case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::Invalid):
      break;
  }
}

MainProtocol_OnLocalWithError_Result& MainProtocol_OnLocalWithError_Result::operator=(MainProtocol_OnLocalWithError_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kResponse:
        new (&response_) ::test::protocollayouts::LocalTablePayload();
        response_ = std::move(other.response_);
        break;
      case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

MainProtocol_OnLocalWithError_Result MainProtocol_OnLocalWithError_Result::WithResponse(::test::protocollayouts::LocalTablePayload&& val) {
  MainProtocol_OnLocalWithError_Result result;
  result.set_response(std::move(val));
  return result;
}
MainProtocol_OnLocalWithError_Result MainProtocol_OnLocalWithError_Result::WithErr(uint32_t&& val) {
  MainProtocol_OnLocalWithError_Result result;
  result.set_err(std::move(val));
  return result;
}


void MainProtocol_OnLocalWithError_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::protocollayouts::LocalTablePayload>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::protocollayouts::LocalTablePayload, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void MainProtocol_OnLocalWithError_Result::Decode(::fidl::Decoder* _decoder, MainProtocol_OnLocalWithError_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kResponse: {
      new (&value->response_) ::test::protocollayouts::LocalTablePayload();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t MainProtocol_OnLocalWithError_Result::Clone(MainProtocol_OnLocalWithError_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kResponse:
      new (&result->response_) ::test::protocollayouts::LocalTablePayload();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

MainProtocol_OnLocalWithError_Result& MainProtocol_OnLocalWithError_Result::set_response(::test::protocollayouts::LocalTablePayload value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

MainProtocol_OnLocalWithError_Result& MainProtocol_OnLocalWithError_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void MainProtocol_OnLocalWithError_Result::Destroy() {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::Invalid);
}

void MainProtocol_OnLocalWithError_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::Invalid):
        break;
      case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kResponse:
        new (&response_) ::test::protocollayouts::LocalTablePayload();
        break;
      case ::test::protocollayouts::MainProtocol_OnLocalWithError_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocolOnLocalWithErrorRequestTable;
const fidl_type_t* MainProtocolOnLocalWithErrorRequest::FidlType = &test_protocollayouts_MainProtocolOnLocalWithErrorRequestTable;

void MainProtocolOnLocalWithErrorRequest::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<MainProtocolOnLocalWithErrorRequest>::value) {
    memcpy(_encoder->template GetPtr<MainProtocolOnLocalWithErrorRequest>(_offset), this, sizeof(MainProtocolOnLocalWithErrorRequest));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void MainProtocolOnLocalWithErrorRequest::Decode(::fidl::Decoder* _decoder, MainProtocolOnLocalWithErrorRequest* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<MainProtocolOnLocalWithErrorRequest>::value) {
    memcpy(_value, _decoder->template GetPtr<MainProtocolOnLocalWithErrorRequest>(_offset), sizeof(MainProtocolOnLocalWithErrorRequest));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t MainProtocolOnLocalWithErrorRequest::Clone(MainProtocolOnLocalWithErrorRequest* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocolOneWayAnonRequestTable;
const fidl_type_t* MainProtocolOneWayAnonRequest::FidlType = &test_protocollayouts_MainProtocolOneWayAnonRequestTable;

MainProtocolOneWayAnonRequest::MainProtocolOneWayAnonRequest() {}

MainProtocolOneWayAnonRequest::MainProtocolOneWayAnonRequest(MainProtocolOneWayAnonRequest&& other) {
  field_presence_ = other.field_presence_;
  if (field_presence_.IsSet<0>()) {
    Construct(&a_value_.value, std::move(other.a_value_.value));
  }
}

MainProtocolOneWayAnonRequest::~MainProtocolOneWayAnonRequest() {
  if (field_presence_.IsSet<0>()) {
    Destruct(&a_value_.value);
  }
}

MainProtocolOneWayAnonRequest& MainProtocolOneWayAnonRequest::operator=(MainProtocolOneWayAnonRequest&& other) {
  if (other.field_presence_.IsSet<0>()) {
    if (field_presence_.IsSet<0>()) {
      a_value_.value = std::move(other.a_value_.value);
    } else {
      field_presence_.Set<0>();
      Construct(&a_value_.value, std::move(other.a_value_.value));
    }
  } else if (field_presence_.IsSet<0>()) {
    field_presence_.Clear<0>();
    Destruct(&a_value_.value);
  }
  return *this;
}

bool MainProtocolOneWayAnonRequest::IsEmpty() const {
  return field_presence_.IsEmpty();
}
MainProtocolOneWayAnonRequest& MainProtocolOneWayAnonRequest::set_a(uint16_t _value) {
  if (!field_presence_.IsSet<0>()) {
    field_presence_.Set<0>();
    Construct(&a_value_.value, std::move(_value));
  } else {
    a_value_.value = std::move(_value);
  }
  return *this;
}

void MainProtocolOneWayAnonRequest::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
  if (field_presence_.IsSet<0>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<uint16_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &a_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &a_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<uint16_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
}

void MainProtocolOneWayAnonRequest::Decode(::fidl::Decoder* _decoder, MainProtocolOneWayAnonRequest* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_a(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_a();
    }
  } else {
    goto done_1;
  }

  

  return;

  // Clear unset values.
clear_all:
done_1:
  _value->clear_a();
  return;
}

zx_status_t MainProtocolOneWayAnonRequest::Clone(MainProtocolOneWayAnonRequest* result) const {
  if (field_presence_.IsSet<0>()) {
    zx_status_t _status = ::fidl::Clone(a_value_.value, result->mutable_a());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_a();
  }
  return ZX_OK;
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocolTwoWayAnonRequestTable;
const fidl_type_t* MainProtocolTwoWayAnonRequest::FidlType = &test_protocollayouts_MainProtocolTwoWayAnonRequestTable;

MainProtocolTwoWayAnonRequest::MainProtocolTwoWayAnonRequest() {}

MainProtocolTwoWayAnonRequest::~MainProtocolTwoWayAnonRequest() {
  Destroy();
}

MainProtocolTwoWayAnonRequest::MainProtocolTwoWayAnonRequest(MainProtocolTwoWayAnonRequest&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::kB:
      b_ = std::move(other.b_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::Invalid):
      break;
    default:
      new (&unknown_data_) decltype(unknown_data_);
      unknown_data_ = std::move(other.unknown_data_);
      break;
  }
}

MainProtocolTwoWayAnonRequest& MainProtocolTwoWayAnonRequest::operator=(MainProtocolTwoWayAnonRequest&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::kB:
        b_ = std::move(other.b_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::Invalid):
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        unknown_data_= std::move(other.unknown_data_);
        break;
    }
  }
  return *this;
}

MainProtocolTwoWayAnonRequest MainProtocolTwoWayAnonRequest::WithB(bool&& val) {
  MainProtocolTwoWayAnonRequest result;
  result.set_b(std::move(val));
  return result;
}


void MainProtocolTwoWayAnonRequest::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::kB: {
      if (::fidl::EncodingInlineSize<bool>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &b_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &b_,
        encoder->Alloc(::fidl::EncodingInlineSize<bool, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::kUnknown: {
      ::fidl::EncodeUnknownBytes(encoder, &unknown_data_, offset + offsetof(fidl_xunion_t, envelope));
      *encoder->GetPtr<uint64_t>(offset) = tag_;
      break;
    }
    default:
      break;
  }
}

void MainProtocolTwoWayAnonRequest::Decode(::fidl::Decoder* _decoder, MainProtocolTwoWayAnonRequest* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::kB: {
      ::fidl::Decode(_decoder, &value->b_, value_offset);
      break;
    }
    default: {
  auto unknown_info = _decoder->EnvelopeUnknownDataInfo(&xunion->envelope);
      value->unknown_data_.resize(unknown_info.num_bytes);
      ::fidl::DecodeUnknownBytesContents(_decoder, &value->unknown_data_, unknown_info.value_offset);
  break;
    }
  }

}

zx_status_t MainProtocolTwoWayAnonRequest::Clone(MainProtocolTwoWayAnonRequest* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::Invalid:
      return ZX_OK;
    case ::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::kB:
      return ::fidl::Clone(b_, &result->b_);
    default:
      new (&result->unknown_data_) decltype(unknown_data_);
      return ::fidl::Clone(unknown_data_, &result->unknown_data_);
    return ZX_OK;
  }
}

MainProtocolTwoWayAnonRequest& MainProtocolTwoWayAnonRequest::set_b(bool value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::kB);
  b_ = std::move(value);
  return *this;
}
MainProtocolTwoWayAnonRequest& MainProtocolTwoWayAnonRequest::SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes) {
  EnsureStorageInitialized(ordinal);
  unknown_data_ = std::move(bytes);
  return *this;
}

void MainProtocolTwoWayAnonRequest::Destroy() {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::kB:
      break;
  
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::Invalid):
      break;
    default:
      unknown_data_.~decltype(unknown_data_)();
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::Invalid);
}

void MainProtocolTwoWayAnonRequest::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::Invalid):
        break;
      case ::test::protocollayouts::MainProtocolTwoWayAnonRequest::Tag::kB:
        new (&b_) bool();
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        break;
    }
  }
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocolTwoWayAnonResponseTable;
const fidl_type_t* MainProtocolTwoWayAnonResponse::FidlType = &test_protocollayouts_MainProtocolTwoWayAnonResponseTable;

MainProtocolTwoWayAnonResponse::MainProtocolTwoWayAnonResponse() {}

MainProtocolTwoWayAnonResponse::MainProtocolTwoWayAnonResponse(MainProtocolTwoWayAnonResponse&& other) {
  field_presence_ = other.field_presence_;
  if (field_presence_.IsSet<0>()) {
    Construct(&a_value_.value, std::move(other.a_value_.value));
  }
}

MainProtocolTwoWayAnonResponse::~MainProtocolTwoWayAnonResponse() {
  if (field_presence_.IsSet<0>()) {
    Destruct(&a_value_.value);
  }
}

MainProtocolTwoWayAnonResponse& MainProtocolTwoWayAnonResponse::operator=(MainProtocolTwoWayAnonResponse&& other) {
  if (other.field_presence_.IsSet<0>()) {
    if (field_presence_.IsSet<0>()) {
      a_value_.value = std::move(other.a_value_.value);
    } else {
      field_presence_.Set<0>();
      Construct(&a_value_.value, std::move(other.a_value_.value));
    }
  } else if (field_presence_.IsSet<0>()) {
    field_presence_.Clear<0>();
    Destruct(&a_value_.value);
  }
  return *this;
}

bool MainProtocolTwoWayAnonResponse::IsEmpty() const {
  return field_presence_.IsEmpty();
}
MainProtocolTwoWayAnonResponse& MainProtocolTwoWayAnonResponse::set_a(uint16_t _value) {
  if (!field_presence_.IsSet<0>()) {
    field_presence_.Set<0>();
    Construct(&a_value_.value, std::move(_value));
  } else {
    a_value_.value = std::move(_value);
  }
  return *this;
}

void MainProtocolTwoWayAnonResponse::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
  if (field_presence_.IsSet<0>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<uint16_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &a_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &a_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<uint16_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
}

void MainProtocolTwoWayAnonResponse::Decode(::fidl::Decoder* _decoder, MainProtocolTwoWayAnonResponse* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_a(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_a();
    }
  } else {
    goto done_1;
  }

  

  return;

  // Clear unset values.
clear_all:
done_1:
  _value->clear_a();
  return;
}

zx_status_t MainProtocolTwoWayAnonResponse::Clone(MainProtocolTwoWayAnonResponse* result) const {
  if (field_presence_.IsSet<0>()) {
    zx_status_t _status = ::fidl::Clone(a_value_.value, result->mutable_a());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_a();
  }
  return ZX_OK;
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocolTwoWayAnonWithErrorRequestTable;
const fidl_type_t* MainProtocolTwoWayAnonWithErrorRequest::FidlType = &test_protocollayouts_MainProtocolTwoWayAnonWithErrorRequestTable;

MainProtocolTwoWayAnonWithErrorRequest::MainProtocolTwoWayAnonWithErrorRequest() {}

MainProtocolTwoWayAnonWithErrorRequest::MainProtocolTwoWayAnonWithErrorRequest(MainProtocolTwoWayAnonWithErrorRequest&& other) {
  field_presence_ = other.field_presence_;
  if (field_presence_.IsSet<0>()) {
    Construct(&a_value_.value, std::move(other.a_value_.value));
  }
}

MainProtocolTwoWayAnonWithErrorRequest::~MainProtocolTwoWayAnonWithErrorRequest() {
  if (field_presence_.IsSet<0>()) {
    Destruct(&a_value_.value);
  }
}

MainProtocolTwoWayAnonWithErrorRequest& MainProtocolTwoWayAnonWithErrorRequest::operator=(MainProtocolTwoWayAnonWithErrorRequest&& other) {
  if (other.field_presence_.IsSet<0>()) {
    if (field_presence_.IsSet<0>()) {
      a_value_.value = std::move(other.a_value_.value);
    } else {
      field_presence_.Set<0>();
      Construct(&a_value_.value, std::move(other.a_value_.value));
    }
  } else if (field_presence_.IsSet<0>()) {
    field_presence_.Clear<0>();
    Destruct(&a_value_.value);
  }
  return *this;
}

bool MainProtocolTwoWayAnonWithErrorRequest::IsEmpty() const {
  return field_presence_.IsEmpty();
}
MainProtocolTwoWayAnonWithErrorRequest& MainProtocolTwoWayAnonWithErrorRequest::set_a(uint16_t _value) {
  if (!field_presence_.IsSet<0>()) {
    field_presence_.Set<0>();
    Construct(&a_value_.value, std::move(_value));
  } else {
    a_value_.value = std::move(_value);
  }
  return *this;
}

void MainProtocolTwoWayAnonWithErrorRequest::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
  if (field_presence_.IsSet<0>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<uint16_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &a_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &a_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<uint16_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
}

void MainProtocolTwoWayAnonWithErrorRequest::Decode(::fidl::Decoder* _decoder, MainProtocolTwoWayAnonWithErrorRequest* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_a(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_a();
    }
  } else {
    goto done_1;
  }

  

  return;

  // Clear unset values.
clear_all:
done_1:
  _value->clear_a();
  return;
}

zx_status_t MainProtocolTwoWayAnonWithErrorRequest::Clone(MainProtocolTwoWayAnonWithErrorRequest* result) const {
  if (field_presence_.IsSet<0>()) {
    zx_status_t _status = ::fidl::Clone(a_value_.value, result->mutable_a());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_a();
  }
  return ZX_OK;
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocol_TwoWayAnonWithError_ResponseTable;
const fidl_type_t* MainProtocol_TwoWayAnonWithError_Response::FidlType = &test_protocollayouts_MainProtocol_TwoWayAnonWithError_ResponseTable;

MainProtocol_TwoWayAnonWithError_Response::MainProtocol_TwoWayAnonWithError_Response() {}

MainProtocol_TwoWayAnonWithError_Response::~MainProtocol_TwoWayAnonWithError_Response() {
  Destroy();
}

MainProtocol_TwoWayAnonWithError_Response::MainProtocol_TwoWayAnonWithError_Response(MainProtocol_TwoWayAnonWithError_Response&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::kB:
      b_ = std::move(other.b_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::Invalid):
      break;
    default:
      new (&unknown_data_) decltype(unknown_data_);
      unknown_data_ = std::move(other.unknown_data_);
      break;
  }
}

MainProtocol_TwoWayAnonWithError_Response& MainProtocol_TwoWayAnonWithError_Response::operator=(MainProtocol_TwoWayAnonWithError_Response&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::kB:
        b_ = std::move(other.b_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::Invalid):
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        unknown_data_= std::move(other.unknown_data_);
        break;
    }
  }
  return *this;
}

MainProtocol_TwoWayAnonWithError_Response MainProtocol_TwoWayAnonWithError_Response::WithB(bool&& val) {
  MainProtocol_TwoWayAnonWithError_Response result;
  result.set_b(std::move(val));
  return result;
}


void MainProtocol_TwoWayAnonWithError_Response::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::kB: {
      if (::fidl::EncodingInlineSize<bool>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &b_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &b_,
        encoder->Alloc(::fidl::EncodingInlineSize<bool, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::kUnknown: {
      ::fidl::EncodeUnknownBytes(encoder, &unknown_data_, offset + offsetof(fidl_xunion_t, envelope));
      *encoder->GetPtr<uint64_t>(offset) = tag_;
      break;
    }
    default:
      break;
  }
}

void MainProtocol_TwoWayAnonWithError_Response::Decode(::fidl::Decoder* _decoder, MainProtocol_TwoWayAnonWithError_Response* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::kB: {
      ::fidl::Decode(_decoder, &value->b_, value_offset);
      break;
    }
    default: {
  auto unknown_info = _decoder->EnvelopeUnknownDataInfo(&xunion->envelope);
      value->unknown_data_.resize(unknown_info.num_bytes);
      ::fidl::DecodeUnknownBytesContents(_decoder, &value->unknown_data_, unknown_info.value_offset);
  break;
    }
  }

}

zx_status_t MainProtocol_TwoWayAnonWithError_Response::Clone(MainProtocol_TwoWayAnonWithError_Response* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::Invalid:
      return ZX_OK;
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::kB:
      return ::fidl::Clone(b_, &result->b_);
    default:
      new (&result->unknown_data_) decltype(unknown_data_);
      return ::fidl::Clone(unknown_data_, &result->unknown_data_);
    return ZX_OK;
  }
}

MainProtocol_TwoWayAnonWithError_Response& MainProtocol_TwoWayAnonWithError_Response::set_b(bool value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::kB);
  b_ = std::move(value);
  return *this;
}
MainProtocol_TwoWayAnonWithError_Response& MainProtocol_TwoWayAnonWithError_Response::SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes) {
  EnsureStorageInitialized(ordinal);
  unknown_data_ = std::move(bytes);
  return *this;
}

void MainProtocol_TwoWayAnonWithError_Response::Destroy() {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::kB:
      break;
  
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::Invalid):
      break;
    default:
      unknown_data_.~decltype(unknown_data_)();
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::Invalid);
}

void MainProtocol_TwoWayAnonWithError_Response::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::Invalid):
        break;
      case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response::Tag::kB:
        new (&b_) bool();
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        break;
    }
  }
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocol_TwoWayAnonWithError_ResultTable;
const fidl_type_t* MainProtocol_TwoWayAnonWithError_Result::FidlType = &test_protocollayouts_MainProtocol_TwoWayAnonWithError_ResultTable;

MainProtocol_TwoWayAnonWithError_Result::MainProtocol_TwoWayAnonWithError_Result() {}

MainProtocol_TwoWayAnonWithError_Result::~MainProtocol_TwoWayAnonWithError_Result() {
  Destroy();
}

MainProtocol_TwoWayAnonWithError_Result::MainProtocol_TwoWayAnonWithError_Result(MainProtocol_TwoWayAnonWithError_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kResponse:
      new (&response_) ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response();
      response_ = std::move(other.response_);
      break;
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::Invalid):
      break;
  }
}

MainProtocol_TwoWayAnonWithError_Result& MainProtocol_TwoWayAnonWithError_Result::operator=(MainProtocol_TwoWayAnonWithError_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kResponse:
        new (&response_) ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response();
        response_ = std::move(other.response_);
        break;
      case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

MainProtocol_TwoWayAnonWithError_Result MainProtocol_TwoWayAnonWithError_Result::WithResponse(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response&& val) {
  MainProtocol_TwoWayAnonWithError_Result result;
  result.set_response(std::move(val));
  return result;
}
MainProtocol_TwoWayAnonWithError_Result MainProtocol_TwoWayAnonWithError_Result::WithErr(uint32_t&& val) {
  MainProtocol_TwoWayAnonWithError_Result result;
  result.set_err(std::move(val));
  return result;
}


void MainProtocol_TwoWayAnonWithError_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void MainProtocol_TwoWayAnonWithError_Result::Decode(::fidl::Decoder* _decoder, MainProtocol_TwoWayAnonWithError_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kResponse: {
      new (&value->response_) ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t MainProtocol_TwoWayAnonWithError_Result::Clone(MainProtocol_TwoWayAnonWithError_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kResponse:
      new (&result->response_) ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

MainProtocol_TwoWayAnonWithError_Result& MainProtocol_TwoWayAnonWithError_Result::set_response(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

MainProtocol_TwoWayAnonWithError_Result& MainProtocol_TwoWayAnonWithError_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void MainProtocol_TwoWayAnonWithError_Result::Destroy() {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::Invalid);
}

void MainProtocol_TwoWayAnonWithError_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::Invalid):
        break;
      case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kResponse:
        new (&response_) ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Response();
        break;
      case ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocolTwoWayAnonWithErrorTopResponseTable;
const fidl_type_t* MainProtocolTwoWayAnonWithErrorTopResponse::FidlType = &test_protocollayouts_MainProtocolTwoWayAnonWithErrorTopResponseTable;

void MainProtocolTwoWayAnonWithErrorTopResponse::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<MainProtocolTwoWayAnonWithErrorTopResponse>::value) {
    memcpy(_encoder->template GetPtr<MainProtocolTwoWayAnonWithErrorTopResponse>(_offset), this, sizeof(MainProtocolTwoWayAnonWithErrorTopResponse));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void MainProtocolTwoWayAnonWithErrorTopResponse::Decode(::fidl::Decoder* _decoder, MainProtocolTwoWayAnonWithErrorTopResponse* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<MainProtocolTwoWayAnonWithErrorTopResponse>::value) {
    memcpy(_value, _decoder->template GetPtr<MainProtocolTwoWayAnonWithErrorTopResponse>(_offset), sizeof(MainProtocolTwoWayAnonWithErrorTopResponse));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t MainProtocolTwoWayAnonWithErrorTopResponse::Clone(MainProtocolTwoWayAnonWithErrorTopResponse* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocolOnAnonRequestTable;
const fidl_type_t* MainProtocolOnAnonRequest::FidlType = &test_protocollayouts_MainProtocolOnAnonRequestTable;

MainProtocolOnAnonRequest::MainProtocolOnAnonRequest() {}

MainProtocolOnAnonRequest::~MainProtocolOnAnonRequest() {
  Destroy();
}

MainProtocolOnAnonRequest::MainProtocolOnAnonRequest(MainProtocolOnAnonRequest&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocolOnAnonRequest::Tag::kB:
      b_ = std::move(other.b_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocolOnAnonRequest::Tag::Invalid):
      break;
    default:
      new (&unknown_data_) decltype(unknown_data_);
      unknown_data_ = std::move(other.unknown_data_);
      break;
  }
}

MainProtocolOnAnonRequest& MainProtocolOnAnonRequest::operator=(MainProtocolOnAnonRequest&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocollayouts::MainProtocolOnAnonRequest::Tag::kB:
        b_ = std::move(other.b_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocolOnAnonRequest::Tag::Invalid):
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        unknown_data_= std::move(other.unknown_data_);
        break;
    }
  }
  return *this;
}

MainProtocolOnAnonRequest MainProtocolOnAnonRequest::WithB(bool&& val) {
  MainProtocolOnAnonRequest result;
  result.set_b(std::move(val));
  return result;
}


void MainProtocolOnAnonRequest::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocollayouts::MainProtocolOnAnonRequest::Tag::kB: {
      if (::fidl::EncodingInlineSize<bool>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &b_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &b_,
        encoder->Alloc(::fidl::EncodingInlineSize<bool, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::protocollayouts::MainProtocolOnAnonRequest::Tag::kUnknown: {
      ::fidl::EncodeUnknownBytes(encoder, &unknown_data_, offset + offsetof(fidl_xunion_t, envelope));
      *encoder->GetPtr<uint64_t>(offset) = tag_;
      break;
    }
    default:
      break;
  }
}

void MainProtocolOnAnonRequest::Decode(::fidl::Decoder* _decoder, MainProtocolOnAnonRequest* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocolOnAnonRequest::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocollayouts::MainProtocolOnAnonRequest::Tag::kB: {
      ::fidl::Decode(_decoder, &value->b_, value_offset);
      break;
    }
    default: {
  auto unknown_info = _decoder->EnvelopeUnknownDataInfo(&xunion->envelope);
      value->unknown_data_.resize(unknown_info.num_bytes);
      ::fidl::DecodeUnknownBytesContents(_decoder, &value->unknown_data_, unknown_info.value_offset);
  break;
    }
  }

}

zx_status_t MainProtocolOnAnonRequest::Clone(MainProtocolOnAnonRequest* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocollayouts::MainProtocolOnAnonRequest::Tag::Invalid:
      return ZX_OK;
    case ::test::protocollayouts::MainProtocolOnAnonRequest::Tag::kB:
      return ::fidl::Clone(b_, &result->b_);
    default:
      new (&result->unknown_data_) decltype(unknown_data_);
      return ::fidl::Clone(unknown_data_, &result->unknown_data_);
    return ZX_OK;
  }
}

MainProtocolOnAnonRequest& MainProtocolOnAnonRequest::set_b(bool value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocolOnAnonRequest::Tag::kB);
  b_ = std::move(value);
  return *this;
}
MainProtocolOnAnonRequest& MainProtocolOnAnonRequest::SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes) {
  EnsureStorageInitialized(ordinal);
  unknown_data_ = std::move(bytes);
  return *this;
}

void MainProtocolOnAnonRequest::Destroy() {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocolOnAnonRequest::Tag::kB:
      break;
  
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocolOnAnonRequest::Tag::Invalid):
      break;
    default:
      unknown_data_.~decltype(unknown_data_)();
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocolOnAnonRequest::Tag::Invalid);
}

void MainProtocolOnAnonRequest::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocolOnAnonRequest::Tag::Invalid):
        break;
      case ::test::protocollayouts::MainProtocolOnAnonRequest::Tag::kB:
        new (&b_) bool();
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        break;
    }
  }
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocol_OnAnonWithError_ResponseTable;
const fidl_type_t* MainProtocol_OnAnonWithError_Response::FidlType = &test_protocollayouts_MainProtocol_OnAnonWithError_ResponseTable;

MainProtocol_OnAnonWithError_Response::MainProtocol_OnAnonWithError_Response() {}

MainProtocol_OnAnonWithError_Response::MainProtocol_OnAnonWithError_Response(MainProtocol_OnAnonWithError_Response&& other) {
  field_presence_ = other.field_presence_;
  if (field_presence_.IsSet<0>()) {
    Construct(&a_value_.value, std::move(other.a_value_.value));
  }
}

MainProtocol_OnAnonWithError_Response::~MainProtocol_OnAnonWithError_Response() {
  if (field_presence_.IsSet<0>()) {
    Destruct(&a_value_.value);
  }
}

MainProtocol_OnAnonWithError_Response& MainProtocol_OnAnonWithError_Response::operator=(MainProtocol_OnAnonWithError_Response&& other) {
  if (other.field_presence_.IsSet<0>()) {
    if (field_presence_.IsSet<0>()) {
      a_value_.value = std::move(other.a_value_.value);
    } else {
      field_presence_.Set<0>();
      Construct(&a_value_.value, std::move(other.a_value_.value));
    }
  } else if (field_presence_.IsSet<0>()) {
    field_presence_.Clear<0>();
    Destruct(&a_value_.value);
  }
  return *this;
}

bool MainProtocol_OnAnonWithError_Response::IsEmpty() const {
  return field_presence_.IsEmpty();
}
MainProtocol_OnAnonWithError_Response& MainProtocol_OnAnonWithError_Response::set_a(uint16_t _value) {
  if (!field_presence_.IsSet<0>()) {
    field_presence_.Set<0>();
    Construct(&a_value_.value, std::move(_value));
  } else {
    a_value_.value = std::move(_value);
  }
  return *this;
}

void MainProtocol_OnAnonWithError_Response::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
  if (field_presence_.IsSet<0>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<uint16_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &a_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &a_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<uint16_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
}

void MainProtocol_OnAnonWithError_Response::Decode(::fidl::Decoder* _decoder, MainProtocol_OnAnonWithError_Response* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_a(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_a();
    }
  } else {
    goto done_1;
  }

  

  return;

  // Clear unset values.
clear_all:
done_1:
  _value->clear_a();
  return;
}

zx_status_t MainProtocol_OnAnonWithError_Response::Clone(MainProtocol_OnAnonWithError_Response* result) const {
  if (field_presence_.IsSet<0>()) {
    zx_status_t _status = ::fidl::Clone(a_value_.value, result->mutable_a());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_a();
  }
  return ZX_OK;
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocol_OnAnonWithError_ResultTable;
const fidl_type_t* MainProtocol_OnAnonWithError_Result::FidlType = &test_protocollayouts_MainProtocol_OnAnonWithError_ResultTable;

MainProtocol_OnAnonWithError_Result::MainProtocol_OnAnonWithError_Result() {}

MainProtocol_OnAnonWithError_Result::~MainProtocol_OnAnonWithError_Result() {
  Destroy();
}

MainProtocol_OnAnonWithError_Result::MainProtocol_OnAnonWithError_Result(MainProtocol_OnAnonWithError_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kResponse:
      new (&response_) ::test::protocollayouts::MainProtocol_OnAnonWithError_Response();
      response_ = std::move(other.response_);
      break;
    case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::Invalid):
      break;
  }
}

MainProtocol_OnAnonWithError_Result& MainProtocol_OnAnonWithError_Result::operator=(MainProtocol_OnAnonWithError_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kResponse:
        new (&response_) ::test::protocollayouts::MainProtocol_OnAnonWithError_Response();
        response_ = std::move(other.response_);
        break;
      case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

MainProtocol_OnAnonWithError_Result MainProtocol_OnAnonWithError_Result::WithResponse(::test::protocollayouts::MainProtocol_OnAnonWithError_Response&& val) {
  MainProtocol_OnAnonWithError_Result result;
  result.set_response(std::move(val));
  return result;
}
MainProtocol_OnAnonWithError_Result MainProtocol_OnAnonWithError_Result::WithErr(uint32_t&& val) {
  MainProtocol_OnAnonWithError_Result result;
  result.set_err(std::move(val));
  return result;
}


void MainProtocol_OnAnonWithError_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::protocollayouts::MainProtocol_OnAnonWithError_Response>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::protocollayouts::MainProtocol_OnAnonWithError_Response, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void MainProtocol_OnAnonWithError_Result::Decode(::fidl::Decoder* _decoder, MainProtocol_OnAnonWithError_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kResponse: {
      new (&value->response_) ::test::protocollayouts::MainProtocol_OnAnonWithError_Response();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t MainProtocol_OnAnonWithError_Result::Clone(MainProtocol_OnAnonWithError_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kResponse:
      new (&result->response_) ::test::protocollayouts::MainProtocol_OnAnonWithError_Response();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

MainProtocol_OnAnonWithError_Result& MainProtocol_OnAnonWithError_Result::set_response(::test::protocollayouts::MainProtocol_OnAnonWithError_Response value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

MainProtocol_OnAnonWithError_Result& MainProtocol_OnAnonWithError_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void MainProtocol_OnAnonWithError_Result::Destroy() {
  switch (tag_) {
    case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::Invalid);
}

void MainProtocol_OnAnonWithError_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::Invalid):
        break;
      case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kResponse:
        new (&response_) ::test::protocollayouts::MainProtocol_OnAnonWithError_Response();
        break;
      case ::test::protocollayouts::MainProtocol_OnAnonWithError_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_protocollayouts_MainProtocolOnAnonWithErrorRequestTable;
const fidl_type_t* MainProtocolOnAnonWithErrorRequest::FidlType = &test_protocollayouts_MainProtocolOnAnonWithErrorRequestTable;

void MainProtocolOnAnonWithErrorRequest::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<MainProtocolOnAnonWithErrorRequest>::value) {
    memcpy(_encoder->template GetPtr<MainProtocolOnAnonWithErrorRequest>(_offset), this, sizeof(MainProtocolOnAnonWithErrorRequest));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void MainProtocolOnAnonWithErrorRequest::Decode(::fidl::Decoder* _decoder, MainProtocolOnAnonWithErrorRequest* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<MainProtocolOnAnonWithErrorRequest>::value) {
    memcpy(_value, _decoder->template GetPtr<MainProtocolOnAnonWithErrorRequest>(_offset), sizeof(MainProtocolOnAnonWithErrorRequest));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t MainProtocolOnAnonWithErrorRequest::Clone(MainProtocolOnAnonWithErrorRequest* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

//
// Proxies and stubs definitions
//
#ifdef __Fuchsia__

  namespace _internal {
__LOCAL extern "C" const fidl_type_t test_protocollayouts_imported_ComposedProtocolOneWayAnonComposedRequestTable;
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedRequestTable;
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedResponseTable;
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedWithErrorRequestTable;
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedWithErrorTopResponseTable;
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_imported_ComposedProtocolOnAnonComposedRequestTable;
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_imported_ComposedProtocolOnAnonComposedWithErrorRequestTable;
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_imported_ImportTablePayloadTable;
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_imported_ImportUnionPayloadTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_imported_ComposedProtocolTwoWayNamedComposedWithErrorTopResponseTable;
  
  
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_imported_ComposedProtocolOnNamedComposedWithErrorRequestTable;
  
  
  
  
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_MainProtocolTwoWayImportWithErrorTopResponseTable;
  
  
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_MainProtocolOnImportWithErrorRequestTable;
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_LocalTablePayloadTable;
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_LocalUnionPayloadTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_MainProtocolTwoWayLocalWithErrorTopResponseTable;
  
  
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_MainProtocolOnLocalWithErrorRequestTable;
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_MainProtocolOneWayAnonRequestTable;
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_MainProtocolTwoWayAnonRequestTable;
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_MainProtocolTwoWayAnonResponseTable;
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_MainProtocolTwoWayAnonWithErrorRequestTable;
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_MainProtocolTwoWayAnonWithErrorTopResponseTable;
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_MainProtocolOnAnonRequestTable;
  
  
__LOCAL extern "C" const fidl_type_t test_protocollayouts_MainProtocolOnAnonWithErrorRequestTable;

}  // namespace _internal

MainProtocol::~MainProtocol() = default;

const fidl_type_t* ::test::protocollayouts::MainProtocol_RequestDecoder::GetType(uint64_t ordinal, bool* out_needs_response, bool* out_is_known) {
  *out_needs_response = false;
  *out_is_known = false;
  switch (ordinal) {
    case ::test::protocollayouts::internal::kMainProtocol_OneWayAnonComposed_Ordinal:
      *out_is_known = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOneWayAnonComposedRequestTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposed_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedRequestTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposedWithError_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedWithErrorRequestTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OneWayNamedComposed_Ordinal:
      *out_is_known = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposed_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposedWithError_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OneWayImport_Ordinal:
      *out_is_known = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayImport_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayImportWithError_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OneWayLocal_Ordinal:
      *out_is_known = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_LocalTablePayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayLocal_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_LocalUnionPayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayLocalWithError_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_LocalTablePayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OneWayAnon_Ordinal:
      *out_is_known = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOneWayAnonRequestTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayAnon_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonRequestTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonWithError_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonWithErrorRequestTable;
        ;
    default:
      return nullptr;
  }
}

const fidl_type_t* MainProtocol_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposed_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedResponseTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposedWithError_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedWithErrorTopResponseTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OnAnonComposed_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOnAnonComposedRequestTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OnAnonComposedWithError_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOnAnonComposedWithErrorRequestTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposed_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposedWithError_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayNamedComposedWithErrorTopResponseTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OnNamedComposed_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OnNamedComposedWithError_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOnNamedComposedWithErrorRequestTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayImport_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayImportWithError_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayImportWithErrorTopResponseTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OnImport_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OnImportWithError_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnImportWithErrorRequestTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayLocal_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_LocalTablePayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayLocalWithError_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayLocalWithErrorTopResponseTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OnLocal_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_LocalUnionPayloadTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OnLocalWithError_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnLocalWithErrorRequestTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayAnon_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonResponseTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonWithError_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonWithErrorTopResponseTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OnAnon_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnAnonRequestTable;
        ;
    case ::test::protocollayouts::internal::kMainProtocol_OnAnonWithError_Ordinal:
      return &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnAnonWithErrorRequestTable;
        ;
    default:
      return nullptr;
  }
}

MainProtocol_EventSender::~MainProtocol_EventSender() = default;

MainProtocol_Sync::~MainProtocol_Sync() = default;

MainProtocol_Proxy::MainProtocol_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

MainProtocol_Proxy::~MainProtocol_Proxy() = default;

zx_status_t MainProtocol_Proxy::Dispatch_(::fidl::HLCPPIncomingMessage message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case ::test::protocollayouts::internal::kMainProtocol_OnAnonComposed_Ordinal: {
      if (!OnAnonComposed) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOnAnonComposedRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOnAnonComposedRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      OnAnonComposed(::fidl::DecodeAs<::test::protocollayouts::imported::ComposedProtocolOnAnonComposedRequest>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_OnAnonComposedWithError_Ordinal: {
      if (!OnAnonComposedWithError) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOnAnonComposedWithErrorRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOnAnonComposedWithErrorRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      OnAnonComposedWithError(::fidl::DecodeAs<::test::protocollayouts::imported::ComposedProtocol_OnAnonComposedWithError_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_OnNamedComposed_Ordinal: {
      if (!OnNamedComposed) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      OnNamedComposed(::fidl::DecodeAs<::test::protocollayouts::imported::ImportUnionPayload>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_OnNamedComposedWithError_Ordinal: {
      if (!OnNamedComposedWithError) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOnNamedComposedWithErrorRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOnNamedComposedWithErrorRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      OnNamedComposedWithError(::fidl::DecodeAs<::test::protocollayouts::imported::ComposedProtocol_OnNamedComposedWithError_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_OnImport_Ordinal: {
      if (!OnImport) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      OnImport(::fidl::DecodeAs<::test::protocollayouts::imported::ImportUnionPayload>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_OnImportWithError_Ordinal: {
      if (!OnImportWithError) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnImportWithErrorRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnImportWithErrorRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      OnImportWithError(::fidl::DecodeAs<::test::protocollayouts::MainProtocol_OnImportWithError_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_OnLocal_Ordinal: {
      if (!OnLocal) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::protocollayouts::_internal::test_protocollayouts_LocalUnionPayloadTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::protocollayouts::_internal::test_protocollayouts_LocalUnionPayloadTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      OnLocal(::fidl::DecodeAs<::test::protocollayouts::LocalUnionPayload>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_OnLocalWithError_Ordinal: {
      if (!OnLocalWithError) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnLocalWithErrorRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnLocalWithErrorRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      OnLocalWithError(::fidl::DecodeAs<::test::protocollayouts::MainProtocol_OnLocalWithError_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_OnAnon_Ordinal: {
      if (!OnAnon) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnAnonRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnAnonRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      OnAnon(::fidl::DecodeAs<::test::protocollayouts::MainProtocolOnAnonRequest>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_OnAnonWithError_Ordinal: {
      if (!OnAnonWithError) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnAnonWithErrorRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnAnonWithErrorRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      OnAnonWithError(::fidl::DecodeAs<::test::protocollayouts::MainProtocol_OnAnonWithError_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void MainProtocol_Proxy::OneWayAnonComposed(::test::protocollayouts::imported::ComposedProtocolOneWayAnonComposedRequest ComposedProtocolOneWayAnonComposedRequest) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OneWayAnonComposed_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OneWayAnonComposed_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOneWayAnonComposedRequestTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::OneWayAnonComposed(&_encoder, &ComposedProtocolOneWayAnonComposedRequest), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
MainProtocol_TwoWayAnonComposed_ResponseHandler(MainProtocol::TwoWayAnonComposedCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for MainProtocol::TwoWayAnonComposed\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::protocollayouts::imported::ComposedProtocolTwoWayAnonComposedResponse>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedResponseTable);
}

}  // namespace
void MainProtocol_Proxy::TwoWayAnonComposed(::test::protocollayouts::imported::ComposedProtocolTwoWayAnonComposedRequest ComposedProtocolTwoWayAnonComposedRequest, TwoWayAnonComposedCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposed_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposed_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedRequestTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayAnonComposed(&_encoder, &ComposedProtocolTwoWayAnonComposedRequest), MainProtocol_TwoWayAnonComposed_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
MainProtocol_TwoWayAnonComposedWithError_ResponseHandler(MainProtocol::TwoWayAnonComposedWithErrorCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for MainProtocol::TwoWayAnonComposedWithError\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::protocollayouts::imported::ComposedProtocol_TwoWayAnonComposedWithError_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedWithErrorTopResponseTable);
}

}  // namespace
void MainProtocol_Proxy::TwoWayAnonComposedWithError(::test::protocollayouts::imported::ComposedProtocolTwoWayAnonComposedWithErrorRequest ComposedProtocolTwoWayAnonComposedWithErrorRequest, TwoWayAnonComposedWithErrorCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposedWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposedWithError_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedWithErrorRequestTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayAnonComposedWithError(&_encoder, &ComposedProtocolTwoWayAnonComposedWithErrorRequest), MainProtocol_TwoWayAnonComposedWithError_ResponseHandler(std::move(callback)));
}
void MainProtocol_Proxy::OneWayNamedComposed(::test::protocollayouts::imported::ImportTablePayload ImportTablePayload) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OneWayNamedComposed_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OneWayNamedComposed_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::OneWayNamedComposed(&_encoder, &ImportTablePayload), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
MainProtocol_TwoWayNamedComposed_ResponseHandler(MainProtocol::TwoWayNamedComposedCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for MainProtocol::TwoWayNamedComposed\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::protocollayouts::imported::ImportTablePayload>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable);
}

}  // namespace
void MainProtocol_Proxy::TwoWayNamedComposed(::test::protocollayouts::imported::ImportUnionPayload ImportUnionPayload, TwoWayNamedComposedCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposed_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposed_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayNamedComposed(&_encoder, &ImportUnionPayload), MainProtocol_TwoWayNamedComposed_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
MainProtocol_TwoWayNamedComposedWithError_ResponseHandler(MainProtocol::TwoWayNamedComposedWithErrorCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for MainProtocol::TwoWayNamedComposedWithError\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::protocollayouts::imported::ComposedProtocol_TwoWayNamedComposedWithError_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayNamedComposedWithErrorTopResponseTable);
}

}  // namespace
void MainProtocol_Proxy::TwoWayNamedComposedWithError(::test::protocollayouts::imported::ImportTablePayload ImportTablePayload, TwoWayNamedComposedWithErrorCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposedWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposedWithError_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayNamedComposedWithError(&_encoder, &ImportTablePayload), MainProtocol_TwoWayNamedComposedWithError_ResponseHandler(std::move(callback)));
}
void MainProtocol_Proxy::OneWayImport(::test::protocollayouts::imported::ImportTablePayload ImportTablePayload) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OneWayImport_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OneWayImport_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::OneWayImport(&_encoder, &ImportTablePayload), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
MainProtocol_TwoWayImport_ResponseHandler(MainProtocol::TwoWayImportCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for MainProtocol::TwoWayImport\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::protocollayouts::imported::ImportTablePayload>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable);
}

}  // namespace
void MainProtocol_Proxy::TwoWayImport(::test::protocollayouts::imported::ImportUnionPayload ImportUnionPayload, TwoWayImportCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayImport_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayImport_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayImport(&_encoder, &ImportUnionPayload), MainProtocol_TwoWayImport_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
MainProtocol_TwoWayImportWithError_ResponseHandler(MainProtocol::TwoWayImportWithErrorCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for MainProtocol::TwoWayImportWithError\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayImportWithErrorTopResponseTable);
}

}  // namespace
void MainProtocol_Proxy::TwoWayImportWithError(::test::protocollayouts::imported::ImportTablePayload ImportTablePayload, TwoWayImportWithErrorCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayImportWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayImportWithError_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayImportWithError(&_encoder, &ImportTablePayload), MainProtocol_TwoWayImportWithError_ResponseHandler(std::move(callback)));
}
void MainProtocol_Proxy::OneWayLocal(::test::protocollayouts::LocalTablePayload LocalTablePayload) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OneWayLocal_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OneWayLocal_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_LocalTablePayloadTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::OneWayLocal(&_encoder, &LocalTablePayload), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
MainProtocol_TwoWayLocal_ResponseHandler(MainProtocol::TwoWayLocalCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for MainProtocol::TwoWayLocal\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::protocollayouts::LocalTablePayload>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::protocollayouts::_internal::test_protocollayouts_LocalTablePayloadTable);
}

}  // namespace
void MainProtocol_Proxy::TwoWayLocal(::test::protocollayouts::LocalUnionPayload LocalUnionPayload, TwoWayLocalCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayLocal_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayLocal_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_LocalUnionPayloadTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayLocal(&_encoder, &LocalUnionPayload), MainProtocol_TwoWayLocal_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
MainProtocol_TwoWayLocalWithError_ResponseHandler(MainProtocol::TwoWayLocalWithErrorCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for MainProtocol::TwoWayLocalWithError\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayLocalWithErrorTopResponseTable);
}

}  // namespace
void MainProtocol_Proxy::TwoWayLocalWithError(::test::protocollayouts::LocalTablePayload LocalTablePayload, TwoWayLocalWithErrorCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayLocalWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayLocalWithError_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_LocalTablePayloadTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayLocalWithError(&_encoder, &LocalTablePayload), MainProtocol_TwoWayLocalWithError_ResponseHandler(std::move(callback)));
}
void MainProtocol_Proxy::OneWayAnon(::test::protocollayouts::MainProtocolOneWayAnonRequest MainProtocolOneWayAnonRequest) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OneWayAnon_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OneWayAnon_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOneWayAnonRequestTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::OneWayAnon(&_encoder, &MainProtocolOneWayAnonRequest), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
MainProtocol_TwoWayAnon_ResponseHandler(MainProtocol::TwoWayAnonCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for MainProtocol::TwoWayAnon\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::protocollayouts::MainProtocolTwoWayAnonResponse>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonResponseTable);
}

}  // namespace
void MainProtocol_Proxy::TwoWayAnon(::test::protocollayouts::MainProtocolTwoWayAnonRequest MainProtocolTwoWayAnonRequest, TwoWayAnonCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayAnon_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayAnon_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonRequestTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayAnon(&_encoder, &MainProtocolTwoWayAnonRequest), MainProtocol_TwoWayAnon_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
MainProtocol_TwoWayAnonWithError_ResponseHandler(MainProtocol::TwoWayAnonWithErrorCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for MainProtocol::TwoWayAnonWithError\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonWithErrorTopResponseTable);
}

}  // namespace
void MainProtocol_Proxy::TwoWayAnonWithError(::test::protocollayouts::MainProtocolTwoWayAnonWithErrorRequest MainProtocolTwoWayAnonWithErrorRequest, TwoWayAnonWithErrorCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayAnonWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonWithError_DynamicFlags);
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonWithErrorRequestTable;
  controller_->Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayAnonWithError(&_encoder, &MainProtocolTwoWayAnonWithErrorRequest), MainProtocol_TwoWayAnonWithError_ResponseHandler(std::move(callback)));
}

MainProtocol_Stub::MainProtocol_Stub(::test::protocollayouts::MainProtocol_Stub::MainProtocol_clazz* impl) : impl_(impl) {
  (void)impl_;
}

MainProtocol_Stub::~MainProtocol_Stub() = default;

namespace {

class MainProtocol_TwoWayAnonComposed_Responder final {
 public:
  MainProtocol_TwoWayAnonComposed_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::protocollayouts::imported::ComposedProtocolTwoWayAnonComposedResponse ComposedProtocolTwoWayAnonComposedResponse) {
    ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposed_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposed_DynamicFlags);
    const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedResponseTable;
    response_.Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::TwoWayAnonComposed(&_encoder, &ComposedProtocolTwoWayAnonComposedResponse));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class MainProtocol_TwoWayAnonComposedWithError_Responder final {
 public:
  MainProtocol_TwoWayAnonComposedWithError_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::protocollayouts::imported::ComposedProtocol_TwoWayAnonComposedWithError_Result result) {
    ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposedWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposedWithError_DynamicFlags);
    const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedWithErrorTopResponseTable;
    response_.Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::TwoWayAnonComposedWithError(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class MainProtocol_TwoWayNamedComposed_Responder final {
 public:
  MainProtocol_TwoWayNamedComposed_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::protocollayouts::imported::ImportTablePayload ImportTablePayload) {
    ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposed_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposed_DynamicFlags);
    const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
    response_.Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::TwoWayNamedComposed(&_encoder, &ImportTablePayload));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class MainProtocol_TwoWayNamedComposedWithError_Responder final {
 public:
  MainProtocol_TwoWayNamedComposedWithError_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::protocollayouts::imported::ComposedProtocol_TwoWayNamedComposedWithError_Result result) {
    ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposedWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposedWithError_DynamicFlags);
    const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayNamedComposedWithErrorTopResponseTable;
    response_.Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::TwoWayNamedComposedWithError(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class MainProtocol_TwoWayImport_Responder final {
 public:
  MainProtocol_TwoWayImport_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::protocollayouts::imported::ImportTablePayload ImportTablePayload) {
    ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayImport_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayImport_DynamicFlags);
    const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
    response_.Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::TwoWayImport(&_encoder, &ImportTablePayload));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class MainProtocol_TwoWayImportWithError_Responder final {
 public:
  MainProtocol_TwoWayImportWithError_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result result) {
    ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayImportWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayImportWithError_DynamicFlags);
    const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayImportWithErrorTopResponseTable;
    response_.Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::TwoWayImportWithError(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class MainProtocol_TwoWayLocal_Responder final {
 public:
  MainProtocol_TwoWayLocal_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::protocollayouts::LocalTablePayload LocalTablePayload) {
    ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayLocal_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayLocal_DynamicFlags);
    const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_LocalTablePayloadTable;
    response_.Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::TwoWayLocal(&_encoder, &LocalTablePayload));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class MainProtocol_TwoWayLocalWithError_Responder final {
 public:
  MainProtocol_TwoWayLocalWithError_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result result) {
    ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayLocalWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayLocalWithError_DynamicFlags);
    const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayLocalWithErrorTopResponseTable;
    response_.Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::TwoWayLocalWithError(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class MainProtocol_TwoWayAnon_Responder final {
 public:
  MainProtocol_TwoWayAnon_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::protocollayouts::MainProtocolTwoWayAnonResponse MainProtocolTwoWayAnonResponse) {
    ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayAnon_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayAnon_DynamicFlags);
    const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonResponseTable;
    response_.Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::TwoWayAnon(&_encoder, &MainProtocolTwoWayAnonResponse));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class MainProtocol_TwoWayAnonWithError_Responder final {
 public:
  MainProtocol_TwoWayAnonWithError_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result result) {
    ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayAnonWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonWithError_DynamicFlags);
    const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonWithErrorTopResponseTable;
    response_.Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::TwoWayAnonWithError(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

}  // namespace

zx_status_t MainProtocol_Stub::Dispatch_(
    ::fidl::HLCPPIncomingMessage message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  bool is_known;
  const fidl_type_t* request_type = ::test::protocollayouts::MainProtocol_RequestDecoder::GetType(message.ordinal(), &needs_response, &is_known);

  if (!is_known) {
    return ZX_ERR_NOT_SUPPORTED;
  }

  if (!message.has_only_header()) {
    if (request_type == nullptr) {
      return ZX_ERR_NOT_SUPPORTED;
    }
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(request_type, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
      return status;
    }
  }

  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type, "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }

  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case ::test::protocollayouts::internal::kMainProtocol_OneWayAnonComposed_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayAnonComposed(::fidl::DecodeAs<::test::protocollayouts::imported::ComposedProtocolOneWayAnonComposedRequest>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposed_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayAnonComposed(::fidl::DecodeAs<::test::protocollayouts::imported::ComposedProtocolTwoWayAnonComposedRequest>(&decoder, 0 + sizeof(fidl_message_header_t)), MainProtocol_TwoWayAnonComposed_Responder(std::move(response)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposedWithError_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayAnonComposedWithError(::fidl::DecodeAs<::test::protocollayouts::imported::ComposedProtocolTwoWayAnonComposedWithErrorRequest>(&decoder, 0 + sizeof(fidl_message_header_t)), MainProtocol_TwoWayAnonComposedWithError_Responder(std::move(response)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_OneWayNamedComposed_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayNamedComposed(::fidl::DecodeAs<::test::protocollayouts::imported::ImportTablePayload>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposed_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayNamedComposed(::fidl::DecodeAs<::test::protocollayouts::imported::ImportUnionPayload>(&decoder, 0 + sizeof(fidl_message_header_t)), MainProtocol_TwoWayNamedComposed_Responder(std::move(response)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposedWithError_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayNamedComposedWithError(::fidl::DecodeAs<::test::protocollayouts::imported::ImportTablePayload>(&decoder, 0 + sizeof(fidl_message_header_t)), MainProtocol_TwoWayNamedComposedWithError_Responder(std::move(response)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_OneWayImport_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayImport(::fidl::DecodeAs<::test::protocollayouts::imported::ImportTablePayload>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayImport_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayImport(::fidl::DecodeAs<::test::protocollayouts::imported::ImportUnionPayload>(&decoder, 0 + sizeof(fidl_message_header_t)), MainProtocol_TwoWayImport_Responder(std::move(response)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayImportWithError_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayImportWithError(::fidl::DecodeAs<::test::protocollayouts::imported::ImportTablePayload>(&decoder, 0 + sizeof(fidl_message_header_t)), MainProtocol_TwoWayImportWithError_Responder(std::move(response)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_OneWayLocal_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayLocal(::fidl::DecodeAs<::test::protocollayouts::LocalTablePayload>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayLocal_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayLocal(::fidl::DecodeAs<::test::protocollayouts::LocalUnionPayload>(&decoder, 0 + sizeof(fidl_message_header_t)), MainProtocol_TwoWayLocal_Responder(std::move(response)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayLocalWithError_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayLocalWithError(::fidl::DecodeAs<::test::protocollayouts::LocalTablePayload>(&decoder, 0 + sizeof(fidl_message_header_t)), MainProtocol_TwoWayLocalWithError_Responder(std::move(response)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_OneWayAnon_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayAnon(::fidl::DecodeAs<::test::protocollayouts::MainProtocolOneWayAnonRequest>(&decoder, 0 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayAnon_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayAnon(::fidl::DecodeAs<::test::protocollayouts::MainProtocolTwoWayAnonRequest>(&decoder, 0 + sizeof(fidl_message_header_t)), MainProtocol_TwoWayAnon_Responder(std::move(response)));
      break;
    }
    case ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonWithError_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayAnonWithError(::fidl::DecodeAs<::test::protocollayouts::MainProtocolTwoWayAnonWithErrorRequest>(&decoder, 0 + sizeof(fidl_message_header_t)), MainProtocol_TwoWayAnonWithError_Responder(std::move(response)));
      break;
    }
    default: {
      // Unknown ordinals are handled at the beginning of dispatching, so this
      // should be unreachable.
      ZX_PANIC("Unreachable: unknown ordinals handled earlier.");
    }
  }
  return ZX_OK;
}
void MainProtocol_Stub::OnAnonComposed(::test::protocollayouts::imported::ComposedProtocolOnAnonComposedRequest ComposedProtocolOnAnonComposedRequest) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OnAnonComposed_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OnAnonComposed_DynamicFlags);
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOnAnonComposedRequestTable;sender_()->Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::OnAnonComposed(&_encoder, &ComposedProtocolOnAnonComposedRequest));
}
void MainProtocol_Stub::OnAnonComposedWithError(::test::protocollayouts::imported::ComposedProtocol_OnAnonComposedWithError_Result result) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OnAnonComposedWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OnAnonComposedWithError_DynamicFlags);
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOnAnonComposedWithErrorRequestTable;sender_()->Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::OnAnonComposedWithError(&_encoder, &result));
}
void MainProtocol_Stub::OnNamedComposed(::test::protocollayouts::imported::ImportUnionPayload ImportUnionPayload) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OnNamedComposed_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OnNamedComposed_DynamicFlags);
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable;sender_()->Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::OnNamedComposed(&_encoder, &ImportUnionPayload));
}
void MainProtocol_Stub::OnNamedComposedWithError(::test::protocollayouts::imported::ComposedProtocol_OnNamedComposedWithError_Result result) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OnNamedComposedWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OnNamedComposedWithError_DynamicFlags);
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOnNamedComposedWithErrorRequestTable;sender_()->Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::OnNamedComposedWithError(&_encoder, &result));
}
void MainProtocol_Stub::OnImport(::test::protocollayouts::imported::ImportUnionPayload ImportUnionPayload) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OnImport_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OnImport_DynamicFlags);
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable;sender_()->Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::OnImport(&_encoder, &ImportUnionPayload));
}
void MainProtocol_Stub::OnImportWithError(::test::protocollayouts::MainProtocol_OnImportWithError_Result result) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OnImportWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OnImportWithError_DynamicFlags);
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnImportWithErrorRequestTable;sender_()->Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::OnImportWithError(&_encoder, &result));
}
void MainProtocol_Stub::OnLocal(::test::protocollayouts::LocalUnionPayload LocalUnionPayload) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OnLocal_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OnLocal_DynamicFlags);
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_LocalUnionPayloadTable;sender_()->Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::OnLocal(&_encoder, &LocalUnionPayload));
}
void MainProtocol_Stub::OnLocalWithError(::test::protocollayouts::MainProtocol_OnLocalWithError_Result result) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OnLocalWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OnLocalWithError_DynamicFlags);
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnLocalWithErrorRequestTable;sender_()->Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::OnLocalWithError(&_encoder, &result));
}
void MainProtocol_Stub::OnAnon(::test::protocollayouts::MainProtocolOnAnonRequest MainProtocolOnAnonRequest) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OnAnon_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OnAnon_DynamicFlags);
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnAnonRequestTable;sender_()->Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::OnAnon(&_encoder, &MainProtocolOnAnonRequest));
}
void MainProtocol_Stub::OnAnonWithError(::test::protocollayouts::MainProtocol_OnAnonWithError_Result result) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OnAnonWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OnAnonWithError_DynamicFlags);
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOnAnonWithErrorRequestTable;sender_()->Send(resp_type, ::test::protocollayouts::MainProtocol_ResponseEncoder::OnAnonWithError(&_encoder, &result));
}

MainProtocol_SyncProxy::MainProtocol_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

MainProtocol_SyncProxy::~MainProtocol_SyncProxy() = default;

zx_status_t MainProtocol_SyncProxy::OneWayAnonComposed(::test::protocollayouts::imported::ComposedProtocolOneWayAnonComposedRequest ComposedProtocolOneWayAnonComposedRequest) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OneWayAnonComposed_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OneWayAnonComposed_DynamicFlags);
    const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolOneWayAnonComposedRequestTable;
  return proxy_.Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::OneWayAnonComposed(&_encoder, &ComposedProtocolOneWayAnonComposedRequest));
}

zx_status_t MainProtocol_SyncProxy::TwoWayAnonComposed(::test::protocollayouts::imported::ComposedProtocolTwoWayAnonComposedRequest ComposedProtocolTwoWayAnonComposedRequest, ::test::protocollayouts::imported::ComposedProtocolTwoWayAnonComposedResponse* out_ComposedProtocolTwoWayAnonComposedResponse) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposed_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposed_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedRequestTable;
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayAnonComposed(&_encoder, &ComposedProtocolTwoWayAnonComposedRequest), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_ComposedProtocolTwoWayAnonComposedResponse = ::fidl::DecodeAs<::test::protocollayouts::imported::ComposedProtocolTwoWayAnonComposedResponse>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t MainProtocol_SyncProxy::TwoWayAnonComposedWithError(::test::protocollayouts::imported::ComposedProtocolTwoWayAnonComposedWithErrorRequest ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::test::protocollayouts::imported::ComposedProtocol_TwoWayAnonComposedWithError_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposedWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonComposedWithError_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedWithErrorRequestTable;
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayAnonComposedWithErrorTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayAnonComposedWithError(&_encoder, &ComposedProtocolTwoWayAnonComposedWithErrorRequest), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::protocollayouts::imported::ComposedProtocol_TwoWayAnonComposedWithError_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t MainProtocol_SyncProxy::OneWayNamedComposed(::test::protocollayouts::imported::ImportTablePayload ImportTablePayload) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OneWayNamedComposed_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OneWayNamedComposed_DynamicFlags);
    const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
  return proxy_.Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::OneWayNamedComposed(&_encoder, &ImportTablePayload));
}

zx_status_t MainProtocol_SyncProxy::TwoWayNamedComposed(::test::protocollayouts::imported::ImportUnionPayload ImportUnionPayload, ::test::protocollayouts::imported::ImportTablePayload* out_ImportTablePayload) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposed_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposed_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable;
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayNamedComposed(&_encoder, &ImportUnionPayload), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_ImportTablePayload = ::fidl::DecodeAs<::test::protocollayouts::imported::ImportTablePayload>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t MainProtocol_SyncProxy::TwoWayNamedComposedWithError(::test::protocollayouts::imported::ImportTablePayload ImportTablePayload, ::test::protocollayouts::imported::ComposedProtocol_TwoWayNamedComposedWithError_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposedWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayNamedComposedWithError_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ComposedProtocolTwoWayNamedComposedWithErrorTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayNamedComposedWithError(&_encoder, &ImportTablePayload), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::protocollayouts::imported::ComposedProtocol_TwoWayNamedComposedWithError_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t MainProtocol_SyncProxy::OneWayImport(::test::protocollayouts::imported::ImportTablePayload ImportTablePayload) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OneWayImport_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OneWayImport_DynamicFlags);
    const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
  return proxy_.Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::OneWayImport(&_encoder, &ImportTablePayload));
}

zx_status_t MainProtocol_SyncProxy::TwoWayImport(::test::protocollayouts::imported::ImportUnionPayload ImportUnionPayload, ::test::protocollayouts::imported::ImportTablePayload* out_ImportTablePayload) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayImport_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayImport_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportUnionPayloadTable;
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayImport(&_encoder, &ImportUnionPayload), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_ImportTablePayload = ::fidl::DecodeAs<::test::protocollayouts::imported::ImportTablePayload>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t MainProtocol_SyncProxy::TwoWayImportWithError(::test::protocollayouts::imported::ImportTablePayload ImportTablePayload, ::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayImportWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayImportWithError_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_imported_ImportTablePayloadTable;
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayImportWithErrorTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayImportWithError(&_encoder, &ImportTablePayload), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::protocollayouts::MainProtocol_TwoWayImportWithError_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t MainProtocol_SyncProxy::OneWayLocal(::test::protocollayouts::LocalTablePayload LocalTablePayload) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OneWayLocal_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OneWayLocal_DynamicFlags);
    const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_LocalTablePayloadTable;
  return proxy_.Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::OneWayLocal(&_encoder, &LocalTablePayload));
}

zx_status_t MainProtocol_SyncProxy::TwoWayLocal(::test::protocollayouts::LocalUnionPayload LocalUnionPayload, ::test::protocollayouts::LocalTablePayload* out_LocalTablePayload) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayLocal_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayLocal_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_LocalUnionPayloadTable;
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_LocalTablePayloadTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayLocal(&_encoder, &LocalUnionPayload), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_LocalTablePayload = ::fidl::DecodeAs<::test::protocollayouts::LocalTablePayload>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t MainProtocol_SyncProxy::TwoWayLocalWithError(::test::protocollayouts::LocalTablePayload LocalTablePayload, ::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayLocalWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayLocalWithError_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_LocalTablePayloadTable;
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayLocalWithErrorTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayLocalWithError(&_encoder, &LocalTablePayload), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::protocollayouts::MainProtocol_TwoWayLocalWithError_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t MainProtocol_SyncProxy::OneWayAnon(::test::protocollayouts::MainProtocolOneWayAnonRequest MainProtocolOneWayAnonRequest) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_OneWayAnon_Ordinal, ::test::protocollayouts::internal::kMainProtocol_OneWayAnon_DynamicFlags);
    const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolOneWayAnonRequestTable;
  return proxy_.Send(req_type, ::test::protocollayouts::MainProtocol_RequestEncoder::OneWayAnon(&_encoder, &MainProtocolOneWayAnonRequest));
}

zx_status_t MainProtocol_SyncProxy::TwoWayAnon(::test::protocollayouts::MainProtocolTwoWayAnonRequest MainProtocolTwoWayAnonRequest, ::test::protocollayouts::MainProtocolTwoWayAnonResponse* out_MainProtocolTwoWayAnonResponse) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayAnon_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayAnon_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonRequestTable;
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayAnon(&_encoder, &MainProtocolTwoWayAnonRequest), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_MainProtocolTwoWayAnonResponse = ::fidl::DecodeAs<::test::protocollayouts::MainProtocolTwoWayAnonResponse>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t MainProtocol_SyncProxy::TwoWayAnonWithError(::test::protocollayouts::MainProtocolTwoWayAnonWithErrorRequest MainProtocolTwoWayAnonWithErrorRequest, ::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::protocollayouts::internal::kMainProtocol_TwoWayAnonWithError_Ordinal, ::test::protocollayouts::internal::kMainProtocol_TwoWayAnonWithError_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonWithErrorRequestTable;
  const fidl_type_t* resp_type =&::test::protocollayouts::_internal::test_protocollayouts_MainProtocolTwoWayAnonWithErrorTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::protocollayouts::MainProtocol_RequestEncoder::TwoWayAnonWithError(&_encoder, &MainProtocolTwoWayAnonWithErrorRequest), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::protocollayouts::MainProtocol_TwoWayAnonWithError_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

#endif  // __Fuchsia__


}  // namespace protocollayouts
}  // namespace test


