// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include "lib/fidl/cpp/internal/header.h"

namespace test {
namespace typesinprotocols {


//
// Domain objects declarations
//


// |Bits| is flexible, hence may contain unknown members not
// defined in the FIDL schema.
class Bits final {
public:
  constexpr Bits() = default;

  // Constructs an instance of |Bits| from an underlying primitive value
  // if the primitive does not contain any unknown members not defined in the
  // FIDL schema. Otherwise, returns |cpp17::nullopt|.
  constexpr inline static cpp17::optional<Bits> TryFrom(uint32_t value) {
    if (value & ~kMask.value_) {
      return cpp17::nullopt;
    }
    return Bits(value & Bits::kMask.value_);
  }

  // Constructs an instance of |Bits| from an underlying primitive value,
  // clearing any bit member not defined in the FIDL schema.
  constexpr inline static Bits TruncatingUnknown(uint32_t value) {
    return Bits(value & Bits::kMask.value_);
  }

  // Constructs an instance of |Bits| from an underlying primitive value,
  // preserving any bit member not defined in the FIDL schema.
  constexpr explicit Bits(uint32_t value) : value_(value) {}
  const static Bits VAL;
  const static Bits kMask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const Bits& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const Bits& other) const { return value_ != other.value_; }
  constexpr inline Bits operator~() const;
  constexpr inline Bits operator|(const Bits& other) const;
  constexpr inline Bits operator&(const Bits& other) const;
  constexpr inline Bits operator^(const Bits& other) const;
  constexpr inline void operator|=(const Bits& other);
  constexpr inline void operator&=(const Bits& other);
  constexpr inline void operator^=(const Bits& other);
  constexpr inline Bits unknown_bits() const {
    return *this & Bits(~kMask.value_);
  }
  constexpr inline bool has_unknown_bits() const { return static_cast<bool>(unknown_bits()); }

private:
  uint32_t value_ = 0;
};

#if !(__cplusplus < 201703)
constexpr const ::test::typesinprotocols::Bits Bits::VAL = ::test::typesinprotocols::Bits(1u);
constexpr const ::test::typesinprotocols::Bits Bits::kMask = ::test::typesinprotocols::Bits(1u);

#endif  // !(__cplusplus < 201703)

constexpr inline ::test::typesinprotocols::Bits Bits::operator~() const {
  return ::test::typesinprotocols::Bits(static_cast<uint32_t>(~this->value_ & kMask.value_));
}

constexpr inline ::test::typesinprotocols::Bits Bits::operator|(
    const ::test::typesinprotocols::Bits& other) const {
  return ::test::typesinprotocols::Bits(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::test::typesinprotocols::Bits Bits::operator&(
    const ::test::typesinprotocols::Bits& other) const {
  return ::test::typesinprotocols::Bits(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::test::typesinprotocols::Bits Bits::operator^(
    const ::test::typesinprotocols::Bits& other) const {
  return ::test::typesinprotocols::Bits(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void Bits::operator|=(
    const ::test::typesinprotocols::Bits& other) {
  this->value_ |= other.value_;
}

constexpr inline void Bits::operator&=(
    const ::test::typesinprotocols::Bits& other) {
  this->value_ &= other.value_;
}

constexpr inline void Bits::operator^=(
    const ::test::typesinprotocols::Bits& other) {
  this->value_ ^= other.value_;
}

inline zx_status_t Clone(::test::typesinprotocols::Bits value,
                         ::test::typesinprotocols::Bits* result) {
  *result = value;
  return ZX_OK;
}




class Enum final {
public:
  constexpr Enum() : value_(0) {}
  constexpr explicit Enum(uint32_t value) : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    
    switch (value_) {
      
      
    case 1u:
      
      
      return false;
    }
    return true;
  }

  constexpr static Enum Unknown() {
    return Enum(0xffffffff);
  }
    
    static const Enum VAL;

private:
  uint32_t value_;
};

#if !(__cplusplus < 201703)
constexpr const ::test::typesinprotocols::Enum Enum::VAL = ::test::typesinprotocols::Enum(1u);
#endif  // !(__cplusplus < 201703)



inline zx_status_t Clone(::test::typesinprotocols::Enum value,
                         ::test::typesinprotocols::Enum* result) {
  *result = value;
  return ZX_OK;
}



class Struct;


class Table;


class Union;


class ResourceStruct;


class ResourceTable;


class ResourceUnion;


class Basic;


class Compound;


class ArrayBasic;


class ArrayCompound;


class VectorBasic;


class VectorCompound;


class VectorOptional;


class ArrayVectorNested;


class Resource;


#ifdef __Fuchsia__

class Protocol;
using ProtocolHandle = ::fidl::InterfaceHandle<Protocol>;

#endif  // __Fuchsia__




class Struct final {
 public:
  static const fidl_type_t* FidlType;
  
  uint8_t __reserved= 0u;

  static inline ::std::unique_ptr<Struct> New() { return ::std::make_unique<Struct>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, Struct* value, size_t _offset);
  zx_status_t Clone(Struct* result) const;
};

inline zx_status_t Clone(const ::test::typesinprotocols::Struct& _value,
                         ::test::typesinprotocols::Struct* _result) {
  return _value.Clone(_result);
}

using StructPtr = ::std::unique_ptr<Struct>;



class Table final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;

  Table();
  Table(Table&& other);
  ~Table();
  Table& operator=(Table&& other);

  static inline ::std::unique_ptr<Table> New() { return ::std::make_unique<Table>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, Table* _value, size_t _offset);
  zx_status_t Clone(Table* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<0> field_presence_;
};

using TablePtr = ::std::unique_ptr<Table>;



class Union final {
 public:
  static const fidl_type_t* FidlType;

  Union();
  ~Union();

  Union(Union&&);
  Union& operator=(Union&&);

  
  static Union WithB(bool&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kB = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<Union> New() { return ::std::make_unique<Union>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, Union* value, size_t offset);
  zx_status_t Clone(Union* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_b() const { return tag_ == ::test::typesinprotocols::Union::Tag::kB; }
  
  bool& b() {
    EnsureStorageInitialized(::test::typesinprotocols::Union::Tag::kB);
    return b_;
  }
  
  const bool& b() const {
    ZX_ASSERT(is_b());
    return b_;
  }
  Union& set_b(bool value);
  Union& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::typesinprotocols::Union::Tag Which() const {
    
    switch (tag_) {
      case ::test::typesinprotocols::Union::Tag::Invalid:
      case ::test::typesinprotocols::Union::Tag::kB:
        return ::test::typesinprotocols::Union::Tag(tag_);
      default:
        return ::test::typesinprotocols::Union::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::typesinprotocols::Union::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::typesinprotocols::Union>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Union::Tag::Invalid);
  union {
    bool b_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::typesinprotocols::Union& value,
                         ::test::typesinprotocols::Union* result) {
  return value.Clone(result);
}

using UnionPtr = ::std::unique_ptr<Union>;



#ifdef __Fuchsia__

class ResourceStruct final {
 public:
  static const fidl_type_t* FidlType;
  
  uint8_t __reserved= 0u;

  static inline ::std::unique_ptr<ResourceStruct> New() { return ::std::make_unique<ResourceStruct>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, ResourceStruct* value, size_t _offset);
  zx_status_t Clone(ResourceStruct* result) const;
};

inline zx_status_t Clone(const ::test::typesinprotocols::ResourceStruct& _value,
                         ::test::typesinprotocols::ResourceStruct* _result) {
  return _value.Clone(_result);
}

using ResourceStructPtr = ::std::unique_ptr<ResourceStruct>;

#endif  // __Fuchsia__




#ifdef __Fuchsia__

class ResourceTable final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;

  ResourceTable();
  ResourceTable(ResourceTable&& other);
  ~ResourceTable();
  ResourceTable& operator=(ResourceTable&& other);

  static inline ::std::unique_ptr<ResourceTable> New() { return ::std::make_unique<ResourceTable>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, ResourceTable* _value, size_t _offset);
  zx_status_t Clone(ResourceTable* _result) const;
 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
      return true;
    default:
      return false;
    }
  }

  ::fidl::internal::BitSet<0> field_presence_;
};

using ResourceTablePtr = ::std::unique_ptr<ResourceTable>;

#endif  // __Fuchsia__




#ifdef __Fuchsia__

class ResourceUnion final {
 public:
  static const fidl_type_t* FidlType;

  ResourceUnion();
  ~ResourceUnion();

  ResourceUnion(ResourceUnion&&);
  ResourceUnion& operator=(ResourceUnion&&);

  
  static ResourceUnion WithB(bool&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
  kUnknown = 0,
  
    kB = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<ResourceUnion> New() { return ::std::make_unique<ResourceUnion>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, ResourceUnion* value, size_t offset);
  zx_status_t Clone(ResourceUnion* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_b() const { return tag_ == ::test::typesinprotocols::ResourceUnion::Tag::kB; }
  
  bool& b() {
    EnsureStorageInitialized(::test::typesinprotocols::ResourceUnion::Tag::kB);
    return b_;
  }
  
  const bool& b() const {
    ZX_ASSERT(is_b());
    return b_;
  }
  ResourceUnion& set_b(bool value);
  ResourceUnion& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes, std::vector<zx::handle> handles);

  ::test::typesinprotocols::ResourceUnion::Tag Which() const {
    
    switch (tag_) {
      case ::test::typesinprotocols::ResourceUnion::Tag::Invalid:
      case ::test::typesinprotocols::ResourceUnion::Tag::kB:
        return ::test::typesinprotocols::ResourceUnion::Tag(tag_);
      default:
        return ::test::typesinprotocols::ResourceUnion::Tag::kUnknown;
    }
    
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::typesinprotocols::ResourceUnion::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_.bytes;
  }
  const std::vector<zx::handle>* UnknownHandles() const {
    if (Which() != ::test::typesinprotocols::ResourceUnion::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_.handles;
  }

  friend ::fidl::Equality<::test::typesinprotocols::ResourceUnion>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::ResourceUnion::Tag::Invalid);
  union {
    bool b_;
    ::fidl::UnknownData unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::typesinprotocols::ResourceUnion& value,
                         ::test::typesinprotocols::ResourceUnion* result) {
  return value.Clone(result);
}

using ResourceUnionPtr = ::std::unique_ptr<ResourceUnion>;

#endif  // __Fuchsia__




class Basic final {
 public:
  static const fidl_type_t* FidlType;
  
  uint8_t uint8{};
  
  uint16_t uint16{};
  
  uint32_t uint32{};
  
  uint64_t uint64{};
  
  int8_t int8{};
  
  int16_t int16{};
  
  int32_t int32{};
  
  int64_t int64{};
  
  float float32{};
  
  double float64{};
  
  ::std::string string;
  
  ::fidl::StringPtr opt_string;

  static inline ::std::unique_ptr<Basic> New() { return ::std::make_unique<Basic>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, Basic* value, size_t _offset);
  zx_status_t Clone(Basic* result) const;
};

inline zx_status_t Clone(const ::test::typesinprotocols::Basic& _value,
                         ::test::typesinprotocols::Basic* _result) {
  return _value.Clone(_result);
}

using BasicPtr = ::std::unique_ptr<Basic>;



class Compound final {
 public:
  static const fidl_type_t* FidlType;
  
  ::test::typesinprotocols::Bits bits{};
  
  ::test::typesinprotocols::Enum enum_{};
  
  ::test::typesinprotocols::Struct struct_;
  
  ::test::typesinprotocols::Table table;
  
  ::test::typesinprotocols::Union union_;
  
  ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct;
  
  ::std::unique_ptr<::test::typesinprotocols::Union> opt_union;

  static inline ::std::unique_ptr<Compound> New() { return ::std::make_unique<Compound>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, Compound* value, size_t _offset);
  zx_status_t Clone(Compound* result) const;
};

inline zx_status_t Clone(const ::test::typesinprotocols::Compound& _value,
                         ::test::typesinprotocols::Compound* _result) {
  return _value.Clone(_result);
}

using CompoundPtr = ::std::unique_ptr<Compound>;



class ArrayBasic final {
 public:
  static const fidl_type_t* FidlType;
  
  ::std::array<uint8_t, 5> array_uint8{};
  
  ::std::array<uint16_t, 5> array_uint16{};
  
  ::std::array<uint32_t, 5> array_uint32{};
  
  ::std::array<uint64_t, 5> array_uint64{};
  
  ::std::array<int8_t, 5> array_int8{};
  
  ::std::array<int16_t, 5> array_int16{};
  
  ::std::array<int32_t, 5> array_int32{};
  
  ::std::array<int64_t, 5> array_int64{};
  
  ::std::array<float, 5> array_float32{};
  
  ::std::array<double, 5> array_float64{};
  
  ::std::array<::std::string, 5> array_string{};
  
  ::std::array<::fidl::StringPtr, 5> array_opt_string{};

  static inline ::std::unique_ptr<ArrayBasic> New() { return ::std::make_unique<ArrayBasic>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, ArrayBasic* value, size_t _offset);
  zx_status_t Clone(ArrayBasic* result) const;
};

inline zx_status_t Clone(const ::test::typesinprotocols::ArrayBasic& _value,
                         ::test::typesinprotocols::ArrayBasic* _result) {
  return _value.Clone(_result);
}

using ArrayBasicPtr = ::std::unique_ptr<ArrayBasic>;



class ArrayCompound final {
 public:
  static const fidl_type_t* FidlType;
  
  ::std::array<::test::typesinprotocols::Bits, 5> array_bits{};
  
  ::std::array<::test::typesinprotocols::Enum, 5> array_enum{};
  
  ::std::array<::test::typesinprotocols::Struct, 5> array_struct{};
  
  ::std::array<::test::typesinprotocols::Table, 5> array_table{};
  
  ::std::array<::test::typesinprotocols::Union, 5> array_union{};
  
  ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct{};
  
  ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union{};

  static inline ::std::unique_ptr<ArrayCompound> New() { return ::std::make_unique<ArrayCompound>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, ArrayCompound* value, size_t _offset);
  zx_status_t Clone(ArrayCompound* result) const;
};

inline zx_status_t Clone(const ::test::typesinprotocols::ArrayCompound& _value,
                         ::test::typesinprotocols::ArrayCompound* _result) {
  return _value.Clone(_result);
}

using ArrayCompoundPtr = ::std::unique_ptr<ArrayCompound>;



class VectorBasic final {
 public:
  static const fidl_type_t* FidlType;
  
  ::std::vector<uint8_t> vector_uint8;
  
  ::std::vector<uint16_t> vector_uint16;
  
  ::std::vector<uint32_t> vector_uint32;
  
  ::std::vector<uint64_t> vector_uint64;
  
  ::std::vector<int8_t> vector_int8;
  
  ::std::vector<int16_t> vector_int16;
  
  ::std::vector<int32_t> vector_int32;
  
  ::std::vector<int64_t> vector_int64;
  
  ::std::vector<float> vector_float32;
  
  ::std::vector<double> vector_float64;
  
  ::std::vector<::std::string> vector_string;
  
  ::std::vector<::fidl::StringPtr> vector_opt_string;

  static inline ::std::unique_ptr<VectorBasic> New() { return ::std::make_unique<VectorBasic>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, VectorBasic* value, size_t _offset);
  zx_status_t Clone(VectorBasic* result) const;
};

inline zx_status_t Clone(const ::test::typesinprotocols::VectorBasic& _value,
                         ::test::typesinprotocols::VectorBasic* _result) {
  return _value.Clone(_result);
}

using VectorBasicPtr = ::std::unique_ptr<VectorBasic>;



class VectorCompound final {
 public:
  static const fidl_type_t* FidlType;
  
  ::std::vector<::test::typesinprotocols::Bits> vector_bits;
  
  ::std::vector<::test::typesinprotocols::Enum> vector_enum;
  
  ::std::vector<::test::typesinprotocols::Struct> vector_struct;
  
  ::std::vector<::test::typesinprotocols::Table> vector_table;
  
  ::std::vector<::test::typesinprotocols::Union> vector_union;
  
  ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct;
  
  ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union;

  static inline ::std::unique_ptr<VectorCompound> New() { return ::std::make_unique<VectorCompound>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, VectorCompound* value, size_t _offset);
  zx_status_t Clone(VectorCompound* result) const;
};

inline zx_status_t Clone(const ::test::typesinprotocols::VectorCompound& _value,
                         ::test::typesinprotocols::VectorCompound* _result) {
  return _value.Clone(_result);
}

using VectorCompoundPtr = ::std::unique_ptr<VectorCompound>;



class VectorOptional final {
 public:
  static const fidl_type_t* FidlType;
  
  ::fidl::VectorPtr<uint8_t> opt_vector_uint8;
  
  ::fidl::VectorPtr<::std::string> opt_vector_string;
  
  ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct;

  static inline ::std::unique_ptr<VectorOptional> New() { return ::std::make_unique<VectorOptional>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, VectorOptional* value, size_t _offset);
  zx_status_t Clone(VectorOptional* result) const;
};

inline zx_status_t Clone(const ::test::typesinprotocols::VectorOptional& _value,
                         ::test::typesinprotocols::VectorOptional* _result) {
  return _value.Clone(_result);
}

using VectorOptionalPtr = ::std::unique_ptr<VectorOptional>;



class ArrayVectorNested final {
 public:
  static const fidl_type_t* FidlType;
  
  ::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8{};
  
  ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8{};
  
  ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8;
  
  ::std::vector<::std::vector<uint8_t>> vector_vector_uint8;

  static inline ::std::unique_ptr<ArrayVectorNested> New() { return ::std::make_unique<ArrayVectorNested>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, ArrayVectorNested* value, size_t _offset);
  zx_status_t Clone(ArrayVectorNested* result) const;
};

inline zx_status_t Clone(const ::test::typesinprotocols::ArrayVectorNested& _value,
                         ::test::typesinprotocols::ArrayVectorNested* _result) {
  return _value.Clone(_result);
}

using ArrayVectorNestedPtr = ::std::unique_ptr<ArrayVectorNested>;



#ifdef __Fuchsia__

class Resource final {
 public:
  static const fidl_type_t* FidlType;
  
  ::zx::handle handle;
  
  ::zx::vmo vmo;
  
  ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end;
  
  ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end;
  
  ::test::typesinprotocols::ResourceStruct struct_;
  
  ::test::typesinprotocols::ResourceTable table;
  
  ::test::typesinprotocols::ResourceUnion union_;
  
  ::zx::handle opt_handle;
  
  ::zx::vmo opt_vmo;
  
  ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end;
  
  ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end;
  
  ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct;
  
  ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union;
  
  ::std::array<::zx::handle, 5> array_handle{};
  
  ::std::array<::zx::vmo, 5> array_vmo{};
  
  ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end{};
  
  ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end{};
  
  ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct{};
  
  ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table{};
  
  ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union{};
  
  ::std::vector<::zx::handle> vector_handle;
  
  ::std::vector<::zx::vmo> vector_vmo;
  
  ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end;
  
  ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end;
  
  ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct;
  
  ::std::vector<::test::typesinprotocols::ResourceTable> vector_table;
  
  ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union;

  static inline ::std::unique_ptr<Resource> New() { return ::std::make_unique<Resource>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
               cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, Resource* value, size_t _offset);
  zx_status_t Clone(Resource* result) const;
};

inline zx_status_t Clone(const ::test::typesinprotocols::Resource& _value,
                         ::test::typesinprotocols::Resource* _result) {
  return _value.Clone(_result);
}

using ResourcePtr = ::std::unique_ptr<Resource>;

#endif  // __Fuchsia__



#ifdef __Fuchsia__

  namespace _internal {
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_BasicTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_CompoundTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ArrayBasicTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ArrayCompoundTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_VectorBasicTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_VectorCompoundTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_VectorOptionalTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ArrayVectorNestedTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ResourceTable;
  
  

}  // namespace _internal

class Protocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage OneWayBasic(::fidl::MessageEncoder* _encoder, uint8_t* uint8, uint16_t* uint16, uint32_t* uint32, uint64_t* uint64, int8_t* int8, int16_t* int16, int32_t* int32, int64_t* int64, float* float32, double* float64, ::std::string* string, ::fidl::StringPtr* opt_string) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(80);
    ::fidl::Encode(_encoder, uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, uint16, 2 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, uint32, 4 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, uint64, 8 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int8, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int16, 18 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int32, 20 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int64, 24 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, float32, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, float64, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, string, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_string, 64 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayBasic(::fidl::MessageEncoder* _encoder, uint8_t* uint8, uint16_t* uint16, uint32_t* uint32, uint64_t* uint64, int8_t* int8, int16_t* int16, int32_t* int32, int64_t* int64, float* float32, double* float64, ::std::string* string, ::fidl::StringPtr* opt_string) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(80);
    ::fidl::Encode(_encoder, uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, uint16, 2 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, uint32, 4 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, uint64, 8 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int8, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int16, 18 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int32, 20 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int64, 24 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, float32, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, float64, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, string, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_string, 64 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OneWayCompound(::fidl::MessageEncoder* _encoder, ::test::typesinprotocols::Bits* bits, ::test::typesinprotocols::Enum* enum_, ::test::typesinprotocols::Struct* struct_, ::test::typesinprotocols::Table* table, ::test::typesinprotocols::Union* union_, ::std::unique_ptr<::test::typesinprotocols::Struct>* opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union>* opt_union) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(72);
    ::fidl::Encode(_encoder, bits, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, enum_, 4 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, struct_, 8 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, table, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, union_, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_struct, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_union, 56 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayCompound(::fidl::MessageEncoder* _encoder, ::test::typesinprotocols::Bits* bits, ::test::typesinprotocols::Enum* enum_, ::test::typesinprotocols::Struct* struct_, ::test::typesinprotocols::Table* table, ::test::typesinprotocols::Union* union_, ::std::unique_ptr<::test::typesinprotocols::Struct>* opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union>* opt_union) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(72);
    ::fidl::Encode(_encoder, bits, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, enum_, 4 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, struct_, 8 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, table, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, union_, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_struct, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_union, 56 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OneWayArrayBasic(::fidl::MessageEncoder* _encoder, ::std::array<uint8_t, 5>* array_uint8, ::std::array<uint16_t, 5>* array_uint16, ::std::array<uint32_t, 5>* array_uint32, ::std::array<uint64_t, 5>* array_uint64, ::std::array<int8_t, 5>* array_int8, ::std::array<int16_t, 5>* array_int16, ::std::array<int32_t, 5>* array_int32, ::std::array<int64_t, 5>* array_int64, ::std::array<float, 5>* array_float32, ::std::array<double, 5>* array_float64, ::std::array<::std::string, 5>* array_string, ::std::array<::fidl::StringPtr, 5>* array_opt_string) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(384);
    ::fidl::Encode(_encoder, array_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_uint16, 6 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_uint32, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_uint64, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int8, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int16, 86 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int32, 96 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int64, 120 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_float32, 160 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_float64, 184 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_string, 224 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_opt_string, 304 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayArrayBasic(::fidl::MessageEncoder* _encoder, ::std::array<uint8_t, 5>* array_uint8, ::std::array<uint16_t, 5>* array_uint16, ::std::array<uint32_t, 5>* array_uint32, ::std::array<uint64_t, 5>* array_uint64, ::std::array<int8_t, 5>* array_int8, ::std::array<int16_t, 5>* array_int16, ::std::array<int32_t, 5>* array_int32, ::std::array<int64_t, 5>* array_int64, ::std::array<float, 5>* array_float32, ::std::array<double, 5>* array_float64, ::std::array<::std::string, 5>* array_string, ::std::array<::fidl::StringPtr, 5>* array_opt_string) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(384);
    ::fidl::Encode(_encoder, array_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_uint16, 6 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_uint32, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_uint64, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int8, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int16, 86 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int32, 96 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int64, 120 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_float32, 160 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_float64, 184 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_string, 224 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_opt_string, 304 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OneWayArrayCompound(::fidl::MessageEncoder* _encoder, ::std::array<::test::typesinprotocols::Bits, 5>* array_bits, ::std::array<::test::typesinprotocols::Enum, 5>* array_enum, ::std::array<::test::typesinprotocols::Struct, 5>* array_struct, ::std::array<::test::typesinprotocols::Table, 5>* array_table, ::std::array<::test::typesinprotocols::Union, 5>* array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>* array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>* array_opt_union) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(328);
    ::fidl::Encode(_encoder, array_bits, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_enum, 20 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_struct, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_table, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_union, 128 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_opt_struct, 208 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_opt_union, 248 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayArrayCompound(::fidl::MessageEncoder* _encoder, ::std::array<::test::typesinprotocols::Bits, 5>* array_bits, ::std::array<::test::typesinprotocols::Enum, 5>* array_enum, ::std::array<::test::typesinprotocols::Struct, 5>* array_struct, ::std::array<::test::typesinprotocols::Table, 5>* array_table, ::std::array<::test::typesinprotocols::Union, 5>* array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>* array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>* array_opt_union) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(328);
    ::fidl::Encode(_encoder, array_bits, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_enum, 20 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_struct, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_table, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_union, 128 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_opt_struct, 208 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_opt_union, 248 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OneWayVectorBasic(::fidl::MessageEncoder* _encoder, ::std::vector<uint8_t>* vector_uint8, ::std::vector<uint16_t>* vector_uint16, ::std::vector<uint32_t>* vector_uint32, ::std::vector<uint64_t>* vector_uint64, ::std::vector<int8_t>* vector_int8, ::std::vector<int16_t>* vector_int16, ::std::vector<int32_t>* vector_int32, ::std::vector<int64_t>* vector_int64, ::std::vector<float>* vector_float32, ::std::vector<double>* vector_float64, ::std::vector<::std::string>* vector_string, ::std::vector<::fidl::StringPtr>* vector_opt_string) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(192);
    ::fidl::Encode(_encoder, vector_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_uint16, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_uint32, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_uint64, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int8, 64 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int16, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int32, 96 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int64, 112 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_float32, 128 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_float64, 144 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_string, 160 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_opt_string, 176 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayVectorBasic(::fidl::MessageEncoder* _encoder, ::std::vector<uint8_t>* vector_uint8, ::std::vector<uint16_t>* vector_uint16, ::std::vector<uint32_t>* vector_uint32, ::std::vector<uint64_t>* vector_uint64, ::std::vector<int8_t>* vector_int8, ::std::vector<int16_t>* vector_int16, ::std::vector<int32_t>* vector_int32, ::std::vector<int64_t>* vector_int64, ::std::vector<float>* vector_float32, ::std::vector<double>* vector_float64, ::std::vector<::std::string>* vector_string, ::std::vector<::fidl::StringPtr>* vector_opt_string) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(192);
    ::fidl::Encode(_encoder, vector_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_uint16, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_uint32, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_uint64, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int8, 64 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int16, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int32, 96 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int64, 112 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_float32, 128 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_float64, 144 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_string, 160 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_opt_string, 176 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OneWayVectorCompound(::fidl::MessageEncoder* _encoder, ::std::vector<::test::typesinprotocols::Bits>* vector_bits, ::std::vector<::test::typesinprotocols::Enum>* vector_enum, ::std::vector<::test::typesinprotocols::Struct>* vector_struct, ::std::vector<::test::typesinprotocols::Table>* vector_table, ::std::vector<::test::typesinprotocols::Union>* vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>* vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>* vector_opt_union) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(112);
    ::fidl::Encode(_encoder, vector_bits, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_enum, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_struct, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_table, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_union, 64 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_opt_struct, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_opt_union, 96 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayVectorCompound(::fidl::MessageEncoder* _encoder, ::std::vector<::test::typesinprotocols::Bits>* vector_bits, ::std::vector<::test::typesinprotocols::Enum>* vector_enum, ::std::vector<::test::typesinprotocols::Struct>* vector_struct, ::std::vector<::test::typesinprotocols::Table>* vector_table, ::std::vector<::test::typesinprotocols::Union>* vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>* vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>* vector_opt_union) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(112);
    ::fidl::Encode(_encoder, vector_bits, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_enum, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_struct, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_table, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_union, 64 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_opt_struct, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_opt_union, 96 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OneWayVectorOptional(::fidl::MessageEncoder* _encoder, ::fidl::VectorPtr<uint8_t>* opt_vector_uint8, ::fidl::VectorPtr<::std::string>* opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>* opt_vector_opt_struct) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(64);
    ::fidl::Encode(_encoder, opt_vector_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_vector_string, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_vector_opt_struct, 48 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayVectorOptional(::fidl::MessageEncoder* _encoder, ::fidl::VectorPtr<uint8_t>* opt_vector_uint8, ::fidl::VectorPtr<::std::string>* opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>* opt_vector_opt_struct) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(64);
    ::fidl::Encode(_encoder, opt_vector_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_vector_string, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_vector_opt_struct, 48 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OneWayArrayVectorNested(::fidl::MessageEncoder* _encoder, ::std::array<::std::array<uint8_t, 5>, 5>* array_array_uint8, ::std::array<::std::vector<uint8_t>, 5>* array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>>* vector_array_uint8, ::std::vector<::std::vector<uint8_t>>* vector_vector_uint8) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(144);
    ::fidl::Encode(_encoder, array_array_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_vector_uint8, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_array_uint8, 112 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_vector_uint8, 128 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayArrayVectorNested(::fidl::MessageEncoder* _encoder, ::std::array<::std::array<uint8_t, 5>, 5>* array_array_uint8, ::std::array<::std::vector<uint8_t>, 5>* array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>>* vector_array_uint8, ::std::vector<::std::vector<uint8_t>>* vector_vector_uint8) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(144);
    ::fidl::Encode(_encoder, array_array_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_vector_uint8, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_array_uint8, 112 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_vector_uint8, 128 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OneWayResource(::fidl::MessageEncoder* _encoder, ::zx::handle* handle, ::zx::vmo* vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* server_end, ::test::typesinprotocols::ResourceStruct* struct_, ::test::typesinprotocols::ResourceTable* table, ::test::typesinprotocols::ResourceUnion* union_, ::zx::handle* opt_handle, ::zx::vmo* opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct>* opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion>* opt_union, ::std::array<::zx::handle, 5>* array_handle, ::std::array<::zx::vmo, 5>* array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>* array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>* array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5>* array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5>* array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5>* array_union, ::std::vector<::zx::handle>* vector_handle, ::std::vector<::zx::vmo>* vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>* vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>* vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct>* vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable>* vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion>* vector_union) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(456);
    ::fidl::Encode(_encoder, handle, 0 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, vmo, 4 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, client_end, 8 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, server_end, 12 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, struct_, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, table, 24 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, union_, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_handle, 56 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, opt_vmo, 60 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, opt_client_end, 64 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, opt_server_end, 68 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, opt_struct, 72 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_union, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_handle, 96 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, array_vmo, 116 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, array_client_end, 136 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, array_server_end, 156 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, array_struct, 176 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_table, 184 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_union, 264 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_handle, 344 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, vector_vmo, 360 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, vector_client_end, 376 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, vector_server_end, 392 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, vector_struct, 408 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_table, 424 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_union, 440 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayResource(::fidl::MessageEncoder* _encoder, ::zx::handle* handle, ::zx::vmo* vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* server_end, ::test::typesinprotocols::ResourceStruct* struct_, ::test::typesinprotocols::ResourceTable* table, ::test::typesinprotocols::ResourceUnion* union_, ::zx::handle* opt_handle, ::zx::vmo* opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct>* opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion>* opt_union, ::std::array<::zx::handle, 5>* array_handle, ::std::array<::zx::vmo, 5>* array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>* array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>* array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5>* array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5>* array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5>* array_union, ::std::vector<::zx::handle>* vector_handle, ::std::vector<::zx::vmo>* vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>* vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>* vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct>* vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable>* vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion>* vector_union) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(456);
    ::fidl::Encode(_encoder, handle, 0 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, vmo, 4 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, client_end, 8 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, server_end, 12 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, struct_, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, table, 24 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, union_, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_handle, 56 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, opt_vmo, 60 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, opt_client_end, 64 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, opt_server_end, 68 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, opt_struct, 72 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_union, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_handle, 96 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, array_vmo, 116 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, array_client_end, 136 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, array_server_end, 156 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, array_struct, 176 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_table, 184 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_union, 264 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_handle, 344 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, vector_vmo, 360 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, vector_client_end, 376 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, vector_server_end, 392 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, vector_struct, 408 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_table, 424 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_union, 440 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



class Protocol_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage TwoWayBasic(::fidl::MessageEncoder* _encoder, uint8_t* uint8, uint16_t* uint16, uint32_t* uint32, uint64_t* uint64, int8_t* int8, int16_t* int16, int32_t* int32, int64_t* int64, float* float32, double* float64, ::std::string* string, ::fidl::StringPtr* opt_string) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(80);
    ::fidl::Encode(_encoder, uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, uint16, 2 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, uint32, 4 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, uint64, 8 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int8, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int16, 18 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int32, 20 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int64, 24 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, float32, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, float64, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, string, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_string, 64 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage EventBasic(::fidl::MessageEncoder* _encoder, uint8_t* uint8, uint16_t* uint16, uint32_t* uint32, uint64_t* uint64, int8_t* int8, int16_t* int16, int32_t* int32, int64_t* int64, float* float32, double* float64, ::std::string* string, ::fidl::StringPtr* opt_string) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(80);
    ::fidl::Encode(_encoder, uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, uint16, 2 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, uint32, 4 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, uint64, 8 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int8, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int16, 18 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int32, 20 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, int64, 24 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, float32, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, float64, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, string, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_string, 64 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayCompound(::fidl::MessageEncoder* _encoder, ::test::typesinprotocols::Bits* bits, ::test::typesinprotocols::Enum* enum_, ::test::typesinprotocols::Struct* struct_, ::test::typesinprotocols::Table* table, ::test::typesinprotocols::Union* union_, ::std::unique_ptr<::test::typesinprotocols::Struct>* opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union>* opt_union) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(72);
    ::fidl::Encode(_encoder, bits, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, enum_, 4 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, struct_, 8 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, table, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, union_, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_struct, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_union, 56 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage EventCompound(::fidl::MessageEncoder* _encoder, ::test::typesinprotocols::Bits* bits, ::test::typesinprotocols::Enum* enum_, ::test::typesinprotocols::Struct* struct_, ::test::typesinprotocols::Table* table, ::test::typesinprotocols::Union* union_, ::std::unique_ptr<::test::typesinprotocols::Struct>* opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union>* opt_union) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(72);
    ::fidl::Encode(_encoder, bits, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, enum_, 4 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, struct_, 8 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, table, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, union_, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_struct, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_union, 56 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayArrayBasic(::fidl::MessageEncoder* _encoder, ::std::array<uint8_t, 5>* array_uint8, ::std::array<uint16_t, 5>* array_uint16, ::std::array<uint32_t, 5>* array_uint32, ::std::array<uint64_t, 5>* array_uint64, ::std::array<int8_t, 5>* array_int8, ::std::array<int16_t, 5>* array_int16, ::std::array<int32_t, 5>* array_int32, ::std::array<int64_t, 5>* array_int64, ::std::array<float, 5>* array_float32, ::std::array<double, 5>* array_float64, ::std::array<::std::string, 5>* array_string, ::std::array<::fidl::StringPtr, 5>* array_opt_string) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(384);
    ::fidl::Encode(_encoder, array_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_uint16, 6 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_uint32, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_uint64, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int8, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int16, 86 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int32, 96 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int64, 120 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_float32, 160 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_float64, 184 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_string, 224 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_opt_string, 304 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage EventArrayBasic(::fidl::MessageEncoder* _encoder, ::std::array<uint8_t, 5>* array_uint8, ::std::array<uint16_t, 5>* array_uint16, ::std::array<uint32_t, 5>* array_uint32, ::std::array<uint64_t, 5>* array_uint64, ::std::array<int8_t, 5>* array_int8, ::std::array<int16_t, 5>* array_int16, ::std::array<int32_t, 5>* array_int32, ::std::array<int64_t, 5>* array_int64, ::std::array<float, 5>* array_float32, ::std::array<double, 5>* array_float64, ::std::array<::std::string, 5>* array_string, ::std::array<::fidl::StringPtr, 5>* array_opt_string) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(384);
    ::fidl::Encode(_encoder, array_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_uint16, 6 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_uint32, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_uint64, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int8, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int16, 86 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int32, 96 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_int64, 120 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_float32, 160 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_float64, 184 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_string, 224 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_opt_string, 304 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayArrayCompound(::fidl::MessageEncoder* _encoder, ::std::array<::test::typesinprotocols::Bits, 5>* array_bits, ::std::array<::test::typesinprotocols::Enum, 5>* array_enum, ::std::array<::test::typesinprotocols::Struct, 5>* array_struct, ::std::array<::test::typesinprotocols::Table, 5>* array_table, ::std::array<::test::typesinprotocols::Union, 5>* array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>* array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>* array_opt_union) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(328);
    ::fidl::Encode(_encoder, array_bits, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_enum, 20 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_struct, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_table, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_union, 128 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_opt_struct, 208 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_opt_union, 248 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage EventArrayCompound(::fidl::MessageEncoder* _encoder, ::std::array<::test::typesinprotocols::Bits, 5>* array_bits, ::std::array<::test::typesinprotocols::Enum, 5>* array_enum, ::std::array<::test::typesinprotocols::Struct, 5>* array_struct, ::std::array<::test::typesinprotocols::Table, 5>* array_table, ::std::array<::test::typesinprotocols::Union, 5>* array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>* array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>* array_opt_union) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(328);
    ::fidl::Encode(_encoder, array_bits, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_enum, 20 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_struct, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_table, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_union, 128 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_opt_struct, 208 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_opt_union, 248 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayVectorBasic(::fidl::MessageEncoder* _encoder, ::std::vector<uint8_t>* vector_uint8, ::std::vector<uint16_t>* vector_uint16, ::std::vector<uint32_t>* vector_uint32, ::std::vector<uint64_t>* vector_uint64, ::std::vector<int8_t>* vector_int8, ::std::vector<int16_t>* vector_int16, ::std::vector<int32_t>* vector_int32, ::std::vector<int64_t>* vector_int64, ::std::vector<float>* vector_float32, ::std::vector<double>* vector_float64, ::std::vector<::std::string>* vector_string, ::std::vector<::fidl::StringPtr>* vector_opt_string) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(192);
    ::fidl::Encode(_encoder, vector_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_uint16, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_uint32, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_uint64, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int8, 64 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int16, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int32, 96 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int64, 112 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_float32, 128 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_float64, 144 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_string, 160 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_opt_string, 176 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage EventVectorBasic(::fidl::MessageEncoder* _encoder, ::std::vector<uint8_t>* vector_uint8, ::std::vector<uint16_t>* vector_uint16, ::std::vector<uint32_t>* vector_uint32, ::std::vector<uint64_t>* vector_uint64, ::std::vector<int8_t>* vector_int8, ::std::vector<int16_t>* vector_int16, ::std::vector<int32_t>* vector_int32, ::std::vector<int64_t>* vector_int64, ::std::vector<float>* vector_float32, ::std::vector<double>* vector_float64, ::std::vector<::std::string>* vector_string, ::std::vector<::fidl::StringPtr>* vector_opt_string) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(192);
    ::fidl::Encode(_encoder, vector_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_uint16, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_uint32, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_uint64, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int8, 64 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int16, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int32, 96 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_int64, 112 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_float32, 128 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_float64, 144 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_string, 160 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_opt_string, 176 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayVectorCompound(::fidl::MessageEncoder* _encoder, ::std::vector<::test::typesinprotocols::Bits>* vector_bits, ::std::vector<::test::typesinprotocols::Enum>* vector_enum, ::std::vector<::test::typesinprotocols::Struct>* vector_struct, ::std::vector<::test::typesinprotocols::Table>* vector_table, ::std::vector<::test::typesinprotocols::Union>* vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>* vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>* vector_opt_union) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(112);
    ::fidl::Encode(_encoder, vector_bits, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_enum, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_struct, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_table, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_union, 64 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_opt_struct, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_opt_union, 96 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage EventVectorCompound(::fidl::MessageEncoder* _encoder, ::std::vector<::test::typesinprotocols::Bits>* vector_bits, ::std::vector<::test::typesinprotocols::Enum>* vector_enum, ::std::vector<::test::typesinprotocols::Struct>* vector_struct, ::std::vector<::test::typesinprotocols::Table>* vector_table, ::std::vector<::test::typesinprotocols::Union>* vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>* vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>* vector_opt_union) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(112);
    ::fidl::Encode(_encoder, vector_bits, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_enum, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_struct, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_table, 48 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_union, 64 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_opt_struct, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_opt_union, 96 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayVectorOptional(::fidl::MessageEncoder* _encoder, ::fidl::VectorPtr<uint8_t>* opt_vector_uint8, ::fidl::VectorPtr<::std::string>* opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>* opt_vector_opt_struct) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(64);
    ::fidl::Encode(_encoder, opt_vector_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_vector_string, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_vector_opt_struct, 48 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage EventVectorOptional(::fidl::MessageEncoder* _encoder, ::fidl::VectorPtr<uint8_t>* opt_vector_uint8, ::fidl::VectorPtr<::std::string>* opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>* opt_vector_opt_struct) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(64);
    ::fidl::Encode(_encoder, opt_vector_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_vector_string, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_vector_opt_struct, 48 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayArrayVectorNested(::fidl::MessageEncoder* _encoder, ::std::array<::std::array<uint8_t, 5>, 5>* array_array_uint8, ::std::array<::std::vector<uint8_t>, 5>* array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>>* vector_array_uint8, ::std::vector<::std::vector<uint8_t>>* vector_vector_uint8) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(144);
    ::fidl::Encode(_encoder, array_array_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_vector_uint8, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_array_uint8, 112 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_vector_uint8, 128 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage EventArrayVectorNested(::fidl::MessageEncoder* _encoder, ::std::array<::std::array<uint8_t, 5>, 5>* array_array_uint8, ::std::array<::std::vector<uint8_t>, 5>* array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>>* vector_array_uint8, ::std::vector<::std::vector<uint8_t>>* vector_vector_uint8) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(144);
    ::fidl::Encode(_encoder, array_array_uint8, 0 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_vector_uint8, 32 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_array_uint8, 112 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_vector_uint8, 128 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TwoWayResource(::fidl::MessageEncoder* _encoder, ::zx::handle* handle, ::zx::vmo* vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* server_end, ::test::typesinprotocols::ResourceStruct* struct_, ::test::typesinprotocols::ResourceTable* table, ::test::typesinprotocols::ResourceUnion* union_, ::zx::handle* opt_handle, ::zx::vmo* opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct>* opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion>* opt_union, ::std::array<::zx::handle, 5>* array_handle, ::std::array<::zx::vmo, 5>* array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>* array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>* array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5>* array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5>* array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5>* array_union, ::std::vector<::zx::handle>* vector_handle, ::std::vector<::zx::vmo>* vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>* vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>* vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct>* vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable>* vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion>* vector_union) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(456);
    ::fidl::Encode(_encoder, handle, 0 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, vmo, 4 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, client_end, 8 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, server_end, 12 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, struct_, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, table, 24 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, union_, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_handle, 56 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, opt_vmo, 60 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, opt_client_end, 64 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, opt_server_end, 68 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, opt_struct, 72 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_union, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_handle, 96 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, array_vmo, 116 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, array_client_end, 136 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, array_server_end, 156 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, array_struct, 176 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_table, 184 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_union, 264 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_handle, 344 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, vector_vmo, 360 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, vector_client_end, 376 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, vector_server_end, 392 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, vector_struct, 408 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_table, 424 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_union, 440 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage EventResource(::fidl::MessageEncoder* _encoder, ::zx::handle* handle, ::zx::vmo* vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* server_end, ::test::typesinprotocols::ResourceStruct* struct_, ::test::typesinprotocols::ResourceTable* table, ::test::typesinprotocols::ResourceUnion* union_, ::zx::handle* opt_handle, ::zx::vmo* opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct>* opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion>* opt_union, ::std::array<::zx::handle, 5>* array_handle, ::std::array<::zx::vmo, 5>* array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>* array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>* array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5>* array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5>* array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5>* array_union, ::std::vector<::zx::handle>* vector_handle, ::std::vector<::zx::vmo>* vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>* vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>* vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct>* vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable>* vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion>* vector_union) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(456);
    ::fidl::Encode(_encoder, handle, 0 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, vmo, 4 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, client_end, 8 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, server_end, 12 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, struct_, 16 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, table, 24 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, union_, 40 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_handle, 56 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, opt_vmo, 60 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, opt_client_end, 64 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, opt_server_end, 68 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, opt_struct, 72 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, opt_union, 80 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_handle, 96 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, array_vmo, 116 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, array_client_end, 136 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, array_server_end, 156 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, array_struct, 176 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_table, 184 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, array_union, 264 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_handle, 344 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, vector_vmo, 360 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, vector_client_end, 376 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, vector_server_end, 392 + sizeof(fidl_message_header_t), ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, vector_struct, 408 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_table, 424 + sizeof(fidl_message_header_t));
    
    ::fidl::Encode(_encoder, vector_union, 440 + sizeof(fidl_message_header_t));
    

    fidl_trace(DidHLCPPEncode, &::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};

#endif  // __Fuchsia__



}  // namespace typesinprotocols
}  // namespace test
namespace fidl {

template <>
struct CodingTraits<::test::typesinprotocols::Bits> {
  static constexpr size_t inline_size_v2 = sizeof(::test::typesinprotocols::Bits);
  static void Encode(Encoder* encoder, ::test::typesinprotocols::Bits* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::typesinprotocols::Bits* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::typesinprotocols::Bits>(underlying);
  }
};

inline zx_status_t Clone(::test::typesinprotocols::Bits value,
                         ::test::typesinprotocols::Bits* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::Bits> {
  bool operator()(const ::test::typesinprotocols::Bits& _lhs, const ::test::typesinprotocols::Bits& _rhs) const {
    uint32_t _lhs_underlying = static_cast<uint32_t>(_lhs);
    uint32_t _rhs_underlying = static_cast<uint32_t>(_rhs);
    return ::fidl::Equals(_lhs_underlying, _rhs_underlying);
  }
};
template <>
struct CodingTraits<::test::typesinprotocols::Enum> {
  static constexpr size_t inline_size_v2 = sizeof(::test::typesinprotocols::Enum);
  static void Encode(Encoder* encoder, ::test::typesinprotocols::Enum* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::typesinprotocols::Enum* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::typesinprotocols::Enum>(underlying);
  }
};

inline zx_status_t Clone(::test::typesinprotocols::Enum value,
                         ::test::typesinprotocols::Enum* result) {
  return ::test::typesinprotocols::Clone(value, result);
}
template<>
struct Equality<::test::typesinprotocols::Enum> {
  bool operator()(const ::test::typesinprotocols::Enum& _lhs, const ::test::typesinprotocols::Enum& _rhs) const {
    return _lhs == _rhs;
  }
};


template <>
struct CodingTraits<::test::typesinprotocols::Struct>
    : public EncodableCodingTraits<::test::typesinprotocols::Struct, 1> {};




template<>
struct IsMemcpyCompatible<::test::typesinprotocols::Struct> : public internal::BoolConstant<
    !HasPadding<::test::typesinprotocols::Struct>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::typesinprotocols::Struct& value,
                         ::test::typesinprotocols::Struct* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::Struct> {
  bool operator()(const ::test::typesinprotocols::Struct& _lhs, const ::test::typesinprotocols::Struct& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::typesinprotocols::Table>
    : public EncodableCodingTraits<::test::typesinprotocols::Table, 16> {};

inline zx_status_t Clone(const ::test::typesinprotocols::Table& _value,
                         ::test::typesinprotocols::Table* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::typesinprotocols::Table> {
  bool operator()(const ::test::typesinprotocols::Table& _lhs, const ::test::typesinprotocols::Table& _rhs) const {
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::typesinprotocols::Union> : public std::true_type {};

template <>
struct CodingTraits<::test::typesinprotocols::Union>
    : public EncodableCodingTraits<::test::typesinprotocols::Union, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::typesinprotocols::Union>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::typesinprotocols::Union>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::typesinprotocols::Union>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::typesinprotocols::Union);

    ::test::typesinprotocols::Union::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::typesinprotocols::Union& value,
                         ::test::typesinprotocols::Union* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::Union> {
  bool operator()(const ::test::typesinprotocols::Union& _lhs, const ::test::typesinprotocols::Union& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Union::Tag::Invalid):
        return true;
      case ::test::typesinprotocols::Union::Tag::kB:
        return ::fidl::Equals(_lhs.b_, _rhs.b_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};
#ifdef __Fuchsia__

template <>
struct CodingTraits<::test::typesinprotocols::ResourceStruct>
    : public EncodableCodingTraits<::test::typesinprotocols::ResourceStruct, 1> {};




template<>
struct IsMemcpyCompatible<::test::typesinprotocols::ResourceStruct> : public internal::BoolConstant<
    !HasPadding<::test::typesinprotocols::ResourceStruct>::value
    && IsMemcpyCompatible<uint8_t>::value> {};


inline zx_status_t Clone(const ::test::typesinprotocols::ResourceStruct& value,
                         ::test::typesinprotocols::ResourceStruct* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::ResourceStruct> {
  bool operator()(const ::test::typesinprotocols::ResourceStruct& _lhs, const ::test::typesinprotocols::ResourceStruct& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct CodingTraits<::test::typesinprotocols::ResourceTable>
    : public EncodableCodingTraits<::test::typesinprotocols::ResourceTable, 16> {};

inline zx_status_t Clone(const ::test::typesinprotocols::ResourceTable& _value,
                         ::test::typesinprotocols::ResourceTable* result) {
  return _value.Clone(result);
}
template<>
struct Equality<::test::typesinprotocols::ResourceTable> {
  bool operator()(const ::test::typesinprotocols::ResourceTable& _lhs, const ::test::typesinprotocols::ResourceTable& _rhs) const {
    return true;
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct IsFidlXUnion<::test::typesinprotocols::ResourceUnion> : public std::true_type {};

template <>
struct CodingTraits<::test::typesinprotocols::ResourceUnion>
    : public EncodableCodingTraits<::test::typesinprotocols::ResourceUnion, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::typesinprotocols::ResourceUnion>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::typesinprotocols::ResourceUnion>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::typesinprotocols::ResourceUnion>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::typesinprotocols::ResourceUnion);

    ::test::typesinprotocols::ResourceUnion::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::typesinprotocols::ResourceUnion& value,
                         ::test::typesinprotocols::ResourceUnion* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::ResourceUnion> {
  bool operator()(const ::test::typesinprotocols::ResourceUnion& _lhs, const ::test::typesinprotocols::ResourceUnion& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::ResourceUnion::Tag::Invalid):
        return true;
      case ::test::typesinprotocols::ResourceUnion::Tag::kB:
        return ::fidl::Equals(_lhs.b_, _rhs.b_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
      }
    }
};

#endif  // __Fuchsia__

template <>
struct CodingTraits<::test::typesinprotocols::Basic>
    : public EncodableCodingTraits<::test::typesinprotocols::Basic, 80> {};


template<>
struct HasPadding<::test::typesinprotocols::Basic> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::typesinprotocols::Basic> : public internal::BoolConstant<
    !HasPadding<::test::typesinprotocols::Basic>::value
    && IsMemcpyCompatible<uint8_t>::value
    && IsMemcpyCompatible<uint16_t>::value
    && IsMemcpyCompatible<uint32_t>::value
    && IsMemcpyCompatible<uint64_t>::value
    && IsMemcpyCompatible<int8_t>::value
    && IsMemcpyCompatible<int16_t>::value
    && IsMemcpyCompatible<int32_t>::value
    && IsMemcpyCompatible<int64_t>::value
    && IsMemcpyCompatible<float>::value
    && IsMemcpyCompatible<double>::value
    && IsMemcpyCompatible<::std::string>::value
    && IsMemcpyCompatible<::fidl::StringPtr>::value> {};


inline zx_status_t Clone(const ::test::typesinprotocols::Basic& value,
                         ::test::typesinprotocols::Basic* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::Basic> {
  bool operator()(const ::test::typesinprotocols::Basic& _lhs, const ::test::typesinprotocols::Basic& _rhs) const {
    if (!::fidl::Equals(_lhs.uint8, _rhs.uint8)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.uint16, _rhs.uint16)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.uint32, _rhs.uint32)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.uint64, _rhs.uint64)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.int8, _rhs.int8)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.int16, _rhs.int16)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.int32, _rhs.int32)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.int64, _rhs.int64)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.float32, _rhs.float32)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.float64, _rhs.float64)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.string, _rhs.string)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.opt_string, _rhs.opt_string)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::typesinprotocols::Compound>
    : public EncodableCodingTraits<::test::typesinprotocols::Compound, 72> {};


template<>
struct HasPadding<::test::typesinprotocols::Compound> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::typesinprotocols::Compound> : public internal::BoolConstant<
    !HasPadding<::test::typesinprotocols::Compound>::value
    && IsMemcpyCompatible<::test::typesinprotocols::Bits>::value
    && IsMemcpyCompatible<::test::typesinprotocols::Enum>::value
    && IsMemcpyCompatible<::test::typesinprotocols::Struct>::value
    && IsMemcpyCompatible<::test::typesinprotocols::Table>::value
    && IsMemcpyCompatible<::test::typesinprotocols::Union>::value
    && IsMemcpyCompatible<::std::unique_ptr<::test::typesinprotocols::Struct>>::value
    && IsMemcpyCompatible<::std::unique_ptr<::test::typesinprotocols::Union>>::value> {};


inline zx_status_t Clone(const ::test::typesinprotocols::Compound& value,
                         ::test::typesinprotocols::Compound* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::Compound> {
  bool operator()(const ::test::typesinprotocols::Compound& _lhs, const ::test::typesinprotocols::Compound& _rhs) const {
    if (!::fidl::Equals(_lhs.bits, _rhs.bits)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.enum_, _rhs.enum_)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.struct_, _rhs.struct_)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.table, _rhs.table)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.union_, _rhs.union_)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.opt_struct, _rhs.opt_struct)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.opt_union, _rhs.opt_union)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::typesinprotocols::ArrayBasic>
    : public EncodableCodingTraits<::test::typesinprotocols::ArrayBasic, 384> {};


template<>
struct HasPadding<::test::typesinprotocols::ArrayBasic> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::typesinprotocols::ArrayBasic> : public internal::BoolConstant<
    !HasPadding<::test::typesinprotocols::ArrayBasic>::value
    && IsMemcpyCompatible<::std::array<uint8_t, 5>>::value
    && IsMemcpyCompatible<::std::array<uint16_t, 5>>::value
    && IsMemcpyCompatible<::std::array<uint32_t, 5>>::value
    && IsMemcpyCompatible<::std::array<uint64_t, 5>>::value
    && IsMemcpyCompatible<::std::array<int8_t, 5>>::value
    && IsMemcpyCompatible<::std::array<int16_t, 5>>::value
    && IsMemcpyCompatible<::std::array<int32_t, 5>>::value
    && IsMemcpyCompatible<::std::array<int64_t, 5>>::value
    && IsMemcpyCompatible<::std::array<float, 5>>::value
    && IsMemcpyCompatible<::std::array<double, 5>>::value
    && IsMemcpyCompatible<::std::array<::std::string, 5>>::value
    && IsMemcpyCompatible<::std::array<::fidl::StringPtr, 5>>::value> {};


inline zx_status_t Clone(const ::test::typesinprotocols::ArrayBasic& value,
                         ::test::typesinprotocols::ArrayBasic* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::ArrayBasic> {
  bool operator()(const ::test::typesinprotocols::ArrayBasic& _lhs, const ::test::typesinprotocols::ArrayBasic& _rhs) const {
    if (!::fidl::Equals(_lhs.array_uint8, _rhs.array_uint8)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_uint16, _rhs.array_uint16)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_uint32, _rhs.array_uint32)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_uint64, _rhs.array_uint64)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_int8, _rhs.array_int8)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_int16, _rhs.array_int16)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_int32, _rhs.array_int32)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_int64, _rhs.array_int64)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_float32, _rhs.array_float32)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_float64, _rhs.array_float64)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_string, _rhs.array_string)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_opt_string, _rhs.array_opt_string)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::typesinprotocols::ArrayCompound>
    : public EncodableCodingTraits<::test::typesinprotocols::ArrayCompound, 328> {};


template<>
struct HasPadding<::test::typesinprotocols::ArrayCompound> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::typesinprotocols::ArrayCompound> : public internal::BoolConstant<
    !HasPadding<::test::typesinprotocols::ArrayCompound>::value
    && IsMemcpyCompatible<::std::array<::test::typesinprotocols::Bits, 5>>::value
    && IsMemcpyCompatible<::std::array<::test::typesinprotocols::Enum, 5>>::value
    && IsMemcpyCompatible<::std::array<::test::typesinprotocols::Struct, 5>>::value
    && IsMemcpyCompatible<::std::array<::test::typesinprotocols::Table, 5>>::value
    && IsMemcpyCompatible<::std::array<::test::typesinprotocols::Union, 5>>::value
    && IsMemcpyCompatible<::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>>::value
    && IsMemcpyCompatible<::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>>::value> {};


inline zx_status_t Clone(const ::test::typesinprotocols::ArrayCompound& value,
                         ::test::typesinprotocols::ArrayCompound* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::ArrayCompound> {
  bool operator()(const ::test::typesinprotocols::ArrayCompound& _lhs, const ::test::typesinprotocols::ArrayCompound& _rhs) const {
    if (!::fidl::Equals(_lhs.array_bits, _rhs.array_bits)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_enum, _rhs.array_enum)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_struct, _rhs.array_struct)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_table, _rhs.array_table)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_union, _rhs.array_union)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_opt_struct, _rhs.array_opt_struct)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_opt_union, _rhs.array_opt_union)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::typesinprotocols::VectorBasic>
    : public EncodableCodingTraits<::test::typesinprotocols::VectorBasic, 192> {};


template<>
struct HasPadding<::test::typesinprotocols::VectorBasic> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::typesinprotocols::VectorBasic> : public internal::BoolConstant<
    !HasPadding<::test::typesinprotocols::VectorBasic>::value
    && IsMemcpyCompatible<::std::vector<uint8_t>>::value
    && IsMemcpyCompatible<::std::vector<uint16_t>>::value
    && IsMemcpyCompatible<::std::vector<uint32_t>>::value
    && IsMemcpyCompatible<::std::vector<uint64_t>>::value
    && IsMemcpyCompatible<::std::vector<int8_t>>::value
    && IsMemcpyCompatible<::std::vector<int16_t>>::value
    && IsMemcpyCompatible<::std::vector<int32_t>>::value
    && IsMemcpyCompatible<::std::vector<int64_t>>::value
    && IsMemcpyCompatible<::std::vector<float>>::value
    && IsMemcpyCompatible<::std::vector<double>>::value
    && IsMemcpyCompatible<::std::vector<::std::string>>::value
    && IsMemcpyCompatible<::std::vector<::fidl::StringPtr>>::value> {};


inline zx_status_t Clone(const ::test::typesinprotocols::VectorBasic& value,
                         ::test::typesinprotocols::VectorBasic* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::VectorBasic> {
  bool operator()(const ::test::typesinprotocols::VectorBasic& _lhs, const ::test::typesinprotocols::VectorBasic& _rhs) const {
    if (!::fidl::Equals(_lhs.vector_uint8, _rhs.vector_uint8)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_uint16, _rhs.vector_uint16)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_uint32, _rhs.vector_uint32)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_uint64, _rhs.vector_uint64)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_int8, _rhs.vector_int8)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_int16, _rhs.vector_int16)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_int32, _rhs.vector_int32)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_int64, _rhs.vector_int64)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_float32, _rhs.vector_float32)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_float64, _rhs.vector_float64)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_string, _rhs.vector_string)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_opt_string, _rhs.vector_opt_string)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::typesinprotocols::VectorCompound>
    : public EncodableCodingTraits<::test::typesinprotocols::VectorCompound, 112> {};


template<>
struct HasPadding<::test::typesinprotocols::VectorCompound> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::typesinprotocols::VectorCompound> : public internal::BoolConstant<
    !HasPadding<::test::typesinprotocols::VectorCompound>::value
    && IsMemcpyCompatible<::std::vector<::test::typesinprotocols::Bits>>::value
    && IsMemcpyCompatible<::std::vector<::test::typesinprotocols::Enum>>::value
    && IsMemcpyCompatible<::std::vector<::test::typesinprotocols::Struct>>::value
    && IsMemcpyCompatible<::std::vector<::test::typesinprotocols::Table>>::value
    && IsMemcpyCompatible<::std::vector<::test::typesinprotocols::Union>>::value
    && IsMemcpyCompatible<::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>>::value
    && IsMemcpyCompatible<::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>>::value> {};


inline zx_status_t Clone(const ::test::typesinprotocols::VectorCompound& value,
                         ::test::typesinprotocols::VectorCompound* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::VectorCompound> {
  bool operator()(const ::test::typesinprotocols::VectorCompound& _lhs, const ::test::typesinprotocols::VectorCompound& _rhs) const {
    if (!::fidl::Equals(_lhs.vector_bits, _rhs.vector_bits)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_enum, _rhs.vector_enum)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_struct, _rhs.vector_struct)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_table, _rhs.vector_table)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_union, _rhs.vector_union)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_opt_struct, _rhs.vector_opt_struct)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_opt_union, _rhs.vector_opt_union)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::typesinprotocols::VectorOptional>
    : public EncodableCodingTraits<::test::typesinprotocols::VectorOptional, 64> {};


template<>
struct HasPadding<::test::typesinprotocols::VectorOptional> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::typesinprotocols::VectorOptional> : public internal::BoolConstant<
    !HasPadding<::test::typesinprotocols::VectorOptional>::value
    && IsMemcpyCompatible<::fidl::VectorPtr<uint8_t>>::value
    && IsMemcpyCompatible<::fidl::VectorPtr<::std::string>>::value
    && IsMemcpyCompatible<::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>>::value> {};


inline zx_status_t Clone(const ::test::typesinprotocols::VectorOptional& value,
                         ::test::typesinprotocols::VectorOptional* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::VectorOptional> {
  bool operator()(const ::test::typesinprotocols::VectorOptional& _lhs, const ::test::typesinprotocols::VectorOptional& _rhs) const {
    if (!::fidl::Equals(_lhs.opt_vector_uint8, _rhs.opt_vector_uint8)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.opt_vector_string, _rhs.opt_vector_string)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.opt_vector_opt_struct, _rhs.opt_vector_opt_struct)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::typesinprotocols::ArrayVectorNested>
    : public EncodableCodingTraits<::test::typesinprotocols::ArrayVectorNested, 144> {};


template<>
struct HasPadding<::test::typesinprotocols::ArrayVectorNested> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::typesinprotocols::ArrayVectorNested> : public internal::BoolConstant<
    !HasPadding<::test::typesinprotocols::ArrayVectorNested>::value
    && IsMemcpyCompatible<::std::array<::std::array<uint8_t, 5>, 5>>::value
    && IsMemcpyCompatible<::std::array<::std::vector<uint8_t>, 5>>::value
    && IsMemcpyCompatible<::std::vector<::std::array<uint8_t, 5>>>::value
    && IsMemcpyCompatible<::std::vector<::std::vector<uint8_t>>>::value> {};


inline zx_status_t Clone(const ::test::typesinprotocols::ArrayVectorNested& value,
                         ::test::typesinprotocols::ArrayVectorNested* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::ArrayVectorNested> {
  bool operator()(const ::test::typesinprotocols::ArrayVectorNested& _lhs, const ::test::typesinprotocols::ArrayVectorNested& _rhs) const {
    if (!::fidl::Equals(_lhs.array_array_uint8, _rhs.array_array_uint8)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_vector_uint8, _rhs.array_vector_uint8)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_array_uint8, _rhs.vector_array_uint8)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_vector_uint8, _rhs.vector_vector_uint8)) {
      return false;
    }
    return true;
  }
};
#ifdef __Fuchsia__

template <>
struct CodingTraits<::test::typesinprotocols::Resource>
    : public EncodableCodingTraits<::test::typesinprotocols::Resource, 456> {};


template<>
struct HasPadding<::test::typesinprotocols::Resource> : public std::true_type {};



template<>
struct IsMemcpyCompatible<::test::typesinprotocols::Resource> : public internal::BoolConstant<
    !HasPadding<::test::typesinprotocols::Resource>::value
    && IsMemcpyCompatible<::zx::handle>::value
    && IsMemcpyCompatible<::zx::vmo>::value
    && IsMemcpyCompatible<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>::value
    && IsMemcpyCompatible<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>::value
    && IsMemcpyCompatible<::test::typesinprotocols::ResourceStruct>::value
    && IsMemcpyCompatible<::test::typesinprotocols::ResourceTable>::value
    && IsMemcpyCompatible<::test::typesinprotocols::ResourceUnion>::value
    && IsMemcpyCompatible<::std::unique_ptr<::test::typesinprotocols::ResourceStruct>>::value
    && IsMemcpyCompatible<::std::unique_ptr<::test::typesinprotocols::ResourceUnion>>::value
    && IsMemcpyCompatible<::std::array<::zx::handle, 5>>::value
    && IsMemcpyCompatible<::std::array<::zx::vmo, 5>>::value
    && IsMemcpyCompatible<::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>>::value
    && IsMemcpyCompatible<::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>>::value
    && IsMemcpyCompatible<::std::array<::test::typesinprotocols::ResourceStruct, 5>>::value
    && IsMemcpyCompatible<::std::array<::test::typesinprotocols::ResourceTable, 5>>::value
    && IsMemcpyCompatible<::std::array<::test::typesinprotocols::ResourceUnion, 5>>::value
    && IsMemcpyCompatible<::std::vector<::zx::handle>>::value
    && IsMemcpyCompatible<::std::vector<::zx::vmo>>::value
    && IsMemcpyCompatible<::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>>::value
    && IsMemcpyCompatible<::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>>::value
    && IsMemcpyCompatible<::std::vector<::test::typesinprotocols::ResourceStruct>>::value
    && IsMemcpyCompatible<::std::vector<::test::typesinprotocols::ResourceTable>>::value
    && IsMemcpyCompatible<::std::vector<::test::typesinprotocols::ResourceUnion>>::value> {};


inline zx_status_t Clone(const ::test::typesinprotocols::Resource& value,
                         ::test::typesinprotocols::Resource* result) {
  return ::test::typesinprotocols::Clone(value, result);
}

template<>
struct Equality<::test::typesinprotocols::Resource> {
  bool operator()(const ::test::typesinprotocols::Resource& _lhs, const ::test::typesinprotocols::Resource& _rhs) const {
    if (!::fidl::Equals(_lhs.handle, _rhs.handle)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vmo, _rhs.vmo)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.client_end, _rhs.client_end)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.server_end, _rhs.server_end)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.struct_, _rhs.struct_)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.table, _rhs.table)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.union_, _rhs.union_)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.opt_handle, _rhs.opt_handle)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.opt_vmo, _rhs.opt_vmo)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.opt_client_end, _rhs.opt_client_end)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.opt_server_end, _rhs.opt_server_end)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.opt_struct, _rhs.opt_struct)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.opt_union, _rhs.opt_union)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_handle, _rhs.array_handle)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_vmo, _rhs.array_vmo)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_client_end, _rhs.array_client_end)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_server_end, _rhs.array_server_end)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_struct, _rhs.array_struct)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_table, _rhs.array_table)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.array_union, _rhs.array_union)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_handle, _rhs.vector_handle)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_vmo, _rhs.vector_vmo)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_client_end, _rhs.vector_client_end)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_server_end, _rhs.vector_server_end)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_struct, _rhs.vector_struct)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_table, _rhs.vector_table)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.vector_union, _rhs.vector_union)) {
      return false;
    }
    return true;
  }
};

#endif  // __Fuchsia__


//
// Proxies and stubs declarations
//
}  // namespace fidl
namespace test {
namespace typesinprotocols {

#ifdef __Fuchsia__

using ProtocolPtr = ::fidl::InterfacePtr<Protocol>;
class Protocol_Proxy;
class Protocol_Stub;
class Protocol_EventSender;
class Protocol_Sync;
using ProtocolSyncPtr = ::fidl::SynchronousInterfacePtr<Protocol>;
class Protocol_SyncProxy;

namespace internal {

constexpr uint64_t kProtocol_OneWayBasic_Ordinal = 0x7c311f0d9e662df9lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_TwoWayBasic_Ordinal = 0x205b92db5139c88flu;

constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_EventBasic_Ordinal = 0x51c5b06295c10c40lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_EventBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_OneWayCompound_Ordinal = 0x2bc2bc3a9237c6cclu;

constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_TwoWayCompound_Ordinal = 0x79f279c7201da131lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_EventCompound_Ordinal = 0x617c5410858734d5lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_EventCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_OneWayArrayBasic_Ordinal = 0x62e2ebcadf35ca19lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayArrayBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_TwoWayArrayBasic_Ordinal = 0x49ad7a74e28ba114lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayArrayBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_EventArrayBasic_Ordinal = 0x51b76208b148f02elu;

constexpr ::fidl::MessageDynamicFlags kProtocol_EventArrayBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_OneWayArrayCompound_Ordinal = 0x464948bae1bda09dlu;

constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayArrayCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_TwoWayArrayCompound_Ordinal = 0xbcae616f8e1ea7blu;

constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayArrayCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_EventArrayCompound_Ordinal = 0x1e63a00079aa7415lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_EventArrayCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_OneWayVectorBasic_Ordinal = 0x4f907dde77464657lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayVectorBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_TwoWayVectorBasic_Ordinal = 0x7860cb3ed8362e74lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayVectorBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_EventVectorBasic_Ordinal = 0x3f9d405e7191eff6lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_EventVectorBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_OneWayVectorCompound_Ordinal = 0x19baae42829dbe90lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayVectorCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_TwoWayVectorCompound_Ordinal = 0x371140db701b23b4lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayVectorCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_EventVectorCompound_Ordinal = 0x53a1fc56e8b3cff3lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_EventVectorCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_OneWayVectorOptional_Ordinal = 0x153c6b333c21c52flu;

constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayVectorOptional_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_TwoWayVectorOptional_Ordinal = 0xe4b620aaafd73f3lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayVectorOptional_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_EventVectorOptional_Ordinal = 0x17617b54dfa8d85dlu;

constexpr ::fidl::MessageDynamicFlags kProtocol_EventVectorOptional_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_OneWayArrayVectorNested_Ordinal = 0x520dc9cb9b9b5ed7lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayArrayVectorNested_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_TwoWayArrayVectorNested_Ordinal = 0x4a438ce0948817dclu;

constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayArrayVectorNested_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_EventArrayVectorNested_Ordinal = 0x110b72cfebc4037elu;

constexpr ::fidl::MessageDynamicFlags kProtocol_EventArrayVectorNested_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_OneWayResource_Ordinal = 0x5af4795a9ed3a022lu;

constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayResource_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_TwoWayResource_Ordinal = 0x1904824a11c6ad5blu;

constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayResource_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

constexpr uint64_t kProtocol_EventResource_Ordinal = 0x4fbde2864601698blu;

constexpr ::fidl::MessageDynamicFlags kProtocol_EventResource_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;}  // namespace internal

#endif  // __Fuchsia__

#ifdef __Fuchsia__

class Protocol {
 public:
  using Proxy_ = ::test::typesinprotocols::Protocol_Proxy;
  using Stub_ = ::test::typesinprotocols::Protocol_Stub;
  using EventSender_ = ::test::typesinprotocols::Protocol_EventSender;
  using Sync_ = ::test::typesinprotocols::Protocol_Sync;
  virtual ~Protocol();
      
  virtual void OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) = 0;
  using TwoWayBasicCallback =
      fit::function<void(uint8_t, uint16_t, uint32_t, uint64_t, int8_t, int16_t, int32_t, int64_t, float, double, ::std::string, ::fidl::StringPtr)>;
      
  virtual void TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string, TwoWayBasicCallback callback) = 0;
  using EventBasicCallback =
      fit::function<void(uint8_t, uint16_t, uint32_t, uint64_t, int8_t, int16_t, int32_t, int64_t, float, double, ::std::string, ::fidl::StringPtr)>;
      
  virtual void OneWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) = 0;
  using TwoWayCompoundCallback =
      fit::function<void(::test::typesinprotocols::Bits, ::test::typesinprotocols::Enum, ::test::typesinprotocols::Struct, ::test::typesinprotocols::Table, ::test::typesinprotocols::Union, ::std::unique_ptr<::test::typesinprotocols::Struct>, ::std::unique_ptr<::test::typesinprotocols::Union>)>;
      
  virtual void TwoWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union, TwoWayCompoundCallback callback) = 0;
  using EventCompoundCallback =
      fit::function<void(::test::typesinprotocols::Bits, ::test::typesinprotocols::Enum, ::test::typesinprotocols::Struct, ::test::typesinprotocols::Table, ::test::typesinprotocols::Union, ::std::unique_ptr<::test::typesinprotocols::Struct>, ::std::unique_ptr<::test::typesinprotocols::Union>)>;
      
  virtual void OneWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) = 0;
  using TwoWayArrayBasicCallback =
      fit::function<void(::std::array<uint8_t, 5>, ::std::array<uint16_t, 5>, ::std::array<uint32_t, 5>, ::std::array<uint64_t, 5>, ::std::array<int8_t, 5>, ::std::array<int16_t, 5>, ::std::array<int32_t, 5>, ::std::array<int64_t, 5>, ::std::array<float, 5>, ::std::array<double, 5>, ::std::array<::std::string, 5>, ::std::array<::fidl::StringPtr, 5>)>;
      
  virtual void TwoWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string, TwoWayArrayBasicCallback callback) = 0;
  using EventArrayBasicCallback =
      fit::function<void(::std::array<uint8_t, 5>, ::std::array<uint16_t, 5>, ::std::array<uint32_t, 5>, ::std::array<uint64_t, 5>, ::std::array<int8_t, 5>, ::std::array<int16_t, 5>, ::std::array<int32_t, 5>, ::std::array<int64_t, 5>, ::std::array<float, 5>, ::std::array<double, 5>, ::std::array<::std::string, 5>, ::std::array<::fidl::StringPtr, 5>)>;
      
  virtual void OneWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) = 0;
  using TwoWayArrayCompoundCallback =
      fit::function<void(::std::array<::test::typesinprotocols::Bits, 5>, ::std::array<::test::typesinprotocols::Enum, 5>, ::std::array<::test::typesinprotocols::Struct, 5>, ::std::array<::test::typesinprotocols::Table, 5>, ::std::array<::test::typesinprotocols::Union, 5>, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>)>;
      
  virtual void TwoWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union, TwoWayArrayCompoundCallback callback) = 0;
  using EventArrayCompoundCallback =
      fit::function<void(::std::array<::test::typesinprotocols::Bits, 5>, ::std::array<::test::typesinprotocols::Enum, 5>, ::std::array<::test::typesinprotocols::Struct, 5>, ::std::array<::test::typesinprotocols::Table, 5>, ::std::array<::test::typesinprotocols::Union, 5>, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>)>;
      
  virtual void OneWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) = 0;
  using TwoWayVectorBasicCallback =
      fit::function<void(::std::vector<uint8_t>, ::std::vector<uint16_t>, ::std::vector<uint32_t>, ::std::vector<uint64_t>, ::std::vector<int8_t>, ::std::vector<int16_t>, ::std::vector<int32_t>, ::std::vector<int64_t>, ::std::vector<float>, ::std::vector<double>, ::std::vector<::std::string>, ::std::vector<::fidl::StringPtr>)>;
      
  virtual void TwoWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string, TwoWayVectorBasicCallback callback) = 0;
  using EventVectorBasicCallback =
      fit::function<void(::std::vector<uint8_t>, ::std::vector<uint16_t>, ::std::vector<uint32_t>, ::std::vector<uint64_t>, ::std::vector<int8_t>, ::std::vector<int16_t>, ::std::vector<int32_t>, ::std::vector<int64_t>, ::std::vector<float>, ::std::vector<double>, ::std::vector<::std::string>, ::std::vector<::fidl::StringPtr>)>;
      
  virtual void OneWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) = 0;
  using TwoWayVectorCompoundCallback =
      fit::function<void(::std::vector<::test::typesinprotocols::Bits>, ::std::vector<::test::typesinprotocols::Enum>, ::std::vector<::test::typesinprotocols::Struct>, ::std::vector<::test::typesinprotocols::Table>, ::std::vector<::test::typesinprotocols::Union>, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>)>;
      
  virtual void TwoWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union, TwoWayVectorCompoundCallback callback) = 0;
  using EventVectorCompoundCallback =
      fit::function<void(::std::vector<::test::typesinprotocols::Bits>, ::std::vector<::test::typesinprotocols::Enum>, ::std::vector<::test::typesinprotocols::Struct>, ::std::vector<::test::typesinprotocols::Table>, ::std::vector<::test::typesinprotocols::Union>, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>)>;
      
  virtual void OneWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) = 0;
  using TwoWayVectorOptionalCallback =
      fit::function<void(::fidl::VectorPtr<uint8_t>, ::fidl::VectorPtr<::std::string>, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>)>;
      
  virtual void TwoWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct, TwoWayVectorOptionalCallback callback) = 0;
  using EventVectorOptionalCallback =
      fit::function<void(::fidl::VectorPtr<uint8_t>, ::fidl::VectorPtr<::std::string>, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>)>;
      
  virtual void OneWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) = 0;
  using TwoWayArrayVectorNestedCallback =
      fit::function<void(::std::array<::std::array<uint8_t, 5>, 5>, ::std::array<::std::vector<uint8_t>, 5>, ::std::vector<::std::array<uint8_t, 5>>, ::std::vector<::std::vector<uint8_t>>)>;
      
  virtual void TwoWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8, TwoWayArrayVectorNestedCallback callback) = 0;
  using EventArrayVectorNestedCallback =
      fit::function<void(::std::array<::std::array<uint8_t, 5>, 5>, ::std::array<::std::vector<uint8_t>, 5>, ::std::vector<::std::array<uint8_t, 5>>, ::std::vector<::std::vector<uint8_t>>)>;
      
  virtual void OneWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) = 0;
  using TwoWayResourceCallback =
      fit::function<void(::zx::handle, ::zx::vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, ::test::typesinprotocols::ResourceStruct, ::test::typesinprotocols::ResourceTable, ::test::typesinprotocols::ResourceUnion, ::zx::handle, ::zx::vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct>, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion>, ::std::array<::zx::handle, 5>, ::std::array<::zx::vmo, 5>, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>, ::std::array<::test::typesinprotocols::ResourceStruct, 5>, ::std::array<::test::typesinprotocols::ResourceTable, 5>, ::std::array<::test::typesinprotocols::ResourceUnion, 5>, ::std::vector<::zx::handle>, ::std::vector<::zx::vmo>, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>, ::std::vector<::test::typesinprotocols::ResourceStruct>, ::std::vector<::test::typesinprotocols::ResourceTable>, ::std::vector<::test::typesinprotocols::ResourceUnion>)>;
      
  virtual void TwoWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union, TwoWayResourceCallback callback) = 0;
  using EventResourceCallback =
      fit::function<void(::zx::handle, ::zx::vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, ::test::typesinprotocols::ResourceStruct, ::test::typesinprotocols::ResourceTable, ::test::typesinprotocols::ResourceUnion, ::zx::handle, ::zx::vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct>, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion>, ::std::array<::zx::handle, 5>, ::std::array<::zx::vmo, 5>, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>, ::std::array<::test::typesinprotocols::ResourceStruct, 5>, ::std::array<::test::typesinprotocols::ResourceTable, 5>, ::std::array<::test::typesinprotocols::ResourceUnion, 5>, ::std::vector<::zx::handle>, ::std::vector<::zx::vmo>, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>, ::std::vector<::test::typesinprotocols::ResourceStruct>, ::std::vector<::test::typesinprotocols::ResourceTable>, ::std::vector<::test::typesinprotocols::ResourceUnion>)>;

  
};

class Protocol_RequestDecoder {
 public:
  Protocol_RequestDecoder() = default;
  virtual ~Protocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response, bool* is_known);
  virtual void OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) = 0;
  virtual void TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) = 0;
  virtual void OneWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) = 0;
  virtual void TwoWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) = 0;
  virtual void OneWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) = 0;
  virtual void TwoWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) = 0;
  virtual void OneWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) = 0;
  virtual void TwoWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) = 0;
  virtual void OneWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) = 0;
  virtual void TwoWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) = 0;
  virtual void OneWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) = 0;
  virtual void TwoWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) = 0;
  virtual void OneWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) = 0;
  virtual void TwoWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) = 0;
  virtual void OneWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) = 0;
  virtual void TwoWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) = 0;
  virtual void OneWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) = 0;
  virtual void TwoWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) = 0;
};

class Protocol_ResponseDecoder {
 public:
  Protocol_ResponseDecoder() = default;
  virtual ~Protocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) = 0;
  virtual void EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) = 0;
  virtual void TwoWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) = 0;
  virtual void EventCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) = 0;
  virtual void TwoWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) = 0;
  virtual void EventArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) = 0;
  virtual void TwoWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) = 0;
  virtual void EventArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) = 0;
  virtual void TwoWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) = 0;
  virtual void EventVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) = 0;
  virtual void TwoWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) = 0;
  virtual void EventVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) = 0;
  virtual void TwoWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) = 0;
  virtual void EventVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) = 0;
  virtual void TwoWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) = 0;
  virtual void EventArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) = 0;
  virtual void TwoWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) = 0;
  virtual void EventResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) = 0;
};

class Protocol_EventSender {
 public:
  virtual ~Protocol_EventSender();
  virtual void EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) = 0;
  virtual void EventCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) = 0;
  virtual void EventArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) = 0;
  virtual void EventArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) = 0;
  virtual void EventVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) = 0;
  virtual void EventVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) = 0;
  virtual void EventVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) = 0;
  virtual void EventArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) = 0;
  virtual void EventResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) = 0;
};

class Protocol_Sync {
 public:
  using Proxy_ = ::test::typesinprotocols::Protocol_SyncProxy;
  virtual ~Protocol_Sync();
  virtual zx_status_t OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) = 0;
  virtual zx_status_t TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string, uint8_t* out_uint8, uint16_t* out_uint16, uint32_t* out_uint32, uint64_t* out_uint64, int8_t* out_int8, int16_t* out_int16, int32_t* out_int32, int64_t* out_int64, float* out_float32, double* out_float64, ::std::string* out_string, ::fidl::StringPtr* out_opt_string) = 0;
  virtual zx_status_t OneWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) = 0;
  virtual zx_status_t TwoWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union, ::test::typesinprotocols::Bits* out_bits, ::test::typesinprotocols::Enum* out_enum_, ::test::typesinprotocols::Struct* out_struct_, ::test::typesinprotocols::Table* out_table, ::test::typesinprotocols::Union* out_union_, ::std::unique_ptr<::test::typesinprotocols::Struct>* out_opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union>* out_opt_union) = 0;
  virtual zx_status_t OneWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) = 0;
  virtual zx_status_t TwoWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string, ::std::array<uint8_t, 5>* out_array_uint8, ::std::array<uint16_t, 5>* out_array_uint16, ::std::array<uint32_t, 5>* out_array_uint32, ::std::array<uint64_t, 5>* out_array_uint64, ::std::array<int8_t, 5>* out_array_int8, ::std::array<int16_t, 5>* out_array_int16, ::std::array<int32_t, 5>* out_array_int32, ::std::array<int64_t, 5>* out_array_int64, ::std::array<float, 5>* out_array_float32, ::std::array<double, 5>* out_array_float64, ::std::array<::std::string, 5>* out_array_string, ::std::array<::fidl::StringPtr, 5>* out_array_opt_string) = 0;
  virtual zx_status_t OneWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) = 0;
  virtual zx_status_t TwoWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union, ::std::array<::test::typesinprotocols::Bits, 5>* out_array_bits, ::std::array<::test::typesinprotocols::Enum, 5>* out_array_enum, ::std::array<::test::typesinprotocols::Struct, 5>* out_array_struct, ::std::array<::test::typesinprotocols::Table, 5>* out_array_table, ::std::array<::test::typesinprotocols::Union, 5>* out_array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>* out_array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>* out_array_opt_union) = 0;
  virtual zx_status_t OneWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) = 0;
  virtual zx_status_t TwoWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string, ::std::vector<uint8_t>* out_vector_uint8, ::std::vector<uint16_t>* out_vector_uint16, ::std::vector<uint32_t>* out_vector_uint32, ::std::vector<uint64_t>* out_vector_uint64, ::std::vector<int8_t>* out_vector_int8, ::std::vector<int16_t>* out_vector_int16, ::std::vector<int32_t>* out_vector_int32, ::std::vector<int64_t>* out_vector_int64, ::std::vector<float>* out_vector_float32, ::std::vector<double>* out_vector_float64, ::std::vector<::std::string>* out_vector_string, ::std::vector<::fidl::StringPtr>* out_vector_opt_string) = 0;
  virtual zx_status_t OneWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) = 0;
  virtual zx_status_t TwoWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union, ::std::vector<::test::typesinprotocols::Bits>* out_vector_bits, ::std::vector<::test::typesinprotocols::Enum>* out_vector_enum, ::std::vector<::test::typesinprotocols::Struct>* out_vector_struct, ::std::vector<::test::typesinprotocols::Table>* out_vector_table, ::std::vector<::test::typesinprotocols::Union>* out_vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>* out_vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>* out_vector_opt_union) = 0;
  virtual zx_status_t OneWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) = 0;
  virtual zx_status_t TwoWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct, ::fidl::VectorPtr<uint8_t>* out_opt_vector_uint8, ::fidl::VectorPtr<::std::string>* out_opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>* out_opt_vector_opt_struct) = 0;
  virtual zx_status_t OneWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) = 0;
  virtual zx_status_t TwoWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8, ::std::array<::std::array<uint8_t, 5>, 5>* out_array_array_uint8, ::std::array<::std::vector<uint8_t>, 5>* out_array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>>* out_vector_array_uint8, ::std::vector<::std::vector<uint8_t>>* out_vector_vector_uint8) = 0;
  virtual zx_status_t OneWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) = 0;
  virtual zx_status_t TwoWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union, ::zx::handle* out_handle, ::zx::vmo* out_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* out_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* out_server_end, ::test::typesinprotocols::ResourceStruct* out_struct_, ::test::typesinprotocols::ResourceTable* out_table, ::test::typesinprotocols::ResourceUnion* out_union_, ::zx::handle* out_opt_handle, ::zx::vmo* out_opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* out_opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* out_opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct>* out_opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion>* out_opt_union, ::std::array<::zx::handle, 5>* out_array_handle, ::std::array<::zx::vmo, 5>* out_array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>* out_array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>* out_array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5>* out_array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5>* out_array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5>* out_array_union, ::std::vector<::zx::handle>* out_vector_handle, ::std::vector<::zx::vmo>* out_vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>* out_vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>* out_vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct>* out_vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable>* out_vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion>* out_vector_union) = 0;
};

class Protocol_Proxy final : public ::fidl::internal::Proxy, public Protocol {
 public:
  explicit Protocol_Proxy(::fidl::internal::ProxyController* controller);
  ~Protocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayBasic
  void OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayBasic
  void TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string, TwoWayBasicCallback callback) override;
  EventBasicCallback EventBasic;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayCompound
  void OneWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayCompound
  void TwoWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union, TwoWayCompoundCallback callback) override;
  EventCompoundCallback EventCompound;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayArrayBasic
  void OneWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayArrayBasic
  void TwoWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string, TwoWayArrayBasicCallback callback) override;
  EventArrayBasicCallback EventArrayBasic;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayArrayCompound
  void OneWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayArrayCompound
  void TwoWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union, TwoWayArrayCompoundCallback callback) override;
  EventArrayCompoundCallback EventArrayCompound;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayVectorBasic
  void OneWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayVectorBasic
  void TwoWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string, TwoWayVectorBasicCallback callback) override;
  EventVectorBasicCallback EventVectorBasic;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayVectorCompound
  void OneWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayVectorCompound
  void TwoWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union, TwoWayVectorCompoundCallback callback) override;
  EventVectorCompoundCallback EventVectorCompound;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayVectorOptional
  void OneWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayVectorOptional
  void TwoWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct, TwoWayVectorOptionalCallback callback) override;
  EventVectorOptionalCallback EventVectorOptional;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayArrayVectorNested
  void OneWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayArrayVectorNested
  void TwoWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8, TwoWayArrayVectorNestedCallback callback) override;
  EventArrayVectorNestedCallback EventArrayVectorNested;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayResource
  void OneWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayResource
  void TwoWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union, TwoWayResourceCallback callback) override;
  EventResourceCallback EventResource;

  


 private:
  Protocol_Proxy(const ::test::typesinprotocols::Protocol_Proxy&) = delete;
  Protocol_Proxy& operator=(const ::test::typesinprotocols::Protocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class Protocol_Stub final : public ::fidl::internal::Stub, public ::test::typesinprotocols::Protocol_EventSender {
 public:
  typedef class ::test::typesinprotocols::Protocol Protocol_clazz;
  explicit Protocol_Stub(::test::typesinprotocols::Protocol_Stub::Protocol_clazz* impl);
  ~Protocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) override;
  void EventCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) override;
  void EventArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) override;
  void EventArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) override;
  void EventVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) override;
  void EventVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) override;
  void EventVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) override;
  void EventArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) override;
  void EventResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) override;

 private:
  ::test::typesinprotocols::Protocol_Stub::Protocol_clazz* impl_;
};

class Protocol_SyncProxy : public ::test::typesinprotocols::Protocol_Sync {
 public:
  explicit Protocol_SyncProxy(::zx::channel channel);
  ~Protocol_SyncProxy() override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayBasic
  zx_status_t OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayBasic
  zx_status_t TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string, uint8_t* out_uint8, uint16_t* out_uint16, uint32_t* out_uint32, uint64_t* out_uint64, int8_t* out_int8, int16_t* out_int16, int32_t* out_int32, int64_t* out_int64, float* out_float32, double* out_float64, ::std::string* out_string, ::fidl::StringPtr* out_opt_string) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayCompound
  zx_status_t OneWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayCompound
  zx_status_t TwoWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union, ::test::typesinprotocols::Bits* out_bits, ::test::typesinprotocols::Enum* out_enum_, ::test::typesinprotocols::Struct* out_struct_, ::test::typesinprotocols::Table* out_table, ::test::typesinprotocols::Union* out_union_, ::std::unique_ptr<::test::typesinprotocols::Struct>* out_opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union>* out_opt_union) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayArrayBasic
  zx_status_t OneWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayArrayBasic
  zx_status_t TwoWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string, ::std::array<uint8_t, 5>* out_array_uint8, ::std::array<uint16_t, 5>* out_array_uint16, ::std::array<uint32_t, 5>* out_array_uint32, ::std::array<uint64_t, 5>* out_array_uint64, ::std::array<int8_t, 5>* out_array_int8, ::std::array<int16_t, 5>* out_array_int16, ::std::array<int32_t, 5>* out_array_int32, ::std::array<int64_t, 5>* out_array_int64, ::std::array<float, 5>* out_array_float32, ::std::array<double, 5>* out_array_float64, ::std::array<::std::string, 5>* out_array_string, ::std::array<::fidl::StringPtr, 5>* out_array_opt_string) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayArrayCompound
  zx_status_t OneWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayArrayCompound
  zx_status_t TwoWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union, ::std::array<::test::typesinprotocols::Bits, 5>* out_array_bits, ::std::array<::test::typesinprotocols::Enum, 5>* out_array_enum, ::std::array<::test::typesinprotocols::Struct, 5>* out_array_struct, ::std::array<::test::typesinprotocols::Table, 5>* out_array_table, ::std::array<::test::typesinprotocols::Union, 5>* out_array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>* out_array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>* out_array_opt_union) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayVectorBasic
  zx_status_t OneWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayVectorBasic
  zx_status_t TwoWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string, ::std::vector<uint8_t>* out_vector_uint8, ::std::vector<uint16_t>* out_vector_uint16, ::std::vector<uint32_t>* out_vector_uint32, ::std::vector<uint64_t>* out_vector_uint64, ::std::vector<int8_t>* out_vector_int8, ::std::vector<int16_t>* out_vector_int16, ::std::vector<int32_t>* out_vector_int32, ::std::vector<int64_t>* out_vector_int64, ::std::vector<float>* out_vector_float32, ::std::vector<double>* out_vector_float64, ::std::vector<::std::string>* out_vector_string, ::std::vector<::fidl::StringPtr>* out_vector_opt_string) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayVectorCompound
  zx_status_t OneWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayVectorCompound
  zx_status_t TwoWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union, ::std::vector<::test::typesinprotocols::Bits>* out_vector_bits, ::std::vector<::test::typesinprotocols::Enum>* out_vector_enum, ::std::vector<::test::typesinprotocols::Struct>* out_vector_struct, ::std::vector<::test::typesinprotocols::Table>* out_vector_table, ::std::vector<::test::typesinprotocols::Union>* out_vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>* out_vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>* out_vector_opt_union) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayVectorOptional
  zx_status_t OneWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayVectorOptional
  zx_status_t TwoWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct, ::fidl::VectorPtr<uint8_t>* out_opt_vector_uint8, ::fidl::VectorPtr<::std::string>* out_opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>* out_opt_vector_opt_struct) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayArrayVectorNested
  zx_status_t OneWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayArrayVectorNested
  zx_status_t TwoWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8, ::std::array<::std::array<uint8_t, 5>, 5>* out_array_array_uint8, ::std::array<::std::vector<uint8_t>, 5>* out_array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>>* out_vector_array_uint8, ::std::vector<::std::vector<uint8_t>>* out_vector_vector_uint8) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.OneWayResource
  zx_status_t OneWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) override;
  // cts-coverage-fidl-name:test.typesinprotocols/Protocol.TwoWayResource
  zx_status_t TwoWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union, ::zx::handle* out_handle, ::zx::vmo* out_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* out_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* out_server_end, ::test::typesinprotocols::ResourceStruct* out_struct_, ::test::typesinprotocols::ResourceTable* out_table, ::test::typesinprotocols::ResourceUnion* out_union_, ::zx::handle* out_opt_handle, ::zx::vmo* out_opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* out_opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* out_opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct>* out_opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion>* out_opt_union, ::std::array<::zx::handle, 5>* out_array_handle, ::std::array<::zx::vmo, 5>* out_array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>* out_array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>* out_array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5>* out_array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5>* out_array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5>* out_array_union, ::std::vector<::zx::handle>* out_vector_handle, ::std::vector<::zx::vmo>* out_vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>* out_vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>* out_vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct>* out_vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable>* out_vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion>* out_vector_union) override;

  private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<Protocol>;
};

#endif  // __Fuchsia__

}  // namespace typesinprotocols
}  // namespace test


