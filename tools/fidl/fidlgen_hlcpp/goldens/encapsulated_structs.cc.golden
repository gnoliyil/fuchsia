// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#include <test/encapsulatedstructs/cpp/fidl.h>

#include "lib/fidl/cpp/internal/implementation.h"

//
// Domain objects definitions
//
namespace test {
namespace encapsulatedstructs {

extern "C" const fidl_type_t test_encapsulatedstructs_Int8Int32Table;
const fidl_type_t* Int8Int32::FidlType = &test_encapsulatedstructs_Int8Int32Table;

void Int8Int32::Encode(::fidl::Encoder* _encoder, size_t _offset,
                       cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Int8Int32>::value) {
    memcpy(_encoder->template GetPtr<Int8Int32>(_offset), this, sizeof(Int8Int32));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 4);
  }
}

void Int8Int32::Decode(::fidl::Decoder* _decoder, Int8Int32* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Int8Int32>::value) {
    memcpy(_value, _decoder->template GetPtr<Int8Int32>(_offset), sizeof(Int8Int32));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 4);
  }
}

zx_status_t Int8Int32::Clone(Int8Int32* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_encapsulatedstructs_Int16Int8Table;
const fidl_type_t* Int16Int8::FidlType = &test_encapsulatedstructs_Int16Int8Table;

void Int16Int8::Encode(::fidl::Encoder* _encoder, size_t _offset,
                       cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Int16Int8>::value) {
    memcpy(_encoder->template GetPtr<Int16Int8>(_offset), this, sizeof(Int16Int8));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 2);
  }
}

void Int16Int8::Decode(::fidl::Decoder* _decoder, Int16Int8* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Int16Int8>::value) {
    memcpy(_value, _decoder->template GetPtr<Int16Int8>(_offset), sizeof(Int16Int8));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 2);
  }
}

zx_status_t Int16Int8::Clone(Int16Int8* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_encapsulatedstructs_ArrayInt16Int8Table;
const fidl_type_t* ArrayInt16Int8::FidlType = &test_encapsulatedstructs_ArrayInt16Int8Table;

void ArrayInt16Int8::Encode(::fidl::Encoder* _encoder, size_t _offset,
                            cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ArrayInt16Int8>::value) {
    memcpy(_encoder->template GetPtr<ArrayInt16Int8>(_offset), this, sizeof(ArrayInt16Int8));
  } else {
    ::fidl::Encode(_encoder, &arr, _offset + 0);
  }
}

void ArrayInt16Int8::Decode(::fidl::Decoder* _decoder, ArrayInt16Int8* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ArrayInt16Int8>::value) {
    memcpy(_value, _decoder->template GetPtr<ArrayInt16Int8>(_offset), sizeof(ArrayInt16Int8));
  } else {
    ::fidl::Decode(_decoder, &_value->arr, _offset + 0);
  }
}

zx_status_t ArrayInt16Int8::Clone(ArrayInt16Int8* _result) const {
  zx_status_t _status = ::fidl::Clone(arr, &_result->arr);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

extern "C" const fidl_type_t test_encapsulatedstructs_StructPaddingTestStructTable;
const fidl_type_t* StructPaddingTestStruct::FidlType = &test_encapsulatedstructs_StructPaddingTestStructTable;

void StructPaddingTestStruct::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<StructPaddingTestStruct>::value) {
    memcpy(_encoder->template GetPtr<StructPaddingTestStruct>(_offset), this, sizeof(StructPaddingTestStruct));
  } else {
    ::fidl::Encode(_encoder, &trailing, _offset + 0);
    ::fidl::Encode(_encoder, &inner, _offset + 4);
    ::fidl::Encode(_encoder, &array, _offset + 12);
  }
}

void StructPaddingTestStruct::Decode(::fidl::Decoder* _decoder, StructPaddingTestStruct* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<StructPaddingTestStruct>::value) {
    memcpy(_value, _decoder->template GetPtr<StructPaddingTestStruct>(_offset), sizeof(StructPaddingTestStruct));
  } else {
    ::fidl::Decode(_decoder, &_value->trailing, _offset + 0);
    ::fidl::Decode(_decoder, &_value->inner, _offset + 4);
    ::fidl::Decode(_decoder, &_value->array, _offset + 12);
  }
}

zx_status_t StructPaddingTestStruct::Clone(StructPaddingTestStruct* _result) const {
  zx_status_t _status = ::fidl::Clone(trailing, &_result->trailing);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(inner, &_result->inner);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array, &_result->array);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_encapsulatedstructs_NonInlineStructTestStructTable;
const fidl_type_t* NonInlineStructTestStruct::FidlType = &test_encapsulatedstructs_NonInlineStructTestStructTable;

void NonInlineStructTestStruct::Encode(::fidl::Encoder* _encoder, size_t _offset,
                                       cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<NonInlineStructTestStruct>::value) {
    memcpy(_encoder->template GetPtr<NonInlineStructTestStruct>(_offset), this, sizeof(NonInlineStructTestStruct));
  } else {
    ::fidl::Encode(_encoder, &element, _offset + 0);

    ::fidl::Encode(_encoder, &h, _offset + 8, ::fidl::HandleInformation{
                                                  .object_type = ZX_OBJ_TYPE_NONE,
                                                  .rights = 0x80000000,
                                              });
  }
}

void NonInlineStructTestStruct::Decode(::fidl::Decoder* _decoder, NonInlineStructTestStruct* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<NonInlineStructTestStruct>::value) {
    memcpy(_value, _decoder->template GetPtr<NonInlineStructTestStruct>(_offset), sizeof(NonInlineStructTestStruct));
  } else {
    ::fidl::Decode(_decoder, &_value->element, _offset + 0);
    ::fidl::Decode(_decoder, &_value->h, _offset + 8);
  }
}

zx_status_t NonInlineStructTestStruct::Clone(NonInlineStructTestStruct* _result) const {
  zx_status_t _status = ::fidl::Clone(element, &_result->element);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(h, &_result->h);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_encapsulatedstructs_TopLevelStructTable;
const fidl_type_t* TopLevelStruct::FidlType = &test_encapsulatedstructs_TopLevelStructTable;

void TopLevelStruct::Encode(::fidl::Encoder* _encoder, size_t _offset,
                            cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<TopLevelStruct>::value) {
    memcpy(_encoder->template GetPtr<TopLevelStruct>(_offset), this, sizeof(TopLevelStruct));
  } else {
    ::fidl::Encode(_encoder, &a, _offset + 0);
    ::fidl::Encode(_encoder, &b, _offset + 24);
  }
}

void TopLevelStruct::Decode(::fidl::Decoder* _decoder, TopLevelStruct* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<TopLevelStruct>::value) {
    memcpy(_value, _decoder->template GetPtr<TopLevelStruct>(_offset), sizeof(TopLevelStruct));
  } else {
    ::fidl::Decode(_decoder, &_value->a, _offset + 0);
    ::fidl::Decode(_decoder, &_value->b, _offset + 24);
  }
}

zx_status_t TopLevelStruct::Clone(TopLevelStruct* _result) const {
  zx_status_t _status = ::fidl::Clone(a, &_result->a);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(b, &_result->b);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

#endif  // __Fuchsia__

//
// Proxies and stubs definitions
//

}  // namespace encapsulatedstructs
}  // namespace test
