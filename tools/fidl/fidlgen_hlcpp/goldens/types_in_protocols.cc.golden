// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#include <test/typesinprotocols/cpp/fidl.h>

#include "lib/fidl/cpp/internal/implementation.h"


//
// Domain objects definitions
//
namespace test {
namespace typesinprotocols {

#if (__cplusplus < 201703)
constexpr const ::test::typesinprotocols::Bits Bits::VAL = ::test::typesinprotocols::Bits(1u);
constexpr const ::test::typesinprotocols::Bits Bits::kMask = ::test::typesinprotocols::Bits(1u);

#endif  // (__cplusplus < 201703)


#if (__cplusplus < 201703)
constexpr const ::test::typesinprotocols::Enum Enum::VAL = ::test::typesinprotocols::Enum(1u);
#endif  // (__cplusplus < 201703)


extern "C" const fidl_type_t test_typesinprotocols_StructTable;
const fidl_type_t* Struct::FidlType = &test_typesinprotocols_StructTable;

void Struct::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Struct>::value) {
    memcpy(_encoder->template GetPtr<Struct>(_offset), this, sizeof(Struct));
  } else {::fidl::Encode(_encoder, &__reserved, _offset + 0);
    
  }
}

void Struct::Decode(::fidl::Decoder* _decoder, Struct* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Struct>::value) {
    memcpy(_value, _decoder->template GetPtr<Struct>(_offset), sizeof(Struct));
  } else {
    ::fidl::Decode(_decoder, &_value->__reserved, _offset + 0);
  }
}

zx_status_t Struct::Clone(Struct* _result) const {
  zx_status_t _status = ::fidl::Clone(__reserved, &_result->__reserved);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_TableTable;
const fidl_type_t* Table::FidlType = &test_typesinprotocols_TableTable;

Table::Table() {}

Table::Table(Table&& other) {
  field_presence_ = other.field_presence_;
}

Table::~Table() {
}

Table& Table::operator=(Table&& other) {
  return *this;
}

bool Table::IsEmpty() const {
  return field_presence_.IsEmpty();
}

void Table::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
}

void Table::Decode(::fidl::Decoder* _decoder, Table* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;

  

  return;

  // Clear unset values.
clear_all:
  return;
}

zx_status_t Table::Clone(Table* result) const {
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_UnionTable;
const fidl_type_t* Union::FidlType = &test_typesinprotocols_UnionTable;

Union::Union() {}

Union::~Union() {
  Destroy();
}

Union::Union(Union&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::typesinprotocols::Union::Tag::kB:
      b_ = std::move(other.b_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Union::Tag::Invalid):
      break;
    default:
      new (&unknown_data_) decltype(unknown_data_);
      unknown_data_ = std::move(other.unknown_data_);
      break;
  }
}

Union& Union::operator=(Union&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::typesinprotocols::Union::Tag::kB:
        b_ = std::move(other.b_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Union::Tag::Invalid):
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        unknown_data_= std::move(other.unknown_data_);
        break;
    }
  }
  return *this;
}

Union Union::WithB(bool&& val) {
  Union result;
  result.set_b(std::move(val));
  return result;
}


void Union::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::typesinprotocols::Union::Tag::kB: {
      if (::fidl::EncodingInlineSize<bool>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &b_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &b_,
        encoder->Alloc(::fidl::EncodingInlineSize<bool, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::typesinprotocols::Union::Tag::kUnknown: {
      ::fidl::EncodeUnknownBytes(encoder, &unknown_data_, offset + offsetof(fidl_xunion_t, envelope));
      *encoder->GetPtr<uint64_t>(offset) = tag_;
      break;
    }
    default:
      break;
  }
}

void Union::Decode(::fidl::Decoder* _decoder, Union* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Union::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::typesinprotocols::Union::Tag::kB: {
      ::fidl::Decode(_decoder, &value->b_, value_offset);
      break;
    }
    default: {
  auto unknown_info = _decoder->EnvelopeUnknownDataInfo(&xunion->envelope);
      value->unknown_data_.resize(unknown_info.num_bytes);
      ::fidl::DecodeUnknownBytesContents(_decoder, &value->unknown_data_, unknown_info.value_offset);
  break;
    }
  }

}

zx_status_t Union::Clone(Union* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::typesinprotocols::Union::Tag::Invalid:
      return ZX_OK;
    case ::test::typesinprotocols::Union::Tag::kB:
      return ::fidl::Clone(b_, &result->b_);
    default:
      new (&result->unknown_data_) decltype(unknown_data_);
      return ::fidl::Clone(unknown_data_, &result->unknown_data_);
    return ZX_OK;
  }
}

Union& Union::set_b(bool value) {
  EnsureStorageInitialized(::test::typesinprotocols::Union::Tag::kB);
  b_ = std::move(value);
  return *this;
}
Union& Union::SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes) {
  EnsureStorageInitialized(ordinal);
  unknown_data_ = std::move(bytes);
  return *this;
}

void Union::Destroy() {
  switch (tag_) {
    case ::test::typesinprotocols::Union::Tag::kB:
      break;
  
    case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Union::Tag::Invalid):
      break;
    default:
      unknown_data_.~decltype(unknown_data_)();
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Union::Tag::Invalid);
}

void Union::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Union::Tag::Invalid):
        break;
      case ::test::typesinprotocols::Union::Tag::kB:
        new (&b_) bool();
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        break;
    }
  }
}


#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ResourceStructTable;
const fidl_type_t* ResourceStruct::FidlType = &test_typesinprotocols_ResourceStructTable;

void ResourceStruct::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ResourceStruct>::value) {
    memcpy(_encoder->template GetPtr<ResourceStruct>(_offset), this, sizeof(ResourceStruct));
  } else {::fidl::Encode(_encoder, &__reserved, _offset + 0);
    
  }
}

void ResourceStruct::Decode(::fidl::Decoder* _decoder, ResourceStruct* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ResourceStruct>::value) {
    memcpy(_value, _decoder->template GetPtr<ResourceStruct>(_offset), sizeof(ResourceStruct));
  } else {
    ::fidl::Decode(_decoder, &_value->__reserved, _offset + 0);
  }
}

zx_status_t ResourceStruct::Clone(ResourceStruct* _result) const {
  zx_status_t _status = ::fidl::Clone(__reserved, &_result->__reserved);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ResourceTableTable;
const fidl_type_t* ResourceTable::FidlType = &test_typesinprotocols_ResourceTableTable;

ResourceTable::ResourceTable() {}

ResourceTable::ResourceTable(ResourceTable&& other) {
  field_presence_ = other.field_presence_;
}

ResourceTable::~ResourceTable() {
}

ResourceTable& ResourceTable::operator=(ResourceTable&& other) {
  return *this;
}

bool ResourceTable::IsEmpty() const {
  return field_presence_.IsEmpty();
}

void ResourceTable::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
}

void ResourceTable::Decode(::fidl::Decoder* _decoder, ResourceTable* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;

  
  if (count > 0) {
    for (uint64_t ordinal = 1; ordinal <= count; ordinal++) {
      if (IsOrdinalKnown(ordinal)) {
        continue;
      }

      size_t envelope_base = base + (ordinal - 1) * sizeof(fidl_envelope_v2_t);
      fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      _decoder->CloseUnknownHandlesInEnvelope(envelope);
    }
  }

  return;

  // Clear unset values.
clear_all:
  return;
}

zx_status_t ResourceTable::Clone(ResourceTable* result) const {
  return ZX_OK;
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ResourceUnionTable;
const fidl_type_t* ResourceUnion::FidlType = &test_typesinprotocols_ResourceUnionTable;

ResourceUnion::ResourceUnion() {}

ResourceUnion::~ResourceUnion() {
  Destroy();
}

ResourceUnion::ResourceUnion(ResourceUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::typesinprotocols::ResourceUnion::Tag::kB:
      b_ = std::move(other.b_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::ResourceUnion::Tag::Invalid):
      break;
    default:
      new (&unknown_data_) decltype(unknown_data_);
      unknown_data_ = std::move(other.unknown_data_);
      break;
  }
}

ResourceUnion& ResourceUnion::operator=(ResourceUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::typesinprotocols::ResourceUnion::Tag::kB:
        b_ = std::move(other.b_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::ResourceUnion::Tag::Invalid):
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        unknown_data_= std::move(other.unknown_data_);
        break;
    }
  }
  return *this;
}

ResourceUnion ResourceUnion::WithB(bool&& val) {
  ResourceUnion result;
  result.set_b(std::move(val));
  return result;
}


void ResourceUnion::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::typesinprotocols::ResourceUnion::Tag::kB: {
      if (::fidl::EncodingInlineSize<bool>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &b_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &b_,
        encoder->Alloc(::fidl::EncodingInlineSize<bool, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::typesinprotocols::ResourceUnion::Tag::kUnknown: {
      ::fidl::EncodeUnknownData(encoder, &unknown_data_, offset + offsetof(fidl_xunion_t, envelope));
      *encoder->GetPtr<uint64_t>(offset) = tag_;
      break;
    }
    default:
      break;
  }
}

void ResourceUnion::Decode(::fidl::Decoder* _decoder, ResourceUnion* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::ResourceUnion::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::typesinprotocols::ResourceUnion::Tag::kB: {
      ::fidl::Decode(_decoder, &value->b_, value_offset);
      break;
    }
    default: {
  auto unknown_info = _decoder->EnvelopeUnknownDataInfo(&xunion->envelope);
      value->unknown_data_.bytes.resize(unknown_info.num_bytes);
      value->unknown_data_.handles.resize(unknown_info.num_handles);
      ::fidl::DecodeUnknownDataContents(_decoder, &value->unknown_data_, unknown_info.value_offset);
  break;
    }
  }

}

zx_status_t ResourceUnion::Clone(ResourceUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::typesinprotocols::ResourceUnion::Tag::Invalid:
      return ZX_OK;
    case ::test::typesinprotocols::ResourceUnion::Tag::kB:
      return ::fidl::Clone(b_, &result->b_);
    default:
      new (&result->unknown_data_) decltype(unknown_data_);
      return ::fidl::Clone(unknown_data_, &result->unknown_data_);
    return ZX_OK;
  }
}

ResourceUnion& ResourceUnion::set_b(bool value) {
  EnsureStorageInitialized(::test::typesinprotocols::ResourceUnion::Tag::kB);
  b_ = std::move(value);
  return *this;
}
ResourceUnion& ResourceUnion::SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes, std::vector<zx::handle> handles) {
  EnsureStorageInitialized(ordinal);
  unknown_data_.bytes = std::move(bytes);
  unknown_data_.handles = std::move(handles);
  return *this;
}

void ResourceUnion::Destroy() {
  switch (tag_) {
    case ::test::typesinprotocols::ResourceUnion::Tag::kB:
      break;
  
    case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::ResourceUnion::Tag::Invalid):
      break;
    default:
      unknown_data_.~decltype(unknown_data_)();
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::ResourceUnion::Tag::Invalid);
}

void ResourceUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::ResourceUnion::Tag::Invalid):
        break;
      case ::test::typesinprotocols::ResourceUnion::Tag::kB:
        new (&b_) bool();
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        break;
    }
  }
}

#endif  // __Fuchsia__



extern "C" const fidl_type_t test_typesinprotocols_BasicTable;
const fidl_type_t* Basic::FidlType = &test_typesinprotocols_BasicTable;

void Basic::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Basic>::value) {
    memcpy(_encoder->template GetPtr<Basic>(_offset), this, sizeof(Basic));
  } else {::fidl::Encode(_encoder, &uint8, _offset + 0);
    ::fidl::Encode(_encoder, &uint16, _offset + 2);
    ::fidl::Encode(_encoder, &uint32, _offset + 4);
    ::fidl::Encode(_encoder, &uint64, _offset + 8);
    ::fidl::Encode(_encoder, &int8, _offset + 16);
    ::fidl::Encode(_encoder, &int16, _offset + 18);
    ::fidl::Encode(_encoder, &int32, _offset + 20);
    ::fidl::Encode(_encoder, &int64, _offset + 24);
    ::fidl::Encode(_encoder, &float32, _offset + 32);
    ::fidl::Encode(_encoder, &float64, _offset + 40);
    ::fidl::Encode(_encoder, &string, _offset + 48);
    ::fidl::Encode(_encoder, &opt_string, _offset + 64);
    
  }
}

void Basic::Decode(::fidl::Decoder* _decoder, Basic* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Basic>::value) {
    memcpy(_value, _decoder->template GetPtr<Basic>(_offset), sizeof(Basic));
  } else {
    ::fidl::Decode(_decoder, &_value->uint8, _offset + 0);
    ::fidl::Decode(_decoder, &_value->uint16, _offset + 2);
    ::fidl::Decode(_decoder, &_value->uint32, _offset + 4);
    ::fidl::Decode(_decoder, &_value->uint64, _offset + 8);
    ::fidl::Decode(_decoder, &_value->int8, _offset + 16);
    ::fidl::Decode(_decoder, &_value->int16, _offset + 18);
    ::fidl::Decode(_decoder, &_value->int32, _offset + 20);
    ::fidl::Decode(_decoder, &_value->int64, _offset + 24);
    ::fidl::Decode(_decoder, &_value->float32, _offset + 32);
    ::fidl::Decode(_decoder, &_value->float64, _offset + 40);
    ::fidl::Decode(_decoder, &_value->string, _offset + 48);
    ::fidl::Decode(_decoder, &_value->opt_string, _offset + 64);
  }
}

zx_status_t Basic::Clone(Basic* _result) const {
  zx_status_t _status = ::fidl::Clone(uint8, &_result->uint8);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(uint16, &_result->uint16);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(uint32, &_result->uint32);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(uint64, &_result->uint64);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(int8, &_result->int8);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(int16, &_result->int16);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(int32, &_result->int32);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(int64, &_result->int64);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(float32, &_result->float32);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(float64, &_result->float64);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(string, &_result->string);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(opt_string, &_result->opt_string);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_CompoundTable;
const fidl_type_t* Compound::FidlType = &test_typesinprotocols_CompoundTable;

void Compound::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Compound>::value) {
    memcpy(_encoder->template GetPtr<Compound>(_offset), this, sizeof(Compound));
  } else {::fidl::Encode(_encoder, &bits, _offset + 0);
    ::fidl::Encode(_encoder, &enum_, _offset + 4);
    ::fidl::Encode(_encoder, &struct_, _offset + 8);
    ::fidl::Encode(_encoder, &table, _offset + 16);
    ::fidl::Encode(_encoder, &union_, _offset + 32);
    ::fidl::Encode(_encoder, &opt_struct, _offset + 48);
    ::fidl::Encode(_encoder, &opt_union, _offset + 56);
    
  }
}

void Compound::Decode(::fidl::Decoder* _decoder, Compound* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Compound>::value) {
    memcpy(_value, _decoder->template GetPtr<Compound>(_offset), sizeof(Compound));
  } else {
    ::fidl::Decode(_decoder, &_value->bits, _offset + 0);
    ::fidl::Decode(_decoder, &_value->enum_, _offset + 4);
    ::fidl::Decode(_decoder, &_value->struct_, _offset + 8);
    ::fidl::Decode(_decoder, &_value->table, _offset + 16);
    ::fidl::Decode(_decoder, &_value->union_, _offset + 32);
    ::fidl::Decode(_decoder, &_value->opt_struct, _offset + 48);
    ::fidl::Decode(_decoder, &_value->opt_union, _offset + 56);
  }
}

zx_status_t Compound::Clone(Compound* _result) const {
  zx_status_t _status = ::fidl::Clone(bits, &_result->bits);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(enum_, &_result->enum_);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(struct_, &_result->struct_);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(table, &_result->table);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(union_, &_result->union_);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(opt_struct, &_result->opt_struct);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(opt_union, &_result->opt_union);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_ArrayBasicTable;
const fidl_type_t* ArrayBasic::FidlType = &test_typesinprotocols_ArrayBasicTable;

void ArrayBasic::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ArrayBasic>::value) {
    memcpy(_encoder->template GetPtr<ArrayBasic>(_offset), this, sizeof(ArrayBasic));
  } else {::fidl::Encode(_encoder, &array_uint8, _offset + 0);
    ::fidl::Encode(_encoder, &array_uint16, _offset + 6);
    ::fidl::Encode(_encoder, &array_uint32, _offset + 16);
    ::fidl::Encode(_encoder, &array_uint64, _offset + 40);
    ::fidl::Encode(_encoder, &array_int8, _offset + 80);
    ::fidl::Encode(_encoder, &array_int16, _offset + 86);
    ::fidl::Encode(_encoder, &array_int32, _offset + 96);
    ::fidl::Encode(_encoder, &array_int64, _offset + 120);
    ::fidl::Encode(_encoder, &array_float32, _offset + 160);
    ::fidl::Encode(_encoder, &array_float64, _offset + 184);
    ::fidl::Encode(_encoder, &array_string, _offset + 224);
    ::fidl::Encode(_encoder, &array_opt_string, _offset + 304);
    
  }
}

void ArrayBasic::Decode(::fidl::Decoder* _decoder, ArrayBasic* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ArrayBasic>::value) {
    memcpy(_value, _decoder->template GetPtr<ArrayBasic>(_offset), sizeof(ArrayBasic));
  } else {
    ::fidl::Decode(_decoder, &_value->array_uint8, _offset + 0);
    ::fidl::Decode(_decoder, &_value->array_uint16, _offset + 6);
    ::fidl::Decode(_decoder, &_value->array_uint32, _offset + 16);
    ::fidl::Decode(_decoder, &_value->array_uint64, _offset + 40);
    ::fidl::Decode(_decoder, &_value->array_int8, _offset + 80);
    ::fidl::Decode(_decoder, &_value->array_int16, _offset + 86);
    ::fidl::Decode(_decoder, &_value->array_int32, _offset + 96);
    ::fidl::Decode(_decoder, &_value->array_int64, _offset + 120);
    ::fidl::Decode(_decoder, &_value->array_float32, _offset + 160);
    ::fidl::Decode(_decoder, &_value->array_float64, _offset + 184);
    ::fidl::Decode(_decoder, &_value->array_string, _offset + 224);
    ::fidl::Decode(_decoder, &_value->array_opt_string, _offset + 304);
  }
}

zx_status_t ArrayBasic::Clone(ArrayBasic* _result) const {
  zx_status_t _status = ::fidl::Clone(array_uint8, &_result->array_uint8);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_uint16, &_result->array_uint16);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_uint32, &_result->array_uint32);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_uint64, &_result->array_uint64);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_int8, &_result->array_int8);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_int16, &_result->array_int16);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_int32, &_result->array_int32);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_int64, &_result->array_int64);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_float32, &_result->array_float32);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_float64, &_result->array_float64);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_string, &_result->array_string);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_opt_string, &_result->array_opt_string);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_ArrayCompoundTable;
const fidl_type_t* ArrayCompound::FidlType = &test_typesinprotocols_ArrayCompoundTable;

void ArrayCompound::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ArrayCompound>::value) {
    memcpy(_encoder->template GetPtr<ArrayCompound>(_offset), this, sizeof(ArrayCompound));
  } else {::fidl::Encode(_encoder, &array_bits, _offset + 0);
    ::fidl::Encode(_encoder, &array_enum, _offset + 20);
    ::fidl::Encode(_encoder, &array_struct, _offset + 40);
    ::fidl::Encode(_encoder, &array_table, _offset + 48);
    ::fidl::Encode(_encoder, &array_union, _offset + 128);
    ::fidl::Encode(_encoder, &array_opt_struct, _offset + 208);
    ::fidl::Encode(_encoder, &array_opt_union, _offset + 248);
    
  }
}

void ArrayCompound::Decode(::fidl::Decoder* _decoder, ArrayCompound* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ArrayCompound>::value) {
    memcpy(_value, _decoder->template GetPtr<ArrayCompound>(_offset), sizeof(ArrayCompound));
  } else {
    ::fidl::Decode(_decoder, &_value->array_bits, _offset + 0);
    ::fidl::Decode(_decoder, &_value->array_enum, _offset + 20);
    ::fidl::Decode(_decoder, &_value->array_struct, _offset + 40);
    ::fidl::Decode(_decoder, &_value->array_table, _offset + 48);
    ::fidl::Decode(_decoder, &_value->array_union, _offset + 128);
    ::fidl::Decode(_decoder, &_value->array_opt_struct, _offset + 208);
    ::fidl::Decode(_decoder, &_value->array_opt_union, _offset + 248);
  }
}

zx_status_t ArrayCompound::Clone(ArrayCompound* _result) const {
  zx_status_t _status = ::fidl::Clone(array_bits, &_result->array_bits);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_enum, &_result->array_enum);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_struct, &_result->array_struct);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_table, &_result->array_table);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_union, &_result->array_union);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_opt_struct, &_result->array_opt_struct);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_opt_union, &_result->array_opt_union);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_VectorBasicTable;
const fidl_type_t* VectorBasic::FidlType = &test_typesinprotocols_VectorBasicTable;

void VectorBasic::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<VectorBasic>::value) {
    memcpy(_encoder->template GetPtr<VectorBasic>(_offset), this, sizeof(VectorBasic));
  } else {::fidl::Encode(_encoder, &vector_uint8, _offset + 0);
    ::fidl::Encode(_encoder, &vector_uint16, _offset + 16);
    ::fidl::Encode(_encoder, &vector_uint32, _offset + 32);
    ::fidl::Encode(_encoder, &vector_uint64, _offset + 48);
    ::fidl::Encode(_encoder, &vector_int8, _offset + 64);
    ::fidl::Encode(_encoder, &vector_int16, _offset + 80);
    ::fidl::Encode(_encoder, &vector_int32, _offset + 96);
    ::fidl::Encode(_encoder, &vector_int64, _offset + 112);
    ::fidl::Encode(_encoder, &vector_float32, _offset + 128);
    ::fidl::Encode(_encoder, &vector_float64, _offset + 144);
    ::fidl::Encode(_encoder, &vector_string, _offset + 160);
    ::fidl::Encode(_encoder, &vector_opt_string, _offset + 176);
    
  }
}

void VectorBasic::Decode(::fidl::Decoder* _decoder, VectorBasic* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<VectorBasic>::value) {
    memcpy(_value, _decoder->template GetPtr<VectorBasic>(_offset), sizeof(VectorBasic));
  } else {
    ::fidl::Decode(_decoder, &_value->vector_uint8, _offset + 0);
    ::fidl::Decode(_decoder, &_value->vector_uint16, _offset + 16);
    ::fidl::Decode(_decoder, &_value->vector_uint32, _offset + 32);
    ::fidl::Decode(_decoder, &_value->vector_uint64, _offset + 48);
    ::fidl::Decode(_decoder, &_value->vector_int8, _offset + 64);
    ::fidl::Decode(_decoder, &_value->vector_int16, _offset + 80);
    ::fidl::Decode(_decoder, &_value->vector_int32, _offset + 96);
    ::fidl::Decode(_decoder, &_value->vector_int64, _offset + 112);
    ::fidl::Decode(_decoder, &_value->vector_float32, _offset + 128);
    ::fidl::Decode(_decoder, &_value->vector_float64, _offset + 144);
    ::fidl::Decode(_decoder, &_value->vector_string, _offset + 160);
    ::fidl::Decode(_decoder, &_value->vector_opt_string, _offset + 176);
  }
}

zx_status_t VectorBasic::Clone(VectorBasic* _result) const {
  zx_status_t _status = ::fidl::Clone(vector_uint8, &_result->vector_uint8);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_uint16, &_result->vector_uint16);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_uint32, &_result->vector_uint32);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_uint64, &_result->vector_uint64);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_int8, &_result->vector_int8);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_int16, &_result->vector_int16);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_int32, &_result->vector_int32);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_int64, &_result->vector_int64);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_float32, &_result->vector_float32);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_float64, &_result->vector_float64);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_string, &_result->vector_string);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_opt_string, &_result->vector_opt_string);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_VectorCompoundTable;
const fidl_type_t* VectorCompound::FidlType = &test_typesinprotocols_VectorCompoundTable;

void VectorCompound::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<VectorCompound>::value) {
    memcpy(_encoder->template GetPtr<VectorCompound>(_offset), this, sizeof(VectorCompound));
  } else {::fidl::Encode(_encoder, &vector_bits, _offset + 0);
    ::fidl::Encode(_encoder, &vector_enum, _offset + 16);
    ::fidl::Encode(_encoder, &vector_struct, _offset + 32);
    ::fidl::Encode(_encoder, &vector_table, _offset + 48);
    ::fidl::Encode(_encoder, &vector_union, _offset + 64);
    ::fidl::Encode(_encoder, &vector_opt_struct, _offset + 80);
    ::fidl::Encode(_encoder, &vector_opt_union, _offset + 96);
    
  }
}

void VectorCompound::Decode(::fidl::Decoder* _decoder, VectorCompound* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<VectorCompound>::value) {
    memcpy(_value, _decoder->template GetPtr<VectorCompound>(_offset), sizeof(VectorCompound));
  } else {
    ::fidl::Decode(_decoder, &_value->vector_bits, _offset + 0);
    ::fidl::Decode(_decoder, &_value->vector_enum, _offset + 16);
    ::fidl::Decode(_decoder, &_value->vector_struct, _offset + 32);
    ::fidl::Decode(_decoder, &_value->vector_table, _offset + 48);
    ::fidl::Decode(_decoder, &_value->vector_union, _offset + 64);
    ::fidl::Decode(_decoder, &_value->vector_opt_struct, _offset + 80);
    ::fidl::Decode(_decoder, &_value->vector_opt_union, _offset + 96);
  }
}

zx_status_t VectorCompound::Clone(VectorCompound* _result) const {
  zx_status_t _status = ::fidl::Clone(vector_bits, &_result->vector_bits);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_enum, &_result->vector_enum);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_struct, &_result->vector_struct);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_table, &_result->vector_table);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_union, &_result->vector_union);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_opt_struct, &_result->vector_opt_struct);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_opt_union, &_result->vector_opt_union);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_VectorOptionalTable;
const fidl_type_t* VectorOptional::FidlType = &test_typesinprotocols_VectorOptionalTable;

void VectorOptional::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<VectorOptional>::value) {
    memcpy(_encoder->template GetPtr<VectorOptional>(_offset), this, sizeof(VectorOptional));
  } else {::fidl::Encode(_encoder, &opt_vector_uint8, _offset + 0);
    ::fidl::Encode(_encoder, &opt_vector_string, _offset + 16);
    ::fidl::Encode(_encoder, &opt_vector_opt_struct, _offset + 48);
    
  }
}

void VectorOptional::Decode(::fidl::Decoder* _decoder, VectorOptional* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<VectorOptional>::value) {
    memcpy(_value, _decoder->template GetPtr<VectorOptional>(_offset), sizeof(VectorOptional));
  } else {
    ::fidl::Decode(_decoder, &_value->opt_vector_uint8, _offset + 0);
    ::fidl::Decode(_decoder, &_value->opt_vector_string, _offset + 16);
    ::fidl::Decode(_decoder, &_value->opt_vector_opt_struct, _offset + 48);
  }
}

zx_status_t VectorOptional::Clone(VectorOptional* _result) const {
  zx_status_t _status = ::fidl::Clone(opt_vector_uint8, &_result->opt_vector_uint8);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(opt_vector_string, &_result->opt_vector_string);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(opt_vector_opt_struct, &_result->opt_vector_opt_struct);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_ArrayVectorNestedTable;
const fidl_type_t* ArrayVectorNested::FidlType = &test_typesinprotocols_ArrayVectorNestedTable;

void ArrayVectorNested::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ArrayVectorNested>::value) {
    memcpy(_encoder->template GetPtr<ArrayVectorNested>(_offset), this, sizeof(ArrayVectorNested));
  } else {::fidl::Encode(_encoder, &array_array_uint8, _offset + 0);
    ::fidl::Encode(_encoder, &array_vector_uint8, _offset + 32);
    ::fidl::Encode(_encoder, &vector_array_uint8, _offset + 112);
    ::fidl::Encode(_encoder, &vector_vector_uint8, _offset + 128);
    
  }
}

void ArrayVectorNested::Decode(::fidl::Decoder* _decoder, ArrayVectorNested* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ArrayVectorNested>::value) {
    memcpy(_value, _decoder->template GetPtr<ArrayVectorNested>(_offset), sizeof(ArrayVectorNested));
  } else {
    ::fidl::Decode(_decoder, &_value->array_array_uint8, _offset + 0);
    ::fidl::Decode(_decoder, &_value->array_vector_uint8, _offset + 32);
    ::fidl::Decode(_decoder, &_value->vector_array_uint8, _offset + 112);
    ::fidl::Decode(_decoder, &_value->vector_vector_uint8, _offset + 128);
  }
}

zx_status_t ArrayVectorNested::Clone(ArrayVectorNested* _result) const {
  zx_status_t _status = ::fidl::Clone(array_array_uint8, &_result->array_array_uint8);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_vector_uint8, &_result->array_vector_uint8);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_array_uint8, &_result->vector_array_uint8);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_vector_uint8, &_result->vector_vector_uint8);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ResourceTable;
const fidl_type_t* Resource::FidlType = &test_typesinprotocols_ResourceTable;

void Resource::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Resource>::value) {
    memcpy(_encoder->template GetPtr<Resource>(_offset), this, sizeof(Resource));
  } else {
    ::fidl::Encode(_encoder, &handle, _offset + 0, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, &vmo, _offset + 4, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, &client_end, _offset + 8, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, &server_end, _offset + 12, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    ::fidl::Encode(_encoder, &struct_, _offset + 16);
    ::fidl::Encode(_encoder, &table, _offset + 24);
    ::fidl::Encode(_encoder, &union_, _offset + 40);
    
    ::fidl::Encode(_encoder, &opt_handle, _offset + 56, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, &opt_vmo, _offset + 60, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, &opt_client_end, _offset + 64, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, &opt_server_end, _offset + 68, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    ::fidl::Encode(_encoder, &opt_struct, _offset + 72);
    ::fidl::Encode(_encoder, &opt_union, _offset + 80);
    
    ::fidl::Encode(_encoder, &array_handle, _offset + 96, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, &array_vmo, _offset + 116, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, &array_client_end, _offset + 136, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, &array_server_end, _offset + 156, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    ::fidl::Encode(_encoder, &array_struct, _offset + 176);
    ::fidl::Encode(_encoder, &array_table, _offset + 184);
    ::fidl::Encode(_encoder, &array_union, _offset + 264);
    
    ::fidl::Encode(_encoder, &vector_handle, _offset + 344, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_NONE,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, &vector_vmo, _offset + 360, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_VMO,
      .rights = 0x80000000,
    });
    
    ::fidl::Encode(_encoder, &vector_client_end, _offset + 376, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    
    ::fidl::Encode(_encoder, &vector_server_end, _offset + 392, ::fidl::HandleInformation {
      .object_type = ZX_OBJ_TYPE_CHANNEL,
      .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
    });
    ::fidl::Encode(_encoder, &vector_struct, _offset + 408);
    ::fidl::Encode(_encoder, &vector_table, _offset + 424);
    ::fidl::Encode(_encoder, &vector_union, _offset + 440);
    
  }
}

void Resource::Decode(::fidl::Decoder* _decoder, Resource* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Resource>::value) {
    memcpy(_value, _decoder->template GetPtr<Resource>(_offset), sizeof(Resource));
  } else {
    ::fidl::Decode(_decoder, &_value->handle, _offset + 0);
    ::fidl::Decode(_decoder, &_value->vmo, _offset + 4);
    ::fidl::Decode(_decoder, &_value->client_end, _offset + 8);
    ::fidl::Decode(_decoder, &_value->server_end, _offset + 12);
    ::fidl::Decode(_decoder, &_value->struct_, _offset + 16);
    ::fidl::Decode(_decoder, &_value->table, _offset + 24);
    ::fidl::Decode(_decoder, &_value->union_, _offset + 40);
    ::fidl::Decode(_decoder, &_value->opt_handle, _offset + 56);
    ::fidl::Decode(_decoder, &_value->opt_vmo, _offset + 60);
    ::fidl::Decode(_decoder, &_value->opt_client_end, _offset + 64);
    ::fidl::Decode(_decoder, &_value->opt_server_end, _offset + 68);
    ::fidl::Decode(_decoder, &_value->opt_struct, _offset + 72);
    ::fidl::Decode(_decoder, &_value->opt_union, _offset + 80);
    ::fidl::Decode(_decoder, &_value->array_handle, _offset + 96);
    ::fidl::Decode(_decoder, &_value->array_vmo, _offset + 116);
    ::fidl::Decode(_decoder, &_value->array_client_end, _offset + 136);
    ::fidl::Decode(_decoder, &_value->array_server_end, _offset + 156);
    ::fidl::Decode(_decoder, &_value->array_struct, _offset + 176);
    ::fidl::Decode(_decoder, &_value->array_table, _offset + 184);
    ::fidl::Decode(_decoder, &_value->array_union, _offset + 264);
    ::fidl::Decode(_decoder, &_value->vector_handle, _offset + 344);
    ::fidl::Decode(_decoder, &_value->vector_vmo, _offset + 360);
    ::fidl::Decode(_decoder, &_value->vector_client_end, _offset + 376);
    ::fidl::Decode(_decoder, &_value->vector_server_end, _offset + 392);
    ::fidl::Decode(_decoder, &_value->vector_struct, _offset + 408);
    ::fidl::Decode(_decoder, &_value->vector_table, _offset + 424);
    ::fidl::Decode(_decoder, &_value->vector_union, _offset + 440);
  }
}

zx_status_t Resource::Clone(Resource* _result) const {
  zx_status_t _status = ::fidl::Clone(handle, &_result->handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vmo, &_result->vmo);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(client_end, &_result->client_end);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(server_end, &_result->server_end);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(struct_, &_result->struct_);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(table, &_result->table);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(union_, &_result->union_);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(opt_handle, &_result->opt_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(opt_vmo, &_result->opt_vmo);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(opt_client_end, &_result->opt_client_end);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(opt_server_end, &_result->opt_server_end);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(opt_struct, &_result->opt_struct);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(opt_union, &_result->opt_union);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_handle, &_result->array_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_vmo, &_result->array_vmo);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_client_end, &_result->array_client_end);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_server_end, &_result->array_server_end);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_struct, &_result->array_struct);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_table, &_result->array_table);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(array_union, &_result->array_union);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_handle, &_result->vector_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_vmo, &_result->vector_vmo);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_client_end, &_result->vector_client_end);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_server_end, &_result->vector_server_end);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_struct, &_result->vector_struct);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_table, &_result->vector_table);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vector_union, &_result->vector_union);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

#endif  // __Fuchsia__



extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorBasic_ResultTable;
const fidl_type_t* Protocol_ErrorBasic_Result::FidlType = &test_typesinprotocols_Protocol_ErrorBasic_ResultTable;

Protocol_ErrorBasic_Result::Protocol_ErrorBasic_Result() {}

Protocol_ErrorBasic_Result::~Protocol_ErrorBasic_Result() {
  Destroy();
}

Protocol_ErrorBasic_Result::Protocol_ErrorBasic_Result(Protocol_ErrorBasic_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kResponse:
      new (&response_) ::test::typesinprotocols::Basic();
      response_ = std::move(other.response_);
      break;
    case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::Invalid):
      break;
  }
}

Protocol_ErrorBasic_Result& Protocol_ErrorBasic_Result::operator=(Protocol_ErrorBasic_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::Basic();
        response_ = std::move(other.response_);
        break;
      case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

Protocol_ErrorBasic_Result Protocol_ErrorBasic_Result::WithResponse(::test::typesinprotocols::Basic&& val) {
  Protocol_ErrorBasic_Result result;
  result.set_response(std::move(val));
  return result;
}
Protocol_ErrorBasic_Result Protocol_ErrorBasic_Result::WithErr(uint32_t&& val) {
  Protocol_ErrorBasic_Result result;
  result.set_err(std::move(val));
  return result;
}


void Protocol_ErrorBasic_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::typesinprotocols::Basic>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::typesinprotocols::Basic, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void Protocol_ErrorBasic_Result::Decode(::fidl::Decoder* _decoder, Protocol_ErrorBasic_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kResponse: {
      new (&value->response_) ::test::typesinprotocols::Basic();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t Protocol_ErrorBasic_Result::Clone(Protocol_ErrorBasic_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kResponse:
      new (&result->response_) ::test::typesinprotocols::Basic();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

Protocol_ErrorBasic_Result& Protocol_ErrorBasic_Result::set_response(::test::typesinprotocols::Basic value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

Protocol_ErrorBasic_Result& Protocol_ErrorBasic_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void Protocol_ErrorBasic_Result::Destroy() {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::Invalid);
}

void Protocol_ErrorBasic_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::Invalid):
        break;
      case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::Basic();
        break;
      case ::test::typesinprotocols::Protocol_ErrorBasic_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorBasicTopResponseTable;
const fidl_type_t* ProtocolErrorBasicTopResponse::FidlType = &test_typesinprotocols_ProtocolErrorBasicTopResponseTable;

void ProtocolErrorBasicTopResponse::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorBasicTopResponse>::value) {
    memcpy(_encoder->template GetPtr<ProtocolErrorBasicTopResponse>(_offset), this, sizeof(ProtocolErrorBasicTopResponse));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void ProtocolErrorBasicTopResponse::Decode(::fidl::Decoder* _decoder, ProtocolErrorBasicTopResponse* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorBasicTopResponse>::value) {
    memcpy(_value, _decoder->template GetPtr<ProtocolErrorBasicTopResponse>(_offset), sizeof(ProtocolErrorBasicTopResponse));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t ProtocolErrorBasicTopResponse::Clone(ProtocolErrorBasicTopResponse* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorCompound_ResultTable;
const fidl_type_t* Protocol_ErrorCompound_Result::FidlType = &test_typesinprotocols_Protocol_ErrorCompound_ResultTable;

Protocol_ErrorCompound_Result::Protocol_ErrorCompound_Result() {}

Protocol_ErrorCompound_Result::~Protocol_ErrorCompound_Result() {
  Destroy();
}

Protocol_ErrorCompound_Result::Protocol_ErrorCompound_Result(Protocol_ErrorCompound_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kResponse:
      new (&response_) ::test::typesinprotocols::Compound();
      response_ = std::move(other.response_);
      break;
    case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::Invalid):
      break;
  }
}

Protocol_ErrorCompound_Result& Protocol_ErrorCompound_Result::operator=(Protocol_ErrorCompound_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::Compound();
        response_ = std::move(other.response_);
        break;
      case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

Protocol_ErrorCompound_Result Protocol_ErrorCompound_Result::WithResponse(::test::typesinprotocols::Compound&& val) {
  Protocol_ErrorCompound_Result result;
  result.set_response(std::move(val));
  return result;
}
Protocol_ErrorCompound_Result Protocol_ErrorCompound_Result::WithErr(uint32_t&& val) {
  Protocol_ErrorCompound_Result result;
  result.set_err(std::move(val));
  return result;
}


void Protocol_ErrorCompound_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::typesinprotocols::Compound>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::typesinprotocols::Compound, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void Protocol_ErrorCompound_Result::Decode(::fidl::Decoder* _decoder, Protocol_ErrorCompound_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kResponse: {
      new (&value->response_) ::test::typesinprotocols::Compound();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t Protocol_ErrorCompound_Result::Clone(Protocol_ErrorCompound_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kResponse:
      new (&result->response_) ::test::typesinprotocols::Compound();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

Protocol_ErrorCompound_Result& Protocol_ErrorCompound_Result::set_response(::test::typesinprotocols::Compound value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

Protocol_ErrorCompound_Result& Protocol_ErrorCompound_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void Protocol_ErrorCompound_Result::Destroy() {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::Invalid);
}

void Protocol_ErrorCompound_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::Invalid):
        break;
      case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::Compound();
        break;
      case ::test::typesinprotocols::Protocol_ErrorCompound_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorCompoundTopResponseTable;
const fidl_type_t* ProtocolErrorCompoundTopResponse::FidlType = &test_typesinprotocols_ProtocolErrorCompoundTopResponseTable;

void ProtocolErrorCompoundTopResponse::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorCompoundTopResponse>::value) {
    memcpy(_encoder->template GetPtr<ProtocolErrorCompoundTopResponse>(_offset), this, sizeof(ProtocolErrorCompoundTopResponse));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void ProtocolErrorCompoundTopResponse::Decode(::fidl::Decoder* _decoder, ProtocolErrorCompoundTopResponse* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorCompoundTopResponse>::value) {
    memcpy(_value, _decoder->template GetPtr<ProtocolErrorCompoundTopResponse>(_offset), sizeof(ProtocolErrorCompoundTopResponse));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t ProtocolErrorCompoundTopResponse::Clone(ProtocolErrorCompoundTopResponse* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorArrayBasic_ResultTable;
const fidl_type_t* Protocol_ErrorArrayBasic_Result::FidlType = &test_typesinprotocols_Protocol_ErrorArrayBasic_ResultTable;

Protocol_ErrorArrayBasic_Result::Protocol_ErrorArrayBasic_Result() {}

Protocol_ErrorArrayBasic_Result::~Protocol_ErrorArrayBasic_Result() {
  Destroy();
}

Protocol_ErrorArrayBasic_Result::Protocol_ErrorArrayBasic_Result(Protocol_ErrorArrayBasic_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kResponse:
      new (&response_) ::test::typesinprotocols::ArrayBasic();
      response_ = std::move(other.response_);
      break;
    case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::Invalid):
      break;
  }
}

Protocol_ErrorArrayBasic_Result& Protocol_ErrorArrayBasic_Result::operator=(Protocol_ErrorArrayBasic_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::ArrayBasic();
        response_ = std::move(other.response_);
        break;
      case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

Protocol_ErrorArrayBasic_Result Protocol_ErrorArrayBasic_Result::WithResponse(::test::typesinprotocols::ArrayBasic&& val) {
  Protocol_ErrorArrayBasic_Result result;
  result.set_response(std::move(val));
  return result;
}
Protocol_ErrorArrayBasic_Result Protocol_ErrorArrayBasic_Result::WithErr(uint32_t&& val) {
  Protocol_ErrorArrayBasic_Result result;
  result.set_err(std::move(val));
  return result;
}


void Protocol_ErrorArrayBasic_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::typesinprotocols::ArrayBasic>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::typesinprotocols::ArrayBasic, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void Protocol_ErrorArrayBasic_Result::Decode(::fidl::Decoder* _decoder, Protocol_ErrorArrayBasic_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kResponse: {
      new (&value->response_) ::test::typesinprotocols::ArrayBasic();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t Protocol_ErrorArrayBasic_Result::Clone(Protocol_ErrorArrayBasic_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kResponse:
      new (&result->response_) ::test::typesinprotocols::ArrayBasic();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

Protocol_ErrorArrayBasic_Result& Protocol_ErrorArrayBasic_Result::set_response(::test::typesinprotocols::ArrayBasic value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

Protocol_ErrorArrayBasic_Result& Protocol_ErrorArrayBasic_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void Protocol_ErrorArrayBasic_Result::Destroy() {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::Invalid);
}

void Protocol_ErrorArrayBasic_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::Invalid):
        break;
      case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::ArrayBasic();
        break;
      case ::test::typesinprotocols::Protocol_ErrorArrayBasic_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayBasicTopResponseTable;
const fidl_type_t* ProtocolErrorArrayBasicTopResponse::FidlType = &test_typesinprotocols_ProtocolErrorArrayBasicTopResponseTable;

void ProtocolErrorArrayBasicTopResponse::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorArrayBasicTopResponse>::value) {
    memcpy(_encoder->template GetPtr<ProtocolErrorArrayBasicTopResponse>(_offset), this, sizeof(ProtocolErrorArrayBasicTopResponse));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void ProtocolErrorArrayBasicTopResponse::Decode(::fidl::Decoder* _decoder, ProtocolErrorArrayBasicTopResponse* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorArrayBasicTopResponse>::value) {
    memcpy(_value, _decoder->template GetPtr<ProtocolErrorArrayBasicTopResponse>(_offset), sizeof(ProtocolErrorArrayBasicTopResponse));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t ProtocolErrorArrayBasicTopResponse::Clone(ProtocolErrorArrayBasicTopResponse* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorArrayCompound_ResultTable;
const fidl_type_t* Protocol_ErrorArrayCompound_Result::FidlType = &test_typesinprotocols_Protocol_ErrorArrayCompound_ResultTable;

Protocol_ErrorArrayCompound_Result::Protocol_ErrorArrayCompound_Result() {}

Protocol_ErrorArrayCompound_Result::~Protocol_ErrorArrayCompound_Result() {
  Destroy();
}

Protocol_ErrorArrayCompound_Result::Protocol_ErrorArrayCompound_Result(Protocol_ErrorArrayCompound_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kResponse:
      new (&response_) ::test::typesinprotocols::ArrayCompound();
      response_ = std::move(other.response_);
      break;
    case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::Invalid):
      break;
  }
}

Protocol_ErrorArrayCompound_Result& Protocol_ErrorArrayCompound_Result::operator=(Protocol_ErrorArrayCompound_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::ArrayCompound();
        response_ = std::move(other.response_);
        break;
      case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

Protocol_ErrorArrayCompound_Result Protocol_ErrorArrayCompound_Result::WithResponse(::test::typesinprotocols::ArrayCompound&& val) {
  Protocol_ErrorArrayCompound_Result result;
  result.set_response(std::move(val));
  return result;
}
Protocol_ErrorArrayCompound_Result Protocol_ErrorArrayCompound_Result::WithErr(uint32_t&& val) {
  Protocol_ErrorArrayCompound_Result result;
  result.set_err(std::move(val));
  return result;
}


void Protocol_ErrorArrayCompound_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::typesinprotocols::ArrayCompound>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::typesinprotocols::ArrayCompound, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void Protocol_ErrorArrayCompound_Result::Decode(::fidl::Decoder* _decoder, Protocol_ErrorArrayCompound_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kResponse: {
      new (&value->response_) ::test::typesinprotocols::ArrayCompound();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t Protocol_ErrorArrayCompound_Result::Clone(Protocol_ErrorArrayCompound_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kResponse:
      new (&result->response_) ::test::typesinprotocols::ArrayCompound();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

Protocol_ErrorArrayCompound_Result& Protocol_ErrorArrayCompound_Result::set_response(::test::typesinprotocols::ArrayCompound value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

Protocol_ErrorArrayCompound_Result& Protocol_ErrorArrayCompound_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void Protocol_ErrorArrayCompound_Result::Destroy() {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::Invalid);
}

void Protocol_ErrorArrayCompound_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::Invalid):
        break;
      case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::ArrayCompound();
        break;
      case ::test::typesinprotocols::Protocol_ErrorArrayCompound_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayCompoundTopResponseTable;
const fidl_type_t* ProtocolErrorArrayCompoundTopResponse::FidlType = &test_typesinprotocols_ProtocolErrorArrayCompoundTopResponseTable;

void ProtocolErrorArrayCompoundTopResponse::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorArrayCompoundTopResponse>::value) {
    memcpy(_encoder->template GetPtr<ProtocolErrorArrayCompoundTopResponse>(_offset), this, sizeof(ProtocolErrorArrayCompoundTopResponse));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void ProtocolErrorArrayCompoundTopResponse::Decode(::fidl::Decoder* _decoder, ProtocolErrorArrayCompoundTopResponse* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorArrayCompoundTopResponse>::value) {
    memcpy(_value, _decoder->template GetPtr<ProtocolErrorArrayCompoundTopResponse>(_offset), sizeof(ProtocolErrorArrayCompoundTopResponse));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t ProtocolErrorArrayCompoundTopResponse::Clone(ProtocolErrorArrayCompoundTopResponse* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorVectorBasic_ResultTable;
const fidl_type_t* Protocol_ErrorVectorBasic_Result::FidlType = &test_typesinprotocols_Protocol_ErrorVectorBasic_ResultTable;

Protocol_ErrorVectorBasic_Result::Protocol_ErrorVectorBasic_Result() {}

Protocol_ErrorVectorBasic_Result::~Protocol_ErrorVectorBasic_Result() {
  Destroy();
}

Protocol_ErrorVectorBasic_Result::Protocol_ErrorVectorBasic_Result(Protocol_ErrorVectorBasic_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kResponse:
      new (&response_) ::test::typesinprotocols::VectorBasic();
      response_ = std::move(other.response_);
      break;
    case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::Invalid):
      break;
  }
}

Protocol_ErrorVectorBasic_Result& Protocol_ErrorVectorBasic_Result::operator=(Protocol_ErrorVectorBasic_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::VectorBasic();
        response_ = std::move(other.response_);
        break;
      case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

Protocol_ErrorVectorBasic_Result Protocol_ErrorVectorBasic_Result::WithResponse(::test::typesinprotocols::VectorBasic&& val) {
  Protocol_ErrorVectorBasic_Result result;
  result.set_response(std::move(val));
  return result;
}
Protocol_ErrorVectorBasic_Result Protocol_ErrorVectorBasic_Result::WithErr(uint32_t&& val) {
  Protocol_ErrorVectorBasic_Result result;
  result.set_err(std::move(val));
  return result;
}


void Protocol_ErrorVectorBasic_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::typesinprotocols::VectorBasic>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::typesinprotocols::VectorBasic, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void Protocol_ErrorVectorBasic_Result::Decode(::fidl::Decoder* _decoder, Protocol_ErrorVectorBasic_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kResponse: {
      new (&value->response_) ::test::typesinprotocols::VectorBasic();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t Protocol_ErrorVectorBasic_Result::Clone(Protocol_ErrorVectorBasic_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kResponse:
      new (&result->response_) ::test::typesinprotocols::VectorBasic();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

Protocol_ErrorVectorBasic_Result& Protocol_ErrorVectorBasic_Result::set_response(::test::typesinprotocols::VectorBasic value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

Protocol_ErrorVectorBasic_Result& Protocol_ErrorVectorBasic_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void Protocol_ErrorVectorBasic_Result::Destroy() {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::Invalid);
}

void Protocol_ErrorVectorBasic_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::Invalid):
        break;
      case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::VectorBasic();
        break;
      case ::test::typesinprotocols::Protocol_ErrorVectorBasic_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorBasicTopResponseTable;
const fidl_type_t* ProtocolErrorVectorBasicTopResponse::FidlType = &test_typesinprotocols_ProtocolErrorVectorBasicTopResponseTable;

void ProtocolErrorVectorBasicTopResponse::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorVectorBasicTopResponse>::value) {
    memcpy(_encoder->template GetPtr<ProtocolErrorVectorBasicTopResponse>(_offset), this, sizeof(ProtocolErrorVectorBasicTopResponse));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void ProtocolErrorVectorBasicTopResponse::Decode(::fidl::Decoder* _decoder, ProtocolErrorVectorBasicTopResponse* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorVectorBasicTopResponse>::value) {
    memcpy(_value, _decoder->template GetPtr<ProtocolErrorVectorBasicTopResponse>(_offset), sizeof(ProtocolErrorVectorBasicTopResponse));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t ProtocolErrorVectorBasicTopResponse::Clone(ProtocolErrorVectorBasicTopResponse* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorVectorCompound_ResultTable;
const fidl_type_t* Protocol_ErrorVectorCompound_Result::FidlType = &test_typesinprotocols_Protocol_ErrorVectorCompound_ResultTable;

Protocol_ErrorVectorCompound_Result::Protocol_ErrorVectorCompound_Result() {}

Protocol_ErrorVectorCompound_Result::~Protocol_ErrorVectorCompound_Result() {
  Destroy();
}

Protocol_ErrorVectorCompound_Result::Protocol_ErrorVectorCompound_Result(Protocol_ErrorVectorCompound_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kResponse:
      new (&response_) ::test::typesinprotocols::VectorCompound();
      response_ = std::move(other.response_);
      break;
    case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::Invalid):
      break;
  }
}

Protocol_ErrorVectorCompound_Result& Protocol_ErrorVectorCompound_Result::operator=(Protocol_ErrorVectorCompound_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::VectorCompound();
        response_ = std::move(other.response_);
        break;
      case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

Protocol_ErrorVectorCompound_Result Protocol_ErrorVectorCompound_Result::WithResponse(::test::typesinprotocols::VectorCompound&& val) {
  Protocol_ErrorVectorCompound_Result result;
  result.set_response(std::move(val));
  return result;
}
Protocol_ErrorVectorCompound_Result Protocol_ErrorVectorCompound_Result::WithErr(uint32_t&& val) {
  Protocol_ErrorVectorCompound_Result result;
  result.set_err(std::move(val));
  return result;
}


void Protocol_ErrorVectorCompound_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::typesinprotocols::VectorCompound>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::typesinprotocols::VectorCompound, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void Protocol_ErrorVectorCompound_Result::Decode(::fidl::Decoder* _decoder, Protocol_ErrorVectorCompound_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kResponse: {
      new (&value->response_) ::test::typesinprotocols::VectorCompound();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t Protocol_ErrorVectorCompound_Result::Clone(Protocol_ErrorVectorCompound_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kResponse:
      new (&result->response_) ::test::typesinprotocols::VectorCompound();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

Protocol_ErrorVectorCompound_Result& Protocol_ErrorVectorCompound_Result::set_response(::test::typesinprotocols::VectorCompound value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

Protocol_ErrorVectorCompound_Result& Protocol_ErrorVectorCompound_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void Protocol_ErrorVectorCompound_Result::Destroy() {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::Invalid);
}

void Protocol_ErrorVectorCompound_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::Invalid):
        break;
      case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::VectorCompound();
        break;
      case ::test::typesinprotocols::Protocol_ErrorVectorCompound_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorCompoundTopResponseTable;
const fidl_type_t* ProtocolErrorVectorCompoundTopResponse::FidlType = &test_typesinprotocols_ProtocolErrorVectorCompoundTopResponseTable;

void ProtocolErrorVectorCompoundTopResponse::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorVectorCompoundTopResponse>::value) {
    memcpy(_encoder->template GetPtr<ProtocolErrorVectorCompoundTopResponse>(_offset), this, sizeof(ProtocolErrorVectorCompoundTopResponse));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void ProtocolErrorVectorCompoundTopResponse::Decode(::fidl::Decoder* _decoder, ProtocolErrorVectorCompoundTopResponse* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorVectorCompoundTopResponse>::value) {
    memcpy(_value, _decoder->template GetPtr<ProtocolErrorVectorCompoundTopResponse>(_offset), sizeof(ProtocolErrorVectorCompoundTopResponse));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t ProtocolErrorVectorCompoundTopResponse::Clone(ProtocolErrorVectorCompoundTopResponse* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorVectorOptional_ResultTable;
const fidl_type_t* Protocol_ErrorVectorOptional_Result::FidlType = &test_typesinprotocols_Protocol_ErrorVectorOptional_ResultTable;

Protocol_ErrorVectorOptional_Result::Protocol_ErrorVectorOptional_Result() {}

Protocol_ErrorVectorOptional_Result::~Protocol_ErrorVectorOptional_Result() {
  Destroy();
}

Protocol_ErrorVectorOptional_Result::Protocol_ErrorVectorOptional_Result(Protocol_ErrorVectorOptional_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kResponse:
      new (&response_) ::test::typesinprotocols::VectorOptional();
      response_ = std::move(other.response_);
      break;
    case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::Invalid):
      break;
  }
}

Protocol_ErrorVectorOptional_Result& Protocol_ErrorVectorOptional_Result::operator=(Protocol_ErrorVectorOptional_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::VectorOptional();
        response_ = std::move(other.response_);
        break;
      case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

Protocol_ErrorVectorOptional_Result Protocol_ErrorVectorOptional_Result::WithResponse(::test::typesinprotocols::VectorOptional&& val) {
  Protocol_ErrorVectorOptional_Result result;
  result.set_response(std::move(val));
  return result;
}
Protocol_ErrorVectorOptional_Result Protocol_ErrorVectorOptional_Result::WithErr(uint32_t&& val) {
  Protocol_ErrorVectorOptional_Result result;
  result.set_err(std::move(val));
  return result;
}


void Protocol_ErrorVectorOptional_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::typesinprotocols::VectorOptional>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::typesinprotocols::VectorOptional, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void Protocol_ErrorVectorOptional_Result::Decode(::fidl::Decoder* _decoder, Protocol_ErrorVectorOptional_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kResponse: {
      new (&value->response_) ::test::typesinprotocols::VectorOptional();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t Protocol_ErrorVectorOptional_Result::Clone(Protocol_ErrorVectorOptional_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kResponse:
      new (&result->response_) ::test::typesinprotocols::VectorOptional();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

Protocol_ErrorVectorOptional_Result& Protocol_ErrorVectorOptional_Result::set_response(::test::typesinprotocols::VectorOptional value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

Protocol_ErrorVectorOptional_Result& Protocol_ErrorVectorOptional_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void Protocol_ErrorVectorOptional_Result::Destroy() {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::Invalid);
}

void Protocol_ErrorVectorOptional_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::Invalid):
        break;
      case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::VectorOptional();
        break;
      case ::test::typesinprotocols::Protocol_ErrorVectorOptional_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorOptionalTopResponseTable;
const fidl_type_t* ProtocolErrorVectorOptionalTopResponse::FidlType = &test_typesinprotocols_ProtocolErrorVectorOptionalTopResponseTable;

void ProtocolErrorVectorOptionalTopResponse::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorVectorOptionalTopResponse>::value) {
    memcpy(_encoder->template GetPtr<ProtocolErrorVectorOptionalTopResponse>(_offset), this, sizeof(ProtocolErrorVectorOptionalTopResponse));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void ProtocolErrorVectorOptionalTopResponse::Decode(::fidl::Decoder* _decoder, ProtocolErrorVectorOptionalTopResponse* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorVectorOptionalTopResponse>::value) {
    memcpy(_value, _decoder->template GetPtr<ProtocolErrorVectorOptionalTopResponse>(_offset), sizeof(ProtocolErrorVectorOptionalTopResponse));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t ProtocolErrorVectorOptionalTopResponse::Clone(ProtocolErrorVectorOptionalTopResponse* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorArrayVectorNested_ResultTable;
const fidl_type_t* Protocol_ErrorArrayVectorNested_Result::FidlType = &test_typesinprotocols_Protocol_ErrorArrayVectorNested_ResultTable;

Protocol_ErrorArrayVectorNested_Result::Protocol_ErrorArrayVectorNested_Result() {}

Protocol_ErrorArrayVectorNested_Result::~Protocol_ErrorArrayVectorNested_Result() {
  Destroy();
}

Protocol_ErrorArrayVectorNested_Result::Protocol_ErrorArrayVectorNested_Result(Protocol_ErrorArrayVectorNested_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kResponse:
      new (&response_) ::test::typesinprotocols::ArrayVectorNested();
      response_ = std::move(other.response_);
      break;
    case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::Invalid):
      break;
  }
}

Protocol_ErrorArrayVectorNested_Result& Protocol_ErrorArrayVectorNested_Result::operator=(Protocol_ErrorArrayVectorNested_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::ArrayVectorNested();
        response_ = std::move(other.response_);
        break;
      case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

Protocol_ErrorArrayVectorNested_Result Protocol_ErrorArrayVectorNested_Result::WithResponse(::test::typesinprotocols::ArrayVectorNested&& val) {
  Protocol_ErrorArrayVectorNested_Result result;
  result.set_response(std::move(val));
  return result;
}
Protocol_ErrorArrayVectorNested_Result Protocol_ErrorArrayVectorNested_Result::WithErr(uint32_t&& val) {
  Protocol_ErrorArrayVectorNested_Result result;
  result.set_err(std::move(val));
  return result;
}


void Protocol_ErrorArrayVectorNested_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::typesinprotocols::ArrayVectorNested>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::typesinprotocols::ArrayVectorNested, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void Protocol_ErrorArrayVectorNested_Result::Decode(::fidl::Decoder* _decoder, Protocol_ErrorArrayVectorNested_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kResponse: {
      new (&value->response_) ::test::typesinprotocols::ArrayVectorNested();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t Protocol_ErrorArrayVectorNested_Result::Clone(Protocol_ErrorArrayVectorNested_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kResponse:
      new (&result->response_) ::test::typesinprotocols::ArrayVectorNested();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

Protocol_ErrorArrayVectorNested_Result& Protocol_ErrorArrayVectorNested_Result::set_response(::test::typesinprotocols::ArrayVectorNested value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

Protocol_ErrorArrayVectorNested_Result& Protocol_ErrorArrayVectorNested_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void Protocol_ErrorArrayVectorNested_Result::Destroy() {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::Invalid);
}

void Protocol_ErrorArrayVectorNested_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::Invalid):
        break;
      case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::ArrayVectorNested();
        break;
      case ::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}


extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayVectorNestedTopResponseTable;
const fidl_type_t* ProtocolErrorArrayVectorNestedTopResponse::FidlType = &test_typesinprotocols_ProtocolErrorArrayVectorNestedTopResponseTable;

void ProtocolErrorArrayVectorNestedTopResponse::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorArrayVectorNestedTopResponse>::value) {
    memcpy(_encoder->template GetPtr<ProtocolErrorArrayVectorNestedTopResponse>(_offset), this, sizeof(ProtocolErrorArrayVectorNestedTopResponse));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void ProtocolErrorArrayVectorNestedTopResponse::Decode(::fidl::Decoder* _decoder, ProtocolErrorArrayVectorNestedTopResponse* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorArrayVectorNestedTopResponse>::value) {
    memcpy(_value, _decoder->template GetPtr<ProtocolErrorArrayVectorNestedTopResponse>(_offset), sizeof(ProtocolErrorArrayVectorNestedTopResponse));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t ProtocolErrorArrayVectorNestedTopResponse::Clone(ProtocolErrorArrayVectorNestedTopResponse* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}


#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_Protocol_ErrorResource_ResultTable;
const fidl_type_t* Protocol_ErrorResource_Result::FidlType = &test_typesinprotocols_Protocol_ErrorResource_ResultTable;

Protocol_ErrorResource_Result::Protocol_ErrorResource_Result() {}

Protocol_ErrorResource_Result::~Protocol_ErrorResource_Result() {
  Destroy();
}

Protocol_ErrorResource_Result::Protocol_ErrorResource_Result(Protocol_ErrorResource_Result&& other) : tag_(other.tag_) {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kResponse:
      new (&response_) ::test::typesinprotocols::Resource();
      response_ = std::move(other.response_);
      break;
    case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kErr:
      err_ = std::move(other.err_);
      break;
    case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::Invalid):
      break;
  }
}

Protocol_ErrorResource_Result& Protocol_ErrorResource_Result::operator=(Protocol_ErrorResource_Result&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::Resource();
        response_ = std::move(other.response_);
        break;
      case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kErr:
        err_ = std::move(other.err_);
        break;
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::Invalid):
        break;
    }
  }
  return *this;
}

Protocol_ErrorResource_Result Protocol_ErrorResource_Result::WithResponse(::test::typesinprotocols::Resource&& val) {
  Protocol_ErrorResource_Result result;
  result.set_response(std::move(val));
  return result;
}
Protocol_ErrorResource_Result Protocol_ErrorResource_Result::WithErr(uint32_t&& val) {
  Protocol_ErrorResource_Result result;
  result.set_err(std::move(val));
  return result;
}


void Protocol_ErrorResource_Result::Encode(::fidl::Encoder* encoder, size_t offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  switch (Which()) {
    case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kResponse: {
      if (::fidl::EncodingInlineSize<::test::typesinprotocols::Resource>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &response_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &response_,
        encoder->Alloc(::fidl::EncodingInlineSize<::test::typesinprotocols::Resource, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kErr: {
      if (::fidl::EncodingInlineSize<uint32_t>(encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
        ::fidl::Encode(encoder, &err_, offset + offsetof(fidl_xunion_v2_t, envelope));

        fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
        xunion->tag = tag_;
        xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
        xunion->envelope.flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
        break;
      }

      ::fidl::Encode(
        encoder,
        &err_,
        encoder->Alloc(::fidl::EncodingInlineSize<uint32_t, ::fidl::Encoder>(encoder)));

      fidl_xunion_v2_t* xunion = encoder->GetPtr<fidl_xunion_v2_t>(offset);
      xunion->tag = tag_;
      xunion->envelope.num_bytes = static_cast<uint32_t>(encoder->CurrentLength() - length_before);
      xunion->envelope.num_handles = static_cast<uint16_t>(encoder->CurrentHandleCount() - handles_before);
      xunion->envelope.flags = 0;
      break;
    }
    default:
      break;
  }
}

void Protocol_ErrorResource_Result::Decode(::fidl::Decoder* _decoder, Protocol_ErrorResource_Result* value, size_t offset) {
  fidl_xunion_v2_t* xunion = _decoder->GetPtr<fidl_xunion_v2_t>(offset);

  if (xunion->envelope.num_bytes == 0 &&
      xunion->envelope.num_handles == 0 &&
      xunion->envelope.flags == 0) {
    value->EnsureStorageInitialized(static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::Invalid));
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  size_t value_offset = _decoder->EnvelopeValueOffset(&xunion->envelope);

  switch (value->tag_) {
    case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kResponse: {
      new (&value->response_) ::test::typesinprotocols::Resource();
      ::fidl::Decode(_decoder, &value->response_, value_offset);
      break;
    }
    case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kErr: {
      ::fidl::Decode(_decoder, &value->err_, value_offset);
      break;
    }
    default: {
  break;
    }
  }

}

zx_status_t Protocol_ErrorResource_Result::Clone(Protocol_ErrorResource_Result* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::Invalid:
      return ZX_OK;
    case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kResponse:
      new (&result->response_) ::test::typesinprotocols::Resource();
      return ::fidl::Clone(response_, &result->response_);
    case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kErr:
      return ::fidl::Clone(err_, &result->err_);
    default:return ZX_OK;
  }
}

Protocol_ErrorResource_Result& Protocol_ErrorResource_Result::set_response(::test::typesinprotocols::Resource value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kResponse);
  response_ = std::move(value);
  return *this;
}

Protocol_ErrorResource_Result& Protocol_ErrorResource_Result::set_err(uint32_t value) {
  EnsureStorageInitialized(::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kErr);
  err_ = std::move(value);
  return *this;
}

void Protocol_ErrorResource_Result::Destroy() {
  switch (tag_) {
    case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kResponse:
      response_.~decltype(response_)();
      break;
    case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kErr:
      break;
  
    default:
      break;
  
  }
  tag_ = static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::Invalid);
}

void Protocol_ErrorResource_Result::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case static_cast<fidl_xunion_tag_t>(::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::Invalid):
        break;
      case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kResponse:
        new (&response_) ::test::typesinprotocols::Resource();
        break;
      case ::test::typesinprotocols::Protocol_ErrorResource_Result::Tag::kErr:
        new (&err_) uint32_t();
        break;
      default:
        break;
    }
  }
}

#endif  // __Fuchsia__



#ifdef __Fuchsia__

extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorResourceTopResponseTable;
const fidl_type_t* ProtocolErrorResourceTopResponse::FidlType = &test_typesinprotocols_ProtocolErrorResourceTopResponseTable;

void ProtocolErrorResourceTopResponse::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorResourceTopResponse>::value) {
    memcpy(_encoder->template GetPtr<ProtocolErrorResourceTopResponse>(_offset), this, sizeof(ProtocolErrorResourceTopResponse));
  } else {::fidl::Encode(_encoder, &result, _offset + 0);
    
  }
}

void ProtocolErrorResourceTopResponse::Decode(::fidl::Decoder* _decoder, ProtocolErrorResourceTopResponse* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<ProtocolErrorResourceTopResponse>::value) {
    memcpy(_value, _decoder->template GetPtr<ProtocolErrorResourceTopResponse>(_offset), sizeof(ProtocolErrorResourceTopResponse));
  } else {
    ::fidl::Decode(_decoder, &_value->result, _offset + 0);
  }
}

zx_status_t ProtocolErrorResourceTopResponse::Clone(ProtocolErrorResourceTopResponse* _result) const {
  zx_status_t _status = ::fidl::Clone(result, &_result->result);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

#endif  // __Fuchsia__


//
// Proxies and stubs definitions
//
#ifdef __Fuchsia__

  namespace _internal {
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_BasicTable;
  
  
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorBasicTopResponseTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_CompoundTable;
  
  
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorCompoundTopResponseTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ArrayBasicTable;
  
  
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayBasicTopResponseTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ArrayCompoundTable;
  
  
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayCompoundTopResponseTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_VectorBasicTable;
  
  
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorBasicTopResponseTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_VectorCompoundTable;
  
  
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorCompoundTopResponseTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_VectorOptionalTable;
  
  
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorVectorOptionalTopResponseTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ArrayVectorNestedTable;
  
  
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorArrayVectorNestedTopResponseTable;
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ResourceTable;
  
  
  
  
  
__LOCAL extern "C" const fidl_type_t test_typesinprotocols_ProtocolErrorResourceTopResponseTable;
  
  

}  // namespace _internal

Protocol::~Protocol() = default;

const fidl_type_t* ::test::typesinprotocols::Protocol_RequestDecoder::GetType(uint64_t ordinal, bool* out_needs_response, bool* out_is_known) {
  *out_needs_response = false;
  *out_is_known = false;
  switch (ordinal) {
    case ::test::typesinprotocols::internal::kProtocol_OneWayBasic_Ordinal:
      *out_is_known = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayBasic_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorBasic_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return nullptr;
        ;
    case ::test::typesinprotocols::internal::kProtocol_OneWayCompound_Ordinal:
      *out_is_known = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayCompound_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorCompound_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return nullptr;
        ;
    case ::test::typesinprotocols::internal::kProtocol_OneWayArrayBasic_Ordinal:
      *out_is_known = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayArrayBasic_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorArrayBasic_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return nullptr;
        ;
    case ::test::typesinprotocols::internal::kProtocol_OneWayArrayCompound_Ordinal:
      *out_is_known = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayArrayCompound_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorArrayCompound_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return nullptr;
        ;
    case ::test::typesinprotocols::internal::kProtocol_OneWayVectorBasic_Ordinal:
      *out_is_known = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayVectorBasic_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorVectorBasic_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return nullptr;
        ;
    case ::test::typesinprotocols::internal::kProtocol_OneWayVectorCompound_Ordinal:
      *out_is_known = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayVectorCompound_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorVectorCompound_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return nullptr;
        ;
    case ::test::typesinprotocols::internal::kProtocol_OneWayVectorOptional_Ordinal:
      *out_is_known = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayVectorOptional_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorVectorOptional_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return nullptr;
        ;
    case ::test::typesinprotocols::internal::kProtocol_OneWayArrayVectorNested_Ordinal:
      *out_is_known = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayArrayVectorNested_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorArrayVectorNested_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return nullptr;
        ;
    case ::test::typesinprotocols::internal::kProtocol_OneWayResource_Ordinal:
      *out_is_known = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayResource_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorResource_Ordinal:
      *out_is_known = true;
      *out_needs_response = true;
      return nullptr;
        ;
    default:
      return nullptr;
  }
}

const fidl_type_t* Protocol_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    case ::test::typesinprotocols::internal::kProtocol_TwoWayBasic_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorBasic_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorBasicTopResponseTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_EventBasic_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayCompound_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorCompound_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorCompoundTopResponseTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_EventCompound_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayArrayBasic_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorArrayBasic_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorArrayBasicTopResponseTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_EventArrayBasic_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayArrayCompound_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorArrayCompound_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorArrayCompoundTopResponseTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_EventArrayCompound_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayVectorBasic_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorVectorBasic_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorVectorBasicTopResponseTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_EventVectorBasic_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayVectorCompound_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorVectorCompound_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorVectorCompoundTopResponseTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_EventVectorCompound_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayVectorOptional_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorVectorOptional_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorVectorOptionalTopResponseTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_EventVectorOptional_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayArrayVectorNested_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorArrayVectorNested_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorArrayVectorNestedTopResponseTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_EventArrayVectorNested_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_TwoWayResource_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_ErrorResource_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorResourceTopResponseTable;
        ;
    case ::test::typesinprotocols::internal::kProtocol_EventResource_Ordinal:
      return &::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable;
        ;
    default:
      return nullptr;
  }
}

Protocol_EventSender::~Protocol_EventSender() = default;

Protocol_Sync::~Protocol_Sync() = default;

Protocol_Proxy::Protocol_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

Protocol_Proxy::~Protocol_Proxy() = default;

zx_status_t Protocol_Proxy::Dispatch_(::fidl::HLCPPIncomingMessage message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case ::test::typesinprotocols::internal::kProtocol_EventBasic_Ordinal: {
      if (!EventBasic) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      EventBasic(::fidl::DecodeAs<uint8_t>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<uint16_t>(&decoder, 2 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<uint32_t>(&decoder, 4 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<uint64_t>(&decoder, 8 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int8_t>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int16_t>(&decoder, 18 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int32_t>(&decoder, 20 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int64_t>(&decoder, 24 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<float>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<double>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::string>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::StringPtr>(&decoder, 64 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_EventCompound_Ordinal: {
      if (!EventCompound) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      EventCompound(::fidl::DecodeAs<::test::typesinprotocols::Bits>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Enum>(&decoder, 4 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Struct>(&decoder, 8 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Table>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Union>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::Struct>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::Union>>(&decoder, 56 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_EventArrayBasic_Ordinal: {
      if (!EventArrayBasic) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      EventArrayBasic(::fidl::DecodeAs<::std::array<uint8_t, 5>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<uint16_t, 5>>(&decoder, 6 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<uint32_t, 5>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<uint64_t, 5>>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int8_t, 5>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int16_t, 5>>(&decoder, 86 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int32_t, 5>>(&decoder, 96 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int64_t, 5>>(&decoder, 120 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<float, 5>>(&decoder, 160 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<double, 5>>(&decoder, 184 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::string, 5>>(&decoder, 224 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::fidl::StringPtr, 5>>(&decoder, 304 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_EventArrayCompound_Ordinal: {
      if (!EventArrayCompound) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      EventArrayCompound(::fidl::DecodeAs<::std::array<::test::typesinprotocols::Bits, 5>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Enum, 5>>(&decoder, 20 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Struct, 5>>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Table, 5>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Union, 5>>(&decoder, 128 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>>(&decoder, 208 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>>(&decoder, 248 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_EventVectorBasic_Ordinal: {
      if (!EventVectorBasic) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      EventVectorBasic(::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<uint16_t>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<uint32_t>>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<uint64_t>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int8_t>>(&decoder, 64 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int16_t>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int32_t>>(&decoder, 96 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int64_t>>(&decoder, 112 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<float>>(&decoder, 128 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<double>>(&decoder, 144 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::string>>(&decoder, 160 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::fidl::StringPtr>>(&decoder, 176 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_EventVectorCompound_Ordinal: {
      if (!EventVectorCompound) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      EventVectorCompound(::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Bits>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Enum>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Struct>>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Table>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Union>>(&decoder, 64 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>>(&decoder, 96 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_EventVectorOptional_Ordinal: {
      if (!EventVectorOptional) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      EventVectorOptional(::fidl::DecodeAs<::fidl::VectorPtr<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::VectorPtr<::std::string>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>>(&decoder, 48 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_EventArrayVectorNested_Ordinal: {
      if (!EventArrayVectorNested) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      EventArrayVectorNested(::fidl::DecodeAs<::std::array<::std::array<uint8_t, 5>, 5>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::vector<uint8_t>, 5>>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::array<uint8_t, 5>>>(&decoder, 112 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::vector<uint8_t>>>(&decoder, 128 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_EventResource_Ordinal: {
      if (!EventResource) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      EventResource(::fidl::DecodeAs<::zx::handle>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::zx::vmo>(&decoder, 4 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>(&decoder, 8 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>(&decoder, 12 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::ResourceStruct>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::ResourceTable>(&decoder, 24 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::ResourceUnion>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::zx::handle>(&decoder, 56 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::zx::vmo>(&decoder, 60 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>(&decoder, 64 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>(&decoder, 68 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::ResourceStruct>>(&decoder, 72 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::ResourceUnion>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::zx::handle, 5>>(&decoder, 96 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::zx::vmo, 5>>(&decoder, 116 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>>(&decoder, 136 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>>(&decoder, 156 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceStruct, 5>>(&decoder, 176 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceTable, 5>>(&decoder, 184 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceUnion, 5>>(&decoder, 264 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::zx::handle>>(&decoder, 344 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::zx::vmo>>(&decoder, 360 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>>(&decoder, 376 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>>(&decoder, 392 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceStruct>>(&decoder, 408 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceTable>>(&decoder, 424 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceUnion>>(&decoder, 440 + sizeof(fidl_message_header_t)));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void Protocol_Proxy::OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayBasic_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayBasic(&_encoder, &uint8, &uint16, &uint32, &uint64, &int8, &int16, &int32, &int64, &float32, &float64, &string, &opt_string), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_TwoWayBasic_ResponseHandler(Protocol::TwoWayBasicCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::TwoWayBasic\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<uint8_t>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<uint16_t>(&decoder, 2 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<uint32_t>(&decoder, 4 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<uint64_t>(&decoder, 8 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int8_t>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int16_t>(&decoder, 18 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int32_t>(&decoder, 20 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int64_t>(&decoder, 24 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<float>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<double>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::string>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::StringPtr>(&decoder, 64 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable);
}

}  // namespace
void Protocol_Proxy::TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string, TwoWayBasicCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayBasic_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayBasic(&_encoder, &uint8, &uint16, &uint32, &uint64, &int8, &int16, &int32, &int64, &float32, &float64, &string, &opt_string), Protocol_TwoWayBasic_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_ErrorBasic_ResponseHandler(Protocol::ErrorBasicCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::ErrorBasic\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorBasic_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorBasicTopResponseTable);
}

}  // namespace
void Protocol_Proxy::ErrorBasic(ErrorBasicCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorBasic_DynamicFlags);
  const fidl_type_t* req_type =nullptr;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorBasic(&_encoder), Protocol_ErrorBasic_ResponseHandler(std::move(callback)));
}
void Protocol_Proxy::OneWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayCompound_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayCompound(&_encoder, &bits, &enum_, &struct_, &table, &union_, &opt_struct, &opt_union), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_TwoWayCompound_ResponseHandler(Protocol::TwoWayCompoundCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::TwoWayCompound\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::typesinprotocols::Bits>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Enum>(&decoder, 4 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Struct>(&decoder, 8 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Table>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Union>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::Struct>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::Union>>(&decoder, 56 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable);
}

}  // namespace
void Protocol_Proxy::TwoWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union, TwoWayCompoundCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayCompound_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayCompound(&_encoder, &bits, &enum_, &struct_, &table, &union_, &opt_struct, &opt_union), Protocol_TwoWayCompound_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_ErrorCompound_ResponseHandler(Protocol::ErrorCompoundCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::ErrorCompound\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorCompound_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorCompoundTopResponseTable);
}

}  // namespace
void Protocol_Proxy::ErrorCompound(ErrorCompoundCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorCompound_DynamicFlags);
  const fidl_type_t* req_type =nullptr;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorCompound(&_encoder), Protocol_ErrorCompound_ResponseHandler(std::move(callback)));
}
void Protocol_Proxy::OneWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayArrayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayArrayBasic_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayArrayBasic(&_encoder, &array_uint8, &array_uint16, &array_uint32, &array_uint64, &array_int8, &array_int16, &array_int32, &array_int64, &array_float32, &array_float64, &array_string, &array_opt_string), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_TwoWayArrayBasic_ResponseHandler(Protocol::TwoWayArrayBasicCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::TwoWayArrayBasic\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::std::array<uint8_t, 5>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<uint16_t, 5>>(&decoder, 6 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<uint32_t, 5>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<uint64_t, 5>>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int8_t, 5>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int16_t, 5>>(&decoder, 86 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int32_t, 5>>(&decoder, 96 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int64_t, 5>>(&decoder, 120 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<float, 5>>(&decoder, 160 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<double, 5>>(&decoder, 184 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::string, 5>>(&decoder, 224 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::fidl::StringPtr, 5>>(&decoder, 304 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable);
}

}  // namespace
void Protocol_Proxy::TwoWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string, TwoWayArrayBasicCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayArrayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayArrayBasic_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayArrayBasic(&_encoder, &array_uint8, &array_uint16, &array_uint32, &array_uint64, &array_int8, &array_int16, &array_int32, &array_int64, &array_float32, &array_float64, &array_string, &array_opt_string), Protocol_TwoWayArrayBasic_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_ErrorArrayBasic_ResponseHandler(Protocol::ErrorArrayBasicCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::ErrorArrayBasic\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorArrayBasic_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorArrayBasicTopResponseTable);
}

}  // namespace
void Protocol_Proxy::ErrorArrayBasic(ErrorArrayBasicCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorArrayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorArrayBasic_DynamicFlags);
  const fidl_type_t* req_type =nullptr;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorArrayBasic(&_encoder), Protocol_ErrorArrayBasic_ResponseHandler(std::move(callback)));
}
void Protocol_Proxy::OneWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayArrayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayArrayCompound_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayArrayCompound(&_encoder, &array_bits, &array_enum, &array_struct, &array_table, &array_union, &array_opt_struct, &array_opt_union), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_TwoWayArrayCompound_ResponseHandler(Protocol::TwoWayArrayCompoundCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::TwoWayArrayCompound\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::std::array<::test::typesinprotocols::Bits, 5>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Enum, 5>>(&decoder, 20 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Struct, 5>>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Table, 5>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Union, 5>>(&decoder, 128 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>>(&decoder, 208 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>>(&decoder, 248 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable);
}

}  // namespace
void Protocol_Proxy::TwoWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union, TwoWayArrayCompoundCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayArrayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayArrayCompound_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayArrayCompound(&_encoder, &array_bits, &array_enum, &array_struct, &array_table, &array_union, &array_opt_struct, &array_opt_union), Protocol_TwoWayArrayCompound_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_ErrorArrayCompound_ResponseHandler(Protocol::ErrorArrayCompoundCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::ErrorArrayCompound\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorArrayCompound_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorArrayCompoundTopResponseTable);
}

}  // namespace
void Protocol_Proxy::ErrorArrayCompound(ErrorArrayCompoundCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorArrayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorArrayCompound_DynamicFlags);
  const fidl_type_t* req_type =nullptr;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorArrayCompound(&_encoder), Protocol_ErrorArrayCompound_ResponseHandler(std::move(callback)));
}
void Protocol_Proxy::OneWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayVectorBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayVectorBasic_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayVectorBasic(&_encoder, &vector_uint8, &vector_uint16, &vector_uint32, &vector_uint64, &vector_int8, &vector_int16, &vector_int32, &vector_int64, &vector_float32, &vector_float64, &vector_string, &vector_opt_string), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_TwoWayVectorBasic_ResponseHandler(Protocol::TwoWayVectorBasicCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::TwoWayVectorBasic\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<uint16_t>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<uint32_t>>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<uint64_t>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int8_t>>(&decoder, 64 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int16_t>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int32_t>>(&decoder, 96 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int64_t>>(&decoder, 112 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<float>>(&decoder, 128 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<double>>(&decoder, 144 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::string>>(&decoder, 160 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::fidl::StringPtr>>(&decoder, 176 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable);
}

}  // namespace
void Protocol_Proxy::TwoWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string, TwoWayVectorBasicCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayVectorBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayVectorBasic_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayVectorBasic(&_encoder, &vector_uint8, &vector_uint16, &vector_uint32, &vector_uint64, &vector_int8, &vector_int16, &vector_int32, &vector_int64, &vector_float32, &vector_float64, &vector_string, &vector_opt_string), Protocol_TwoWayVectorBasic_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_ErrorVectorBasic_ResponseHandler(Protocol::ErrorVectorBasicCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::ErrorVectorBasic\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorVectorBasic_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorVectorBasicTopResponseTable);
}

}  // namespace
void Protocol_Proxy::ErrorVectorBasic(ErrorVectorBasicCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorVectorBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorVectorBasic_DynamicFlags);
  const fidl_type_t* req_type =nullptr;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorVectorBasic(&_encoder), Protocol_ErrorVectorBasic_ResponseHandler(std::move(callback)));
}
void Protocol_Proxy::OneWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayVectorCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayVectorCompound_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayVectorCompound(&_encoder, &vector_bits, &vector_enum, &vector_struct, &vector_table, &vector_union, &vector_opt_struct, &vector_opt_union), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_TwoWayVectorCompound_ResponseHandler(Protocol::TwoWayVectorCompoundCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::TwoWayVectorCompound\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Bits>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Enum>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Struct>>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Table>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Union>>(&decoder, 64 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>>(&decoder, 96 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable);
}

}  // namespace
void Protocol_Proxy::TwoWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union, TwoWayVectorCompoundCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayVectorCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayVectorCompound_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayVectorCompound(&_encoder, &vector_bits, &vector_enum, &vector_struct, &vector_table, &vector_union, &vector_opt_struct, &vector_opt_union), Protocol_TwoWayVectorCompound_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_ErrorVectorCompound_ResponseHandler(Protocol::ErrorVectorCompoundCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::ErrorVectorCompound\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorVectorCompound_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorVectorCompoundTopResponseTable);
}

}  // namespace
void Protocol_Proxy::ErrorVectorCompound(ErrorVectorCompoundCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorVectorCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorVectorCompound_DynamicFlags);
  const fidl_type_t* req_type =nullptr;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorVectorCompound(&_encoder), Protocol_ErrorVectorCompound_ResponseHandler(std::move(callback)));
}
void Protocol_Proxy::OneWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayVectorOptional_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayVectorOptional_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayVectorOptional(&_encoder, &opt_vector_uint8, &opt_vector_string, &opt_vector_opt_struct), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_TwoWayVectorOptional_ResponseHandler(Protocol::TwoWayVectorOptionalCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::TwoWayVectorOptional\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::fidl::VectorPtr<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::VectorPtr<::std::string>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>>(&decoder, 48 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable);
}

}  // namespace
void Protocol_Proxy::TwoWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct, TwoWayVectorOptionalCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayVectorOptional_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayVectorOptional_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayVectorOptional(&_encoder, &opt_vector_uint8, &opt_vector_string, &opt_vector_opt_struct), Protocol_TwoWayVectorOptional_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_ErrorVectorOptional_ResponseHandler(Protocol::ErrorVectorOptionalCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::ErrorVectorOptional\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorVectorOptional_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorVectorOptionalTopResponseTable);
}

}  // namespace
void Protocol_Proxy::ErrorVectorOptional(ErrorVectorOptionalCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorVectorOptional_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorVectorOptional_DynamicFlags);
  const fidl_type_t* req_type =nullptr;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorVectorOptional(&_encoder), Protocol_ErrorVectorOptional_ResponseHandler(std::move(callback)));
}
void Protocol_Proxy::OneWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayArrayVectorNested_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayArrayVectorNested_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayArrayVectorNested(&_encoder, &array_array_uint8, &array_vector_uint8, &vector_array_uint8, &vector_vector_uint8), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_TwoWayArrayVectorNested_ResponseHandler(Protocol::TwoWayArrayVectorNestedCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::TwoWayArrayVectorNested\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::std::array<::std::array<uint8_t, 5>, 5>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::vector<uint8_t>, 5>>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::array<uint8_t, 5>>>(&decoder, 112 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::vector<uint8_t>>>(&decoder, 128 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable);
}

}  // namespace
void Protocol_Proxy::TwoWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8, TwoWayArrayVectorNestedCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayArrayVectorNested_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayArrayVectorNested_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayArrayVectorNested(&_encoder, &array_array_uint8, &array_vector_uint8, &vector_array_uint8, &vector_vector_uint8), Protocol_TwoWayArrayVectorNested_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_ErrorArrayVectorNested_ResponseHandler(Protocol::ErrorArrayVectorNestedCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::ErrorArrayVectorNested\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorArrayVectorNestedTopResponseTable);
}

}  // namespace
void Protocol_Proxy::ErrorArrayVectorNested(ErrorArrayVectorNestedCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorArrayVectorNested_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorArrayVectorNested_DynamicFlags);
  const fidl_type_t* req_type =nullptr;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorArrayVectorNested(&_encoder), Protocol_ErrorArrayVectorNested_ResponseHandler(std::move(callback)));
}
void Protocol_Proxy::OneWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayResource_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayResource_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayResource(&_encoder, &handle, &vmo, &client_end, &server_end, &struct_, &table, &union_, &opt_handle, &opt_vmo, &opt_client_end, &opt_server_end, &opt_struct, &opt_union, &array_handle, &array_vmo, &array_client_end, &array_server_end, &array_struct, &array_table, &array_union, &vector_handle, &vector_vmo, &vector_client_end, &vector_server_end, &vector_struct, &vector_table, &vector_union), nullptr);
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_TwoWayResource_ResponseHandler(Protocol::TwoWayResourceCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::TwoWayResource\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::zx::handle>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::zx::vmo>(&decoder, 4 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>(&decoder, 8 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>(&decoder, 12 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::ResourceStruct>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::ResourceTable>(&decoder, 24 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::ResourceUnion>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::zx::handle>(&decoder, 56 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::zx::vmo>(&decoder, 60 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>(&decoder, 64 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>(&decoder, 68 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::ResourceStruct>>(&decoder, 72 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::ResourceUnion>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::zx::handle, 5>>(&decoder, 96 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::zx::vmo, 5>>(&decoder, 116 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>>(&decoder, 136 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>>(&decoder, 156 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceStruct, 5>>(&decoder, 176 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceTable, 5>>(&decoder, 184 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceUnion, 5>>(&decoder, 264 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::zx::handle>>(&decoder, 344 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::zx::vmo>>(&decoder, 360 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>>(&decoder, 376 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>>(&decoder, 392 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceStruct>>(&decoder, 408 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceTable>>(&decoder, 424 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceUnion>>(&decoder, 440 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable);
}

}  // namespace
void Protocol_Proxy::TwoWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union, TwoWayResourceCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayResource_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayResource_DynamicFlags);
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayResource(&_encoder, &handle, &vmo, &client_end, &server_end, &struct_, &table, &union_, &opt_handle, &opt_vmo, &opt_client_end, &opt_server_end, &opt_struct, &opt_union, &array_handle, &array_vmo, &array_client_end, &array_server_end, &array_struct, &array_table, &array_union, &vector_handle, &vector_vmo, &vector_client_end, &vector_server_end, &vector_struct, &vector_table, &vector_union), Protocol_TwoWayResource_ResponseHandler(std::move(callback)));
}
namespace {

::std::unique_ptr<::fidl::internal::SingleUseMessageHandler>
Protocol_ErrorResource_ResponseHandler(Protocol::ErrorResourceCallback&& callback) {
  ZX_DEBUG_ASSERT_MSG(callback,
                      "Callback must not be empty for Protocol::ErrorResource\n");
  return ::std::make_unique<::fidl::internal::SingleUseMessageHandler>(
      [callback_ = std::move(callback)](::fidl::HLCPPIncomingMessage&& message) {
        ::fidl::Decoder decoder(std::move(message));
        callback_(::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorResource_Result>(&decoder, 0 + sizeof(fidl_message_header_t)));
        return ZX_OK;
      }, &::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorResourceTopResponseTable);
}

}  // namespace
void Protocol_Proxy::ErrorResource(ErrorResourceCallback callback) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorResource_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorResource_DynamicFlags);
  const fidl_type_t* req_type =nullptr;
  controller_->Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorResource(&_encoder), Protocol_ErrorResource_ResponseHandler(std::move(callback)));
}

Protocol_Stub::Protocol_Stub(::test::typesinprotocols::Protocol_Stub::Protocol_clazz* impl) : impl_(impl) {
  (void)impl_;
}

Protocol_Stub::~Protocol_Stub() = default;

namespace {

class Protocol_TwoWayBasic_Responder final {
 public:
  Protocol_TwoWayBasic_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayBasic_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::TwoWayBasic(&_encoder, &uint8, &uint16, &uint32, &uint64, &int8, &int16, &int32, &int64, &float32, &float64, &string, &opt_string));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_ErrorBasic_Responder final {
 public:
  Protocol_ErrorBasic_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::typesinprotocols::Protocol_ErrorBasic_Result result) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorBasic_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorBasicTopResponseTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::ErrorBasic(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_TwoWayCompound_Responder final {
 public:
  Protocol_TwoWayCompound_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayCompound_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::TwoWayCompound(&_encoder, &bits, &enum_, &struct_, &table, &union_, &opt_struct, &opt_union));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_ErrorCompound_Responder final {
 public:
  Protocol_ErrorCompound_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::typesinprotocols::Protocol_ErrorCompound_Result result) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorCompound_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorCompoundTopResponseTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::ErrorCompound(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_TwoWayArrayBasic_Responder final {
 public:
  Protocol_TwoWayArrayBasic_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayArrayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayArrayBasic_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::TwoWayArrayBasic(&_encoder, &array_uint8, &array_uint16, &array_uint32, &array_uint64, &array_int8, &array_int16, &array_int32, &array_int64, &array_float32, &array_float64, &array_string, &array_opt_string));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_ErrorArrayBasic_Responder final {
 public:
  Protocol_ErrorArrayBasic_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::typesinprotocols::Protocol_ErrorArrayBasic_Result result) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorArrayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorArrayBasic_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorArrayBasicTopResponseTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::ErrorArrayBasic(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_TwoWayArrayCompound_Responder final {
 public:
  Protocol_TwoWayArrayCompound_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayArrayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayArrayCompound_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::TwoWayArrayCompound(&_encoder, &array_bits, &array_enum, &array_struct, &array_table, &array_union, &array_opt_struct, &array_opt_union));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_ErrorArrayCompound_Responder final {
 public:
  Protocol_ErrorArrayCompound_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::typesinprotocols::Protocol_ErrorArrayCompound_Result result) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorArrayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorArrayCompound_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorArrayCompoundTopResponseTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::ErrorArrayCompound(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_TwoWayVectorBasic_Responder final {
 public:
  Protocol_TwoWayVectorBasic_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayVectorBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayVectorBasic_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::TwoWayVectorBasic(&_encoder, &vector_uint8, &vector_uint16, &vector_uint32, &vector_uint64, &vector_int8, &vector_int16, &vector_int32, &vector_int64, &vector_float32, &vector_float64, &vector_string, &vector_opt_string));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_ErrorVectorBasic_Responder final {
 public:
  Protocol_ErrorVectorBasic_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::typesinprotocols::Protocol_ErrorVectorBasic_Result result) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorVectorBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorVectorBasic_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorVectorBasicTopResponseTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::ErrorVectorBasic(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_TwoWayVectorCompound_Responder final {
 public:
  Protocol_TwoWayVectorCompound_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayVectorCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayVectorCompound_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::TwoWayVectorCompound(&_encoder, &vector_bits, &vector_enum, &vector_struct, &vector_table, &vector_union, &vector_opt_struct, &vector_opt_union));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_ErrorVectorCompound_Responder final {
 public:
  Protocol_ErrorVectorCompound_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::typesinprotocols::Protocol_ErrorVectorCompound_Result result) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorVectorCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorVectorCompound_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorVectorCompoundTopResponseTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::ErrorVectorCompound(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_TwoWayVectorOptional_Responder final {
 public:
  Protocol_TwoWayVectorOptional_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayVectorOptional_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayVectorOptional_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::TwoWayVectorOptional(&_encoder, &opt_vector_uint8, &opt_vector_string, &opt_vector_opt_struct));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_ErrorVectorOptional_Responder final {
 public:
  Protocol_ErrorVectorOptional_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::typesinprotocols::Protocol_ErrorVectorOptional_Result result) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorVectorOptional_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorVectorOptional_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorVectorOptionalTopResponseTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::ErrorVectorOptional(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_TwoWayArrayVectorNested_Responder final {
 public:
  Protocol_TwoWayArrayVectorNested_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayArrayVectorNested_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayArrayVectorNested_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::TwoWayArrayVectorNested(&_encoder, &array_array_uint8, &array_vector_uint8, &vector_array_uint8, &vector_vector_uint8));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_ErrorArrayVectorNested_Responder final {
 public:
  Protocol_ErrorArrayVectorNested_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result result) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorArrayVectorNested_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorArrayVectorNested_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorArrayVectorNestedTopResponseTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::ErrorArrayVectorNested(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_TwoWayResource_Responder final {
 public:
  Protocol_TwoWayResource_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayResource_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayResource_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::TwoWayResource(&_encoder, &handle, &vmo, &client_end, &server_end, &struct_, &table, &union_, &opt_handle, &opt_vmo, &opt_client_end, &opt_server_end, &opt_struct, &opt_union, &array_handle, &array_vmo, &array_client_end, &array_server_end, &array_struct, &array_table, &array_union, &vector_handle, &vector_vmo, &vector_client_end, &vector_server_end, &vector_struct, &vector_table, &vector_union));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

class Protocol_ErrorResource_Responder final {
 public:
  Protocol_ErrorResource_Responder(::fidl::internal::PendingResponse response)
      : response_(std::move(response)) {}

  void operator()(::test::typesinprotocols::Protocol_ErrorResource_Result result) {
    ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorResource_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorResource_DynamicFlags);
    const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorResourceTopResponseTable;
    response_.Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::ErrorResource(&_encoder, &result));
  }

 private:
  ::fidl::internal::PendingResponse response_;
};

}  // namespace

zx_status_t Protocol_Stub::Dispatch_(
    ::fidl::HLCPPIncomingMessage message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  bool is_known;
  const fidl_type_t* request_type = ::test::typesinprotocols::Protocol_RequestDecoder::GetType(message.ordinal(), &needs_response, &is_known);

  if (!is_known) {
    return ZX_ERR_NOT_SUPPORTED;
  }

  if (!message.has_only_header()) {
    if (request_type == nullptr) {
      return ZX_ERR_NOT_SUPPORTED;
    }
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(request_type, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
      return status;
    }
  }

  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type, "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }

  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case ::test::typesinprotocols::internal::kProtocol_OneWayBasic_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayBasic(::fidl::DecodeAs<uint8_t>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<uint16_t>(&decoder, 2 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<uint32_t>(&decoder, 4 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<uint64_t>(&decoder, 8 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int8_t>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int16_t>(&decoder, 18 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int32_t>(&decoder, 20 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int64_t>(&decoder, 24 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<float>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<double>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::string>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::StringPtr>(&decoder, 64 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_TwoWayBasic_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayBasic(::fidl::DecodeAs<uint8_t>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<uint16_t>(&decoder, 2 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<uint32_t>(&decoder, 4 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<uint64_t>(&decoder, 8 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int8_t>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int16_t>(&decoder, 18 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int32_t>(&decoder, 20 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<int64_t>(&decoder, 24 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<float>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<double>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::string>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::StringPtr>(&decoder, 64 + sizeof(fidl_message_header_t)), Protocol_TwoWayBasic_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_ErrorBasic_Ordinal:
    {
      impl_->ErrorBasic(Protocol_ErrorBasic_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_OneWayCompound_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayCompound(::fidl::DecodeAs<::test::typesinprotocols::Bits>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Enum>(&decoder, 4 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Struct>(&decoder, 8 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Table>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Union>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::Struct>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::Union>>(&decoder, 56 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_TwoWayCompound_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayCompound(::fidl::DecodeAs<::test::typesinprotocols::Bits>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Enum>(&decoder, 4 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Struct>(&decoder, 8 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Table>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::Union>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::Struct>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::Union>>(&decoder, 56 + sizeof(fidl_message_header_t)), Protocol_TwoWayCompound_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_ErrorCompound_Ordinal:
    {
      impl_->ErrorCompound(Protocol_ErrorCompound_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_OneWayArrayBasic_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayArrayBasic(::fidl::DecodeAs<::std::array<uint8_t, 5>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<uint16_t, 5>>(&decoder, 6 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<uint32_t, 5>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<uint64_t, 5>>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int8_t, 5>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int16_t, 5>>(&decoder, 86 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int32_t, 5>>(&decoder, 96 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int64_t, 5>>(&decoder, 120 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<float, 5>>(&decoder, 160 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<double, 5>>(&decoder, 184 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::string, 5>>(&decoder, 224 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::fidl::StringPtr, 5>>(&decoder, 304 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_TwoWayArrayBasic_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayArrayBasic(::fidl::DecodeAs<::std::array<uint8_t, 5>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<uint16_t, 5>>(&decoder, 6 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<uint32_t, 5>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<uint64_t, 5>>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int8_t, 5>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int16_t, 5>>(&decoder, 86 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int32_t, 5>>(&decoder, 96 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<int64_t, 5>>(&decoder, 120 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<float, 5>>(&decoder, 160 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<double, 5>>(&decoder, 184 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::string, 5>>(&decoder, 224 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::fidl::StringPtr, 5>>(&decoder, 304 + sizeof(fidl_message_header_t)), Protocol_TwoWayArrayBasic_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_ErrorArrayBasic_Ordinal:
    {
      impl_->ErrorArrayBasic(Protocol_ErrorArrayBasic_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_OneWayArrayCompound_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayArrayCompound(::fidl::DecodeAs<::std::array<::test::typesinprotocols::Bits, 5>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Enum, 5>>(&decoder, 20 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Struct, 5>>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Table, 5>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Union, 5>>(&decoder, 128 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>>(&decoder, 208 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>>(&decoder, 248 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_TwoWayArrayCompound_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayArrayCompound(::fidl::DecodeAs<::std::array<::test::typesinprotocols::Bits, 5>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Enum, 5>>(&decoder, 20 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Struct, 5>>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Table, 5>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Union, 5>>(&decoder, 128 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>>(&decoder, 208 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>>(&decoder, 248 + sizeof(fidl_message_header_t)), Protocol_TwoWayArrayCompound_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_ErrorArrayCompound_Ordinal:
    {
      impl_->ErrorArrayCompound(Protocol_ErrorArrayCompound_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_OneWayVectorBasic_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayVectorBasic(::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<uint16_t>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<uint32_t>>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<uint64_t>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int8_t>>(&decoder, 64 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int16_t>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int32_t>>(&decoder, 96 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int64_t>>(&decoder, 112 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<float>>(&decoder, 128 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<double>>(&decoder, 144 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::string>>(&decoder, 160 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::fidl::StringPtr>>(&decoder, 176 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_TwoWayVectorBasic_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayVectorBasic(::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<uint16_t>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<uint32_t>>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<uint64_t>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int8_t>>(&decoder, 64 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int16_t>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int32_t>>(&decoder, 96 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<int64_t>>(&decoder, 112 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<float>>(&decoder, 128 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<double>>(&decoder, 144 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::string>>(&decoder, 160 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::fidl::StringPtr>>(&decoder, 176 + sizeof(fidl_message_header_t)), Protocol_TwoWayVectorBasic_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_ErrorVectorBasic_Ordinal:
    {
      impl_->ErrorVectorBasic(Protocol_ErrorVectorBasic_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_OneWayVectorCompound_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayVectorCompound(::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Bits>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Enum>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Struct>>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Table>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Union>>(&decoder, 64 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>>(&decoder, 96 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_TwoWayVectorCompound_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayVectorCompound(::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Bits>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Enum>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Struct>>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Table>>(&decoder, 48 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Union>>(&decoder, 64 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>>(&decoder, 96 + sizeof(fidl_message_header_t)), Protocol_TwoWayVectorCompound_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_ErrorVectorCompound_Ordinal:
    {
      impl_->ErrorVectorCompound(Protocol_ErrorVectorCompound_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_OneWayVectorOptional_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayVectorOptional(::fidl::DecodeAs<::fidl::VectorPtr<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::VectorPtr<::std::string>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>>(&decoder, 48 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_TwoWayVectorOptional_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayVectorOptional(::fidl::DecodeAs<::fidl::VectorPtr<uint8_t>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::VectorPtr<::std::string>>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>>(&decoder, 48 + sizeof(fidl_message_header_t)), Protocol_TwoWayVectorOptional_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_ErrorVectorOptional_Ordinal:
    {
      impl_->ErrorVectorOptional(Protocol_ErrorVectorOptional_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_OneWayArrayVectorNested_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayArrayVectorNested(::fidl::DecodeAs<::std::array<::std::array<uint8_t, 5>, 5>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::vector<uint8_t>, 5>>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::array<uint8_t, 5>>>(&decoder, 112 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::vector<uint8_t>>>(&decoder, 128 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_TwoWayArrayVectorNested_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayArrayVectorNested(::fidl::DecodeAs<::std::array<::std::array<uint8_t, 5>, 5>>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::std::vector<uint8_t>, 5>>(&decoder, 32 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::array<uint8_t, 5>>>(&decoder, 112 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::std::vector<uint8_t>>>(&decoder, 128 + sizeof(fidl_message_header_t)), Protocol_TwoWayArrayVectorNested_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_ErrorArrayVectorNested_Ordinal:
    {
      impl_->ErrorArrayVectorNested(Protocol_ErrorArrayVectorNested_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_OneWayResource_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->OneWayResource(::fidl::DecodeAs<::zx::handle>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::zx::vmo>(&decoder, 4 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>(&decoder, 8 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>(&decoder, 12 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::ResourceStruct>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::ResourceTable>(&decoder, 24 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::ResourceUnion>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::zx::handle>(&decoder, 56 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::zx::vmo>(&decoder, 60 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>(&decoder, 64 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>(&decoder, 68 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::ResourceStruct>>(&decoder, 72 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::ResourceUnion>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::zx::handle, 5>>(&decoder, 96 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::zx::vmo, 5>>(&decoder, 116 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>>(&decoder, 136 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>>(&decoder, 156 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceStruct, 5>>(&decoder, 176 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceTable, 5>>(&decoder, 184 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceUnion, 5>>(&decoder, 264 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::zx::handle>>(&decoder, 344 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::zx::vmo>>(&decoder, 360 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>>(&decoder, 376 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>>(&decoder, 392 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceStruct>>(&decoder, 408 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceTable>>(&decoder, 424 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceUnion>>(&decoder, 440 + sizeof(fidl_message_header_t)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_TwoWayResource_Ordinal:
    {
      ::fidl::Decoder decoder(std::move(message));
      impl_->TwoWayResource(::fidl::DecodeAs<::zx::handle>(&decoder, 0 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::zx::vmo>(&decoder, 4 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>(&decoder, 8 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>(&decoder, 12 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::ResourceStruct>(&decoder, 16 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::ResourceTable>(&decoder, 24 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::test::typesinprotocols::ResourceUnion>(&decoder, 40 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::zx::handle>(&decoder, 56 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::zx::vmo>(&decoder, 60 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>(&decoder, 64 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>(&decoder, 68 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::ResourceStruct>>(&decoder, 72 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::ResourceUnion>>(&decoder, 80 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::zx::handle, 5>>(&decoder, 96 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::zx::vmo, 5>>(&decoder, 116 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>>(&decoder, 136 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>>(&decoder, 156 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceStruct, 5>>(&decoder, 176 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceTable, 5>>(&decoder, 184 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceUnion, 5>>(&decoder, 264 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::zx::handle>>(&decoder, 344 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::zx::vmo>>(&decoder, 360 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>>(&decoder, 376 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>>(&decoder, 392 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceStruct>>(&decoder, 408 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceTable>>(&decoder, 424 + sizeof(fidl_message_header_t)), ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceUnion>>(&decoder, 440 + sizeof(fidl_message_header_t)), Protocol_TwoWayResource_Responder(std::move(response)));
      break;
    }
    case ::test::typesinprotocols::internal::kProtocol_ErrorResource_Ordinal:
    {
      impl_->ErrorResource(Protocol_ErrorResource_Responder(std::move(response)));
      break;
    }
    default: {
      // Unknown ordinals are handled at the beginning of dispatching, so this
      // should be unreachable.
      ZX_PANIC("Unreachable: unknown ordinals handled earlier.");
    }
  }
  return ZX_OK;
}
void Protocol_Stub::EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_EventBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_EventBasic_DynamicFlags);
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable;sender_()->Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::EventBasic(&_encoder, &uint8, &uint16, &uint32, &uint64, &int8, &int16, &int32, &int64, &float32, &float64, &string, &opt_string));
}
void Protocol_Stub::EventCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_EventCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_EventCompound_DynamicFlags);
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable;sender_()->Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::EventCompound(&_encoder, &bits, &enum_, &struct_, &table, &union_, &opt_struct, &opt_union));
}
void Protocol_Stub::EventArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_EventArrayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_EventArrayBasic_DynamicFlags);
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable;sender_()->Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::EventArrayBasic(&_encoder, &array_uint8, &array_uint16, &array_uint32, &array_uint64, &array_int8, &array_int16, &array_int32, &array_int64, &array_float32, &array_float64, &array_string, &array_opt_string));
}
void Protocol_Stub::EventArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_EventArrayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_EventArrayCompound_DynamicFlags);
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable;sender_()->Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::EventArrayCompound(&_encoder, &array_bits, &array_enum, &array_struct, &array_table, &array_union, &array_opt_struct, &array_opt_union));
}
void Protocol_Stub::EventVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_EventVectorBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_EventVectorBasic_DynamicFlags);
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable;sender_()->Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::EventVectorBasic(&_encoder, &vector_uint8, &vector_uint16, &vector_uint32, &vector_uint64, &vector_int8, &vector_int16, &vector_int32, &vector_int64, &vector_float32, &vector_float64, &vector_string, &vector_opt_string));
}
void Protocol_Stub::EventVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_EventVectorCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_EventVectorCompound_DynamicFlags);
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable;sender_()->Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::EventVectorCompound(&_encoder, &vector_bits, &vector_enum, &vector_struct, &vector_table, &vector_union, &vector_opt_struct, &vector_opt_union));
}
void Protocol_Stub::EventVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_EventVectorOptional_Ordinal, ::test::typesinprotocols::internal::kProtocol_EventVectorOptional_DynamicFlags);
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable;sender_()->Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::EventVectorOptional(&_encoder, &opt_vector_uint8, &opt_vector_string, &opt_vector_opt_struct));
}
void Protocol_Stub::EventArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_EventArrayVectorNested_Ordinal, ::test::typesinprotocols::internal::kProtocol_EventArrayVectorNested_DynamicFlags);
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable;sender_()->Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::EventArrayVectorNested(&_encoder, &array_array_uint8, &array_vector_uint8, &vector_array_uint8, &vector_vector_uint8));
}
void Protocol_Stub::EventResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_EventResource_Ordinal, ::test::typesinprotocols::internal::kProtocol_EventResource_DynamicFlags);
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable;sender_()->Send(resp_type, ::test::typesinprotocols::Protocol_ResponseEncoder::EventResource(&_encoder, &handle, &vmo, &client_end, &server_end, &struct_, &table, &union_, &opt_handle, &opt_vmo, &opt_client_end, &opt_server_end, &opt_struct, &opt_union, &array_handle, &array_vmo, &array_client_end, &array_server_end, &array_struct, &array_table, &array_union, &vector_handle, &vector_vmo, &vector_client_end, &vector_server_end, &vector_struct, &vector_table, &vector_union));
}

Protocol_SyncProxy::Protocol_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

Protocol_SyncProxy::~Protocol_SyncProxy() = default;

zx_status_t Protocol_SyncProxy::OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayBasic_DynamicFlags);
    const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable;
  return proxy_.Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayBasic(&_encoder, &uint8, &uint16, &uint32, &uint64, &int8, &int16, &int32, &int64, &float32, &float64, &string, &opt_string));
}

zx_status_t Protocol_SyncProxy::TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::fidl::StringPtr opt_string, uint8_t* out_uint8, uint16_t* out_uint16, uint32_t* out_uint32, uint64_t* out_uint64, int8_t* out_int8, int16_t* out_int16, int32_t* out_int32, int64_t* out_int64, float* out_float32, double* out_float64, ::std::string* out_string, ::fidl::StringPtr* out_opt_string) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayBasic_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_BasicTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayBasic(&_encoder, &uint8, &uint16, &uint32, &uint64, &int8, &int16, &int32, &int64, &float32, &float64, &string, &opt_string), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_uint8 = ::fidl::DecodeAs<uint8_t>(&decoder_, 0 + sizeof(fidl_message_header_t));
  *out_uint16 = ::fidl::DecodeAs<uint16_t>(&decoder_, 2 + sizeof(fidl_message_header_t));
  *out_uint32 = ::fidl::DecodeAs<uint32_t>(&decoder_, 4 + sizeof(fidl_message_header_t));
  *out_uint64 = ::fidl::DecodeAs<uint64_t>(&decoder_, 8 + sizeof(fidl_message_header_t));
  *out_int8 = ::fidl::DecodeAs<int8_t>(&decoder_, 16 + sizeof(fidl_message_header_t));
  *out_int16 = ::fidl::DecodeAs<int16_t>(&decoder_, 18 + sizeof(fidl_message_header_t));
  *out_int32 = ::fidl::DecodeAs<int32_t>(&decoder_, 20 + sizeof(fidl_message_header_t));
  *out_int64 = ::fidl::DecodeAs<int64_t>(&decoder_, 24 + sizeof(fidl_message_header_t));
  *out_float32 = ::fidl::DecodeAs<float>(&decoder_, 32 + sizeof(fidl_message_header_t));
  *out_float64 = ::fidl::DecodeAs<double>(&decoder_, 40 + sizeof(fidl_message_header_t));
  *out_string = ::fidl::DecodeAs<::std::string>(&decoder_, 48 + sizeof(fidl_message_header_t));
  *out_opt_string = ::fidl::DecodeAs<::fidl::StringPtr>(&decoder_, 64 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::ErrorBasic(::test::typesinprotocols::Protocol_ErrorBasic_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorBasic_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =nullptr;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorBasicTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorBasic(&_encoder), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorBasic_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::OneWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayCompound_DynamicFlags);
    const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable;
  return proxy_.Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayCompound(&_encoder, &bits, &enum_, &struct_, &table, &union_, &opt_struct, &opt_union));
}

zx_status_t Protocol_SyncProxy::TwoWayCompound(::test::typesinprotocols::Bits bits, ::test::typesinprotocols::Enum enum_, ::test::typesinprotocols::Struct struct_, ::test::typesinprotocols::Table table, ::test::typesinprotocols::Union union_, ::std::unique_ptr<::test::typesinprotocols::Struct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union> opt_union, ::test::typesinprotocols::Bits* out_bits, ::test::typesinprotocols::Enum* out_enum_, ::test::typesinprotocols::Struct* out_struct_, ::test::typesinprotocols::Table* out_table, ::test::typesinprotocols::Union* out_union_, ::std::unique_ptr<::test::typesinprotocols::Struct>* out_opt_struct, ::std::unique_ptr<::test::typesinprotocols::Union>* out_opt_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayCompound_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_CompoundTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayCompound(&_encoder, &bits, &enum_, &struct_, &table, &union_, &opt_struct, &opt_union), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_bits = ::fidl::DecodeAs<::test::typesinprotocols::Bits>(&decoder_, 0 + sizeof(fidl_message_header_t));
  *out_enum_ = ::fidl::DecodeAs<::test::typesinprotocols::Enum>(&decoder_, 4 + sizeof(fidl_message_header_t));
  *out_struct_ = ::fidl::DecodeAs<::test::typesinprotocols::Struct>(&decoder_, 8 + sizeof(fidl_message_header_t));
  *out_table = ::fidl::DecodeAs<::test::typesinprotocols::Table>(&decoder_, 16 + sizeof(fidl_message_header_t));
  *out_union_ = ::fidl::DecodeAs<::test::typesinprotocols::Union>(&decoder_, 32 + sizeof(fidl_message_header_t));
  *out_opt_struct = ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::Struct>>(&decoder_, 48 + sizeof(fidl_message_header_t));
  *out_opt_union = ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::Union>>(&decoder_, 56 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::ErrorCompound(::test::typesinprotocols::Protocol_ErrorCompound_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorCompound_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =nullptr;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorCompoundTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorCompound(&_encoder), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorCompound_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::OneWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayArrayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayArrayBasic_DynamicFlags);
    const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable;
  return proxy_.Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayArrayBasic(&_encoder, &array_uint8, &array_uint16, &array_uint32, &array_uint64, &array_int8, &array_int16, &array_int32, &array_int64, &array_float32, &array_float64, &array_string, &array_opt_string));
}

zx_status_t Protocol_SyncProxy::TwoWayArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::fidl::StringPtr, 5> array_opt_string, ::std::array<uint8_t, 5>* out_array_uint8, ::std::array<uint16_t, 5>* out_array_uint16, ::std::array<uint32_t, 5>* out_array_uint32, ::std::array<uint64_t, 5>* out_array_uint64, ::std::array<int8_t, 5>* out_array_int8, ::std::array<int16_t, 5>* out_array_int16, ::std::array<int32_t, 5>* out_array_int32, ::std::array<int64_t, 5>* out_array_int64, ::std::array<float, 5>* out_array_float32, ::std::array<double, 5>* out_array_float64, ::std::array<::std::string, 5>* out_array_string, ::std::array<::fidl::StringPtr, 5>* out_array_opt_string) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayArrayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayArrayBasic_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayBasicTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayArrayBasic(&_encoder, &array_uint8, &array_uint16, &array_uint32, &array_uint64, &array_int8, &array_int16, &array_int32, &array_int64, &array_float32, &array_float64, &array_string, &array_opt_string), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_array_uint8 = ::fidl::DecodeAs<::std::array<uint8_t, 5>>(&decoder_, 0 + sizeof(fidl_message_header_t));
  *out_array_uint16 = ::fidl::DecodeAs<::std::array<uint16_t, 5>>(&decoder_, 6 + sizeof(fidl_message_header_t));
  *out_array_uint32 = ::fidl::DecodeAs<::std::array<uint32_t, 5>>(&decoder_, 16 + sizeof(fidl_message_header_t));
  *out_array_uint64 = ::fidl::DecodeAs<::std::array<uint64_t, 5>>(&decoder_, 40 + sizeof(fidl_message_header_t));
  *out_array_int8 = ::fidl::DecodeAs<::std::array<int8_t, 5>>(&decoder_, 80 + sizeof(fidl_message_header_t));
  *out_array_int16 = ::fidl::DecodeAs<::std::array<int16_t, 5>>(&decoder_, 86 + sizeof(fidl_message_header_t));
  *out_array_int32 = ::fidl::DecodeAs<::std::array<int32_t, 5>>(&decoder_, 96 + sizeof(fidl_message_header_t));
  *out_array_int64 = ::fidl::DecodeAs<::std::array<int64_t, 5>>(&decoder_, 120 + sizeof(fidl_message_header_t));
  *out_array_float32 = ::fidl::DecodeAs<::std::array<float, 5>>(&decoder_, 160 + sizeof(fidl_message_header_t));
  *out_array_float64 = ::fidl::DecodeAs<::std::array<double, 5>>(&decoder_, 184 + sizeof(fidl_message_header_t));
  *out_array_string = ::fidl::DecodeAs<::std::array<::std::string, 5>>(&decoder_, 224 + sizeof(fidl_message_header_t));
  *out_array_opt_string = ::fidl::DecodeAs<::std::array<::fidl::StringPtr, 5>>(&decoder_, 304 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::ErrorArrayBasic(::test::typesinprotocols::Protocol_ErrorArrayBasic_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorArrayBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorArrayBasic_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =nullptr;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorArrayBasicTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorArrayBasic(&_encoder), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorArrayBasic_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::OneWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayArrayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayArrayCompound_DynamicFlags);
    const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable;
  return proxy_.Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayArrayCompound(&_encoder, &array_bits, &array_enum, &array_struct, &array_table, &array_union, &array_opt_struct, &array_opt_union));
}

zx_status_t Protocol_SyncProxy::TwoWayArrayCompound(::std::array<::test::typesinprotocols::Bits, 5> array_bits, ::std::array<::test::typesinprotocols::Enum, 5> array_enum, ::std::array<::test::typesinprotocols::Struct, 5> array_struct, ::std::array<::test::typesinprotocols::Table, 5> array_table, ::std::array<::test::typesinprotocols::Union, 5> array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5> array_opt_union, ::std::array<::test::typesinprotocols::Bits, 5>* out_array_bits, ::std::array<::test::typesinprotocols::Enum, 5>* out_array_enum, ::std::array<::test::typesinprotocols::Struct, 5>* out_array_struct, ::std::array<::test::typesinprotocols::Table, 5>* out_array_table, ::std::array<::test::typesinprotocols::Union, 5>* out_array_union, ::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>* out_array_opt_struct, ::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>* out_array_opt_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayArrayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayArrayCompound_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayCompoundTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayArrayCompound(&_encoder, &array_bits, &array_enum, &array_struct, &array_table, &array_union, &array_opt_struct, &array_opt_union), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_array_bits = ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Bits, 5>>(&decoder_, 0 + sizeof(fidl_message_header_t));
  *out_array_enum = ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Enum, 5>>(&decoder_, 20 + sizeof(fidl_message_header_t));
  *out_array_struct = ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Struct, 5>>(&decoder_, 40 + sizeof(fidl_message_header_t));
  *out_array_table = ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Table, 5>>(&decoder_, 48 + sizeof(fidl_message_header_t));
  *out_array_union = ::fidl::DecodeAs<::std::array<::test::typesinprotocols::Union, 5>>(&decoder_, 128 + sizeof(fidl_message_header_t));
  *out_array_opt_struct = ::fidl::DecodeAs<::std::array<::std::unique_ptr<::test::typesinprotocols::Struct>, 5>>(&decoder_, 208 + sizeof(fidl_message_header_t));
  *out_array_opt_union = ::fidl::DecodeAs<::std::array<::std::unique_ptr<::test::typesinprotocols::Union>, 5>>(&decoder_, 248 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::ErrorArrayCompound(::test::typesinprotocols::Protocol_ErrorArrayCompound_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorArrayCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorArrayCompound_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =nullptr;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorArrayCompoundTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorArrayCompound(&_encoder), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorArrayCompound_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::OneWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayVectorBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayVectorBasic_DynamicFlags);
    const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable;
  return proxy_.Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayVectorBasic(&_encoder, &vector_uint8, &vector_uint16, &vector_uint32, &vector_uint64, &vector_int8, &vector_int16, &vector_int32, &vector_int64, &vector_float32, &vector_float64, &vector_string, &vector_opt_string));
}

zx_status_t Protocol_SyncProxy::TwoWayVectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::fidl::StringPtr> vector_opt_string, ::std::vector<uint8_t>* out_vector_uint8, ::std::vector<uint16_t>* out_vector_uint16, ::std::vector<uint32_t>* out_vector_uint32, ::std::vector<uint64_t>* out_vector_uint64, ::std::vector<int8_t>* out_vector_int8, ::std::vector<int16_t>* out_vector_int16, ::std::vector<int32_t>* out_vector_int32, ::std::vector<int64_t>* out_vector_int64, ::std::vector<float>* out_vector_float32, ::std::vector<double>* out_vector_float64, ::std::vector<::std::string>* out_vector_string, ::std::vector<::fidl::StringPtr>* out_vector_opt_string) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayVectorBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayVectorBasic_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorBasicTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayVectorBasic(&_encoder, &vector_uint8, &vector_uint16, &vector_uint32, &vector_uint64, &vector_int8, &vector_int16, &vector_int32, &vector_int64, &vector_float32, &vector_float64, &vector_string, &vector_opt_string), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_vector_uint8 = ::fidl::DecodeAs<::std::vector<uint8_t>>(&decoder_, 0 + sizeof(fidl_message_header_t));
  *out_vector_uint16 = ::fidl::DecodeAs<::std::vector<uint16_t>>(&decoder_, 16 + sizeof(fidl_message_header_t));
  *out_vector_uint32 = ::fidl::DecodeAs<::std::vector<uint32_t>>(&decoder_, 32 + sizeof(fidl_message_header_t));
  *out_vector_uint64 = ::fidl::DecodeAs<::std::vector<uint64_t>>(&decoder_, 48 + sizeof(fidl_message_header_t));
  *out_vector_int8 = ::fidl::DecodeAs<::std::vector<int8_t>>(&decoder_, 64 + sizeof(fidl_message_header_t));
  *out_vector_int16 = ::fidl::DecodeAs<::std::vector<int16_t>>(&decoder_, 80 + sizeof(fidl_message_header_t));
  *out_vector_int32 = ::fidl::DecodeAs<::std::vector<int32_t>>(&decoder_, 96 + sizeof(fidl_message_header_t));
  *out_vector_int64 = ::fidl::DecodeAs<::std::vector<int64_t>>(&decoder_, 112 + sizeof(fidl_message_header_t));
  *out_vector_float32 = ::fidl::DecodeAs<::std::vector<float>>(&decoder_, 128 + sizeof(fidl_message_header_t));
  *out_vector_float64 = ::fidl::DecodeAs<::std::vector<double>>(&decoder_, 144 + sizeof(fidl_message_header_t));
  *out_vector_string = ::fidl::DecodeAs<::std::vector<::std::string>>(&decoder_, 160 + sizeof(fidl_message_header_t));
  *out_vector_opt_string = ::fidl::DecodeAs<::std::vector<::fidl::StringPtr>>(&decoder_, 176 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::ErrorVectorBasic(::test::typesinprotocols::Protocol_ErrorVectorBasic_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorVectorBasic_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorVectorBasic_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =nullptr;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorVectorBasicTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorVectorBasic(&_encoder), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorVectorBasic_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::OneWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayVectorCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayVectorCompound_DynamicFlags);
    const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable;
  return proxy_.Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayVectorCompound(&_encoder, &vector_bits, &vector_enum, &vector_struct, &vector_table, &vector_union, &vector_opt_struct, &vector_opt_union));
}

zx_status_t Protocol_SyncProxy::TwoWayVectorCompound(::std::vector<::test::typesinprotocols::Bits> vector_bits, ::std::vector<::test::typesinprotocols::Enum> vector_enum, ::std::vector<::test::typesinprotocols::Struct> vector_struct, ::std::vector<::test::typesinprotocols::Table> vector_table, ::std::vector<::test::typesinprotocols::Union> vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>> vector_opt_union, ::std::vector<::test::typesinprotocols::Bits>* out_vector_bits, ::std::vector<::test::typesinprotocols::Enum>* out_vector_enum, ::std::vector<::test::typesinprotocols::Struct>* out_vector_struct, ::std::vector<::test::typesinprotocols::Table>* out_vector_table, ::std::vector<::test::typesinprotocols::Union>* out_vector_union, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>* out_vector_opt_struct, ::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>* out_vector_opt_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayVectorCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayVectorCompound_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorCompoundTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayVectorCompound(&_encoder, &vector_bits, &vector_enum, &vector_struct, &vector_table, &vector_union, &vector_opt_struct, &vector_opt_union), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_vector_bits = ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Bits>>(&decoder_, 0 + sizeof(fidl_message_header_t));
  *out_vector_enum = ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Enum>>(&decoder_, 16 + sizeof(fidl_message_header_t));
  *out_vector_struct = ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Struct>>(&decoder_, 32 + sizeof(fidl_message_header_t));
  *out_vector_table = ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Table>>(&decoder_, 48 + sizeof(fidl_message_header_t));
  *out_vector_union = ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::Union>>(&decoder_, 64 + sizeof(fidl_message_header_t));
  *out_vector_opt_struct = ::fidl::DecodeAs<::std::vector<::std::unique_ptr<::test::typesinprotocols::Struct>>>(&decoder_, 80 + sizeof(fidl_message_header_t));
  *out_vector_opt_union = ::fidl::DecodeAs<::std::vector<::std::unique_ptr<::test::typesinprotocols::Union>>>(&decoder_, 96 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::ErrorVectorCompound(::test::typesinprotocols::Protocol_ErrorVectorCompound_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorVectorCompound_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorVectorCompound_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =nullptr;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorVectorCompoundTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorVectorCompound(&_encoder), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorVectorCompound_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::OneWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayVectorOptional_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayVectorOptional_DynamicFlags);
    const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable;
  return proxy_.Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayVectorOptional(&_encoder, &opt_vector_uint8, &opt_vector_string, &opt_vector_opt_struct));
}

zx_status_t Protocol_SyncProxy::TwoWayVectorOptional(::fidl::VectorPtr<uint8_t> opt_vector_uint8, ::fidl::VectorPtr<::std::string> opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>> opt_vector_opt_struct, ::fidl::VectorPtr<uint8_t>* out_opt_vector_uint8, ::fidl::VectorPtr<::std::string>* out_opt_vector_string, ::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>* out_opt_vector_opt_struct) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayVectorOptional_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayVectorOptional_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_VectorOptionalTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayVectorOptional(&_encoder, &opt_vector_uint8, &opt_vector_string, &opt_vector_opt_struct), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_opt_vector_uint8 = ::fidl::DecodeAs<::fidl::VectorPtr<uint8_t>>(&decoder_, 0 + sizeof(fidl_message_header_t));
  *out_opt_vector_string = ::fidl::DecodeAs<::fidl::VectorPtr<::std::string>>(&decoder_, 16 + sizeof(fidl_message_header_t));
  *out_opt_vector_opt_struct = ::fidl::DecodeAs<::fidl::VectorPtr<::std::unique_ptr<::test::typesinprotocols::Struct>>>(&decoder_, 48 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::ErrorVectorOptional(::test::typesinprotocols::Protocol_ErrorVectorOptional_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorVectorOptional_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorVectorOptional_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =nullptr;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorVectorOptionalTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorVectorOptional(&_encoder), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorVectorOptional_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::OneWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayArrayVectorNested_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayArrayVectorNested_DynamicFlags);
    const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable;
  return proxy_.Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayArrayVectorNested(&_encoder, &array_array_uint8, &array_vector_uint8, &vector_array_uint8, &vector_vector_uint8));
}

zx_status_t Protocol_SyncProxy::TwoWayArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8, ::std::array<::std::array<uint8_t, 5>, 5>* out_array_array_uint8, ::std::array<::std::vector<uint8_t>, 5>* out_array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>>* out_vector_array_uint8, ::std::vector<::std::vector<uint8_t>>* out_vector_vector_uint8) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayArrayVectorNested_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayArrayVectorNested_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ArrayVectorNestedTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayArrayVectorNested(&_encoder, &array_array_uint8, &array_vector_uint8, &vector_array_uint8, &vector_vector_uint8), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_array_array_uint8 = ::fidl::DecodeAs<::std::array<::std::array<uint8_t, 5>, 5>>(&decoder_, 0 + sizeof(fidl_message_header_t));
  *out_array_vector_uint8 = ::fidl::DecodeAs<::std::array<::std::vector<uint8_t>, 5>>(&decoder_, 32 + sizeof(fidl_message_header_t));
  *out_vector_array_uint8 = ::fidl::DecodeAs<::std::vector<::std::array<uint8_t, 5>>>(&decoder_, 112 + sizeof(fidl_message_header_t));
  *out_vector_vector_uint8 = ::fidl::DecodeAs<::std::vector<::std::vector<uint8_t>>>(&decoder_, 128 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::ErrorArrayVectorNested(::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorArrayVectorNested_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorArrayVectorNested_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =nullptr;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorArrayVectorNestedTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorArrayVectorNested(&_encoder), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorArrayVectorNested_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::OneWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_OneWayResource_Ordinal, ::test::typesinprotocols::internal::kProtocol_OneWayResource_DynamicFlags);
    const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable;
  return proxy_.Send(req_type, ::test::typesinprotocols::Protocol_RequestEncoder::OneWayResource(&_encoder, &handle, &vmo, &client_end, &server_end, &struct_, &table, &union_, &opt_handle, &opt_vmo, &opt_client_end, &opt_server_end, &opt_struct, &opt_union, &array_handle, &array_vmo, &array_client_end, &array_server_end, &array_struct, &array_table, &array_union, &vector_handle, &vector_vmo, &vector_client_end, &vector_server_end, &vector_struct, &vector_table, &vector_union));
}

zx_status_t Protocol_SyncProxy::TwoWayResource(::zx::handle handle, ::zx::vmo vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> server_end, ::test::typesinprotocols::ResourceStruct struct_, ::test::typesinprotocols::ResourceTable table, ::test::typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol> opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol> opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct> opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable> vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion> vector_union, ::zx::handle* out_handle, ::zx::vmo* out_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* out_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* out_server_end, ::test::typesinprotocols::ResourceStruct* out_struct_, ::test::typesinprotocols::ResourceTable* out_table, ::test::typesinprotocols::ResourceUnion* out_union_, ::zx::handle* out_opt_handle, ::zx::vmo* out_opt_vmo, ::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>* out_opt_client_end, ::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>* out_opt_server_end, ::std::unique_ptr<::test::typesinprotocols::ResourceStruct>* out_opt_struct, ::std::unique_ptr<::test::typesinprotocols::ResourceUnion>* out_opt_union, ::std::array<::zx::handle, 5>* out_array_handle, ::std::array<::zx::vmo, 5>* out_array_vmo, ::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>* out_array_client_end, ::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>* out_array_server_end, ::std::array<::test::typesinprotocols::ResourceStruct, 5>* out_array_struct, ::std::array<::test::typesinprotocols::ResourceTable, 5>* out_array_table, ::std::array<::test::typesinprotocols::ResourceUnion, 5>* out_array_union, ::std::vector<::zx::handle>* out_vector_handle, ::std::vector<::zx::vmo>* out_vector_vmo, ::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>* out_vector_client_end, ::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>* out_vector_server_end, ::std::vector<::test::typesinprotocols::ResourceStruct>* out_vector_struct, ::std::vector<::test::typesinprotocols::ResourceTable>* out_vector_table, ::std::vector<::test::typesinprotocols::ResourceUnion>* out_vector_union) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_TwoWayResource_Ordinal, ::test::typesinprotocols::internal::kProtocol_TwoWayResource_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ResourceTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::TwoWayResource(&_encoder, &handle, &vmo, &client_end, &server_end, &struct_, &table, &union_, &opt_handle, &opt_vmo, &opt_client_end, &opt_server_end, &opt_struct, &opt_union, &array_handle, &array_vmo, &array_client_end, &array_server_end, &array_struct, &array_table, &array_union, &vector_handle, &vector_vmo, &vector_client_end, &vector_server_end, &vector_struct, &vector_table, &vector_union), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_handle = ::fidl::DecodeAs<::zx::handle>(&decoder_, 0 + sizeof(fidl_message_header_t));
  *out_vmo = ::fidl::DecodeAs<::zx::vmo>(&decoder_, 4 + sizeof(fidl_message_header_t));
  *out_client_end = ::fidl::DecodeAs<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>(&decoder_, 8 + sizeof(fidl_message_header_t));
  *out_server_end = ::fidl::DecodeAs<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>(&decoder_, 12 + sizeof(fidl_message_header_t));
  *out_struct_ = ::fidl::DecodeAs<::test::typesinprotocols::ResourceStruct>(&decoder_, 16 + sizeof(fidl_message_header_t));
  *out_table = ::fidl::DecodeAs<::test::typesinprotocols::ResourceTable>(&decoder_, 24 + sizeof(fidl_message_header_t));
  *out_union_ = ::fidl::DecodeAs<::test::typesinprotocols::ResourceUnion>(&decoder_, 40 + sizeof(fidl_message_header_t));
  *out_opt_handle = ::fidl::DecodeAs<::zx::handle>(&decoder_, 56 + sizeof(fidl_message_header_t));
  *out_opt_vmo = ::fidl::DecodeAs<::zx::vmo>(&decoder_, 60 + sizeof(fidl_message_header_t));
  *out_opt_client_end = ::fidl::DecodeAs<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>(&decoder_, 64 + sizeof(fidl_message_header_t));
  *out_opt_server_end = ::fidl::DecodeAs<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>(&decoder_, 68 + sizeof(fidl_message_header_t));
  *out_opt_struct = ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::ResourceStruct>>(&decoder_, 72 + sizeof(fidl_message_header_t));
  *out_opt_union = ::fidl::DecodeAs<::std::unique_ptr<::test::typesinprotocols::ResourceUnion>>(&decoder_, 80 + sizeof(fidl_message_header_t));
  *out_array_handle = ::fidl::DecodeAs<::std::array<::zx::handle, 5>>(&decoder_, 96 + sizeof(fidl_message_header_t));
  *out_array_vmo = ::fidl::DecodeAs<::std::array<::zx::vmo, 5>>(&decoder_, 116 + sizeof(fidl_message_header_t));
  *out_array_client_end = ::fidl::DecodeAs<::std::array<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>, 5>>(&decoder_, 136 + sizeof(fidl_message_header_t));
  *out_array_server_end = ::fidl::DecodeAs<::std::array<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>, 5>>(&decoder_, 156 + sizeof(fidl_message_header_t));
  *out_array_struct = ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceStruct, 5>>(&decoder_, 176 + sizeof(fidl_message_header_t));
  *out_array_table = ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceTable, 5>>(&decoder_, 184 + sizeof(fidl_message_header_t));
  *out_array_union = ::fidl::DecodeAs<::std::array<::test::typesinprotocols::ResourceUnion, 5>>(&decoder_, 264 + sizeof(fidl_message_header_t));
  *out_vector_handle = ::fidl::DecodeAs<::std::vector<::zx::handle>>(&decoder_, 344 + sizeof(fidl_message_header_t));
  *out_vector_vmo = ::fidl::DecodeAs<::std::vector<::zx::vmo>>(&decoder_, 360 + sizeof(fidl_message_header_t));
  *out_vector_client_end = ::fidl::DecodeAs<::std::vector<::fidl::InterfaceHandle<::test::typesinprotocols::Protocol>>>(&decoder_, 376 + sizeof(fidl_message_header_t));
  *out_vector_server_end = ::fidl::DecodeAs<::std::vector<::fidl::InterfaceRequest<::test::typesinprotocols::Protocol>>>(&decoder_, 392 + sizeof(fidl_message_header_t));
  *out_vector_struct = ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceStruct>>(&decoder_, 408 + sizeof(fidl_message_header_t));
  *out_vector_table = ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceTable>>(&decoder_, 424 + sizeof(fidl_message_header_t));
  *out_vector_union = ::fidl::DecodeAs<::std::vector<::test::typesinprotocols::ResourceUnion>>(&decoder_, 440 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

zx_status_t Protocol_SyncProxy::ErrorResource(::test::typesinprotocols::Protocol_ErrorResource_Result* out_result) {
  ::fidl::MessageEncoder _encoder(::test::typesinprotocols::internal::kProtocol_ErrorResource_Ordinal, ::test::typesinprotocols::internal::kProtocol_ErrorResource_DynamicFlags);
  ::fidl::IncomingMessageBuffer buffer_;
  ::fidl::HLCPPIncomingMessage response_ = buffer_.CreateEmptyIncomingMessage();
  const fidl_type_t* req_type =nullptr;
  const fidl_type_t* resp_type =&::test::typesinprotocols::_internal::test_typesinprotocols_ProtocolErrorResourceTopResponseTable;
  zx_status_t status_ = proxy_.Call(req_type, resp_type, ::test::typesinprotocols::Protocol_RequestEncoder::ErrorResource(&_encoder), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<::test::typesinprotocols::Protocol_ErrorResource_Result>(&decoder_, 0 + sizeof(fidl_message_header_t));
  return ZX_OK;
}

#endif  // __Fuchsia__


}  // namespace typesinprotocols
}  // namespace test


