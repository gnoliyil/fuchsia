// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include "lib/fidl/cpp/internal/header.h"

namespace test {
namespace anonymous {

//
// Domain objects declarations
//

class Op final {
 public:
  constexpr Op() : value_(0) {}
  constexpr explicit Op(uint32_t value) : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

      case 3u:

        return false;
    }
    return true;
  }

  constexpr static Op Unknown() {
    return Op(0xffffffff);
  }

  static const Op ADD;

  static const Op MUL;

  static const Op DIV;

 private:
  uint32_t value_;
};

#if !(__cplusplus < 201703)
constexpr const ::test::anonymous::Op Op::ADD = ::test::anonymous::Op(1u);
constexpr const ::test::anonymous::Op Op::MUL = ::test::anonymous::Op(2u);
constexpr const ::test::anonymous::Op Op::DIV = ::test::anonymous::Op(3u);
#endif  // !(__cplusplus < 201703)

inline zx_status_t Clone(::test::anonymous::Op value,
                         ::test::anonymous::Op* result) {
  *result = value;
  return ZX_OK;
}

class OverrideTest;

// |Flags| is flexible, hence may contain unknown members not
// defined in the FIDL schema.
class Flags final {
 public:
  constexpr Flags() = default;

  // Constructs an instance of |Flags| from an underlying primitive value
  // if the primitive does not contain any unknown members not defined in the
  // FIDL schema. Otherwise, returns |cpp17::nullopt|.
  constexpr inline static cpp17::optional<Flags> TryFrom(uint16_t value) {
    if (value & ~kMask.value_) {
      return cpp17::nullopt;
    }
    return Flags(value & Flags::kMask.value_);
  }

  // Constructs an instance of |Flags| from an underlying primitive value,
  // clearing any bit member not defined in the FIDL schema.
  constexpr inline static Flags TruncatingUnknown(uint16_t value) {
    return Flags(value & Flags::kMask.value_);
  }

  // Constructs an instance of |Flags| from an underlying primitive value,
  // preserving any bit member not defined in the FIDL schema.
  constexpr explicit Flags(uint16_t value) : value_(value) {}
  const static Flags INLINE;
  const static Flags kMask;

  explicit constexpr inline operator uint16_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const Flags& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const Flags& other) const { return value_ != other.value_; }
  constexpr inline Flags operator~() const;
  constexpr inline Flags operator|(const Flags& other) const;
  constexpr inline Flags operator&(const Flags& other) const;
  constexpr inline Flags operator^(const Flags& other) const;
  constexpr inline void operator|=(const Flags& other);
  constexpr inline void operator&=(const Flags& other);
  constexpr inline void operator^=(const Flags& other);
  constexpr inline Flags unknown_bits() const {
    return *this & Flags(~kMask.value_);
  }
  constexpr inline bool has_unknown_bits() const { return static_cast<bool>(unknown_bits()); }

 private:
  uint16_t value_ = 0;
};

#if !(__cplusplus < 201703)
constexpr const ::test::anonymous::Flags Flags::INLINE = ::test::anonymous::Flags(1u);
constexpr const ::test::anonymous::Flags Flags::kMask = ::test::anonymous::Flags(1u);

#endif  // !(__cplusplus < 201703)

constexpr inline ::test::anonymous::Flags Flags::operator~() const {
  return ::test::anonymous::Flags(static_cast<uint16_t>(~this->value_ & kMask.value_));
}

constexpr inline ::test::anonymous::Flags Flags::operator|(
    const ::test::anonymous::Flags& other) const {
  return ::test::anonymous::Flags(static_cast<uint16_t>(this->value_ | other.value_));
}

constexpr inline ::test::anonymous::Flags Flags::operator&(
    const ::test::anonymous::Flags& other) const {
  return ::test::anonymous::Flags(static_cast<uint16_t>(this->value_ & other.value_));
}

constexpr inline ::test::anonymous::Flags Flags::operator^(
    const ::test::anonymous::Flags& other) const {
  return ::test::anonymous::Flags(static_cast<uint16_t>(this->value_ ^ other.value_));
}

constexpr inline void Flags::operator|=(
    const ::test::anonymous::Flags& other) {
  this->value_ |= other.value_;
}

constexpr inline void Flags::operator&=(
    const ::test::anonymous::Flags& other) {
  this->value_ &= other.value_;
}

constexpr inline void Flags::operator^=(
    const ::test::anonymous::Flags& other) {
  this->value_ ^= other.value_;
}

inline zx_status_t Clone(::test::anonymous::Flags value,
                         ::test::anonymous::Flags* result) {
  *result = value;
  return ZX_OK;
}

class FunctionApplication;

class Expression;

class UnionMember;

class TableData;

class TableMember;

class SomeProtocolSomeMethodRequest;

// |BitsMember| is flexible, hence may contain unknown members not
// defined in the FIDL schema.
class BitsMember final {
 public:
  constexpr BitsMember() = default;

  // Constructs an instance of |BitsMember| from an underlying primitive value
  // if the primitive does not contain any unknown members not defined in the
  // FIDL schema. Otherwise, returns |cpp17::nullopt|.
  constexpr inline static cpp17::optional<BitsMember> TryFrom(uint32_t value) {
    if (value & ~kMask.value_) {
      return cpp17::nullopt;
    }
    return BitsMember(value & BitsMember::kMask.value_);
  }

  // Constructs an instance of |BitsMember| from an underlying primitive value,
  // clearing any bit member not defined in the FIDL schema.
  constexpr inline static BitsMember TruncatingUnknown(uint32_t value) {
    return BitsMember(value & BitsMember::kMask.value_);
  }

  // Constructs an instance of |BitsMember| from an underlying primitive value,
  // preserving any bit member not defined in the FIDL schema.
  constexpr explicit BitsMember(uint32_t value) : value_(value) {}
  const static BitsMember BIT_ONE;
  const static BitsMember BIT_TWO;
  const static BitsMember kMask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const { return static_cast<bool>(value_); }
  constexpr inline bool operator==(const BitsMember& other) const { return value_ == other.value_; }
  constexpr inline bool operator!=(const BitsMember& other) const { return value_ != other.value_; }
  constexpr inline BitsMember operator~() const;
  constexpr inline BitsMember operator|(const BitsMember& other) const;
  constexpr inline BitsMember operator&(const BitsMember& other) const;
  constexpr inline BitsMember operator^(const BitsMember& other) const;
  constexpr inline void operator|=(const BitsMember& other);
  constexpr inline void operator&=(const BitsMember& other);
  constexpr inline void operator^=(const BitsMember& other);
  constexpr inline BitsMember unknown_bits() const {
    return *this & BitsMember(~kMask.value_);
  }
  constexpr inline bool has_unknown_bits() const { return static_cast<bool>(unknown_bits()); }

 private:
  uint32_t value_ = 0;
};

#if !(__cplusplus < 201703)
constexpr const ::test::anonymous::BitsMember BitsMember::BIT_ONE = ::test::anonymous::BitsMember(1u);
constexpr const ::test::anonymous::BitsMember BitsMember::BIT_TWO = ::test::anonymous::BitsMember(2u);
constexpr const ::test::anonymous::BitsMember BitsMember::kMask = ::test::anonymous::BitsMember(3u);

#endif  // !(__cplusplus < 201703)

constexpr inline ::test::anonymous::BitsMember BitsMember::operator~() const {
  return ::test::anonymous::BitsMember(static_cast<uint32_t>(~this->value_ & kMask.value_));
}

constexpr inline ::test::anonymous::BitsMember BitsMember::operator|(
    const ::test::anonymous::BitsMember& other) const {
  return ::test::anonymous::BitsMember(static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::test::anonymous::BitsMember BitsMember::operator&(
    const ::test::anonymous::BitsMember& other) const {
  return ::test::anonymous::BitsMember(static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::test::anonymous::BitsMember BitsMember::operator^(
    const ::test::anonymous::BitsMember& other) const {
  return ::test::anonymous::BitsMember(static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void BitsMember::operator|=(
    const ::test::anonymous::BitsMember& other) {
  this->value_ |= other.value_;
}

constexpr inline void BitsMember::operator&=(
    const ::test::anonymous::BitsMember& other) {
  this->value_ &= other.value_;
}

constexpr inline void BitsMember::operator^=(
    const ::test::anonymous::BitsMember& other) {
  this->value_ ^= other.value_;
}

inline zx_status_t Clone(::test::anonymous::BitsMember value,
                         ::test::anonymous::BitsMember* result) {
  *result = value;
  return ZX_OK;
}

class SomeProtocol_SomeMethod_Response;

class SomeProtocol_SomeMethod_Error final {
 public:
  constexpr SomeProtocol_SomeMethod_Error() : value_(0) {}
  constexpr explicit SomeProtocol_SomeMethod_Error(uint32_t value) : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

        return false;
    }
    return true;
  }

  constexpr static SomeProtocol_SomeMethod_Error Unknown() {
    return SomeProtocol_SomeMethod_Error(0xffffffff);
  }

  static const SomeProtocol_SomeMethod_Error ERROR_ONE;

  static const SomeProtocol_SomeMethod_Error ERROR_TWO;

 private:
  uint32_t value_;
};

#if !(__cplusplus < 201703)
constexpr const ::test::anonymous::SomeProtocol_SomeMethod_Error SomeProtocol_SomeMethod_Error::ERROR_ONE = ::test::anonymous::SomeProtocol_SomeMethod_Error(1u);
constexpr const ::test::anonymous::SomeProtocol_SomeMethod_Error SomeProtocol_SomeMethod_Error::ERROR_TWO = ::test::anonymous::SomeProtocol_SomeMethod_Error(2u);
#endif  // !(__cplusplus < 201703)

inline zx_status_t Clone(::test::anonymous::SomeProtocol_SomeMethod_Error value,
                         ::test::anonymous::SomeProtocol_SomeMethod_Error* result) {
  *result = value;
  return ZX_OK;
}

class SomeProtocol_SomeMethod_Result;

class SomeProtocolSomeMethodTopResponse;

#ifdef __Fuchsia__

class SomeProtocol;
using SomeProtocolHandle = ::fidl::InterfaceHandle<SomeProtocol>;

#endif  // __Fuchsia__

class OverrideTest final {
 public:
  static const fidl_type_t* FidlType;

  ::test::anonymous::Op op{};

  ::std::unique_ptr<::test::anonymous::Expression> left{};

  ::std::unique_ptr<::test::anonymous::Expression> right{};

  static inline ::std::unique_ptr<OverrideTest> New() { return ::std::make_unique<OverrideTest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, OverrideTest* value, size_t _offset);
  zx_status_t Clone(OverrideTest* result) const;
};

inline zx_status_t Clone(const ::test::anonymous::OverrideTest& _value,
                         ::test::anonymous::OverrideTest* _result) {
  return _value.Clone(_result);
}

using OverrideTestPtr = ::std::unique_ptr<OverrideTest>;

class FunctionApplication final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;

  const ::std::string& func() const {
    ZX_ASSERT(field_presence_.IsSet<0>());
    return func_value_.value;
  }
  bool has_func() const {
    return field_presence_.IsSet<0>();
  }

  ::std::string* mutable_func() {
    if (!field_presence_.IsSet<0>()) {
      field_presence_.Set<0>();
      Construct(&func_value_.value);
    }
    return &func_value_.value;
  }
  FunctionApplication& set_func(::std::string _value);
  void clear_func() {
    if (!field_presence_.IsSet<0>()) {
      return;
    }
    field_presence_.Clear<0>();
    Destruct(&func_value_.value);
  }

  const ::std::vector<::std::unique_ptr<::test::anonymous::Expression>>& args() const {
    ZX_ASSERT(field_presence_.IsSet<2>());
    return args_value_.value;
  }
  bool has_args() const {
    return field_presence_.IsSet<2>();
  }

  ::std::vector<::std::unique_ptr<::test::anonymous::Expression>>* mutable_args() {
    if (!field_presence_.IsSet<2>()) {
      field_presence_.Set<2>();
      Construct(&args_value_.value);
    }
    return &args_value_.value;
  }
  FunctionApplication& set_args(::std::vector<::std::unique_ptr<::test::anonymous::Expression>> _value);
  void clear_args() {
    if (!field_presence_.IsSet<2>()) {
      return;
    }
    field_presence_.Clear<2>();
    Destruct(&args_value_.value);
  }

  const ::test::anonymous::Flags& flags() const {
    ZX_ASSERT(field_presence_.IsSet<3>());
    return flags_value_.value;
  }
  bool has_flags() const {
    return field_presence_.IsSet<3>();
  }

  ::test::anonymous::Flags* mutable_flags() {
    if (!field_presence_.IsSet<3>()) {
      field_presence_.Set<3>();
      Construct(&flags_value_.value);
    }
    return &flags_value_.value;
  }
  FunctionApplication& set_flags(::test::anonymous::Flags _value);
  void clear_flags() {
    if (!field_presence_.IsSet<3>()) {
      return;
    }
    field_presence_.Clear<3>();
    Destruct(&flags_value_.value);
  }

  FunctionApplication();
  FunctionApplication(FunctionApplication&& other);
  ~FunctionApplication();
  FunctionApplication& operator=(FunctionApplication&& other);

  static inline ::std::unique_ptr<FunctionApplication> New() { return ::std::make_unique<FunctionApplication>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, FunctionApplication* _value, size_t _offset);
  zx_status_t Clone(FunctionApplication* _result) const;

 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
      case 1:
      case 3:
      case 4:
        return true;
      default:
        return false;
    }
  }

  ::fidl::internal::BitSet<4> field_presence_;
  union ValueUnion_func {
    ValueUnion_func() {}
    ~ValueUnion_func() {}

    ::std::string value;
  };
  ValueUnion_func func_value_;
  union ValueUnion_args {
    ValueUnion_args() {}
    ~ValueUnion_args() {}

    ::std::vector<::std::unique_ptr<::test::anonymous::Expression>> value;
  };
  ValueUnion_args args_value_;
  union ValueUnion_flags {
    ValueUnion_flags() {}
    ~ValueUnion_flags() {}

    ::test::anonymous::Flags value;
  };
  ValueUnion_flags flags_value_;
};

using FunctionApplicationPtr = ::std::unique_ptr<FunctionApplication>;

class Expression final {
 public:
  static const fidl_type_t* FidlType;

  Expression();
  ~Expression();

  Expression(Expression&&);
  Expression& operator=(Expression&&);

  static Expression WithValue(uint64_t&&);
  static Expression WithBinOp(::test::anonymous::OverrideTest&&);
  static Expression WithFunctionApplication(::test::anonymous::FunctionApplication&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
    kUnknown = 0,

    kValue = 1,                // 0x1
    kBinOp = 2,                // 0x2
    kFunctionApplication = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<Expression> New() { return ::std::make_unique<Expression>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, Expression* value, size_t offset);
  zx_status_t Clone(Expression* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_value() const { return tag_ == ::test::anonymous::Expression::Tag::kValue; }

  uint64_t& value() {
    EnsureStorageInitialized(::test::anonymous::Expression::Tag::kValue);
    return value_;
  }

  const uint64_t& value() const {
    ZX_ASSERT(is_value());
    return value_;
  }
  Expression& set_value(uint64_t value);

  bool is_bin_op() const { return tag_ == ::test::anonymous::Expression::Tag::kBinOp; }

  ::test::anonymous::OverrideTest& bin_op() {
    EnsureStorageInitialized(::test::anonymous::Expression::Tag::kBinOp);
    return bin_op_;
  }

  const ::test::anonymous::OverrideTest& bin_op() const {
    ZX_ASSERT(is_bin_op());
    return bin_op_;
  }
  Expression& set_bin_op(::test::anonymous::OverrideTest value);

  bool is_function_application() const { return tag_ == ::test::anonymous::Expression::Tag::kFunctionApplication; }

  ::test::anonymous::FunctionApplication& function_application() {
    EnsureStorageInitialized(::test::anonymous::Expression::Tag::kFunctionApplication);
    return function_application_;
  }

  const ::test::anonymous::FunctionApplication& function_application() const {
    ZX_ASSERT(is_function_application());
    return function_application_;
  }
  Expression& set_function_application(::test::anonymous::FunctionApplication value);
  Expression& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::anonymous::Expression::Tag Which() const {
    switch (tag_) {
      case ::test::anonymous::Expression::Tag::Invalid:
      case ::test::anonymous::Expression::Tag::kValue:
      case ::test::anonymous::Expression::Tag::kBinOp:
      case ::test::anonymous::Expression::Tag::kFunctionApplication:
        return ::test::anonymous::Expression::Tag(tag_);
      default:
        return ::test::anonymous::Expression::Tag::kUnknown;
    }
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::anonymous::Expression::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::anonymous::Expression>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::anonymous::Expression::Tag::Invalid);
  union {
    uint64_t value_;
    ::test::anonymous::OverrideTest bin_op_;
    ::test::anonymous::FunctionApplication function_application_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::anonymous::Expression& value,
                         ::test::anonymous::Expression* result) {
  return value.Clone(result);
}

using ExpressionPtr = ::std::unique_ptr<Expression>;

class UnionMember final {
 public:
  static const fidl_type_t* FidlType;

  UnionMember();
  ~UnionMember();

  UnionMember(UnionMember&&);
  UnionMember& operator=(UnionMember&&);

  static UnionMember WithUnionData(uint8_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
    kUnknown = 0,

    kUnionData = 2,  // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnionMember> New() { return ::std::make_unique<UnionMember>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnionMember* value, size_t offset);
  zx_status_t Clone(UnionMember* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_union_data() const { return tag_ == ::test::anonymous::UnionMember::Tag::kUnionData; }

  uint8_t& union_data() {
    EnsureStorageInitialized(::test::anonymous::UnionMember::Tag::kUnionData);
    return union_data_;
  }

  const uint8_t& union_data() const {
    ZX_ASSERT(is_union_data());
    return union_data_;
  }
  UnionMember& set_union_data(uint8_t value);
  UnionMember& SetUnknownData(fidl_xunion_tag_t ordinal, std::vector<uint8_t> bytes);

  ::test::anonymous::UnionMember::Tag Which() const {
    switch (tag_) {
      case ::test::anonymous::UnionMember::Tag::Invalid:
      case ::test::anonymous::UnionMember::Tag::kUnionData:
        return ::test::anonymous::UnionMember::Tag(tag_);
      default:
        return ::test::anonymous::UnionMember::Tag::kUnknown;
    }
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::test::anonymous::UnionMember::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::test::anonymous::UnionMember>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::anonymous::UnionMember::Tag::Invalid);
  union {
    uint8_t union_data_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::test::anonymous::UnionMember& value,
                         ::test::anonymous::UnionMember* result) {
  return value.Clone(result);
}

using UnionMemberPtr = ::std::unique_ptr<UnionMember>;

class TableData final {
 public:
  static const fidl_type_t* FidlType;

  uint8_t data{};

  static inline ::std::unique_ptr<TableData> New() { return ::std::make_unique<TableData>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, TableData* value, size_t _offset);
  zx_status_t Clone(TableData* result) const;
};

inline zx_status_t Clone(const ::test::anonymous::TableData& _value,
                         ::test::anonymous::TableData* _result) {
  return _value.Clone(_result);
}

using TableDataPtr = ::std::unique_ptr<TableData>;

class TableMember final {
 public:
  static const fidl_type_t* FidlType;
  /// Returns whether no field is set.
  bool IsEmpty() const;

  const ::std::vector<::test::anonymous::TableData>& table_data() const {
    ZX_ASSERT(field_presence_.IsSet<1>());
    return table_data_value_.value;
  }
  bool has_table_data() const {
    return field_presence_.IsSet<1>();
  }

  ::std::vector<::test::anonymous::TableData>* mutable_table_data() {
    if (!field_presence_.IsSet<1>()) {
      field_presence_.Set<1>();
      Construct(&table_data_value_.value);
    }
    return &table_data_value_.value;
  }
  TableMember& set_table_data(::std::vector<::test::anonymous::TableData> _value);
  void clear_table_data() {
    if (!field_presence_.IsSet<1>()) {
      return;
    }
    field_presence_.Clear<1>();
    Destruct(&table_data_value_.value);
  }

  TableMember();
  TableMember(TableMember&& other);
  ~TableMember();
  TableMember& operator=(TableMember&& other);

  static inline ::std::unique_ptr<TableMember> New() { return ::std::make_unique<TableMember>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, TableMember* _value, size_t _offset);
  zx_status_t Clone(TableMember* _result) const;

 private:
  template <class T, class... Args>
  void Construct(T* p, Args&&... args) {
    new (p) T(std::forward<Args>(args)...);
  }

  template <class T>
  void Destruct(T* p) {
    p->~T();
  }

  size_t MaxOrdinal() const {
    return static_cast<size_t>(field_presence_.MaxSetIndex()) + std::size_t{1};
  }

  static bool IsOrdinalKnown(uint64_t ordinal) {
    switch (ordinal) {
      case 2:
        return true;
      default:
        return false;
    }
  }

  ::fidl::internal::BitSet<2> field_presence_;
  union ValueUnion_table_data {
    ValueUnion_table_data() {}
    ~ValueUnion_table_data() {}

    ::std::vector<::test::anonymous::TableData> value;
  };
  ValueUnion_table_data table_data_value_;
};

using TableMemberPtr = ::std::unique_ptr<TableMember>;

class SomeProtocolSomeMethodRequest final {
 public:
  static const fidl_type_t* FidlType;

  ::test::anonymous::UnionMember union_member{};

  ::test::anonymous::TableMember table_member{};

  static inline ::std::unique_ptr<SomeProtocolSomeMethodRequest> New() { return ::std::make_unique<SomeProtocolSomeMethodRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, SomeProtocolSomeMethodRequest* value, size_t _offset);
  zx_status_t Clone(SomeProtocolSomeMethodRequest* result) const;
};

inline zx_status_t Clone(const ::test::anonymous::SomeProtocolSomeMethodRequest& _value,
                         ::test::anonymous::SomeProtocolSomeMethodRequest* _result) {
  return _value.Clone(_result);
}

using SomeProtocolSomeMethodRequestPtr = ::std::unique_ptr<SomeProtocolSomeMethodRequest>;

class SomeProtocol_SomeMethod_Response final {
 public:
  static const fidl_type_t* FidlType;
  SomeProtocol_SomeMethod_Response() = default;
  explicit SomeProtocol_SomeMethod_Response(::test::anonymous::BitsMember v) : bits_member(std::move(v)) {}
  ::test::anonymous::BitsMember ResultValue_() { return std::move(bits_member); }
  explicit SomeProtocol_SomeMethod_Response(::std::tuple<::test::anonymous::BitsMember> _value_tuple) {
    std::tie(bits_member) = std::move(_value_tuple);
  }
  operator ::std::tuple<::test::anonymous::BitsMember>() && {
    return std::make_tuple(std::move(bits_member));
  }

  ::test::anonymous::BitsMember bits_member{};

  static inline ::std::unique_ptr<SomeProtocol_SomeMethod_Response> New() { return ::std::make_unique<SomeProtocol_SomeMethod_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, SomeProtocol_SomeMethod_Response* value, size_t _offset);
  zx_status_t Clone(SomeProtocol_SomeMethod_Response* result) const;
};

inline zx_status_t Clone(const ::test::anonymous::SomeProtocol_SomeMethod_Response& _value,
                         ::test::anonymous::SomeProtocol_SomeMethod_Response* _result) {
  return _value.Clone(_result);
}

using SomeProtocol_SomeMethod_ResponsePtr = ::std::unique_ptr<SomeProtocol_SomeMethod_Response>;

class SomeProtocol_SomeMethod_Result final {
 public:
  static const fidl_type_t* FidlType;

  SomeProtocol_SomeMethod_Result();
  ~SomeProtocol_SomeMethod_Result();

  SomeProtocol_SomeMethod_Result(SomeProtocol_SomeMethod_Result&&);
  SomeProtocol_SomeMethod_Result& operator=(SomeProtocol_SomeMethod_Result&&);

  static SomeProtocol_SomeMethod_Result WithResponse(::test::anonymous::SomeProtocol_SomeMethod_Response&&);
  static SomeProtocol_SomeMethod_Result WithErr(::test::anonymous::SomeProtocol_SomeMethod_Error&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<SomeProtocol_SomeMethod_Result> New() { return ::std::make_unique<SomeProtocol_SomeMethod_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, SomeProtocol_SomeMethod_Result* value, size_t offset);
  zx_status_t Clone(SomeProtocol_SomeMethod_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::kResponse; }

  ::test::anonymous::SomeProtocol_SomeMethod_Response& response() {
    EnsureStorageInitialized(::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::kResponse);
    return response_;
  }

  const ::test::anonymous::SomeProtocol_SomeMethod_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  SomeProtocol_SomeMethod_Result& set_response(::test::anonymous::SomeProtocol_SomeMethod_Response value);

  bool is_err() const { return tag_ == ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::kErr; }

  ::test::anonymous::SomeProtocol_SomeMethod_Error& err() {
    EnsureStorageInitialized(::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::kErr);
    return err_;
  }

  const ::test::anonymous::SomeProtocol_SomeMethod_Error& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  SomeProtocol_SomeMethod_Result& set_err(::test::anonymous::SomeProtocol_SomeMethod_Error value);

  ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag Which() const {
    return ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::anonymous::SomeProtocol_SomeMethod_Result>;
  SomeProtocol_SomeMethod_Result(fpromise::result<::test::anonymous::BitsMember, ::test::anonymous::SomeProtocol_SomeMethod_Error>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::anonymous::SomeProtocol_SomeMethod_Response{result.take_value()});
    } else {
      set_err(result.take_error());
    }
  }
  SomeProtocol_SomeMethod_Result(fpromise::ok_result<::test::anonymous::BitsMember>&& result)
      : SomeProtocol_SomeMethod_Result(fpromise::result<::test::anonymous::BitsMember, ::test::anonymous::SomeProtocol_SomeMethod_Error>(std::move(result))) {}
  SomeProtocol_SomeMethod_Result(fpromise::error_result<::test::anonymous::SomeProtocol_SomeMethod_Error>&& result)
      : SomeProtocol_SomeMethod_Result(fpromise::result<::test::anonymous::BitsMember, ::test::anonymous::SomeProtocol_SomeMethod_Error>(std::move(result))) {}
  operator fpromise::result<::test::anonymous::BitsMember, ::test::anonymous::SomeProtocol_SomeMethod_Error>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::test::anonymous::BitsMember> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::Invalid);
  union {
    ::test::anonymous::SomeProtocol_SomeMethod_Response response_;
    ::test::anonymous::SomeProtocol_SomeMethod_Error err_;
  };
};

inline zx_status_t Clone(const ::test::anonymous::SomeProtocol_SomeMethod_Result& value,
                         ::test::anonymous::SomeProtocol_SomeMethod_Result* result) {
  return value.Clone(result);
}

using SomeProtocol_SomeMethod_ResultPtr = ::std::unique_ptr<SomeProtocol_SomeMethod_Result>;

class SomeProtocolSomeMethodTopResponse final {
 public:
  static const fidl_type_t* FidlType;

  ::test::anonymous::SomeProtocol_SomeMethod_Result result{};

  static inline ::std::unique_ptr<SomeProtocolSomeMethodTopResponse> New() { return ::std::make_unique<SomeProtocolSomeMethodTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, SomeProtocolSomeMethodTopResponse* value, size_t _offset);
  zx_status_t Clone(SomeProtocolSomeMethodTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::anonymous::SomeProtocolSomeMethodTopResponse& _value,
                         ::test::anonymous::SomeProtocolSomeMethodTopResponse* _result) {
  return _value.Clone(_result);
}

using SomeProtocolSomeMethodTopResponsePtr = ::std::unique_ptr<SomeProtocolSomeMethodTopResponse>;

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t test_anonymous_SomeProtocolSomeMethodRequestTable;

}  // namespace _internal

class SomeProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage SomeMethod(::fidl::MessageEncoder* _encoder, ::test::anonymous::UnionMember* union_member, ::test::anonymous::TableMember* table_member) {
    fidl_trace(WillHLCPPEncode);
    _encoder->Alloc(32);
    ::fidl::Encode(_encoder, union_member, 0 + sizeof(fidl_message_header_t));

    ::fidl::Encode(_encoder, table_member, 16 + sizeof(fidl_message_header_t));

    fidl_trace(DidHLCPPEncode, &::test::anonymous::_internal::test_anonymous_SomeProtocolSomeMethodRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
namespace _internal {
__LOCAL extern "C" const fidl_type_t test_anonymous_SomeProtocolSomeMethodTopResponseTable;

}  // namespace _internal

class SomeProtocol_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage SomeMethod(::fidl::MessageEncoder* _encoder, ::test::anonymous::SomeProtocol_SomeMethod_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    fidl_trace(DidHLCPPEncode, &::test::anonymous::_internal::test_anonymous_SomeProtocolSomeMethodTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};

#endif  // __Fuchsia__

}  // namespace anonymous
}  // namespace test
namespace fidl {

template <>
struct CodingTraits<::test::anonymous::Op> {
  static constexpr size_t inline_size_v2 = sizeof(::test::anonymous::Op);
  static void Encode(Encoder* encoder, ::test::anonymous::Op* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::anonymous::Op* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::anonymous::Op>(underlying);
  }
};

inline zx_status_t Clone(::test::anonymous::Op value,
                         ::test::anonymous::Op* result) {
  return ::test::anonymous::Clone(value, result);
}
template <>
struct Equality<::test::anonymous::Op> {
  bool operator()(const ::test::anonymous::Op& _lhs, const ::test::anonymous::Op& _rhs) const {
    return _lhs == _rhs;
  }
};

template <>
struct CodingTraits<::test::anonymous::OverrideTest>
    : public EncodableCodingTraits<::test::anonymous::OverrideTest, 40> {};

template <>
struct HasPadding<::test::anonymous::OverrideTest> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::anonymous::OverrideTest> : public internal::BoolConstant<
                                                                 !HasPadding<::test::anonymous::OverrideTest>::value && IsMemcpyCompatible<::test::anonymous::Op>::value && IsMemcpyCompatible<::std::unique_ptr<::test::anonymous::Expression>>::value> {};

inline zx_status_t Clone(const ::test::anonymous::OverrideTest& value,
                         ::test::anonymous::OverrideTest* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::OverrideTest> {
  bool operator()(const ::test::anonymous::OverrideTest& _lhs, const ::test::anonymous::OverrideTest& _rhs) const {
    if (!::fidl::Equals(_lhs.op, _rhs.op)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.left, _rhs.left)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.right, _rhs.right)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::anonymous::Flags> {
  static constexpr size_t inline_size_v2 = sizeof(::test::anonymous::Flags);
  static void Encode(Encoder* encoder, ::test::anonymous::Flags* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint16_t underlying = static_cast<uint16_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::anonymous::Flags* value, size_t offset) {
    uint16_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::anonymous::Flags>(underlying);
  }
};

inline zx_status_t Clone(::test::anonymous::Flags value,
                         ::test::anonymous::Flags* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::Flags> {
  bool operator()(const ::test::anonymous::Flags& _lhs, const ::test::anonymous::Flags& _rhs) const {
    uint16_t _lhs_underlying = static_cast<uint16_t>(_lhs);
    uint16_t _rhs_underlying = static_cast<uint16_t>(_rhs);
    return ::fidl::Equals(_lhs_underlying, _rhs_underlying);
  }
};
template <>
struct CodingTraits<::test::anonymous::FunctionApplication>
    : public EncodableCodingTraits<::test::anonymous::FunctionApplication, 16> {};

inline zx_status_t Clone(const ::test::anonymous::FunctionApplication& _value,
                         ::test::anonymous::FunctionApplication* result) {
  return _value.Clone(result);
}
template <>
struct Equality<::test::anonymous::FunctionApplication> {
  bool operator()(const ::test::anonymous::FunctionApplication& _lhs, const ::test::anonymous::FunctionApplication& _rhs) const {
    if (_lhs.has_func()) {
      if (!_rhs.has_func()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.func(), _rhs.func())) {
        return false;
      }
    } else if (_rhs.has_func()) {
      return false;
    }
    if (_lhs.has_args()) {
      if (!_rhs.has_args()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.args(), _rhs.args())) {
        return false;
      }
    } else if (_rhs.has_args()) {
      return false;
    }
    if (_lhs.has_flags()) {
      if (!_rhs.has_flags()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.flags(), _rhs.flags())) {
        return false;
      }
    } else if (_rhs.has_flags()) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::anonymous::Expression> : public std::true_type {};

template <>
struct CodingTraits<::test::anonymous::Expression>
    : public EncodableCodingTraits<::test::anonymous::Expression, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::anonymous::Expression>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::anonymous::Expression>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::anonymous::Expression>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::anonymous::Expression);

    ::test::anonymous::Expression::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::anonymous::Expression& value,
                         ::test::anonymous::Expression* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::Expression> {
  bool operator()(const ::test::anonymous::Expression& _lhs, const ::test::anonymous::Expression& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::anonymous::Expression::Tag::Invalid):
        return true;
      case ::test::anonymous::Expression::Tag::kValue:
        return ::fidl::Equals(_lhs.value_, _rhs.value_);
      case ::test::anonymous::Expression::Tag::kBinOp:
        return ::fidl::Equals(_lhs.bin_op_, _rhs.bin_op_);
      case ::test::anonymous::Expression::Tag::kFunctionApplication:
        return ::fidl::Equals(_lhs.function_application_, _rhs.function_application_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
    }
  }
};
template <>
struct IsFidlXUnion<::test::anonymous::UnionMember> : public std::true_type {};

template <>
struct CodingTraits<::test::anonymous::UnionMember>
    : public EncodableCodingTraits<::test::anonymous::UnionMember, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::anonymous::UnionMember>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::anonymous::UnionMember>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::anonymous::UnionMember>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::anonymous::UnionMember);

    ::test::anonymous::UnionMember::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::anonymous::UnionMember& value,
                         ::test::anonymous::UnionMember* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::UnionMember> {
  bool operator()(const ::test::anonymous::UnionMember& _lhs, const ::test::anonymous::UnionMember& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::anonymous::UnionMember::Tag::Invalid):
        return true;
      case ::test::anonymous::UnionMember::Tag::kUnionData:
        return ::fidl::Equals(_lhs.union_data_, _rhs.union_data_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
    }
  }
};
template <>
struct CodingTraits<::test::anonymous::TableData>
    : public EncodableCodingTraits<::test::anonymous::TableData, 1> {};

template <>
struct IsMemcpyCompatible<::test::anonymous::TableData> : public internal::BoolConstant<
                                                              !HasPadding<::test::anonymous::TableData>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::anonymous::TableData& value,
                         ::test::anonymous::TableData* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::TableData> {
  bool operator()(const ::test::anonymous::TableData& _lhs, const ::test::anonymous::TableData& _rhs) const {
    if (!::fidl::Equals(_lhs.data, _rhs.data)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::anonymous::TableMember>
    : public EncodableCodingTraits<::test::anonymous::TableMember, 16> {};

inline zx_status_t Clone(const ::test::anonymous::TableMember& _value,
                         ::test::anonymous::TableMember* result) {
  return _value.Clone(result);
}
template <>
struct Equality<::test::anonymous::TableMember> {
  bool operator()(const ::test::anonymous::TableMember& _lhs, const ::test::anonymous::TableMember& _rhs) const {
    if (_lhs.has_table_data()) {
      if (!_rhs.has_table_data()) {
        return false;
      }
      if (!::fidl::Equals(_lhs.table_data(), _rhs.table_data())) {
        return false;
      }
    } else if (_rhs.has_table_data()) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::anonymous::SomeProtocolSomeMethodRequest>
    : public EncodableCodingTraits<::test::anonymous::SomeProtocolSomeMethodRequest, 32> {};

template <>
struct HasPadding<::test::anonymous::SomeProtocolSomeMethodRequest> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::anonymous::SomeProtocolSomeMethodRequest> : public internal::BoolConstant<
                                                                                  !HasPadding<::test::anonymous::SomeProtocolSomeMethodRequest>::value && IsMemcpyCompatible<::test::anonymous::UnionMember>::value && IsMemcpyCompatible<::test::anonymous::TableMember>::value> {};

inline zx_status_t Clone(const ::test::anonymous::SomeProtocolSomeMethodRequest& value,
                         ::test::anonymous::SomeProtocolSomeMethodRequest* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::SomeProtocolSomeMethodRequest> {
  bool operator()(const ::test::anonymous::SomeProtocolSomeMethodRequest& _lhs, const ::test::anonymous::SomeProtocolSomeMethodRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.union_member, _rhs.union_member)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.table_member, _rhs.table_member)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::anonymous::BitsMember> {
  static constexpr size_t inline_size_v2 = sizeof(::test::anonymous::BitsMember);
  static void Encode(Encoder* encoder, ::test::anonymous::BitsMember* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::anonymous::BitsMember* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::anonymous::BitsMember>(underlying);
  }
};

inline zx_status_t Clone(::test::anonymous::BitsMember value,
                         ::test::anonymous::BitsMember* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::BitsMember> {
  bool operator()(const ::test::anonymous::BitsMember& _lhs, const ::test::anonymous::BitsMember& _rhs) const {
    uint32_t _lhs_underlying = static_cast<uint32_t>(_lhs);
    uint32_t _rhs_underlying = static_cast<uint32_t>(_rhs);
    return ::fidl::Equals(_lhs_underlying, _rhs_underlying);
  }
};
template <>
struct CodingTraits<::test::anonymous::SomeProtocol_SomeMethod_Response>
    : public EncodableCodingTraits<::test::anonymous::SomeProtocol_SomeMethod_Response, 4> {};

template <>
struct IsMemcpyCompatible<::test::anonymous::SomeProtocol_SomeMethod_Response> : public internal::BoolConstant<
                                                                                     !HasPadding<::test::anonymous::SomeProtocol_SomeMethod_Response>::value && IsMemcpyCompatible<::test::anonymous::BitsMember>::value> {};

inline zx_status_t Clone(const ::test::anonymous::SomeProtocol_SomeMethod_Response& value,
                         ::test::anonymous::SomeProtocol_SomeMethod_Response* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::SomeProtocol_SomeMethod_Response> {
  bool operator()(const ::test::anonymous::SomeProtocol_SomeMethod_Response& _lhs, const ::test::anonymous::SomeProtocol_SomeMethod_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.bits_member, _rhs.bits_member)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::anonymous::SomeProtocol_SomeMethod_Error> {
  static constexpr size_t inline_size_v2 = sizeof(::test::anonymous::SomeProtocol_SomeMethod_Error);
  static void Encode(Encoder* encoder, ::test::anonymous::SomeProtocol_SomeMethod_Error* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::anonymous::SomeProtocol_SomeMethod_Error* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::anonymous::SomeProtocol_SomeMethod_Error>(underlying);
  }
};

inline zx_status_t Clone(::test::anonymous::SomeProtocol_SomeMethod_Error value,
                         ::test::anonymous::SomeProtocol_SomeMethod_Error* result) {
  return ::test::anonymous::Clone(value, result);
}
template <>
struct Equality<::test::anonymous::SomeProtocol_SomeMethod_Error> {
  bool operator()(const ::test::anonymous::SomeProtocol_SomeMethod_Error& _lhs, const ::test::anonymous::SomeProtocol_SomeMethod_Error& _rhs) const {
    return _lhs == _rhs;
  }
};

template <>
struct IsFidlXUnion<::test::anonymous::SomeProtocol_SomeMethod_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::anonymous::SomeProtocol_SomeMethod_Result>
    : public EncodableCodingTraits<::test::anonymous::SomeProtocol_SomeMethod_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::anonymous::SomeProtocol_SomeMethod_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::anonymous::SomeProtocol_SomeMethod_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::anonymous::SomeProtocol_SomeMethod_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::anonymous::SomeProtocol_SomeMethod_Result);

    ::test::anonymous::SomeProtocol_SomeMethod_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::anonymous::SomeProtocol_SomeMethod_Result& value,
                         ::test::anonymous::SomeProtocol_SomeMethod_Result* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::SomeProtocol_SomeMethod_Result> {
  bool operator()(const ::test::anonymous::SomeProtocol_SomeMethod_Result& _lhs, const ::test::anonymous::SomeProtocol_SomeMethod_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::Invalid):
        return true;
      case ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::anonymous::SomeProtocol_SomeMethod_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::anonymous::SomeProtocolSomeMethodTopResponse>
    : public EncodableCodingTraits<::test::anonymous::SomeProtocolSomeMethodTopResponse, 16> {};

template <>
struct HasPadding<::test::anonymous::SomeProtocolSomeMethodTopResponse> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::anonymous::SomeProtocolSomeMethodTopResponse> : public internal::BoolConstant<
                                                                                      !HasPadding<::test::anonymous::SomeProtocolSomeMethodTopResponse>::value && IsMemcpyCompatible<::test::anonymous::SomeProtocol_SomeMethod_Result>::value> {};

inline zx_status_t Clone(const ::test::anonymous::SomeProtocolSomeMethodTopResponse& value,
                         ::test::anonymous::SomeProtocolSomeMethodTopResponse* result) {
  return ::test::anonymous::Clone(value, result);
}

template <>
struct Equality<::test::anonymous::SomeProtocolSomeMethodTopResponse> {
  bool operator()(const ::test::anonymous::SomeProtocolSomeMethodTopResponse& _lhs, const ::test::anonymous::SomeProtocolSomeMethodTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};

//
// Proxies and stubs declarations
//
}  // namespace fidl
namespace test {
namespace anonymous {

#ifdef __Fuchsia__

using SomeProtocolPtr = ::fidl::InterfacePtr<SomeProtocol>;
class SomeProtocol_Proxy;
class SomeProtocol_Stub;
class SomeProtocol_EventSender;
class SomeProtocol_Sync;
using SomeProtocolSyncPtr = ::fidl::SynchronousInterfacePtr<SomeProtocol>;
class SomeProtocol_SyncProxy;

namespace internal {

constexpr uint64_t kSomeProtocol_SomeMethod_Ordinal = 0x22ea52ec7a5146d8lu;

constexpr ::fidl::MessageDynamicFlags kSomeProtocol_SomeMethod_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
}  // namespace internal

#endif  // __Fuchsia__

#ifdef __Fuchsia__

class SomeProtocol {
 public:
  using Proxy_ = ::test::anonymous::SomeProtocol_Proxy;
  using Stub_ = ::test::anonymous::SomeProtocol_Stub;
  using EventSender_ = ::test::anonymous::SomeProtocol_EventSender;
  using Sync_ = ::test::anonymous::SomeProtocol_Sync;
  virtual ~SomeProtocol();
  using SomeMethodCallback =
      fit::function<void(::test::anonymous::SomeProtocol_SomeMethod_Result)>;

  virtual void SomeMethod(::test::anonymous::UnionMember union_member, ::test::anonymous::TableMember table_member, SomeMethodCallback callback) = 0;
};

class SomeProtocol_RequestDecoder {
 public:
  SomeProtocol_RequestDecoder() = default;
  virtual ~SomeProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response, bool* is_known);
  virtual void SomeMethod(::test::anonymous::UnionMember union_member, ::test::anonymous::TableMember table_member) = 0;
};

class SomeProtocol_ResponseDecoder {
 public:
  SomeProtocol_ResponseDecoder() = default;
  virtual ~SomeProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void SomeMethod(::test::anonymous::SomeProtocol_SomeMethod_Result result) = 0;
};

class SomeProtocol_EventSender {
 public:
  virtual ~SomeProtocol_EventSender();
};

class SomeProtocol_Sync {
 public:
  using Proxy_ = ::test::anonymous::SomeProtocol_SyncProxy;
  virtual ~SomeProtocol_Sync();
  virtual zx_status_t SomeMethod(::test::anonymous::UnionMember union_member, ::test::anonymous::TableMember table_member, ::test::anonymous::SomeProtocol_SomeMethod_Result* out_result) = 0;
};

class SomeProtocol_Proxy final : public ::fidl::internal::Proxy, public SomeProtocol {
 public:
  explicit SomeProtocol_Proxy(::fidl::internal::ProxyController* controller);
  ~SomeProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.anonymous/SomeProtocol.SomeMethod
  void SomeMethod(::test::anonymous::UnionMember union_member, ::test::anonymous::TableMember table_member, SomeMethodCallback callback) override;

 private:
  SomeProtocol_Proxy(const ::test::anonymous::SomeProtocol_Proxy&) = delete;
  SomeProtocol_Proxy& operator=(const ::test::anonymous::SomeProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class SomeProtocol_Stub final : public ::fidl::internal::Stub, public ::test::anonymous::SomeProtocol_EventSender {
 public:
  typedef class ::test::anonymous::SomeProtocol SomeProtocol_clazz;
  explicit SomeProtocol_Stub(::test::anonymous::SomeProtocol_Stub::SomeProtocol_clazz* impl);
  ~SomeProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  ::test::anonymous::SomeProtocol_Stub::SomeProtocol_clazz* impl_;
};

class SomeProtocol_SyncProxy : public ::test::anonymous::SomeProtocol_Sync {
 public:
  explicit SomeProtocol_SyncProxy(::zx::channel channel);
  ~SomeProtocol_SyncProxy() override;
  // cts-coverage-fidl-name:test.anonymous/SomeProtocol.SomeMethod
  zx_status_t SomeMethod(::test::anonymous::UnionMember union_member, ::test::anonymous::TableMember table_member, ::test::anonymous::SomeProtocol_SomeMethod_Result* out_result) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<SomeProtocol>;
};

#endif  // __Fuchsia__

}  // namespace anonymous
}  // namespace test
