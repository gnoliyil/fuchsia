// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#include <test/table/cpp/fidl.h>

#include "lib/fidl/cpp/internal/implementation.h"


//
// Domain objects definitions
//
namespace test {
namespace table {

extern "C" const fidl_type_t test_table_EmptyTableTable;
const fidl_type_t* EmptyTable::FidlType = &test_table_EmptyTableTable;

EmptyTable::EmptyTable() {}

EmptyTable::EmptyTable(EmptyTable&& other) {
  field_presence_ = other.field_presence_;
}

EmptyTable::~EmptyTable() {
}

EmptyTable& EmptyTable::operator=(EmptyTable&& other) {
  return *this;
}

bool EmptyTable::IsEmpty() const {
  return field_presence_.IsEmpty();
}

void EmptyTable::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
}

void EmptyTable::Decode(::fidl::Decoder* _decoder, EmptyTable* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;

  

  return;

  // Clear unset values.
clear_all:
  return;
}

zx_status_t EmptyTable::Clone(EmptyTable* result) const {
  return ZX_OK;
}


extern "C" const fidl_type_t test_table_SimpleTableTable;
const fidl_type_t* SimpleTable::FidlType = &test_table_SimpleTableTable;

SimpleTable::SimpleTable() {}

SimpleTable::SimpleTable(SimpleTable&& other) {
  field_presence_ = other.field_presence_;
  if (field_presence_.IsSet<0>()) {
    Construct(&x_value_.value, std::move(other.x_value_.value));
  }
  if (field_presence_.IsSet<4>()) {
    Construct(&y_value_.value, std::move(other.y_value_.value));
  }
}

SimpleTable::~SimpleTable() {
  if (field_presence_.IsSet<0>()) {
    Destruct(&x_value_.value);
  }
  if (field_presence_.IsSet<4>()) {
    Destruct(&y_value_.value);
  }
}

SimpleTable& SimpleTable::operator=(SimpleTable&& other) {
  if (other.field_presence_.IsSet<0>()) {
    if (field_presence_.IsSet<0>()) {
      x_value_.value = std::move(other.x_value_.value);
    } else {
      field_presence_.Set<0>();
      Construct(&x_value_.value, std::move(other.x_value_.value));
    }
  } else if (field_presence_.IsSet<0>()) {
    field_presence_.Clear<0>();
    Destruct(&x_value_.value);
  }
  if (other.field_presence_.IsSet<4>()) {
    if (field_presence_.IsSet<4>()) {
      y_value_.value = std::move(other.y_value_.value);
    } else {
      field_presence_.Set<4>();
      Construct(&y_value_.value, std::move(other.y_value_.value));
    }
  } else if (field_presence_.IsSet<4>()) {
    field_presence_.Clear<4>();
    Destruct(&y_value_.value);
  }
  return *this;
}

bool SimpleTable::IsEmpty() const {
  return field_presence_.IsEmpty();
}
SimpleTable& SimpleTable::set_x(int64_t _value) {
  if (!field_presence_.IsSet<0>()) {
    field_presence_.Set<0>();
    Construct(&x_value_.value, std::move(_value));
  } else {
    x_value_.value = std::move(_value);
  }
  return *this;
}
SimpleTable& SimpleTable::set_y(int64_t _value) {
  if (!field_presence_.IsSet<4>()) {
    field_presence_.Set<4>();
    Construct(&y_value_.value, std::move(_value));
  } else {
    y_value_.value = std::move(_value);
  }
  return *this;
}

void SimpleTable::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
  if (field_presence_.IsSet<0>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &x_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &x_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<4>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (5 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &y_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &y_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
}

void SimpleTable::Decode(::fidl::Decoder* _decoder, SimpleTable* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_x(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_x();
    }
  } else {
    goto done_1;
  }
  if (count >= 5) {
    size_t envelope_base = base + (5 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_y(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_y();
    }
  } else {
    goto done_5;
  }

  

  return;

  // Clear unset values.
clear_all:
done_1:
  _value->clear_x();
done_5:
  _value->clear_y();
  return;
}

zx_status_t SimpleTable::Clone(SimpleTable* result) const {
  if (field_presence_.IsSet<0>()) {
    zx_status_t _status = ::fidl::Clone(x_value_.value, result->mutable_x());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_x();
  }
  if (field_presence_.IsSet<4>()) {
    zx_status_t _status = ::fidl::Clone(y_value_.value, result->mutable_y());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_y();
  }
  return ZX_OK;
}


extern "C" const fidl_type_t test_table_OlderSimpleTableTable;
const fidl_type_t* OlderSimpleTable::FidlType = &test_table_OlderSimpleTableTable;

OlderSimpleTable::OlderSimpleTable() {}

OlderSimpleTable::OlderSimpleTable(OlderSimpleTable&& other) {
  field_presence_ = other.field_presence_;
  if (field_presence_.IsSet<0>()) {
    Construct(&x_value_.value, std::move(other.x_value_.value));
  }
}

OlderSimpleTable::~OlderSimpleTable() {
  if (field_presence_.IsSet<0>()) {
    Destruct(&x_value_.value);
  }
}

OlderSimpleTable& OlderSimpleTable::operator=(OlderSimpleTable&& other) {
  if (other.field_presence_.IsSet<0>()) {
    if (field_presence_.IsSet<0>()) {
      x_value_.value = std::move(other.x_value_.value);
    } else {
      field_presence_.Set<0>();
      Construct(&x_value_.value, std::move(other.x_value_.value));
    }
  } else if (field_presence_.IsSet<0>()) {
    field_presence_.Clear<0>();
    Destruct(&x_value_.value);
  }
  return *this;
}

bool OlderSimpleTable::IsEmpty() const {
  return field_presence_.IsEmpty();
}
OlderSimpleTable& OlderSimpleTable::set_x(int64_t _value) {
  if (!field_presence_.IsSet<0>()) {
    field_presence_.Set<0>();
    Construct(&x_value_.value, std::move(_value));
  } else {
    x_value_.value = std::move(_value);
  }
  return *this;
}

void OlderSimpleTable::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
  if (field_presence_.IsSet<0>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &x_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &x_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
}

void OlderSimpleTable::Decode(::fidl::Decoder* _decoder, OlderSimpleTable* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_x(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_x();
    }
  } else {
    goto done_1;
  }

  

  return;

  // Clear unset values.
clear_all:
done_1:
  _value->clear_x();
  return;
}

zx_status_t OlderSimpleTable::Clone(OlderSimpleTable* result) const {
  if (field_presence_.IsSet<0>()) {
    zx_status_t _status = ::fidl::Clone(x_value_.value, result->mutable_x());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_x();
  }
  return ZX_OK;
}


extern "C" const fidl_type_t test_table_NewerSimpleTableTable;
const fidl_type_t* NewerSimpleTable::FidlType = &test_table_NewerSimpleTableTable;

NewerSimpleTable::NewerSimpleTable() {}

NewerSimpleTable::NewerSimpleTable(NewerSimpleTable&& other) {
  field_presence_ = other.field_presence_;
  if (field_presence_.IsSet<0>()) {
    Construct(&x_value_.value, std::move(other.x_value_.value));
  }
  if (field_presence_.IsSet<4>()) {
    Construct(&y_value_.value, std::move(other.y_value_.value));
  }
  if (field_presence_.IsSet<5>()) {
    Construct(&z_value_.value, std::move(other.z_value_.value));
  }
}

NewerSimpleTable::~NewerSimpleTable() {
  if (field_presence_.IsSet<0>()) {
    Destruct(&x_value_.value);
  }
  if (field_presence_.IsSet<4>()) {
    Destruct(&y_value_.value);
  }
  if (field_presence_.IsSet<5>()) {
    Destruct(&z_value_.value);
  }
}

NewerSimpleTable& NewerSimpleTable::operator=(NewerSimpleTable&& other) {
  if (other.field_presence_.IsSet<0>()) {
    if (field_presence_.IsSet<0>()) {
      x_value_.value = std::move(other.x_value_.value);
    } else {
      field_presence_.Set<0>();
      Construct(&x_value_.value, std::move(other.x_value_.value));
    }
  } else if (field_presence_.IsSet<0>()) {
    field_presence_.Clear<0>();
    Destruct(&x_value_.value);
  }
  if (other.field_presence_.IsSet<4>()) {
    if (field_presence_.IsSet<4>()) {
      y_value_.value = std::move(other.y_value_.value);
    } else {
      field_presence_.Set<4>();
      Construct(&y_value_.value, std::move(other.y_value_.value));
    }
  } else if (field_presence_.IsSet<4>()) {
    field_presence_.Clear<4>();
    Destruct(&y_value_.value);
  }
  if (other.field_presence_.IsSet<5>()) {
    if (field_presence_.IsSet<5>()) {
      z_value_.value = std::move(other.z_value_.value);
    } else {
      field_presence_.Set<5>();
      Construct(&z_value_.value, std::move(other.z_value_.value));
    }
  } else if (field_presence_.IsSet<5>()) {
    field_presence_.Clear<5>();
    Destruct(&z_value_.value);
  }
  return *this;
}

bool NewerSimpleTable::IsEmpty() const {
  return field_presence_.IsEmpty();
}
NewerSimpleTable& NewerSimpleTable::set_x(int64_t _value) {
  if (!field_presence_.IsSet<0>()) {
    field_presence_.Set<0>();
    Construct(&x_value_.value, std::move(_value));
  } else {
    x_value_.value = std::move(_value);
  }
  return *this;
}
NewerSimpleTable& NewerSimpleTable::set_y(int64_t _value) {
  if (!field_presence_.IsSet<4>()) {
    field_presence_.Set<4>();
    Construct(&y_value_.value, std::move(_value));
  } else {
    y_value_.value = std::move(_value);
  }
  return *this;
}
NewerSimpleTable& NewerSimpleTable::set_z(int64_t _value) {
  if (!field_presence_.IsSet<5>()) {
    field_presence_.Set<5>();
    Construct(&z_value_.value, std::move(_value));
  } else {
    z_value_.value = std::move(_value);
  }
  return *this;
}

void NewerSimpleTable::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
  if (field_presence_.IsSet<0>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &x_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &x_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<4>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (5 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &y_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &y_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<5>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (6 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &z_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &z_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
}

void NewerSimpleTable::Decode(::fidl::Decoder* _decoder, NewerSimpleTable* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_x(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_x();
    }
  } else {
    goto done_1;
  }
  if (count >= 5) {
    size_t envelope_base = base + (5 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_y(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_y();
    }
  } else {
    goto done_5;
  }
  if (count >= 6) {
    size_t envelope_base = base + (6 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_z(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_z();
    }
  } else {
    goto done_6;
  }

  

  return;

  // Clear unset values.
clear_all:
done_1:
  _value->clear_x();
done_5:
  _value->clear_y();
done_6:
  _value->clear_z();
  return;
}

zx_status_t NewerSimpleTable::Clone(NewerSimpleTable* result) const {
  if (field_presence_.IsSet<0>()) {
    zx_status_t _status = ::fidl::Clone(x_value_.value, result->mutable_x());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_x();
  }
  if (field_presence_.IsSet<4>()) {
    zx_status_t _status = ::fidl::Clone(y_value_.value, result->mutable_y());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_y();
  }
  if (field_presence_.IsSet<5>()) {
    zx_status_t _status = ::fidl::Clone(z_value_.value, result->mutable_z());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_z();
  }
  return ZX_OK;
}


extern "C" const fidl_type_t test_table_ReverseOrdinalTableTable;
const fidl_type_t* ReverseOrdinalTable::FidlType = &test_table_ReverseOrdinalTableTable;

ReverseOrdinalTable::ReverseOrdinalTable() {}

ReverseOrdinalTable::ReverseOrdinalTable(ReverseOrdinalTable&& other) {
  field_presence_ = other.field_presence_;
  if (field_presence_.IsSet<0>()) {
    Construct(&z_value_.value, std::move(other.z_value_.value));
  }
  if (field_presence_.IsSet<1>()) {
    Construct(&y_value_.value, std::move(other.y_value_.value));
  }
  if (field_presence_.IsSet<2>()) {
    Construct(&x_value_.value, std::move(other.x_value_.value));
  }
}

ReverseOrdinalTable::~ReverseOrdinalTable() {
  if (field_presence_.IsSet<0>()) {
    Destruct(&z_value_.value);
  }
  if (field_presence_.IsSet<1>()) {
    Destruct(&y_value_.value);
  }
  if (field_presence_.IsSet<2>()) {
    Destruct(&x_value_.value);
  }
}

ReverseOrdinalTable& ReverseOrdinalTable::operator=(ReverseOrdinalTable&& other) {
  if (other.field_presence_.IsSet<0>()) {
    if (field_presence_.IsSet<0>()) {
      z_value_.value = std::move(other.z_value_.value);
    } else {
      field_presence_.Set<0>();
      Construct(&z_value_.value, std::move(other.z_value_.value));
    }
  } else if (field_presence_.IsSet<0>()) {
    field_presence_.Clear<0>();
    Destruct(&z_value_.value);
  }
  if (other.field_presence_.IsSet<1>()) {
    if (field_presence_.IsSet<1>()) {
      y_value_.value = std::move(other.y_value_.value);
    } else {
      field_presence_.Set<1>();
      Construct(&y_value_.value, std::move(other.y_value_.value));
    }
  } else if (field_presence_.IsSet<1>()) {
    field_presence_.Clear<1>();
    Destruct(&y_value_.value);
  }
  if (other.field_presence_.IsSet<2>()) {
    if (field_presence_.IsSet<2>()) {
      x_value_.value = std::move(other.x_value_.value);
    } else {
      field_presence_.Set<2>();
      Construct(&x_value_.value, std::move(other.x_value_.value));
    }
  } else if (field_presence_.IsSet<2>()) {
    field_presence_.Clear<2>();
    Destruct(&x_value_.value);
  }
  return *this;
}

bool ReverseOrdinalTable::IsEmpty() const {
  return field_presence_.IsEmpty();
}
ReverseOrdinalTable& ReverseOrdinalTable::set_z(int64_t _value) {
  if (!field_presence_.IsSet<0>()) {
    field_presence_.Set<0>();
    Construct(&z_value_.value, std::move(_value));
  } else {
    z_value_.value = std::move(_value);
  }
  return *this;
}
ReverseOrdinalTable& ReverseOrdinalTable::set_y(int64_t _value) {
  if (!field_presence_.IsSet<1>()) {
    field_presence_.Set<1>();
    Construct(&y_value_.value, std::move(_value));
  } else {
    y_value_.value = std::move(_value);
  }
  return *this;
}
ReverseOrdinalTable& ReverseOrdinalTable::set_x(int64_t _value) {
  if (!field_presence_.IsSet<2>()) {
    field_presence_.Set<2>();
    Construct(&x_value_.value, std::move(_value));
  } else {
    x_value_.value = std::move(_value);
  }
  return *this;
}

void ReverseOrdinalTable::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
  if (field_presence_.IsSet<0>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &z_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &z_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<1>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (2 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &y_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &y_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<2>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (3 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &x_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &x_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
}

void ReverseOrdinalTable::Decode(::fidl::Decoder* _decoder, ReverseOrdinalTable* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_z(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_z();
    }
  } else {
    goto done_1;
  }
  if (count >= 2) {
    size_t envelope_base = base + (2 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_y(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_y();
    }
  } else {
    goto done_2;
  }
  if (count >= 3) {
    size_t envelope_base = base + (3 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_x(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_x();
    }
  } else {
    goto done_3;
  }

  

  return;

  // Clear unset values.
clear_all:
done_1:
  _value->clear_z();
done_2:
  _value->clear_y();
done_3:
  _value->clear_x();
  return;
}

zx_status_t ReverseOrdinalTable::Clone(ReverseOrdinalTable* result) const {
  if (field_presence_.IsSet<0>()) {
    zx_status_t _status = ::fidl::Clone(z_value_.value, result->mutable_z());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_z();
  }
  if (field_presence_.IsSet<1>()) {
    zx_status_t _status = ::fidl::Clone(y_value_.value, result->mutable_y());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_y();
  }
  if (field_presence_.IsSet<2>()) {
    zx_status_t _status = ::fidl::Clone(x_value_.value, result->mutable_x());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_x();
  }
  return ZX_OK;
}


extern "C" const fidl_type_t test_table_TableWithAttributesTable;
const fidl_type_t* TableWithAttributes::FidlType = &test_table_TableWithAttributesTable;

TableWithAttributes::TableWithAttributes() {}

TableWithAttributes::TableWithAttributes(TableWithAttributes&& other) {
  field_presence_ = other.field_presence_;
  if (field_presence_.IsSet<0>()) {
    Construct(&x_value_.value, std::move(other.x_value_.value));
  }
}

TableWithAttributes::~TableWithAttributes() {
  if (field_presence_.IsSet<0>()) {
    Destruct(&x_value_.value);
  }
}

TableWithAttributes& TableWithAttributes::operator=(TableWithAttributes&& other) {
  if (other.field_presence_.IsSet<0>()) {
    if (field_presence_.IsSet<0>()) {
      x_value_.value = std::move(other.x_value_.value);
    } else {
      field_presence_.Set<0>();
      Construct(&x_value_.value, std::move(other.x_value_.value));
    }
  } else if (field_presence_.IsSet<0>()) {
    field_presence_.Clear<0>();
    Destruct(&x_value_.value);
  }
  return *this;
}

bool TableWithAttributes::IsEmpty() const {
  return field_presence_.IsEmpty();
}
TableWithAttributes& TableWithAttributes::set_x(int64_t _value) {
  if (!field_presence_.IsSet<0>()) {
    field_presence_.Set<0>();
    Construct(&x_value_.value, std::move(_value));
  } else {
    x_value_.value = std::move(_value);
  }
  return *this;
}

void TableWithAttributes::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
  if (field_presence_.IsSet<0>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &x_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &x_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
}

void TableWithAttributes::Decode(::fidl::Decoder* _decoder, TableWithAttributes* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_x(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_x();
    }
  } else {
    goto done_1;
  }

  

  return;

  // Clear unset values.
clear_all:
done_1:
  _value->clear_x();
  return;
}

zx_status_t TableWithAttributes::Clone(TableWithAttributes* result) const {
  if (field_presence_.IsSet<0>()) {
    zx_status_t _status = ::fidl::Clone(x_value_.value, result->mutable_x());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_x();
  }
  return ZX_OK;
}


extern "C" const fidl_type_t test_table_ExtensionTableTable;
const fidl_type_t* ExtensionTable::FidlType = &test_table_ExtensionTableTable;

ExtensionTable::ExtensionTable() {}

ExtensionTable::ExtensionTable(ExtensionTable&& other) {
  field_presence_ = other.field_presence_;
}

ExtensionTable::~ExtensionTable() {
}

ExtensionTable& ExtensionTable::operator=(ExtensionTable&& other) {
  return *this;
}

bool ExtensionTable::IsEmpty() const {
  return field_presence_.IsEmpty();
}

void ExtensionTable::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
}

void ExtensionTable::Decode(::fidl::Decoder* _decoder, ExtensionTable* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;

  

  return;

  // Clear unset values.
clear_all:
  return;
}

zx_status_t ExtensionTable::Clone(ExtensionTable* result) const {
  return ZX_OK;
}


extern "C" const fidl_type_t test_table_SixtyFourOrdinalTableTable;
const fidl_type_t* SixtyFourOrdinalTable::FidlType = &test_table_SixtyFourOrdinalTableTable;

SixtyFourOrdinalTable::SixtyFourOrdinalTable() {}

SixtyFourOrdinalTable::SixtyFourOrdinalTable(SixtyFourOrdinalTable&& other) {
  field_presence_ = other.field_presence_;
  if (field_presence_.IsSet<0>()) {
    Construct(&v1_value_.value, std::move(other.v1_value_.value));
  }
  if (field_presence_.IsSet<1>()) {
    Construct(&v2_value_.value, std::move(other.v2_value_.value));
  }
  if (field_presence_.IsSet<2>()) {
    Construct(&v3_value_.value, std::move(other.v3_value_.value));
  }
  if (field_presence_.IsSet<3>()) {
    Construct(&v4_value_.value, std::move(other.v4_value_.value));
  }
  if (field_presence_.IsSet<4>()) {
    Construct(&v5_value_.value, std::move(other.v5_value_.value));
  }
  if (field_presence_.IsSet<5>()) {
    Construct(&v6_value_.value, std::move(other.v6_value_.value));
  }
  if (field_presence_.IsSet<6>()) {
    Construct(&v7_value_.value, std::move(other.v7_value_.value));
  }
  if (field_presence_.IsSet<7>()) {
    Construct(&v8_value_.value, std::move(other.v8_value_.value));
  }
  if (field_presence_.IsSet<8>()) {
    Construct(&v9_value_.value, std::move(other.v9_value_.value));
  }
  if (field_presence_.IsSet<9>()) {
    Construct(&v10_value_.value, std::move(other.v10_value_.value));
  }
  if (field_presence_.IsSet<10>()) {
    Construct(&v11_value_.value, std::move(other.v11_value_.value));
  }
  if (field_presence_.IsSet<11>()) {
    Construct(&v12_value_.value, std::move(other.v12_value_.value));
  }
  if (field_presence_.IsSet<12>()) {
    Construct(&v13_value_.value, std::move(other.v13_value_.value));
  }
  if (field_presence_.IsSet<13>()) {
    Construct(&v14_value_.value, std::move(other.v14_value_.value));
  }
  if (field_presence_.IsSet<14>()) {
    Construct(&v15_value_.value, std::move(other.v15_value_.value));
  }
  if (field_presence_.IsSet<15>()) {
    Construct(&v16_value_.value, std::move(other.v16_value_.value));
  }
  if (field_presence_.IsSet<16>()) {
    Construct(&v17_value_.value, std::move(other.v17_value_.value));
  }
  if (field_presence_.IsSet<17>()) {
    Construct(&v18_value_.value, std::move(other.v18_value_.value));
  }
  if (field_presence_.IsSet<18>()) {
    Construct(&v19_value_.value, std::move(other.v19_value_.value));
  }
  if (field_presence_.IsSet<19>()) {
    Construct(&v20_value_.value, std::move(other.v20_value_.value));
  }
  if (field_presence_.IsSet<20>()) {
    Construct(&v21_value_.value, std::move(other.v21_value_.value));
  }
  if (field_presence_.IsSet<21>()) {
    Construct(&v22_value_.value, std::move(other.v22_value_.value));
  }
  if (field_presence_.IsSet<22>()) {
    Construct(&v23_value_.value, std::move(other.v23_value_.value));
  }
  if (field_presence_.IsSet<23>()) {
    Construct(&v24_value_.value, std::move(other.v24_value_.value));
  }
  if (field_presence_.IsSet<24>()) {
    Construct(&v25_value_.value, std::move(other.v25_value_.value));
  }
  if (field_presence_.IsSet<25>()) {
    Construct(&v26_value_.value, std::move(other.v26_value_.value));
  }
  if (field_presence_.IsSet<26>()) {
    Construct(&v27_value_.value, std::move(other.v27_value_.value));
  }
  if (field_presence_.IsSet<27>()) {
    Construct(&v28_value_.value, std::move(other.v28_value_.value));
  }
  if (field_presence_.IsSet<28>()) {
    Construct(&v29_value_.value, std::move(other.v29_value_.value));
  }
  if (field_presence_.IsSet<29>()) {
    Construct(&v30_value_.value, std::move(other.v30_value_.value));
  }
  if (field_presence_.IsSet<30>()) {
    Construct(&v31_value_.value, std::move(other.v31_value_.value));
  }
  if (field_presence_.IsSet<31>()) {
    Construct(&v32_value_.value, std::move(other.v32_value_.value));
  }
  if (field_presence_.IsSet<32>()) {
    Construct(&v33_value_.value, std::move(other.v33_value_.value));
  }
  if (field_presence_.IsSet<33>()) {
    Construct(&v34_value_.value, std::move(other.v34_value_.value));
  }
  if (field_presence_.IsSet<34>()) {
    Construct(&v35_value_.value, std::move(other.v35_value_.value));
  }
  if (field_presence_.IsSet<35>()) {
    Construct(&v36_value_.value, std::move(other.v36_value_.value));
  }
  if (field_presence_.IsSet<36>()) {
    Construct(&v37_value_.value, std::move(other.v37_value_.value));
  }
  if (field_presence_.IsSet<37>()) {
    Construct(&v38_value_.value, std::move(other.v38_value_.value));
  }
  if (field_presence_.IsSet<38>()) {
    Construct(&v39_value_.value, std::move(other.v39_value_.value));
  }
  if (field_presence_.IsSet<39>()) {
    Construct(&v40_value_.value, std::move(other.v40_value_.value));
  }
  if (field_presence_.IsSet<40>()) {
    Construct(&v41_value_.value, std::move(other.v41_value_.value));
  }
  if (field_presence_.IsSet<41>()) {
    Construct(&v42_value_.value, std::move(other.v42_value_.value));
  }
  if (field_presence_.IsSet<42>()) {
    Construct(&v43_value_.value, std::move(other.v43_value_.value));
  }
  if (field_presence_.IsSet<43>()) {
    Construct(&v44_value_.value, std::move(other.v44_value_.value));
  }
  if (field_presence_.IsSet<44>()) {
    Construct(&v45_value_.value, std::move(other.v45_value_.value));
  }
  if (field_presence_.IsSet<45>()) {
    Construct(&v46_value_.value, std::move(other.v46_value_.value));
  }
  if (field_presence_.IsSet<46>()) {
    Construct(&v47_value_.value, std::move(other.v47_value_.value));
  }
  if (field_presence_.IsSet<47>()) {
    Construct(&v48_value_.value, std::move(other.v48_value_.value));
  }
  if (field_presence_.IsSet<48>()) {
    Construct(&v49_value_.value, std::move(other.v49_value_.value));
  }
  if (field_presence_.IsSet<49>()) {
    Construct(&v50_value_.value, std::move(other.v50_value_.value));
  }
  if (field_presence_.IsSet<50>()) {
    Construct(&v51_value_.value, std::move(other.v51_value_.value));
  }
  if (field_presence_.IsSet<51>()) {
    Construct(&v52_value_.value, std::move(other.v52_value_.value));
  }
  if (field_presence_.IsSet<52>()) {
    Construct(&v53_value_.value, std::move(other.v53_value_.value));
  }
  if (field_presence_.IsSet<53>()) {
    Construct(&v54_value_.value, std::move(other.v54_value_.value));
  }
  if (field_presence_.IsSet<54>()) {
    Construct(&v55_value_.value, std::move(other.v55_value_.value));
  }
  if (field_presence_.IsSet<55>()) {
    Construct(&v56_value_.value, std::move(other.v56_value_.value));
  }
  if (field_presence_.IsSet<56>()) {
    Construct(&v57_value_.value, std::move(other.v57_value_.value));
  }
  if (field_presence_.IsSet<57>()) {
    Construct(&v58_value_.value, std::move(other.v58_value_.value));
  }
  if (field_presence_.IsSet<58>()) {
    Construct(&v59_value_.value, std::move(other.v59_value_.value));
  }
  if (field_presence_.IsSet<59>()) {
    Construct(&v60_value_.value, std::move(other.v60_value_.value));
  }
  if (field_presence_.IsSet<60>()) {
    Construct(&v61_value_.value, std::move(other.v61_value_.value));
  }
  if (field_presence_.IsSet<61>()) {
    Construct(&v62_value_.value, std::move(other.v62_value_.value));
  }
  if (field_presence_.IsSet<62>()) {
    Construct(&v63_value_.value, std::move(other.v63_value_.value));
  }
  if (field_presence_.IsSet<63>()) {
    Construct(&v64_value_.value, std::move(other.v64_value_.value));
  }
}

SixtyFourOrdinalTable::~SixtyFourOrdinalTable() {
  if (field_presence_.IsSet<0>()) {
    Destruct(&v1_value_.value);
  }
  if (field_presence_.IsSet<1>()) {
    Destruct(&v2_value_.value);
  }
  if (field_presence_.IsSet<2>()) {
    Destruct(&v3_value_.value);
  }
  if (field_presence_.IsSet<3>()) {
    Destruct(&v4_value_.value);
  }
  if (field_presence_.IsSet<4>()) {
    Destruct(&v5_value_.value);
  }
  if (field_presence_.IsSet<5>()) {
    Destruct(&v6_value_.value);
  }
  if (field_presence_.IsSet<6>()) {
    Destruct(&v7_value_.value);
  }
  if (field_presence_.IsSet<7>()) {
    Destruct(&v8_value_.value);
  }
  if (field_presence_.IsSet<8>()) {
    Destruct(&v9_value_.value);
  }
  if (field_presence_.IsSet<9>()) {
    Destruct(&v10_value_.value);
  }
  if (field_presence_.IsSet<10>()) {
    Destruct(&v11_value_.value);
  }
  if (field_presence_.IsSet<11>()) {
    Destruct(&v12_value_.value);
  }
  if (field_presence_.IsSet<12>()) {
    Destruct(&v13_value_.value);
  }
  if (field_presence_.IsSet<13>()) {
    Destruct(&v14_value_.value);
  }
  if (field_presence_.IsSet<14>()) {
    Destruct(&v15_value_.value);
  }
  if (field_presence_.IsSet<15>()) {
    Destruct(&v16_value_.value);
  }
  if (field_presence_.IsSet<16>()) {
    Destruct(&v17_value_.value);
  }
  if (field_presence_.IsSet<17>()) {
    Destruct(&v18_value_.value);
  }
  if (field_presence_.IsSet<18>()) {
    Destruct(&v19_value_.value);
  }
  if (field_presence_.IsSet<19>()) {
    Destruct(&v20_value_.value);
  }
  if (field_presence_.IsSet<20>()) {
    Destruct(&v21_value_.value);
  }
  if (field_presence_.IsSet<21>()) {
    Destruct(&v22_value_.value);
  }
  if (field_presence_.IsSet<22>()) {
    Destruct(&v23_value_.value);
  }
  if (field_presence_.IsSet<23>()) {
    Destruct(&v24_value_.value);
  }
  if (field_presence_.IsSet<24>()) {
    Destruct(&v25_value_.value);
  }
  if (field_presence_.IsSet<25>()) {
    Destruct(&v26_value_.value);
  }
  if (field_presence_.IsSet<26>()) {
    Destruct(&v27_value_.value);
  }
  if (field_presence_.IsSet<27>()) {
    Destruct(&v28_value_.value);
  }
  if (field_presence_.IsSet<28>()) {
    Destruct(&v29_value_.value);
  }
  if (field_presence_.IsSet<29>()) {
    Destruct(&v30_value_.value);
  }
  if (field_presence_.IsSet<30>()) {
    Destruct(&v31_value_.value);
  }
  if (field_presence_.IsSet<31>()) {
    Destruct(&v32_value_.value);
  }
  if (field_presence_.IsSet<32>()) {
    Destruct(&v33_value_.value);
  }
  if (field_presence_.IsSet<33>()) {
    Destruct(&v34_value_.value);
  }
  if (field_presence_.IsSet<34>()) {
    Destruct(&v35_value_.value);
  }
  if (field_presence_.IsSet<35>()) {
    Destruct(&v36_value_.value);
  }
  if (field_presence_.IsSet<36>()) {
    Destruct(&v37_value_.value);
  }
  if (field_presence_.IsSet<37>()) {
    Destruct(&v38_value_.value);
  }
  if (field_presence_.IsSet<38>()) {
    Destruct(&v39_value_.value);
  }
  if (field_presence_.IsSet<39>()) {
    Destruct(&v40_value_.value);
  }
  if (field_presence_.IsSet<40>()) {
    Destruct(&v41_value_.value);
  }
  if (field_presence_.IsSet<41>()) {
    Destruct(&v42_value_.value);
  }
  if (field_presence_.IsSet<42>()) {
    Destruct(&v43_value_.value);
  }
  if (field_presence_.IsSet<43>()) {
    Destruct(&v44_value_.value);
  }
  if (field_presence_.IsSet<44>()) {
    Destruct(&v45_value_.value);
  }
  if (field_presence_.IsSet<45>()) {
    Destruct(&v46_value_.value);
  }
  if (field_presence_.IsSet<46>()) {
    Destruct(&v47_value_.value);
  }
  if (field_presence_.IsSet<47>()) {
    Destruct(&v48_value_.value);
  }
  if (field_presence_.IsSet<48>()) {
    Destruct(&v49_value_.value);
  }
  if (field_presence_.IsSet<49>()) {
    Destruct(&v50_value_.value);
  }
  if (field_presence_.IsSet<50>()) {
    Destruct(&v51_value_.value);
  }
  if (field_presence_.IsSet<51>()) {
    Destruct(&v52_value_.value);
  }
  if (field_presence_.IsSet<52>()) {
    Destruct(&v53_value_.value);
  }
  if (field_presence_.IsSet<53>()) {
    Destruct(&v54_value_.value);
  }
  if (field_presence_.IsSet<54>()) {
    Destruct(&v55_value_.value);
  }
  if (field_presence_.IsSet<55>()) {
    Destruct(&v56_value_.value);
  }
  if (field_presence_.IsSet<56>()) {
    Destruct(&v57_value_.value);
  }
  if (field_presence_.IsSet<57>()) {
    Destruct(&v58_value_.value);
  }
  if (field_presence_.IsSet<58>()) {
    Destruct(&v59_value_.value);
  }
  if (field_presence_.IsSet<59>()) {
    Destruct(&v60_value_.value);
  }
  if (field_presence_.IsSet<60>()) {
    Destruct(&v61_value_.value);
  }
  if (field_presence_.IsSet<61>()) {
    Destruct(&v62_value_.value);
  }
  if (field_presence_.IsSet<62>()) {
    Destruct(&v63_value_.value);
  }
  if (field_presence_.IsSet<63>()) {
    Destruct(&v64_value_.value);
  }
}

SixtyFourOrdinalTable& SixtyFourOrdinalTable::operator=(SixtyFourOrdinalTable&& other) {
  if (other.field_presence_.IsSet<0>()) {
    if (field_presence_.IsSet<0>()) {
      v1_value_.value = std::move(other.v1_value_.value);
    } else {
      field_presence_.Set<0>();
      Construct(&v1_value_.value, std::move(other.v1_value_.value));
    }
  } else if (field_presence_.IsSet<0>()) {
    field_presence_.Clear<0>();
    Destruct(&v1_value_.value);
  }
  if (other.field_presence_.IsSet<1>()) {
    if (field_presence_.IsSet<1>()) {
      v2_value_.value = std::move(other.v2_value_.value);
    } else {
      field_presence_.Set<1>();
      Construct(&v2_value_.value, std::move(other.v2_value_.value));
    }
  } else if (field_presence_.IsSet<1>()) {
    field_presence_.Clear<1>();
    Destruct(&v2_value_.value);
  }
  if (other.field_presence_.IsSet<2>()) {
    if (field_presence_.IsSet<2>()) {
      v3_value_.value = std::move(other.v3_value_.value);
    } else {
      field_presence_.Set<2>();
      Construct(&v3_value_.value, std::move(other.v3_value_.value));
    }
  } else if (field_presence_.IsSet<2>()) {
    field_presence_.Clear<2>();
    Destruct(&v3_value_.value);
  }
  if (other.field_presence_.IsSet<3>()) {
    if (field_presence_.IsSet<3>()) {
      v4_value_.value = std::move(other.v4_value_.value);
    } else {
      field_presence_.Set<3>();
      Construct(&v4_value_.value, std::move(other.v4_value_.value));
    }
  } else if (field_presence_.IsSet<3>()) {
    field_presence_.Clear<3>();
    Destruct(&v4_value_.value);
  }
  if (other.field_presence_.IsSet<4>()) {
    if (field_presence_.IsSet<4>()) {
      v5_value_.value = std::move(other.v5_value_.value);
    } else {
      field_presence_.Set<4>();
      Construct(&v5_value_.value, std::move(other.v5_value_.value));
    }
  } else if (field_presence_.IsSet<4>()) {
    field_presence_.Clear<4>();
    Destruct(&v5_value_.value);
  }
  if (other.field_presence_.IsSet<5>()) {
    if (field_presence_.IsSet<5>()) {
      v6_value_.value = std::move(other.v6_value_.value);
    } else {
      field_presence_.Set<5>();
      Construct(&v6_value_.value, std::move(other.v6_value_.value));
    }
  } else if (field_presence_.IsSet<5>()) {
    field_presence_.Clear<5>();
    Destruct(&v6_value_.value);
  }
  if (other.field_presence_.IsSet<6>()) {
    if (field_presence_.IsSet<6>()) {
      v7_value_.value = std::move(other.v7_value_.value);
    } else {
      field_presence_.Set<6>();
      Construct(&v7_value_.value, std::move(other.v7_value_.value));
    }
  } else if (field_presence_.IsSet<6>()) {
    field_presence_.Clear<6>();
    Destruct(&v7_value_.value);
  }
  if (other.field_presence_.IsSet<7>()) {
    if (field_presence_.IsSet<7>()) {
      v8_value_.value = std::move(other.v8_value_.value);
    } else {
      field_presence_.Set<7>();
      Construct(&v8_value_.value, std::move(other.v8_value_.value));
    }
  } else if (field_presence_.IsSet<7>()) {
    field_presence_.Clear<7>();
    Destruct(&v8_value_.value);
  }
  if (other.field_presence_.IsSet<8>()) {
    if (field_presence_.IsSet<8>()) {
      v9_value_.value = std::move(other.v9_value_.value);
    } else {
      field_presence_.Set<8>();
      Construct(&v9_value_.value, std::move(other.v9_value_.value));
    }
  } else if (field_presence_.IsSet<8>()) {
    field_presence_.Clear<8>();
    Destruct(&v9_value_.value);
  }
  if (other.field_presence_.IsSet<9>()) {
    if (field_presence_.IsSet<9>()) {
      v10_value_.value = std::move(other.v10_value_.value);
    } else {
      field_presence_.Set<9>();
      Construct(&v10_value_.value, std::move(other.v10_value_.value));
    }
  } else if (field_presence_.IsSet<9>()) {
    field_presence_.Clear<9>();
    Destruct(&v10_value_.value);
  }
  if (other.field_presence_.IsSet<10>()) {
    if (field_presence_.IsSet<10>()) {
      v11_value_.value = std::move(other.v11_value_.value);
    } else {
      field_presence_.Set<10>();
      Construct(&v11_value_.value, std::move(other.v11_value_.value));
    }
  } else if (field_presence_.IsSet<10>()) {
    field_presence_.Clear<10>();
    Destruct(&v11_value_.value);
  }
  if (other.field_presence_.IsSet<11>()) {
    if (field_presence_.IsSet<11>()) {
      v12_value_.value = std::move(other.v12_value_.value);
    } else {
      field_presence_.Set<11>();
      Construct(&v12_value_.value, std::move(other.v12_value_.value));
    }
  } else if (field_presence_.IsSet<11>()) {
    field_presence_.Clear<11>();
    Destruct(&v12_value_.value);
  }
  if (other.field_presence_.IsSet<12>()) {
    if (field_presence_.IsSet<12>()) {
      v13_value_.value = std::move(other.v13_value_.value);
    } else {
      field_presence_.Set<12>();
      Construct(&v13_value_.value, std::move(other.v13_value_.value));
    }
  } else if (field_presence_.IsSet<12>()) {
    field_presence_.Clear<12>();
    Destruct(&v13_value_.value);
  }
  if (other.field_presence_.IsSet<13>()) {
    if (field_presence_.IsSet<13>()) {
      v14_value_.value = std::move(other.v14_value_.value);
    } else {
      field_presence_.Set<13>();
      Construct(&v14_value_.value, std::move(other.v14_value_.value));
    }
  } else if (field_presence_.IsSet<13>()) {
    field_presence_.Clear<13>();
    Destruct(&v14_value_.value);
  }
  if (other.field_presence_.IsSet<14>()) {
    if (field_presence_.IsSet<14>()) {
      v15_value_.value = std::move(other.v15_value_.value);
    } else {
      field_presence_.Set<14>();
      Construct(&v15_value_.value, std::move(other.v15_value_.value));
    }
  } else if (field_presence_.IsSet<14>()) {
    field_presence_.Clear<14>();
    Destruct(&v15_value_.value);
  }
  if (other.field_presence_.IsSet<15>()) {
    if (field_presence_.IsSet<15>()) {
      v16_value_.value = std::move(other.v16_value_.value);
    } else {
      field_presence_.Set<15>();
      Construct(&v16_value_.value, std::move(other.v16_value_.value));
    }
  } else if (field_presence_.IsSet<15>()) {
    field_presence_.Clear<15>();
    Destruct(&v16_value_.value);
  }
  if (other.field_presence_.IsSet<16>()) {
    if (field_presence_.IsSet<16>()) {
      v17_value_.value = std::move(other.v17_value_.value);
    } else {
      field_presence_.Set<16>();
      Construct(&v17_value_.value, std::move(other.v17_value_.value));
    }
  } else if (field_presence_.IsSet<16>()) {
    field_presence_.Clear<16>();
    Destruct(&v17_value_.value);
  }
  if (other.field_presence_.IsSet<17>()) {
    if (field_presence_.IsSet<17>()) {
      v18_value_.value = std::move(other.v18_value_.value);
    } else {
      field_presence_.Set<17>();
      Construct(&v18_value_.value, std::move(other.v18_value_.value));
    }
  } else if (field_presence_.IsSet<17>()) {
    field_presence_.Clear<17>();
    Destruct(&v18_value_.value);
  }
  if (other.field_presence_.IsSet<18>()) {
    if (field_presence_.IsSet<18>()) {
      v19_value_.value = std::move(other.v19_value_.value);
    } else {
      field_presence_.Set<18>();
      Construct(&v19_value_.value, std::move(other.v19_value_.value));
    }
  } else if (field_presence_.IsSet<18>()) {
    field_presence_.Clear<18>();
    Destruct(&v19_value_.value);
  }
  if (other.field_presence_.IsSet<19>()) {
    if (field_presence_.IsSet<19>()) {
      v20_value_.value = std::move(other.v20_value_.value);
    } else {
      field_presence_.Set<19>();
      Construct(&v20_value_.value, std::move(other.v20_value_.value));
    }
  } else if (field_presence_.IsSet<19>()) {
    field_presence_.Clear<19>();
    Destruct(&v20_value_.value);
  }
  if (other.field_presence_.IsSet<20>()) {
    if (field_presence_.IsSet<20>()) {
      v21_value_.value = std::move(other.v21_value_.value);
    } else {
      field_presence_.Set<20>();
      Construct(&v21_value_.value, std::move(other.v21_value_.value));
    }
  } else if (field_presence_.IsSet<20>()) {
    field_presence_.Clear<20>();
    Destruct(&v21_value_.value);
  }
  if (other.field_presence_.IsSet<21>()) {
    if (field_presence_.IsSet<21>()) {
      v22_value_.value = std::move(other.v22_value_.value);
    } else {
      field_presence_.Set<21>();
      Construct(&v22_value_.value, std::move(other.v22_value_.value));
    }
  } else if (field_presence_.IsSet<21>()) {
    field_presence_.Clear<21>();
    Destruct(&v22_value_.value);
  }
  if (other.field_presence_.IsSet<22>()) {
    if (field_presence_.IsSet<22>()) {
      v23_value_.value = std::move(other.v23_value_.value);
    } else {
      field_presence_.Set<22>();
      Construct(&v23_value_.value, std::move(other.v23_value_.value));
    }
  } else if (field_presence_.IsSet<22>()) {
    field_presence_.Clear<22>();
    Destruct(&v23_value_.value);
  }
  if (other.field_presence_.IsSet<23>()) {
    if (field_presence_.IsSet<23>()) {
      v24_value_.value = std::move(other.v24_value_.value);
    } else {
      field_presence_.Set<23>();
      Construct(&v24_value_.value, std::move(other.v24_value_.value));
    }
  } else if (field_presence_.IsSet<23>()) {
    field_presence_.Clear<23>();
    Destruct(&v24_value_.value);
  }
  if (other.field_presence_.IsSet<24>()) {
    if (field_presence_.IsSet<24>()) {
      v25_value_.value = std::move(other.v25_value_.value);
    } else {
      field_presence_.Set<24>();
      Construct(&v25_value_.value, std::move(other.v25_value_.value));
    }
  } else if (field_presence_.IsSet<24>()) {
    field_presence_.Clear<24>();
    Destruct(&v25_value_.value);
  }
  if (other.field_presence_.IsSet<25>()) {
    if (field_presence_.IsSet<25>()) {
      v26_value_.value = std::move(other.v26_value_.value);
    } else {
      field_presence_.Set<25>();
      Construct(&v26_value_.value, std::move(other.v26_value_.value));
    }
  } else if (field_presence_.IsSet<25>()) {
    field_presence_.Clear<25>();
    Destruct(&v26_value_.value);
  }
  if (other.field_presence_.IsSet<26>()) {
    if (field_presence_.IsSet<26>()) {
      v27_value_.value = std::move(other.v27_value_.value);
    } else {
      field_presence_.Set<26>();
      Construct(&v27_value_.value, std::move(other.v27_value_.value));
    }
  } else if (field_presence_.IsSet<26>()) {
    field_presence_.Clear<26>();
    Destruct(&v27_value_.value);
  }
  if (other.field_presence_.IsSet<27>()) {
    if (field_presence_.IsSet<27>()) {
      v28_value_.value = std::move(other.v28_value_.value);
    } else {
      field_presence_.Set<27>();
      Construct(&v28_value_.value, std::move(other.v28_value_.value));
    }
  } else if (field_presence_.IsSet<27>()) {
    field_presence_.Clear<27>();
    Destruct(&v28_value_.value);
  }
  if (other.field_presence_.IsSet<28>()) {
    if (field_presence_.IsSet<28>()) {
      v29_value_.value = std::move(other.v29_value_.value);
    } else {
      field_presence_.Set<28>();
      Construct(&v29_value_.value, std::move(other.v29_value_.value));
    }
  } else if (field_presence_.IsSet<28>()) {
    field_presence_.Clear<28>();
    Destruct(&v29_value_.value);
  }
  if (other.field_presence_.IsSet<29>()) {
    if (field_presence_.IsSet<29>()) {
      v30_value_.value = std::move(other.v30_value_.value);
    } else {
      field_presence_.Set<29>();
      Construct(&v30_value_.value, std::move(other.v30_value_.value));
    }
  } else if (field_presence_.IsSet<29>()) {
    field_presence_.Clear<29>();
    Destruct(&v30_value_.value);
  }
  if (other.field_presence_.IsSet<30>()) {
    if (field_presence_.IsSet<30>()) {
      v31_value_.value = std::move(other.v31_value_.value);
    } else {
      field_presence_.Set<30>();
      Construct(&v31_value_.value, std::move(other.v31_value_.value));
    }
  } else if (field_presence_.IsSet<30>()) {
    field_presence_.Clear<30>();
    Destruct(&v31_value_.value);
  }
  if (other.field_presence_.IsSet<31>()) {
    if (field_presence_.IsSet<31>()) {
      v32_value_.value = std::move(other.v32_value_.value);
    } else {
      field_presence_.Set<31>();
      Construct(&v32_value_.value, std::move(other.v32_value_.value));
    }
  } else if (field_presence_.IsSet<31>()) {
    field_presence_.Clear<31>();
    Destruct(&v32_value_.value);
  }
  if (other.field_presence_.IsSet<32>()) {
    if (field_presence_.IsSet<32>()) {
      v33_value_.value = std::move(other.v33_value_.value);
    } else {
      field_presence_.Set<32>();
      Construct(&v33_value_.value, std::move(other.v33_value_.value));
    }
  } else if (field_presence_.IsSet<32>()) {
    field_presence_.Clear<32>();
    Destruct(&v33_value_.value);
  }
  if (other.field_presence_.IsSet<33>()) {
    if (field_presence_.IsSet<33>()) {
      v34_value_.value = std::move(other.v34_value_.value);
    } else {
      field_presence_.Set<33>();
      Construct(&v34_value_.value, std::move(other.v34_value_.value));
    }
  } else if (field_presence_.IsSet<33>()) {
    field_presence_.Clear<33>();
    Destruct(&v34_value_.value);
  }
  if (other.field_presence_.IsSet<34>()) {
    if (field_presence_.IsSet<34>()) {
      v35_value_.value = std::move(other.v35_value_.value);
    } else {
      field_presence_.Set<34>();
      Construct(&v35_value_.value, std::move(other.v35_value_.value));
    }
  } else if (field_presence_.IsSet<34>()) {
    field_presence_.Clear<34>();
    Destruct(&v35_value_.value);
  }
  if (other.field_presence_.IsSet<35>()) {
    if (field_presence_.IsSet<35>()) {
      v36_value_.value = std::move(other.v36_value_.value);
    } else {
      field_presence_.Set<35>();
      Construct(&v36_value_.value, std::move(other.v36_value_.value));
    }
  } else if (field_presence_.IsSet<35>()) {
    field_presence_.Clear<35>();
    Destruct(&v36_value_.value);
  }
  if (other.field_presence_.IsSet<36>()) {
    if (field_presence_.IsSet<36>()) {
      v37_value_.value = std::move(other.v37_value_.value);
    } else {
      field_presence_.Set<36>();
      Construct(&v37_value_.value, std::move(other.v37_value_.value));
    }
  } else if (field_presence_.IsSet<36>()) {
    field_presence_.Clear<36>();
    Destruct(&v37_value_.value);
  }
  if (other.field_presence_.IsSet<37>()) {
    if (field_presence_.IsSet<37>()) {
      v38_value_.value = std::move(other.v38_value_.value);
    } else {
      field_presence_.Set<37>();
      Construct(&v38_value_.value, std::move(other.v38_value_.value));
    }
  } else if (field_presence_.IsSet<37>()) {
    field_presence_.Clear<37>();
    Destruct(&v38_value_.value);
  }
  if (other.field_presence_.IsSet<38>()) {
    if (field_presence_.IsSet<38>()) {
      v39_value_.value = std::move(other.v39_value_.value);
    } else {
      field_presence_.Set<38>();
      Construct(&v39_value_.value, std::move(other.v39_value_.value));
    }
  } else if (field_presence_.IsSet<38>()) {
    field_presence_.Clear<38>();
    Destruct(&v39_value_.value);
  }
  if (other.field_presence_.IsSet<39>()) {
    if (field_presence_.IsSet<39>()) {
      v40_value_.value = std::move(other.v40_value_.value);
    } else {
      field_presence_.Set<39>();
      Construct(&v40_value_.value, std::move(other.v40_value_.value));
    }
  } else if (field_presence_.IsSet<39>()) {
    field_presence_.Clear<39>();
    Destruct(&v40_value_.value);
  }
  if (other.field_presence_.IsSet<40>()) {
    if (field_presence_.IsSet<40>()) {
      v41_value_.value = std::move(other.v41_value_.value);
    } else {
      field_presence_.Set<40>();
      Construct(&v41_value_.value, std::move(other.v41_value_.value));
    }
  } else if (field_presence_.IsSet<40>()) {
    field_presence_.Clear<40>();
    Destruct(&v41_value_.value);
  }
  if (other.field_presence_.IsSet<41>()) {
    if (field_presence_.IsSet<41>()) {
      v42_value_.value = std::move(other.v42_value_.value);
    } else {
      field_presence_.Set<41>();
      Construct(&v42_value_.value, std::move(other.v42_value_.value));
    }
  } else if (field_presence_.IsSet<41>()) {
    field_presence_.Clear<41>();
    Destruct(&v42_value_.value);
  }
  if (other.field_presence_.IsSet<42>()) {
    if (field_presence_.IsSet<42>()) {
      v43_value_.value = std::move(other.v43_value_.value);
    } else {
      field_presence_.Set<42>();
      Construct(&v43_value_.value, std::move(other.v43_value_.value));
    }
  } else if (field_presence_.IsSet<42>()) {
    field_presence_.Clear<42>();
    Destruct(&v43_value_.value);
  }
  if (other.field_presence_.IsSet<43>()) {
    if (field_presence_.IsSet<43>()) {
      v44_value_.value = std::move(other.v44_value_.value);
    } else {
      field_presence_.Set<43>();
      Construct(&v44_value_.value, std::move(other.v44_value_.value));
    }
  } else if (field_presence_.IsSet<43>()) {
    field_presence_.Clear<43>();
    Destruct(&v44_value_.value);
  }
  if (other.field_presence_.IsSet<44>()) {
    if (field_presence_.IsSet<44>()) {
      v45_value_.value = std::move(other.v45_value_.value);
    } else {
      field_presence_.Set<44>();
      Construct(&v45_value_.value, std::move(other.v45_value_.value));
    }
  } else if (field_presence_.IsSet<44>()) {
    field_presence_.Clear<44>();
    Destruct(&v45_value_.value);
  }
  if (other.field_presence_.IsSet<45>()) {
    if (field_presence_.IsSet<45>()) {
      v46_value_.value = std::move(other.v46_value_.value);
    } else {
      field_presence_.Set<45>();
      Construct(&v46_value_.value, std::move(other.v46_value_.value));
    }
  } else if (field_presence_.IsSet<45>()) {
    field_presence_.Clear<45>();
    Destruct(&v46_value_.value);
  }
  if (other.field_presence_.IsSet<46>()) {
    if (field_presence_.IsSet<46>()) {
      v47_value_.value = std::move(other.v47_value_.value);
    } else {
      field_presence_.Set<46>();
      Construct(&v47_value_.value, std::move(other.v47_value_.value));
    }
  } else if (field_presence_.IsSet<46>()) {
    field_presence_.Clear<46>();
    Destruct(&v47_value_.value);
  }
  if (other.field_presence_.IsSet<47>()) {
    if (field_presence_.IsSet<47>()) {
      v48_value_.value = std::move(other.v48_value_.value);
    } else {
      field_presence_.Set<47>();
      Construct(&v48_value_.value, std::move(other.v48_value_.value));
    }
  } else if (field_presence_.IsSet<47>()) {
    field_presence_.Clear<47>();
    Destruct(&v48_value_.value);
  }
  if (other.field_presence_.IsSet<48>()) {
    if (field_presence_.IsSet<48>()) {
      v49_value_.value = std::move(other.v49_value_.value);
    } else {
      field_presence_.Set<48>();
      Construct(&v49_value_.value, std::move(other.v49_value_.value));
    }
  } else if (field_presence_.IsSet<48>()) {
    field_presence_.Clear<48>();
    Destruct(&v49_value_.value);
  }
  if (other.field_presence_.IsSet<49>()) {
    if (field_presence_.IsSet<49>()) {
      v50_value_.value = std::move(other.v50_value_.value);
    } else {
      field_presence_.Set<49>();
      Construct(&v50_value_.value, std::move(other.v50_value_.value));
    }
  } else if (field_presence_.IsSet<49>()) {
    field_presence_.Clear<49>();
    Destruct(&v50_value_.value);
  }
  if (other.field_presence_.IsSet<50>()) {
    if (field_presence_.IsSet<50>()) {
      v51_value_.value = std::move(other.v51_value_.value);
    } else {
      field_presence_.Set<50>();
      Construct(&v51_value_.value, std::move(other.v51_value_.value));
    }
  } else if (field_presence_.IsSet<50>()) {
    field_presence_.Clear<50>();
    Destruct(&v51_value_.value);
  }
  if (other.field_presence_.IsSet<51>()) {
    if (field_presence_.IsSet<51>()) {
      v52_value_.value = std::move(other.v52_value_.value);
    } else {
      field_presence_.Set<51>();
      Construct(&v52_value_.value, std::move(other.v52_value_.value));
    }
  } else if (field_presence_.IsSet<51>()) {
    field_presence_.Clear<51>();
    Destruct(&v52_value_.value);
  }
  if (other.field_presence_.IsSet<52>()) {
    if (field_presence_.IsSet<52>()) {
      v53_value_.value = std::move(other.v53_value_.value);
    } else {
      field_presence_.Set<52>();
      Construct(&v53_value_.value, std::move(other.v53_value_.value));
    }
  } else if (field_presence_.IsSet<52>()) {
    field_presence_.Clear<52>();
    Destruct(&v53_value_.value);
  }
  if (other.field_presence_.IsSet<53>()) {
    if (field_presence_.IsSet<53>()) {
      v54_value_.value = std::move(other.v54_value_.value);
    } else {
      field_presence_.Set<53>();
      Construct(&v54_value_.value, std::move(other.v54_value_.value));
    }
  } else if (field_presence_.IsSet<53>()) {
    field_presence_.Clear<53>();
    Destruct(&v54_value_.value);
  }
  if (other.field_presence_.IsSet<54>()) {
    if (field_presence_.IsSet<54>()) {
      v55_value_.value = std::move(other.v55_value_.value);
    } else {
      field_presence_.Set<54>();
      Construct(&v55_value_.value, std::move(other.v55_value_.value));
    }
  } else if (field_presence_.IsSet<54>()) {
    field_presence_.Clear<54>();
    Destruct(&v55_value_.value);
  }
  if (other.field_presence_.IsSet<55>()) {
    if (field_presence_.IsSet<55>()) {
      v56_value_.value = std::move(other.v56_value_.value);
    } else {
      field_presence_.Set<55>();
      Construct(&v56_value_.value, std::move(other.v56_value_.value));
    }
  } else if (field_presence_.IsSet<55>()) {
    field_presence_.Clear<55>();
    Destruct(&v56_value_.value);
  }
  if (other.field_presence_.IsSet<56>()) {
    if (field_presence_.IsSet<56>()) {
      v57_value_.value = std::move(other.v57_value_.value);
    } else {
      field_presence_.Set<56>();
      Construct(&v57_value_.value, std::move(other.v57_value_.value));
    }
  } else if (field_presence_.IsSet<56>()) {
    field_presence_.Clear<56>();
    Destruct(&v57_value_.value);
  }
  if (other.field_presence_.IsSet<57>()) {
    if (field_presence_.IsSet<57>()) {
      v58_value_.value = std::move(other.v58_value_.value);
    } else {
      field_presence_.Set<57>();
      Construct(&v58_value_.value, std::move(other.v58_value_.value));
    }
  } else if (field_presence_.IsSet<57>()) {
    field_presence_.Clear<57>();
    Destruct(&v58_value_.value);
  }
  if (other.field_presence_.IsSet<58>()) {
    if (field_presence_.IsSet<58>()) {
      v59_value_.value = std::move(other.v59_value_.value);
    } else {
      field_presence_.Set<58>();
      Construct(&v59_value_.value, std::move(other.v59_value_.value));
    }
  } else if (field_presence_.IsSet<58>()) {
    field_presence_.Clear<58>();
    Destruct(&v59_value_.value);
  }
  if (other.field_presence_.IsSet<59>()) {
    if (field_presence_.IsSet<59>()) {
      v60_value_.value = std::move(other.v60_value_.value);
    } else {
      field_presence_.Set<59>();
      Construct(&v60_value_.value, std::move(other.v60_value_.value));
    }
  } else if (field_presence_.IsSet<59>()) {
    field_presence_.Clear<59>();
    Destruct(&v60_value_.value);
  }
  if (other.field_presence_.IsSet<60>()) {
    if (field_presence_.IsSet<60>()) {
      v61_value_.value = std::move(other.v61_value_.value);
    } else {
      field_presence_.Set<60>();
      Construct(&v61_value_.value, std::move(other.v61_value_.value));
    }
  } else if (field_presence_.IsSet<60>()) {
    field_presence_.Clear<60>();
    Destruct(&v61_value_.value);
  }
  if (other.field_presence_.IsSet<61>()) {
    if (field_presence_.IsSet<61>()) {
      v62_value_.value = std::move(other.v62_value_.value);
    } else {
      field_presence_.Set<61>();
      Construct(&v62_value_.value, std::move(other.v62_value_.value));
    }
  } else if (field_presence_.IsSet<61>()) {
    field_presence_.Clear<61>();
    Destruct(&v62_value_.value);
  }
  if (other.field_presence_.IsSet<62>()) {
    if (field_presence_.IsSet<62>()) {
      v63_value_.value = std::move(other.v63_value_.value);
    } else {
      field_presence_.Set<62>();
      Construct(&v63_value_.value, std::move(other.v63_value_.value));
    }
  } else if (field_presence_.IsSet<62>()) {
    field_presence_.Clear<62>();
    Destruct(&v63_value_.value);
  }
  if (other.field_presence_.IsSet<63>()) {
    if (field_presence_.IsSet<63>()) {
      v64_value_.value = std::move(other.v64_value_.value);
    } else {
      field_presence_.Set<63>();
      Construct(&v64_value_.value, std::move(other.v64_value_.value));
    }
  } else if (field_presence_.IsSet<63>()) {
    field_presence_.Clear<63>();
    Destruct(&v64_value_.value);
  }
  return *this;
}

bool SixtyFourOrdinalTable::IsEmpty() const {
  return field_presence_.IsEmpty();
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v1(int64_t _value) {
  if (!field_presence_.IsSet<0>()) {
    field_presence_.Set<0>();
    Construct(&v1_value_.value, std::move(_value));
  } else {
    v1_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v2(int64_t _value) {
  if (!field_presence_.IsSet<1>()) {
    field_presence_.Set<1>();
    Construct(&v2_value_.value, std::move(_value));
  } else {
    v2_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v3(int64_t _value) {
  if (!field_presence_.IsSet<2>()) {
    field_presence_.Set<2>();
    Construct(&v3_value_.value, std::move(_value));
  } else {
    v3_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v4(int64_t _value) {
  if (!field_presence_.IsSet<3>()) {
    field_presence_.Set<3>();
    Construct(&v4_value_.value, std::move(_value));
  } else {
    v4_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v5(int64_t _value) {
  if (!field_presence_.IsSet<4>()) {
    field_presence_.Set<4>();
    Construct(&v5_value_.value, std::move(_value));
  } else {
    v5_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v6(int64_t _value) {
  if (!field_presence_.IsSet<5>()) {
    field_presence_.Set<5>();
    Construct(&v6_value_.value, std::move(_value));
  } else {
    v6_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v7(int64_t _value) {
  if (!field_presence_.IsSet<6>()) {
    field_presence_.Set<6>();
    Construct(&v7_value_.value, std::move(_value));
  } else {
    v7_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v8(int64_t _value) {
  if (!field_presence_.IsSet<7>()) {
    field_presence_.Set<7>();
    Construct(&v8_value_.value, std::move(_value));
  } else {
    v8_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v9(int64_t _value) {
  if (!field_presence_.IsSet<8>()) {
    field_presence_.Set<8>();
    Construct(&v9_value_.value, std::move(_value));
  } else {
    v9_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v10(int64_t _value) {
  if (!field_presence_.IsSet<9>()) {
    field_presence_.Set<9>();
    Construct(&v10_value_.value, std::move(_value));
  } else {
    v10_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v11(int64_t _value) {
  if (!field_presence_.IsSet<10>()) {
    field_presence_.Set<10>();
    Construct(&v11_value_.value, std::move(_value));
  } else {
    v11_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v12(int64_t _value) {
  if (!field_presence_.IsSet<11>()) {
    field_presence_.Set<11>();
    Construct(&v12_value_.value, std::move(_value));
  } else {
    v12_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v13(int64_t _value) {
  if (!field_presence_.IsSet<12>()) {
    field_presence_.Set<12>();
    Construct(&v13_value_.value, std::move(_value));
  } else {
    v13_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v14(int64_t _value) {
  if (!field_presence_.IsSet<13>()) {
    field_presence_.Set<13>();
    Construct(&v14_value_.value, std::move(_value));
  } else {
    v14_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v15(int64_t _value) {
  if (!field_presence_.IsSet<14>()) {
    field_presence_.Set<14>();
    Construct(&v15_value_.value, std::move(_value));
  } else {
    v15_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v16(int64_t _value) {
  if (!field_presence_.IsSet<15>()) {
    field_presence_.Set<15>();
    Construct(&v16_value_.value, std::move(_value));
  } else {
    v16_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v17(int64_t _value) {
  if (!field_presence_.IsSet<16>()) {
    field_presence_.Set<16>();
    Construct(&v17_value_.value, std::move(_value));
  } else {
    v17_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v18(int64_t _value) {
  if (!field_presence_.IsSet<17>()) {
    field_presence_.Set<17>();
    Construct(&v18_value_.value, std::move(_value));
  } else {
    v18_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v19(int64_t _value) {
  if (!field_presence_.IsSet<18>()) {
    field_presence_.Set<18>();
    Construct(&v19_value_.value, std::move(_value));
  } else {
    v19_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v20(int64_t _value) {
  if (!field_presence_.IsSet<19>()) {
    field_presence_.Set<19>();
    Construct(&v20_value_.value, std::move(_value));
  } else {
    v20_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v21(int64_t _value) {
  if (!field_presence_.IsSet<20>()) {
    field_presence_.Set<20>();
    Construct(&v21_value_.value, std::move(_value));
  } else {
    v21_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v22(int64_t _value) {
  if (!field_presence_.IsSet<21>()) {
    field_presence_.Set<21>();
    Construct(&v22_value_.value, std::move(_value));
  } else {
    v22_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v23(int64_t _value) {
  if (!field_presence_.IsSet<22>()) {
    field_presence_.Set<22>();
    Construct(&v23_value_.value, std::move(_value));
  } else {
    v23_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v24(int64_t _value) {
  if (!field_presence_.IsSet<23>()) {
    field_presence_.Set<23>();
    Construct(&v24_value_.value, std::move(_value));
  } else {
    v24_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v25(int64_t _value) {
  if (!field_presence_.IsSet<24>()) {
    field_presence_.Set<24>();
    Construct(&v25_value_.value, std::move(_value));
  } else {
    v25_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v26(int64_t _value) {
  if (!field_presence_.IsSet<25>()) {
    field_presence_.Set<25>();
    Construct(&v26_value_.value, std::move(_value));
  } else {
    v26_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v27(int64_t _value) {
  if (!field_presence_.IsSet<26>()) {
    field_presence_.Set<26>();
    Construct(&v27_value_.value, std::move(_value));
  } else {
    v27_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v28(int64_t _value) {
  if (!field_presence_.IsSet<27>()) {
    field_presence_.Set<27>();
    Construct(&v28_value_.value, std::move(_value));
  } else {
    v28_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v29(int64_t _value) {
  if (!field_presence_.IsSet<28>()) {
    field_presence_.Set<28>();
    Construct(&v29_value_.value, std::move(_value));
  } else {
    v29_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v30(int64_t _value) {
  if (!field_presence_.IsSet<29>()) {
    field_presence_.Set<29>();
    Construct(&v30_value_.value, std::move(_value));
  } else {
    v30_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v31(int64_t _value) {
  if (!field_presence_.IsSet<30>()) {
    field_presence_.Set<30>();
    Construct(&v31_value_.value, std::move(_value));
  } else {
    v31_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v32(int64_t _value) {
  if (!field_presence_.IsSet<31>()) {
    field_presence_.Set<31>();
    Construct(&v32_value_.value, std::move(_value));
  } else {
    v32_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v33(int64_t _value) {
  if (!field_presence_.IsSet<32>()) {
    field_presence_.Set<32>();
    Construct(&v33_value_.value, std::move(_value));
  } else {
    v33_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v34(int64_t _value) {
  if (!field_presence_.IsSet<33>()) {
    field_presence_.Set<33>();
    Construct(&v34_value_.value, std::move(_value));
  } else {
    v34_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v35(int64_t _value) {
  if (!field_presence_.IsSet<34>()) {
    field_presence_.Set<34>();
    Construct(&v35_value_.value, std::move(_value));
  } else {
    v35_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v36(int64_t _value) {
  if (!field_presence_.IsSet<35>()) {
    field_presence_.Set<35>();
    Construct(&v36_value_.value, std::move(_value));
  } else {
    v36_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v37(int64_t _value) {
  if (!field_presence_.IsSet<36>()) {
    field_presence_.Set<36>();
    Construct(&v37_value_.value, std::move(_value));
  } else {
    v37_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v38(int64_t _value) {
  if (!field_presence_.IsSet<37>()) {
    field_presence_.Set<37>();
    Construct(&v38_value_.value, std::move(_value));
  } else {
    v38_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v39(int64_t _value) {
  if (!field_presence_.IsSet<38>()) {
    field_presence_.Set<38>();
    Construct(&v39_value_.value, std::move(_value));
  } else {
    v39_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v40(int64_t _value) {
  if (!field_presence_.IsSet<39>()) {
    field_presence_.Set<39>();
    Construct(&v40_value_.value, std::move(_value));
  } else {
    v40_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v41(int64_t _value) {
  if (!field_presence_.IsSet<40>()) {
    field_presence_.Set<40>();
    Construct(&v41_value_.value, std::move(_value));
  } else {
    v41_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v42(int64_t _value) {
  if (!field_presence_.IsSet<41>()) {
    field_presence_.Set<41>();
    Construct(&v42_value_.value, std::move(_value));
  } else {
    v42_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v43(int64_t _value) {
  if (!field_presence_.IsSet<42>()) {
    field_presence_.Set<42>();
    Construct(&v43_value_.value, std::move(_value));
  } else {
    v43_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v44(int64_t _value) {
  if (!field_presence_.IsSet<43>()) {
    field_presence_.Set<43>();
    Construct(&v44_value_.value, std::move(_value));
  } else {
    v44_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v45(int64_t _value) {
  if (!field_presence_.IsSet<44>()) {
    field_presence_.Set<44>();
    Construct(&v45_value_.value, std::move(_value));
  } else {
    v45_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v46(int64_t _value) {
  if (!field_presence_.IsSet<45>()) {
    field_presence_.Set<45>();
    Construct(&v46_value_.value, std::move(_value));
  } else {
    v46_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v47(int64_t _value) {
  if (!field_presence_.IsSet<46>()) {
    field_presence_.Set<46>();
    Construct(&v47_value_.value, std::move(_value));
  } else {
    v47_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v48(int64_t _value) {
  if (!field_presence_.IsSet<47>()) {
    field_presence_.Set<47>();
    Construct(&v48_value_.value, std::move(_value));
  } else {
    v48_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v49(int64_t _value) {
  if (!field_presence_.IsSet<48>()) {
    field_presence_.Set<48>();
    Construct(&v49_value_.value, std::move(_value));
  } else {
    v49_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v50(int64_t _value) {
  if (!field_presence_.IsSet<49>()) {
    field_presence_.Set<49>();
    Construct(&v50_value_.value, std::move(_value));
  } else {
    v50_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v51(int64_t _value) {
  if (!field_presence_.IsSet<50>()) {
    field_presence_.Set<50>();
    Construct(&v51_value_.value, std::move(_value));
  } else {
    v51_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v52(int64_t _value) {
  if (!field_presence_.IsSet<51>()) {
    field_presence_.Set<51>();
    Construct(&v52_value_.value, std::move(_value));
  } else {
    v52_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v53(int64_t _value) {
  if (!field_presence_.IsSet<52>()) {
    field_presence_.Set<52>();
    Construct(&v53_value_.value, std::move(_value));
  } else {
    v53_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v54(int64_t _value) {
  if (!field_presence_.IsSet<53>()) {
    field_presence_.Set<53>();
    Construct(&v54_value_.value, std::move(_value));
  } else {
    v54_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v55(int64_t _value) {
  if (!field_presence_.IsSet<54>()) {
    field_presence_.Set<54>();
    Construct(&v55_value_.value, std::move(_value));
  } else {
    v55_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v56(int64_t _value) {
  if (!field_presence_.IsSet<55>()) {
    field_presence_.Set<55>();
    Construct(&v56_value_.value, std::move(_value));
  } else {
    v56_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v57(int64_t _value) {
  if (!field_presence_.IsSet<56>()) {
    field_presence_.Set<56>();
    Construct(&v57_value_.value, std::move(_value));
  } else {
    v57_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v58(int64_t _value) {
  if (!field_presence_.IsSet<57>()) {
    field_presence_.Set<57>();
    Construct(&v58_value_.value, std::move(_value));
  } else {
    v58_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v59(int64_t _value) {
  if (!field_presence_.IsSet<58>()) {
    field_presence_.Set<58>();
    Construct(&v59_value_.value, std::move(_value));
  } else {
    v59_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v60(int64_t _value) {
  if (!field_presence_.IsSet<59>()) {
    field_presence_.Set<59>();
    Construct(&v60_value_.value, std::move(_value));
  } else {
    v60_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v61(int64_t _value) {
  if (!field_presence_.IsSet<60>()) {
    field_presence_.Set<60>();
    Construct(&v61_value_.value, std::move(_value));
  } else {
    v61_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v62(int64_t _value) {
  if (!field_presence_.IsSet<61>()) {
    field_presence_.Set<61>();
    Construct(&v62_value_.value, std::move(_value));
  } else {
    v62_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v63(int64_t _value) {
  if (!field_presence_.IsSet<62>()) {
    field_presence_.Set<62>();
    Construct(&v63_value_.value, std::move(_value));
  } else {
    v63_value_.value = std::move(_value);
  }
  return *this;
}
SixtyFourOrdinalTable& SixtyFourOrdinalTable::set_v64(::test::table::ExtensionTable _value) {
  if (!field_presence_.IsSet<63>()) {
    field_presence_.Set<63>();
    Construct(&v64_value_.value, std::move(_value));
  } else {
    v64_value_.value = std::move(_value);
  }
  return *this;
}

void SixtyFourOrdinalTable::Encode(::fidl::Encoder* _encoder, size_t _offset,
                         cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  size_t max_ordinal = MaxOrdinal();
  ::fidl::EncodeVectorPointer(_encoder, max_ordinal, _offset);
  if (max_ordinal == 0) return;
  [[maybe_unused]] size_t base = _encoder->Alloc(max_ordinal * sizeof(fidl_envelope_v2_t));
  if (field_presence_.IsSet<0>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v1_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v1_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<1>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (2 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v2_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v2_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<2>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (3 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v3_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v3_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<3>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (4 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v4_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v4_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<4>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (5 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v5_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v5_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<5>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (6 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v6_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v6_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<6>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (7 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v7_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v7_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<7>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (8 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v8_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v8_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<8>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (9 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v9_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v9_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<9>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (10 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v10_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v10_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<10>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (11 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v11_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v11_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<11>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (12 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v12_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v12_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<12>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (13 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v13_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v13_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<13>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (14 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v14_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v14_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<14>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (15 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v15_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v15_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<15>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (16 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v16_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v16_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<16>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (17 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v17_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v17_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<17>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (18 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v18_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v18_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<18>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (19 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v19_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v19_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<19>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (20 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v20_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v20_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<20>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (21 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v21_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v21_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<21>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (22 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v22_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v22_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<22>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (23 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v23_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v23_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<23>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (24 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v24_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v24_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<24>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (25 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v25_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v25_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<25>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (26 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v26_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v26_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<26>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (27 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v27_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v27_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<27>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (28 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v28_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v28_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<28>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (29 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v29_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v29_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<29>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (30 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v30_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v30_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<30>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (31 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v31_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v31_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<31>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (32 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v32_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v32_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<32>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (33 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v33_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v33_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<33>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (34 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v34_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v34_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<34>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (35 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v35_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v35_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<35>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (36 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v36_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v36_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<36>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (37 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v37_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v37_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<37>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (38 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v38_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v38_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<38>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (39 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v39_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v39_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<39>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (40 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v40_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v40_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<40>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (41 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v41_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v41_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<41>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (42 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v42_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v42_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<42>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (43 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v43_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v43_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<43>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (44 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v44_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v44_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<44>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (45 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v45_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v45_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<45>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (46 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v46_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v46_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<46>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (47 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v47_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v47_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<47>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (48 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v48_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v48_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<48>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (49 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v49_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v49_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<49>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (50 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v50_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v50_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<50>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (51 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v51_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v51_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<51>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (52 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v52_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v52_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<52>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (53 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v53_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v53_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<53>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (54 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v54_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v54_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<54>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (55 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v55_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v55_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<55>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (56 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v56_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v56_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<56>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (57 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v57_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v57_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<57>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (58 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v58_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v58_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<58>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (59 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v59_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v59_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<59>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (60 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v60_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v60_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<60>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (61 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v61_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v61_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<61>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (62 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v62_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v62_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<62>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (63 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<int64_t>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v63_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v63_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<int64_t, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
  if (field_presence_.IsSet<63>()) {
    const size_t length_before = _encoder->CurrentLength();
    const size_t handles_before = _encoder->CurrentHandleCount();

    size_t envelope_base = base + (64 - 1) * sizeof(fidl_envelope_v2_t);

    if (::fidl::EncodingInlineSize<::test::table::ExtensionTable>(_encoder) <= FIDL_ENVELOPE_INLINING_SIZE_THRESHOLD) {
      ::fidl::Encode(_encoder, &v64_value_.value, envelope_base);

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = FIDL_ENVELOPE_FLAGS_INLINING_MASK;
    } else {
      ::fidl::Encode(
        _encoder,
        &v64_value_.value,
        _encoder->Alloc(::fidl::EncodingInlineSize<::test::table::ExtensionTable, ::fidl::Encoder>(_encoder)));

      fidl_envelope_v2_t* envelope = _encoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
      envelope->num_bytes = static_cast<uint32_t>(_encoder->CurrentLength() - length_before);
      envelope->num_handles = static_cast<uint16_t>(_encoder->CurrentHandleCount() - handles_before);
      envelope->flags = 0;
    }
  }
}

void SixtyFourOrdinalTable::Decode(::fidl::Decoder* _decoder, SixtyFourOrdinalTable* _value, size_t _offset) {
  fidl_vector_t* encoded = _decoder->GetPtr<fidl_vector_t>(_offset);
  [[maybe_unused]] size_t base;
  [[maybe_unused]] size_t count;
  if (!encoded->data) {
    goto clear_all;
  }

  base = _decoder->GetOffset(encoded->data);
  count = encoded->count;
  if (count >= 1) {
    size_t envelope_base = base + (1 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v1(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v1();
    }
  } else {
    goto done_1;
  }
  if (count >= 2) {
    size_t envelope_base = base + (2 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v2(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v2();
    }
  } else {
    goto done_2;
  }
  if (count >= 3) {
    size_t envelope_base = base + (3 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v3(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v3();
    }
  } else {
    goto done_3;
  }
  if (count >= 4) {
    size_t envelope_base = base + (4 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v4(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v4();
    }
  } else {
    goto done_4;
  }
  if (count >= 5) {
    size_t envelope_base = base + (5 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v5(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v5();
    }
  } else {
    goto done_5;
  }
  if (count >= 6) {
    size_t envelope_base = base + (6 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v6(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v6();
    }
  } else {
    goto done_6;
  }
  if (count >= 7) {
    size_t envelope_base = base + (7 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v7(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v7();
    }
  } else {
    goto done_7;
  }
  if (count >= 8) {
    size_t envelope_base = base + (8 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v8(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v8();
    }
  } else {
    goto done_8;
  }
  if (count >= 9) {
    size_t envelope_base = base + (9 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v9(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v9();
    }
  } else {
    goto done_9;
  }
  if (count >= 10) {
    size_t envelope_base = base + (10 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v10(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v10();
    }
  } else {
    goto done_10;
  }
  if (count >= 11) {
    size_t envelope_base = base + (11 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v11(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v11();
    }
  } else {
    goto done_11;
  }
  if (count >= 12) {
    size_t envelope_base = base + (12 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v12(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v12();
    }
  } else {
    goto done_12;
  }
  if (count >= 13) {
    size_t envelope_base = base + (13 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v13(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v13();
    }
  } else {
    goto done_13;
  }
  if (count >= 14) {
    size_t envelope_base = base + (14 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v14(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v14();
    }
  } else {
    goto done_14;
  }
  if (count >= 15) {
    size_t envelope_base = base + (15 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v15(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v15();
    }
  } else {
    goto done_15;
  }
  if (count >= 16) {
    size_t envelope_base = base + (16 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v16(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v16();
    }
  } else {
    goto done_16;
  }
  if (count >= 17) {
    size_t envelope_base = base + (17 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v17(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v17();
    }
  } else {
    goto done_17;
  }
  if (count >= 18) {
    size_t envelope_base = base + (18 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v18(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v18();
    }
  } else {
    goto done_18;
  }
  if (count >= 19) {
    size_t envelope_base = base + (19 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v19(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v19();
    }
  } else {
    goto done_19;
  }
  if (count >= 20) {
    size_t envelope_base = base + (20 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v20(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v20();
    }
  } else {
    goto done_20;
  }
  if (count >= 21) {
    size_t envelope_base = base + (21 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v21(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v21();
    }
  } else {
    goto done_21;
  }
  if (count >= 22) {
    size_t envelope_base = base + (22 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v22(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v22();
    }
  } else {
    goto done_22;
  }
  if (count >= 23) {
    size_t envelope_base = base + (23 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v23(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v23();
    }
  } else {
    goto done_23;
  }
  if (count >= 24) {
    size_t envelope_base = base + (24 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v24(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v24();
    }
  } else {
    goto done_24;
  }
  if (count >= 25) {
    size_t envelope_base = base + (25 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v25(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v25();
    }
  } else {
    goto done_25;
  }
  if (count >= 26) {
    size_t envelope_base = base + (26 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v26(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v26();
    }
  } else {
    goto done_26;
  }
  if (count >= 27) {
    size_t envelope_base = base + (27 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v27(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v27();
    }
  } else {
    goto done_27;
  }
  if (count >= 28) {
    size_t envelope_base = base + (28 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v28(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v28();
    }
  } else {
    goto done_28;
  }
  if (count >= 29) {
    size_t envelope_base = base + (29 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v29(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v29();
    }
  } else {
    goto done_29;
  }
  if (count >= 30) {
    size_t envelope_base = base + (30 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v30(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v30();
    }
  } else {
    goto done_30;
  }
  if (count >= 31) {
    size_t envelope_base = base + (31 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v31(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v31();
    }
  } else {
    goto done_31;
  }
  if (count >= 32) {
    size_t envelope_base = base + (32 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v32(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v32();
    }
  } else {
    goto done_32;
  }
  if (count >= 33) {
    size_t envelope_base = base + (33 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v33(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v33();
    }
  } else {
    goto done_33;
  }
  if (count >= 34) {
    size_t envelope_base = base + (34 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v34(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v34();
    }
  } else {
    goto done_34;
  }
  if (count >= 35) {
    size_t envelope_base = base + (35 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v35(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v35();
    }
  } else {
    goto done_35;
  }
  if (count >= 36) {
    size_t envelope_base = base + (36 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v36(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v36();
    }
  } else {
    goto done_36;
  }
  if (count >= 37) {
    size_t envelope_base = base + (37 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v37(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v37();
    }
  } else {
    goto done_37;
  }
  if (count >= 38) {
    size_t envelope_base = base + (38 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v38(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v38();
    }
  } else {
    goto done_38;
  }
  if (count >= 39) {
    size_t envelope_base = base + (39 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v39(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v39();
    }
  } else {
    goto done_39;
  }
  if (count >= 40) {
    size_t envelope_base = base + (40 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v40(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v40();
    }
  } else {
    goto done_40;
  }
  if (count >= 41) {
    size_t envelope_base = base + (41 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v41(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v41();
    }
  } else {
    goto done_41;
  }
  if (count >= 42) {
    size_t envelope_base = base + (42 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v42(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v42();
    }
  } else {
    goto done_42;
  }
  if (count >= 43) {
    size_t envelope_base = base + (43 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v43(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v43();
    }
  } else {
    goto done_43;
  }
  if (count >= 44) {
    size_t envelope_base = base + (44 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v44(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v44();
    }
  } else {
    goto done_44;
  }
  if (count >= 45) {
    size_t envelope_base = base + (45 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v45(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v45();
    }
  } else {
    goto done_45;
  }
  if (count >= 46) {
    size_t envelope_base = base + (46 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v46(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v46();
    }
  } else {
    goto done_46;
  }
  if (count >= 47) {
    size_t envelope_base = base + (47 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v47(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v47();
    }
  } else {
    goto done_47;
  }
  if (count >= 48) {
    size_t envelope_base = base + (48 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v48(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v48();
    }
  } else {
    goto done_48;
  }
  if (count >= 49) {
    size_t envelope_base = base + (49 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v49(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v49();
    }
  } else {
    goto done_49;
  }
  if (count >= 50) {
    size_t envelope_base = base + (50 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v50(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v50();
    }
  } else {
    goto done_50;
  }
  if (count >= 51) {
    size_t envelope_base = base + (51 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v51(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v51();
    }
  } else {
    goto done_51;
  }
  if (count >= 52) {
    size_t envelope_base = base + (52 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v52(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v52();
    }
  } else {
    goto done_52;
  }
  if (count >= 53) {
    size_t envelope_base = base + (53 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v53(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v53();
    }
  } else {
    goto done_53;
  }
  if (count >= 54) {
    size_t envelope_base = base + (54 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v54(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v54();
    }
  } else {
    goto done_54;
  }
  if (count >= 55) {
    size_t envelope_base = base + (55 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v55(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v55();
    }
  } else {
    goto done_55;
  }
  if (count >= 56) {
    size_t envelope_base = base + (56 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v56(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v56();
    }
  } else {
    goto done_56;
  }
  if (count >= 57) {
    size_t envelope_base = base + (57 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v57(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v57();
    }
  } else {
    goto done_57;
  }
  if (count >= 58) {
    size_t envelope_base = base + (58 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v58(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v58();
    }
  } else {
    goto done_58;
  }
  if (count >= 59) {
    size_t envelope_base = base + (59 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v59(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v59();
    }
  } else {
    goto done_59;
  }
  if (count >= 60) {
    size_t envelope_base = base + (60 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v60(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v60();
    }
  } else {
    goto done_60;
  }
  if (count >= 61) {
    size_t envelope_base = base + (61 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v61(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v61();
    }
  } else {
    goto done_61;
  }
  if (count >= 62) {
    size_t envelope_base = base + (62 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v62(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v62();
    }
  } else {
    goto done_62;
  }
  if (count >= 63) {
    size_t envelope_base = base + (63 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v63(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v63();
    }
  } else {
    goto done_63;
  }
  if (count >= 64) {
    size_t envelope_base = base + (64 - 1) * sizeof(fidl_envelope_v2_t);
    fidl_envelope_v2_t* envelope = _decoder->GetPtr<fidl_envelope_v2_t>(envelope_base);
    if (*reinterpret_cast<const void* const*>(envelope) != nullptr) {
      ::fidl::Decode(_decoder, _value->mutable_v64(),
        _decoder->EnvelopeValueOffset(envelope));
    } else {
      _value->clear_v64();
    }
  } else {
    goto done_64;
  }

  

  return;

  // Clear unset values.
clear_all:
done_1:
  _value->clear_v1();
done_2:
  _value->clear_v2();
done_3:
  _value->clear_v3();
done_4:
  _value->clear_v4();
done_5:
  _value->clear_v5();
done_6:
  _value->clear_v6();
done_7:
  _value->clear_v7();
done_8:
  _value->clear_v8();
done_9:
  _value->clear_v9();
done_10:
  _value->clear_v10();
done_11:
  _value->clear_v11();
done_12:
  _value->clear_v12();
done_13:
  _value->clear_v13();
done_14:
  _value->clear_v14();
done_15:
  _value->clear_v15();
done_16:
  _value->clear_v16();
done_17:
  _value->clear_v17();
done_18:
  _value->clear_v18();
done_19:
  _value->clear_v19();
done_20:
  _value->clear_v20();
done_21:
  _value->clear_v21();
done_22:
  _value->clear_v22();
done_23:
  _value->clear_v23();
done_24:
  _value->clear_v24();
done_25:
  _value->clear_v25();
done_26:
  _value->clear_v26();
done_27:
  _value->clear_v27();
done_28:
  _value->clear_v28();
done_29:
  _value->clear_v29();
done_30:
  _value->clear_v30();
done_31:
  _value->clear_v31();
done_32:
  _value->clear_v32();
done_33:
  _value->clear_v33();
done_34:
  _value->clear_v34();
done_35:
  _value->clear_v35();
done_36:
  _value->clear_v36();
done_37:
  _value->clear_v37();
done_38:
  _value->clear_v38();
done_39:
  _value->clear_v39();
done_40:
  _value->clear_v40();
done_41:
  _value->clear_v41();
done_42:
  _value->clear_v42();
done_43:
  _value->clear_v43();
done_44:
  _value->clear_v44();
done_45:
  _value->clear_v45();
done_46:
  _value->clear_v46();
done_47:
  _value->clear_v47();
done_48:
  _value->clear_v48();
done_49:
  _value->clear_v49();
done_50:
  _value->clear_v50();
done_51:
  _value->clear_v51();
done_52:
  _value->clear_v52();
done_53:
  _value->clear_v53();
done_54:
  _value->clear_v54();
done_55:
  _value->clear_v55();
done_56:
  _value->clear_v56();
done_57:
  _value->clear_v57();
done_58:
  _value->clear_v58();
done_59:
  _value->clear_v59();
done_60:
  _value->clear_v60();
done_61:
  _value->clear_v61();
done_62:
  _value->clear_v62();
done_63:
  _value->clear_v63();
done_64:
  _value->clear_v64();
  return;
}

zx_status_t SixtyFourOrdinalTable::Clone(SixtyFourOrdinalTable* result) const {
  if (field_presence_.IsSet<0>()) {
    zx_status_t _status = ::fidl::Clone(v1_value_.value, result->mutable_v1());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v1();
  }
  if (field_presence_.IsSet<1>()) {
    zx_status_t _status = ::fidl::Clone(v2_value_.value, result->mutable_v2());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v2();
  }
  if (field_presence_.IsSet<2>()) {
    zx_status_t _status = ::fidl::Clone(v3_value_.value, result->mutable_v3());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v3();
  }
  if (field_presence_.IsSet<3>()) {
    zx_status_t _status = ::fidl::Clone(v4_value_.value, result->mutable_v4());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v4();
  }
  if (field_presence_.IsSet<4>()) {
    zx_status_t _status = ::fidl::Clone(v5_value_.value, result->mutable_v5());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v5();
  }
  if (field_presence_.IsSet<5>()) {
    zx_status_t _status = ::fidl::Clone(v6_value_.value, result->mutable_v6());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v6();
  }
  if (field_presence_.IsSet<6>()) {
    zx_status_t _status = ::fidl::Clone(v7_value_.value, result->mutable_v7());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v7();
  }
  if (field_presence_.IsSet<7>()) {
    zx_status_t _status = ::fidl::Clone(v8_value_.value, result->mutable_v8());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v8();
  }
  if (field_presence_.IsSet<8>()) {
    zx_status_t _status = ::fidl::Clone(v9_value_.value, result->mutable_v9());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v9();
  }
  if (field_presence_.IsSet<9>()) {
    zx_status_t _status = ::fidl::Clone(v10_value_.value, result->mutable_v10());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v10();
  }
  if (field_presence_.IsSet<10>()) {
    zx_status_t _status = ::fidl::Clone(v11_value_.value, result->mutable_v11());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v11();
  }
  if (field_presence_.IsSet<11>()) {
    zx_status_t _status = ::fidl::Clone(v12_value_.value, result->mutable_v12());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v12();
  }
  if (field_presence_.IsSet<12>()) {
    zx_status_t _status = ::fidl::Clone(v13_value_.value, result->mutable_v13());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v13();
  }
  if (field_presence_.IsSet<13>()) {
    zx_status_t _status = ::fidl::Clone(v14_value_.value, result->mutable_v14());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v14();
  }
  if (field_presence_.IsSet<14>()) {
    zx_status_t _status = ::fidl::Clone(v15_value_.value, result->mutable_v15());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v15();
  }
  if (field_presence_.IsSet<15>()) {
    zx_status_t _status = ::fidl::Clone(v16_value_.value, result->mutable_v16());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v16();
  }
  if (field_presence_.IsSet<16>()) {
    zx_status_t _status = ::fidl::Clone(v17_value_.value, result->mutable_v17());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v17();
  }
  if (field_presence_.IsSet<17>()) {
    zx_status_t _status = ::fidl::Clone(v18_value_.value, result->mutable_v18());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v18();
  }
  if (field_presence_.IsSet<18>()) {
    zx_status_t _status = ::fidl::Clone(v19_value_.value, result->mutable_v19());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v19();
  }
  if (field_presence_.IsSet<19>()) {
    zx_status_t _status = ::fidl::Clone(v20_value_.value, result->mutable_v20());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v20();
  }
  if (field_presence_.IsSet<20>()) {
    zx_status_t _status = ::fidl::Clone(v21_value_.value, result->mutable_v21());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v21();
  }
  if (field_presence_.IsSet<21>()) {
    zx_status_t _status = ::fidl::Clone(v22_value_.value, result->mutable_v22());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v22();
  }
  if (field_presence_.IsSet<22>()) {
    zx_status_t _status = ::fidl::Clone(v23_value_.value, result->mutable_v23());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v23();
  }
  if (field_presence_.IsSet<23>()) {
    zx_status_t _status = ::fidl::Clone(v24_value_.value, result->mutable_v24());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v24();
  }
  if (field_presence_.IsSet<24>()) {
    zx_status_t _status = ::fidl::Clone(v25_value_.value, result->mutable_v25());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v25();
  }
  if (field_presence_.IsSet<25>()) {
    zx_status_t _status = ::fidl::Clone(v26_value_.value, result->mutable_v26());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v26();
  }
  if (field_presence_.IsSet<26>()) {
    zx_status_t _status = ::fidl::Clone(v27_value_.value, result->mutable_v27());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v27();
  }
  if (field_presence_.IsSet<27>()) {
    zx_status_t _status = ::fidl::Clone(v28_value_.value, result->mutable_v28());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v28();
  }
  if (field_presence_.IsSet<28>()) {
    zx_status_t _status = ::fidl::Clone(v29_value_.value, result->mutable_v29());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v29();
  }
  if (field_presence_.IsSet<29>()) {
    zx_status_t _status = ::fidl::Clone(v30_value_.value, result->mutable_v30());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v30();
  }
  if (field_presence_.IsSet<30>()) {
    zx_status_t _status = ::fidl::Clone(v31_value_.value, result->mutable_v31());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v31();
  }
  if (field_presence_.IsSet<31>()) {
    zx_status_t _status = ::fidl::Clone(v32_value_.value, result->mutable_v32());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v32();
  }
  if (field_presence_.IsSet<32>()) {
    zx_status_t _status = ::fidl::Clone(v33_value_.value, result->mutable_v33());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v33();
  }
  if (field_presence_.IsSet<33>()) {
    zx_status_t _status = ::fidl::Clone(v34_value_.value, result->mutable_v34());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v34();
  }
  if (field_presence_.IsSet<34>()) {
    zx_status_t _status = ::fidl::Clone(v35_value_.value, result->mutable_v35());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v35();
  }
  if (field_presence_.IsSet<35>()) {
    zx_status_t _status = ::fidl::Clone(v36_value_.value, result->mutable_v36());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v36();
  }
  if (field_presence_.IsSet<36>()) {
    zx_status_t _status = ::fidl::Clone(v37_value_.value, result->mutable_v37());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v37();
  }
  if (field_presence_.IsSet<37>()) {
    zx_status_t _status = ::fidl::Clone(v38_value_.value, result->mutable_v38());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v38();
  }
  if (field_presence_.IsSet<38>()) {
    zx_status_t _status = ::fidl::Clone(v39_value_.value, result->mutable_v39());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v39();
  }
  if (field_presence_.IsSet<39>()) {
    zx_status_t _status = ::fidl::Clone(v40_value_.value, result->mutable_v40());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v40();
  }
  if (field_presence_.IsSet<40>()) {
    zx_status_t _status = ::fidl::Clone(v41_value_.value, result->mutable_v41());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v41();
  }
  if (field_presence_.IsSet<41>()) {
    zx_status_t _status = ::fidl::Clone(v42_value_.value, result->mutable_v42());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v42();
  }
  if (field_presence_.IsSet<42>()) {
    zx_status_t _status = ::fidl::Clone(v43_value_.value, result->mutable_v43());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v43();
  }
  if (field_presence_.IsSet<43>()) {
    zx_status_t _status = ::fidl::Clone(v44_value_.value, result->mutable_v44());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v44();
  }
  if (field_presence_.IsSet<44>()) {
    zx_status_t _status = ::fidl::Clone(v45_value_.value, result->mutable_v45());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v45();
  }
  if (field_presence_.IsSet<45>()) {
    zx_status_t _status = ::fidl::Clone(v46_value_.value, result->mutable_v46());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v46();
  }
  if (field_presence_.IsSet<46>()) {
    zx_status_t _status = ::fidl::Clone(v47_value_.value, result->mutable_v47());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v47();
  }
  if (field_presence_.IsSet<47>()) {
    zx_status_t _status = ::fidl::Clone(v48_value_.value, result->mutable_v48());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v48();
  }
  if (field_presence_.IsSet<48>()) {
    zx_status_t _status = ::fidl::Clone(v49_value_.value, result->mutable_v49());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v49();
  }
  if (field_presence_.IsSet<49>()) {
    zx_status_t _status = ::fidl::Clone(v50_value_.value, result->mutable_v50());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v50();
  }
  if (field_presence_.IsSet<50>()) {
    zx_status_t _status = ::fidl::Clone(v51_value_.value, result->mutable_v51());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v51();
  }
  if (field_presence_.IsSet<51>()) {
    zx_status_t _status = ::fidl::Clone(v52_value_.value, result->mutable_v52());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v52();
  }
  if (field_presence_.IsSet<52>()) {
    zx_status_t _status = ::fidl::Clone(v53_value_.value, result->mutable_v53());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v53();
  }
  if (field_presence_.IsSet<53>()) {
    zx_status_t _status = ::fidl::Clone(v54_value_.value, result->mutable_v54());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v54();
  }
  if (field_presence_.IsSet<54>()) {
    zx_status_t _status = ::fidl::Clone(v55_value_.value, result->mutable_v55());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v55();
  }
  if (field_presence_.IsSet<55>()) {
    zx_status_t _status = ::fidl::Clone(v56_value_.value, result->mutable_v56());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v56();
  }
  if (field_presence_.IsSet<56>()) {
    zx_status_t _status = ::fidl::Clone(v57_value_.value, result->mutable_v57());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v57();
  }
  if (field_presence_.IsSet<57>()) {
    zx_status_t _status = ::fidl::Clone(v58_value_.value, result->mutable_v58());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v58();
  }
  if (field_presence_.IsSet<58>()) {
    zx_status_t _status = ::fidl::Clone(v59_value_.value, result->mutable_v59());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v59();
  }
  if (field_presence_.IsSet<59>()) {
    zx_status_t _status = ::fidl::Clone(v60_value_.value, result->mutable_v60());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v60();
  }
  if (field_presence_.IsSet<60>()) {
    zx_status_t _status = ::fidl::Clone(v61_value_.value, result->mutable_v61());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v61();
  }
  if (field_presence_.IsSet<61>()) {
    zx_status_t _status = ::fidl::Clone(v62_value_.value, result->mutable_v62());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v62();
  }
  if (field_presence_.IsSet<62>()) {
    zx_status_t _status = ::fidl::Clone(v63_value_.value, result->mutable_v63());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v63();
  }
  if (field_presence_.IsSet<63>()) {
    zx_status_t _status = ::fidl::Clone(v64_value_.value, result->mutable_v64());
    if (_status != ZX_OK)
      return _status;
  } else {
    result->clear_v64();
  }
  return ZX_OK;
}

//
// Proxies and stubs definitions
//

}  // namespace table
}  // namespace test


