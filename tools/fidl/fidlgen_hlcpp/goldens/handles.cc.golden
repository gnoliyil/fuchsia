// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions
// fidl_experiment = zx_select_case_sensitivity

#include <test/handles/cpp/fidl.h>

#include "lib/fidl/cpp/internal/implementation.h"

//
// Domain objects definitions
//
namespace test {
namespace handles {

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_handles_HandlesTable;
const fidl_type_t* Handles::FidlType = &test_handles_HandlesTable;

void Handles::Encode(::fidl::Encoder* _encoder, size_t _offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
  if (::fidl::IsMemcpyCompatible<Handles>::value) {
    memcpy(_encoder->template GetPtr<Handles>(_offset), this, sizeof(Handles));
  } else {
    ::fidl::Encode(_encoder, &plain_handle, _offset + 0, ::fidl::HandleInformation{
                                                             .object_type = ZX_OBJ_TYPE_NONE,
                                                             .rights = 0x80000000,
                                                         });

    ::fidl::Encode(_encoder, &bti_handle, _offset + 4, ::fidl::HandleInformation{
                                                           .object_type = ZX_OBJ_TYPE_BTI,
                                                           .rights = 0x80000000,
                                                       });

    ::fidl::Encode(_encoder, &channel_handle, _offset + 8, ::fidl::HandleInformation{
                                                               .object_type = ZX_OBJ_TYPE_CHANNEL,
                                                               .rights = 0x80000000,
                                                           });

    ::fidl::Encode(_encoder, &clock_handle, _offset + 12, ::fidl::HandleInformation{
                                                              .object_type = ZX_OBJ_TYPE_CLOCK,
                                                              .rights = 0x80000000,
                                                          });

    ::fidl::Encode(_encoder, &debuglog_handle, _offset + 16, ::fidl::HandleInformation{
                                                                 .object_type = ZX_OBJ_TYPE_DEBUGLOG,
                                                                 .rights = 0x80000000,
                                                             });

    ::fidl::Encode(_encoder, &event_handle, _offset + 20, ::fidl::HandleInformation{
                                                              .object_type = ZX_OBJ_TYPE_EVENT,
                                                              .rights = 0x80000000,
                                                          });

    ::fidl::Encode(_encoder, &eventpair_handle, _offset + 24, ::fidl::HandleInformation{
                                                                  .object_type = ZX_OBJ_TYPE_EVENTPAIR,
                                                                  .rights = 0x80000000,
                                                              });

    ::fidl::Encode(_encoder, &exception_handle, _offset + 28, ::fidl::HandleInformation{
                                                                  .object_type = ZX_OBJ_TYPE_EXCEPTION,
                                                                  .rights = 0x80000000,
                                                              });

    ::fidl::Encode(_encoder, &fifo_handle, _offset + 32, ::fidl::HandleInformation{
                                                             .object_type = ZX_OBJ_TYPE_FIFO,
                                                             .rights = 0x80000000,
                                                         });

    ::fidl::Encode(_encoder, &guest_handle, _offset + 36, ::fidl::HandleInformation{
                                                              .object_type = ZX_OBJ_TYPE_GUEST,
                                                              .rights = 0x80000000,
                                                          });

    ::fidl::Encode(_encoder, &interrupt_handle, _offset + 40, ::fidl::HandleInformation{
                                                                  .object_type = ZX_OBJ_TYPE_INTERRUPT,
                                                                  .rights = 0x80000000,
                                                              });

    ::fidl::Encode(_encoder, &iommu_handle, _offset + 44, ::fidl::HandleInformation{
                                                              .object_type = ZX_OBJ_TYPE_IOMMU,
                                                              .rights = 0x80000000,
                                                          });

    ::fidl::Encode(_encoder, &job_handle, _offset + 48, ::fidl::HandleInformation{
                                                            .object_type = ZX_OBJ_TYPE_JOB,
                                                            .rights = 0x80000000,
                                                        });

    ::fidl::Encode(_encoder, &msi_handle, _offset + 52, ::fidl::HandleInformation{
                                                            .object_type = ZX_OBJ_TYPE_MSI,
                                                            .rights = 0x80000000,
                                                        });

    ::fidl::Encode(_encoder, &pager_handle, _offset + 56, ::fidl::HandleInformation{
                                                              .object_type = ZX_OBJ_TYPE_PAGER,
                                                              .rights = 0x80000000,
                                                          });

    ::fidl::Encode(_encoder, &pmt_handle, _offset + 60, ::fidl::HandleInformation{
                                                            .object_type = ZX_OBJ_TYPE_PMT,
                                                            .rights = 0x80000000,
                                                        });

    ::fidl::Encode(_encoder, &port_handle, _offset + 64, ::fidl::HandleInformation{
                                                             .object_type = ZX_OBJ_TYPE_PORT,
                                                             .rights = 0x80000000,
                                                         });

    ::fidl::Encode(_encoder, &process_handle, _offset + 68, ::fidl::HandleInformation{
                                                                .object_type = ZX_OBJ_TYPE_PROCESS,
                                                                .rights = 0x80000000,
                                                            });

    ::fidl::Encode(_encoder, &profile_handle, _offset + 72, ::fidl::HandleInformation{
                                                                .object_type = ZX_OBJ_TYPE_PROFILE,
                                                                .rights = 0x80000000,
                                                            });

    ::fidl::Encode(_encoder, &resource_handle, _offset + 76, ::fidl::HandleInformation{
                                                                 .object_type = ZX_OBJ_TYPE_RESOURCE,
                                                                 .rights = 0x80000000,
                                                             });

    ::fidl::Encode(_encoder, &socket_handle, _offset + 80, ::fidl::HandleInformation{
                                                               .object_type = ZX_OBJ_TYPE_SOCKET,
                                                               .rights = 0x80000000,
                                                           });

    ::fidl::Encode(_encoder, &stream_handle, _offset + 84, ::fidl::HandleInformation{
                                                               .object_type = ZX_OBJ_TYPE_STREAM,
                                                               .rights = 0x80000000,
                                                           });

    ::fidl::Encode(_encoder, &suspendtoken_handle, _offset + 88, ::fidl::HandleInformation{
                                                                     .object_type = ZX_OBJ_TYPE_SUSPEND_TOKEN,
                                                                     .rights = 0x80000000,
                                                                 });

    ::fidl::Encode(_encoder, &thread_handle, _offset + 92, ::fidl::HandleInformation{
                                                               .object_type = ZX_OBJ_TYPE_THREAD,
                                                               .rights = 0x80000000,
                                                           });

    ::fidl::Encode(_encoder, &timer_handle, _offset + 96, ::fidl::HandleInformation{
                                                              .object_type = ZX_OBJ_TYPE_TIMER,
                                                              .rights = 0x80000000,
                                                          });

    ::fidl::Encode(_encoder, &vcpu_handle, _offset + 100, ::fidl::HandleInformation{
                                                              .object_type = ZX_OBJ_TYPE_VCPU,
                                                              .rights = 0x80000000,
                                                          });

    ::fidl::Encode(_encoder, &vmar_handle, _offset + 104, ::fidl::HandleInformation{
                                                              .object_type = ZX_OBJ_TYPE_VMAR,
                                                              .rights = 0x80000000,
                                                          });

    ::fidl::Encode(_encoder, &vmo_handle, _offset + 108, ::fidl::HandleInformation{
                                                             .object_type = ZX_OBJ_TYPE_VMO,
                                                             .rights = 0x80000000,
                                                         });

    ::fidl::Encode(_encoder, &rights_handle, _offset + 112, ::fidl::HandleInformation{
                                                                .object_type = ZX_OBJ_TYPE_VMO,
                                                                .rights = 0x5,
                                                            });

    ::fidl::Encode(_encoder, &aliased_plain_handle_field, _offset + 116, ::fidl::HandleInformation{
                                                                             .object_type = ZX_OBJ_TYPE_NONE,
                                                                             .rights = 0x80000000,
                                                                         });

    ::fidl::Encode(_encoder, &aliased_subtype_handle_field, _offset + 120, ::fidl::HandleInformation{
                                                                               .object_type = ZX_OBJ_TYPE_VMO,
                                                                               .rights = 0x80000000,
                                                                           });

    ::fidl::Encode(_encoder, &aliased_rights_handle_field, _offset + 124, ::fidl::HandleInformation{
                                                                              .object_type = ZX_OBJ_TYPE_VMO,
                                                                              .rights = 0x1,
                                                                          });

    ::fidl::Encode(_encoder, &some_protocol, _offset + 128, ::fidl::HandleInformation{
                                                                .object_type = ZX_OBJ_TYPE_CHANNEL,
                                                                .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                                                            });

    ::fidl::Encode(_encoder, &request_some_protocol, _offset + 132, ::fidl::HandleInformation{
                                                                        .object_type = ZX_OBJ_TYPE_CHANNEL,
                                                                        .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                                                                    });
  }
}

void Handles::Decode(::fidl::Decoder* _decoder, Handles* _value, size_t _offset) {
  if (::fidl::IsMemcpyCompatible<Handles>::value) {
    memcpy(_value, _decoder->template GetPtr<Handles>(_offset), sizeof(Handles));
  } else {
    ::fidl::Decode(_decoder, &_value->plain_handle, _offset + 0);
    ::fidl::Decode(_decoder, &_value->bti_handle, _offset + 4);
    ::fidl::Decode(_decoder, &_value->channel_handle, _offset + 8);
    ::fidl::Decode(_decoder, &_value->clock_handle, _offset + 12);
    ::fidl::Decode(_decoder, &_value->debuglog_handle, _offset + 16);
    ::fidl::Decode(_decoder, &_value->event_handle, _offset + 20);
    ::fidl::Decode(_decoder, &_value->eventpair_handle, _offset + 24);
    ::fidl::Decode(_decoder, &_value->exception_handle, _offset + 28);
    ::fidl::Decode(_decoder, &_value->fifo_handle, _offset + 32);
    ::fidl::Decode(_decoder, &_value->guest_handle, _offset + 36);
    ::fidl::Decode(_decoder, &_value->interrupt_handle, _offset + 40);
    ::fidl::Decode(_decoder, &_value->iommu_handle, _offset + 44);
    ::fidl::Decode(_decoder, &_value->job_handle, _offset + 48);
    ::fidl::Decode(_decoder, &_value->msi_handle, _offset + 52);
    ::fidl::Decode(_decoder, &_value->pager_handle, _offset + 56);
    ::fidl::Decode(_decoder, &_value->pmt_handle, _offset + 60);
    ::fidl::Decode(_decoder, &_value->port_handle, _offset + 64);
    ::fidl::Decode(_decoder, &_value->process_handle, _offset + 68);
    ::fidl::Decode(_decoder, &_value->profile_handle, _offset + 72);
    ::fidl::Decode(_decoder, &_value->resource_handle, _offset + 76);
    ::fidl::Decode(_decoder, &_value->socket_handle, _offset + 80);
    ::fidl::Decode(_decoder, &_value->stream_handle, _offset + 84);
    ::fidl::Decode(_decoder, &_value->suspendtoken_handle, _offset + 88);
    ::fidl::Decode(_decoder, &_value->thread_handle, _offset + 92);
    ::fidl::Decode(_decoder, &_value->timer_handle, _offset + 96);
    ::fidl::Decode(_decoder, &_value->vcpu_handle, _offset + 100);
    ::fidl::Decode(_decoder, &_value->vmar_handle, _offset + 104);
    ::fidl::Decode(_decoder, &_value->vmo_handle, _offset + 108);
    ::fidl::Decode(_decoder, &_value->rights_handle, _offset + 112);
    ::fidl::Decode(_decoder, &_value->aliased_plain_handle_field, _offset + 116);
    ::fidl::Decode(_decoder, &_value->aliased_subtype_handle_field, _offset + 120);
    ::fidl::Decode(_decoder, &_value->aliased_rights_handle_field, _offset + 124);
    ::fidl::Decode(_decoder, &_value->some_protocol, _offset + 128);
    ::fidl::Decode(_decoder, &_value->request_some_protocol, _offset + 132);
  }
}

zx_status_t Handles::Clone(Handles* _result) const {
  zx_status_t _status = ::fidl::Clone(plain_handle, &_result->plain_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(bti_handle, &_result->bti_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(channel_handle, &_result->channel_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(clock_handle, &_result->clock_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(debuglog_handle, &_result->debuglog_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(event_handle, &_result->event_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(eventpair_handle, &_result->eventpair_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(exception_handle, &_result->exception_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(fifo_handle, &_result->fifo_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(guest_handle, &_result->guest_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(interrupt_handle, &_result->interrupt_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(iommu_handle, &_result->iommu_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(job_handle, &_result->job_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(msi_handle, &_result->msi_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(pager_handle, &_result->pager_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(pmt_handle, &_result->pmt_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(port_handle, &_result->port_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(process_handle, &_result->process_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(profile_handle, &_result->profile_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(resource_handle, &_result->resource_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(socket_handle, &_result->socket_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(stream_handle, &_result->stream_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(suspendtoken_handle, &_result->suspendtoken_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(thread_handle, &_result->thread_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(timer_handle, &_result->timer_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vcpu_handle, &_result->vcpu_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vmar_handle, &_result->vmar_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(vmo_handle, &_result->vmo_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(rights_handle, &_result->rights_handle);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(aliased_plain_handle_field, &_result->aliased_plain_handle_field);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(aliased_subtype_handle_field, &_result->aliased_subtype_handle_field);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(aliased_rights_handle_field, &_result->aliased_rights_handle_field);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(some_protocol, &_result->some_protocol);
  if (_status != ZX_OK)
    return _status;
  _status = ::fidl::Clone(request_some_protocol, &_result->request_some_protocol);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}

#endif  // __Fuchsia__

//
// Proxies and stubs definitions
//
#ifdef __Fuchsia__

SomeProtocol::~SomeProtocol() = default;

const fidl_type_t* ::test::handles::SomeProtocol_RequestDecoder::GetType(uint64_t ordinal, bool* out_needs_response, bool* out_is_known) {
  *out_needs_response = false;
  *out_is_known = false;
  switch (ordinal) {
    default:
      return nullptr;
  }
}

const fidl_type_t* SomeProtocol_ResponseDecoder::GetType(uint64_t ordinal) {
  switch (ordinal) {
    default:
      return nullptr;
  }
}

SomeProtocol_EventSender::~SomeProtocol_EventSender() = default;

SomeProtocol_Sync::~SomeProtocol_Sync() = default;

SomeProtocol_Proxy::SomeProtocol_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

SomeProtocol_Proxy::~SomeProtocol_Proxy() = default;

zx_status_t SomeProtocol_Proxy::Dispatch_(::fidl::HLCPPIncomingMessage message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

SomeProtocol_Stub::SomeProtocol_Stub(::test::handles::SomeProtocol_Stub::SomeProtocol_clazz* impl) : impl_(impl) {
  (void)impl_;
}

SomeProtocol_Stub::~SomeProtocol_Stub() = default;

namespace {

}  // namespace

zx_status_t SomeProtocol_Stub::Dispatch_(
    ::fidl::HLCPPIncomingMessage message,
    ::fidl::internal::PendingResponse response) {
  bool needs_response;
  bool is_known;
  const fidl_type_t* request_type = ::test::handles::SomeProtocol_RequestDecoder::GetType(message.ordinal(), &needs_response, &is_known);

  if (!is_known) {
    return ZX_ERR_NOT_SUPPORTED;
  }

  if (!message.has_only_header()) {
    if (request_type == nullptr) {
      return ZX_ERR_NOT_SUPPORTED;
    }
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(request_type, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, error_msg);
      return status;
    }
  }

  if (response.needs_response() != needs_response) {
    if (needs_response) {
      FIDL_REPORT_DECODING_ERROR(message, request_type, "Message needing a response with no txid");
    } else {
      FIDL_REPORT_DECODING_ERROR(message, request_type, "Message not needing a response with a txid");
    }
    return ZX_ERR_INVALID_ARGS;
  }

  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    default: {
      // Unknown ordinals are handled at the beginning of dispatching, so this
      // should be unreachable.
      ZX_PANIC("Unreachable: unknown ordinals handled earlier.");
    }
  }
  return ZX_OK;
}

SomeProtocol_SyncProxy::SomeProtocol_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

SomeProtocol_SyncProxy::~SomeProtocol_SyncProxy() = default;

#endif  // __Fuchsia__

}  // namespace handles
}  // namespace test
