// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = simple_empty_response_syntax
// fidl_experiment = unknown_interactions

#pragma once

#include "lib/fidl/cpp/internal/header.h"

namespace test {
namespace enum_ {

//
// Domain objects declarations
//

enum class MyStrictEnum : uint32_t {

  FOO = 1u,

  BAR = 2u,
};

inline zx_status_t Clone(::test::enum_::MyStrictEnum value,
                         ::test::enum_::MyStrictEnum* result) {
  *result = value;
  return ZX_OK;
}

class MyFlexibleEnum final {
 public:
  constexpr MyFlexibleEnum() : value_(0) {}
  constexpr explicit MyFlexibleEnum(uint32_t value) : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

        return false;
    }
    return true;
  }

  constexpr static MyFlexibleEnum Unknown() {
    return MyFlexibleEnum(0xffffffff);
  }

  static const MyFlexibleEnum FOO;

  static const MyFlexibleEnum BAR;

 private:
  uint32_t value_;
};

#if !(__cplusplus < 201703)
constexpr const ::test::enum_::MyFlexibleEnum MyFlexibleEnum::FOO = ::test::enum_::MyFlexibleEnum(1u);
constexpr const ::test::enum_::MyFlexibleEnum MyFlexibleEnum::BAR = ::test::enum_::MyFlexibleEnum(2u);
#endif  // !(__cplusplus < 201703)

inline zx_status_t Clone(::test::enum_::MyFlexibleEnum value,
                         ::test::enum_::MyFlexibleEnum* result) {
  *result = value;
  return ZX_OK;
}

class MyFlexibleEnumWithCustomUnknown final {
 public:
  constexpr MyFlexibleEnumWithCustomUnknown() : value_(0) {}
  constexpr explicit MyFlexibleEnumWithCustomUnknown(uint32_t value) : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

        return false;
    }
    return true;
  }

  constexpr static MyFlexibleEnumWithCustomUnknown Unknown() {
    return MyFlexibleEnumWithCustomUnknown(0x3);
  }

  static const MyFlexibleEnumWithCustomUnknown FOO;

  static const MyFlexibleEnumWithCustomUnknown BAR;

  static const MyFlexibleEnumWithCustomUnknown CUSTOM_UNKNOWN;

 private:
  uint32_t value_;
};

#if !(__cplusplus < 201703)
constexpr const ::test::enum_::MyFlexibleEnumWithCustomUnknown MyFlexibleEnumWithCustomUnknown::FOO = ::test::enum_::MyFlexibleEnumWithCustomUnknown(1u);
constexpr const ::test::enum_::MyFlexibleEnumWithCustomUnknown MyFlexibleEnumWithCustomUnknown::BAR = ::test::enum_::MyFlexibleEnumWithCustomUnknown(2u);
constexpr const ::test::enum_::MyFlexibleEnumWithCustomUnknown MyFlexibleEnumWithCustomUnknown::CUSTOM_UNKNOWN = ::test::enum_::MyFlexibleEnumWithCustomUnknown(3u);
#endif  // !(__cplusplus < 201703)

inline zx_status_t Clone(::test::enum_::MyFlexibleEnumWithCustomUnknown value,
                         ::test::enum_::MyFlexibleEnumWithCustomUnknown* result) {
  *result = value;
  return ZX_OK;
}

class MyEmptyFlexibleEnum final {
 public:
  constexpr MyEmptyFlexibleEnum() : value_(0) {}
  constexpr explicit MyEmptyFlexibleEnum(uint32_t value) : value_(value) {}
  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    return true;
  }

  constexpr static MyEmptyFlexibleEnum Unknown() {
    return MyEmptyFlexibleEnum(0xffffffff);
  }

 private:
  uint32_t value_;
};

#if !(__cplusplus < 201703)
#endif  // !(__cplusplus < 201703)

inline zx_status_t Clone(::test::enum_::MyEmptyFlexibleEnum value,
                         ::test::enum_::MyEmptyFlexibleEnum* result) {
  *result = value;
  return ZX_OK;
}

}  // namespace enum_
}  // namespace test
namespace fidl {

template <>
struct CodingTraits<::test::enum_::MyStrictEnum> {
  static constexpr size_t inline_size_v2 = sizeof(::test::enum_::MyStrictEnum);
  static void Encode(Encoder* encoder, ::test::enum_::MyStrictEnum* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::enum_::MyStrictEnum* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::enum_::MyStrictEnum>(underlying);
  }
};

inline zx_status_t Clone(::test::enum_::MyStrictEnum value,
                         ::test::enum_::MyStrictEnum* result) {
  return ::test::enum_::Clone(value, result);
}
template <>
struct Equality<::test::enum_::MyStrictEnum> {
  bool operator()(const ::test::enum_::MyStrictEnum& _lhs, const ::test::enum_::MyStrictEnum& _rhs) const {
    return _lhs == _rhs;
  }
};

template <>
struct CodingTraits<::test::enum_::MyFlexibleEnum> {
  static constexpr size_t inline_size_v2 = sizeof(::test::enum_::MyFlexibleEnum);
  static void Encode(Encoder* encoder, ::test::enum_::MyFlexibleEnum* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::enum_::MyFlexibleEnum* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::enum_::MyFlexibleEnum>(underlying);
  }
};

inline zx_status_t Clone(::test::enum_::MyFlexibleEnum value,
                         ::test::enum_::MyFlexibleEnum* result) {
  return ::test::enum_::Clone(value, result);
}
template <>
struct Equality<::test::enum_::MyFlexibleEnum> {
  bool operator()(const ::test::enum_::MyFlexibleEnum& _lhs, const ::test::enum_::MyFlexibleEnum& _rhs) const {
    return _lhs == _rhs;
  }
};

template <>
struct CodingTraits<::test::enum_::MyFlexibleEnumWithCustomUnknown> {
  static constexpr size_t inline_size_v2 = sizeof(::test::enum_::MyFlexibleEnumWithCustomUnknown);
  static void Encode(Encoder* encoder, ::test::enum_::MyFlexibleEnumWithCustomUnknown* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::enum_::MyFlexibleEnumWithCustomUnknown* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::enum_::MyFlexibleEnumWithCustomUnknown>(underlying);
  }
};

inline zx_status_t Clone(::test::enum_::MyFlexibleEnumWithCustomUnknown value,
                         ::test::enum_::MyFlexibleEnumWithCustomUnknown* result) {
  return ::test::enum_::Clone(value, result);
}
template <>
struct Equality<::test::enum_::MyFlexibleEnumWithCustomUnknown> {
  bool operator()(const ::test::enum_::MyFlexibleEnumWithCustomUnknown& _lhs, const ::test::enum_::MyFlexibleEnumWithCustomUnknown& _rhs) const {
    return _lhs == _rhs;
  }
};

template <>
struct CodingTraits<::test::enum_::MyEmptyFlexibleEnum> {
  static constexpr size_t inline_size_v2 = sizeof(::test::enum_::MyEmptyFlexibleEnum);
  static void Encode(Encoder* encoder, ::test::enum_::MyEmptyFlexibleEnum* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::enum_::MyEmptyFlexibleEnum* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::enum_::MyEmptyFlexibleEnum>(underlying);
  }
};

inline zx_status_t Clone(::test::enum_::MyEmptyFlexibleEnum value,
                         ::test::enum_::MyEmptyFlexibleEnum* result) {
  return ::test::enum_::Clone(value, result);
}
template <>
struct Equality<::test::enum_::MyEmptyFlexibleEnum> {
  bool operator()(const ::test::enum_::MyEmptyFlexibleEnum& _lhs, const ::test::enum_::MyEmptyFlexibleEnum& _rhs) const {
    return _lhs == _rhs;
  }
};

//
// Proxies and stubs declarations
//
}  // namespace fidl
