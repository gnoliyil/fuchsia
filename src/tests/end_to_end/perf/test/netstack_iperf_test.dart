// Copyright 2020 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// @dart=2.12

import 'dart:convert';
import 'dart:io';
import 'dart:math';

import 'package:sl4f/sl4f.dart';
import 'package:sl4f/trace_processing.dart' as trace;
import 'package:test/test.dart';

import 'helpers.dart';

enum Protocol { udp, tcp }

enum Direction { deviceToHost, hostToDevice, loopback }

class Stats {
  List<double> throughput = [];
  int packets = 0;
  int lost_packets = 0;
  double jitter_weighted = 0;
}

String unit(String key) {
  switch (key) {
    case 'bits_per_second':
      return 'bits/second';
    case 'bits_per_second_coefficient_of_variation':
      return 'percent';
    case 'lost_packets':
      return 'count_smallerIsBetter';
    case 'lost_percent':
      return 'percent';
    case 'jitter_ms':
      return 'milliseconds';
    case 'CPU':
      return 'percent';
    default:
      return 'unknown';
  }
}

// Translate iperf json to fuchsiaperf.json.
Map<String, dynamic> generateResult(
    String label, String key, List<dynamic> values) {
  return {
    'label': '$label/$key',
    'test_suite': 'fuchsia.netstack.iperf_benchmarks',
    'unit': unit(key),
    'values': values,
  };
}

// This test adds e2e performance benchmarks using iperf3 for TCP and UDP
// traffic. This runs iperf3 in 2 ways:
// - client and server both running in Fuchsia over loopback.
// - server running in Fuchsia and client on the host.
//
// Some of the benchmarks are:
// throughput - send/recv rate of transfer in bits/second
// loss       - number of UDP packets that were sent but failed to reach the
//              receiving application.
// jitter     - mean deviation of latency experienced by receiver in msec for UDP.
// CPU usage  - Avg CPU usage during the iperf3 sessions.
void main(List<String> args) {
  enableLoggingOutput();
  // The first TCP/UDP port number that the Fuchsia side will listen on.
  const firstListenPort = 9001;
  // systemMetricsStarted indicates if we have waited for system_metrics
  // daemon to be launched.
  bool systemMetricsStarted = false;

  // Process the JSON output from iperf3 to Fuchsiaperf JSON format.
  Future<List<Map<String, dynamic>>> iperfResultsToFuchsiaPerf(
      {required Protocol proto,
      required Direction direction,
      required int msgSize,
      required PerfTestHelper helper,
      required List<String> resultsFiles,
      required List<double> cpuPercentages}) async {
    late final String protoLabel;
    switch (proto) {
      case Protocol.udp:
        protoLabel = 'UDP';
        break;
      case Protocol.tcp:
        protoLabel = 'TCP';
        break;
    }

    late final String directionLabel;
    switch (direction) {
      case Direction.deviceToHost:
        directionLabel = 'send';
        break;
      case Direction.hostToDevice:
        directionLabel = 'recv';
        break;
      case Direction.loopback:
        directionLabel = 'loopback';
        break;
    }

    var stats = Stats();
    for (final String resultsFile in resultsFiles) {
      late final File localResultsFile;
      if (direction == Direction.loopback) {
        // Make a local copy of the json file generated by iperf3.
        localResultsFile =
            (await helper.storage.dumpFile(resultsFile, 'iperf', 'json'))!;

        // Remove the results file on the target.
        await helper.sl4fDriver.ssh.run('rm $resultsFile');
      } else {
        localResultsFile = File(resultsFile);
      }

      final iperfResults = jsonDecode(await localResultsFile.readAsString());

      // Verify iperf parameters are as we'd expect.
      {
        final setup = iperfResults['start']['test_start'];
        expect(setup['protocol'], equals(protoLabel));
        expect(setup['blksize'], equals(msgSize));
      }
      // Retrieve records from iperf json.
      final end = iperfResults['end'];

      if (proto == Protocol.tcp) {
        if (direction == Direction.deviceToHost) {
          stats.throughput.add(end['sum_sent']['bits_per_second']);
        } else {
          stats.throughput.add(end['sum_received']['bits_per_second']);
        }
      } else {
        if (direction == Direction.deviceToHost) {
          stats.throughput.add(end['sum']['bits_per_second']);
        } else {
          // For UDP, there is no sum_received record, but we gather the
          // receiver information from server-output.
          final receiver = iperfResults['server_output_json']['end']['sum'];
          // TODO(https://github.com/esnet/iperf/issues/754): Remove the following
          // once iperf calculates throughput correctly when the server is the
          // receiver. In the meantime, derive the value from the other stats.
          stats.throughput
              .add((msgSize * 8) * receiver['packets'] / receiver['seconds']);

          stats.packets += receiver['packets'] as int;
          stats.lost_packets += receiver['lost_packets'] as int;
          // Note that in order to compute the average jitter of packets
          // across all flows, the jitter for each flow must be weighted by
          // the packet count of said flow to produce the total jitter across
          // all packets, which when divided by the number of packets yields
          // the correct statistic.
          stats.jitter_weighted += receiver['packets'] * receiver['jitter_ms'];
        }
      }
    }

    var label = '$protoLabel/$directionLabel/${msgSize}bytes';
    final int flows = resultsFiles.length;
    if (flows > 1) {
      label += '/${flows}flows';
    }
    final List<Map<String, dynamic>> results = [];
    final double throughput =
        stats.throughput.reduce((double a, double b) => a + b);
    results.add(generateResult(label, 'bits_per_second', [throughput]));
    results.add(generateResult(label, 'CPU', cpuPercentages));
    if (proto != Protocol.tcp && direction != Direction.deviceToHost) {
      results.add(generateResult(label, 'lost_packets', [stats.lost_packets]));
      results.add(generateResult(label, 'lost_percent',
          [stats.lost_packets / (stats.lost_packets + stats.packets) * 100]));
      results.add(generateResult(
          label, 'jitter_ms', [stats.jitter_weighted / stats.packets]));
    }

    if (flows > 1) {
      // The following calculates the [sample standard deviation][sd], which
      // applies Bessel's correction.
      //
      // [sd]: https://en.wikipedia.org/wiki/Standard_deviation#Corrected_sample_standard_deviation
      final double meanThroughput = throughput / flows;
      final double sumOfSquaredDeltas = stats.throughput.fold(
        0,
        (sum, throughput) => sum += pow(throughput - meanThroughput, 2),
      );
      final double stdDev = sqrt(sumOfSquaredDeltas / (flows - 1));

      results.add(generateResult(
          label,
          'bits_per_second_coefficient_of_variation',
          [stdDev / meanThroughput * 100]));
    }
    return results;
  }

  Future<void> startIperfServer(PerfTestHelper helper, int port) async {
    // Start iperf server on the target device.
    await helper.sl4fDriver.ssh.start('iperf3 --server --port $port --json',
        mode: ProcessStartMode.detached);

    // Poll for the server to have started listening for client
    // connection on the expected port.
    for (var i = 0; i < 15; i++) {
      await Future.delayed(Duration(seconds: 1));
      final inspect = Inspect(helper.sl4fDriver);
      final results = await inspect
          .snapshot(['core/network/netstack:Socket\\ Info/*:LocalAddress']);
      if (results != null && results.isNotEmpty) {
        for (var j = 0; j < results.length; j++) {
          if (results[j]['payload'] != null &&
              results[j]['payload']['Socket Info'] != null) {
            for (final entry in results[j]['payload']['Socket Info'].entries) {
              if (entry.value['LocalAddress'] != null &&
                  entry.value['LocalAddress'].endsWith(':$port')) {
                return;
              }
            }
          }
        }
      }
    }
    throw Sl4fException('Failed to start Iperf server.');
  }

  Future<Iterable<double>> getCpuUsages(
      Performance performance, File traceFile) async {
    const String _trace2jsonPath = 'runtime_deps/trace2json';
    final traceResults =
        await performance.convertTraceFileToJson(_trace2jsonPath, traceFile);

    final model = await trace.createModelFromFile(traceResults);
    return trace.getArgValuesFromEvents<double>(
        trace.filterEventsTyped<trace.CounterEvent>(trace.getAllEvents(model),
            category: 'system_metrics', name: 'cpu_usage'),
        'average_cpu_percentage');
  }

  // Wait for system_metrics daemon to start logging CPU usage metrics.
  // At the time of writing this test, on NUC7, this sometimes can take
  // ~30sec for us to start getting CPU usage metrics.
  Future<void> waitSystemMetricsDaemonStart(PerfTestHelper helper) async {
    if (systemMetricsStarted) {
      return;
    }

    for (var i = 0; i < 10; i++) {
      final performance = Performance(helper.sl4fDriver, Dump());
      final traceSession = await performance.initializeTracing(categories: [
        'system_metrics',
      ]);
      await traceSession.start();
      // Do nothing for sometime to let system_metrics to be logged.
      await Future.delayed(Duration(seconds: 10));
      await traceSession.stop();
      final cpuPercentages = await getCpuUsages(
          performance, await traceSession.terminateAndDownload('iperf'));
      if (cpuPercentages.isNotEmpty) {
        systemMetricsStarted = true;
        return;
      }
    }
    throw Sl4fException(
        'Failed to retrieve CPU stats from system_metrics daemon.');
  }

  Future<void> runIperfClientTests(PerfTestHelper helper, Protocol proto,
      String label, Direction direction) async {
    String protocolOption = '';
    String dirOption = '';
    String serverIp;
    if (proto == Protocol.udp) {
      protocolOption = '--udp';
    }

    if (direction == Direction.deviceToHost) {
      // This reverses the default direction of traffic flow such that
      // the target device sends traffic.
      dirOption = '--reverse';
    }

    if (direction == Direction.loopback) {
      serverIp = '127.0.0.1';
    } else {
      // TODO(fxbug.dev/47782): Currently, we are using the link used for ssh to also
      // inject data traffic. This is prone to interference to ssh and to the tests.
      // On NUC7, we can use a separate usb-ethernet interface for the test traffic.
      serverIp = helper.sl4fDriver.ssh.target;
    }

    List<Map<String, dynamic>> results = [];
    var msgSizes = {64, 1024, 1400};
    for (var size in msgSizes) {
      var flowCounts = {1, 2, 4};
      for (var flows in flowCounts) {
        try {
          List<Future<void>> startServerFutures = [];
          for (int i = 0; i < flows; i++) {
            startServerFutures
                .add(startIperfServer(helper, firstListenPort + i));
          }
          await Future.wait(startServerFutures);

          // Start tracing.
          final performance = Performance(helper.sl4fDriver, Dump());
          final traceSession = await performance.initializeTracing(categories: [
            'system_metrics',
          ]);
          await traceSession.start();

          String bwValue = '';
          if (direction == Direction.loopback) {
            // For localhost test, use maximum possible bandwidth.
            bwValue = '0';
          } else {
            // TODO(fxbug.dev/47782): Until we define separate link for ssh and data,
            // enforce a < 1Gbps rate on NUC7. After the bug is resolved, this can
            // be changed to '0' which means as much as the system and link can
            // transmit.
            bwValue = '${100 ~/ flows}M';
          }
          final commonCmdArgs = [
            '--client',
            serverIp,
            '--length',
            '$size',
            '--json',
            protocolOption,
            '--bitrate',
            '$bwValue',
            dirOption,
            '--get-server-output'
          ];
          List<Future<String>> clientFutures = [];
          for (int i = 0; i < flows; i++) {
            final cmdArgs = [
              ...commonCmdArgs,
              '--port',
              '${firstListenPort + i}'
            ];
            if (direction == Direction.loopback) {
              var args = cmdArgs.join(' ');
              clientFutures.add(Future(() async {
                final resultsFile = '/tmp/iperf_results_$i.json';
                final result = await helper.sl4fDriver.ssh
                    .run('iperf3 $args > $resultsFile');
                expect(result.exitCode, equals(0));
                return resultsFile;
              }));
            } else {
              // Run iperf3 client from the host-tools.
              final hostPath =
                  Platform.script.resolve('runtime_deps/iperf3').toFilePath();
              clientFutures.add(Future(() async {
                final result =
                    await Process.run(hostPath, cmdArgs, runInShell: true);
                expect(result.exitCode, equals(0));
                final iperfFile = (await Dump()
                    .writeAsString('iperf', 'json', result.stdout))!;
                return iperfFile.path;
              }));
            }
          }
          List<String> resultsFiles = await Future.wait(clientFutures);

          // Wait for trace record to complete.
          await traceSession.stop();
          final cpuPercentages = await getCpuUsages(
              performance, await traceSession.terminateAndDownload('iperf'));

          results.addAll(await iperfResultsToFuchsiaPerf(
            helper: helper,
            resultsFiles: resultsFiles,
            cpuPercentages: cpuPercentages.toList(),
            proto: proto,
            direction: direction,
            msgSize: size,
          ));
        } finally {
          await helper.sl4fDriver.ssh.run('killall iperf3');
        }
      }
    }

    var fuchsiaperfFile = (await Dump().writeAsString(
        'netstack_iperf_results', 'fuchsiaperf.json', jsonEncode(results)))!;
    // Translate fuchsiaperf.json to Catapult format.
    await helper.performance.convertResults('runtime_deps/catapult_converter',
        fuchsiaperfFile, Platform.environment,
        expectedMetricNamesFile:
            'fuchsia.netstack.iperf_benchmarks.$label.txt');
  }

  List<void Function()> tests = [];
  void addIperfTest(String label, Protocol proto, Direction direction) {
    tests.add(() {
      test(label, () async {
        final helper = await PerfTestHelper.make();
        await waitSystemMetricsDaemonStart(helper);
        try {
          await runIperfClientTests(helper, proto, label, direction);
        } finally {
          // Kill the iperf3 server process.
          await helper.sl4fDriver.ssh.run('killall iperf3');
        }
      }, timeout: Timeout.none);
    });
  }

  // Localhost tests where both ends of iperf3 sessions are within
  // the target device over loopback interface.
  // Run iperf3 client and capture both sender and receiver stats.
  addIperfTest('localhost_tcp', Protocol.tcp, Direction.loopback);
  addIperfTest('localhost_udp', Protocol.udp, Direction.loopback);

  // Tests across host and target device
  //
  // Run iperf3 to capture data about the send only and receive only
  // performance of the target device, for TCP and UDP. Note that we
  // are only interested in the send/recv performance of the target device.
  addIperfTest('ethernet_tcp_send', Protocol.tcp, Direction.deviceToHost);
  addIperfTest('ethernet_tcp_recv', Protocol.tcp, Direction.hostToDevice);
  addIperfTest('ethernet_udp_send', Protocol.udp, Direction.deviceToHost);
  addIperfTest('ethernet_udp_recv', Protocol.udp, Direction.hostToDevice);

  runShardTests(args, tests);
}
