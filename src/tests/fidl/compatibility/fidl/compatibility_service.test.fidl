// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
library fidl.test.compatibility;

using fidl.test.imported as imp;
using zx;

type this_is_a_struct = struct {
    s string;
};

type this_is_an_empty_struct = struct {};

type this_is_a_union = strict union {
    1: s string;
    2: b bool;
};

type this_is_a_table = table {
    1: s string;
};

type this_is_a_xunion = flexible union {
    1: s string;
    2: b bool;
};

type primitive_types = struct {
    b bool;
    i8 int8;
    i16 int16;
    i32 int32;
    i64 int64;
    u8 uint8;
    u16 uint16;
    u32 uint32;
    u64 uint64;
    f32 float32;
    f64 float64;
};

type default_values = struct {
    @allow_deprecated_struct_defaults
    b1 bool = true;
    @allow_deprecated_struct_defaults
    b2 bool = false;
    @allow_deprecated_struct_defaults
    i8 int8 = -23;
    @allow_deprecated_struct_defaults
    i16 int16 = 34;
    @allow_deprecated_struct_defaults
    i32 int32 = -34595;
    @allow_deprecated_struct_defaults
    i64 int64 = 3948038;
    @allow_deprecated_struct_defaults
    u8 uint8 = 0;
    @allow_deprecated_struct_defaults
    u16 uint16 = 348;
    @allow_deprecated_struct_defaults
    u32 uint32 = 9038;
    @allow_deprecated_struct_defaults
    u64 uint64 = 19835;
    @allow_deprecated_struct_defaults
    f32 float32 = 1.30;
    @allow_deprecated_struct_defaults
    f64 float64 = 0.0000054;
    @allow_deprecated_struct_defaults
    s string = "hello";
};

// Arbitrary, but must be small enough such that a single message doesn't exceed
// kMaxMessageSize or kMaxMessageHandles.
const arrays_size uint32 = 3;

type arrays = resource struct {
    b_0 array<bool, 1>;
    i8_0 array<int8, 1>;
    i16_0 array<int16, 1>;
    i32_0 array<int32, 1>;
    i64_0 array<int64, 1>;
    u8_0 array<uint8, 1>;
    u16_0 array<uint16, 1>;
    u32_0 array<uint32, 1>;
    u64_0 array<uint64, 1>;
    f32_0 array<float32, 1>;
    f64_0 array<float64, 1>;
    handle_0 array<zx.Handle, 1>;
    b_1 array<bool, arrays_size>;
    i8_1 array<int8, arrays_size>;
    i16_1 array<int16, arrays_size>;
    i32_1 array<int32, arrays_size>;
    i64_1 array<int64, arrays_size>;
    u8_1 array<uint8, arrays_size>;
    u16_1 array<uint16, arrays_size>;
    u32_1 array<uint32, arrays_size>;
    u64_1 array<uint64, arrays_size>;
    f32_1 array<float32, arrays_size>;
    f64_1 array<float64, arrays_size>;
    handle_1 array<zx.Handle, arrays_size>;
};

type arrays_2d = resource struct {
    b array<array<bool, 2>, arrays_size>;
    i8 array<array<int8, 2>, arrays_size>;
    i16 array<array<int16, 2>, arrays_size>;
    i32 array<array<int32, 2>, arrays_size>;
    i64 array<array<int64, 2>, arrays_size>;
    u8 array<array<uint8, 2>, arrays_size>;
    u16 array<array<uint16, 2>, arrays_size>;
    u32 array<array<uint32, 2>, arrays_size>;
    u64 array<array<uint64, 2>, arrays_size>;
    f32 array<array<float32, 2>, arrays_size>;
    f64 array<array<float64, 2>, arrays_size>;
    handle_handle array<array<zx.Handle, 2>, arrays_size>;
};

// Arbitrary, but must be small enough such that a single message doesn't exceed
// kMaxMessageSize or kMaxMessageHandles.
const vectors_size uint32 = 3;

type vectors = resource struct {
    b_0 vector<bool>;
    i8_0 vector<int8>;
    i16_0 vector<int16>;
    i32_0 vector<int32>;
    i64_0 vector<int64>;
    u8_0 vector<uint8>;
    u16_0 vector<uint16>;
    u32_0 vector<uint32>;
    u64_0 vector<uint64>;
    f32_0 vector<float32>;
    f64_0 vector<float64>;
    handle_0 vector<zx.Handle>;
    b_1 vector<vector<bool>:2>;
    i8_1 vector<vector<int8>:2>;
    i16_1 vector<vector<int16>:2>;
    i32_1 vector<vector<int32>:2>;
    i64_1 vector<vector<int64>:2>;
    u8_1 vector<vector<uint8>:2>;
    u16_1 vector<vector<uint16>:2>;
    u32_1 vector<vector<uint32>:2>;
    u64_1 vector<vector<uint64>:2>;
    f32_1 vector<vector<float32>:2>;
    f64_1 vector<vector<float64>:2>;
    handle_1 vector<vector<zx.Handle>:2>;
    b_sized_0 vector<bool>:1;
    i8_sized_0 vector<int8>:1;
    i16_sized_0 vector<int16>:1;
    i32_sized_0 vector<int32>:1;
    i64_sized_0 vector<int64>:1;
    u8_sized_0 vector<uint8>:1;
    u16_sized_0 vector<uint16>:1;
    u32_sized_0 vector<uint32>:1;
    u64_sized_0 vector<uint64>:1;
    f32_sized_0 vector<float32>:1;
    f64_sized_0 vector<float64>:1;
    handle_sized_0 vector<zx.Handle>:1;
    b_sized_1 vector<bool>:vectors_size;
    i8_sized_1 vector<int8>:vectors_size;
    i16_sized_1 vector<int16>:vectors_size;
    i32_sized_1 vector<int32>:vectors_size;
    i64_sized_1 vector<int64>:vectors_size;
    u8_sized_1 vector<uint8>:vectors_size;
    u16_sized_1 vector<uint16>:vectors_size;
    u32_sized_1 vector<uint32>:vectors_size;
    u64_sized_1 vector<uint64>:vectors_size;
    f32_sized_1 vector<float32>:vectors_size;
    f64_sized_1 vector<float64>:vectors_size;
    handle_sized_1 vector<zx.Handle>:vectors_size;
    b_sized_2 vector<vector<bool>:2>:vectors_size;
    i8_sized_2 vector<vector<int8>:2>:vectors_size;
    i16_sized_2 vector<vector<int16>:2>:vectors_size;
    i32_sized_2 vector<vector<int32>:2>:vectors_size;
    i64_sized_2 vector<vector<int64>:2>:vectors_size;
    u8_sized_2 vector<vector<uint8>:2>:vectors_size;
    u16_sized_2 vector<vector<uint16>:2>:vectors_size;
    u32_sized_2 vector<vector<uint32>:2>:vectors_size;
    u64_sized_2 vector<vector<uint64>:2>:vectors_size;
    f32_sized_2 vector<vector<float32>:2>:vectors_size;
    f64_sized_2 vector<vector<float64>:2>:vectors_size;
    handle_sized_2 vector<vector<zx.Handle>:2>:vectors_size;
    b_nullable_0 vector<bool>:<1, optional>;
    i8_nullable_0 vector<int8>:<1, optional>;
    i16_nullable_0 vector<int16>:<1, optional>;
    i32_nullable_0 vector<int32>:<1, optional>;
    i64_nullable_0 vector<int64>:<1, optional>;
    u8_nullable_0 vector<uint8>:<1, optional>;
    u16_nullable_0 vector<uint16>:<1, optional>;
    u32_nullable_0 vector<uint32>:<1, optional>;
    u64_nullable_0 vector<uint64>:<1, optional>;
    f32_nullable_0 vector<float32>:<1, optional>;
    f64_nullable_0 vector<float64>:<1, optional>;
    handle_nullable_0 vector<zx.Handle>:<1, optional>;
    b_nullable_1 vector<vector<bool>:2>:optional;
    i8_nullable_1 vector<vector<int8>:2>:optional;
    i16_nullable_1 vector<vector<int16>:2>:optional;
    i32_nullable_1 vector<vector<int32>:2>:optional;
    i64_nullable_1 vector<vector<int64>:2>:optional;
    u8_nullable_1 vector<vector<uint8>:2>:optional;
    u16_nullable_1 vector<vector<uint16>:2>:optional;
    u32_nullable_1 vector<vector<uint32>:2>:optional;
    u64_nullable_1 vector<vector<uint64>:2>:optional;
    f32_nullable_1 vector<vector<float32>:2>:optional;
    f64_nullable_1 vector<vector<float64>:2>:optional;
    handle_nullable_1 vector<vector<zx.Handle>:2>:optional;
    b_nullable_sized_0 vector<bool>:<1, optional>;
    i8_nullable_sized_0 vector<int8>:<1, optional>;
    i16_nullable_sized_0 vector<int16>:<1, optional>;
    i32_nullable_sized_0 vector<int32>:<1, optional>;
    i64_nullable_sized_0 vector<int64>:<1, optional>;
    u8_nullable_sized_0 vector<uint8>:<1, optional>;
    u16_nullable_sized_0 vector<uint16>:<1, optional>;
    u32_nullable_sized_0 vector<uint32>:<1, optional>;
    u64_nullable_sized_0 vector<uint64>:<1, optional>;
    f32_nullable_sized_0 vector<float32>:<1, optional>;
    f64_nullable_sized_0 vector<float64>:<1, optional>;
    handle_nullable_sized_0 vector<zx.Handle>:<1, optional>;
    b_nullable_sized_1 vector<bool>:<vectors_size, optional>;
    i8_nullable_sized_1 vector<int8>:<vectors_size, optional>;
    i16_nullable_sized_1 vector<int16>:<vectors_size, optional>;
    i32_nullable_sized_1 vector<int32>:<vectors_size, optional>;
    i64_nullable_sized_1 vector<int64>:<vectors_size, optional>;
    u8_nullable_sized_1 vector<uint8>:<vectors_size, optional>;
    u16_nullable_sized_1 vector<uint16>:<vectors_size, optional>;
    u32_nullable_sized_1 vector<uint32>:<vectors_size, optional>;
    u64_nullable_sized_1 vector<uint64>:<vectors_size, optional>;
    f32_nullable_sized_1 vector<float32>:<vectors_size, optional>;
    f64_nullable_sized_1 vector<float64>:<vectors_size, optional>;
    handle_nullable_sized_1 vector<zx.Handle>:<vectors_size, optional>;
    b_nullable_sized_2 vector<vector<bool>:2>:<vectors_size, optional>;
    i8_nullable_sized_2 vector<vector<int8>:2>:<vectors_size, optional>;
    i16_nullable_sized_2 vector<vector<int16>:2>:<vectors_size, optional>;
    i32_nullable_sized_2 vector<vector<int32>:2>:<vectors_size, optional>;
    i64_nullable_sized_2 vector<vector<int64>:2>:<vectors_size, optional>;
    u8_nullable_sized_2 vector<vector<uint8>:2>:<vectors_size, optional>;
    u16_nullable_sized_2 vector<vector<uint16>:2>:<vectors_size, optional>;
    u32_nullable_sized_2 vector<vector<uint32>:2>:<vectors_size, optional>;
    u64_nullable_sized_2 vector<vector<uint64>:2>:<vectors_size, optional>;
    f32_nullable_sized_2 vector<vector<float32>:2>:<vectors_size, optional>;
    f64_nullable_sized_2 vector<vector<float64>:2>:<vectors_size, optional>;
    handle_nullable_sized_2 vector<vector<zx.Handle>:2>:<vectors_size, optional>;
};

// We don't test handle types that don't support duplication
// (supports_duplication in zx/object_traits.h) or that require special
// privileges to create.
type handles = resource struct {
    handle_handle zx.Handle;
    process_handle zx.Handle:PROCESS;
    thread_handle zx.Handle:THREAD;
    vmo_handle zx.Handle:VMO;
    event_handle zx.Handle:EVENT;
    port_handle zx.Handle:PORT;
    socket_handle zx.Handle:SOCKET;
    eventpair_handle zx.Handle:EVENTPAIR;
    job_handle zx.Handle:JOB;
    vmar_handle zx.Handle:VMAR;
    fifo_handle zx.Handle:FIFO;
    timer_handle zx.Handle:TIMER;
    nullable_handle_handle zx.Handle:optional;
    nullable_process_handle zx.Handle:<PROCESS, optional>;
    nullable_thread_handle zx.Handle:<THREAD, optional>;
    nullable_vmo_handle zx.Handle:<VMO, optional>;
    nullable_channel_handle zx.Handle:<CHANNEL, optional>;
    nullable_event_handle zx.Handle:<EVENT, optional>;
    nullable_port_handle zx.Handle:<PORT, optional>;
    nullable_interrupt_handle zx.Handle:<INTERRUPT, optional>;
    nullable_log_handle zx.Handle:<LOG, optional>;
    nullable_socket_handle zx.Handle:<SOCKET, optional>;
    nullable_eventpair_handle zx.Handle:<EVENTPAIR, optional>;
    nullable_job_handle zx.Handle:<JOB, optional>;
    nullable_vmar_handle zx.Handle:<VMAR, optional>;
    nullable_fifo_handle zx.Handle:<FIFO, optional>;
    nullable_timer_handle zx.Handle:<TIMER, optional>;
};

// Arbitrary.
const strings_size uint32 = 32;

type strings = struct {
    s string;
    nullable_s string:optional;
    size_0_s string:2;
    size_1_s string:strings_size;
    nullable_size_0_s string:<2, optional>;
    nullable_size_1_s string:<strings_size, optional>;
};

type default_enum = strict enum {
    kZero = 0;
    kOne = 1;
};

type i8_enum = strict enum : int8 {
    kNegativeOne = -1;
    kOne = 1;
};

type i16_enum = strict enum : int16 {
    kNegativeOne = -1;
    kOne = 1;
    kTwo = 2;
};

type i32_enum = strict enum : int32 {
    kNegativeOne = -1;
    kOne = 1;
    kTwo = 2;
    kThree = 3;
};

type i64_enum = strict enum : int64 {
    kNegativeOne = -1;
    kOne = 1;
    kTwo = 2;
    kThree = 3;
    kFour = 4;
};

type u8_enum = strict enum : uint8 {
    kOne = 1;
    kTwo = 2;
    kThree = 3;
    kFour = 4;
    kFive = 5;
};

type u16_enum = strict enum : uint16 {
    kOne = 1;
    kTwo = 2;
    kThree = 3;
    kFour = 4;
    kFive = 5;
    kSix = 6;
};

type u32_enum = strict enum : uint32 {
    kOne = 1;
    kTwo = 2;
    kThree = 3;
    kFour = 4;
    kFive = 5;
    kSix = 6;
    kSeven = 7;
};

type u64_enum = strict enum : uint64 {
    kOne = 1;
    kTwo = 2;
    kThree = 3;
    kFour = 4;
    kFive = 5;
    kSix = 6;
    kSeven = 7;
    kEight = 8;
};

type default_bits = strict bits {
    kOne = 1;
    kTwo = 2;
};

type u8_bits = strict bits : uint8 {
    kOne = 1;
    kTwo = 2;
    kThree = 4;
    kFour = 8;
    kFive = 16;
};

type u16_bits = strict bits : uint16 {
    kOne = 1;
    kTwo = 2;
    kThree = 4;
    kFour = 8;
    kFive = 16;
    kSix = 32;
};

type u32_bits = strict bits : uint32 {
    kOne = 1;
    kTwo = 2;
    kThree = 4;
    kFour = 8;
    kFive = 16;
    kSix = 32;
    kSeven = 64;
};

type u64_bits = strict bits : uint64 {
    kOne = 1;
    kTwo = 2;
    kThree = 4;
    kFour = 8;
    kFive = 16;
    kSix = 32;
    kSeven = 64;
    kEight = 128;
};

type structs = struct {
    s this_is_a_struct;
    nullable_s box<this_is_a_struct>;
    es this_is_an_empty_struct;
};

type unions = struct {
    u this_is_a_union;
    nullable_u this_is_a_union:optional;
};

// This struct is meant to exercise almost all features of FIDL.
type Struct = resource struct {
    primitive_types primitive_types;
    default_values default_values;
    arrays arrays;
    arrays_2d arrays_2d;
    vectors vectors;
    handles handles;
    strings strings;
    default_enum default_enum;
    i8_enum i8_enum;
    i16_enum i16_enum;
    i32_enum i32_enum;
    i64_enum i64_enum;
    u8_enum u8_enum;
    u16_enum u16_enum;
    u32_enum u32_enum;
    u64_enum u64_enum;
    default_bits default_bits;
    u8_bits u8_bits;
    u16_bits u16_bits;
    u32_bits u32_bits;
    u64_bits u64_bits;
    structs structs;
    unions unions;
    table this_is_a_table;
    xunion this_is_a_xunion;
    b bool;
};

// This struct contains arrays of all different kinds of FIDL types.
type ArraysStruct = resource struct {
    bools array<bool, arrays_size>;
    int8s array<int8, arrays_size>;
    int16s array<int16, arrays_size>;
    int32s array<int32, arrays_size>;
    int64s array<int64, arrays_size>;
    uint8s array<uint8, arrays_size>;
    uint16s array<uint16, arrays_size>;
    uint32s array<uint32, arrays_size>;
    uint64s array<uint64, arrays_size>;
    float32s array<float32, arrays_size>;
    float64s array<float64, arrays_size>;
    enums array<default_enum, arrays_size>;
    bits array<default_bits, arrays_size>;
    handles array<zx.Handle, arrays_size>;
    nullable_handles array<zx.Handle:optional, arrays_size>;
    strings array<string, arrays_size>;
    nullable_strings array<string:optional, arrays_size>;
    structs array<this_is_a_struct, arrays_size>;
    nullable_structs array<box<this_is_a_struct>, arrays_size>;
    unions array<this_is_a_union, arrays_size>;
    nullable_unions array<this_is_a_union:optional, arrays_size>;
    arrays array<array<uint32, arrays_size>, arrays_size>;
    vectors array<vector<uint32>, arrays_size>;
    nullable_vectors array<vector<uint32>:optional, arrays_size>;
    tables array<this_is_a_table, arrays_size>;
    xunions array<this_is_a_xunion, arrays_size>;
};

// This struct contains vectors of all different kinds of FIDL types.
type VectorsStruct = resource struct {
    bools vector<bool>:vectors_size;
    int8s vector<int8>:vectors_size;
    int16s vector<int16>:vectors_size;
    int32s vector<int32>:vectors_size;
    int64s vector<int64>:vectors_size;
    uint8s vector<uint8>:vectors_size;
    uint16s vector<uint16>:vectors_size;
    uint32s vector<uint32>:vectors_size;
    uint64s vector<uint64>:vectors_size;
    float32s vector<float32>:vectors_size;
    float64s vector<float64>:vectors_size;
    enums vector<default_enum>:vectors_size;
    bits vector<default_bits>:vectors_size;
    handles vector<zx.Handle>:vectors_size;
    nullable_handles vector<zx.Handle:optional>:vectors_size;
    strings vector<string>:vectors_size;
    nullable_strings vector<string:optional>:vectors_size;
    structs vector<this_is_a_struct>:vectors_size;
    nullable_structs vector<box<this_is_a_struct>>:vectors_size;
    unions vector<this_is_a_union>:vectors_size;
    nullable_unions vector<this_is_a_union:optional>:vectors_size;
    arrays vector<array<uint32, vectors_size>>:vectors_size;
    vectors vector<vector<uint32>>:vectors_size;
    nullable_vectors vector<vector<uint32>:optional>:vectors_size;
    tables vector<this_is_a_table>:vectors_size;
    xunions vector<this_is_a_xunion>:vectors_size;
};

// This table has members all different FIDL types.
type AllTypesTable = resource table {
    1: bool_member bool;
    2: int8_member int8;
    3: int16_member int16;
    4: int32_member int32;
    5: int64_member int64;
    6: uint8_member uint8;
    7: uint16_member uint16;
    8: uint32_member uint32;
    9: uint64_member uint64;
   10: float32_member float32;
   11: float64_member float64;
   12: enum_member default_enum;
   13: bits_member default_bits;
   14: handle_member zx.Handle;
   15: string_member string;
   16: struct_member this_is_a_struct;
   17: union_member this_is_a_union;
   18: array_member array<uint32, arrays_size>;
   19: vector_member vector<uint32>;
   20: table_member this_is_a_table;
   21: xunion_member this_is_a_xunion;
};

// This xunion has members all different FIDL types.
type AllTypesXunion = flexible resource union {
    1: bool_member bool;
    2: int8_member int8;
    3: int16_member int16;
    4: int32_member int32;
    5: int64_member int64;
    6: uint8_member uint8;
    7: uint16_member uint16;
    8: uint32_member uint32;
    9: uint64_member uint64;
   10: float32_member float32;
   11: float64_member float64;
   12: enum_member default_enum;
   13: bits_member default_bits;
   14: handle_member zx.Handle;
   15: string_member string;
   16: struct_member this_is_a_struct;
   17: union_member this_is_a_union;
   18: array_member array<uint32, arrays_size>;
   19: vector_member vector<uint32>;
   20: table_member this_is_a_table;
   21: xunion_member this_is_a_xunion;
};

type RespondWith = strict enum {
    SUCCESS = 1;
    ERR = 2;
};

type RequestTable = table {
    1: value uint64;
    2: forward_to_server string;
};

type ResponseTable = table {
    1: value uint64;
};

type RequestUnion = flexible union {
    1: unsigned struct {
        value uint64;
        forward_to_server string;
    };
    2: signed struct {
        value int64;
        forward_to_server string;
    };
};

type ResponseUnion = strict union {
    1: unsigned uint64;
    2: signed int64;
};

@discoverable
closed protocol Echo {
    compose imp.Composed;

    // If `forward_to_server` is empty, just returns `value`.
    // If `forward_to_server` is not empty, it is treated as the URL of a server
    // which implements this interface. The server that receives the non-empty
    // `forward_to_server` arg acts as a proxy for that other server.
    // For the error variants: if should_error is true, the provided err result
    // error is sent, otherwise the response variant is sent.
    strict EchoMinimal(struct {
        forward_to_server string;
    }) -> ();
    strict EchoMinimalWithError(struct {
        forward_to_server string;
        result_variant RespondWith;
    }) -> () error uint32;

    // Same as the above, but the server should use the event to return the
    // response, rather than a return value.
    strict EchoMinimalNoRetVal(struct {
        forward_to_server string;
    });
    strict -> EchoMinimalEvent();

    strict EchoStruct(resource struct {
        value Struct;
        forward_to_server string;
    }) -> (resource struct {
        value Struct;
    });
    strict EchoStructWithError(resource struct {
        value Struct;
        result_err default_enum;
        forward_to_server string;
        result_variant RespondWith;
    }) -> (resource struct {
        value Struct;
    }) error default_enum;
    strict EchoStructNoRetVal(resource struct {
        value Struct;
        forward_to_server string;
    });
    strict -> EchoEvent(resource struct {
        value Struct;
    });
    strict EchoArrays(resource struct {
        value ArraysStruct;
        forward_to_server string;
    }) -> (resource struct {
        value ArraysStruct;
    });
    strict EchoArraysWithError(resource struct {
        value ArraysStruct;
        result_err default_enum;
        forward_to_server string;
        result_variant RespondWith;
    }) -> (resource struct {
        value ArraysStruct;
    }) error default_enum;

    strict EchoVectors(resource struct {
        value VectorsStruct;
        forward_to_server string;
    }) -> (resource struct {
        value VectorsStruct;
    });
    strict EchoVectorsWithError(resource struct {
        value VectorsStruct;
        result_err default_enum;
        forward_to_server string;
        result_variant RespondWith;
    }) -> (resource struct {
        value VectorsStruct;
    }) error default_enum;

    strict EchoTable(resource struct {
        value AllTypesTable;
        forward_to_server string;
    }) -> (resource struct {
        value AllTypesTable;
    });
    strict EchoTableWithError(resource struct {
        value AllTypesTable;
        result_err default_enum;
        forward_to_server string;
        result_variant RespondWith;
    }) -> (resource struct {
        value AllTypesTable;
    }) error default_enum;


    // TODO(fxbug.dev/88343): renamed these tests to make clearer the difference between these and
    // the payload tests below.
    strict EchoXunions(resource struct {
        value vector<AllTypesXunion>;
        forward_to_server string;
    }) -> (resource struct {
        value vector<AllTypesXunion>;
    });
    strict EchoXunionsWithError(resource struct {
        value vector<AllTypesXunion>;
        result_err default_enum;
        forward_to_server string;
        result_variant RespondWith;
    }) -> (resource struct {
        value vector<AllTypesXunion>;
    }) error default_enum;

    strict EchoNamedStruct(imp.RequestStruct) -> (imp.ResponseStruct);
    strict EchoNamedStructWithError(imp.ErrorableRequestStruct) -> (imp.ResponseStruct) error uint32;
    strict EchoNamedStructNoRetVal(imp.EventTriggeringRequestStruct);
    strict -> OnEchoNamedEvent(imp.ResponseStruct);

    strict EchoTablePayload(RequestTable) -> (ResponseTable);
    strict EchoTablePayloadWithError(table {
        1: value uint64;
        2: forward_to_server string;
        3: result_err default_enum;
        4: result_variant RespondWith;
    }) -> (ResponseTable) error default_enum;
    strict EchoTablePayloadNoRetVal(RequestTable);
    strict -> OnEchoTablePayloadEvent(ResponseTable);

    strict EchoUnionPayload(RequestUnion) -> (ResponseUnion);
    strict EchoUnionPayloadWithError(flexible union {
        1: unsigned @generated_name("UnsignedErrorable") struct {
            value uint64;
            forward_to_server string;
            result_err default_enum;
            result_variant RespondWith;
        };
        2: signed @generated_name("SignedErrorable") struct {
            value int64;
            forward_to_server string;
            result_err default_enum;
            result_variant RespondWith;
        };
    }) -> (ResponseUnion) error default_enum;
    strict EchoUnionPayloadNoRetVal(RequestUnion);
    strict -> OnEchoUnionPayloadEvent(ResponseUnion);
};
