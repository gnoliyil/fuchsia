# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/board.gni")
import("//build/images/vboot/vboot.gni")
import("//src/firmware/gigaboot/cpp/backends.gni")
import("//zircon/kernel/phys/efi/efi_executable.gni")

config("board_name") {
  cflags = [ "-DBOARD_NAME=\"${board_name}\"" ]
}

source_set("lib") {
  sources = [
    "acpi.h",
    "boot_zbi_items.cc",
    "boot_zbi_items.h",
    "cmdline.cc",
    "cmdline.h",
    "device_path.cc",
    "device_path.h",
    "efi_variables.cc",
    "efi_variables.h",
    "fastboot.cc",
    "fastboot.h",
    "gpt.cc",
    "gpt.h",
    "partition.cc",
    "partition.h",
    "tss2_uefi.cc",
    "tss2_uefi.h",
    "utils.cc",
    "utils.h",
  ]

  public_deps = [
    "//sdk/lib/fit",
    "//sdk/lib/zbi-format",
    "//src/firmware/gigaboot/lib:bootbyte",
    "//src/firmware/lib/fastboot:fastboot-base",
    "//src/firmware/lib/storage",
    "//src/firmware/lib/zbi:in_tree",
    "//src/firmware/lib/zircon_boot:in_tree",
    "//src/lib/utf_conversion",
    "//third_party/tpm2-tss:tss2-rc",
    "//third_party/tpm2-tss:tss2-sys",
    "//zircon/kernel/lib/efi",
    "//zircon/kernel/lib/efi/variable",
    "//zircon/kernel/phys/efi:main",
    "//zircon/kernel/phys/efi:protocol",
    "//zircon/system/ulib/fbl",
    "//zircon/system/ulib/pretty",
    "//zircon/third_party/ulib/cksum",
  ]

  if (is_kernel) {
    public_deps += [
      "//zircon/kernel/lib/ktl",
      "//zircon/kernel/lib/libc",
    ]

    include_dirs = [ "//" ]  # utf_conversion isn't a proper library.
  }

  # UEFI does not require aligned access
  defines = [ "FUCHSIA_FIRMWARE_STORAGE_BUFFER_ALIGNMENT=1" ]
  public_configs = [ ":board_name" ]
}

# Some dependency does not exist in non efi toolchain, which will cause gn
# preprocessing error.
if (is_efi_toolchain) {
  # Backend implementation for the NUC platform
  source_set("backends_nuc") {
    sources = [ "backends_nuc.cc" ]
    deps = [
      "legacy_c_gigaboot",
      "//zircon/system/public",
      "//zircon/system/ulib/fbl:fbl",
    ]
  }

  source_set("gigaboot-main") {
    sources = [
      "fastboot_tcp.cc",
      "fastboot_tcp.h",
      "main.cc",
      "malloc.cc",
      "sysdeps.cc",
      "zircon_boot_ops.cc",
      "zircon_boot_ops.h",
    ]

    deps = [
      ":lib",
      "legacy_c_gigaboot",
      "//src/firmware/lib/zircon_boot:in_tree",
      "//src/lib/zbitl",
      "//zircon/kernel/lib/ktl",
      "//zircon/kernel/lib/libc",
      "//zircon/kernel/phys:boot-zbi",
      "//zircon/kernel/phys:symbolize",
      "//zircon/third_party/ulib/cksum",
      gigaboot_backends,
    ]

    cflags = [ "-DAVB_COMPILATION" ]
  }
}

# A template that assembles a gigaboot esp binary and hardcodes a given
# permanent attributes file to into it.
#
# Parameters
#
#   permanent_attributes_file (required)
#     [path] path label to the permanent attributes file
template("gigaboot_esp") {
  assert(defined(invoker.permanent_attributes_file))

  # Action to convert permanent attributes file to hardcoded array.
  _action_name = target_name + "_convert_to_cc_action"
  action(_action_name) {
    script = "//src/firmware/gigaboot/cpp/permanent_attributes_to_cc.py"
    _out_path = "$target_gen_dir/$target_name/test_perm_attr.cc"
    args = [
      rebase_path(invoker.permanent_attributes_file),
      rebase_path(_out_path, root_build_dir),
    ]
    inputs = [ invoker.permanent_attributes_file ]
    outputs = [ _out_path ]
  }

  # A target that provides API to get the hardcoded permanent attributes and
  # hash
  _permanent_attributes_target = target_name + "_permanent_attributes"
  source_set(_permanent_attributes_target) {
    # Use the source generated by the above action target.
    sources = get_target_outputs(":$_action_name")
    deps = [ ":$_action_name" ]
    if (is_kernel) {
      public_deps = [ "//zircon/kernel/lib/libc" ]
    }
  }

  _efi_target = target_name + "-efi"
  efi_executable(_efi_target) {
    deps = [
      ":$_permanent_attributes_target",
      "//src/firmware/gigaboot/cpp:gigaboot-main",
    ]

    # The LTO toolchain currently fails due to undefined "__chkstk", even though
    # the function is defined in src/firmware/gigaboot/lib/stdlib.c. For now we
    # simply disable the variant.
    exclude_toolchain_tags = [ "lto" ]
  }

  esp(target_name) {
    output_name = target_name

    if (use_gigaboot) {
      gigaboot_target = ":$_efi_target($efi_toolchain)"
      gigaboot_bin = get_label_info("$gigaboot_target", "root_out_dir") + "/" +
                     get_label_info(gigaboot_target, "name") + ".efi"
      metadata = {
        images = [
          {
            label = get_label_info(":$target_name", "label_with_toolchain")
            archive = true
            bootserver_pave = [ "--bootloader" ]
            bootserver_pave_zedboot = [ "--bootloader" ]
            fastboot_flash = [ "fuchsia-esp" ]
            name = "${target_name}.esp"
            path = "${target_name}.esp.blk"
            type = "blk"
          },
        ]
      }
    }
  }
}

gigaboot_esp("fuchsia") {
  permanent_attributes_file = gigaboot_eng_permanent_attributes
}

if (gigaboot_userdebug_permanent_attributes != "") {
  gigaboot_esp("userdebug-esp") {
    permanent_attributes_file = gigaboot_userdebug_permanent_attributes
  }
}

if (gigaboot_user_permanent_attributes != "") {
  gigaboot_esp("user-esp") {
    permanent_attributes_file = gigaboot_user_permanent_attributes
  }
}
