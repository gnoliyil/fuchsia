/* automatically generated by rust-bindgen 0.64.0 */

// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#![allow(non_camel_case_types)]
#![allow(dead_code)]
#![allow(non_upper_case_globals)]

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    _unused: [u8; 0],
}
pub type FILE = __sFILE;
#[doc = " @brief Opaque type for a the uBPF VM."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ubpf_vm {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque type for a uBPF JIT compiled function."]
pub type ubpf_jit_fn = ::std::option::Option<
    unsafe extern "C" fn(mem: *mut ::std::os::raw::c_void, mem_len: usize) -> u64,
>;
extern "C" {
    #[doc = " @brief Create a new uBPF VM.\n\n @return A pointer to the new VM, or NULL on failure."]
    pub fn ubpf_create() -> *mut ubpf_vm;
}
extern "C" {
    #[doc = " @brief Free a uBPF VM.\n\n @param[in] vm The VM to free."]
    pub fn ubpf_destroy(vm: *mut ubpf_vm);
}
extern "C" {
    #[doc = " @brief Enable / disable bounds_check. Bounds check is enabled by default, but it may be too restrictive.\n\n @param[in] vm The VM to enable / disable bounds check on.\n @param[in] enable Enable bounds check if true, disable if false.\n @retval true Bounds check was previously enabled."]
    pub fn ubpf_toggle_bounds_check(vm: *mut ubpf_vm, enable: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Set the function to be invoked if the program hits a fatal error.\n\n @param[in] vm The VM to set the error function on.\n @param[in] error_printf The function to be invoked on fatal error."]
    pub fn ubpf_set_error_print(
        vm: *mut ubpf_vm,
        error_printf: ::std::option::Option<
            unsafe extern "C" fn(
                stream: *mut FILE,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[doc = " @brief Register an external function.\n The immediate field of a CALL instruction is an index into an array of\n functions registered by the user. This API associates a function with\n an index.\n\n @param[in] vm The VM to register the function on.\n @param[in] index The index to register the function at.\n @param[in] name The human readable name of the function.\n @param[in] fn The function to register.\n @retval 0 Success.\n @retval -1 Failure."]
    pub fn ubpf_register(
        vm: *mut ubpf_vm,
        index: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
        fn_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Load code into a VM.\n This must be done before calling ubpf_exec or ubpf_compile and after\n registering all functions.\n\n 'code' should point to eBPF bytecodes and 'code_len' should be the size in\n bytes of that buffer.\n\n @param[in] vm The VM to load the code into.\n @param[in] code The eBPF bytecodes to load.\n @param[in] code_len The length of the eBPF bytecodes.\n @param[out] errmsg The error message, if any. This should be freed by the caller.\n @retval 0 Success.\n @retval -1 Failure."]
    pub fn ubpf_load(
        vm: *mut ubpf_vm,
        code: *const ::std::os::raw::c_void,
        code_len: u32,
        errmsg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Unload code from a VM.\n\n The VM must be reloaded with code before calling ubpf_exec or ubpf_compile.\n\n @param[in] vm The VM to unload the code from."]
    pub fn ubpf_unload_code(vm: *mut ubpf_vm);
}
extern "C" {
    #[doc = " @brief Load code from an ELF file.\n\n This must be done before calling ubpf_exec or ubpf_compile and after\n registering all functions.\n\n 'elf' should point to a copy of an ELF file in memory and 'elf_len' should\n be the size in bytes of that buffer.\n\n The ELF file must be 64-bit little-endian with a single text section\n containing the eBPF bytecodes. This is compatible with the output of\n Clang.\n\n @param[in] vm The VM to load the code into.\n @param[in] elf A pointer to a copy of an ELF file in memory.\n @param[in] elf_len The size of the ELF file.\n @param[out] errmsg The error message, if any. This should be freed by the caller.\n @retval 0 Success.\n @retval -1 Failure."]
    pub fn ubpf_load_elf(
        vm: *mut ubpf_vm,
        elf: *const ::std::os::raw::c_void,
        elf_len: usize,
        errmsg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Execute a BPF program in the VM using the interpreter.\n\n A program must be loaded into the VM and all external functions must be\n registered before calling this function.\n\n @param[in] vm The VM to execute the program in.\n @param[in] mem The memory to pass to the program.\n @param[in] mem_len The length of the memory.\n @param[in] bpf_return_value The value of the r0 register when the program exits.\n @retval 0 Success.\n @retval -1 Failure."]
    pub fn ubpf_exec(
        vm: *const ubpf_vm,
        mem: *mut ::std::os::raw::c_void,
        mem_len: usize,
        bpf_return_value: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Compile a BPF program in the VM to native code.\n\n A program must be loaded into the VM and all external functions must be\n registered before calling this function.\n\n @param[in] vm The VM to compile the program in.\n @param[out] errmsg The error message, if any. This should be freed by the caller.\n @return ubpf_jit_fn A pointer to the compiled program, or NULL on failure."]
    pub fn ubpf_compile(vm: *mut ubpf_vm, errmsg: *mut *mut ::std::os::raw::c_char) -> ubpf_jit_fn;
}
extern "C" {
    #[doc = " @brief Translate the eBPF byte code to x64 machine code.\n\n A program must be loaded into the VM and all external functions must be\n registered before calling this function.\n\n @param[in] vm The VM to translate the program in.\n @param[out] buffer The buffer to store the translated code in.\n @param[in] size The size of the buffer.\n @param[out] errmsg The error message, if any. This should be freed by the caller.\n @retval 0 Success.\n @retval -1 Failure."]
    pub fn ubpf_translate(
        vm: *mut ubpf_vm,
        buffer: *mut u8,
        size: *mut usize,
        errmsg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Instruct the uBPF runtime to apply unwind-on-success semantics to a helper function.\n If the function returns 0, the uBPF runtime will end execution of\n the eBPF program and immediately return control to the caller. This is used\n for implementing function like the \"bpf_tail_call\" helper.\n\n @param[in] vm The VM to set the unwind helper in.\n @param[in] idx Index of the helper function to unwind on success.\n @retval 0 Success.\n @retval -1 Failure."]
    pub fn ubpf_set_unwind_function_index(
        vm: *mut ubpf_vm,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Override the storage location for the BPF registers in the VM.\n\n @param[in] vm The VM to set the register storage in.\n @param[in] regs The register storage."]
    pub fn ubpf_set_registers(vm: *mut ubpf_vm, regs: *mut u64);
}
extern "C" {
    #[doc = " @brief Retrieve the storage location for the BPF registers in the VM.\n\n @param[in] vm The VM to get the register storage from.\n @return uint64_t* A pointer to the register storage."]
    pub fn ubpf_get_registers(vm: *const ubpf_vm) -> *mut u64;
}
extern "C" {
    #[doc = " @brief Optional secret to improve ROP protection.\n\n @param[in] vm The VM to set the secret for.\n @param[in] secret Optional secret to improve ROP protection.\n Returns 0 on success, -1 on error (e.g. if the secret is set after\n the instructions are loaded)."]
    pub fn ubpf_set_pointer_secret(vm: *mut ubpf_vm, secret: u64) -> ::std::os::raw::c_int;
}
