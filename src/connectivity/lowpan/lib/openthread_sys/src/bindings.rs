/* automatically generated by rust-bindgen 0.60.1 */

// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index =
                    if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const OT_LOG_LEVEL_NONE: u32 = 0;
pub const OT_LOG_LEVEL_CRIT: u32 = 1;
pub const OT_LOG_LEVEL_WARN: u32 = 2;
pub const OT_LOG_LEVEL_NOTE: u32 = 3;
pub const OT_LOG_LEVEL_INFO: u32 = 4;
pub const OT_LOG_LEVEL_DEBG: u32 = 5;
pub const OPENTHREAD_API_VERSION: u32 = 306;
pub const OT_UPTIME_STRING_SIZE: u32 = 24;
pub const OT_CRYPTO_SHA256_HASH_SIZE: u32 = 32;
pub const OT_CRYPTO_ECDSA_MAX_DER_SIZE: u32 = 125;
pub const OT_CRYPTO_ECDSA_PUBLIC_KEY_SIZE: u32 = 64;
pub const OT_CRYPTO_ECDSA_SIGNATURE_SIZE: u32 = 64;
pub const OT_CRYPTO_PBDKF2_MAX_SALT_SIZE: u32 = 30;
pub const OT_PANID_BROADCAST: u32 = 65535;
pub const OT_EXT_ADDRESS_SIZE: u32 = 8;
pub const OT_MAC_KEY_SIZE: u32 = 16;
pub const OT_IP6_PREFIX_SIZE: u32 = 8;
pub const OT_IP6_PREFIX_BITSIZE: u32 = 64;
pub const OT_IP6_IID_SIZE: u32 = 8;
pub const OT_IP6_ADDRESS_SIZE: u32 = 16;
pub const OT_IP6_ADDRESS_STRING_SIZE: u32 = 40;
pub const OT_IP6_SOCK_ADDR_STRING_SIZE: u32 = 48;
pub const OT_IP6_PREFIX_STRING_SIZE: u32 = 45;
pub const OT_IP6_MAX_MLR_ADDRESSES: u32 = 15;
pub const OT_NETWORK_DATA_ITERATOR_INIT: u32 = 0;
pub const OT_SERVICE_DATA_MAX_SIZE: u32 = 252;
pub const OT_SERVER_DATA_MAX_SIZE: u32 = 248;
pub const OT_BACKBONE_ROUTER_MULTICAST_LISTENER_ITERATOR_INIT: u32 = 0;
pub const OT_DEFAULT_COAP_PORT: u32 = 5683;
pub const OT_COAP_DEFAULT_TOKEN_LENGTH: u32 = 2;
pub const OT_COAP_MAX_TOKEN_LENGTH: u32 = 8;
pub const OT_COAP_MAX_RETRANSMIT: u32 = 20;
pub const OT_COAP_MIN_ACK_TIMEOUT: u32 = 1000;
pub const OT_DEFAULT_COAP_SECURE_PORT: u32 = 5684;
pub const OT_NETWORK_KEY_SIZE: u32 = 16;
pub const OT_NETWORK_NAME_MAX_SIZE: u32 = 16;
pub const OT_EXT_PAN_ID_SIZE: u32 = 8;
pub const OT_MESH_LOCAL_PREFIX_SIZE: u32 = 8;
pub const OT_PSKC_MAX_SIZE: u32 = 16;
pub const OT_CHANNEL_1_MASK: u32 = 2;
pub const OT_CHANNEL_2_MASK: u32 = 4;
pub const OT_CHANNEL_3_MASK: u32 = 8;
pub const OT_CHANNEL_4_MASK: u32 = 16;
pub const OT_CHANNEL_5_MASK: u32 = 32;
pub const OT_CHANNEL_6_MASK: u32 = 64;
pub const OT_CHANNEL_7_MASK: u32 = 128;
pub const OT_CHANNEL_8_MASK: u32 = 256;
pub const OT_CHANNEL_9_MASK: u32 = 512;
pub const OT_CHANNEL_10_MASK: u32 = 1024;
pub const OT_CHANNEL_11_MASK: u32 = 2048;
pub const OT_CHANNEL_12_MASK: u32 = 4096;
pub const OT_CHANNEL_13_MASK: u32 = 8192;
pub const OT_CHANNEL_14_MASK: u32 = 16384;
pub const OT_CHANNEL_15_MASK: u32 = 32768;
pub const OT_CHANNEL_16_MASK: u32 = 65536;
pub const OT_CHANNEL_17_MASK: u32 = 131072;
pub const OT_CHANNEL_18_MASK: u32 = 262144;
pub const OT_CHANNEL_19_MASK: u32 = 524288;
pub const OT_CHANNEL_20_MASK: u32 = 1048576;
pub const OT_CHANNEL_21_MASK: u32 = 2097152;
pub const OT_CHANNEL_22_MASK: u32 = 4194304;
pub const OT_CHANNEL_23_MASK: u32 = 8388608;
pub const OT_CHANNEL_24_MASK: u32 = 16777216;
pub const OT_CHANNEL_25_MASK: u32 = 33554432;
pub const OT_CHANNEL_26_MASK: u32 = 67108864;
pub const OT_OPERATIONAL_DATASET_MAX_LENGTH: u32 = 254;
pub const OT_JOINER_MAX_DISCERNER_LENGTH: u32 = 64;
pub const OT_COMMISSIONING_PASSPHRASE_MIN_SIZE: u32 = 6;
pub const OT_COMMISSIONING_PASSPHRASE_MAX_SIZE: u32 = 255;
pub const OT_PROVISIONING_URL_MAX_SIZE: u32 = 64;
pub const OT_STEERING_DATA_MAX_LENGTH: u32 = 16;
pub const OT_JOINER_MAX_PSKD_LENGTH: u32 = 32;
pub const OT_DNS_MAX_NAME_SIZE: u32 = 255;
pub const OT_DNS_MAX_LABEL_SIZE: u32 = 64;
pub const OT_DNS_TXT_KEY_MIN_LENGTH: u32 = 1;
pub const OT_DNS_TXT_KEY_MAX_LENGTH: u32 = 9;
pub const OT_ICMP6_HEADER_DATA_SIZE: u32 = 4;
pub const OT_MAC_FILTER_FIXED_RSS_DISABLED: u32 = 127;
pub const OT_MAC_FILTER_ITERATOR_INIT: u32 = 0;
pub const OT_IP4_ADDRESS_SIZE: u32 = 4;
pub const OT_IP4_ADDRESS_STRING_SIZE: u32 = 17;
pub const OT_IP4_CIDR_STRING_SIZE: u32 = 20;
pub const OT_NETWORK_BASE_TLV_MAX_LENGTH: u32 = 254;
pub const OT_NETWORK_MAX_ROUTER_ID: u32 = 62;
pub const OT_NEIGHBOR_INFO_ITERATOR_INIT: u32 = 0;
pub const OT_JOINER_ADVDATA_MAX_LENGTH: u32 = 64;
pub const OT_NETWORK_DIAGNOSTIC_TYPELIST_MAX_ENTRIES: u32 = 19;
pub const OT_NETWORK_DIAGNOSTIC_CHILD_TABLE_ENTRY_SIZE: u32 = 3;
pub const OT_NETWORK_DIAGNOSTIC_ITERATOR_INIT: u32 = 0;
pub const OT_TIME_SYNC_INVALID_SEQ: u32 = 0;
pub const OT_SNTP_DEFAULT_SERVER_IP: &[u8; 19usize] = b"2001:4860:4806:8::\0";
pub const OT_SNTP_DEFAULT_SERVER_PORT: u32 = 123;
pub const OT_TCP_ENDPOINT_TCB_SIZE_BASE: u32 = 368;
pub const OT_TCP_ENDPOINT_TCB_NUM_PTR: u32 = 36;
pub const OT_TCP_RECEIVE_BUFFER_SIZE_FEW_HOPS: u32 = 2598;
pub const OT_TCP_RECEIVE_BUFFER_SIZE_MANY_HOPS: u32 = 4157;
pub const OT_TCP_LISTENER_TCB_SIZE_BASE: u32 = 16;
pub const OT_TCP_LISTENER_TCB_NUM_PTR: u32 = 3;
pub const OT_CHILD_IP6_ADDRESS_ITERATOR_INIT: u32 = 0;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[doc = " No error."]
pub const OT_ERROR_NONE: otError = 0;
#[doc = " Operational failed."]
pub const OT_ERROR_FAILED: otError = 1;
#[doc = " Message was dropped."]
pub const OT_ERROR_DROP: otError = 2;
#[doc = " Insufficient buffers."]
pub const OT_ERROR_NO_BUFS: otError = 3;
#[doc = " No route available."]
pub const OT_ERROR_NO_ROUTE: otError = 4;
#[doc = " Service is busy and could not service the operation."]
pub const OT_ERROR_BUSY: otError = 5;
#[doc = " Failed to parse message."]
pub const OT_ERROR_PARSE: otError = 6;
#[doc = " Input arguments are invalid."]
pub const OT_ERROR_INVALID_ARGS: otError = 7;
#[doc = " Security checks failed."]
pub const OT_ERROR_SECURITY: otError = 8;
#[doc = " Address resolution requires an address query operation."]
pub const OT_ERROR_ADDRESS_QUERY: otError = 9;
#[doc = " Address is not in the source match table."]
pub const OT_ERROR_NO_ADDRESS: otError = 10;
#[doc = " Operation was aborted."]
pub const OT_ERROR_ABORT: otError = 11;
#[doc = " Function or method is not implemented."]
pub const OT_ERROR_NOT_IMPLEMENTED: otError = 12;
#[doc = " Cannot complete due to invalid state."]
pub const OT_ERROR_INVALID_STATE: otError = 13;
#[doc = " No acknowledgment was received after macMaxFrameRetries (IEEE 802.15.4-2006)."]
pub const OT_ERROR_NO_ACK: otError = 14;
#[doc = " A transmission could not take place due to activity on the channel, i.e., the CSMA-CA mechanism has failed"]
#[doc = " (IEEE 802.15.4-2006)."]
pub const OT_ERROR_CHANNEL_ACCESS_FAILURE: otError = 15;
#[doc = " Not currently attached to a Thread Partition."]
pub const OT_ERROR_DETACHED: otError = 16;
#[doc = " FCS check failure while receiving."]
pub const OT_ERROR_FCS: otError = 17;
#[doc = " No frame received."]
pub const OT_ERROR_NO_FRAME_RECEIVED: otError = 18;
#[doc = " Received a frame from an unknown neighbor."]
pub const OT_ERROR_UNKNOWN_NEIGHBOR: otError = 19;
#[doc = " Received a frame from an invalid source address."]
pub const OT_ERROR_INVALID_SOURCE_ADDRESS: otError = 20;
#[doc = " Received a frame filtered by the address filter (allowlisted or denylisted)."]
pub const OT_ERROR_ADDRESS_FILTERED: otError = 21;
#[doc = " Received a frame filtered by the destination address check."]
pub const OT_ERROR_DESTINATION_ADDRESS_FILTERED: otError = 22;
#[doc = " The requested item could not be found."]
pub const OT_ERROR_NOT_FOUND: otError = 23;
#[doc = " The operation is already in progress."]
pub const OT_ERROR_ALREADY: otError = 24;
#[doc = " The creation of IPv6 address failed."]
pub const OT_ERROR_IP6_ADDRESS_CREATION_FAILURE: otError = 26;
#[doc = " Operation prevented by mode flags"]
pub const OT_ERROR_NOT_CAPABLE: otError = 27;
#[doc = " Coap response or acknowledgment or DNS, SNTP response not received."]
pub const OT_ERROR_RESPONSE_TIMEOUT: otError = 28;
#[doc = " Received a duplicated frame."]
pub const OT_ERROR_DUPLICATED: otError = 29;
#[doc = " Message is being dropped from reassembly list due to timeout."]
pub const OT_ERROR_REASSEMBLY_TIMEOUT: otError = 30;
#[doc = " Message is not a TMF Message."]
pub const OT_ERROR_NOT_TMF: otError = 31;
#[doc = " Received a non-lowpan data frame."]
pub const OT_ERROR_NOT_LOWPAN_DATA_FRAME: otError = 32;
#[doc = " The link margin was too low."]
pub const OT_ERROR_LINK_MARGIN_LOW: otError = 34;
#[doc = " Input (CLI) command is invalid."]
pub const OT_ERROR_INVALID_COMMAND: otError = 35;
#[doc = " Special error code used to indicate success/error status is pending and not yet known."]
#[doc = ""]
pub const OT_ERROR_PENDING: otError = 36;
#[doc = " Request rejected."]
pub const OT_ERROR_REJECTED: otError = 37;
#[doc = " The number of defined errors."]
pub const OT_NUM_ERRORS: otError = 38;
#[doc = " Generic error (should not use)."]
pub const OT_ERROR_GENERIC: otError = 255;
#[doc = " This enumeration represents error codes used throughout OpenThread."]
#[doc = ""]
pub type otError = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function converts an otError enum into a string."]
    #[doc = ""]
    #[doc = " @param[in]  aError     An otError enum."]
    #[doc = ""]
    #[doc = " @returns  A string representation of an otError."]
    #[doc = ""]
    pub fn otThreadErrorToString(aError: otError) -> *const ::std::os::raw::c_char;
}
pub type va_list = __builtin_va_list;
#[doc = " This type represents the log level."]
#[doc = ""]
pub type otLogLevel = ::std::os::raw::c_int;
#[doc = "< OpenThread API"]
pub const OT_LOG_REGION_API: otLogRegion = 1;
#[doc = "< MLE"]
pub const OT_LOG_REGION_MLE: otLogRegion = 2;
#[doc = "< EID-to-RLOC mapping."]
pub const OT_LOG_REGION_ARP: otLogRegion = 3;
#[doc = "< Network Data"]
pub const OT_LOG_REGION_NET_DATA: otLogRegion = 4;
#[doc = "< ICMPv6"]
pub const OT_LOG_REGION_ICMP: otLogRegion = 5;
#[doc = "< IPv6"]
pub const OT_LOG_REGION_IP6: otLogRegion = 6;
#[doc = "< TCP"]
pub const OT_LOG_REGION_TCP: otLogRegion = 7;
#[doc = "< IEEE 802.15.4 MAC"]
pub const OT_LOG_REGION_MAC: otLogRegion = 8;
#[doc = "< Memory"]
pub const OT_LOG_REGION_MEM: otLogRegion = 9;
#[doc = "< NCP"]
pub const OT_LOG_REGION_NCP: otLogRegion = 10;
#[doc = "< Mesh Commissioning Protocol"]
pub const OT_LOG_REGION_MESH_COP: otLogRegion = 11;
#[doc = "< Network Diagnostic"]
pub const OT_LOG_REGION_NET_DIAG: otLogRegion = 12;
#[doc = "< Platform"]
pub const OT_LOG_REGION_PLATFORM: otLogRegion = 13;
#[doc = "< CoAP"]
pub const OT_LOG_REGION_COAP: otLogRegion = 14;
#[doc = "< CLI"]
pub const OT_LOG_REGION_CLI: otLogRegion = 15;
#[doc = "< OpenThread Core"]
pub const OT_LOG_REGION_CORE: otLogRegion = 16;
#[doc = "< Utility module"]
pub const OT_LOG_REGION_UTIL: otLogRegion = 17;
#[doc = "< Backbone Router (available since Thread 1.2)"]
pub const OT_LOG_REGION_BBR: otLogRegion = 18;
#[doc = "< Multicast Listener Registration (available since Thread 1.2)"]
pub const OT_LOG_REGION_MLR: otLogRegion = 19;
#[doc = "< Domain Unicast Address (available since Thread 1.2)"]
pub const OT_LOG_REGION_DUA: otLogRegion = 20;
#[doc = "< Border Router"]
pub const OT_LOG_REGION_BR: otLogRegion = 21;
#[doc = "< Service Registration Protocol (SRP)"]
pub const OT_LOG_REGION_SRP: otLogRegion = 22;
#[doc = "< DNS"]
pub const OT_LOG_REGION_DNS: otLogRegion = 23;
#[doc = " This enumeration represents log regions."]
#[doc = ""]
#[doc = " The support for log region is removed and instead each core module can define its own name to appended to the logs."]
#[doc = " However, the `otLogRegion` enumeration is still defined as before to help with platforms which we may be using it"]
#[doc = " in their `otPlatLog()` implementation. The OT core will always emit all logs with `OT_LOG_REGION_CORE`."]
#[doc = ""]
pub type otLogRegion = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function outputs logs."]
    #[doc = ""]
    #[doc = " Note that the support for log region is removed. The OT core will always emit all logs with `OT_LOG_REGION_CORE`"]
    #[doc = " as @p aLogRegion."]
    #[doc = ""]
    #[doc = " @param[in]  aLogLevel   The log level."]
    #[doc = " @param[in]  aLogRegion  The log region."]
    #[doc = " @param[in]  aFormat     A pointer to the format string."]
    #[doc = " @param[in]  ...         Arguments for the format specification."]
    #[doc = ""]
    pub fn otPlatLog(
        aLogLevel: otLogLevel,
        aLogRegion: otLogRegion,
        aFormat: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " This (optional) platform function outputs a prepared log line."]
    #[doc = ""]
    #[doc = " Note that this function is optional and if not provided by platform layer, a default (weak) implementation is"]
    #[doc = " provided and used by OpenThread core as `otPlatLog(aLogLevel, aLogResion, \"%s\", aLogLine)`."]
    #[doc = ""]
    #[doc = " @param[in]  aLogLevel   The log level."]
    #[doc = " @param[in]  aLogRegion  The log region."]
    #[doc = " @param[in]  aLogLine    A pointer to a log line string."]
    #[doc = ""]
    pub fn otPlatLogLine(
        aLogLevel: otLogLevel,
        aLogRegion: otLogRegion,
        aLogLine: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " This function handles OpenThread log level changes."]
    #[doc = ""]
    #[doc = " This platform function is called whenever the OpenThread log level changes."]
    #[doc = " This platform function is optional since an empty weak implementation has been provided."]
    #[doc = ""]
    #[doc = " @note Only applicable when `OPENTHREAD_CONFIG_LOG_LEVEL_DYNAMIC_ENABLE=1`."]
    #[doc = ""]
    #[doc = " @param[in]  aLogLevel  The new OpenThread log level."]
    #[doc = ""]
    pub fn otPlatLogHandleLevelChanged(aLogLevel: otLogLevel);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otInstance {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " This function initializes the OpenThread library."]
    #[doc = ""]
    #[doc = " This function initializes OpenThread and prepares it for subsequent OpenThread API calls. This function must be"]
    #[doc = " called before any other calls to OpenThread."]
    #[doc = ""]
    #[doc = " This function is available and can only be used when support for multiple OpenThread instances is enabled."]
    #[doc = ""]
    #[doc = " @param[in]     aInstanceBuffer      The buffer for OpenThread to use for allocating the otInstance structure."]
    #[doc = " @param[in,out] aInstanceBufferSize  On input, the size of aInstanceBuffer. On output, if not enough space for"]
    #[doc = "                                     otInstance, the number of bytes required for otInstance."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the new OpenThread instance."]
    #[doc = ""]
    #[doc = " @sa otInstanceFinalize"]
    #[doc = ""]
    pub fn otInstanceInit(
        aInstanceBuffer: *mut ::std::os::raw::c_void,
        aInstanceBufferSize: *mut usize,
    ) -> *mut otInstance;
}
extern "C" {
    #[doc = " This function initializes the static single instance of the OpenThread library."]
    #[doc = ""]
    #[doc = " This function initializes OpenThread and prepares it for subsequent OpenThread API calls. This function must be"]
    #[doc = " called before any other calls to OpenThread."]
    #[doc = ""]
    #[doc = " This function is available and can only be used when support for multiple OpenThread instances is disabled."]
    #[doc = ""]
    #[doc = " @returns A pointer to the single OpenThread instance."]
    #[doc = ""]
    pub fn otInstanceInitSingle() -> *mut otInstance;
}
extern "C" {
    #[doc = " This function indicates whether or not the instance is valid/initialized."]
    #[doc = ""]
    #[doc = " The instance is considered valid if it is acquired and initialized using either `otInstanceInitSingle()` (in single"]
    #[doc = " instance case) or `otInstanceInit()` (in multi instance case). A subsequent call to `otInstanceFinalize()` causes"]
    #[doc = " the instance to be considered as uninitialized."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns TRUE if the given instance is valid/initialized, FALSE otherwise."]
    #[doc = ""]
    pub fn otInstanceIsInitialized(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function disables the OpenThread library."]
    #[doc = ""]
    #[doc = " Call this function when OpenThread is no longer in use."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otInstanceFinalize(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function returns the current instance uptime (in msec)."]
    #[doc = ""]
    #[doc = " This function requires `OPENTHREAD_CONFIG_UPTIME_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " The uptime is given as number of milliseconds since OpenThread instance was initialized."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The uptime (number of milliseconds)."]
    #[doc = ""]
    pub fn otInstanceGetUptime(aInstance: *mut otInstance) -> u64;
}
extern "C" {
    #[doc = " This function returns the current instance uptime as a human-readable string."]
    #[doc = ""]
    #[doc = " This function requires `OPENTHREAD_CONFIG_UPTIME_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " The string follows the format \"<hh>:<mm>:<ss>.<mmmm>\" for hours, minutes, seconds and millisecond (if uptime is"]
    #[doc = " shorter than one day) or \"<dd>d.<hh>:<mm>:<ss>.<mmmm>\" (if longer than a day)."]
    #[doc = ""]
    #[doc = " If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated"]
    #[doc = " but the outputted string is always null-terminated."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[out] aBuffer   A pointer to a char array to output the string."]
    #[doc = " @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_UPTIME_STRING_SIZE`."]
    #[doc = ""]
    pub fn otInstanceGetUptimeAsString(
        aInstance: *mut otInstance,
        aBuffer: *mut ::std::os::raw::c_char,
        aSize: u16,
    );
}
#[doc = "< IPv6 address was added"]
pub const OT_CHANGED_IP6_ADDRESS_ADDED: _bindgen_ty_1 = 1;
#[doc = "< IPv6 address was removed"]
pub const OT_CHANGED_IP6_ADDRESS_REMOVED: _bindgen_ty_1 = 2;
#[doc = "< Role (disabled, detached, child, router, leader) changed"]
pub const OT_CHANGED_THREAD_ROLE: _bindgen_ty_1 = 4;
#[doc = "< The link-local address changed"]
pub const OT_CHANGED_THREAD_LL_ADDR: _bindgen_ty_1 = 8;
#[doc = "< The mesh-local address changed"]
pub const OT_CHANGED_THREAD_ML_ADDR: _bindgen_ty_1 = 16;
#[doc = "< RLOC was added"]
pub const OT_CHANGED_THREAD_RLOC_ADDED: _bindgen_ty_1 = 32;
#[doc = "< RLOC was removed"]
pub const OT_CHANGED_THREAD_RLOC_REMOVED: _bindgen_ty_1 = 64;
#[doc = "< Partition ID changed"]
pub const OT_CHANGED_THREAD_PARTITION_ID: _bindgen_ty_1 = 128;
#[doc = "< Thread Key Sequence changed"]
pub const OT_CHANGED_THREAD_KEY_SEQUENCE_COUNTER: _bindgen_ty_1 = 256;
#[doc = "< Thread Network Data changed"]
pub const OT_CHANGED_THREAD_NETDATA: _bindgen_ty_1 = 512;
#[doc = "< Child was added"]
pub const OT_CHANGED_THREAD_CHILD_ADDED: _bindgen_ty_1 = 1024;
#[doc = "< Child was removed"]
pub const OT_CHANGED_THREAD_CHILD_REMOVED: _bindgen_ty_1 = 2048;
#[doc = "< Subscribed to a IPv6 multicast address"]
pub const OT_CHANGED_IP6_MULTICAST_SUBSCRIBED: _bindgen_ty_1 = 4096;
#[doc = "< Unsubscribed from a IPv6 multicast address"]
pub const OT_CHANGED_IP6_MULTICAST_UNSUBSCRIBED: _bindgen_ty_1 = 8192;
#[doc = "< Thread network channel changed"]
pub const OT_CHANGED_THREAD_CHANNEL: _bindgen_ty_1 = 16384;
#[doc = "< Thread network PAN Id changed"]
pub const OT_CHANGED_THREAD_PANID: _bindgen_ty_1 = 32768;
#[doc = "< Thread network name changed"]
pub const OT_CHANGED_THREAD_NETWORK_NAME: _bindgen_ty_1 = 65536;
#[doc = "< Thread network extended PAN ID changed"]
pub const OT_CHANGED_THREAD_EXT_PANID: _bindgen_ty_1 = 131072;
#[doc = "< Network key changed"]
pub const OT_CHANGED_NETWORK_KEY: _bindgen_ty_1 = 262144;
#[doc = "< PSKc changed"]
pub const OT_CHANGED_PSKC: _bindgen_ty_1 = 524288;
#[doc = "< Security Policy changed"]
pub const OT_CHANGED_SECURITY_POLICY: _bindgen_ty_1 = 1048576;
#[doc = "< Channel Manager new pending Thread channel changed"]
pub const OT_CHANGED_CHANNEL_MANAGER_NEW_CHANNEL: _bindgen_ty_1 = 2097152;
#[doc = "< Supported channel mask changed"]
pub const OT_CHANGED_SUPPORTED_CHANNEL_MASK: _bindgen_ty_1 = 4194304;
#[doc = "< Commissioner state changed"]
pub const OT_CHANGED_COMMISSIONER_STATE: _bindgen_ty_1 = 8388608;
#[doc = "< Thread network interface state changed"]
pub const OT_CHANGED_THREAD_NETIF_STATE: _bindgen_ty_1 = 16777216;
#[doc = "< Backbone Router state changed"]
pub const OT_CHANGED_THREAD_BACKBONE_ROUTER_STATE: _bindgen_ty_1 = 33554432;
#[doc = "< Local Backbone Router configuration changed"]
pub const OT_CHANGED_THREAD_BACKBONE_ROUTER_LOCAL: _bindgen_ty_1 = 67108864;
#[doc = "< Joiner state changed"]
pub const OT_CHANGED_JOINER_STATE: _bindgen_ty_1 = 134217728;
#[doc = "< Active Operational Dataset changed"]
pub const OT_CHANGED_ACTIVE_DATASET: _bindgen_ty_1 = 268435456;
#[doc = "< Pending Operational Dataset changed"]
pub const OT_CHANGED_PENDING_DATASET: _bindgen_ty_1 = 536870912;
#[doc = "< The state of NAT64 translator changed"]
pub const OT_CHANGED_NAT64_TRANSLATOR_STATE: _bindgen_ty_1 = 1073741824;
#[doc = " This enumeration defines flags that are passed as part of `otStateChangedCallback`."]
#[doc = ""]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " This type represents a bit-field indicating specific state/configuration that has changed. See `OT_CHANGED_*`"]
#[doc = " definitions."]
#[doc = ""]
pub type otChangedFlags = u32;
#[doc = " This function pointer is called to notify certain configuration or state changes within OpenThread."]
#[doc = ""]
#[doc = " @param[in]  aFlags    A bit-field indicating specific state that has changed.  See `OT_CHANGED_*` definitions."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otStateChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(aFlags: otChangedFlags, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function registers a callback to indicate when certain configuration or state changes within OpenThread."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aCallback  A pointer to a function that is called with certain configuration or state changes."]
    #[doc = " @param[in]  aContext   A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Added the callback to the list of callbacks."]
    #[doc = " @retval OT_ERROR_ALREADY  The callback was already registered."]
    #[doc = " @retval OT_ERROR_NO_BUFS  Could not add the callback due to resource constraints."]
    #[doc = ""]
    pub fn otSetStateChangedCallback(
        aInstance: *mut otInstance,
        aCallback: otStateChangedCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function removes a callback to indicate when certain configuration or state changes within OpenThread."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aCallback   A pointer to a function that is called with certain configuration or state changes."]
    #[doc = " @param[in]  aContext    A pointer to application-specific context."]
    #[doc = ""]
    pub fn otRemoveStateChangeCallback(
        aInstance: *mut otInstance,
        aCallback: otStateChangedCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This method triggers a platform reset."]
    #[doc = ""]
    #[doc = " The reset process ensures that all the OpenThread state/info (stored in volatile memory) is erased. Note that the"]
    #[doc = " `otPlatformReset` does not erase any persistent state/info saved in non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otInstanceReset(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Deletes all the settings stored on non-volatile memory, and then triggers a platform reset."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otInstanceFactoryReset(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method resets the internal states of the OpenThread radio stack."]
    #[doc = ""]
    #[doc = " Callbacks and configurations are preserved."]
    #[doc = ""]
    #[doc = " This API is only available under radio builds (`OPENTHREAD_RADIO = 1`)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otInstanceResetRadioStack(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function erases all the OpenThread persistent info (network settings) stored on non-volatile memory."]
    #[doc = " Erase is successful only if the device is in `disabled` state/role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           All persistent info/state was erased successfully."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Device is not in `disabled` state/role."]
    #[doc = ""]
    pub fn otInstanceErasePersistentInfo(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function gets the OpenThread version string."]
    #[doc = ""]
    #[doc = " @returns A pointer to the OpenThread version."]
    #[doc = ""]
    pub fn otGetVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function gets the OpenThread radio version string."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the OpenThread radio version."]
    #[doc = ""]
    pub fn otGetRadioVersionString(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
#[doc = " This structure represents Backbone Router configuration."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otBackboneRouterConfig {
    #[doc = "< Only used when get Primary Backbone Router information in the Thread Network"]
    pub mServer16: u16,
    #[doc = "< Reregistration Delay (in seconds)"]
    pub mReregistrationDelay: u16,
    #[doc = "< Multicast Listener Registration Timeout (in seconds)"]
    pub mMlrTimeout: u32,
    #[doc = "< Sequence Number"]
    pub mSequenceNumber: u8,
}
extern "C" {
    #[doc = " This function gets the Primary Backbone Router information in the Thread Network."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aConfig              A pointer to where to put Primary Backbone Router information."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE              Successfully got Primary Backbone Router information."]
    #[doc = " @retval OT_ERROR_NOT_FOUND         No Primary Backbone Router exists."]
    #[doc = ""]
    pub fn otBackboneRouterGetPrimary(
        aInstance: *mut otInstance,
        aConfig: *mut otBackboneRouterConfig,
    ) -> otError;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMessage {
    _unused: [u8; 0],
}
#[doc = "< Low priority level."]
pub const OT_MESSAGE_PRIORITY_LOW: otMessagePriority = 0;
#[doc = "< Normal priority level."]
pub const OT_MESSAGE_PRIORITY_NORMAL: otMessagePriority = 1;
#[doc = "< High priority level."]
pub const OT_MESSAGE_PRIORITY_HIGH: otMessagePriority = 2;
#[doc = " This enumeration defines the OpenThread message priority levels."]
#[doc = ""]
pub type otMessagePriority = ::std::os::raw::c_uint;
#[doc = " This structure represents a message settings."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMessageSettings {
    #[doc = "< TRUE if the message should be secured at Layer 2."]
    pub mLinkSecurityEnabled: bool,
    #[doc = "< Priority level (MUST be a `OT_MESSAGE_PRIORITY_*` from `otMessagePriority`)."]
    pub mPriority: u8,
}
extern "C" {
    #[doc = " Free an allocated message buffer."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = ""]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = " @sa otMessageWrite"]
    #[doc = ""]
    pub fn otMessageFree(aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " Get the message length in bytes."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = ""]
    #[doc = " @returns The message length in bytes."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = " @sa otMessageWrite"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = ""]
    pub fn otMessageGetLength(aMessage: *const otMessage) -> u16;
}
extern "C" {
    #[doc = " Set the message length in bytes."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = " @param[in]  aLength   A length in bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully set the message length."]
    #[doc = " @retval OT_ERROR_NO_BUFS  No available buffers to grow the message."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = " @sa otMessageWrite"]
    #[doc = ""]
    pub fn otMessageSetLength(aMessage: *mut otMessage, aLength: u16) -> otError;
}
extern "C" {
    #[doc = " Get the message offset in bytes."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = ""]
    #[doc = " @returns The message offset value."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = " @sa otMessageWrite"]
    #[doc = ""]
    pub fn otMessageGetOffset(aMessage: *const otMessage) -> u16;
}
extern "C" {
    #[doc = " Set the message offset in bytes."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = " @param[in]  aOffset   An offset in bytes."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = " @sa otMessageWrite"]
    #[doc = ""]
    pub fn otMessageSetOffset(aMessage: *mut otMessage, aOffset: u16);
}
extern "C" {
    #[doc = " This function indicates whether or not link security is enabled for the message."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = ""]
    #[doc = " @retval TRUE   If link security is enabled."]
    #[doc = " @retval FALSE  If link security is not enabled."]
    #[doc = ""]
    pub fn otMessageIsLinkSecurityEnabled(aMessage: *const otMessage) -> bool;
}
extern "C" {
    #[doc = " This function sets/forces the message to be forwarded using direct transmission."]
    #[doc = " Default setting for a new message is `false`."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = " @param[in]  aEnabled  If `true`, the message is forced to use direct transmission. If `false`, the message follows"]
    #[doc = "                       the normal procedure."]
    #[doc = ""]
    pub fn otMessageSetDirectTransmission(aMessage: *mut otMessage, aEnabled: bool);
}
extern "C" {
    #[doc = " This function returns the average RSS (received signal strength) associated with the message."]
    #[doc = ""]
    #[doc = " @returns The average RSS value (in dBm) or OT_RADIO_RSSI_INVALID if no average RSS is available."]
    #[doc = ""]
    pub fn otMessageGetRss(aMessage: *const otMessage) -> i8;
}
extern "C" {
    #[doc = " Append bytes to a message."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = " @param[in]  aBuf      A pointer to the data to append."]
    #[doc = " @param[in]  aLength   Number of bytes to append."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully appended to the message"]
    #[doc = " @retval OT_ERROR_NO_BUFS  No available buffers to grow the message."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = " @sa otMessageWrite"]
    #[doc = ""]
    pub fn otMessageAppend(
        aMessage: *mut otMessage,
        aBuf: *const ::std::os::raw::c_void,
        aLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Read bytes from a message."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = " @param[in]  aOffset   An offset in bytes."]
    #[doc = " @param[in]  aBuf      A pointer to a buffer that message bytes are read to."]
    #[doc = " @param[in]  aLength   Number of bytes to read."]
    #[doc = ""]
    #[doc = " @returns The number of bytes read."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageWrite"]
    #[doc = ""]
    pub fn otMessageRead(
        aMessage: *const otMessage,
        aOffset: u16,
        aBuf: *mut ::std::os::raw::c_void,
        aLength: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Write bytes to a message."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to a message buffer."]
    #[doc = " @param[in]  aOffset   An offset in bytes."]
    #[doc = " @param[in]  aBuf      A pointer to a buffer that message bytes are written from."]
    #[doc = " @param[in]  aLength   Number of bytes to write."]
    #[doc = ""]
    #[doc = " @returns The number of bytes written."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = " @sa otMessageAppend"]
    #[doc = " @sa otMessageGetLength"]
    #[doc = " @sa otMessageSetLength"]
    #[doc = " @sa otMessageGetOffset"]
    #[doc = " @sa otMessageSetOffset"]
    #[doc = " @sa otMessageRead"]
    #[doc = ""]
    pub fn otMessageWrite(
        aMessage: *mut otMessage,
        aOffset: u16,
        aBuf: *const ::std::os::raw::c_void,
        aLength: u16,
    ) -> ::std::os::raw::c_int;
}
#[doc = " This structure represents an OpenThread message queue."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otMessageQueue {
    #[doc = "< Opaque data used by the implementation."]
    pub mData: *mut ::std::os::raw::c_void,
}
impl Default for otMessageQueue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents information about a message queue."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMessageQueueInfo {
    #[doc = "< Number of messages in the queue."]
    pub mNumMessages: u16,
    #[doc = "< Number of data buffers used by messages in the queue."]
    pub mNumBuffers: u16,
    #[doc = "< Total number of bytes used by all messages in the queue."]
    pub mTotalBytes: u32,
}
#[doc = " This structure represents the message buffer information for different queues used by OpenThread stack."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otBufferInfo {
    #[doc = "< The total number of buffers in the messages pool (0xffff if unknown)."]
    pub mTotalBuffers: u16,
    #[doc = "< The number of free buffers (0xffff if unknown)."]
    pub mFreeBuffers: u16,
    #[doc = " The maximum number of used buffers at the same time since OT stack initialization or last call to"]
    #[doc = " `otMessageResetBufferInfo()`."]
    #[doc = ""]
    pub mMaxUsedBuffers: u16,
    #[doc = "< Info about 6LoWPAN send queue."]
    pub m6loSendQueue: otMessageQueueInfo,
    #[doc = "< Info about 6LoWPAN reassembly queue."]
    pub m6loReassemblyQueue: otMessageQueueInfo,
    #[doc = "< Info about IPv6 send queue."]
    pub mIp6Queue: otMessageQueueInfo,
    #[doc = "< Info about MPL send queue."]
    pub mMplQueue: otMessageQueueInfo,
    #[doc = "< Info about MLE delayed message queue."]
    pub mMleQueue: otMessageQueueInfo,
    #[doc = "< Info about CoAP/TMF send queue."]
    pub mCoapQueue: otMessageQueueInfo,
    #[doc = "< Info about CoAP secure send queue."]
    pub mCoapSecureQueue: otMessageQueueInfo,
    #[doc = "< Info about application CoAP send queue."]
    pub mApplicationCoapQueue: otMessageQueueInfo,
}
extern "C" {
    #[doc = " Initialize the message queue."]
    #[doc = ""]
    #[doc = " This function MUST be called once and only once for a `otMessageQueue` instance before any other `otMessageQueue`"]
    #[doc = " functions. The behavior is undefined if other queue APIs are used with an `otMessageQueue` before it being"]
    #[doc = " initialized or if it is initialized more than once."]
    #[doc = ""]
    #[doc = " @param[in]  aQueue     A pointer to a message queue."]
    #[doc = ""]
    pub fn otMessageQueueInit(aQueue: *mut otMessageQueue);
}
extern "C" {
    #[doc = " This function adds a message to the end of the given message queue."]
    #[doc = ""]
    #[doc = " @param[in]  aQueue    A pointer to the message queue."]
    #[doc = " @param[in]  aMessage  The message to add."]
    #[doc = ""]
    pub fn otMessageQueueEnqueue(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " This function adds a message at the head/front of the given message queue."]
    #[doc = ""]
    #[doc = " @param[in]  aQueue    A pointer to the message queue."]
    #[doc = " @param[in]  aMessage  The message to add."]
    #[doc = ""]
    pub fn otMessageQueueEnqueueAtHead(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " This function removes a message from the given message queue."]
    #[doc = ""]
    #[doc = " @param[in]  aQueue    A pointer to the message queue."]
    #[doc = " @param[in]  aMessage  The message to remove."]
    #[doc = ""]
    pub fn otMessageQueueDequeue(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " This function returns a pointer to the message at the head of the queue."]
    #[doc = ""]
    #[doc = " @param[in]  aQueue    A pointer to a message queue."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the message at the head of queue or NULL if queue is empty."]
    #[doc = ""]
    pub fn otMessageQueueGetHead(aQueue: *mut otMessageQueue) -> *mut otMessage;
}
extern "C" {
    #[doc = " This function returns a pointer to the next message in the queue by iterating forward (from head to tail)."]
    #[doc = ""]
    #[doc = " @param[in]  aQueue    A pointer to a message queue."]
    #[doc = " @param[in]  aMessage  A pointer to current message buffer."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the next message in the queue after `aMessage` or NULL if `aMessage is the tail of queue."]
    #[doc = "           NULL is returned if `aMessage` is not in the queue `aQueue`."]
    #[doc = ""]
    pub fn otMessageQueueGetNext(
        aQueue: *mut otMessageQueue,
        aMessage: *const otMessage,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Get the Message Buffer information."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to the OpenThread instance."]
    #[doc = " @param[out]  aBufferInfo  A pointer where the message buffer information is written."]
    #[doc = ""]
    pub fn otMessageGetBufferInfo(aInstance: *mut otInstance, aBufferInfo: *mut otBufferInfo);
}
extern "C" {
    #[doc = " Reset the Message Buffer information counter tracking the maximum number buffers in use at the same time."]
    #[doc = ""]
    #[doc = " This resets `mMaxUsedBuffers` in `otBufferInfo`."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to the OpenThread instance."]
    #[doc = ""]
    pub fn otMessageResetBufferInfo(aInstance: *mut otInstance);
}
#[doc = "< Key Type: Raw Data."]
pub const OT_CRYPTO_KEY_TYPE_RAW: otCryptoKeyType = 0;
#[doc = "< Key Type: AES."]
pub const OT_CRYPTO_KEY_TYPE_AES: otCryptoKeyType = 1;
#[doc = "< Key Type: HMAC."]
pub const OT_CRYPTO_KEY_TYPE_HMAC: otCryptoKeyType = 2;
#[doc = " This enumeration defines the key types."]
#[doc = ""]
pub type otCryptoKeyType = ::std::os::raw::c_uint;
#[doc = "< Key Algorithm: Vendor Defined."]
pub const OT_CRYPTO_KEY_ALG_VENDOR: otCryptoKeyAlgorithm = 0;
#[doc = "< Key Algorithm: AES ECB."]
pub const OT_CRYPTO_KEY_ALG_AES_ECB: otCryptoKeyAlgorithm = 1;
#[doc = "< Key Algorithm: HMAC SHA-256."]
pub const OT_CRYPTO_KEY_ALG_HMAC_SHA_256: otCryptoKeyAlgorithm = 2;
#[doc = " This enumeration defines the key algorithms."]
#[doc = ""]
pub type otCryptoKeyAlgorithm = ::std::os::raw::c_uint;
#[doc = "< Key Usage: Key Usage is empty."]
pub const OT_CRYPTO_KEY_USAGE_NONE: _bindgen_ty_2 = 0;
#[doc = "< Key Usage: Key can be exported."]
pub const OT_CRYPTO_KEY_USAGE_EXPORT: _bindgen_ty_2 = 1;
#[doc = "< Key Usage: Encryption (vendor defined)."]
pub const OT_CRYPTO_KEY_USAGE_ENCRYPT: _bindgen_ty_2 = 2;
#[doc = "< Key Usage: AES ECB."]
pub const OT_CRYPTO_KEY_USAGE_DECRYPT: _bindgen_ty_2 = 4;
#[doc = "< Key Usage: HMAC SHA-256."]
pub const OT_CRYPTO_KEY_USAGE_SIGN_HASH: _bindgen_ty_2 = 8;
#[doc = " This enumeration defines the key usage flags."]
#[doc = ""]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[doc = "< Key Persistence: Key is volatile."]
pub const OT_CRYPTO_KEY_STORAGE_VOLATILE: otCryptoKeyStorage = 0;
#[doc = "< Key Persistence: Key is persistent."]
pub const OT_CRYPTO_KEY_STORAGE_PERSISTENT: otCryptoKeyStorage = 1;
#[doc = " This enumeration defines the key storage types."]
#[doc = ""]
pub type otCryptoKeyStorage = ::std::os::raw::c_uint;
#[doc = " This datatype represents the key reference."]
#[doc = ""]
pub type otCryptoKeyRef = u32;
#[doc = " @struct otCryptoKey"]
#[doc = ""]
#[doc = " This structure represents the Key Material required for Crypto operations."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCryptoKey {
    #[doc = "< Pointer to the buffer containing key. NULL indicates to use `mKeyRef`."]
    pub mKey: *const u8,
    #[doc = "< The key length in bytes (applicable when `mKey` is not NULL)."]
    pub mKeyLength: u16,
    #[doc = "< The PSA key ref (requires `mKey` to be NULL)."]
    pub mKeyRef: u32,
}
impl Default for otCryptoKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otCryptoContext"]
#[doc = ""]
#[doc = " This structure stores the context object for platform APIs."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCryptoContext {
    #[doc = "< Pointer to the context."]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< The length of the context in bytes."]
    pub mContextSize: u16,
}
impl Default for otCryptoContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otPlatCryptoSha256Hash"]
#[doc = ""]
#[doc = " This structure represents a SHA-256 hash."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otPlatCryptoSha256Hash {
    #[doc = "< Hash bytes."]
    pub m8: [u8; 32usize],
}
#[doc = " @struct otPlatCryptoEcdsaKeyPair"]
#[doc = ""]
#[doc = " This structure represents an ECDSA key pair (public and private keys)."]
#[doc = ""]
#[doc = " The key pair is stored using Distinguished Encoding Rules (DER) format (per RFC 5915)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otPlatCryptoEcdsaKeyPair {
    pub mDerBytes: [u8; 125usize],
    pub mDerLength: u8,
}
impl Default for otPlatCryptoEcdsaKeyPair {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otPlatCryptoEcdsaPublicKey"]
#[doc = ""]
#[doc = " This struct represents a ECDSA public key."]
#[doc = ""]
#[doc = " The public key is stored as a byte sequence representation of an uncompressed curve point (RFC 6605 - sec 4)."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct otPlatCryptoEcdsaPublicKey {
    pub m8: [u8; 64usize],
}
impl Default for otPlatCryptoEcdsaPublicKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otPlatCryptoEcdsaSignature"]
#[doc = ""]
#[doc = " This struct represents an ECDSA signature."]
#[doc = ""]
#[doc = " The signature is encoded as the concatenated binary representation of two MPIs `r` and `s` which are calculated"]
#[doc = " during signing (RFC 6605 - section 4)."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct otPlatCryptoEcdsaSignature {
    pub m8: [u8; 64usize],
}
impl Default for otPlatCryptoEcdsaSignature {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Initialize the Crypto module."]
    #[doc = ""]
    pub fn otPlatCryptoInit();
}
extern "C" {
    #[doc = " Import a key into PSA ITS."]
    #[doc = ""]
    #[doc = " @param[in,out] aKeyRef           Pointer to the key ref to be used for crypto operations."]
    #[doc = " @param[in]     aKeyType          Key Type encoding for the key."]
    #[doc = " @param[in]     aKeyAlgorithm     Key algorithm encoding for the key."]
    #[doc = " @param[in]     aKeyUsage         Key Usage encoding for the key (combinations of `OT_CRYPTO_KEY_USAGE_*`)."]
    #[doc = " @param[in]     aKeyPersistence   Key Persistence for this key"]
    #[doc = " @param[in]     aKey              Actual key to be imported."]
    #[doc = " @param[in]     aKeyLen           Length of the key to be imported."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully imported the key."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to import the key."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aKey was set to NULL."]
    #[doc = ""]
    #[doc = " @note If OT_CRYPTO_KEY_STORAGE_PERSISTENT is passed for aKeyPersistence then @p aKeyRef is input and platform"]
    #[doc = "       should use the given aKeyRef and MUST not change it."]
    #[doc = ""]
    #[doc = "       If OT_CRYPTO_KEY_STORAGE_VOLATILE is passed for aKeyPersistence then @p aKeyRef is output, the initial"]
    #[doc = "       value does not matter and platform API MUST update it to return the new key ref."]
    #[doc = ""]
    #[doc = "       This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled."]
    #[doc = ""]
    pub fn otPlatCryptoImportKey(
        aKeyRef: *mut otCryptoKeyRef,
        aKeyType: otCryptoKeyType,
        aKeyAlgorithm: otCryptoKeyAlgorithm,
        aKeyUsage: ::std::os::raw::c_int,
        aKeyPersistence: otCryptoKeyStorage,
        aKey: *const u8,
        aKeyLen: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " Export a key stored in PSA ITS."]
    #[doc = ""]
    #[doc = " @param[in]   aKeyRef           The key ref to be used for crypto operations."]
    #[doc = " @param[out]  aBuffer           Pointer to the buffer where key needs to be exported."]
    #[doc = " @param[in]   aBufferLen        Length of the buffer passed to store the exported key."]
    #[doc = " @param[out]  aKeyLen           Pointer to return the length of the exported key."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully exported  @p aKeyRef."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to export @p aKeyRef."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aBuffer was NULL"]
    #[doc = ""]
    #[doc = " @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled."]
    #[doc = ""]
    pub fn otPlatCryptoExportKey(
        aKeyRef: otCryptoKeyRef,
        aBuffer: *mut u8,
        aBufferLen: usize,
        aKeyLen: *mut usize,
    ) -> otError;
}
extern "C" {
    #[doc = " Destroy a key stored in PSA ITS."]
    #[doc = ""]
    #[doc = " @param[in]   aKeyRef          The key ref to be destroyed"]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully destroyed the key."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to destroy the key."]
    #[doc = ""]
    #[doc = " @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled."]
    #[doc = ""]
    pub fn otPlatCryptoDestroyKey(aKeyRef: otCryptoKeyRef) -> otError;
}
extern "C" {
    #[doc = " Check if the key ref passed has an associated key in PSA ITS."]
    #[doc = ""]
    #[doc = " @param[in]  aKeyRef          The Key Ref to check."]
    #[doc = ""]
    #[doc = " @retval TRUE                 There is an associated key with @p aKeyRef."]
    #[doc = " @retval FALSE                There is no associated key with @p aKeyRef."]
    #[doc = ""]
    #[doc = " @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled."]
    #[doc = ""]
    pub fn otPlatCryptoHasKey(aKeyRef: otCryptoKeyRef) -> bool;
}
extern "C" {
    #[doc = " Initialize the HMAC operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext          Context for HMAC operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully initialized HMAC operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to initialize HMAC operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    #[doc = " @note The platform driver shall point the context to the correct object such as psa_mac_operation_t or"]
    #[doc = "       mbedtls_md_context_t."]
    #[doc = ""]
    pub fn otPlatCryptoHmacSha256Init(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Uninitialize the HMAC operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext          Context for HMAC operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully uninitialized HMAC operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to uninitialized HMAC operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoHmacSha256Deinit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Start HMAC operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for HMAC operation."]
    #[doc = " @param[in]  aKey               Key material to be used for HMAC operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully started HMAC operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to start HMAC operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoHmacSha256Start(
        aContext: *mut otCryptoContext,
        aKey: *const otCryptoKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Update the HMAC operation with new input."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for HMAC operation."]
    #[doc = " @param[in]  aBuf               A pointer to the input buffer."]
    #[doc = " @param[in]  aBufLength         The length of @p aBuf in bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully updated HMAC with new input operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to update HMAC operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoHmacSha256Update(
        aContext: *mut otCryptoContext,
        aBuf: *const ::std::os::raw::c_void,
        aBufLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Complete the HMAC operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for HMAC operation."]
    #[doc = " @param[out] aBuf               A pointer to the output buffer."]
    #[doc = " @param[in]  aBufLength         The length of @p aBuf in bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully completed HMAC operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to complete HMAC operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoHmacSha256Finish(
        aContext: *mut otCryptoContext,
        aBuf: *mut u8,
        aBufLength: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " Initialise the AES operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for AES operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully Initialised AES operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to Initialise AES operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = " @retval OT_ERROR_NO_BUFS       Cannot allocate the context."]
    #[doc = ""]
    #[doc = " @note The platform driver shall point the context to the correct object such as psa_key_id"]
    #[doc = "       or mbedtls_aes_context_t."]
    #[doc = ""]
    pub fn otPlatCryptoAesInit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Set the key for AES operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for AES operation."]
    #[doc = " @param[out] aKey               Key to use for AES operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully set the key for AES operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to set the key for AES operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoAesSetKey(
        aContext: *mut otCryptoContext,
        aKey: *const otCryptoKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Encrypt the given data."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for AES operation."]
    #[doc = " @param[in]  aInput             Pointer to the input buffer."]
    #[doc = " @param[in]  aOutput            Pointer to the output buffer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully encrypted @p aInput."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to encrypt @p aInput."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey or @p aOutput were NULL"]
    #[doc = ""]
    pub fn otPlatCryptoAesEncrypt(
        aContext: *mut otCryptoContext,
        aInput: *const u8,
        aOutput: *mut u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Free the AES context."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for AES operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully freed AES context."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to free AES context."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoAesFree(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Initialise the HKDF context."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for HKDF operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully Initialised AES operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to Initialise AES operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    #[doc = " @note The platform driver shall point the context to the correct object such as psa_key_derivation_operation_t"]
    #[doc = "       or HmacSha256::Hash"]
    #[doc = ""]
    pub fn otPlatCryptoHkdfInit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Perform HKDF Expand step."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Operation context for HKDF operation."]
    #[doc = " @param[in]  aInfo              Pointer to the Info sequence."]
    #[doc = " @param[in]  aInfoLength        Length of the Info sequence."]
    #[doc = " @param[out] aOutputKey         Pointer to the output Key."]
    #[doc = " @param[in]  aOutputKeyLength   Size of the output key buffer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          HKDF Expand was successful."]
    #[doc = " @retval OT_ERROR_FAILED        HKDF Expand failed."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoHkdfExpand(
        aContext: *mut otCryptoContext,
        aInfo: *const u8,
        aInfoLength: u16,
        aOutputKey: *mut u8,
        aOutputKeyLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Perform HKDF Extract step."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Operation context for HKDF operation."]
    #[doc = " @param[in]  aSalt              Pointer to the Salt for HKDF."]
    #[doc = " @param[in]  aSaltLength        Length of Salt."]
    #[doc = " @param[in]  aInputKey          Pointer to the input key."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          HKDF Extract was successful."]
    #[doc = " @retval OT_ERROR_FAILED        HKDF Extract failed."]
    #[doc = ""]
    pub fn otPlatCryptoHkdfExtract(
        aContext: *mut otCryptoContext,
        aSalt: *const u8,
        aSaltLength: u16,
        aInputKey: *const otCryptoKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Uninitialize the HKDF context."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for HKDF operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully un-initialised HKDF operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to un-initialised HKDF operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoHkdfDeinit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Initialise the SHA-256 operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for SHA-256 operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully initialised SHA-256 operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to initialise SHA-256 operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @note The platform driver shall point the context to the correct object such as psa_hash_operation_t"]
    #[doc = "       or mbedtls_sha256_context."]
    pub fn otPlatCryptoSha256Init(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Uninitialize the SHA-256 operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for SHA-256 operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully un-initialised SHA-256 operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to un-initialised SHA-256 operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoSha256Deinit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Start SHA-256 operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for SHA-256 operation."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully started SHA-256 operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to start SHA-256 operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoSha256Start(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Update SHA-256 operation with new input."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for SHA-256 operation."]
    #[doc = " @param[in]  aBuf               A pointer to the input buffer."]
    #[doc = " @param[in]  aBufLength         The length of @p aBuf in bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully updated SHA-256 with new input operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to update SHA-256 operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoSha256Update(
        aContext: *mut otCryptoContext,
        aBuf: *const ::std::os::raw::c_void,
        aBufLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Finish SHA-256 operation."]
    #[doc = ""]
    #[doc = " @param[in]  aContext           Context for SHA-256 operation."]
    #[doc = " @param[in]  aHash              A pointer to the output buffer, where hash needs to be stored."]
    #[doc = " @param[in]  aHashSize          The length of @p aHash in bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully completed the SHA-256 operation."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to complete SHA-256 operation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aHash was NULL"]
    #[doc = ""]
    pub fn otPlatCryptoSha256Finish(
        aContext: *mut otCryptoContext,
        aHash: *mut u8,
        aHashSize: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Initialize cryptographically-secure pseudorandom number generator (CSPRNG)."]
    #[doc = ""]
    pub fn otPlatCryptoRandomInit();
}
extern "C" {
    #[doc = " Deinitialize cryptographically-secure pseudorandom number generator (CSPRNG)."]
    #[doc = ""]
    pub fn otPlatCryptoRandomDeinit();
}
extern "C" {
    #[doc = " Fills a given buffer with cryptographically secure random bytes."]
    #[doc = ""]
    #[doc = " @param[out] aBuffer            A pointer to a buffer to fill with the random bytes."]
    #[doc = " @param[in]  aSize              Size of buffer (number of bytes to fill)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully filled buffer with random values."]
    #[doc = " @retval OT_ERROR_FAILED        Operation failed."]
    #[doc = ""]
    pub fn otPlatCryptoRandomGet(aBuffer: *mut u8, aSize: u16) -> otError;
}
extern "C" {
    #[doc = " Generate and populate the output buffer with a new ECDSA key-pair."]
    #[doc = ""]
    #[doc = " @param[out] aKeyPair           A pointer to an ECDSA key-pair structure to store the generated key-pair."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          A new key-pair was generated successfully."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for key generation."]
    #[doc = " @retval OT_ERROR_NOT_CAPABLE   Feature not supported."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to generate key-pair."]
    #[doc = ""]
    pub fn otPlatCryptoEcdsaGenerateKey(aKeyPair: *mut otPlatCryptoEcdsaKeyPair) -> otError;
}
extern "C" {
    #[doc = " Get the associated public key from the input context."]
    #[doc = ""]
    #[doc = " @param[in]  aKeyPair           A pointer to an ECDSA key-pair structure where the key-pair is stored."]
    #[doc = " @param[out] aPublicKey         A pointer to an ECDSA public key structure to store the public key."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Public key was retrieved successfully, and @p aBuffer is updated."]
    #[doc = " @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format)."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL."]
    #[doc = ""]
    pub fn otPlatCryptoEcdsaGetPublicKey(
        aKeyPair: *const otPlatCryptoEcdsaKeyPair,
        aPublicKey: *mut otPlatCryptoEcdsaPublicKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Calculate the ECDSA signature for a hashed message using the private key from the input context."]
    #[doc = ""]
    #[doc = " This method uses the deterministic digital signature generation procedure from RFC 6979."]
    #[doc = ""]
    #[doc = " @param[in]  aKeyPair           A pointer to an ECDSA key-pair structure where the key-pair is stored."]
    #[doc = " @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature calculation"]
    #[doc = "                                is stored."]
    #[doc = " @param[out] aSignature         A pointer to an ECDSA signature structure to output the calculated signature."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          The signature was calculated successfully, @p aSignature was updated."]
    #[doc = " @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format)."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature calculation."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL."]
    #[doc = ""]
    pub fn otPlatCryptoEcdsaSign(
        aKeyPair: *const otPlatCryptoEcdsaKeyPair,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *mut otPlatCryptoEcdsaSignature,
    ) -> otError;
}
extern "C" {
    #[doc = " Use the key from the input context to verify the ECDSA signature of a hashed message."]
    #[doc = ""]
    #[doc = " @param[in]  aPublicKey         A pointer to an ECDSA public key structure where the public key for signature"]
    #[doc = "                                verification is stored."]
    #[doc = " @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature verification"]
    #[doc = "                                is stored."]
    #[doc = " @param[in]  aSignature         A pointer to an ECDSA signature structure where the signature value to be verified is"]
    #[doc = "                                stored."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          The signature was verified successfully."]
    #[doc = " @retval OT_ERROR_SECURITY      The signature is invalid."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The key or hash is invalid."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature verification."]
    #[doc = ""]
    pub fn otPlatCryptoEcdsaVerify(
        aPublicKey: *const otPlatCryptoEcdsaPublicKey,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *const otPlatCryptoEcdsaSignature,
    ) -> otError;
}
extern "C" {
    #[doc = " Perform PKCS#5 PBKDF2 using CMAC (AES-CMAC-PRF-128)."]
    #[doc = ""]
    #[doc = " @param[in]     aPassword          Password to use when generating key."]
    #[doc = " @param[in]     aPasswordLen       Length of password."]
    #[doc = " @param[in]     aSalt              Salt to use when generating key."]
    #[doc = " @param[in]     aSaltLen           Length of salt."]
    #[doc = " @param[in]     aIterationCounter  Iteration count."]
    #[doc = " @param[in]     aKeyLen            Length of generated key in bytes."]
    #[doc = " @param[out]    aKey               A pointer to the generated key."]
    #[doc = ""]
    pub fn otPlatCryptoPbkdf2GenerateKey(
        aPassword: *const u8,
        aPasswordLen: u16,
        aSalt: *const u8,
        aSaltLen: u16,
        aIterationCounter: u32,
        aKeyLen: u16,
        aKey: *mut u8,
    );
}
#[doc = "< aMaxPHYPacketSize (IEEE 802.15.4-2006)"]
pub const OT_RADIO_FRAME_MAX_SIZE: _bindgen_ty_3 = 127;
#[doc = "< Minimal size of frame FCS + CONTROL"]
pub const OT_RADIO_FRAME_MIN_SIZE: _bindgen_ty_3 = 3;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_SYMBOLS_PER_OCTET: _bindgen_ty_3 = 2;
#[doc = "< 2.4 GHz IEEE 802.15.4 (bits per second)"]
pub const OT_RADIO_BIT_RATE: _bindgen_ty_3 = 250000;
#[doc = "< Number of bits per octet"]
pub const OT_RADIO_BITS_PER_OCTET: _bindgen_ty_3 = 8;
#[doc = "< The O-QPSK PHY symbol rate when operating in the 780MHz, 915MHz, 2380MHz, 2450MHz"]
pub const OT_RADIO_SYMBOL_RATE: _bindgen_ty_3 = 62500;
#[doc = "< Symbol duration time in unit of microseconds"]
pub const OT_RADIO_SYMBOL_TIME: _bindgen_ty_3 = 16;
#[doc = "< Time for 10 symbols in unit of microseconds"]
pub const OT_RADIO_TEN_SYMBOLS_TIME: _bindgen_ty_3 = 160;
#[doc = "< LQI measurement not supported"]
pub const OT_RADIO_LQI_NONE: _bindgen_ty_3 = 0;
#[doc = "< Invalid or unknown RSSI value"]
pub const OT_RADIO_RSSI_INVALID: _bindgen_ty_3 = 127;
#[doc = "< Invalid or unknown power value"]
pub const OT_RADIO_POWER_INVALID: _bindgen_ty_3 = 127;
#[doc = " @defgroup radio-types Radio Types"]
#[doc = ""]
#[doc = " @brief"]
#[doc = "   This module includes the platform abstraction for a radio frame."]
#[doc = ""]
#[doc = " @{"]
#[doc = ""]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_0: _bindgen_ty_4 = 0;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_0_MASK: _bindgen_ty_4 = 1;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_2: _bindgen_ty_4 = 2;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_2_MASK: _bindgen_ty_4 = 4;
#[doc = " This enumeration defines the channel page."]
#[doc = ""]
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MIN: _bindgen_ty_5 = 1;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MAX: _bindgen_ty_5 = 10;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MASK: _bindgen_ty_5 = 2046;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MIN: _bindgen_ty_5 = 11;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MAX: _bindgen_ty_5 = 26;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MASK: _bindgen_ty_5 = 134215680;
#[doc = " This enumeration defines the frequency band channel range."]
#[doc = ""]
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[doc = " This type represents radio capabilities."]
#[doc = ""]
#[doc = " The value is a bit-field indicating the capabilities supported by the radio. See `OT_RADIO_CAPS_*` definitions."]
#[doc = ""]
pub type otRadioCaps = u8;
#[doc = "< Radio supports no capability."]
pub const OT_RADIO_CAPS_NONE: _bindgen_ty_6 = 0;
#[doc = "< Radio supports AckTime event."]
pub const OT_RADIO_CAPS_ACK_TIMEOUT: _bindgen_ty_6 = 1;
#[doc = "< Radio supports Energy Scans."]
pub const OT_RADIO_CAPS_ENERGY_SCAN: _bindgen_ty_6 = 2;
#[doc = "< Radio supports tx retry logic with collision avoidance (CSMA)."]
pub const OT_RADIO_CAPS_TRANSMIT_RETRIES: _bindgen_ty_6 = 4;
#[doc = "< Radio supports CSMA backoff for frame transmission (but no retry)."]
pub const OT_RADIO_CAPS_CSMA_BACKOFF: _bindgen_ty_6 = 8;
#[doc = "< Radio supports direct transition from sleep to TX with CSMA."]
pub const OT_RADIO_CAPS_SLEEP_TO_TX: _bindgen_ty_6 = 16;
#[doc = "< Radio supports tx security."]
pub const OT_RADIO_CAPS_TRANSMIT_SEC: _bindgen_ty_6 = 32;
#[doc = "< Radio supports tx at specific time."]
pub const OT_RADIO_CAPS_TRANSMIT_TIMING: _bindgen_ty_6 = 64;
#[doc = "< Radio supports rx at specific time."]
pub const OT_RADIO_CAPS_RECEIVE_TIMING: _bindgen_ty_6 = 128;
#[doc = " This enumeration defines constants that are used to indicate different radio capabilities. See `otRadioCaps`."]
#[doc = ""]
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[doc = " This type represents the IEEE 802.15.4 PAN ID."]
#[doc = ""]
pub type otPanId = u16;
#[doc = " This type represents the IEEE 802.15.4 Short Address."]
#[doc = ""]
pub type otShortAddress = u16;
#[doc = "< Size of IE header in bytes."]
pub const OT_IE_HEADER_SIZE: _bindgen_ty_7 = 2;
#[doc = "< Size of CSL IE content in bytes."]
pub const OT_CSL_IE_SIZE: _bindgen_ty_7 = 4;
#[doc = "< Max length for header IE in ACK."]
pub const OT_ACK_IE_MAX_SIZE: _bindgen_ty_7 = 16;
#[doc = "< Max length of Link Metrics data in Vendor-Specific IE."]
pub const OT_ENH_PROBING_IE_DATA_MAX_SIZE: _bindgen_ty_7 = 2;
#[doc = " This enumeration defines constants about size of header IE in ACK."]
#[doc = ""]
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[doc = " @struct otExtAddress"]
#[doc = ""]
#[doc = " This structure represents the IEEE 802.15.4 Extended Address."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otExtAddress {
    #[doc = "< IEEE 802.15.4 Extended Address bytes"]
    pub m8: [u8; 8usize],
}
#[doc = " @struct otMacKey"]
#[doc = ""]
#[doc = " This structure represents a MAC Key."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMacKey {
    #[doc = "< MAC Key bytes."]
    pub m8: [u8; 16usize],
}
#[doc = " This type represents a MAC Key Ref used by PSA."]
#[doc = ""]
pub type otMacKeyRef = otCryptoKeyRef;
#[doc = " @struct otMacKeyMaterial"]
#[doc = ""]
#[doc = " This structure represents a MAC Key."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMacKeyMaterial {
    pub mKeyMaterial: otMacKeyMaterial__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otMacKeyMaterial__bindgen_ty_1 {
    #[doc = "< Reference to the key stored."]
    pub mKeyRef: otMacKeyRef,
    #[doc = "< Key stored as literal."]
    pub mKey: otMacKey,
}
impl Default for otMacKeyMaterial__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otMacKeyMaterial {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Use Literal Keys."]
pub const OT_KEY_TYPE_LITERAL_KEY: otRadioKeyType = 0;
#[doc = "< Use Reference to Key."]
pub const OT_KEY_TYPE_KEY_REF: otRadioKeyType = 1;
#[doc = " This enumeration defines constants about key types."]
#[doc = ""]
pub type otRadioKeyType = ::std::os::raw::c_uint;
#[doc = " This structure represents the IEEE 802.15.4 Header IE (Information Element) related information of a radio frame."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otRadioIeInfo {
    #[doc = "< The time offset to the Thread network time."]
    pub mNetworkTimeOffset: i64,
    #[doc = "< The Time IE offset from the start of PSDU."]
    pub mTimeIeOffset: u8,
    #[doc = "< The Time sync sequence."]
    pub mTimeSyncSeq: u8,
}
#[doc = " This structure represents an IEEE 802.15.4 radio frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRadioFrame {
    #[doc = "< The PSDU."]
    pub mPsdu: *mut u8,
    #[doc = "< Length of the PSDU."]
    pub mLength: u16,
    #[doc = "< Channel used to transmit/receive the frame."]
    pub mChannel: u8,
    #[doc = "< Radio link type - should be ignored by radio driver."]
    pub mRadioType: u8,
    pub mInfo: otRadioFrame__bindgen_ty_1,
}
#[doc = " The union of transmit and receive information for a radio frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union otRadioFrame__bindgen_ty_1 {
    pub mTxInfo: otRadioFrame__bindgen_ty_1__bindgen_ty_1,
    pub mRxInfo: otRadioFrame__bindgen_ty_1__bindgen_ty_2,
}
#[doc = " Structure representing radio frame transmit information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otRadioFrame__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The key material used for AES-CCM frame security."]
    pub mAesKey: *const otMacKeyMaterial,
    #[doc = "< The pointer to the Header IE(s) related information."]
    pub mIeInfo: *mut otRadioIeInfo,
    #[doc = "< The delay time for this transmission (based on `mTxDelayBaseTime`)."]
    pub mTxDelay: u32,
    #[doc = "< The base time for the transmission delay."]
    pub mTxDelayBaseTime: u32,
    #[doc = "< Maximum number of backoffs attempts before declaring CCA failure."]
    pub mMaxCsmaBackoffs: u8,
    #[doc = "< Maximum number of retries allowed after a transmission failure."]
    pub mMaxFrameRetries: u8,
    #[doc = " The RX channel after frame TX is done (after all frame retries - ack received, or timeout, or abort)."]
    #[doc = ""]
    #[doc = " Radio platforms can choose to fully ignore this. OT stack will make sure to call `otPlatRadioReceive()`"]
    #[doc = " with the desired RX channel after a frame TX is done and signaled in `otPlatRadioTxDone()` callback."]
    #[doc = " Radio platforms that don't provide `OT_RADIO_CAPS_TRANSMIT_RETRIES` must always ignore this."]
    #[doc = ""]
    #[doc = " This is intended for situations where there may be delay in interactions between OT stack and radio, as"]
    #[doc = " an example this is used in RCP/host architecture to make sure RCP switches to PAN channel more quickly."]
    #[doc = " In particular, this can help with CSL tx to a sleepy child, where the child may use a different channel"]
    #[doc = " for CSL than the PAN channel. After frame tx, we want the radio/RCP to go back to the PAN channel"]
    #[doc = " quickly to ensure that parent does not miss tx from child afterwards, e.g., child responding to the"]
    #[doc = " earlier CSL transmitted frame from parent using PAN channel while radio still staying on CSL channel."]
    #[doc = ""]
    #[doc = " The switch to the RX channel MUST happen after the frame TX is fully done, i.e., after all retries and"]
    #[doc = " when ack is received (when \"Ack Request\" flag is set on the TX frame) or ack timeout. Note that ack is"]
    #[doc = " expected on the same channel that frame is sent on."]
    #[doc = ""]
    pub mRxChannelAfterTxDone: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u32,
}
impl Default for otRadioFrame__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otRadioFrame__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn mIsHeaderUpdated(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsHeaderUpdated(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsARetx(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsARetx(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mCsmaCaEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCsmaCaEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mCslPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCslPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSecurityProcessed(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSecurityProcessed(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsHeaderUpdated: bool,
        mIsARetx: bool,
        mCsmaCaEnabled: bool,
        mCslPresent: bool,
        mIsSecurityProcessed: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsHeaderUpdated: u8 = unsafe { ::std::mem::transmute(mIsHeaderUpdated) };
            mIsHeaderUpdated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsARetx: u8 = unsafe { ::std::mem::transmute(mIsARetx) };
            mIsARetx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mCsmaCaEnabled: u8 = unsafe { ::std::mem::transmute(mCsmaCaEnabled) };
            mCsmaCaEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mCslPresent: u8 = unsafe { ::std::mem::transmute(mCslPresent) };
            mCslPresent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsSecurityProcessed: u8 = unsafe { ::std::mem::transmute(mIsSecurityProcessed) };
            mIsSecurityProcessed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Structure representing radio frame receive information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otRadioFrame__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " The timestamp when the frame was received in microseconds."]
    #[doc = ""]
    #[doc = " The value SHALL be the time when the SFD was received."]
    #[doc = ""]
    pub mTimestamp: u64,
    #[doc = "< ACK security frame counter (applicable when `mAckedWithSecEnhAck` is set)."]
    pub mAckFrameCounter: u32,
    #[doc = "< ACK security key index (applicable when `mAckedWithSecEnhAck` is set)."]
    pub mAckKeyId: u8,
    #[doc = "< Received signal strength indicator in dBm for received frames."]
    pub mRssi: i8,
    #[doc = "< Link Quality Indicator for received frames."]
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otRadioFrame__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn mAckedWithFramePending(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAckedWithFramePending(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAckedWithSecEnhAck(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAckedWithSecEnhAck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mAckedWithFramePending: bool,
        mAckedWithSecEnhAck: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mAckedWithFramePending: u8 =
                unsafe { ::std::mem::transmute(mAckedWithFramePending) };
            mAckedWithFramePending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mAckedWithSecEnhAck: u8 = unsafe { ::std::mem::transmute(mAckedWithSecEnhAck) };
            mAckedWithSecEnhAck as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for otRadioFrame__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otRadioFrame {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const OT_RADIO_STATE_DISABLED: otRadioState = 0;
pub const OT_RADIO_STATE_SLEEP: otRadioState = 1;
pub const OT_RADIO_STATE_RECEIVE: otRadioState = 2;
pub const OT_RADIO_STATE_TRANSMIT: otRadioState = 3;
pub const OT_RADIO_STATE_INVALID: otRadioState = 255;
#[doc = " This structure represents the state of a radio."]
#[doc = " Initially, a radio is in the Disabled state."]
pub type otRadioState = ::std::os::raw::c_uint;
#[doc = " This structure represents radio coexistence metrics."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otRadioCoexMetrics {
    #[doc = "< Number of grant glitches."]
    pub mNumGrantGlitch: u32,
    #[doc = "< Number of tx requests."]
    pub mNumTxRequest: u32,
    #[doc = "< Number of tx requests while grant was active."]
    pub mNumTxGrantImmediate: u32,
    #[doc = "< Number of tx requests while grant was inactive."]
    pub mNumTxGrantWait: u32,
    #[doc = "< Number of tx requests while grant was inactive that were ultimately granted."]
    pub mNumTxGrantWaitActivated: u32,
    #[doc = "< Number of tx requests while grant was inactive that timed out."]
    pub mNumTxGrantWaitTimeout: u32,
    #[doc = "< Number of tx that were in progress when grant was deactivated."]
    pub mNumTxGrantDeactivatedDuringRequest: u32,
    #[doc = "< Number of tx requests that were not granted within 50us."]
    pub mNumTxDelayedGrant: u32,
    #[doc = "< Average time in usec from tx request to grant."]
    pub mAvgTxRequestToGrantTime: u32,
    #[doc = "< Number of rx requests."]
    pub mNumRxRequest: u32,
    #[doc = "< Number of rx requests while grant was active."]
    pub mNumRxGrantImmediate: u32,
    #[doc = "< Number of rx requests while grant was inactive."]
    pub mNumRxGrantWait: u32,
    #[doc = "< Number of rx requests while grant was inactive that were ultimately granted."]
    pub mNumRxGrantWaitActivated: u32,
    #[doc = "< Number of rx requests while grant was inactive that timed out."]
    pub mNumRxGrantWaitTimeout: u32,
    #[doc = "< Number of rx that were in progress when grant was deactivated."]
    pub mNumRxGrantDeactivatedDuringRequest: u32,
    #[doc = "< Number of rx requests that were not granted within 50us."]
    pub mNumRxDelayedGrant: u32,
    #[doc = "< Average time in usec from rx request to grant."]
    pub mAvgRxRequestToGrantTime: u32,
    #[doc = "< Number of rx requests that completed without receiving grant."]
    pub mNumRxGrantNone: u32,
    #[doc = "< Stats collection stopped due to saturation."]
    pub mStopped: bool,
}
#[doc = " This structure represents what metrics are specified to query."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otLinkMetrics {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otLinkMetrics {
    #[inline]
    pub fn mPduCount(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPduCount(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mLqi(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLqi(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mLinkMargin(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkMargin(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mRssi(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRssi(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mReserved(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mReserved(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPduCount: bool,
        mLqi: bool,
        mLinkMargin: bool,
        mRssi: bool,
        mReserved: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mPduCount: u8 = unsafe { ::std::mem::transmute(mPduCount) };
            mPduCount as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mLqi: u8 = unsafe { ::std::mem::transmute(mLqi) };
            mLqi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mLinkMargin: u8 = unsafe { ::std::mem::transmute(mLinkMargin) };
            mLinkMargin as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mRssi: u8 = unsafe { ::std::mem::transmute(mRssi) };
            mRssi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mReserved: u8 = unsafe { ::std::mem::transmute(mReserved) };
            mReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Get the radio capabilities."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns The radio capability bit vector (see `OT_RADIO_CAP_*` definitions)."]
    #[doc = ""]
    pub fn otPlatRadioGetCaps(aInstance: *mut otInstance) -> otRadioCaps;
}
extern "C" {
    #[doc = " Get the radio version string."]
    #[doc = ""]
    #[doc = " This is an optional radio driver platform function. If not provided by platform radio driver, OpenThread uses"]
    #[doc = " the OpenThread version instead (@sa otGetVersionString())."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns A pointer to the OpenThread radio version."]
    #[doc = ""]
    pub fn otPlatRadioGetVersionString(aInstance: *mut otInstance)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the radio receive sensitivity value."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns The radio receive sensitivity value in dBm."]
    #[doc = ""]
    pub fn otPlatRadioGetReceiveSensitivity(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Gets the factory-assigned IEEE EUI-64 for this interface."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = " @param[out] aIeeeEui64  A pointer to the factory-assigned IEEE EUI-64."]
    #[doc = ""]
    pub fn otPlatRadioGetIeeeEui64(aInstance: *mut otInstance, aIeeeEui64: *mut u8);
}
extern "C" {
    #[doc = " Set the PAN ID for address filtering."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aPanId     The IEEE 802.15.4 PAN ID."]
    #[doc = ""]
    pub fn otPlatRadioSetPanId(aInstance: *mut otInstance, aPanId: otPanId);
}
extern "C" {
    #[doc = " Set the Extended Address for address filtering."]
    #[doc = ""]
    #[doc = " @param[in] aInstance    The OpenThread instance structure."]
    #[doc = " @param[in] aExtAddress  A pointer to the IEEE 802.15.4 Extended Address stored in little-endian byte order."]
    #[doc = ""]
    #[doc = ""]
    pub fn otPlatRadioSetExtendedAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    );
}
extern "C" {
    #[doc = " Set the Short Address for address filtering."]
    #[doc = ""]
    #[doc = " @param[in] aInstance      The OpenThread instance structure."]
    #[doc = " @param[in] aShortAddress  The IEEE 802.15.4 Short Address."]
    #[doc = ""]
    pub fn otPlatRadioSetShortAddress(aInstance: *mut otInstance, aShortAddress: otShortAddress);
}
extern "C" {
    #[doc = " Get the radio's transmit power in dBm."]
    #[doc = ""]
    #[doc = " @note The transmit power returned will be no larger than the power specified in the max power table for"]
    #[doc = " the current channel."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[out] aPower    The transmit power in dBm."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully retrieved the transmit power."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     @p aPower was NULL."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  Transmit power configuration via dBm is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioGetTransmitPower(aInstance: *mut otInstance, aPower: *mut i8) -> otError;
}
extern "C" {
    #[doc = " Set the radio's transmit power in dBm."]
    #[doc = ""]
    #[doc = " @note The real transmit power will be no larger than the power specified in the max power table for"]
    #[doc = " the current channel."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aPower     The transmit power in dBm."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the transmit power."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  Transmit power configuration via dBm is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioSetTransmitPower(aInstance: *mut otInstance, aPower: i8) -> otError;
}
extern "C" {
    #[doc = " Get the radio's CCA ED threshold in dBm measured at antenna connector per IEEE 802.15.4 - 2015 section 10.1.4."]
    #[doc = ""]
    #[doc = " @param[in] aInstance    The OpenThread instance structure."]
    #[doc = " @param[out] aThreshold  The CCA ED threshold in dBm."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully retrieved the CCA ED threshold."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     @p aThreshold was NULL."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  CCA ED threshold configuration via dBm is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioGetCcaEnergyDetectThreshold(
        aInstance: *mut otInstance,
        aThreshold: *mut i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Set the radio's CCA ED threshold in dBm measured at antenna connector per IEEE 802.15.4 - 2015 section 10.1.4."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   The OpenThread instance structure."]
    #[doc = " @param[in] aThreshold  The CCA ED threshold in dBm."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the transmit power."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     Given threshold is out of range."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  CCA ED threshold configuration via dBm is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioSetCcaEnergyDetectThreshold(
        aInstance: *mut otInstance,
        aThreshold: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the external FEM's Rx LNA gain in dBm."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  The OpenThread instance structure."]
    #[doc = " @param[out] aGain     The external FEM's Rx LNA gain in dBm."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully retrieved the external FEM's LNA gain."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     @p aGain was NULL."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  External FEM's LNA setting is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioGetFemLnaGain(aInstance: *mut otInstance, aGain: *mut i8) -> otError;
}
extern "C" {
    #[doc = " Sets the external FEM's Rx LNA gain in dBm."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aGain      The external FEM's Rx LNA gain in dBm."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the external FEM's LNA gain."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  External FEM's LNA gain setting is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioSetFemLnaGain(aInstance: *mut otInstance, aGain: i8) -> otError;
}
extern "C" {
    #[doc = " Get the status of promiscuous mode."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @retval TRUE   Promiscuous mode is enabled."]
    #[doc = " @retval FALSE  Promiscuous mode is disabled."]
    #[doc = ""]
    pub fn otPlatRadioGetPromiscuous(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Enable or disable promiscuous mode."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance The OpenThread instance structure."]
    #[doc = " @param[in]  aEnable   TRUE to enable or FALSE to disable promiscuous mode."]
    #[doc = ""]
    pub fn otPlatRadioSetPromiscuous(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " Update MAC keys and key index"]
    #[doc = ""]
    #[doc = " This function is used when radio provides OT_RADIO_CAPS_TRANSMIT_SEC capability."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aKeyIdMode   The key ID mode."]
    #[doc = " @param[in]   aKeyId       Current MAC key index."]
    #[doc = " @param[in]   aPrevKey     A pointer to the previous MAC key."]
    #[doc = " @param[in]   aCurrKey     A pointer to the current MAC key."]
    #[doc = " @param[in]   aNextKey     A pointer to the next MAC key."]
    #[doc = " @param[in]   aKeyType     Key Type used."]
    #[doc = ""]
    pub fn otPlatRadioSetMacKey(
        aInstance: *mut otInstance,
        aKeyIdMode: u8,
        aKeyId: u8,
        aPrevKey: *const otMacKeyMaterial,
        aCurrKey: *const otMacKeyMaterial,
        aNextKey: *const otMacKeyMaterial,
        aKeyType: otRadioKeyType,
    );
}
extern "C" {
    #[doc = " This method sets the current MAC frame counter value."]
    #[doc = ""]
    #[doc = " This function is used when radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aMacFrameCounter  The MAC frame counter value."]
    #[doc = ""]
    pub fn otPlatRadioSetMacFrameCounter(aInstance: *mut otInstance, aMacFrameCounter: u32);
}
extern "C" {
    #[doc = " This method sets the current MAC frame counter value only if the new given value is larger than the current value."]
    #[doc = ""]
    #[doc = " This function is used when radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aMacFrameCounter  The MAC frame counter value."]
    #[doc = ""]
    pub fn otPlatRadioSetMacFrameCounterIfLarger(aInstance: *mut otInstance, aMacFrameCounter: u32);
}
extern "C" {
    #[doc = " Get the current estimated time (in microseconds) of the radio chip."]
    #[doc = ""]
    #[doc = " This microsecond timer must be a free-running timer. The timer must continue to advance with microsecond precision"]
    #[doc = " even when the radio is in the sleep state."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The current time in microseconds. UINT64_MAX when platform does not support or radio time is not ready."]
    #[doc = ""]
    pub fn otPlatRadioGetNow(aInstance: *mut otInstance) -> u64;
}
extern "C" {
    #[doc = " Get the bus speed in bits/second between the host and the radio chip."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The bus speed in bits/second between the host and the radio chip."]
    #[doc = "          Return 0 when the MAC and above layer and Radio layer resides on the same chip."]
    #[doc = ""]
    pub fn otPlatRadioGetBusSpeed(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Get current state of the radio."]
    #[doc = ""]
    #[doc = " This function is not required by OpenThread. It may be used for debugging and/or application-specific purposes."]
    #[doc = ""]
    #[doc = " @note This function may be not implemented. It does not affect OpenThread."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @return  Current state of the radio."]
    #[doc = ""]
    pub fn otPlatRadioGetState(aInstance: *mut otInstance) -> otRadioState;
}
extern "C" {
    #[doc = " Enable the radio."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully enabled."]
    #[doc = " @retval OT_ERROR_FAILED   The radio could not be enabled."]
    #[doc = ""]
    pub fn otPlatRadioEnable(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Disable the radio."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            Successfully transitioned to Disabled."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   The radio was not in sleep state."]
    #[doc = ""]
    pub fn otPlatRadioDisable(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Check whether radio is enabled or not."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns TRUE if the radio is enabled, FALSE otherwise."]
    #[doc = ""]
    pub fn otPlatRadioIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Transition the radio from Receive to Sleep (turn off the radio)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully transitioned to Sleep."]
    #[doc = " @retval OT_ERROR_BUSY          The radio was transmitting."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The radio was disabled."]
    #[doc = ""]
    pub fn otPlatRadioSleep(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Transition the radio from Sleep to Receive (turn on the radio)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  The OpenThread instance structure."]
    #[doc = " @param[in]  aChannel   The channel to use for receiving."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully transitioned to Receive."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The radio was disabled or transmitting."]
    #[doc = ""]
    pub fn otPlatRadioReceive(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
extern "C" {
    #[doc = " Schedule a radio reception window at a specific time and duration."]
    #[doc = ""]
    #[doc = " @param[in]  aChannel   The radio channel on which to receive."]
    #[doc = " @param[in]  aStart     The receive window start time, in microseconds."]
    #[doc = " @param[in]  aDuration  The receive window duration, in microseconds"]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully scheduled receive window."]
    #[doc = " @retval OT_ERROR_FAILED  The receive window could not be scheduled."]
    pub fn otPlatRadioReceiveAt(
        aInstance: *mut otInstance,
        aChannel: u8,
        aStart: u32,
        aDuration: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread of a received frame."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance The OpenThread instance structure."]
    #[doc = " @param[in]  aFrame    A pointer to the received frame or NULL if the receive operation failed."]
    #[doc = " @param[in]  aError    OT_ERROR_NONE when successfully received a frame,"]
    #[doc = "                       OT_ERROR_ABORT when reception was aborted and a frame was not received,"]
    #[doc = "                       OT_ERROR_NO_BUFS when a frame could not be received due to lack of rx buffer space."]
    #[doc = ""]
    pub fn otPlatRadioReceiveDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread diagnostics module of a received frame."]
    #[doc = ""]
    #[doc = " This function is used when diagnostics is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance The OpenThread instance structure."]
    #[doc = " @param[in]  aFrame    A pointer to the received frame or NULL if the receive operation failed."]
    #[doc = " @param[in]  aError    OT_ERROR_NONE when successfully received a frame,"]
    #[doc = "                       OT_ERROR_ABORT when reception was aborted and a frame was not received,"]
    #[doc = "                       OT_ERROR_NO_BUFS when a frame could not be received due to lack of rx buffer space."]
    #[doc = ""]
    pub fn otPlatDiagRadioReceiveDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " Get the radio transmit frame buffer."]
    #[doc = ""]
    #[doc = " OpenThread forms the IEEE 802.15.4 frame in this buffer then calls `otPlatRadioTransmit()` to request transmission."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns A pointer to the transmit frame buffer."]
    #[doc = ""]
    pub fn otPlatRadioGetTransmitBuffer(aInstance: *mut otInstance) -> *mut otRadioFrame;
}
extern "C" {
    #[doc = " Begin the transmit sequence on the radio."]
    #[doc = ""]
    #[doc = " The caller must form the IEEE 802.15.4 frame in the buffer provided by `otPlatRadioGetTransmitBuffer()` before"]
    #[doc = " requesting transmission.  The channel and transmit power are also included in the otRadioFrame structure."]
    #[doc = ""]
    #[doc = " The transmit sequence consists of:"]
    #[doc = " 1. Transitioning the radio to Transmit from one of the following states:"]
    #[doc = "    - Receive if RX is on when the device is idle or OT_RADIO_CAPS_SLEEP_TO_TX is not supported"]
    #[doc = "    - Sleep if RX is off when the device is idle and OT_RADIO_CAPS_SLEEP_TO_TX is supported."]
    #[doc = " 2. Transmits the psdu on the given channel and at the given transmit power."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aFrame     A pointer to the frame to be transmitted."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully transitioned to Transmit."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The radio was not in the Receive state."]
    #[doc = ""]
    pub fn otPlatRadioTransmit(aInstance: *mut otInstance, aFrame: *mut otRadioFrame) -> otError;
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread that the transmission has started."]
    #[doc = ""]
    #[doc = " @note  This function should be called by the same thread that executes all of the other OpenThread code. It should"]
    #[doc = "        not be called by ISR or any other task."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to the OpenThread instance structure."]
    #[doc = " @param[in]  aFrame     A pointer to the frame that is being transmitted."]
    #[doc = ""]
    pub fn otPlatRadioTxStarted(aInstance: *mut otInstance, aFrame: *mut otRadioFrame);
}
extern "C" {
    #[doc = " The radio driver calls this function to notify OpenThread that the transmit operation has completed,"]
    #[doc = " providing both the transmitted frame and, if applicable, the received ack frame."]
    #[doc = ""]
    #[doc = " When radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability, radio platform layer updates @p aFrame"]
    #[doc = " with the security frame counter and key index values maintained by the radio."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  The OpenThread instance structure."]
    #[doc = " @param[in]  aFrame     A pointer to the frame that was transmitted."]
    #[doc = " @param[in]  aAckFrame  A pointer to the ACK frame, NULL if no ACK was received."]
    #[doc = " @param[in]  aError     OT_ERROR_NONE when the frame was transmitted,"]
    #[doc = "                        OT_ERROR_NO_ACK when the frame was transmitted but no ACK was received,"]
    #[doc = "                        OT_ERROR_CHANNEL_ACCESS_FAILURE tx could not take place due to activity on the channel,"]
    #[doc = "                        OT_ERROR_ABORT when transmission was aborted for other reasons."]
    #[doc = ""]
    pub fn otPlatRadioTxDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aAckFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread diagnostics module that the transmission has completed."]
    #[doc = ""]
    #[doc = " This function is used when diagnostics is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      The OpenThread instance structure."]
    #[doc = " @param[in]  aFrame         A pointer to the frame that was transmitted."]
    #[doc = " @param[in]  aError         OT_ERROR_NONE when the frame was transmitted,"]
    #[doc = "                            OT_ERROR_CHANNEL_ACCESS_FAILURE tx could not take place due to activity on the channel,"]
    #[doc = "                            OT_ERROR_ABORT when transmission was aborted for other reasons."]
    #[doc = ""]
    pub fn otPlatDiagRadioTransmitDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " Get the most recent RSSI measurement."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns The RSSI in dBm when it is valid.  127 when RSSI is invalid."]
    #[doc = ""]
    pub fn otPlatRadioGetRssi(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Begin the energy scan sequence on the radio."]
    #[doc = ""]
    #[doc = " This function is used when radio provides OT_RADIO_CAPS_ENERGY_SCAN capability."]
    #[doc = ""]
    #[doc = " @param[in] aInstance      The OpenThread instance structure."]
    #[doc = " @param[in] aScanChannel   The channel to perform the energy scan on."]
    #[doc = " @param[in] aScanDuration  The duration, in milliseconds, for the channel to be scanned."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully started scanning the channel."]
    #[doc = " @retval OT_ERROR_BUSY             The radio is performing enery scanning."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  The radio doesn't support energy scanning."]
    #[doc = ""]
    pub fn otPlatRadioEnergyScan(
        aInstance: *mut otInstance,
        aScanChannel: u8,
        aScanDuration: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread that the energy scan is complete."]
    #[doc = ""]
    #[doc = " This function is used when radio provides OT_RADIO_CAPS_ENERGY_SCAN capability."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance           The OpenThread instance structure."]
    #[doc = " @param[in]  aEnergyScanMaxRssi  The maximum RSSI encountered on the scanned channel."]
    #[doc = ""]
    pub fn otPlatRadioEnergyScanDone(aInstance: *mut otInstance, aEnergyScanMaxRssi: i8);
}
extern "C" {
    #[doc = " Enable/Disable source address match feature."]
    #[doc = ""]
    #[doc = " The source address match feature controls how the radio layer decides the \"frame pending\" bit for acks sent in"]
    #[doc = " response to data request commands from children."]
    #[doc = ""]
    #[doc = " If disabled, the radio layer must set the \"frame pending\" on all acks to data request commands."]
    #[doc = ""]
    #[doc = " If enabled, the radio layer uses the source address match table to determine whether to set or clear the \"frame"]
    #[doc = " pending\" bit in an ack to a data request command."]
    #[doc = ""]
    #[doc = " The source address match table provides the list of children for which there is a pending frame. Either a short"]
    #[doc = " address or an extended/long address can be added to the source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = " @param[in]  aEnable     Enable/disable source address match feature."]
    #[doc = ""]
    pub fn otPlatRadioEnableSrcMatch(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " Add a short address to the source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      The OpenThread instance structure."]
    #[doc = " @param[in]  aShortAddress  The short address to be added."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE      Successfully added short address to the source match table."]
    #[doc = " @retval OT_ERROR_NO_BUFS   No available entry in the source match table."]
    #[doc = ""]
    pub fn otPlatRadioAddSrcMatchShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: otShortAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Add an extended address to the source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    The OpenThread instance structure."]
    #[doc = " @param[in]  aExtAddress  The extended address to be added stored in little-endian byte order."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE      Successfully added extended address to the source match table."]
    #[doc = " @retval OT_ERROR_NO_BUFS   No available entry in the source match table."]
    #[doc = ""]
    pub fn otPlatRadioAddSrcMatchExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove a short address from the source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      The OpenThread instance structure."]
    #[doc = " @param[in]  aShortAddress  The short address to be removed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE        Successfully removed short address from the source match table."]
    #[doc = " @retval OT_ERROR_NO_ADDRESS  The short address is not in source address match table."]
    #[doc = ""]
    pub fn otPlatRadioClearSrcMatchShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: otShortAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove an extended address from the source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    The OpenThread instance structure."]
    #[doc = " @param[in]  aExtAddress  The extended address to be removed stored in little-endian byte order."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE        Successfully removed the extended address from the source match table."]
    #[doc = " @retval OT_ERROR_NO_ADDRESS  The extended address is not in source address match table."]
    #[doc = ""]
    pub fn otPlatRadioClearSrcMatchExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Clear all short addresses from the source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = ""]
    pub fn otPlatRadioClearSrcMatchShortEntries(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Clear all the extended/long addresses from source address match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = ""]
    pub fn otPlatRadioClearSrcMatchExtEntries(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the radio supported channel mask that the device is allowed to be on."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns The radio supported channel mask."]
    #[doc = ""]
    pub fn otPlatRadioGetSupportedChannelMask(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Gets the radio preferred channel mask that the device prefers to form on."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns The radio preferred channel mask."]
    #[doc = ""]
    pub fn otPlatRadioGetPreferredChannelMask(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Enable the radio coex."]
    #[doc = ""]
    #[doc = " This function is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aEnabled   TRUE to enable the radio coex, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully enabled."]
    #[doc = " @retval OT_ERROR_FAILED   The radio coex could not be enabled."]
    #[doc = ""]
    pub fn otPlatRadioSetCoexEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " Check whether radio coex is enabled or not."]
    #[doc = ""]
    #[doc = " This function is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns TRUE if the radio coex is enabled, FALSE otherwise."]
    #[doc = ""]
    pub fn otPlatRadioIsCoexEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get the radio coexistence metrics."]
    #[doc = ""]
    #[doc = " This function is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     The OpenThread instance structure."]
    #[doc = " @param[out] aCoexMetrics  A pointer to the coexistence metrics structure."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the coex metrics."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aCoexMetrics was NULL."]
    pub fn otPlatRadioGetCoexMetrics(
        aInstance: *mut otInstance,
        aCoexMetrics: *mut otRadioCoexMetrics,
    ) -> otError;
}
extern "C" {
    #[doc = " Enable or disable CSL receiver."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     The OpenThread instance structure."]
    #[doc = " @param[in]  aCslPeriod    CSL period, 0 for disabling CSL."]
    #[doc = " @param[in]  aShortAddr    The short source address of CSL receiver's peer."]
    #[doc = " @param[in]  aExtAddr      The extended source address of CSL receiver's peer."]
    #[doc = ""]
    #[doc = " @note Platforms should use CSL peer addresses to include CSL IE when generating enhanced acks."]
    #[doc = ""]
    #[doc = " @retval  kErrorNotImplemented Radio driver doesn't support CSL."]
    #[doc = " @retval  kErrorFailed         Other platform specific errors."]
    #[doc = " @retval  kErrorNone           Successfully enabled or disabled CSL."]
    #[doc = ""]
    pub fn otPlatRadioEnableCsl(
        aInstance: *mut otInstance,
        aCslPeriod: u32,
        aShortAddr: otShortAddress,
        aExtAddr: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Update CSL sample time in radio driver."]
    #[doc = ""]
    #[doc = " Sample time is stored in radio driver as a copy to calculate phase when sending ACK with CSL IE."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         The OpenThread instance structure."]
    #[doc = " @param[in]  aCslSampleTime    The latest sample time."]
    #[doc = ""]
    pub fn otPlatRadioUpdateCslSampleTime(aInstance: *mut otInstance, aCslSampleTime: u32);
}
extern "C" {
    #[doc = " Get the current accuracy, in units of ± ppm, of the clock used for scheduling CSL operations."]
    #[doc = ""]
    #[doc = " @note Platforms may optimize this value based on operational conditions (i.e.: temperature)."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The current CSL rx/tx scheduling drift, in units of ± ppm."]
    #[doc = ""]
    pub fn otPlatRadioGetCslAccuracy(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " The fixed uncertainty of the Device for scheduling CSL Transmissions in units of 10 microseconds."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The CSL Uncertainty in units of 10 us."]
    #[doc = ""]
    pub fn otPlatRadioGetCslUncertainty(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the max transmit power for a specific channel."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    The OpenThread instance structure."]
    #[doc = " @param[in]  aChannel     The radio channel."]
    #[doc = " @param[in]  aMaxPower    The max power in dBm, passing OT_RADIO_RSSI_INVALID will disable this channel."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented"]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS     The specified channel is not valid."]
    #[doc = " @retval  OT_ERROR_FAILED           Other platform specific errors."]
    #[doc = " @retval  OT_ERROR_NONE             Successfully set max transmit power."]
    #[doc = ""]
    pub fn otPlatRadioSetChannelMaxTransmitPower(
        aInstance: *mut otInstance,
        aChannel: u8,
        aMaxPower: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Set the region code."]
    #[doc = ""]
    #[doc = " The radio region format is the 2-bytes ascii representation of the"]
    #[doc = " ISO 3166 alpha-2 code."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    The OpenThread instance structure."]
    #[doc = " @param[in]  aRegionCode  The radio region."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_FAILED           Other platform specific errors."]
    #[doc = " @retval  OT_ERROR_NONE             Successfully set region code."]
    #[doc = " @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioSetRegion(aInstance: *mut otInstance, aRegionCode: u16) -> otError;
}
extern "C" {
    #[doc = " Get the region code."]
    #[doc = ""]
    #[doc = " The radio region format is the 2-bytes ascii representation of the"]
    #[doc = " ISO 3166 alpha-2 code."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    The OpenThread instance structure."]
    #[doc = " @param[out] aRegionCode  The radio region."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS     @p aRegionCode is nullptr."]
    #[doc = " @retval  OT_ERROR_FAILED           Other platform specific errors."]
    #[doc = " @retval  OT_ERROR_NONE             Successfully got region code."]
    #[doc = " @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioGetRegion(aInstance: *mut otInstance, aRegionCode: *mut u16) -> otError;
}
extern "C" {
    #[doc = " Enable/disable or update Enhanced-ACK Based Probing in radio for a specific Initiator."]
    #[doc = ""]
    #[doc = " After Enhanced-ACK Based Probing is configured by a specific Probing Initiator, the Enhanced-ACK sent to that"]
    #[doc = " node should include Vendor-Specific IE containing Link Metrics data. This method informs the radio to start/stop to"]
    #[doc = " collect Link Metrics data and include Vendor-Specific IE that containing the data in Enhanced-ACK sent to that"]
    #[doc = " Probing Initiator."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     The OpenThread instance structure."]
    #[doc = " @param[in]  aLinkMetrics  This parameter specifies what metrics to query. Per spec 4.11.3.4.4.6, at most 2 metrics"]
    #[doc = "                           can be specified. The probing would be disabled if @p `aLinkMetrics` is bitwise 0."]
    #[doc = " @param[in]  aShortAddress The short address of the Probing Initiator."]
    #[doc = " @param[in]  aExtAddress   The extended source address of the Probing Initiator. @p aExtAddr MUST NOT be `NULL`."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE            Successfully configured the Enhanced-ACK Based Probing."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS    @p aExtAddress is `NULL`."]
    #[doc = " @retval  OT_ERROR_NOT_FOUND       The Initiator indicated by @p aShortAddress is not found when trying to clear."]
    #[doc = " @retval  OT_ERROR_NO_BUFS         No more Initiator can be supported."]
    #[doc = " @retval  OT_ERROR_NOT_IMPLEMENTED The feature is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioConfigureEnhAckProbing(
        aInstance: *mut otInstance,
        aLinkMetrics: otLinkMetrics,
        aShortAddress: otShortAddress,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Add a calibrated power of the specified channel to the power calibration table."]
    #[doc = ""]
    #[doc = " @note This API is an optional radio platform API. It's up to the platform layer to implement it."]
    #[doc = ""]
    #[doc = " The @p aActualPower is the actual measured output power when the parameters of the radio hardware modules"]
    #[doc = " are set to the @p aRawPowerSetting."]
    #[doc = ""]
    #[doc = " The raw power setting is an opaque byte array. OpenThread doesn't define the format of the raw power setting."]
    #[doc = " Its format is radio hardware related and it should be defined by the developers in the platform radio driver."]
    #[doc = " For example, if the radio hardware contains both the radio chip and the FEM chip, the raw power setting can be"]
    #[doc = " a combination of the radio power register and the FEM gain value."]
    #[doc = ""]
    #[doc = " @param[in] aInstance               The OpenThread instance structure."]
    #[doc = " @param[in] aChannel                The radio channel."]
    #[doc = " @param[in] aActualPower            The actual power in 0.01dBm."]
    #[doc = " @param[in] aRawPowerSetting        A pointer to the raw power setting byte array."]
    #[doc = " @param[in] aRawPowerSettingLength  The length of the @p aRawPowerSetting."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully added the calibrated power to the power calibration table."]
    #[doc = " @retval OT_ERROR_NO_BUFS          No available entry in the power calibration table."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     The @p aChannel, @p aActualPower or @p aRawPowerSetting is invalid or the"]
    #[doc = "                                   @p aActualPower already exists in the power calibration table."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This feature is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioAddCalibratedPower(
        aInstance: *mut otInstance,
        aChannel: u8,
        aActualPower: i16,
        aRawPowerSetting: *const u8,
        aRawPowerSettingLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Clear all calibrated powers from the power calibration table."]
    #[doc = ""]
    #[doc = " @note This API is an optional radio platform API. It's up to the platform layer to implement it."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully cleared all calibrated powers from the power calibration table."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This feature is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioClearCalibratedPowers(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Set the target power for the given channel."]
    #[doc = ""]
    #[doc = " @note This API is an optional radio platform API. It's up to the platform layer to implement it."]
    #[doc = "       If this API is implemented, the function `otPlatRadioSetTransmitPower()` should be disabled."]
    #[doc = ""]
    #[doc = " The radio driver should set the actual output power to be less than or equal to the target power and as close"]
    #[doc = " as possible to the target power."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     The OpenThread instance structure."]
    #[doc = " @param[in]  aChannel      The radio channel."]
    #[doc = " @param[in]  aTargetPower  The target power in 0.01dBm. Passing `INT16_MAX` will disable this channel to use the"]
    #[doc = "                           target power."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE             Successfully set the target power."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS     The @p aChannel or @p aTargetPower is invalid."]
    #[doc = " @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented."]
    #[doc = ""]
    pub fn otPlatRadioSetChannelTargetPower(
        aInstance: *mut otInstance,
        aChannel: u8,
        aTargetPower: i16,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the raw power setting for the given channel."]
    #[doc = ""]
    #[doc = " @note OpenThread `src/core/utils` implements a default implementation of the API `otPlatRadioAddCalibratedPower()`,"]
    #[doc = "       `otPlatRadioClearCalibratedPowers()` and `otPlatRadioSetChannelTargetPower()`. This API is provided by"]
    #[doc = "       the default implementation to get the raw power setting for the given channel. If the platform doesn't"]
    #[doc = "       use the default implementation, it can ignore this API."]
    #[doc = ""]
    #[doc = " Platform radio layer should parse the raw power setting based on the radio layer defined format and set the"]
    #[doc = " parameters of each radio hardware module."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance               The OpenThread instance structure."]
    #[doc = " @param[in]      aChannel                The radio channel."]
    #[doc = " @param[out]     aRawPowerSetting        A pointer to the raw power setting byte array."]
    #[doc = " @param[in,out]  aRawPowerSettingLength  On input, a pointer to the size of @p aRawPowerSetting."]
    #[doc = "                                         On output, a pointer to the length of the raw power setting data."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE          Successfully got the target power."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS  The @p aChannel is invalid, @p aRawPowerSetting or @p aRawPowerSettingLength is NULL"]
    #[doc = "                                 or @aRawPowerSettingLength is too short."]
    #[doc = " @retval  OT_ERROR_NOT_FOUND     The raw power setting for the @p aChannel was not found."]
    #[doc = ""]
    pub fn otPlatRadioGetRawPowerSetting(
        aInstance: *mut otInstance,
        aChannel: u8,
        aRawPowerSetting: *mut u8,
        aRawPowerSettingLength: *mut u16,
    ) -> otError;
}
#[doc = " @struct otIp6InterfaceIdentifier"]
#[doc = ""]
#[doc = " This structure represents the Interface Identifier of an IPv6 address."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6InterfaceIdentifier {
    #[doc = "< The Interface Identifier accessor fields"]
    pub mFields: otIp6InterfaceIdentifier__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIp6InterfaceIdentifier__bindgen_ty_1 {
    #[doc = "< 8-bit fields"]
    pub m8: [u8; 8usize],
    #[doc = "< 16-bit fields"]
    pub m16: [u16; 4usize],
    #[doc = "< 32-bit fields"]
    pub m32: [u32; 2usize],
}
impl Default for otIp6InterfaceIdentifier__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otIp6InterfaceIdentifier {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otIp6NetworkPrefix"]
#[doc = ""]
#[doc = " This structure represents the Network Prefix of an IPv6 address (most significant 64 bits of the address)."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otIp6NetworkPrefix {
    #[doc = "< The Network Prefix."]
    pub m8: [u8; 8usize],
}
#[doc = " @struct otIp6AddressComponents"]
#[doc = ""]
#[doc = " This structure represents the components of an IPv6 address."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6AddressComponents {
    #[doc = "< The Network Prefix (most significant 64 bits of the address)"]
    pub mNetworkPrefix: otIp6NetworkPrefix,
    #[doc = "< The Interface Identifier (least significant 64 bits of the address)"]
    pub mIid: otIp6InterfaceIdentifier,
}
impl Default for otIp6AddressComponents {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otIp6Address"]
#[doc = ""]
#[doc = " This structure represents an IPv6 address."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6Address {
    #[doc = "< IPv6 accessor fields"]
    pub mFields: otIp6Address__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIp6Address__bindgen_ty_1 {
    #[doc = "< 8-bit fields"]
    pub m8: [u8; 16usize],
    #[doc = "< 16-bit fields"]
    pub m16: [u16; 8usize],
    #[doc = "< 32-bit fields"]
    pub m32: [u32; 4usize],
    #[doc = "< IPv6 address components"]
    pub mComponents: otIp6AddressComponents,
}
impl Default for otIp6Address__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otIp6Address {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents an IPv6 prefix."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6Prefix {
    #[doc = "< The IPv6 prefix."]
    pub mPrefix: otIp6Address,
    #[doc = "< The IPv6 prefix length (in bits)."]
    pub mLength: u8,
}
impl Default for otIp6Prefix {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Thread assigned address (ALOC, RLOC, MLEID, etc)"]
pub const OT_ADDRESS_ORIGIN_THREAD: _bindgen_ty_8 = 0;
#[doc = "< SLAAC assigned address"]
pub const OT_ADDRESS_ORIGIN_SLAAC: _bindgen_ty_8 = 1;
#[doc = "< DHCPv6 assigned address"]
pub const OT_ADDRESS_ORIGIN_DHCPV6: _bindgen_ty_8 = 2;
#[doc = "< Manually assigned address"]
pub const OT_ADDRESS_ORIGIN_MANUAL: _bindgen_ty_8 = 3;
#[doc = " IPv6 Address origins"]
#[doc = ""]
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[doc = " This structure represents an IPv6 network interface unicast address."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetifAddress {
    #[doc = "< The IPv6 unicast address."]
    pub mAddress: otIp6Address,
    #[doc = "< The Prefix length (in bits)."]
    pub mPrefixLength: u8,
    #[doc = "< The IPv6 address origin."]
    pub mAddressOrigin: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< A pointer to the next network interface address."]
    pub mNext: *mut otNetifAddress,
}
impl Default for otNetifAddress {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otNetifAddress {
    #[inline]
    pub fn mPreferred(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPreferred(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mValid(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mValid(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mScopeOverrideValid(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mScopeOverrideValid(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mScopeOverride(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mScopeOverride(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mRloc(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRloc(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPreferred: bool,
        mValid: bool,
        mScopeOverrideValid: bool,
        mScopeOverride: ::std::os::raw::c_uint,
        mRloc: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mPreferred: u8 = unsafe { ::std::mem::transmute(mPreferred) };
            mPreferred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mValid: u8 = unsafe { ::std::mem::transmute(mValid) };
            mValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mScopeOverrideValid: u8 = unsafe { ::std::mem::transmute(mScopeOverrideValid) };
            mScopeOverrideValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let mScopeOverride: u32 = unsafe { ::std::mem::transmute(mScopeOverride) };
            mScopeOverride as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mRloc: u8 = unsafe { ::std::mem::transmute(mRloc) };
            mRloc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents an IPv6 network interface multicast address."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetifMulticastAddress {
    #[doc = "< The IPv6 multicast address."]
    pub mAddress: otIp6Address,
    #[doc = "< A pointer to the next network interface multicast address."]
    pub mNext: *const otNetifMulticastAddress,
}
impl Default for otNetifMulticastAddress {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents an IPv6 socket address."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otSockAddr {
    #[doc = "< An IPv6 address."]
    pub mAddress: otIp6Address,
    #[doc = "< A transport-layer port."]
    pub mPort: u16,
}
impl Default for otSockAddr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Non-ECT"]
pub const OT_ECN_NOT_CAPABLE: _bindgen_ty_9 = 0;
#[doc = "< ECT(0)"]
pub const OT_ECN_CAPABLE_0: _bindgen_ty_9 = 2;
#[doc = "< ECT(1)"]
pub const OT_ECN_CAPABLE_1: _bindgen_ty_9 = 1;
#[doc = "< Congestion encountered (CE)"]
pub const OT_ECN_MARKED: _bindgen_ty_9 = 3;
#[doc = " ECN statuses, represented as in the IP header."]
#[doc = ""]
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[doc = " This structure represents the local and peer IPv6 socket addresses."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMessageInfo {
    #[doc = "< The local IPv6 address."]
    pub mSockAddr: otIp6Address,
    #[doc = "< The peer IPv6 address."]
    pub mPeerAddr: otIp6Address,
    #[doc = "< The local transport-layer port."]
    pub mSockPort: u16,
    #[doc = "< The peer transport-layer port."]
    pub mPeerPort: u16,
    #[doc = "< A pointer to link-specific information."]
    pub mLinkInfo: *const ::std::os::raw::c_void,
    #[doc = "< The IPv6 Hop Limit value. Only applies if `mAllowZeroHopLimit` is FALSE."]
    #[doc = "< If `0`, IPv6 Hop Limit is default value `OPENTHREAD_CONFIG_IP6_HOP_LIMIT_DEFAULT`."]
    #[doc = "< Otherwise, specifies the IPv6 Hop Limit."]
    pub mHopLimit: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl Default for otMessageInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otMessageInfo {
    #[inline]
    pub fn mEcn(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mEcn(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsHostInterface(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsHostInterface(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAllowZeroHopLimit(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAllowZeroHopLimit(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mMulticastLoop(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mMulticastLoop(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mEcn: u8,
        mIsHostInterface: bool,
        mAllowZeroHopLimit: bool,
        mMulticastLoop: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let mEcn: u8 = unsafe { ::std::mem::transmute(mEcn) };
            mEcn as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsHostInterface: u8 = unsafe { ::std::mem::transmute(mIsHostInterface) };
            mIsHostInterface as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mAllowZeroHopLimit: u8 = unsafe { ::std::mem::transmute(mAllowZeroHopLimit) };
            mAllowZeroHopLimit as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mMulticastLoop: u8 = unsafe { ::std::mem::transmute(mMulticastLoop) };
            mMulticastLoop as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< IPv6 Hop-by-Hop Option"]
pub const OT_IP6_PROTO_HOP_OPTS: _bindgen_ty_10 = 0;
#[doc = "< Transmission Control Protocol"]
pub const OT_IP6_PROTO_TCP: _bindgen_ty_10 = 6;
#[doc = "< User Datagram"]
pub const OT_IP6_PROTO_UDP: _bindgen_ty_10 = 17;
#[doc = "< IPv6 encapsulation"]
pub const OT_IP6_PROTO_IP6: _bindgen_ty_10 = 41;
#[doc = "< Routing Header for IPv6"]
pub const OT_IP6_PROTO_ROUTING: _bindgen_ty_10 = 43;
#[doc = "< Fragment Header for IPv6"]
pub const OT_IP6_PROTO_FRAGMENT: _bindgen_ty_10 = 44;
#[doc = "< ICMP for IPv6"]
pub const OT_IP6_PROTO_ICMP6: _bindgen_ty_10 = 58;
#[doc = "< No Next Header for IPv6"]
pub const OT_IP6_PROTO_NONE: _bindgen_ty_10 = 59;
#[doc = "< Destination Options for IPv6"]
pub const OT_IP6_PROTO_DST_OPTS: _bindgen_ty_10 = 60;
#[doc = " Internet Protocol Numbers."]
#[doc = ""]
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Brings the IPv6 interface up or down."]
    #[doc = ""]
    #[doc = " Call this to enable or disable IPv6 communication."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in] aEnabled  TRUE to enable IPv6, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            Successfully brought the IPv6 interface up/down."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   IPv6 interface is not available since device is operating in raw-link mode"]
    #[doc = "                                  (applicable only when `OPENTHREAD_CONFIG_LINK_RAW_ENABLE` feature is enabled)."]
    #[doc = ""]
    pub fn otIp6SetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " Indicates whether or not the IPv6 interface is up."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE   The IPv6 interface is enabled."]
    #[doc = " @retval FALSE  The IPv6 interface is disabled."]
    #[doc = ""]
    pub fn otIp6IsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Adds a Network Interface Address to the Thread interface."]
    #[doc = ""]
    #[doc = " The passed-in instance @p aAddress is copied by the Thread interface. The Thread interface only"]
    #[doc = " supports a fixed number of externally added unicast addresses. See `OPENTHREAD_CONFIG_IP6_MAX_EXT_UCAST_ADDRS`."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aAddress  A pointer to a Network Interface Address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully added (or updated) the Network Interface Address."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The IP Address indicated by @p aAddress is an internal address."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The Network Interface is already storing the maximum allowed external addresses."]
    pub fn otIp6AddUnicastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otNetifAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes a Network Interface Address from the Thread interface."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aAddress  A pointer to an IP Address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully removed the Network Interface Address."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The IP Address indicated by @p aAddress is an internal address."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     The IP Address indicated by @p aAddress was not found."]
    pub fn otIp6RemoveUnicastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the list of IPv6 addresses assigned to the Thread interface."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the first Network Interface Address."]
    pub fn otIp6GetUnicastAddresses(aInstance: *mut otInstance) -> *const otNetifAddress;
}
extern "C" {
    #[doc = " Subscribes the Thread interface to a Network Interface Multicast Address."]
    #[doc = ""]
    #[doc = " The passed in instance @p aAddress will be copied by the Thread interface. The Thread interface only"]
    #[doc = " supports a fixed number of externally added multicast addresses. See `OPENTHREAD_CONFIG_IP6_MAX_EXT_MCAST_ADDRS`."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aAddress  A pointer to an IP Address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully subscribed to the Network Interface Multicast Address."]
    #[doc = " @retval OT_ERROR_ALREADY        The multicast address is already subscribed."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   The IP Address indicated by @p aAddress is an invalid multicast address."]
    #[doc = " @retval OT_ERROR_REJECTED       The IP Address indicated by @p aAddress is an internal multicast address."]
    #[doc = " @retval OT_ERROR_NO_BUFS        The Network Interface is already storing the maximum allowed external multicast"]
    #[doc = "                                 addresses."]
    #[doc = ""]
    pub fn otIp6SubscribeMulticastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Unsubscribes the Thread interface to a Network Interface Multicast Address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aAddress  A pointer to an IP Address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully unsubscribed to the Network Interface Multicast Address."]
    #[doc = " @retval OT_ERROR_REJECTED      The IP Address indicated by @p aAddress is an internal address."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     The IP Address indicated by @p aAddress was not found."]
    #[doc = ""]
    pub fn otIp6UnsubscribeMulticastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the list of IPv6 multicast addresses subscribed to the Thread interface."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the first Network Interface Multicast Address."]
    #[doc = ""]
    pub fn otIp6GetMulticastAddresses(aInstance: *mut otInstance)
        -> *const otNetifMulticastAddress;
}
extern "C" {
    #[doc = " Checks if multicast promiscuous mode is enabled on the Thread interface."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @sa otIp6SetMulticastPromiscuousEnabled"]
    #[doc = ""]
    pub fn otIp6IsMulticastPromiscuousEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Enables or disables multicast promiscuous mode on the Thread interface."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnabled   TRUE to enable Multicast Promiscuous mode, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @sa otIp6IsMulticastPromiscuousEnabled"]
    #[doc = ""]
    pub fn otIp6SetMulticastPromiscuousEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " Allocate a new message buffer for sending an IPv6 message."]
    #[doc = ""]
    #[doc = " @note If @p aSettings is 'NULL', the link layer security is enabled and the message priority is set to"]
    #[doc = " OT_MESSAGE_PRIORITY_NORMAL by default."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSettings  A pointer to the message settings or NULL to set default settings."]
    #[doc = ""]
    #[doc = " @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = ""]
    pub fn otIp6NewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Allocate a new message buffer and write the IPv6 datagram to the message buffer for sending an IPv6 message."]
    #[doc = ""]
    #[doc = " @note If @p aSettings is NULL, the link layer security is enabled and the message priority is obtained from IPv6"]
    #[doc = "       message itself."]
    #[doc = "       If @p aSettings is not NULL, the @p aSetting->mPriority is ignored and obtained from IPv6 message itself."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aData        A pointer to the IPv6 datagram buffer."]
    #[doc = " @param[in]  aDataLength  The size of the IPv6 datagram buffer pointed by @p aData."]
    #[doc = " @param[in]  aSettings    A pointer to the message settings or NULL to set default settings."]
    #[doc = ""]
    #[doc = " @returns A pointer to the message or NULL if malformed IPv6 header or insufficient message buffers are available."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = ""]
    pub fn otIp6NewMessageFromBuffer(
        aInstance: *mut otInstance,
        aData: *const u8,
        aDataLength: u16,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
#[doc = " This function pointer is called when an IPv6 datagram is received."]
#[doc = ""]
#[doc = " @param[in]  aMessage  A pointer to the message buffer containing the received IPv6 datagram. This function transfers"]
#[doc = "                       the ownership of the @p aMessage to the receiver of the callback. The message should be"]
#[doc = "                       freed by the receiver of the callback after it is processed (see otMessageFree())."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otIp6ReceiveCallback = ::std::option::Option<
    unsafe extern "C" fn(aMessage: *mut otMessage, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function registers a callback to provide received IPv6 datagrams."]
    #[doc = ""]
    #[doc = " By default, this callback does not pass Thread control traffic.  See otIp6SetReceiveFilterEnabled() to"]
    #[doc = " change the Thread control traffic filter setting."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aCallback         A pointer to a function that is called when an IPv6 datagram is received or"]
    #[doc = "                               NULL to disable the callback."]
    #[doc = " @param[in]  aCallbackContext  A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @sa otIp6IsReceiveFilterEnabled"]
    #[doc = " @sa otIp6SetReceiveFilterEnabled"]
    #[doc = ""]
    pub fn otIp6SetReceiveCallback(
        aInstance: *mut otInstance,
        aCallback: otIp6ReceiveCallback,
        aCallbackContext: *mut ::std::os::raw::c_void,
    );
}
#[doc = " @struct otIp6AddressInfo"]
#[doc = ""]
#[doc = " This structure represents IPv6 address information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otIp6AddressInfo {
    #[doc = "< A pointer to the IPv6 address."]
    pub mAddress: *const otIp6Address,
    #[doc = "< The prefix length of mAddress if it is a unicast address."]
    pub mPrefixLength: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl Default for otIp6AddressInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otIp6AddressInfo {
    #[inline]
    pub fn mScope(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mScope(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mPreferred(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPreferred(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mScope: u8, mPreferred: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mScope: u8 = unsafe { ::std::mem::transmute(mScope) };
            mScope as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mPreferred: u8 = unsafe { ::std::mem::transmute(mPreferred) };
            mPreferred as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This function pointer is called when an internal IPv6 address is added or removed."]
#[doc = ""]
#[doc = " @param[in]   aAddressInfo        A pointer to the IPv6 address information."]
#[doc = " @param[in]   aIsAdded            TRUE if the @p aAddress was added, FALSE if @p aAddress was removed."]
#[doc = " @param[in]   aContext            A pointer to application-specific context."]
#[doc = ""]
pub type otIp6AddressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aAddressInfo: *const otIp6AddressInfo,
        aIsAdded: bool,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function registers a callback to notify internal IPv6 address changes."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance           A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aCallback           A pointer to a function that is called when an internal IPv6 address is added or"]
    #[doc = "                                  removed. NULL to disable the callback."]
    #[doc = " @param[in]   aCallbackContext    A pointer to application-specific context."]
    #[doc = ""]
    pub fn otIp6SetAddressCallback(
        aInstance: *mut otInstance,
        aCallback: otIp6AddressCallback,
        aCallbackContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function indicates whether or not Thread control traffic is filtered out when delivering IPv6 datagrams"]
    #[doc = " via the callback specified in otIp6SetReceiveCallback()."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  TRUE if Thread control traffic is filtered out, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @sa otIp6SetReceiveCallback"]
    #[doc = " @sa otIp6SetReceiveFilterEnabled"]
    #[doc = ""]
    pub fn otIp6IsReceiveFilterEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function sets whether or not Thread control traffic is filtered out when delivering IPv6 datagrams"]
    #[doc = " via the callback specified in otIp6SetReceiveCallback()."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnabled  TRUE if Thread control traffic is filtered out, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @sa otIp6SetReceiveCallback"]
    #[doc = " @sa otIsReceiveIp6FilterEnabled"]
    #[doc = ""]
    pub fn otIp6SetReceiveFilterEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " This function sends an IPv6 datagram via the Thread interface."]
    #[doc = ""]
    #[doc = " The caller transfers ownership of @p aMessage when making this call. OpenThread will free @p aMessage when"]
    #[doc = " processing is complete, including when a value other than `OT_ERROR_NONE` is returned."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage  A pointer to the message buffer containing the IPv6 datagram."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE                    Successfully processed the message."]
    #[doc = " @retval OT_ERROR_DROP                    Message was well-formed but not fully processed due to packet processing"]
    #[doc = " rules."]
    #[doc = " @retval OT_ERROR_NO_BUFS                 Could not allocate necessary message buffers when processing the datagram."]
    #[doc = " @retval OT_ERROR_NO_ROUTE                No route to host."]
    #[doc = " @retval OT_ERROR_INVALID_SOURCE_ADDRESS  Source address is invalid, e.g. an anycast address or a multicast address."]
    #[doc = " @retval OT_ERROR_PARSE                   Encountered a malformed header when processing the message."]
    #[doc = ""]
    pub fn otIp6Send(aInstance: *mut otInstance, aMessage: *mut otMessage) -> otError;
}
extern "C" {
    #[doc = " This function adds a port to the allowed unsecured port list."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPort     The port value."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE         The port was successfully added to the allowed unsecure port list."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS The port is invalid (value 0 is reserved for internal use)."]
    #[doc = " @retval OT_ERROR_NO_BUFS      The unsecure port list is full."]
    #[doc = ""]
    pub fn otIp6AddUnsecurePort(aInstance: *mut otInstance, aPort: u16) -> otError;
}
extern "C" {
    #[doc = " This function removes a port from the allowed unsecure port list."]
    #[doc = ""]
    #[doc = " @note This function removes @p aPort by overwriting @p aPort with the element after @p aPort in the internal port"]
    #[doc = "       list. Be careful when calling otIp6GetUnsecurePorts() followed by otIp6RemoveUnsecurePort() to remove unsecure"]
    #[doc = "       ports."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPort     The port value."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE         The port was successfully removed from the allowed unsecure port list."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS The port is invalid (value 0 is reserved for internal use)."]
    #[doc = " @retval OT_ERROR_NOT_FOUND    The port was not found in the unsecure port list."]
    #[doc = ""]
    pub fn otIp6RemoveUnsecurePort(aInstance: *mut otInstance, aPort: u16) -> otError;
}
extern "C" {
    #[doc = " This function removes all ports from the allowed unsecure port list."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otIp6RemoveAllUnsecurePorts(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function returns a pointer to the unsecure port list."]
    #[doc = ""]
    #[doc = " @note Port value 0 is used to indicate an invalid entry."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aNumEntries  The number of entries in the list."]
    #[doc = ""]
    #[doc = " @returns A pointer to the unsecure port list."]
    #[doc = ""]
    pub fn otIp6GetUnsecurePorts(aInstance: *mut otInstance, aNumEntries: *mut u8) -> *const u16;
}
extern "C" {
    #[doc = " Test if two IPv6 addresses are the same."]
    #[doc = ""]
    #[doc = " @param[in]  aFirst   A pointer to the first IPv6 address to compare."]
    #[doc = " @param[in]  aSecond  A pointer to the second IPv6 address to compare."]
    #[doc = ""]
    #[doc = " @retval TRUE   The two IPv6 addresses are the same."]
    #[doc = " @retval FALSE  The two IPv6 addresses are not the same."]
    #[doc = ""]
    pub fn otIp6IsAddressEqual(aFirst: *const otIp6Address, aSecond: *const otIp6Address) -> bool;
}
extern "C" {
    #[doc = " Test if two IPv6 prefixes are the same."]
    #[doc = ""]
    #[doc = " @param[in]  aFirst   A pointer to the first IPv6 prefix to compare."]
    #[doc = " @param[in]  aSecond  A pointer to the second IPv6 prefix to compare."]
    #[doc = ""]
    #[doc = " @retval TRUE   The two IPv6 prefixes are the same."]
    #[doc = " @retval FALSE  The two IPv6 prefixes are not the same."]
    #[doc = ""]
    pub fn otIp6ArePrefixesEqual(aFirst: *const otIp6Prefix, aSecond: *const otIp6Prefix) -> bool;
}
extern "C" {
    #[doc = " This function converts a human-readable IPv6 address string into a binary representation."]
    #[doc = ""]
    #[doc = " @param[in]   aString   A pointer to a NULL-terminated string."]
    #[doc = " @param[out]  aAddress  A pointer to an IPv6 address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully parsed the string."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  Failed to parse the string."]
    #[doc = ""]
    pub fn otIp6AddressFromString(
        aString: *const ::std::os::raw::c_char,
        aAddress: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " This function converts a given IPv6 address to a human-readable string."]
    #[doc = ""]
    #[doc = " The IPv6 address string is formatted as 16 hex values separated by ':' (i.e., \"%x:%x:%x:...:%x\")."]
    #[doc = ""]
    #[doc = " If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated"]
    #[doc = " but the outputted string is always null-terminated."]
    #[doc = ""]
    #[doc = " @param[in]  aAddress  A pointer to an IPv6 address (MUST NOT be NULL)."]
    #[doc = " @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL)."]
    #[doc = " @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_ADDRESS_STRING_SIZE`."]
    #[doc = ""]
    pub fn otIp6AddressToString(
        aAddress: *const otIp6Address,
        aBuffer: *mut ::std::os::raw::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " This function converts a given IPv6 socket address to a human-readable string."]
    #[doc = ""]
    #[doc = " The IPv6 socket address string is formatted as [`address`]:`port` where `address` is shown"]
    #[doc = " as 16 hex values separated by `:` and `port` is the port number in decimal format,"]
    #[doc = " for example \"[%x:%x:...:%x]:%u\"."]
    #[doc = ""]
    #[doc = " If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated"]
    #[doc = " but the outputted string is always null-terminated."]
    #[doc = ""]
    #[doc = " @param[in]  aSockAddr A pointer to an IPv6 socket address (MUST NOT be NULL)."]
    #[doc = " @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL)."]
    #[doc = " @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_SOCK_ADDR_STRING_SIZE`."]
    #[doc = ""]
    pub fn otIp6SockAddrToString(
        aSockAddr: *const otSockAddr,
        aBuffer: *mut ::std::os::raw::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " This function converts a given IPv6 prefix to a human-readable string."]
    #[doc = ""]
    #[doc = " The IPv6 address string is formatted as \"%x:%x:%x:...[::]/plen\"."]
    #[doc = ""]
    #[doc = " If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated"]
    #[doc = " but the outputted string is always null-terminated."]
    #[doc = ""]
    #[doc = " @param[in]  aPrefix   A pointer to an IPv6 prefix (MUST NOT be NULL)."]
    #[doc = " @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL)."]
    #[doc = " @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_PREFIX_STRING_SIZE`."]
    #[doc = ""]
    pub fn otIp6PrefixToString(
        aPrefix: *const otIp6Prefix,
        aBuffer: *mut ::std::os::raw::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " This function returns the prefix match length (bits) for two IPv6 addresses."]
    #[doc = ""]
    #[doc = " @param[in]  aFirst   A pointer to the first IPv6 address."]
    #[doc = " @param[in]  aSecond  A pointer to the second IPv6 address."]
    #[doc = ""]
    #[doc = " @returns  The prefix match length in bits."]
    #[doc = ""]
    pub fn otIp6PrefixMatch(aFirst: *const otIp6Address, aSecond: *const otIp6Address) -> u8;
}
extern "C" {
    #[doc = " This method gets a prefix with @p aLength from @p aAddress."]
    #[doc = ""]
    #[doc = " @param[in]  aAddress   A pointer to an IPv6 address."]
    #[doc = " @param[in]  aLength    The length of prefix in bits."]
    #[doc = " @param[out] aPrefix    A pointer to output the IPv6 prefix."]
    #[doc = ""]
    pub fn otIp6GetPrefix(aAddress: *const otIp6Address, aLength: u8, aPrefix: *mut otIp6Prefix);
}
extern "C" {
    #[doc = " This function indicates whether or not a given IPv6 address is the Unspecified Address."]
    #[doc = ""]
    #[doc = " @param[in]  aAddress   A pointer to an IPv6 address."]
    #[doc = ""]
    #[doc = " @retval TRUE   If the IPv6 address is the Unspecified Address."]
    #[doc = " @retval FALSE  If the IPv6 address is not the Unspecified Address."]
    #[doc = ""]
    pub fn otIp6IsAddressUnspecified(aAddress: *const otIp6Address) -> bool;
}
extern "C" {
    #[doc = " This function perform OpenThread source address selection."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aMessageInfo  A pointer to the message information."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE       Found a source address and is filled into mSockAddr of @p aMessageInfo."]
    #[doc = " @retval  OT_ERROR_NOT_FOUND  No source address was found and @p aMessageInfo is unchanged."]
    #[doc = ""]
    pub fn otIp6SelectSourceAddress(
        aInstance: *mut otInstance,
        aMessageInfo: *mut otMessageInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether the SLAAC module is enabled or not."]
    #[doc = ""]
    #[doc = " This function requires the build-time feature `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " @retval TRUE    SLAAC module is enabled."]
    #[doc = " @retval FALSE   SLAAC module is disabled."]
    #[doc = ""]
    pub fn otIp6IsSlaacEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function enables/disables the SLAAC module."]
    #[doc = ""]
    #[doc = " This function requires the build-time feature `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " When SLAAC module is enabled, SLAAC addresses (based on on-mesh prefixes in Network Data) are added to the interface."]
    #[doc = " When SLAAC module is disabled any previously added SLAAC address is removed."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in] aEnabled  TRUE to enable, FALSE to disable."]
    #[doc = ""]
    pub fn otIp6SetSlaacEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
#[doc = " This function pointer allows user to filter prefixes and not allow an SLAAC address based on a prefix to be added."]
#[doc = ""]
#[doc = " `otIp6SetSlaacPrefixFilter()` can be used to set the filter handler. The filter handler is invoked by SLAAC module"]
#[doc = " when it is about to add a SLAAC address based on a prefix. Its boolean return value determines whether the address"]
#[doc = " is filtered (not added) or not."]
#[doc = ""]
#[doc = " @param[in] aInstance   A pointer to an OpenThread instance."]
#[doc = " @param[in] aPrefix     A pointer to prefix for which SLAAC address is about to be added."]
#[doc = ""]
#[doc = " @retval TRUE    Indicates that the SLAAC address based on the prefix should be filtered and NOT added."]
#[doc = " @retval FALSE   Indicates that the SLAAC address based on the prefix should be added."]
#[doc = ""]
pub type otIp6SlaacPrefixFilter = ::std::option::Option<
    unsafe extern "C" fn(aInstance: *mut otInstance, aPrefix: *const otIp6Prefix) -> bool,
>;
extern "C" {
    #[doc = " This function sets the SLAAC module filter handler."]
    #[doc = ""]
    #[doc = " This function requires the build-time feature `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " The filter handler is called by SLAAC module when it is about to add a SLAAC address based on a prefix to decide"]
    #[doc = " whether the address should be added or not."]
    #[doc = ""]
    #[doc = " A NULL filter handler disables filtering and allows all SLAAC addresses to be added."]
    #[doc = ""]
    #[doc = " If this function is not called, the default filter used by SLAAC module will be NULL (filtering is disabled)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in] aFilter      A pointer to SLAAC prefix filter handler, or NULL to disable filtering."]
    #[doc = ""]
    pub fn otIp6SetSlaacPrefixFilter(aInstance: *mut otInstance, aFilter: otIp6SlaacPrefixFilter);
}
#[doc = " This function pointer is called with results of `otIp6RegisterMulticastListeners`."]
#[doc = ""]
#[doc = " @param[in]  aContext  A pointer to the user context."]
#[doc = " @param[in]  aError    OT_ERROR_NONE when successfully sent MLR.req and received MLR.rsp,"]
#[doc = "                       OT_ERROR_RESPONSE_TIMEOUT when failed to receive MLR.rsp,"]
#[doc = "                       OT_ERROR_PARSE when failed to parse MLR.rsp."]
#[doc = " @param[in]  aMlrStatus         The Multicast Listener Registration status when @p aError is OT_ERROR_NONE."]
#[doc = " @param[in]  aFailedAddresses   A pointer to the failed IPv6 addresses when @p aError is OT_ERROR_NONE."]
#[doc = " @param[in]  aFailedAddressNum  The number of failed IPv6 addresses when @p aError is OT_ERROR_NONE."]
#[doc = ""]
#[doc = " @sa otIp6RegisterMulticastListeners"]
#[doc = ""]
pub type otIp6RegisterMulticastListenersCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aError: otError,
        aMlrStatus: u8,
        aFailedAddresses: *const otIp6Address,
        aFailedAddressNum: u8,
    ),
>;
extern "C" {
    #[doc = " This function registers Multicast Listeners to Primary Backbone Router."]
    #[doc = ""]
    #[doc = " Note: only available when both `OPENTHREAD_CONFIG_TMF_PROXY_MLR_ENABLE` and"]
    #[doc = " `OPENTHREAD_CONFIG_COMMISSIONER_ENABLE` are enabled)"]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aAddresses   A Multicast Address Array to register."]
    #[doc = " @param[in]  aAddressNum  The number of Multicast Address to register (0 if @p aAddresses is NULL)."]
    #[doc = " @param[in]  aTimeout     A pointer to the timeout value (in seconds) to be included in MLR.req. A timeout value of 0"]
    #[doc = "                          removes the corresponding Multicast Listener. If NULL, MLR.req would have no Timeout Tlv by"]
    #[doc = "                          default."]
    #[doc = " @param[in]  aCallback    A pointer to the callback function."]
    #[doc = " @param[in]  aContext     A pointer to the user context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully sent MLR.req. The @p aCallback will be called iff this method"]
    #[doc = "                                 returns OT_ERROR_NONE."]
    #[doc = " @retval OT_ERROR_BUSY           If a previous registration was ongoing."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   If one or more arguments are invalid."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  If the device was not in a valid state to send MLR.req (e.g. Commissioner not"]
    #[doc = "                                 started, Primary Backbone Router not found)."]
    #[doc = " @retval OT_ERROR_NO_BUFS        If insufficient message buffers available."]
    #[doc = ""]
    #[doc = " @sa otIp6RegisterMulticastListenersCallback"]
    #[doc = ""]
    pub fn otIp6RegisterMulticastListeners(
        aInstance: *mut otInstance,
        aAddresses: *const otIp6Address,
        aAddressNum: u8,
        aTimeout: *const u32,
        aCallback: otIp6RegisterMulticastListenersCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the Mesh Local IID (for test purpose)."]
    #[doc = ""]
    #[doc = " Only available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aIid        A pointer to the Mesh Local IID to set."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE           Successfully set the Mesh Local IID."]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    pub fn otIp6SetMeshLocalIid(
        aInstance: *mut otInstance,
        aIid: *const otIp6InterfaceIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " This function converts a given IP protocol number to a human-readable string."]
    #[doc = ""]
    #[doc = " @param[in] aIpProto   An IP protocol number (`OT_IP6_PROTO_*` enumeration)."]
    #[doc = ""]
    #[doc = " @returns A string representing @p aIpProto."]
    #[doc = ""]
    pub fn otIp6ProtoToString(aIpProto: u8) -> *const ::std::os::raw::c_char;
}
#[doc = " This structure represents the counters for packets and bytes."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otPacketsAndBytes {
    #[doc = "< The number of packets."]
    pub mPackets: u64,
    #[doc = "< The number of bytes."]
    pub mBytes: u64,
}
#[doc = " This structure represents the counters of packets forwarded via Border Routing."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otBorderRoutingCounters {
    #[doc = "< The counters for inbound unicast."]
    pub mInboundUnicast: otPacketsAndBytes,
    #[doc = "< The counters for inbound multicast."]
    pub mInboundMulticast: otPacketsAndBytes,
    #[doc = "< The counters for outbound unicast."]
    pub mOutboundUnicast: otPacketsAndBytes,
    #[doc = "< The counters for outbound multicast."]
    pub mOutboundMulticast: otPacketsAndBytes,
    #[doc = "< The number of received RA packets."]
    pub mRaRx: u32,
    #[doc = "< The number of RA packets successfully transmitted."]
    pub mRaTxSuccess: u32,
    #[doc = "< The number of RA packets failed to transmit."]
    pub mRaTxFailure: u32,
    #[doc = "< The number of received RS packets."]
    pub mRsRx: u32,
    #[doc = "< The number of RS packets successfully transmitted."]
    pub mRsTxSuccess: u32,
    #[doc = "< The number of RS packets failed to transmit."]
    pub mRsTxFailure: u32,
}
extern "C" {
    #[doc = " Gets the Border Routing counters."]
    #[doc = ""]
    #[doc = " This function requires the build-time feature `OPENTHREAD_CONFIG_IP6_BR_COUNTERS_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Border Routing counters."]
    #[doc = ""]
    pub fn otIp6GetBorderRoutingCounters(
        aInstance: *mut otInstance,
    ) -> *const otBorderRoutingCounters;
}
extern "C" {
    #[doc = " Resets the Border Routing counters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otIp6ResetBorderRoutingCounters(aInstance: *mut otInstance);
}
pub type otNetworkDataIterator = u32;
#[doc = " This structure represents a Border Router configuration."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct otBorderRouterConfig {
    #[doc = "< The IPv6 prefix."]
    pub mPrefix: otIp6Prefix,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "< The border router's RLOC16 (value ignored on config add)."]
    pub mRloc16: u16,
}
impl Default for otBorderRouterConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otBorderRouterConfig {
    #[inline]
    pub fn mPreference(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mPreference(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mPreferred(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPreferred(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mSlaac(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mSlaac(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDhcp(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDhcp(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mConfigure(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mConfigure(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDefaultRoute(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDefaultRoute(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mOnMesh(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mOnMesh(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mStable(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mStable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNdDns(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNdDns(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDp(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDp(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPreference: ::std::os::raw::c_int,
        mPreferred: bool,
        mSlaac: bool,
        mDhcp: bool,
        mConfigure: bool,
        mDefaultRoute: bool,
        mOnMesh: bool,
        mStable: bool,
        mNdDns: bool,
        mDp: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let mPreference: u32 = unsafe { ::std::mem::transmute(mPreference) };
            mPreference as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mPreferred: u8 = unsafe { ::std::mem::transmute(mPreferred) };
            mPreferred as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mSlaac: u8 = unsafe { ::std::mem::transmute(mSlaac) };
            mSlaac as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mDhcp: u8 = unsafe { ::std::mem::transmute(mDhcp) };
            mDhcp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mConfigure: u8 = unsafe { ::std::mem::transmute(mConfigure) };
            mConfigure as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mDefaultRoute: u8 = unsafe { ::std::mem::transmute(mDefaultRoute) };
            mDefaultRoute as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mOnMesh: u8 = unsafe { ::std::mem::transmute(mOnMesh) };
            mOnMesh as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mStable: u8 = unsafe { ::std::mem::transmute(mStable) };
            mStable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let mNdDns: u8 = unsafe { ::std::mem::transmute(mNdDns) };
            mNdDns as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let mDp: u8 = unsafe { ::std::mem::transmute(mDp) };
            mDp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents 6LoWPAN Context ID information associated with a prefix in Network Data."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otLowpanContextInfo {
    #[doc = "< The 6LoWPAN Context ID."]
    pub mContextId: u8,
    #[doc = "< The compress flag."]
    pub mCompressFlag: bool,
    #[doc = "< The associated IPv6 prefix."]
    pub mPrefix: otIp6Prefix,
}
impl Default for otLowpanContextInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents an External Route configuration."]
#[doc = ""]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct otExternalRouteConfig {
    #[doc = "< The IPv6 prefix."]
    pub mPrefix: otIp6Prefix,
    #[doc = "< The border router's RLOC16 (value ignored on config add)."]
    pub mRloc16: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for otExternalRouteConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otExternalRouteConfig {
    #[inline]
    pub fn mPreference(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mPreference(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mNat64(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNat64(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mStable(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mStable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNextHopIsThisDevice(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNextHopIsThisDevice(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPreference: ::std::os::raw::c_int,
        mNat64: bool,
        mStable: bool,
        mNextHopIsThisDevice: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let mPreference: u32 = unsafe { ::std::mem::transmute(mPreference) };
            mPreference as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mNat64: u8 = unsafe { ::std::mem::transmute(mNat64) };
            mNat64 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mStable: u8 = unsafe { ::std::mem::transmute(mStable) };
            mStable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mNextHopIsThisDevice: u8 = unsafe { ::std::mem::transmute(mNextHopIsThisDevice) };
            mNextHopIsThisDevice as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Low route preference."]
pub const OT_ROUTE_PREFERENCE_LOW: otRoutePreference = -1;
#[doc = "< Medium route preference."]
pub const OT_ROUTE_PREFERENCE_MED: otRoutePreference = 0;
#[doc = "< High route preference."]
pub const OT_ROUTE_PREFERENCE_HIGH: otRoutePreference = 1;
#[doc = " Defines valid values for `mPreference` in `otExternalRouteConfig` and `otBorderRouterConfig`."]
#[doc = ""]
pub type otRoutePreference = ::std::os::raw::c_int;
#[doc = " This structure represents a Server configuration."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otServerConfig {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Length of server data."]
    pub mServerDataLength: u8,
    #[doc = "< Server data bytes."]
    pub mServerData: [u8; 248usize],
    #[doc = "< The Server RLOC16."]
    pub mRloc16: u16,
}
impl Default for otServerConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otServerConfig {
    #[inline]
    pub fn mStable(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mStable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mStable: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mStable: u8 = unsafe { ::std::mem::transmute(mStable) };
            mStable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents a Service configuration."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otServiceConfig {
    #[doc = "< Service ID (when iterating over the  Network Data)."]
    pub mServiceId: u8,
    #[doc = "< IANA Enterprise Number."]
    pub mEnterpriseNumber: u32,
    #[doc = "< Length of service data."]
    pub mServiceDataLength: u8,
    #[doc = "< Service data bytes."]
    pub mServiceData: [u8; 252usize],
    #[doc = "< The Server configuration."]
    pub mServerConfig: otServerConfig,
}
impl Default for otServiceConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Provide full or stable copy of the Partition's Thread Network Data."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]      aStable      TRUE when copying the stable version, FALSE when copying the full version."]
    #[doc = " @param[out]     aData        A pointer to the data buffer."]
    #[doc = " @param[in,out]  aDataLength  On entry, size of the data buffer pointed to by @p aData."]
    #[doc = "                              On exit, number of copied bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully copied the Thread Network Data into @p aData and updated @p aDataLength."]
    #[doc = " @retval OT_ERROR_NO_BUFS Not enough space in @p aData to fully copy the Thread Network Data."]
    #[doc = ""]
    pub fn otNetDataGet(
        aInstance: *mut otInstance,
        aStable: bool,
        aData: *mut u8,
        aDataLength: *mut u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the current length (number of bytes) of Partition's Thread Network Data."]
    #[doc = ""]
    #[doc = " @param[in] aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @return The length of the Network Data."]
    #[doc = ""]
    pub fn otNetDataGetLength(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Get the maximum observed length of the Thread Network Data since OT stack initialization or since the last call to"]
    #[doc = " `otNetDataResetMaxLength()`."]
    #[doc = ""]
    #[doc = " @param[in] aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @return The maximum length of the Network Data (high water mark for Network Data length)."]
    #[doc = ""]
    pub fn otNetDataGetMaxLength(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Reset the tracked maximum length of the Thread Network Data."]
    #[doc = ""]
    #[doc = " @param[in] aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @sa otNetDataGetMaxLength"]
    #[doc = ""]
    pub fn otNetDataResetMaxLength(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the next On Mesh Prefix in the partition's Network Data."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator  A pointer to the Network Data iterator context. To get the first on-mesh entry"]
    #[doc = "it should be set to OT_NETWORK_DATA_ITERATOR_INIT."]
    #[doc = " @param[out]     aConfig    A pointer to where the On Mesh Prefix information will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully found the next On Mesh prefix."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No subsequent On Mesh prefix exists in the Thread Network Data."]
    #[doc = ""]
    pub fn otNetDataGetNextOnMeshPrefix(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aConfig: *mut otBorderRouterConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the next external route in the partition's Network Data."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator  A pointer to the Network Data iterator context. To get the first external route entry"]
    #[doc = "it should be set to OT_NETWORK_DATA_ITERATOR_INIT."]
    #[doc = " @param[out]     aConfig    A pointer to where the External Route information will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully found the next External Route."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No subsequent external route entry exists in the Thread Network Data."]
    #[doc = ""]
    pub fn otNetDataGetNextRoute(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aConfig: *mut otExternalRouteConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the next service in the partition's Network Data."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator  A pointer to the Network Data iterator context. To get the first service entry"]
    #[doc = "it should be set to OT_NETWORK_DATA_ITERATOR_INIT."]
    #[doc = " @param[out]     aConfig    A pointer to where the service information will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully found the next service."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No subsequent service exists in the partition's Network Data."]
    #[doc = ""]
    pub fn otNetDataGetNextService(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aConfig: *mut otServiceConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the next 6LoWPAN Context ID info in the partition's Network Data."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator     A pointer to the Network Data iterator. To get the first service entry"]
    #[doc = "it should be set to OT_NETWORK_DATA_ITERATOR_INIT."]
    #[doc = " @param[out]     aContextInfo  A pointer to where the retrieved 6LoWPAN Context ID information will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully found the next 6LoWPAN Context ID info."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No subsequent 6LoWPAN Context info exists in the partition's Network Data."]
    #[doc = ""]
    pub fn otNetDataGetNextLowpanContextInfo(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aContextInfo: *mut otLowpanContextInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Network Data Version."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Network Data Version."]
    #[doc = ""]
    pub fn otNetDataGetVersion(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Get the Stable Network Data Version."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Stable Network Data Version."]
    #[doc = ""]
    pub fn otNetDataGetStableVersion(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Check if the steering data includes a Joiner."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEui64             A pointer to the Joiner's IEEE EUI-64."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          @p aEui64 is included in the steering data."]
    #[doc = " @retval OT_ERROR_INVALID_STATE No steering data present."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     @p aEui64 is not included in the steering data."]
    #[doc = ""]
    pub fn otNetDataSteeringDataCheckJoiner(
        aInstance: *mut otInstance,
        aEui64: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Check if the steering data includes a Joiner with a given discerner value."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDiscerner         A pointer to the Joiner Discerner."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          @p aDiscerner is included in the steering data."]
    #[doc = " @retval OT_ERROR_INVALID_STATE No steering data present."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     @p aDiscerner is not included in the steering data."]
    #[doc = ""]
    pub fn otNetDataSteeringDataCheckJoinerWithDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *const otJoinerDiscerner,
    ) -> otError;
}
extern "C" {
    #[doc = " Check whether a given Prefix can act as a valid OMR prefix and also the Leader's Network Data contains this prefix."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPrefix    A pointer to the IPv6 prefix."]
    #[doc = ""]
    #[doc = " @returns  Whether @p aPrefix is a valid OMR prefix and Leader's Network Data contains the OMR prefix @p aPrefix."]
    #[doc = ""]
    #[doc = " @note This API is only available when `OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE` is used."]
    #[doc = ""]
    pub fn otNetDataContainsOmrPrefix(
        aInstance: *mut otInstance,
        aPrefix: *const otIp6Prefix,
    ) -> bool;
}
#[doc = "< Backbone function is disabled."]
pub const OT_BACKBONE_ROUTER_STATE_DISABLED: otBackboneRouterState = 0;
#[doc = "< Secondary Backbone Router."]
pub const OT_BACKBONE_ROUTER_STATE_SECONDARY: otBackboneRouterState = 1;
#[doc = "< The Primary Backbone Router."]
pub const OT_BACKBONE_ROUTER_STATE_PRIMARY: otBackboneRouterState = 2;
#[doc = " Represents the Backbone Router Status."]
#[doc = ""]
pub type otBackboneRouterState = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Enables or disables Backbone functionality."]
    #[doc = ""]
    #[doc = " If enabled, a Server Data Request message `SRV_DATA.ntf` is triggered for the attached"]
    #[doc = " device if there is no Backbone Router Service in the Thread Network Data."]
    #[doc = ""]
    #[doc = " If disabled, `SRV_DATA.ntf` is triggered if the Backbone Router is in the Primary state."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in] aEnable   TRUE to enable Backbone functionality, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @sa otBackboneRouterGetState"]
    #[doc = " @sa otBackboneRouterGetConfig"]
    #[doc = " @sa otBackboneRouterSetConfig"]
    #[doc = " @sa otBackboneRouterRegister"]
    #[doc = ""]
    pub fn otBackboneRouterSetEnabled(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " Gets the Backbone Router #otBackboneRouterState."]
    #[doc = ""]
    #[doc = " @param[in] aInstance       A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_BACKBONE_ROUTER_STATE_DISABLED   Backbone functionality is disabled."]
    #[doc = " @retval OT_BACKBONE_ROUTER_STATE_SECONDARY  Secondary Backbone Router."]
    #[doc = " @retval OT_BACKBONE_ROUTER_STATE_PRIMARY    The Primary Backbone Router."]
    #[doc = ""]
    #[doc = " @sa otBackboneRouterSetEnabled"]
    #[doc = " @sa otBackboneRouterGetConfig"]
    #[doc = " @sa otBackboneRouterSetConfig"]
    #[doc = " @sa otBackboneRouterRegister"]
    #[doc = ""]
    pub fn otBackboneRouterGetState(aInstance: *mut otInstance) -> otBackboneRouterState;
}
extern "C" {
    #[doc = " Gets the local Backbone Router configuration."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aConfig              A pointer where to put local Backbone Router configuration."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @sa otBackboneRouterSetEnabled"]
    #[doc = " @sa otBackboneRouterGetState"]
    #[doc = " @sa otBackboneRouterSetConfig"]
    #[doc = " @sa otBackboneRouterRegister"]
    #[doc = ""]
    pub fn otBackboneRouterGetConfig(
        aInstance: *mut otInstance,
        aConfig: *mut otBackboneRouterConfig,
    );
}
extern "C" {
    #[doc = " Sets the local Backbone Router configuration #otBackboneRouterConfig."]
    #[doc = ""]
    #[doc = " A Server Data Request message `SRV_DATA.ntf` is initiated automatically if BBR Dataset changes for Primary"]
    #[doc = " Backbone Router."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance             A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aConfig               A pointer to the Backbone Router configuration to take effect."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully updated configuration."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The configuration in @p aConfig is invalid."]
    #[doc = ""]
    #[doc = " @sa otBackboneRouterSetEnabled"]
    #[doc = " @sa otBackboneRouterGetState"]
    #[doc = " @sa otBackboneRouterGetConfig"]
    #[doc = " @sa otBackboneRouterRegister"]
    #[doc = ""]
    pub fn otBackboneRouterSetConfig(
        aInstance: *mut otInstance,
        aConfig: *const otBackboneRouterConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Explicitly registers local Backbone Router configuration."]
    #[doc = ""]
    #[doc = " A Server Data Request message `SRV_DATA.ntf` is triggered for the attached device."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance             A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NO_BUFS           Insufficient space to add the Backbone Router service."]
    #[doc = " @retval OT_ERROR_NONE              Successfully queued a Server Data Request message for delivery."]
    #[doc = ""]
    #[doc = " @sa otBackboneRouterSetEnabled"]
    #[doc = " @sa otBackboneRouterGetState"]
    #[doc = " @sa otBackboneRouterGetConfig"]
    #[doc = " @sa otBackboneRouterSetConfig"]
    #[doc = ""]
    pub fn otBackboneRouterRegister(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This method returns the Backbone Router registration jitter value."]
    #[doc = ""]
    #[doc = " @returns The Backbone Router registration jitter value."]
    #[doc = ""]
    #[doc = " @sa otBackboneRouterSetRegistrationJitter"]
    #[doc = ""]
    pub fn otBackboneRouterGetRegistrationJitter(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " This method sets the Backbone Router registration jitter value."]
    #[doc = ""]
    #[doc = " @param[in]  aJitter the Backbone Router registration jitter value to set."]
    #[doc = ""]
    #[doc = " @sa otBackboneRouterGetRegistrationJitter"]
    #[doc = ""]
    pub fn otBackboneRouterSetRegistrationJitter(aInstance: *mut otInstance, aJitter: u8);
}
extern "C" {
    #[doc = " This method gets the local Domain Prefix configuration."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[out] aConfig   A pointer to the Domain Prefix configuration."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully got the Domain Prefix configuration."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No Domain Prefix was configured."]
    #[doc = ""]
    pub fn otBackboneRouterGetDomainPrefix(
        aInstance: *mut otInstance,
        aConfig: *mut otBorderRouterConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This method configures response status for next DUA registration."]
    #[doc = ""]
    #[doc = " Note: available only when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled."]
    #[doc = "       Only used for test and certification."]
    #[doc = ""]
    #[doc = " TODO: (DUA) support coap error code and corresponding process for certification purpose."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in] aMlIid    A pointer to the Mesh Local IID. If NULL, respond with @p aStatus for any"]
    #[doc = "                      coming DUA.req, otherwise only respond the one with matching @p aMlIid."]
    #[doc = " @param[in] aStatus   The status to respond."]
    #[doc = ""]
    #[doc = ""]
    pub fn otBackboneRouterConfigNextDuaRegistrationResponse(
        aInstance: *mut otInstance,
        aMlIid: *const otIp6InterfaceIdentifier,
        aStatus: u8,
    );
}
extern "C" {
    #[doc = " Configures the response status for the next Multicast Listener Registration."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE`,"]
    #[doc = " `OPENTHREAD_CONFIG_BACKBONE_ROUTER_MULTICAST_ROUTING_ENABLE`, and"]
    #[doc = " `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` are enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in] aStatus    The status to respond."]
    #[doc = ""]
    pub fn otBackboneRouterConfigNextMulticastListenerRegistrationResponse(
        aInstance: *mut otInstance,
        aStatus: u8,
    );
}
#[doc = "< Multicast Listener was added."]
pub const OT_BACKBONE_ROUTER_MULTICAST_LISTENER_ADDED: otBackboneRouterMulticastListenerEvent = 0;
#[doc = "< Multicast Listener was removed or expired."]
pub const OT_BACKBONE_ROUTER_MULTICAST_LISTENER_REMOVED: otBackboneRouterMulticastListenerEvent = 1;
#[doc = " Represents the Multicast Listener events."]
#[doc = ""]
pub type otBackboneRouterMulticastListenerEvent = ::std::os::raw::c_uint;
#[doc = " This function pointer is called whenever the Multicast Listeners change."]
#[doc = ""]
#[doc = " @param[in] aContext  The user context pointer."]
#[doc = " @param[in] aEvent    The Multicast Listener event."]
#[doc = " @param[in] aAddress  The IPv6 multicast address of the Multicast Listener."]
#[doc = ""]
pub type otBackboneRouterMulticastListenerCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aEvent: otBackboneRouterMulticastListenerEvent,
        aAddress: *const otIp6Address,
    ),
>;
extern "C" {
    #[doc = " This method sets the Backbone Router Multicast Listener callback."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in] aCallback  A pointer to the Multicast Listener callback."]
    #[doc = " @param[in] aContext   A user context pointer."]
    #[doc = ""]
    pub fn otBackboneRouterSetMulticastListenerCallback(
        aInstance: *mut otInstance,
        aCallback: otBackboneRouterMulticastListenerCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Clears the Multicast Listeners."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE`,"]
    #[doc = " `OPENTHREAD_CONFIG_BACKBONE_ROUTER_MULTICAST_ROUTING_ENABLE`, and"]
    #[doc = " `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` are enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @sa otBackboneRouterMulticastListenerAdd"]
    #[doc = " @sa otBackboneRouterMulticastListenerGetNext"]
    #[doc = ""]
    pub fn otBackboneRouterMulticastListenerClear(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Adds a Multicast Listener with a timeout value, in seconds."]
    #[doc = ""]
    #[doc = " Pass `0` to use the default MLR timeout."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE`,"]
    #[doc = " `OPENTHREAD_CONFIG_BACKBONE_ROUTER_MULTICAST_ROUTING_ENABLE`, and"]
    #[doc = " `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` are enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in] aAddress   The Multicast Listener address."]
    #[doc = " @param[in] aTimeout   The timeout (in seconds) of the Multicast Listener, or 0 to use the default MLR timeout."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          If the Multicast Listener was successfully added."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  If the Multicast Listener address was invalid."]
    #[doc = " @retval OT_ERROR_NO_BUFS       No space available to save the Multicast Listener."]
    #[doc = ""]
    #[doc = " @sa otBackboneRouterMulticastListenerClear"]
    #[doc = " @sa otBackboneRouterMulticastListenerGetNext"]
    #[doc = ""]
    pub fn otBackboneRouterMulticastListenerAdd(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
        aTimeout: u32,
    ) -> otError;
}
pub type otBackboneRouterMulticastListenerIterator = u16;
#[doc = " This structure represents a Backbone Router Multicast Listener info."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otBackboneRouterMulticastListenerInfo {
    pub mAddress: otIp6Address,
    pub mTimeout: u32,
}
impl Default for otBackboneRouterMulticastListenerInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function gets the next Multicast Listener info (using an iterator)."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance      A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator      A pointer to the iterator. On success the iterator will be updated to point to next"]
    #[doc = "                                Multicast Listener. To get the first entry the iterator should be set to"]
    #[doc = "                                OT_BACKBONE_ROUTER_MULTICAST_LISTENER_ITERATOR_INIT."]
    #[doc = " @param[out]     aListenerInfo  A pointer to an `otBackboneRouterMulticastListenerInfo` where information of next"]
    #[doc = "                                Multicast Listener is placed (on success)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully found the next Multicast Listener info (@p aListenerInfo was successfully"]
    #[doc = "                             updated)."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No subsequent Multicast Listener info was found."]
    #[doc = ""]
    #[doc = " @sa otBackboneRouterMulticastListenerClear"]
    #[doc = " @sa otBackboneRouterMulticastListenerAdd"]
    #[doc = ""]
    pub fn otBackboneRouterMulticastListenerGetNext(
        aInstance: *mut otInstance,
        aIterator: *mut otBackboneRouterMulticastListenerIterator,
        aListenerInfo: *mut otBackboneRouterMulticastListenerInfo,
    ) -> otError;
}
#[doc = "< ND Proxy was added."]
pub const OT_BACKBONE_ROUTER_NDPROXY_ADDED: otBackboneRouterNdProxyEvent = 0;
#[doc = "< ND Proxy was removed."]
pub const OT_BACKBONE_ROUTER_NDPROXY_REMOVED: otBackboneRouterNdProxyEvent = 1;
#[doc = "< ND Proxy was renewed."]
pub const OT_BACKBONE_ROUTER_NDPROXY_RENEWED: otBackboneRouterNdProxyEvent = 2;
#[doc = "< All ND Proxies were cleared."]
pub const OT_BACKBONE_ROUTER_NDPROXY_CLEARED: otBackboneRouterNdProxyEvent = 3;
#[doc = " Represents the ND Proxy events."]
#[doc = ""]
pub type otBackboneRouterNdProxyEvent = ::std::os::raw::c_uint;
#[doc = " This function pointer is called whenever the Nd Proxy changed."]
#[doc = ""]
#[doc = " @param[in] aContext  The user context pointer."]
#[doc = " @param[in] aEvent    The ND Proxy event."]
#[doc = " @param[in] aDua      The Domain Unicast Address of the ND Proxy, or `nullptr` if @p aEvent is"]
#[doc = "                      `OT_BACKBONE_ROUTER_NDPROXY_CLEARED`."]
#[doc = ""]
pub type otBackboneRouterNdProxyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aEvent: otBackboneRouterNdProxyEvent,
        aDua: *const otIp6Address,
    ),
>;
extern "C" {
    #[doc = " This method sets the Backbone Router ND Proxy callback."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in] aCallback  A pointer to the ND Proxy callback."]
    #[doc = " @param[in] aContext   A user context pointer."]
    #[doc = ""]
    pub fn otBackboneRouterSetNdProxyCallback(
        aInstance: *mut otInstance,
        aCallback: otBackboneRouterNdProxyCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
#[doc = " Represents the Backbone Router ND Proxy info."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otBackboneRouterNdProxyInfo {
    #[doc = "< Mesh-local IID"]
    pub mMeshLocalIid: *mut otIp6InterfaceIdentifier,
    #[doc = "< Time since last transaction (Seconds)"]
    pub mTimeSinceLastTransaction: u32,
    #[doc = "< RLOC16"]
    pub mRloc16: u16,
}
impl Default for otBackboneRouterNdProxyInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This method gets the Backbone Router ND Proxy info."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aDua          The Domain Unicast Address."]
    #[doc = " @param[out]  aNdProxyInfo  A pointer to the ND Proxy info."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully got the ND Proxy info."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  Failed to find the Domain Unicast Address in the ND Proxy table."]
    #[doc = ""]
    pub fn otBackboneRouterGetNdProxyInfo(
        aInstance: *mut otInstance,
        aDua: *const otIp6Address,
        aNdProxyInfo: *mut otBackboneRouterNdProxyInfo,
    ) -> otError;
}
#[doc = "< Domain Prefix was added."]
pub const OT_BACKBONE_ROUTER_DOMAIN_PREFIX_ADDED: otBackboneRouterDomainPrefixEvent = 0;
#[doc = "< Domain Prefix was removed."]
pub const OT_BACKBONE_ROUTER_DOMAIN_PREFIX_REMOVED: otBackboneRouterDomainPrefixEvent = 1;
#[doc = "< Domain Prefix was changed."]
pub const OT_BACKBONE_ROUTER_DOMAIN_PREFIX_CHANGED: otBackboneRouterDomainPrefixEvent = 2;
#[doc = " Represents the Domain Prefix events."]
#[doc = ""]
pub type otBackboneRouterDomainPrefixEvent = ::std::os::raw::c_uint;
#[doc = " This function pointer is called whenever the Domain Prefix changed."]
#[doc = ""]
#[doc = " @param[in] aContext       The user context pointer."]
#[doc = " @param[in] aEvent         The Domain Prefix event."]
#[doc = " @param[in] aDomainPrefix  The new Domain Prefix if added or changed, nullptr otherwise."]
#[doc = ""]
pub type otBackboneRouterDomainPrefixCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aEvent: otBackboneRouterDomainPrefixEvent,
        aDomainPrefix: *const otIp6Prefix,
    ),
>;
extern "C" {
    #[doc = " This method sets the Backbone Router Domain Prefix callback."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in] aCallback  A pointer to the Domain Prefix callback."]
    #[doc = " @param[in] aContext   A user context pointer."]
    #[doc = ""]
    pub fn otBackboneRouterSetDomainPrefixCallback(
        aInstance: *mut otInstance,
        aCallback: otBackboneRouterDomainPrefixCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
#[doc = "< Border agent role is disabled."]
pub const OT_BORDER_AGENT_STATE_STOPPED: otBorderAgentState = 0;
#[doc = "< Border agent is started."]
pub const OT_BORDER_AGENT_STATE_STARTED: otBorderAgentState = 1;
#[doc = "< Border agent is connected with external commissioner."]
pub const OT_BORDER_AGENT_STATE_ACTIVE: otBorderAgentState = 2;
#[doc = " This enumeration defines the Border Agent state."]
#[doc = ""]
pub type otBorderAgentState = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Gets the #otBorderAgentState of the Thread Border Agent role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The current #otBorderAgentState of the Border Agent."]
    #[doc = ""]
    pub fn otBorderAgentGetState(aInstance: *mut otInstance) -> otBorderAgentState;
}
extern "C" {
    #[doc = " Gets the UDP port of the Thread Border Agent service."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns UDP port of the Border Agent."]
    #[doc = ""]
    pub fn otBorderAgentGetUdpPort(aInstance: *mut otInstance) -> u16;
}
#[doc = " This structure represents an iterator to iterate through the Border Router's discovered prefix table."]
#[doc = ""]
#[doc = " The fields in this type are opaque (intended for use by OpenThread core only) and therefore should not be"]
#[doc = " accessed or used by caller."]
#[doc = ""]
#[doc = " Before using an iterator, it MUST be initialized using `otBorderRoutingPrefixTableInitIterator()`."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otBorderRoutingPrefixTableIterator {
    pub mPtr1: *const ::std::os::raw::c_void,
    pub mPtr2: *const ::std::os::raw::c_void,
    pub mData32: u32,
}
impl Default for otBorderRoutingPrefixTableIterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents an entry from the discovered prefix table."]
#[doc = ""]
#[doc = " The entries in the discovered table track the Prefix/Route Info Options in the received Router Advertisement messages"]
#[doc = " from other routers on infrastructure link."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otBorderRoutingPrefixTableEntry {
    #[doc = "< IPv6 address of the router."]
    pub mRouterAddress: otIp6Address,
    #[doc = "< The discovered IPv6 prefix."]
    pub mPrefix: otIp6Prefix,
    #[doc = "< Indicates whether the prefix is on-link or route prefix."]
    pub mIsOnLink: bool,
    #[doc = "< Milliseconds since last update of this prefix."]
    pub mMsecSinceLastUpdate: u32,
    #[doc = "< Valid lifetime of the prefix (in seconds)."]
    pub mValidLifetime: u32,
    #[doc = "< Route preference when `mIsOnlink` is false."]
    pub mRoutePreference: otRoutePreference,
    #[doc = "< Preferred lifetime of the on-link prefix when `mIsOnLink` is true."]
    pub mPreferredLifetime: u32,
}
impl Default for otBorderRoutingPrefixTableEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Routing Manager is uninitialized."]
pub const OT_BORDER_ROUTING_STATE_UNINITIALIZED: otBorderRoutingState = 0;
#[doc = "< Routing Manager is initialized but disabled."]
pub const OT_BORDER_ROUTING_STATE_DISABLED: otBorderRoutingState = 1;
#[doc = "< Routing Manager in initialized and enabled but currently stopped."]
pub const OT_BORDER_ROUTING_STATE_STOPPED: otBorderRoutingState = 2;
#[doc = "< Routing Manager is initialized, enabled, and running."]
pub const OT_BORDER_ROUTING_STATE_RUNNING: otBorderRoutingState = 3;
#[doc = " This enumeration represents the state of Border Routing Manager."]
#[doc = ""]
pub type otBorderRoutingState = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This method initializes the Border Routing Manager on given infrastructure interface."]
    #[doc = ""]
    #[doc = " @note  This method MUST be called before any other otBorderRouting* APIs."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aInfraIfIndex      The infrastructure interface index."]
    #[doc = " @param[in]  aInfraIfIsRunning  A boolean that indicates whether the infrastructure"]
    #[doc = "                                interface is running."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE           Successfully started the Border Routing Manager on given infrastructure."]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager has already been initialized."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS   The index of the infrastructure interface is not valid."]
    #[doc = " @retval  OT_ERROR_FAILED         Internal failure. Usually due to failure in generating random prefixes."]
    #[doc = ""]
    #[doc = " @sa otPlatInfraIfStateChanged."]
    #[doc = ""]
    pub fn otBorderRoutingInit(
        aInstance: *mut otInstance,
        aInfraIfIndex: u32,
        aInfraIfIsRunning: bool,
    ) -> otError;
}
extern "C" {
    #[doc = " Enables or disables the Border Routing Manager."]
    #[doc = ""]
    #[doc = " @note  The Border Routing Manager is disabled by default."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnabled   A boolean to enable/disable the routing manager."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not initialized yet."]
    #[doc = " @retval  OT_ERROR_NONE           Successfully enabled/disabled the Border Routing Manager."]
    #[doc = ""]
    pub fn otBorderRoutingSetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " Gets the current state of Border Routing Manager."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The current state of Border Routing Manager."]
    #[doc = ""]
    pub fn otBorderRoutingGetState(aInstance: *mut otInstance) -> otBorderRoutingState;
}
extern "C" {
    #[doc = " This function gets the current preference used when advertising Route Info Options (RIO) in Router Advertisement"]
    #[doc = " messages sent over the infrastructure link."]
    #[doc = ""]
    #[doc = " The RIO preference is determined as follows:"]
    #[doc = ""]
    #[doc = " - If explicitly set by user by calling `otBorderRoutingSetRouteInfoOptionPreference()`, the given preference is"]
    #[doc = "   used."]
    #[doc = " - Otherwise, it is determined based on device's current role: Medium preference when in router/leader role and"]
    #[doc = "   low preference when in child role."]
    #[doc = ""]
    #[doc = " @returns The current Route Info Option preference."]
    #[doc = ""]
    pub fn otBorderRoutingGetRouteInfoOptionPreference(
        aInstance: *mut otInstance,
    ) -> otRoutePreference;
}
extern "C" {
    #[doc = " This function explicitly sets the preference to use when advertising Route Info Options (RIO) in Router"]
    #[doc = " Advertisement messages sent over the infrastructure link."]
    #[doc = ""]
    #[doc = " After a call to this function, BR will use the given preference for all its advertised RIOs. The preference can be"]
    #[doc = " cleared by calling `otBorderRoutingClearRouteInfoOptionPreference()`."]
    #[doc = ""]
    #[doc = " @param[in] aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in] aPreference   The route preference to use."]
    #[doc = ""]
    pub fn otBorderRoutingSetRouteInfoOptionPreference(
        aInstance: *mut otInstance,
        aPreference: otRoutePreference,
    );
}
extern "C" {
    #[doc = " This function clears a previously set preference value for advertised Route Info Options."]
    #[doc = ""]
    #[doc = " After a call to this function, BR will use device's role to determine the RIO preference: Medium preference when"]
    #[doc = " in router/leader role and low preference when in child role."]
    #[doc = ""]
    #[doc = " @param[in] aInstance     A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otBorderRoutingClearRouteInfoOptionPreference(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets the local Off-Mesh-Routable (OMR) Prefix, for example `fdfc:1ff5:1512:5622::/64`."]
    #[doc = ""]
    #[doc = " An OMR Prefix is a randomly generated 64-bit prefix that's published in the"]
    #[doc = " Thread network if there isn't already an OMR prefix. This prefix can be reached"]
    #[doc = " from the local Wi-Fi or Ethernet network."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aPrefix    A pointer to where the prefix will be output to."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not initialized yet."]
    #[doc = " @retval  OT_ERROR_NONE           Successfully retrieved the OMR prefix."]
    #[doc = ""]
    pub fn otBorderRoutingGetOmrPrefix(
        aInstance: *mut otInstance,
        aPrefix: *mut otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the currently favored Off-Mesh-Routable (OMR) Prefix."]
    #[doc = ""]
    #[doc = " The favored OMR prefix can be discovered from Network Data or can be this device's local OMR prefix."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aPrefix      A pointer to output the favored OMR prefix."]
    #[doc = " @param[out]  aPreference  A pointer to output the preference associated the favored prefix."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not running yet."]
    #[doc = " @retval  OT_ERROR_NONE           Successfully retrieved the favored OMR prefix."]
    #[doc = ""]
    pub fn otBorderRoutingGetFavoredOmrPrefix(
        aInstance: *mut otInstance,
        aPrefix: *mut otIp6Prefix,
        aPreference: *mut otRoutePreference,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the local On-Link Prefix for the adjacent infrastructure link."]
    #[doc = ""]
    #[doc = " The local On-Link Prefix is a 64-bit prefix that's advertised on the infrastructure link if there isn't already a"]
    #[doc = " usable on-link prefix being advertised on the link."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aPrefix    A pointer to where the prefix will be output to."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not initialized yet."]
    #[doc = " @retval  OT_ERROR_NONE           Successfully retrieved the local on-link prefix."]
    #[doc = ""]
    pub fn otBorderRoutingGetOnLinkPrefix(
        aInstance: *mut otInstance,
        aPrefix: *mut otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the currently favored On-Link Prefix."]
    #[doc = ""]
    #[doc = " The favored prefix is either a discovered on-link prefix on the infrastructure link or the local on-link prefix."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aPrefix    A pointer to where the prefix will be output to."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not initialized yet."]
    #[doc = " @retval  OT_ERROR_NONE           Successfully retrieved the favored on-link prefix."]
    #[doc = ""]
    pub fn otBorderRoutingGetFavoredOnLinkPrefix(
        aInstance: *mut otInstance,
        aPrefix: *mut otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the local NAT64 Prefix of the Border Router."]
    #[doc = ""]
    #[doc = " NAT64 Prefix might not be advertised in the Thread network."]
    #[doc = ""]
    #[doc = " `OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE` must be enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aPrefix     A pointer to where the prefix will be output to."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not initialized yet."]
    #[doc = " @retval  OT_ERROR_NONE           Successfully retrieved the NAT64 prefix."]
    #[doc = ""]
    pub fn otBorderRoutingGetNat64Prefix(
        aInstance: *mut otInstance,
        aPrefix: *mut otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the currently favored NAT64 prefix."]
    #[doc = ""]
    #[doc = " The favored NAT64 prefix can be discovered from infrastructure link or can be this device's local NAT64 prefix."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aPrefix      A pointer to output the favored NAT64 prefix."]
    #[doc = " @param[out]  aPreference  A pointer to output the preference associated the favored prefix."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not initialized yet."]
    #[doc = " @retval  OT_ERROR_NONE           Successfully retrieved the favored NAT64 prefix."]
    #[doc = ""]
    pub fn otBorderRoutingGetFavoredNat64Prefix(
        aInstance: *mut otInstance,
        aPrefix: *mut otIp6Prefix,
        aPreference: *mut otRoutePreference,
    ) -> otError;
}
extern "C" {
    #[doc = " This function initializes an `otBorderRoutingPrefixTableIterator`."]
    #[doc = ""]
    #[doc = " An iterator MUST be initialized before it is used."]
    #[doc = ""]
    #[doc = " An iterator can be initialized again to restart from the beginning of the table."]
    #[doc = ""]
    #[doc = " When iterating over entries in the table, to ensure the update times `mMsecSinceLastUpdate` of entries are"]
    #[doc = " consistent, they are given relative to the time the iterator was initialized."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  The OpenThread instance."]
    #[doc = " @param[out] aIterator  A pointer to the iterator to initialize."]
    #[doc = ""]
    pub fn otBorderRoutingPrefixTableInitIterator(
        aInstance: *mut otInstance,
        aIterator: *mut otBorderRoutingPrefixTableIterator,
    );
}
extern "C" {
    #[doc = " This function iterates over the entries in the Border Router's discovered prefix table."]
    #[doc = ""]
    #[doc = " @param[in]     aInstance    The OpenThread instance."]
    #[doc = " @param[in,out] aIterator    A pointer to the iterator."]
    #[doc = " @param[out]    aEntry       A pointer to the entry to populate."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE        Iterated to the next entry, @p aEntry and @p aIterator are updated."]
    #[doc = " @retval OT_ERROR_NOT_FOUND   No more entries in the table."]
    #[doc = ""]
    pub fn otBorderRoutingGetNextPrefixTableEntry(
        aInstance: *mut otInstance,
        aIterator: *mut otBorderRoutingPrefixTableIterator,
        aEntry: *mut otBorderRoutingPrefixTableEntry,
    ) -> otError;
}
extern "C" {
    #[doc = " This method provides a full or stable copy of the local Thread Network Data."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]      aStable      TRUE when copying the stable version, FALSE when copying the full version."]
    #[doc = " @param[out]     aData        A pointer to the data buffer."]
    #[doc = " @param[in,out]  aDataLength  On entry, size of the data buffer pointed to by @p aData."]
    #[doc = "                              On exit, number of copied bytes."]
    pub fn otBorderRouterGetNetData(
        aInstance: *mut otInstance,
        aStable: bool,
        aData: *mut u8,
        aDataLength: *mut u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Add a border router configuration to the local network data."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aConfig   A pointer to the border router configuration."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully added the configuration to the local network data."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  One or more configuration parameters were invalid."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Not enough room is available to add the configuration to the local network data."]
    #[doc = ""]
    #[doc = " @sa otBorderRouterRemoveOnMeshPrefix"]
    #[doc = " @sa otBorderRouterRegister"]
    pub fn otBorderRouterAddOnMeshPrefix(
        aInstance: *mut otInstance,
        aConfig: *const otBorderRouterConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove a border router configuration from the local network data."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPrefix   A pointer to an IPv6 prefix."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully removed the configuration from the local network data."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  Could not find the Border Router entry."]
    #[doc = ""]
    #[doc = " @sa otBorderRouterAddOnMeshPrefix"]
    #[doc = " @sa otBorderRouterRegister"]
    pub fn otBorderRouterRemoveOnMeshPrefix(
        aInstance: *mut otInstance,
        aPrefix: *const otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the next On Mesh Prefix in the local Network Data."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator  A pointer to the Network Data iterator context. To get the first on-mesh entry"]
    #[doc = "it should be set to OT_NETWORK_DATA_ITERATOR_INIT."]
    #[doc = " @param[out]     aConfig    A pointer to the On Mesh Prefix information."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully found the next On Mesh prefix."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No subsequent On Mesh prefix exists in the Thread Network Data."]
    #[doc = ""]
    pub fn otBorderRouterGetNextOnMeshPrefix(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aConfig: *mut otBorderRouterConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Add an external route configuration to the local network data."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aConfig   A pointer to the external route configuration."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully added the configuration to the local network data."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  One or more configuration parameters were invalid."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Not enough room is available to add the configuration to the local network data."]
    #[doc = ""]
    #[doc = " @sa otBorderRouterRemoveRoute"]
    #[doc = " @sa otBorderRouterRegister"]
    pub fn otBorderRouterAddRoute(
        aInstance: *mut otInstance,
        aConfig: *const otExternalRouteConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove an external route configuration from the local network data."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPrefix   A pointer to an IPv6 prefix."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully removed the configuration from the local network data."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  Could not find the Border Router entry."]
    #[doc = ""]
    #[doc = " @sa otBorderRouterAddRoute"]
    #[doc = " @sa otBorderRouterRegister"]
    pub fn otBorderRouterRemoveRoute(
        aInstance: *mut otInstance,
        aPrefix: *const otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the next external route in the local Network Data."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator  A pointer to the Network Data iterator context. To get the first external route entry"]
    #[doc = "it should be set to OT_NETWORK_DATA_ITERATOR_INIT."]
    #[doc = " @param[out]     aConfig    A pointer to the External Route information."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully found the next External Route."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No subsequent external route entry exists in the Thread Network Data."]
    #[doc = ""]
    pub fn otBorderRouterGetNextRoute(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aConfig: *mut otExternalRouteConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Immediately register the local network data with the Leader."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE  Successfully queued a Server Data Request message for delivery."]
    #[doc = ""]
    #[doc = " @sa otBorderRouterAddOnMeshPrefix"]
    #[doc = " @sa otBorderRouterRemoveOnMeshPrefix"]
    #[doc = " @sa otBorderRouterAddRoute"]
    #[doc = " @sa otBorderRouterRemoveRoute"]
    pub fn otBorderRouterRegister(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Requests a Thread network channel change."]
    #[doc = ""]
    #[doc = " The network switches to the given channel after a specified delay (see #otChannelManagerSetDelay()). The channel"]
    #[doc = " change is performed by updating the Pending Operational Dataset."]
    #[doc = ""]
    #[doc = " A subsequent call will cancel an ongoing previously requested channel change."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannel           The new channel for the Thread network."]
    #[doc = ""]
    pub fn otChannelManagerRequestChannelChange(aInstance: *mut otInstance, aChannel: u8);
}
extern "C" {
    #[doc = " This function gets the channel from the last successful call to `otChannelManagerRequestChannelChange()`"]
    #[doc = ""]
    #[doc = " @returns The last requested channel or zero if there has been no channel change request yet."]
    #[doc = ""]
    pub fn otChannelManagerGetRequestedChannel(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " This function gets the delay (in seconds) used by Channel Manager for a channel change."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The delay (in seconds) for channel change."]
    #[doc = ""]
    pub fn otChannelManagerGetDelay(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the delay (in seconds) used for a channel change."]
    #[doc = ""]
    #[doc = " The delay should preferably be longer than the maximum data poll interval used by all sleepy-end-devices within the"]
    #[doc = " Thread network."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDelay             Delay in seconds."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Delay was updated successfully."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The given delay @p aDelay is too short."]
    #[doc = ""]
    pub fn otChannelManagerSetDelay(aInstance: *mut otInstance, aDelay: u16) -> otError;
}
extern "C" {
    #[doc = " This function requests that `ChannelManager` checks and selects a new channel and starts a channel change."]
    #[doc = ""]
    #[doc = " Unlike the `otChannelManagerRequestChannelChange()` where the channel must be given as a parameter, this function"]
    #[doc = " asks the `ChannelManager` to select a channel by itself (based on collected channel quality info)."]
    #[doc = ""]
    #[doc = " Once called, the Channel Manager will perform the following 3 steps:"]
    #[doc = ""]
    #[doc = " 1) `ChannelManager` decides if the channel change would be helpful. This check can be skipped if"]
    #[doc = "    `aSkipQualityCheck` is set to true (forcing a channel selection to happen and skipping the quality check)."]
    #[doc = "    This step uses the collected link quality metrics on the device (such as CCA failure rate, frame and message"]
    #[doc = "    error rates per neighbor, etc.) to determine if the current channel quality is at the level that justifies"]
    #[doc = "    a channel change."]
    #[doc = ""]
    #[doc = " 2) If the first step passes, then `ChannelManager` selects a potentially better channel. It uses the collected"]
    #[doc = "    channel quality data by `ChannelMonitor` module. The supported and favored channels are used at this step."]
    #[doc = "    (see otChannelManagerSetSupportedChannels() and otChannelManagerSetFavoredChannels())."]
    #[doc = ""]
    #[doc = " 3) If the newly selected channel is different from the current channel, `ChannelManager` requests/starts the"]
    #[doc = "    channel change process (internally invoking a `RequestChannelChange()`)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance                A pointer to an OpenThread instance."]
    #[doc = " @param[in] aSkipQualityCheck        Indicates whether the quality check (step 1) should be skipped."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE               Channel selection finished successfully."]
    #[doc = " @retval OT_ERROR_NOT_FOUND          Supported channel mask is empty, therefore could not select a channel."]
    #[doc = ""]
    pub fn otChannelManagerRequestChannelSelect(
        aInstance: *mut otInstance,
        aSkipQualityCheck: bool,
    ) -> otError;
}
extern "C" {
    #[doc = " Enables or disables the auto-channel-selection functionality."]
    #[doc = ""]
    #[doc = " When enabled, `ChannelManager` will periodically invoke a `RequestChannelSelect(false)`. The period interval"]
    #[doc = " can be set by `SetAutoChannelSelectionInterval()`."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnabled     Indicates whether to enable or disable this functionality."]
    #[doc = ""]
    pub fn otChannelManagerSetAutoChannelSelectionEnabled(
        aInstance: *mut otInstance,
        aEnabled: bool,
    );
}
extern "C" {
    #[doc = " This function indicates whether the auto-channel-selection functionality is enabled or not."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns TRUE if enabled, FALSE if disabled."]
    #[doc = ""]
    pub fn otChannelManagerGetAutoChannelSelectionEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Sets the period interval (in seconds) used by auto-channel-selection functionality."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in] aInterval   The interval in seconds."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           The interval was set successfully."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   The @p aInterval is not valid (zero)."]
    #[doc = ""]
    pub fn otChannelManagerSetAutoChannelSelectionInterval(
        aInstance: *mut otInstance,
        aInterval: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the period interval (in seconds) used by auto-channel-selection functionality."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The interval in seconds."]
    #[doc = ""]
    pub fn otChannelManagerGetAutoChannelSelectionInterval(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Gets the supported channel mask."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  The supported channels as a bit-mask."]
    #[doc = ""]
    pub fn otChannelManagerGetSupportedChannels(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the supported channel mask."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannelMask  A channel mask."]
    #[doc = ""]
    pub fn otChannelManagerSetSupportedChannels(aInstance: *mut otInstance, aChannelMask: u32);
}
extern "C" {
    #[doc = " Gets the favored channel mask."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  The favored channels as a bit-mask."]
    #[doc = ""]
    pub fn otChannelManagerGetFavoredChannels(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the favored channel mask."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannelMask  A channel mask."]
    #[doc = ""]
    pub fn otChannelManagerSetFavoredChannels(aInstance: *mut otInstance, aChannelMask: u32);
}
extern "C" {
    #[doc = " Gets the CCA failure rate threshold."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  The CCA failure rate threshold. Value 0 maps to 0% and 0xffff maps to 100%."]
    #[doc = ""]
    pub fn otChannelManagerGetCcaFailureRateThreshold(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the CCA failure rate threshold."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aThreshold    A CCA failure rate threshold. Value 0 maps to 0% and 0xffff maps to 100%."]
    #[doc = ""]
    pub fn otChannelManagerSetCcaFailureRateThreshold(aInstance: *mut otInstance, aThreshold: u16);
}
extern "C" {
    #[doc = " Enables or disables the Channel Monitoring operation."]
    #[doc = ""]
    #[doc = " Once operation starts, any previously collected data is cleared. However, after operation is disabled, the previous"]
    #[doc = " collected data is still valid and can be read."]
    #[doc = ""]
    #[doc = " @note OpenThread core internally enables or disables the Channel Monitoring operation when the IPv6 interface is"]
    #[doc = " brought up or down, for example in a call to `otIp6SetEnabled()`."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnabled        TRUE to enable/start Channel Monitoring operation, FALSE to disable/stop it."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE      Channel Monitoring state changed successfully"]
    #[doc = " @retval OT_ERROR_ALREADY   Channel Monitoring is already in the same state."]
    #[doc = ""]
    pub fn otChannelMonitorSetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether the Channel Monitoring operation is enabled and running."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns TRUE if the Channel Monitoring operation is enabled, FALSE otherwise."]
    #[doc = ""]
    pub fn otChannelMonitorIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get channel monitoring sample interval in milliseconds."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  The channel monitor sample interval in milliseconds."]
    #[doc = ""]
    pub fn otChannelMonitorGetSampleInterval(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Get channel monitoring RSSI threshold in dBm."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  The RSSI threshold in dBm."]
    #[doc = ""]
    pub fn otChannelMonitorGetRssiThreshold(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Get channel monitoring averaging sample window length (number of samples)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  The averaging sample window."]
    #[doc = ""]
    pub fn otChannelMonitorGetSampleWindow(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Get channel monitoring total number of RSSI samples (per channel)."]
    #[doc = ""]
    #[doc = " The count indicates total number samples per channel by channel monitoring module since its start (since Thread"]
    #[doc = " network interface was enabled)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  Total number of RSSI samples (per channel) taken so far."]
    #[doc = ""]
    pub fn otChannelMonitorGetSampleCount(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Gets the current channel occupancy for a given channel."]
    #[doc = ""]
    #[doc = " The channel occupancy value represents the average rate/percentage of RSSI samples that were above RSSI threshold"]
    #[doc = " (\"bad\" RSSI samples)."]
    #[doc = ""]
    #[doc = " For the first \"sample window\" samples, the average is maintained as the actual percentage (i.e., ratio of number"]
    #[doc = " of \"bad\" samples by total number of samples). After \"window\" samples, the averager uses an exponentially"]
    #[doc = " weighted moving average. Practically, this means the average is representative of up to `3 * window` last samples"]
    #[doc = " with highest weight given to the latest `kSampleWindow` samples."]
    #[doc = ""]
    #[doc = " Max value of `0xffff` indicates all RSSI samples were above RSSI threshold (i.e. 100% of samples were \"bad\")."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannel        The channel for which to get the link occupancy."]
    #[doc = ""]
    #[doc = " @returns The current channel occupancy for the given channel."]
    #[doc = ""]
    pub fn otChannelMonitorGetChannelOccupancy(aInstance: *mut otInstance, aChannel: u8) -> u16;
}
extern "C" {
    #[doc = " Gets the child supervision interval (in seconds) on a child."]
    #[doc = ""]
    #[doc = " Child supervision feature provides a mechanism for a sleepy child to ask its parent to ensure to send a message to"]
    #[doc = " it within the supervision interval. If there is no transmission to the child within the supervision interval,"]
    #[doc = " parent sends a supervision message (a data message with empty payload) to the child."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  The child supervision interval. Zero indicates that supervision is disabled."]
    #[doc = ""]
    pub fn otChildSupervisionGetInterval(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the child supervision interval (in seconds) on the child."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aInterval       The supervision interval (in seconds). Zero to disable supervision."]
    #[doc = ""]
    pub fn otChildSupervisionSetInterval(aInstance: *mut otInstance, aInterval: u16);
}
extern "C" {
    #[doc = " Gets the supervision check timeout interval (in seconds) on the child."]
    #[doc = ""]
    #[doc = " If the device is a sleepy child and it does not hear from its parent within the specified check timeout, it initiates"]
    #[doc = " the re-attach process (MLE Child Update Request/Response exchange with its parent)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  The supervision check timeout. Zero indicates that supervision check on the child is disabled."]
    #[doc = ""]
    pub fn otChildSupervisionGetCheckTimeout(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the supervision check timeout interval (in seconds)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aTimeout        The check timeout (in seconds). Zero to disable supervision check on the child."]
    #[doc = ""]
    pub fn otChildSupervisionSetCheckTimeout(aInstance: *mut otInstance, aTimeout: u16);
}
extern "C" {
    #[doc = " Get the value of supervision check timeout failure counter."]
    #[doc = ""]
    #[doc = " The counter tracks the number of supervision check failures on the child. It is incremented when the child does"]
    #[doc = " not hear from its parent within the specified check timeout interval."]
    #[doc = ""]
    pub fn otChildSupervisionGetCheckFailureCounter(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Reset the supervision check timeout failure counter to zero."]
    #[doc = ""]
    pub fn otChildSupervisionResetCheckFailureCounter(aInstance: *mut otInstance);
}
#[doc = " This structure represents a CLI command."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCliCommand {
    #[doc = "< A pointer to the command string."]
    pub mName: *const ::std::os::raw::c_char,
    pub mCommand: ::std::option::Option<
        unsafe extern "C" fn(
            aContext: *mut ::std::os::raw::c_void,
            aArgsLength: u8,
            aArgs: *mut *mut ::std::os::raw::c_char,
        ) -> otError,
    >,
}
impl Default for otCliCommand {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This function pointer is called to notify about Console output."]
#[doc = ""]
#[doc = " @param[out] aContext    A user context pointer."]
#[doc = " @param[in]  aFormat     The format string."]
#[doc = " @param[in]  aArguments  The format string arguments."]
#[doc = ""]
#[doc = " @returns                Number of bytes written by the callback."]
#[doc = ""]
pub type otCliOutputCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aFormat: *const ::std::os::raw::c_char,
        aArguments: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Initialize the CLI module."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = " @param[in]  aCallback   A callback method called to process CLI output."]
    #[doc = " @param[in]  aContext    A user context pointer."]
    #[doc = ""]
    pub fn otCliInit(
        aInstance: *mut otInstance,
        aCallback: otCliOutputCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This method is called to feed in a console input line."]
    #[doc = ""]
    #[doc = " @param[in]  aBuf        A pointer to a null-terminated string."]
    #[doc = ""]
    pub fn otCliInputLine(aBuf: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set a user command table."]
    #[doc = ""]
    #[doc = " @param[in]  aUserCommands  A pointer to an array with user commands."]
    #[doc = " @param[in]  aLength        @p aUserCommands length."]
    #[doc = " @param[in]  aContext       @p The context passed to the handler."]
    #[doc = ""]
    pub fn otCliSetUserCommands(
        aUserCommands: *const otCliCommand,
        aLength: u8,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Write a number of bytes to the CLI console as a hex string."]
    #[doc = ""]
    #[doc = " @param[in]  aBytes   A pointer to data which should be printed."]
    #[doc = " @param[in]  aLength  @p aBytes length."]
    #[doc = ""]
    pub fn otCliOutputBytes(aBytes: *const u8, aLength: u8);
}
extern "C" {
    #[doc = " Write formatted string to the CLI console"]
    #[doc = ""]
    #[doc = " @param[in]  aFmt   A pointer to the format string."]
    #[doc = " @param[in]  ...    A matching list of arguments."]
    #[doc = ""]
    pub fn otCliOutputFormat(aFmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Write error code to the CLI console"]
    #[doc = ""]
    #[doc = " If the @p aError is `OT_ERROR_PENDING` nothing will be outputted."]
    #[doc = ""]
    #[doc = " @param[in]  aError Error code value."]
    #[doc = ""]
    pub fn otCliAppendResult(aError: otError);
}
extern "C" {
    #[doc = " Callback to write the OpenThread Log to the CLI console"]
    #[doc = ""]
    #[doc = " @param[in]  aLogLevel   The log level."]
    #[doc = " @param[in]  aLogRegion  The log region."]
    #[doc = " @param[in]  aFormat     A pointer to the format string."]
    #[doc = " @param[in]  aArgs       va_list matching aFormat."]
    #[doc = ""]
    pub fn otCliPlatLogv(
        aLogLevel: otLogLevel,
        aLogRegion: otLogRegion,
        aFormat: *const ::std::os::raw::c_char,
        aArgs: *mut __va_list_tag,
    );
}
#[doc = "< Confirmable"]
pub const OT_COAP_TYPE_CONFIRMABLE: otCoapType = 0;
#[doc = "< Non-confirmable"]
pub const OT_COAP_TYPE_NON_CONFIRMABLE: otCoapType = 1;
#[doc = "< Acknowledgment"]
pub const OT_COAP_TYPE_ACKNOWLEDGMENT: otCoapType = 2;
#[doc = "< Reset"]
pub const OT_COAP_TYPE_RESET: otCoapType = 3;
#[doc = " CoAP Type values (2 bit unsigned integer)."]
#[doc = ""]
pub type otCoapType = ::std::os::raw::c_uint;
#[doc = "< Empty message code"]
pub const OT_COAP_CODE_EMPTY: otCoapCode = 0;
#[doc = "< Get"]
pub const OT_COAP_CODE_GET: otCoapCode = 1;
#[doc = "< Post"]
pub const OT_COAP_CODE_POST: otCoapCode = 2;
#[doc = "< Put"]
pub const OT_COAP_CODE_PUT: otCoapCode = 3;
#[doc = "< Delete"]
pub const OT_COAP_CODE_DELETE: otCoapCode = 4;
#[doc = "< 2.00"]
pub const OT_COAP_CODE_RESPONSE_MIN: otCoapCode = 64;
#[doc = "< Created"]
pub const OT_COAP_CODE_CREATED: otCoapCode = 65;
#[doc = "< Deleted"]
pub const OT_COAP_CODE_DELETED: otCoapCode = 66;
#[doc = "< Valid"]
pub const OT_COAP_CODE_VALID: otCoapCode = 67;
#[doc = "< Changed"]
pub const OT_COAP_CODE_CHANGED: otCoapCode = 68;
#[doc = "< Content"]
pub const OT_COAP_CODE_CONTENT: otCoapCode = 69;
#[doc = "< RFC7959 Continue"]
pub const OT_COAP_CODE_CONTINUE: otCoapCode = 95;
#[doc = "< Bad Request"]
pub const OT_COAP_CODE_BAD_REQUEST: otCoapCode = 128;
#[doc = "< Unauthorized"]
pub const OT_COAP_CODE_UNAUTHORIZED: otCoapCode = 129;
#[doc = "< Bad Option"]
pub const OT_COAP_CODE_BAD_OPTION: otCoapCode = 130;
#[doc = "< Forbidden"]
pub const OT_COAP_CODE_FORBIDDEN: otCoapCode = 131;
#[doc = "< Not Found"]
pub const OT_COAP_CODE_NOT_FOUND: otCoapCode = 132;
#[doc = "< Method Not Allowed"]
pub const OT_COAP_CODE_METHOD_NOT_ALLOWED: otCoapCode = 133;
#[doc = "< Not Acceptable"]
pub const OT_COAP_CODE_NOT_ACCEPTABLE: otCoapCode = 134;
#[doc = "< RFC7959 Request Entity Incomplete"]
pub const OT_COAP_CODE_REQUEST_INCOMPLETE: otCoapCode = 136;
#[doc = "< Precondition Failed"]
pub const OT_COAP_CODE_PRECONDITION_FAILED: otCoapCode = 140;
#[doc = "< Request Entity Too Large"]
pub const OT_COAP_CODE_REQUEST_TOO_LARGE: otCoapCode = 141;
#[doc = "< Unsupported Content-Format"]
pub const OT_COAP_CODE_UNSUPPORTED_FORMAT: otCoapCode = 143;
#[doc = "< Internal Server Error"]
pub const OT_COAP_CODE_INTERNAL_ERROR: otCoapCode = 160;
#[doc = "< Not Implemented"]
pub const OT_COAP_CODE_NOT_IMPLEMENTED: otCoapCode = 161;
#[doc = "< Bad Gateway"]
pub const OT_COAP_CODE_BAD_GATEWAY: otCoapCode = 162;
#[doc = "< Service Unavailable"]
pub const OT_COAP_CODE_SERVICE_UNAVAILABLE: otCoapCode = 163;
#[doc = "< Gateway Timeout"]
pub const OT_COAP_CODE_GATEWAY_TIMEOUT: otCoapCode = 164;
#[doc = "< Proxying Not Supported"]
pub const OT_COAP_CODE_PROXY_NOT_SUPPORTED: otCoapCode = 165;
#[doc = " CoAP Code values."]
#[doc = ""]
pub type otCoapCode = ::std::os::raw::c_uint;
#[doc = "< If-Match"]
pub const OT_COAP_OPTION_IF_MATCH: otCoapOptionType = 1;
#[doc = "< Uri-Host"]
pub const OT_COAP_OPTION_URI_HOST: otCoapOptionType = 3;
#[doc = "< ETag"]
pub const OT_COAP_OPTION_E_TAG: otCoapOptionType = 4;
#[doc = "< If-None-Match"]
pub const OT_COAP_OPTION_IF_NONE_MATCH: otCoapOptionType = 5;
#[doc = "< Observe [RFC7641]"]
pub const OT_COAP_OPTION_OBSERVE: otCoapOptionType = 6;
#[doc = "< Uri-Port"]
pub const OT_COAP_OPTION_URI_PORT: otCoapOptionType = 7;
#[doc = "< Location-Path"]
pub const OT_COAP_OPTION_LOCATION_PATH: otCoapOptionType = 8;
#[doc = "< Uri-Path"]
pub const OT_COAP_OPTION_URI_PATH: otCoapOptionType = 11;
#[doc = "< Content-Format"]
pub const OT_COAP_OPTION_CONTENT_FORMAT: otCoapOptionType = 12;
#[doc = "< Max-Age"]
pub const OT_COAP_OPTION_MAX_AGE: otCoapOptionType = 14;
#[doc = "< Uri-Query"]
pub const OT_COAP_OPTION_URI_QUERY: otCoapOptionType = 15;
#[doc = "< Accept"]
pub const OT_COAP_OPTION_ACCEPT: otCoapOptionType = 17;
#[doc = "< Location-Query"]
pub const OT_COAP_OPTION_LOCATION_QUERY: otCoapOptionType = 20;
#[doc = "< Block2 (RFC7959)"]
pub const OT_COAP_OPTION_BLOCK2: otCoapOptionType = 23;
#[doc = "< Block1 (RFC7959)"]
pub const OT_COAP_OPTION_BLOCK1: otCoapOptionType = 27;
#[doc = "< Size2 (RFC7959)"]
pub const OT_COAP_OPTION_SIZE2: otCoapOptionType = 28;
#[doc = "< Proxy-Uri"]
pub const OT_COAP_OPTION_PROXY_URI: otCoapOptionType = 35;
#[doc = "< Proxy-Scheme"]
pub const OT_COAP_OPTION_PROXY_SCHEME: otCoapOptionType = 39;
#[doc = "< Size1"]
pub const OT_COAP_OPTION_SIZE1: otCoapOptionType = 60;
#[doc = " CoAP Option Numbers"]
pub type otCoapOptionType = ::std::os::raw::c_uint;
#[doc = " This structure represents a CoAP option."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otCoapOption {
    #[doc = "< Option Number"]
    pub mNumber: u16,
    #[doc = "< Option Length"]
    pub mLength: u16,
}
#[doc = " This structure acts as an iterator for CoAP options"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCoapOptionIterator {
    #[doc = "< CoAP message"]
    pub mMessage: *const otMessage,
    #[doc = "< CoAP message option"]
    pub mOption: otCoapOption,
    #[doc = "< Byte offset of next option"]
    pub mNextOptionOffset: u16,
}
impl Default for otCoapOptionIterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " text/plain; charset=utf-8: [RFC2046][RFC3676][RFC5147]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_TEXT_PLAIN: otCoapOptionContentFormat = 0;
#[doc = " application/cose; cose-type=\"cose-encrypt0\": [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_ENCRYPT0: otCoapOptionContentFormat = 16;
#[doc = " application/cose; cose-type=\"cose-mac0\": [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_MAC0: otCoapOptionContentFormat = 17;
#[doc = " application/cose; cose-type=\"cose-sign1\": [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_SIGN1: otCoapOptionContentFormat = 18;
#[doc = " application/link-format: [RFC6690]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_LINK_FORMAT: otCoapOptionContentFormat = 40;
#[doc = " application/xml: [RFC3023]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_XML: otCoapOptionContentFormat = 41;
#[doc = " application/octet-stream: [RFC2045][RFC2046]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_OCTET_STREAM: otCoapOptionContentFormat = 42;
#[doc = " application/exi:"]
#[doc = " [\"Efficient XML Interchange (EXI) Format 1.0 (Second Edition)\", February 2014]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_EXI: otCoapOptionContentFormat = 47;
#[doc = " application/json: [RFC7159]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_JSON: otCoapOptionContentFormat = 50;
#[doc = " application/json-patch+json: [RFC6902]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_JSON_PATCH_JSON: otCoapOptionContentFormat = 51;
#[doc = " application/merge-patch+json: [RFC7396]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_MERGE_PATCH_JSON: otCoapOptionContentFormat = 52;
#[doc = " application/cbor: [RFC7049]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_CBOR: otCoapOptionContentFormat = 60;
#[doc = " application/cwt: [RFC8392]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_CWT: otCoapOptionContentFormat = 61;
#[doc = " application/cose; cose-type=\"cose-encrypt\": [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_ENCRYPT: otCoapOptionContentFormat = 96;
#[doc = " application/cose; cose-type=\"cose-mac\": [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_MAC: otCoapOptionContentFormat = 97;
#[doc = " application/cose; cose-type=\"cose-sign\": [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_SIGN: otCoapOptionContentFormat = 98;
#[doc = " application/cose-key: [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_KEY: otCoapOptionContentFormat = 101;
#[doc = " application/cose-key-set: [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_KEY_SET: otCoapOptionContentFormat = 102;
#[doc = " application/senml+json: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENML_JSON: otCoapOptionContentFormat = 110;
#[doc = " application/sensml+json: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENSML_JSON: otCoapOptionContentFormat = 111;
#[doc = " application/senml+cbor: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENML_CBOR: otCoapOptionContentFormat = 112;
#[doc = " application/sensml+cbor: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENSML_CBOR: otCoapOptionContentFormat = 113;
#[doc = " application/senml-exi: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENML_EXI: otCoapOptionContentFormat = 114;
#[doc = " application/sensml-exi: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENSML_EXI: otCoapOptionContentFormat = 115;
#[doc = " application/coap-group+json: [RFC7390]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COAP_GROUP_JSON: otCoapOptionContentFormat = 256;
#[doc = " application/senml+xml: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENML_XML: otCoapOptionContentFormat = 310;
#[doc = " application/sensml+xml: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENSML_XML: otCoapOptionContentFormat = 311;
#[doc = " CoAP Content Format codes.  The full list is documented at"]
#[doc = " https://www.iana.org/assignments/core-parameters/core-parameters.xhtml#content-formats"]
pub type otCoapOptionContentFormat = ::std::os::raw::c_uint;
pub const OT_COAP_OPTION_BLOCK_SZX_16: otCoapBlockSzx = 0;
pub const OT_COAP_OPTION_BLOCK_SZX_32: otCoapBlockSzx = 1;
pub const OT_COAP_OPTION_BLOCK_SZX_64: otCoapBlockSzx = 2;
pub const OT_COAP_OPTION_BLOCK_SZX_128: otCoapBlockSzx = 3;
pub const OT_COAP_OPTION_BLOCK_SZX_256: otCoapBlockSzx = 4;
pub const OT_COAP_OPTION_BLOCK_SZX_512: otCoapBlockSzx = 5;
pub const OT_COAP_OPTION_BLOCK_SZX_1024: otCoapBlockSzx = 6;
#[doc = " CoAP Block Size Exponents"]
pub type otCoapBlockSzx = ::std::os::raw::c_uint;
#[doc = " This function pointer is called when a CoAP response is received or on the request timeout."]
#[doc = ""]
#[doc = " @param[in]  aContext      A pointer to application-specific context."]
#[doc = " @param[in]  aMessage      A pointer to the message buffer containing the response. NULL if no response was received."]
#[doc = " @param[in]  aMessageInfo  A pointer to the message info for @p aMessage. NULL if no response was received."]
#[doc = " @param[in]  aResult       A result of the CoAP transaction."]
#[doc = ""]
#[doc = " @retval  OT_ERROR_NONE              A response was received successfully."]
#[doc = " @retval  OT_ERROR_ABORT             A CoAP transaction was reset by peer."]
#[doc = " @retval  OT_ERROR_RESPONSE_TIMEOUT  No response or acknowledgment received during timeout period."]
#[doc = ""]
pub type otCoapResponseHandler = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aResult: otError,
    ),
>;
#[doc = " This function pointer is called when a CoAP request with a given Uri-Path is received."]
#[doc = ""]
#[doc = " @param[in]  aContext      A pointer to arbitrary context information."]
#[doc = " @param[in]  aMessage      A pointer to the message."]
#[doc = " @param[in]  aMessageInfo  A pointer to the message info for @p aMessage."]
#[doc = ""]
pub type otCoapRequestHandler = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ),
>;
#[doc = " This function pointer is called when a CoAP message with an block-wise transfer option is received."]
#[doc = ""]
#[doc = " This function is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE configuration"]
#[doc = " is enabled."]
#[doc = ""]
#[doc = " @param[in]  aContext     A pointer to application-specific context."]
#[doc = " @param[in]  aBlock       A pointer to the block segment."]
#[doc = " @param[in]  aPosition    The position of @p aBlock in a sequence in bytes."]
#[doc = " @param[in]  aBlockLength The length of the block segment in bytes."]
#[doc = " @param[in]  aMore        Flag if more block segments are following."]
#[doc = " @param[in]  aTotalLength The total length in bytes of the transferred information (indicated by a Size1 or Size2"]
#[doc = "                          option)."]
#[doc = ""]
#[doc = " @retval  OT_ERROR_NONE               Block segment was stored successfully."]
#[doc = " @retval  OT_ERROR_NO_BUFS            No more memory to store blocks."]
#[doc = " @retval  OT_ERROR_NO_FRAME_RECEIVED  Block segment missing."]
#[doc = ""]
pub type otCoapBlockwiseReceiveHook = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aBlock: *const u8,
        aPosition: u32,
        aBlockLength: u16,
        aMore: bool,
        aTotalLength: u32,
    ) -> otError,
>;
#[doc = " This function pointer is called before the next block in a block-wise transfer is sent."]
#[doc = ""]
#[doc = " This function is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE configuration"]
#[doc = " is enabled."]
#[doc = ""]
#[doc = " @param[in]       aContext     A pointer to application-specific context."]
#[doc = " @param[in,out]   aBlock       A pointer to where the block segment can be written to."]
#[doc = " @param[in]       aPosition    The position in a sequence from which to obtain the block segment."]
#[doc = " @param[in,out]   aBlockLength On entry, the maximum block segment length in bytes."]
#[doc = " @param[out]      aMore        A pointer to the flag if more block segments will follow."]
#[doc = ""]
#[doc = " @warning By changing the value of aBlockLength, the block size of the whole exchange is"]
#[doc = "          renegotiated. It is recommended to do this after the first block has been received as"]
#[doc = "          later changes could cause problems with other CoAP implementations."]
#[doc = ""]
#[doc = " @retval  OT_ERROR_NONE           No error occurred."]
#[doc = " @retval  OT_ERROR_INVALID_ARGS   Block at @p aPosition does not exist."]
#[doc = ""]
pub type otCoapBlockwiseTransmitHook = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aBlock: *mut u8,
        aPosition: u32,
        aBlockLength: *mut u16,
        aMore: *mut bool,
    ) -> otError,
>;
#[doc = " This structure represents a CoAP resource."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCoapResource {
    #[doc = "< The URI Path string"]
    pub mUriPath: *const ::std::os::raw::c_char,
    #[doc = "< The callback for handling a received request"]
    pub mHandler: otCoapRequestHandler,
    #[doc = "< Application-specific context"]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< The next CoAP resource in the list"]
    pub mNext: *mut otCoapResource,
}
impl Default for otCoapResource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents a CoAP resource with block-wise transfer."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCoapBlockwiseResource {
    #[doc = "< The URI Path string"]
    pub mUriPath: *const ::std::os::raw::c_char,
    #[doc = "< The callback for handling a received request"]
    pub mHandler: otCoapRequestHandler,
    #[doc = " The callback for handling incoming block-wise transfer."]
    #[doc = "  This callback is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE"]
    #[doc = "  configuration is enabled."]
    pub mReceiveHook: otCoapBlockwiseReceiveHook,
    #[doc = " The callback for handling outgoing block-wise transfer."]
    #[doc = "  This callback is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE"]
    #[doc = "  configuration is enabled."]
    pub mTransmitHook: otCoapBlockwiseTransmitHook,
    #[doc = "< Application-specific context"]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< The next CoAP resource in the list"]
    pub mNext: *mut otCoapBlockwiseResource,
}
impl Default for otCoapBlockwiseResource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents the CoAP transmission parameters."]
#[doc = ""]
#[doc = " @note mAckTimeout * ((2 ** (mMaxRetransmit + 1)) - 1) * (mAckRandomFactorNumerator / mAckRandomFactorDenominator)"]
#[doc = "       must not exceed what can be represented by a uint32_t (0xffffffff). This limitation allows OpenThread to"]
#[doc = "       avoid 64-bit arithmetic."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otCoapTxParameters {
    #[doc = " Minimum spacing before first retransmission when ACK is not received, in milliseconds (RFC7252 default value is"]
    #[doc = " 2000ms)."]
    #[doc = ""]
    pub mAckTimeout: u32,
    #[doc = " Numerator of ACK_RANDOM_FACTOR used to calculate maximum spacing before first retransmission when ACK is not"]
    #[doc = " received (RFC7252 default value of ACK_RANDOM_FACTOR is 1.5; must not be decreased below 1)."]
    #[doc = ""]
    pub mAckRandomFactorNumerator: u8,
    #[doc = " Denominator of ACK_RANDOM_FACTOR used to calculate maximum spacing before first retransmission when ACK is not"]
    #[doc = " received (RFC7252 default value of ACK_RANDOM_FACTOR is 1.5; must not be decreased below 1)."]
    #[doc = ""]
    pub mAckRandomFactorDenominator: u8,
    #[doc = " Maximum number of retransmissions for CoAP Confirmable messages (RFC7252 default value is 4)."]
    #[doc = ""]
    pub mMaxRetransmit: u8,
}
extern "C" {
    #[doc = " This function initializes the CoAP header."]
    #[doc = ""]
    #[doc = " @param[in,out] aMessage   A pointer to the CoAP message to initialize."]
    #[doc = " @param[in]     aType      CoAP message type."]
    #[doc = " @param[in]     aCode      CoAP message code."]
    #[doc = ""]
    pub fn otCoapMessageInit(aMessage: *mut otMessage, aType: otCoapType, aCode: otCoapCode);
}
extern "C" {
    #[doc = " This function initializes a response message."]
    #[doc = ""]
    #[doc = " @note Both message ID and token are set according to @p aRequest."]
    #[doc = ""]
    #[doc = " @param[in,out]  aResponse  A pointer to the CoAP response message."]
    #[doc = " @param[in]      aRequest   A pointer to the CoAP request message."]
    #[doc = " @param[in]      aType      CoAP message type."]
    #[doc = " @param[in]      aCode      CoAP message code."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully initialized the response message."]
    #[doc = " @retval OT_ERROR_NO_BUFS  Insufficient message buffers available to initialize the response message."]
    #[doc = ""]
    pub fn otCoapMessageInitResponse(
        aResponse: *mut otMessage,
        aRequest: *const otMessage,
        aType: otCoapType,
        aCode: otCoapCode,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the Token value and length in a header."]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage          A pointer to the CoAP message."]
    #[doc = " @param[in]      aToken            A pointer to the Token value."]
    #[doc = " @param[in]      aTokenLength      The Length of @p aToken."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully set the Token value."]
    #[doc = " @retval OT_ERROR_NO_BUFS  Insufficient buffers to set the Token value."]
    #[doc = ""]
    pub fn otCoapMessageSetToken(
        aMessage: *mut otMessage,
        aToken: *const u8,
        aTokenLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the Token length and randomizes its value."]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage      A pointer to the CoAP message."]
    #[doc = " @param[in]      aTokenLength  The Length of a Token to set."]
    #[doc = ""]
    pub fn otCoapMessageGenerateToken(aMessage: *mut otMessage, aTokenLength: u8);
}
extern "C" {
    #[doc = " This function appends the Content Format CoAP option as specified in"]
    #[doc = " https://tools.ietf.org/html/rfc7252#page-92.  This *must* be called before"]
    #[doc = " setting otCoapMessageSetPayloadMarker if a payload is to be included in the"]
    #[doc = " message."]
    #[doc = ""]
    #[doc = " The function is a convenience wrapper around otCoapMessageAppendUintOption,"]
    #[doc = " and if the desired format type code isn't listed in otCoapOptionContentFormat,"]
    #[doc = " this base function should be used instead."]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage          A pointer to the CoAP message."]
    #[doc = " @param[in]      aContentFormat    One of the content formats listed in"]
    #[doc = "                                  otCoapOptionContentFormat above."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully appended the option."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size."]
    #[doc = ""]
    pub fn otCoapMessageAppendContentFormatOption(
        aMessage: *mut otMessage,
        aContentFormat: otCoapOptionContentFormat,
    ) -> otError;
}
extern "C" {
    #[doc = " This function appends a CoAP option in a header."]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage  A pointer to the CoAP message."]
    #[doc = " @param[in]      aNumber   The CoAP Option number."]
    #[doc = " @param[in]      aLength   The CoAP Option length."]
    #[doc = " @param[in]      aValue    A pointer to the CoAP value."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully appended the option."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size."]
    #[doc = ""]
    pub fn otCoapMessageAppendOption(
        aMessage: *mut otMessage,
        aNumber: u16,
        aLength: u16,
        aValue: *const ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function appends an unsigned integer CoAP option as specified in"]
    #[doc = " https://tools.ietf.org/html/rfc7252#section-3.2"]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage A pointer to the CoAP message."]
    #[doc = " @param[in]      aNumber  The CoAP Option number."]
    #[doc = " @param[in]      aValue   The CoAP Option unsigned integer value."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully appended the option."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size."]
    #[doc = ""]
    #[doc = " @see otCoapMessageGetOptionUintValue"]
    pub fn otCoapMessageAppendUintOption(
        aMessage: *mut otMessage,
        aNumber: u16,
        aValue: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " This function appends an Observe option."]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage  A pointer to the CoAP message."]
    #[doc = " @param[in]      aObserve  Observe field value."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully appended the option."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size."]
    #[doc = ""]
    pub fn otCoapMessageAppendObserveOption(aMessage: *mut otMessage, aObserve: u32) -> otError;
}
extern "C" {
    #[doc = " This function appends a Uri-Path option."]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage  A pointer to the CoAP message."]
    #[doc = " @param[in]      aUriPath  A pointer to a NULL-terminated string."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully appended the option."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size."]
    #[doc = ""]
    pub fn otCoapMessageAppendUriPathOptions(
        aMessage: *mut otMessage,
        aUriPath: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function converts a CoAP Block option SZX field to the actual block size"]
    #[doc = ""]
    #[doc = " @param[in]     aSize     Block size exponent."]
    #[doc = ""]
    #[doc = " @returns The actual size exponent value."]
    #[doc = ""]
    pub fn otCoapBlockSizeFromExponent(aSize: otCoapBlockSzx) -> u16;
}
extern "C" {
    #[doc = " This function appends a Block2 option"]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage  A pointer to the CoAP message."]
    #[doc = " @param[in]      aNum      Current block number."]
    #[doc = " @param[in]      aMore     Boolean to indicate more blocks are to be sent."]
    #[doc = " @param[in]      aSize     Block Size Exponent."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully appended the option."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size."]
    #[doc = ""]
    pub fn otCoapMessageAppendBlock2Option(
        aMessage: *mut otMessage,
        aNum: u32,
        aMore: bool,
        aSize: otCoapBlockSzx,
    ) -> otError;
}
extern "C" {
    #[doc = " This function appends a Block1 option"]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage  A pointer to the CoAP message."]
    #[doc = " @param[in]      aNum      Current block number."]
    #[doc = " @param[in]      aMore     Boolean to indicate more blocks are to be sent."]
    #[doc = " @param[in]      aSize     Block Size Exponent."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully appended the option."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size."]
    #[doc = ""]
    pub fn otCoapMessageAppendBlock1Option(
        aMessage: *mut otMessage,
        aNum: u32,
        aMore: bool,
        aSize: otCoapBlockSzx,
    ) -> otError;
}
extern "C" {
    #[doc = " This function appends a Proxy-Uri option."]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage  A pointer to the CoAP message."]
    #[doc = " @param[in]      aUriPath  A pointer to a NULL-terminated string."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully appended the option."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size."]
    #[doc = ""]
    pub fn otCoapMessageAppendProxyUriOption(
        aMessage: *mut otMessage,
        aUriPath: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function appends a Max-Age option."]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage  A pointer to the CoAP message."]
    #[doc = " @param[in]      aMaxAge   The Max-Age value."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully appended the option."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size."]
    #[doc = ""]
    pub fn otCoapMessageAppendMaxAgeOption(aMessage: *mut otMessage, aMaxAge: u32) -> otError;
}
extern "C" {
    #[doc = " This function appends a single Uri-Query option."]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage  A pointer to the CoAP message."]
    #[doc = " @param[in]      aUriQuery A pointer to NULL-terminated string, which should contain a single key=value pair."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully appended the option."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size."]
    pub fn otCoapMessageAppendUriQueryOption(
        aMessage: *mut otMessage,
        aUriQuery: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function adds Payload Marker indicating beginning of the payload to the CoAP header."]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage  A pointer to the CoAP message."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Payload Marker successfully added."]
    #[doc = " @retval OT_ERROR_NO_BUFS  Header Payload Marker exceeds the buffer size."]
    #[doc = ""]
    pub fn otCoapMessageSetPayloadMarker(aMessage: *mut otMessage) -> otError;
}
extern "C" {
    #[doc = " This function returns the Type value."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to the CoAP message."]
    #[doc = ""]
    #[doc = " @returns The Type value."]
    #[doc = ""]
    pub fn otCoapMessageGetType(aMessage: *const otMessage) -> otCoapType;
}
extern "C" {
    #[doc = " This function returns the Code value."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to the CoAP message."]
    #[doc = ""]
    #[doc = " @returns The Code value."]
    #[doc = ""]
    pub fn otCoapMessageGetCode(aMessage: *const otMessage) -> otCoapCode;
}
extern "C" {
    #[doc = " This function sets the Code value."]
    #[doc = ""]
    #[doc = " @param[in,out]  aMessage  A pointer to the CoAP message to initialize."]
    #[doc = " @param[in]      aCode     CoAP message code."]
    #[doc = ""]
    pub fn otCoapMessageSetCode(aMessage: *mut otMessage, aCode: otCoapCode);
}
extern "C" {
    #[doc = " This method returns the CoAP Code as human readable string."]
    #[doc = ""]
    #[doc = " @param[in]   aMessage    A pointer to the CoAP message."]
    #[doc = ""]
    #[doc = " @ returns The CoAP Code as string."]
    #[doc = ""]
    pub fn otCoapMessageCodeToString(aMessage: *const otMessage) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function returns the Message ID value."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to the CoAP message."]
    #[doc = ""]
    #[doc = " @returns The Message ID value."]
    #[doc = ""]
    pub fn otCoapMessageGetMessageId(aMessage: *const otMessage) -> u16;
}
extern "C" {
    #[doc = " This function returns the Token length."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to the CoAP message."]
    #[doc = ""]
    #[doc = " @returns The Token length."]
    #[doc = ""]
    pub fn otCoapMessageGetTokenLength(aMessage: *const otMessage) -> u8;
}
extern "C" {
    #[doc = " This function returns a pointer to the Token value."]
    #[doc = ""]
    #[doc = " @param[in]  aMessage  A pointer to the CoAP message."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Token value."]
    #[doc = ""]
    pub fn otCoapMessageGetToken(aMessage: *const otMessage) -> *const u8;
}
extern "C" {
    #[doc = " This function initialises an iterator for the options in the given message."]
    #[doc = ""]
    #[doc = " @param[in,out]  aIterator A pointer to the CoAP message option iterator."]
    #[doc = " @param[in]      aMessage  A pointer to the CoAP message."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE   Successfully initialised."]
    #[doc = " @retval  OT_ERROR_PARSE  Message state is inconsistent."]
    #[doc = ""]
    pub fn otCoapOptionIteratorInit(
        aIterator: *mut otCoapOptionIterator,
        aMessage: *const otMessage,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns a pointer to the first option matching the specified option number."]
    #[doc = ""]
    #[doc = " @param[in]  aIterator A pointer to the CoAP message option iterator."]
    #[doc = " @param[in]  aOption   The option number sought."]
    #[doc = ""]
    #[doc = " @returns A pointer to the first matching option. If no matching option is present NULL pointer is returned."]
    #[doc = ""]
    pub fn otCoapOptionIteratorGetFirstOptionMatching(
        aIterator: *mut otCoapOptionIterator,
        aOption: u16,
    ) -> *const otCoapOption;
}
extern "C" {
    #[doc = " This function returns a pointer to the first option."]
    #[doc = ""]
    #[doc = " @param[in,out]  aIterator A pointer to the CoAP message option iterator."]
    #[doc = ""]
    #[doc = " @returns A pointer to the first option. If no option is present NULL pointer is returned."]
    #[doc = ""]
    pub fn otCoapOptionIteratorGetFirstOption(
        aIterator: *mut otCoapOptionIterator,
    ) -> *const otCoapOption;
}
extern "C" {
    #[doc = " This function returns a pointer to the next option matching the specified option number."]
    #[doc = ""]
    #[doc = " @param[in]  aIterator A pointer to the CoAP message option iterator."]
    #[doc = " @param[in]  aOption   The option number sought."]
    #[doc = ""]
    #[doc = " @returns A pointer to the next matching option. If no further matching option is present NULL pointer is returned."]
    #[doc = ""]
    pub fn otCoapOptionIteratorGetNextOptionMatching(
        aIterator: *mut otCoapOptionIterator,
        aOption: u16,
    ) -> *const otCoapOption;
}
extern "C" {
    #[doc = " This function returns a pointer to the next option."]
    #[doc = ""]
    #[doc = " @param[in,out]  aIterator A pointer to the CoAP message option iterator."]
    #[doc = ""]
    #[doc = " @returns A pointer to the next option. If no more options are present NULL pointer is returned."]
    #[doc = ""]
    pub fn otCoapOptionIteratorGetNextOption(
        aIterator: *mut otCoapOptionIterator,
    ) -> *const otCoapOption;
}
extern "C" {
    #[doc = " This function fills current option value into @p aValue assuming the current value is an unsigned integer encoded"]
    #[doc = " according to https://tools.ietf.org/html/rfc7252#section-3.2"]
    #[doc = ""]
    #[doc = " @param[in,out]   aIterator   A pointer to the CoAP message option iterator."]
    #[doc = " @param[out]      aValue      A pointer to an unsigned integer to receive the option value."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE       Successfully filled value."]
    #[doc = " @retval  OT_ERROR_NOT_FOUND  No current option."]
    #[doc = " @retval  OT_ERROR_NO_BUFS    Value is too long to fit in a uint64_t."]
    #[doc = ""]
    #[doc = " @see otCoapMessageAppendUintOption"]
    pub fn otCoapOptionIteratorGetOptionUintValue(
        aIterator: *mut otCoapOptionIterator,
        aValue: *mut u64,
    ) -> otError;
}
extern "C" {
    #[doc = " This function fills current option value into @p aValue."]
    #[doc = ""]
    #[doc = " @param[in,out]  aIterator A pointer to the CoAP message option iterator."]
    #[doc = " @param[out]     aValue    A pointer to a buffer to receive the option value."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE       Successfully filled value."]
    #[doc = " @retval  OT_ERROR_NOT_FOUND  No current option."]
    #[doc = ""]
    pub fn otCoapOptionIteratorGetOptionValue(
        aIterator: *mut otCoapOptionIterator,
        aValue: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function creates a new CoAP message."]
    #[doc = ""]
    #[doc = " @note If @p aSettings is 'NULL', the link layer security is enabled and the message priority is set to"]
    #[doc = " OT_MESSAGE_PRIORITY_NORMAL by default."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSettings  A pointer to the message settings or NULL to set default settings."]
    #[doc = ""]
    #[doc = " @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid."]
    #[doc = ""]
    pub fn otCoapNewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " This function sends a CoAP request with custom transmission parameters."]
    #[doc = ""]
    #[doc = " If a response for a request is expected, respective function and context information should be provided."]
    #[doc = " If no response is expected, these arguments should be NULL pointers."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage         A pointer to the message to send."]
    #[doc = " @param[in]  aMessageInfo     A pointer to the message info associated with @p aMessage."]
    #[doc = " @param[in]  aHandler         A function pointer that shall be called on response reception or timeout."]
    #[doc = " @param[in]  aContext         A pointer to arbitrary context information. May be NULL if not used."]
    #[doc = " @param[in]  aTxParameters    A pointer to transmission parameters for this request. Use NULL for defaults."]
    #[doc = "                              Otherwise, parameters given must meet the following conditions:"]
    #[doc = "                              1. mMaxRetransmit is no more than OT_COAP_MAX_RETRANSMIT."]
    #[doc = "                              2. mAckRandomFactorNumerator / mAckRandomFactorDenominator must not be below 1.0."]
    #[doc = "                              3. The calculated exchange life time must not overflow uint32_t."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_INVALID_ARGS    @p aTxParameters is invalid."]
    #[doc = " @retval OT_ERROR_NONE            Successfully sent CoAP message."]
    #[doc = " @retval OT_ERROR_NO_BUFS         Failed to allocate retransmission data."]
    #[doc = ""]
    pub fn otCoapSendRequestWithParameters(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aHandler: otCoapResponseHandler,
        aContext: *mut ::std::os::raw::c_void,
        aTxParameters: *const otCoapTxParameters,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends a CoAP request block-wise with custom transmission parameters."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE configuration"]
    #[doc = " is enabled."]
    #[doc = ""]
    #[doc = " If a response for a request is expected, respective function and context information should be provided."]
    #[doc = " If the response is expected to be block-wise, a respective hook function should be provided."]
    #[doc = " If no response is expected, these arguments should be NULL pointers."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage         A pointer to the message to send."]
    #[doc = " @param[in]  aMessageInfo     A pointer to the message info associated with @p aMessage."]
    #[doc = " @param[in]  aHandler         A function pointer that shall be called on response reception or timeout."]
    #[doc = " @param[in]  aContext         A pointer to arbitrary context information. May be NULL if not used."]
    #[doc = " @param[in]  aTxParameters    A pointer to transmission parameters for this request. Use NULL for defaults."]
    #[doc = " @param[in]  aTransmitHook    A pointer to a hook function for outgoing block-wise transfer."]
    #[doc = " @param[in]  aReceiveHook     A pointer to a hook function for incoming block-wise transfer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully sent CoAP message."]
    #[doc = " @retval OT_ERROR_NO_BUFS Failed to allocate retransmission data."]
    #[doc = ""]
    pub fn otCoapSendRequestBlockWiseWithParameters(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aHandler: otCoapResponseHandler,
        aContext: *mut ::std::os::raw::c_void,
        aTxParameters: *const otCoapTxParameters,
        aTransmitHook: otCoapBlockwiseTransmitHook,
        aReceiveHook: otCoapBlockwiseReceiveHook,
    ) -> otError;
}
extern "C" {
    #[doc = " This function starts the CoAP server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPort      The local UDP port to bind to."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully started the CoAP server."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to start the CoAP server."]
    #[doc = ""]
    pub fn otCoapStart(aInstance: *mut otInstance, aPort: u16) -> otError;
}
extern "C" {
    #[doc = " This function stops the CoAP server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE  Successfully stopped the CoAP server."]
    #[doc = ""]
    pub fn otCoapStop(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function adds a resource to the CoAP server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aResource  A pointer to the resource."]
    #[doc = ""]
    pub fn otCoapAddResource(aInstance: *mut otInstance, aResource: *mut otCoapResource);
}
extern "C" {
    #[doc = " This function removes a resource from the CoAP server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aResource  A pointer to the resource."]
    #[doc = ""]
    pub fn otCoapRemoveResource(aInstance: *mut otInstance, aResource: *mut otCoapResource);
}
extern "C" {
    #[doc = " This function adds a block-wise resource to the CoAP server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aResource  A pointer to the resource."]
    #[doc = ""]
    pub fn otCoapAddBlockWiseResource(
        aInstance: *mut otInstance,
        aResource: *mut otCoapBlockwiseResource,
    );
}
extern "C" {
    #[doc = " This function removes a block-wise resource from the CoAP server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aResource  A pointer to the resource."]
    #[doc = ""]
    pub fn otCoapRemoveBlockWiseResource(
        aInstance: *mut otInstance,
        aResource: *mut otCoapBlockwiseResource,
    );
}
extern "C" {
    #[doc = " This function sets the default handler for unhandled CoAP requests."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aHandler   A function pointer that shall be called when an unhandled request arrives."]
    #[doc = " @param[in]  aContext   A pointer to arbitrary context information. May be NULL if not used."]
    #[doc = ""]
    pub fn otCoapSetDefaultHandler(
        aInstance: *mut otInstance,
        aHandler: otCoapRequestHandler,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function sends a CoAP response from the server with custom transmission parameters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage         A pointer to the CoAP response to send."]
    #[doc = " @param[in]  aMessageInfo     A pointer to the message info associated with @p aMessage."]
    #[doc = " @param[in]  aTxParameters    A pointer to transmission parameters for this response. Use NULL for defaults."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully enqueued the CoAP response message."]
    #[doc = " @retval OT_ERROR_NO_BUFS  Insufficient buffers available to send the CoAP response."]
    #[doc = ""]
    pub fn otCoapSendResponseWithParameters(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aTxParameters: *const otCoapTxParameters,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends a CoAP response block-wise from the server with custom transmission parameters."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE configuration"]
    #[doc = " is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage         A pointer to the CoAP response to send."]
    #[doc = " @param[in]  aMessageInfo     A pointer to the message info associated with @p aMessage."]
    #[doc = " @param[in]  aTxParameters    A pointer to transmission parameters for this response. Use NULL for defaults."]
    #[doc = " @param[in]  aContext         A pointer to arbitrary context information. May be NULL if not used."]
    #[doc = " @param[in]  aTransmitHook    A pointer to a hook function for outgoing block-wise transfer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully enqueued the CoAP response message."]
    #[doc = " @retval OT_ERROR_NO_BUFS  Insufficient buffers available to send the CoAP response."]
    #[doc = ""]
    pub fn otCoapSendResponseBlockWiseWithParameters(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aTxParameters: *const otCoapTxParameters,
        aContext: *mut ::std::os::raw::c_void,
        aTransmitHook: otCoapBlockwiseTransmitHook,
    ) -> otError;
}
#[doc = " This function pointer is called when the DTLS connection state changes."]
#[doc = ""]
#[doc = " @param[in]  aConnected  true, if a connection was established, false otherwise."]
#[doc = " @param[in]  aContext    A pointer to arbitrary context information."]
#[doc = ""]
pub type otHandleCoapSecureClientConnect = ::std::option::Option<
    unsafe extern "C" fn(aConnected: bool, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function starts the CoAP Secure service."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPort      The local UDP port to bind to."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE  Successfully started the CoAP Secure server."]
    #[doc = ""]
    pub fn otCoapSecureStart(aInstance: *mut otInstance, aPort: u16) -> otError;
}
extern "C" {
    #[doc = " This function stops the CoAP Secure server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otCoapSecureStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method sets the Pre-Shared Key (PSK) and cipher suite"]
    #[doc = " DTLS_PSK_WITH_AES_128_CCM_8."]
    #[doc = ""]
    #[doc = " @note This function requires the build-time feature `MBEDTLS_KEY_EXCHANGE_PSK_ENABLED` to be enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPsk          A pointer to the PSK."]
    #[doc = " @param[in]  aPskLength    The PSK length."]
    #[doc = " @param[in]  aPskIdentity  The Identity Name for the PSK."]
    #[doc = " @param[in]  aPskIdLength  The PSK Identity Length."]
    #[doc = ""]
    pub fn otCoapSecureSetPsk(
        aInstance: *mut otInstance,
        aPsk: *const u8,
        aPskLength: u16,
        aPskIdentity: *const u8,
        aPskIdLength: u16,
    );
}
extern "C" {
    #[doc = " This method returns the peer x509 certificate base64 encoded."]
    #[doc = ""]
    #[doc = " @note This function requires the build-time features `MBEDTLS_BASE64_C` and"]
    #[doc = "       `MBEDTLS_SSL_KEEP_PEER_CERTIFICATE` to be enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aPeerCert        A pointer to the base64 encoded certificate buffer."]
    #[doc = " @param[out]  aCertLength      The length of the base64 encoded peer certificate."]
    #[doc = " @param[in]   aCertBufferSize  The buffer size of aPeerCert."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_INVALID_STATE   Not connected yet."]
    #[doc = " @retval OT_ERROR_NONE            Successfully get the peer certificate."]
    #[doc = " @retval OT_ERROR_NO_BUFS         Can't allocate memory for certificate."]
    #[doc = ""]
    pub fn otCoapSecureGetPeerCertificateBase64(
        aInstance: *mut otInstance,
        aPeerCert: *mut ::std::os::raw::c_uchar,
        aCertLength: *mut usize,
        aCertBufferSize: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " This method sets the authentication mode for the coap secure connection."]
    #[doc = ""]
    #[doc = " Disable or enable the verification of peer certificate."]
    #[doc = " Must be called before start."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance               A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aVerifyPeerCertificate  true, to verify the peer certificate."]
    #[doc = ""]
    pub fn otCoapSecureSetSslAuthMode(aInstance: *mut otInstance, aVerifyPeerCertificate: bool);
}
extern "C" {
    #[doc = " This method sets the local device's X509 certificate with corresponding private key for"]
    #[doc = " DTLS session with DTLS_ECDHE_ECDSA_WITH_AES_128_CCM_8."]
    #[doc = ""]
    #[doc = " @note This function requires `MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED=1`."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aX509Cert          A pointer to the PEM formatted X509 certificate."]
    #[doc = " @param[in]  aX509Length        The length of certificate."]
    #[doc = " @param[in]  aPrivateKey        A pointer to the PEM formatted private key."]
    #[doc = " @param[in]  aPrivateKeyLength  The length of the private key."]
    #[doc = ""]
    pub fn otCoapSecureSetCertificate(
        aInstance: *mut otInstance,
        aX509Cert: *const u8,
        aX509Length: u32,
        aPrivateKey: *const u8,
        aPrivateKeyLength: u32,
    );
}
extern "C" {
    #[doc = " This method sets the trusted top level CAs. It is needed for validating the"]
    #[doc = " certificate of the peer."]
    #[doc = ""]
    #[doc = " DTLS mode \"ECDHE ECDSA with AES 128 CCM 8\" for Application CoAPS."]
    #[doc = ""]
    #[doc = " @note This function requires `MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED=1`."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance                A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aX509CaCertificateChain  A pointer to the PEM formatted X509 CA chain."]
    #[doc = " @param[in]  aX509CaCertChainLength   The length of chain."]
    #[doc = ""]
    pub fn otCoapSecureSetCaCertificateChain(
        aInstance: *mut otInstance,
        aX509CaCertificateChain: *const u8,
        aX509CaCertChainLength: u32,
    );
}
extern "C" {
    #[doc = " This method initializes DTLS session with a peer."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance               A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSockAddr               A pointer to the remote socket address."]
    #[doc = " @param[in]  aHandler                A pointer to a function that will be called when the DTLS connection"]
    #[doc = "                                     state changes."]
    #[doc = " @param[in]  aContext                A pointer to arbitrary context information."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE  Successfully started DTLS connection."]
    #[doc = ""]
    pub fn otCoapSecureConnect(
        aInstance: *mut otInstance,
        aSockAddr: *const otSockAddr,
        aHandler: otHandleCoapSecureClientConnect,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This method stops the DTLS connection."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otCoapSecureDisconnect(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method indicates whether or not the DTLS session is connected."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE   The DTLS session is connected."]
    #[doc = " @retval FALSE  The DTLS session is not connected."]
    #[doc = ""]
    pub fn otCoapSecureIsConnected(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This method indicates whether or not the DTLS session is active."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE  If DTLS session is active."]
    #[doc = " @retval FALSE If DTLS session is not active."]
    #[doc = ""]
    pub fn otCoapSecureIsConnectionActive(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This method sends a CoAP request block-wise over secure DTLS connection."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE configuration"]
    #[doc = " is enabled."]
    #[doc = ""]
    #[doc = " If a response for a request is expected, respective function and context information should be provided."]
    #[doc = " If no response is expected, these arguments should be NULL pointers."]
    #[doc = " If Message Id was not set in the header (equal to 0), this function will assign unique Message Id to the message."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage      A reference to the message to send."]
    #[doc = " @param[in]  aHandler      A function pointer that shall be called on response reception or time-out."]
    #[doc = " @param[in]  aContext      A pointer to arbitrary context information."]
    #[doc = " @param[in]  aTransmitHook A function pointer that is called on Block1 response reception."]
    #[doc = " @param[in]  aReceiveHook  A function pointer that is called on Block2 response reception."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully sent CoAP message."]
    #[doc = " @retval OT_ERROR_NO_BUFS        Failed to allocate retransmission data."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  DTLS connection was not initialized."]
    #[doc = ""]
    pub fn otCoapSecureSendRequestBlockWise(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aHandler: otCoapResponseHandler,
        aContext: *mut ::std::os::raw::c_void,
        aTransmitHook: otCoapBlockwiseTransmitHook,
        aReceiveHook: otCoapBlockwiseReceiveHook,
    ) -> otError;
}
extern "C" {
    #[doc = " This method sends a CoAP request over secure DTLS connection."]
    #[doc = ""]
    #[doc = " If a response for a request is expected, respective function and context information should be provided."]
    #[doc = " If no response is expected, these arguments should be NULL pointers."]
    #[doc = " If Message Id was not set in the header (equal to 0), this function will assign unique Message Id to the message."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage      A reference to the message to send."]
    #[doc = " @param[in]  aHandler      A function pointer that shall be called on response reception or time-out."]
    #[doc = " @param[in]  aContext      A pointer to arbitrary context information."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully sent CoAP message."]
    #[doc = " @retval OT_ERROR_NO_BUFS        Failed to allocate retransmission data."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  DTLS connection was not initialized."]
    #[doc = ""]
    pub fn otCoapSecureSendRequest(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aHandler: otCoapResponseHandler,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function adds a resource to the CoAP Secure server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aResource  A pointer to the resource."]
    #[doc = ""]
    pub fn otCoapSecureAddResource(aInstance: *mut otInstance, aResource: *mut otCoapResource);
}
extern "C" {
    #[doc = " This function removes a resource from the CoAP Secure server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aResource  A pointer to the resource."]
    #[doc = ""]
    pub fn otCoapSecureRemoveResource(aInstance: *mut otInstance, aResource: *mut otCoapResource);
}
extern "C" {
    #[doc = " This function adds a block-wise resource to the CoAP Secure server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aResource  A pointer to the resource."]
    #[doc = ""]
    pub fn otCoapSecureAddBlockWiseResource(
        aInstance: *mut otInstance,
        aResource: *mut otCoapBlockwiseResource,
    );
}
extern "C" {
    #[doc = " This function removes a block-wise resource from the CoAP Secure server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aResource  A pointer to the resource."]
    #[doc = ""]
    pub fn otCoapSecureRemoveBlockWiseResource(
        aInstance: *mut otInstance,
        aResource: *mut otCoapBlockwiseResource,
    );
}
extern "C" {
    #[doc = " This function sets the default handler for unhandled CoAP Secure requests."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aHandler   A function pointer that shall be called when an unhandled request arrives."]
    #[doc = " @param[in]  aContext   A pointer to arbitrary context information. May be NULL if not used."]
    #[doc = ""]
    pub fn otCoapSecureSetDefaultHandler(
        aInstance: *mut otInstance,
        aHandler: otCoapRequestHandler,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This method sets the connected callback to indicate, when"]
    #[doc = " a Client connect to the CoAP Secure server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aHandler      A pointer to a function that will be called once DTLS connection is established."]
    #[doc = " @param[in]  aContext      A pointer to arbitrary context information. May be NULL if not used."]
    #[doc = ""]
    pub fn otCoapSecureSetClientConnectedCallback(
        aInstance: *mut otInstance,
        aHandler: otHandleCoapSecureClientConnect,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function sends a CoAP response block-wise from the CoAP Secure server."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE configuration"]
    #[doc = " is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage      A pointer to the CoAP response to send."]
    #[doc = " @param[in]  aMessageInfo  A pointer to the message info associated with @p aMessage."]
    #[doc = " @param[in]  aContext      A pointer to arbitrary context information. May be NULL if not used."]
    #[doc = " @param[in]  aTransmitHook A function pointer that is called on Block1 request reception."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully enqueued the CoAP response message."]
    #[doc = " @retval OT_ERROR_NO_BUFS  Insufficient buffers available to send the CoAP response."]
    #[doc = ""]
    pub fn otCoapSecureSendResponseBlockWise(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aContext: *mut ::std::os::raw::c_void,
        aTransmitHook: otCoapBlockwiseTransmitHook,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends a CoAP response from the CoAP Secure server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage      A pointer to the CoAP response to send."]
    #[doc = " @param[in]  aMessageInfo  A pointer to the message info associated with @p aMessage."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully enqueued the CoAP response message."]
    #[doc = " @retval OT_ERROR_NO_BUFS  Insufficient buffers available to send the CoAP response."]
    #[doc = ""]
    pub fn otCoapSecureSendResponse(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> otError;
}
#[doc = " @struct otNetworkKey"]
#[doc = ""]
#[doc = " This structure represents a Thread Network Key."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNetworkKey {
    #[doc = "< Byte values"]
    pub m8: [u8; 16usize],
}
#[doc = " This datatype represents KeyRef to NetworkKey."]
#[doc = ""]
pub type otNetworkKeyRef = otCryptoKeyRef;
#[doc = " This structure represents a Network Name."]
#[doc = ""]
#[doc = " The `otNetworkName` is a null terminated C string (i.e., `m8` char array MUST end with null char `\\0`)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNetworkName {
    #[doc = "< Byte values. The `+ 1` is for null char."]
    pub m8: [::std::os::raw::c_char; 17usize],
}
#[doc = " This structure represents an Extended PAN ID."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otExtendedPanId {
    #[doc = "< Byte values"]
    pub m8: [u8; 8usize],
}
#[doc = " @struct otIp6NetworkPrefix"]
#[doc = ""]
#[doc = " This structure represents the Network Prefix of an IPv6 address (most significant 64 bits of the address)."]
#[doc = ""]
pub type otMeshLocalPrefix = otIp6NetworkPrefix;
#[doc = " This structure represents PSKc."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otPskc {
    #[doc = "< Byte values"]
    pub m8: [u8; 16usize],
}
#[doc = " This datatype represents KeyRef to PSKc."]
#[doc = ""]
pub type otPskcRef = otCryptoKeyRef;
#[doc = " This structure represent Security Policy."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otSecurityPolicy {
    #[doc = "< The value for thrKeyRotation in units of hours."]
    pub mRotationTime: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl otSecurityPolicy {
    #[inline]
    pub fn mObtainNetworkKeyEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mObtainNetworkKeyEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNativeCommissioningEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNativeCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mRoutersEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRoutersEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mExternalCommissioningEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mExternalCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mCommercialCommissioningEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCommercialCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAutonomousEnrollmentEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAutonomousEnrollmentEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNetworkKeyProvisioningEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNetworkKeyProvisioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mTobleLinkEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mTobleLinkEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNonCcmRoutersEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNonCcmRoutersEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mVersionThresholdForRouting(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_mVersionThresholdForRouting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mObtainNetworkKeyEnabled: bool,
        mNativeCommissioningEnabled: bool,
        mRoutersEnabled: bool,
        mExternalCommissioningEnabled: bool,
        mCommercialCommissioningEnabled: bool,
        mAutonomousEnrollmentEnabled: bool,
        mNetworkKeyProvisioningEnabled: bool,
        mTobleLinkEnabled: bool,
        mNonCcmRoutersEnabled: bool,
        mVersionThresholdForRouting: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mObtainNetworkKeyEnabled: u8 =
                unsafe { ::std::mem::transmute(mObtainNetworkKeyEnabled) };
            mObtainNetworkKeyEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mNativeCommissioningEnabled: u8 =
                unsafe { ::std::mem::transmute(mNativeCommissioningEnabled) };
            mNativeCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mRoutersEnabled: u8 = unsafe { ::std::mem::transmute(mRoutersEnabled) };
            mRoutersEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mExternalCommissioningEnabled: u8 =
                unsafe { ::std::mem::transmute(mExternalCommissioningEnabled) };
            mExternalCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mCommercialCommissioningEnabled: u8 =
                unsafe { ::std::mem::transmute(mCommercialCommissioningEnabled) };
            mCommercialCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mAutonomousEnrollmentEnabled: u8 =
                unsafe { ::std::mem::transmute(mAutonomousEnrollmentEnabled) };
            mAutonomousEnrollmentEnabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mNetworkKeyProvisioningEnabled: u8 =
                unsafe { ::std::mem::transmute(mNetworkKeyProvisioningEnabled) };
            mNetworkKeyProvisioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mTobleLinkEnabled: u8 = unsafe { ::std::mem::transmute(mTobleLinkEnabled) };
            mTobleLinkEnabled as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mNonCcmRoutersEnabled: u8 = unsafe { ::std::mem::transmute(mNonCcmRoutersEnabled) };
            mNonCcmRoutersEnabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let mVersionThresholdForRouting: u8 =
                unsafe { ::std::mem::transmute(mVersionThresholdForRouting) };
            mVersionThresholdForRouting as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This type represents Channel Mask."]
#[doc = ""]
pub type otChannelMask = u32;
#[doc = " This structure represents presence of different components in Active or Pending Operational Dataset."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otOperationalDatasetComponents {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl otOperationalDatasetComponents {
    #[inline]
    pub fn mIsActiveTimestampPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsActiveTimestampPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsPendingTimestampPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsPendingTimestampPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsNetworkKeyPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsNetworkKeyPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsNetworkNamePresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsNetworkNamePresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsExtendedPanIdPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsExtendedPanIdPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsMeshLocalPrefixPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsMeshLocalPrefixPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsDelayPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsDelayPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsPanIdPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsPanIdPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsChannelPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsChannelPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsPskcPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsPskcPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSecurityPolicyPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSecurityPolicyPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsChannelMaskPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsChannelMaskPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsActiveTimestampPresent: bool,
        mIsPendingTimestampPresent: bool,
        mIsNetworkKeyPresent: bool,
        mIsNetworkNamePresent: bool,
        mIsExtendedPanIdPresent: bool,
        mIsMeshLocalPrefixPresent: bool,
        mIsDelayPresent: bool,
        mIsPanIdPresent: bool,
        mIsChannelPresent: bool,
        mIsPskcPresent: bool,
        mIsSecurityPolicyPresent: bool,
        mIsChannelMaskPresent: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsActiveTimestampPresent: u8 =
                unsafe { ::std::mem::transmute(mIsActiveTimestampPresent) };
            mIsActiveTimestampPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsPendingTimestampPresent: u8 =
                unsafe { ::std::mem::transmute(mIsPendingTimestampPresent) };
            mIsPendingTimestampPresent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsNetworkKeyPresent: u8 = unsafe { ::std::mem::transmute(mIsNetworkKeyPresent) };
            mIsNetworkKeyPresent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsNetworkNamePresent: u8 = unsafe { ::std::mem::transmute(mIsNetworkNamePresent) };
            mIsNetworkNamePresent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsExtendedPanIdPresent: u8 =
                unsafe { ::std::mem::transmute(mIsExtendedPanIdPresent) };
            mIsExtendedPanIdPresent as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mIsMeshLocalPrefixPresent: u8 =
                unsafe { ::std::mem::transmute(mIsMeshLocalPrefixPresent) };
            mIsMeshLocalPrefixPresent as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mIsDelayPresent: u8 = unsafe { ::std::mem::transmute(mIsDelayPresent) };
            mIsDelayPresent as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mIsPanIdPresent: u8 = unsafe { ::std::mem::transmute(mIsPanIdPresent) };
            mIsPanIdPresent as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mIsChannelPresent: u8 = unsafe { ::std::mem::transmute(mIsChannelPresent) };
            mIsChannelPresent as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let mIsPskcPresent: u8 = unsafe { ::std::mem::transmute(mIsPskcPresent) };
            mIsPskcPresent as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let mIsSecurityPolicyPresent: u8 =
                unsafe { ::std::mem::transmute(mIsSecurityPolicyPresent) };
            mIsSecurityPolicyPresent as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let mIsChannelMaskPresent: u8 = unsafe { ::std::mem::transmute(mIsChannelMaskPresent) };
            mIsChannelMaskPresent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents a Thread Dataset timestamp component."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otTimestamp {
    pub mSeconds: u64,
    pub mTicks: u16,
    pub mAuthoritative: bool,
}
#[doc = " This structure represents an Active or Pending Operational Dataset."]
#[doc = ""]
#[doc = " Components in Dataset are optional. `mComponets` structure specifies which components are present in the Dataset."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otOperationalDataset {
    #[doc = "< Active Timestamp"]
    pub mActiveTimestamp: otTimestamp,
    #[doc = "< Pending Timestamp"]
    pub mPendingTimestamp: otTimestamp,
    #[doc = "< Network Key"]
    pub mNetworkKey: otNetworkKey,
    #[doc = "< Network Name"]
    pub mNetworkName: otNetworkName,
    #[doc = "< Extended PAN ID"]
    pub mExtendedPanId: otExtendedPanId,
    #[doc = "< Mesh Local Prefix"]
    pub mMeshLocalPrefix: otMeshLocalPrefix,
    #[doc = "< Delay Timer"]
    pub mDelay: u32,
    #[doc = "< PAN ID"]
    pub mPanId: otPanId,
    #[doc = "< Channel"]
    pub mChannel: u16,
    #[doc = "< PSKc"]
    pub mPskc: otPskc,
    #[doc = "< Security Policy"]
    pub mSecurityPolicy: otSecurityPolicy,
    #[doc = "< Channel Mask"]
    pub mChannelMask: otChannelMask,
    #[doc = "< Specifies which components are set in the Dataset."]
    pub mComponents: otOperationalDatasetComponents,
}
#[doc = " This structure represents an Active or Pending Operational Dataset."]
#[doc = ""]
#[doc = " The Operational Dataset is TLV encoded as specified by Thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otOperationalDatasetTlvs {
    #[doc = "< Operational Dataset TLVs."]
    pub mTlvs: [u8; 254usize],
    #[doc = "< Size of Operational Dataset in bytes."]
    pub mLength: u8,
}
impl Default for otOperationalDatasetTlvs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< meshcop Channel TLV"]
pub const OT_MESHCOP_TLV_CHANNEL: otMeshcopTlvType = 0;
#[doc = "< meshcop Pan Id TLV"]
pub const OT_MESHCOP_TLV_PANID: otMeshcopTlvType = 1;
#[doc = "< meshcop Extended Pan Id TLV"]
pub const OT_MESHCOP_TLV_EXTPANID: otMeshcopTlvType = 2;
#[doc = "< meshcop Network Name TLV"]
pub const OT_MESHCOP_TLV_NETWORKNAME: otMeshcopTlvType = 3;
#[doc = "< meshcop PSKc TLV"]
pub const OT_MESHCOP_TLV_PSKC: otMeshcopTlvType = 4;
#[doc = "< meshcop Network Key TLV"]
pub const OT_MESHCOP_TLV_NETWORKKEY: otMeshcopTlvType = 5;
#[doc = "< meshcop Network Key Sequence TLV"]
pub const OT_MESHCOP_TLV_NETWORK_KEY_SEQUENCE: otMeshcopTlvType = 6;
#[doc = "< meshcop Mesh Local Prefix TLV"]
pub const OT_MESHCOP_TLV_MESHLOCALPREFIX: otMeshcopTlvType = 7;
#[doc = "< meshcop Steering Data TLV"]
pub const OT_MESHCOP_TLV_STEERING_DATA: otMeshcopTlvType = 8;
#[doc = "< meshcop Border Agent Locator TLV"]
pub const OT_MESHCOP_TLV_BORDER_AGENT_RLOC: otMeshcopTlvType = 9;
#[doc = "< meshcop Commissioner ID TLV"]
pub const OT_MESHCOP_TLV_COMMISSIONER_ID: otMeshcopTlvType = 10;
#[doc = "< meshcop Commissioner Session ID TLV"]
pub const OT_MESHCOP_TLV_COMM_SESSION_ID: otMeshcopTlvType = 11;
#[doc = "< meshcop Security Policy TLV"]
pub const OT_MESHCOP_TLV_SECURITYPOLICY: otMeshcopTlvType = 12;
#[doc = "< meshcop Get TLV"]
pub const OT_MESHCOP_TLV_GET: otMeshcopTlvType = 13;
#[doc = "< meshcop Active Timestamp TLV"]
pub const OT_MESHCOP_TLV_ACTIVETIMESTAMP: otMeshcopTlvType = 14;
#[doc = "< meshcop Commissioner UDP Port TLV"]
pub const OT_MESHCOP_TLV_COMMISSIONER_UDP_PORT: otMeshcopTlvType = 15;
#[doc = "< meshcop State TLV"]
pub const OT_MESHCOP_TLV_STATE: otMeshcopTlvType = 16;
#[doc = "< meshcop Joiner DTLS Encapsulation TLV"]
pub const OT_MESHCOP_TLV_JOINER_DTLS: otMeshcopTlvType = 17;
#[doc = "< meshcop Joiner UDP Port TLV"]
pub const OT_MESHCOP_TLV_JOINER_UDP_PORT: otMeshcopTlvType = 18;
#[doc = "< meshcop Joiner IID TLV"]
pub const OT_MESHCOP_TLV_JOINER_IID: otMeshcopTlvType = 19;
#[doc = "< meshcop Joiner Router Locator TLV"]
pub const OT_MESHCOP_TLV_JOINER_RLOC: otMeshcopTlvType = 20;
#[doc = "< meshcop Joiner Router KEK TLV"]
pub const OT_MESHCOP_TLV_JOINER_ROUTER_KEK: otMeshcopTlvType = 21;
#[doc = "< meshcop Provisioning URL TLV"]
pub const OT_MESHCOP_TLV_PROVISIONING_URL: otMeshcopTlvType = 32;
#[doc = "< meshcop Vendor Name TLV"]
pub const OT_MESHCOP_TLV_VENDOR_NAME_TLV: otMeshcopTlvType = 33;
#[doc = "< meshcop Vendor Model TLV"]
pub const OT_MESHCOP_TLV_VENDOR_MODEL_TLV: otMeshcopTlvType = 34;
#[doc = "< meshcop Vendor SW Version TLV"]
pub const OT_MESHCOP_TLV_VENDOR_SW_VERSION_TLV: otMeshcopTlvType = 35;
#[doc = "< meshcop Vendor Data TLV"]
pub const OT_MESHCOP_TLV_VENDOR_DATA_TLV: otMeshcopTlvType = 36;
#[doc = "< meshcop Vendor Stack Version TLV"]
pub const OT_MESHCOP_TLV_VENDOR_STACK_VERSION_TLV: otMeshcopTlvType = 37;
#[doc = "< meshcop UDP encapsulation TLV"]
pub const OT_MESHCOP_TLV_UDP_ENCAPSULATION_TLV: otMeshcopTlvType = 48;
#[doc = "< meshcop IPv6 address TLV"]
pub const OT_MESHCOP_TLV_IPV6_ADDRESS_TLV: otMeshcopTlvType = 49;
#[doc = "< meshcop Pending Timestamp TLV"]
pub const OT_MESHCOP_TLV_PENDINGTIMESTAMP: otMeshcopTlvType = 51;
#[doc = "< meshcop Delay Timer TLV"]
pub const OT_MESHCOP_TLV_DELAYTIMER: otMeshcopTlvType = 52;
#[doc = "< meshcop Channel Mask TLV"]
pub const OT_MESHCOP_TLV_CHANNELMASK: otMeshcopTlvType = 53;
#[doc = "< meshcop Count TLV"]
pub const OT_MESHCOP_TLV_COUNT: otMeshcopTlvType = 54;
#[doc = "< meshcop Period TLV"]
pub const OT_MESHCOP_TLV_PERIOD: otMeshcopTlvType = 55;
#[doc = "< meshcop Scan Duration TLV"]
pub const OT_MESHCOP_TLV_SCAN_DURATION: otMeshcopTlvType = 56;
#[doc = "< meshcop Energy List TLV"]
pub const OT_MESHCOP_TLV_ENERGY_LIST: otMeshcopTlvType = 57;
#[doc = "< meshcop Discovery Request TLV"]
pub const OT_MESHCOP_TLV_DISCOVERYREQUEST: otMeshcopTlvType = 128;
#[doc = "< meshcop Discovery Response TLV"]
pub const OT_MESHCOP_TLV_DISCOVERYRESPONSE: otMeshcopTlvType = 129;
#[doc = "< meshcop Joiner Advertisement TLV"]
pub const OT_MESHCOP_TLV_JOINERADVERTISEMENT: otMeshcopTlvType = 241;
#[doc = " This enumeration represents meshcop TLV types."]
#[doc = ""]
pub type otMeshcopTlvType = ::std::os::raw::c_uint;
#[doc = " This function pointer is called when a response to a MGMT_SET request is received or times out."]
#[doc = ""]
#[doc = " @param[in]  aResult   A result of the operation."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
#[doc = " @retval  OT_ERROR_NONE              The request was accepted by the leader."]
#[doc = " @retval  OT_ERROR_REJECTED          The request was rejected by the leader."]
#[doc = " @retval  OT_ERROR_PARSE             An error occurred during parsing the response."]
#[doc = " @retval  OT_ERROR_ABORT             The request was reset by peer."]
#[doc = " @retval  OT_ERROR_RESPONSE_TIMEOUT  No response or acknowledgment received during timeout period."]
#[doc = ""]
pub type otDatasetMgmtSetCallback = ::std::option::Option<
    unsafe extern "C" fn(aResult: otError, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function indicates whether a valid network is present in the Active Operational Dataset or not."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns TRUE if a valid network is present in the Active Operational Dataset, FALSE otherwise."]
    #[doc = ""]
    pub fn otDatasetIsCommissioned(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Gets the Active Operational Dataset."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aDataset  A pointer to where the Active Operational Dataset will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the Active Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store."]
    #[doc = ""]
    pub fn otDatasetGetActive(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the Active Operational Dataset."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aDataset  A pointer to where the Active Operational Dataset will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the Active Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store."]
    #[doc = ""]
    pub fn otDatasetGetActiveTlvs(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the Active Operational Dataset."]
    #[doc = ""]
    #[doc = " If the dataset does not include an Active Timestamp, the dataset is only partially complete."]
    #[doc = ""]
    #[doc = " If Thread is enabled on a device that has a partially complete Active Dataset, the device will attempt to attach to"]
    #[doc = " an existing Thread network using any existing information in the dataset. Only the Thread Network Key is needed to"]
    #[doc = " attach to a network."]
    #[doc = ""]
    #[doc = " If channel is not included in the dataset, the device will send MLE Announce messages across different channels to"]
    #[doc = " find neighbors on other channels."]
    #[doc = ""]
    #[doc = " If the device successfully attaches to a Thread network, the device will then retrieve the full Active Dataset from"]
    #[doc = " its Parent. Note that a router-capable device will not transition to the Router or Leader roles until it has a"]
    #[doc = " complete Active Dataset."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset  A pointer to the Active Operational Dataset."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the Active Operational Dataset."]
    #[doc = " @retval OT_ERROR_NO_BUFS          Insufficient buffer space to set the Active Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  The platform does not implement settings functionality."]
    #[doc = ""]
    pub fn otDatasetSetActive(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the Active Operational Dataset."]
    #[doc = ""]
    #[doc = " If the dataset does not include an Active Timestamp, the dataset is only partially complete."]
    #[doc = ""]
    #[doc = " If Thread is enabled on a device that has a partially complete Active Dataset, the device will attempt to attach to"]
    #[doc = " an existing Thread network using any existing information in the dataset. Only the Thread Network Key is needed to"]
    #[doc = " attach to a network."]
    #[doc = ""]
    #[doc = " If channel is not included in the dataset, the device will send MLE Announce messages across different channels to"]
    #[doc = " find neighbors on other channels."]
    #[doc = ""]
    #[doc = " If the device successfully attaches to a Thread network, the device will then retrieve the full Active Dataset from"]
    #[doc = " its Parent. Note that a router-capable device will not transition to the Router or Leader roles until it has a"]
    #[doc = " complete Active Dataset."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset  A pointer to the Active Operational Dataset."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the Active Operational Dataset."]
    #[doc = " @retval OT_ERROR_NO_BUFS          Insufficient buffer space to set the Active Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  The platform does not implement settings functionality."]
    #[doc = ""]
    pub fn otDatasetSetActiveTlvs(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the Pending Operational Dataset."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aDataset  A pointer to where the Pending Operational Dataset will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the Pending Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store."]
    #[doc = ""]
    pub fn otDatasetGetPending(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the Pending Operational Dataset."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aDataset  A pointer to where the Pending Operational Dataset will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the Pending Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store."]
    #[doc = ""]
    pub fn otDatasetGetPendingTlvs(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the Pending Operational Dataset."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset  A pointer to the Pending Operational Dataset."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the Pending Operational Dataset."]
    #[doc = " @retval OT_ERROR_NO_BUFS          Insufficient buffer space to set the Pending Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  The platform does not implement settings functionality."]
    #[doc = ""]
    pub fn otDatasetSetPending(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the Pending Operational Dataset."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset  A pointer to the Pending Operational Dataset."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the Pending Operational Dataset."]
    #[doc = " @retval OT_ERROR_NO_BUFS          Insufficient buffer space to set the Pending Operational Dataset."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  The platform does not implement settings functionality."]
    #[doc = ""]
    pub fn otDatasetSetPendingTlvs(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_ACTIVE_GET."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance           A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDatasetComponents  A pointer to a Dataset Components structure specifying which components to request."]
    #[doc = " @param[in]  aTlvTypes           A pointer to array containing additional raw TLV types to be requested."]
    #[doc = " @param[in]  aLength             The length of @p aTlvTypes."]
    #[doc = " @param[in]  aAddress            A pointer to the IPv6 destination, if it is NULL, will use Leader ALOC as default."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully send the meshcop dataset command."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send."]
    #[doc = ""]
    pub fn otDatasetSendMgmtActiveGet(
        aInstance: *mut otInstance,
        aDatasetComponents: *const otOperationalDatasetComponents,
        aTlvTypes: *const u8,
        aLength: u8,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_ACTIVE_SET."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset   A pointer to operational dataset."]
    #[doc = " @param[in]  aTlvs      A pointer to TLVs."]
    #[doc = " @param[in]  aLength    The length of TLVs."]
    #[doc = " @param[in]  aCallback  A pointer to a function that is called on response reception or timeout."]
    #[doc = " @param[in]  aContext   A pointer to application-specific context for @p aCallback."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully send the meshcop dataset command."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send."]
    #[doc = " @retval OT_ERROR_BUSY          A previous request is ongoing."]
    #[doc = ""]
    pub fn otDatasetSendMgmtActiveSet(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
        aTlvs: *const u8,
        aLength: u8,
        aCallback: otDatasetMgmtSetCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_PENDING_GET."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance           A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDatasetComponents  A pointer to a Dataset Components structure specifying which components to request."]
    #[doc = " @param[in]  aTlvTypes           A pointer to array containing additional raw TLV types to be requested."]
    #[doc = " @param[in]  aLength             The length of @p aTlvTypes."]
    #[doc = " @param[in]  aAddress            A pointer to the IPv6 destination, if it is NULL, will use Leader ALOC as default."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully send the meshcop dataset command."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send."]
    #[doc = ""]
    pub fn otDatasetSendMgmtPendingGet(
        aInstance: *mut otInstance,
        aDatasetComponents: *const otOperationalDatasetComponents,
        aTlvTypes: *const u8,
        aLength: u8,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_PENDING_SET."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset   A pointer to operational dataset."]
    #[doc = " @param[in]  aTlvs      A pointer to TLVs."]
    #[doc = " @param[in]  aLength    The length of TLVs."]
    #[doc = " @param[in]  aCallback  A pointer to a function that is called on response reception or timeout."]
    #[doc = " @param[in]  aContext   A pointer to application-specific context for @p aCallback."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully send the meshcop dataset command."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send."]
    #[doc = " @retval OT_ERROR_BUSY          A previous request is ongoing."]
    #[doc = ""]
    pub fn otDatasetSendMgmtPendingSet(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
        aTlvs: *const u8,
        aLength: u8,
        aCallback: otDatasetMgmtSetCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function generates PSKc from a given pass-phrase, network name, and extended PAN ID."]
    #[doc = ""]
    #[doc = " PSKc is used to establish the Commissioner Session."]
    #[doc = ""]
    #[doc = " @param[in]  aPassPhrase   The commissioning pass-phrase."]
    #[doc = " @param[in]  aNetworkName  The network name for PSKc computation."]
    #[doc = " @param[in]  aExtPanId     The extended PAN ID for PSKc computation."]
    #[doc = " @param[out] aPskc         A pointer to variable to output the generated PSKc."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully generate PSKc."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  If any of the input arguments is invalid."]
    #[doc = ""]
    pub fn otDatasetGeneratePskc(
        aPassPhrase: *const ::std::os::raw::c_char,
        aNetworkName: *const otNetworkName,
        aExtPanId: *const otExtendedPanId,
        aPskc: *mut otPskc,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets an `otNetworkName` instance from a given null terminated C string."]
    #[doc = ""]
    #[doc = " @p aNameString must follow UTF-8 encoding and the Network Name length must not be longer than"]
    #[doc = " `OT_NETWORK_NAME_MAX_SIZE`."]
    #[doc = ""]
    #[doc = " @param[out] aNetworkName        A pointer to the `otNetworkName` to set."]
    #[doc = " @param[in]  aNameString         A name C string."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set @p aNetworkName from @p aNameString."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   @p aNameStrng is invalid (too long or does not follow UTF-8 encoding)."]
    #[doc = ""]
    pub fn otNetworkNameFromString(
        aNetworkName: *mut otNetworkName,
        aNameString: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Parses an Operational Dataset from a given `otOperationalDatasetTlvs`."]
    #[doc = ""]
    #[doc = " @param[in]  aDatasetTlvs  A pointer to dataset TLVs."]
    #[doc = " @param[out] aDataset      A pointer to where the dataset will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully set @p aDataset from @p aDatasetTlvs."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aDatasetTlvs is invalid."]
    #[doc = ""]
    pub fn otDatasetParseTlvs(
        aDatasetTlvs: *const otOperationalDatasetTlvs,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " Converts a given Operational Dataset to `otOperationalDatasetTlvs`."]
    #[doc = ""]
    #[doc = " @param[in]  aDataset      An Operational dataset to convert to TLVs."]
    #[doc = " @param[out] aDatasetTlvs  A pointer to dataset TLVs to return the result."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully converted @p aDataset and updated @p aDatasetTlvs."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aDataset is invalid, does not contain active or pending timestamps."]
    #[doc = ""]
    pub fn otDatasetConvertToTlvs(
        aDataset: *const otOperationalDataset,
        aDatasetTlvs: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Updates a given Operational Dataset."]
    #[doc = ""]
    #[doc = " @p aDataset contains the fields to be updated and their new value."]
    #[doc = ""]
    #[doc = " @param[in]     aDataset      Specifies the set of types and values to update."]
    #[doc = " @param[in,out] aDatasetTlvs  A pointer to dataset TLVs to update."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully updated @p aDatasetTlvs."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aDataset contains invalid values."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Not enough space space in @p aDatasetTlvs to apply the update."]
    #[doc = ""]
    pub fn otDatasetUpdateTlvs(
        aDataset: *const otOperationalDataset,
        aDatasetTlvs: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
pub const OT_JOINER_STATE_IDLE: otJoinerState = 0;
pub const OT_JOINER_STATE_DISCOVER: otJoinerState = 1;
pub const OT_JOINER_STATE_CONNECT: otJoinerState = 2;
pub const OT_JOINER_STATE_CONNECTED: otJoinerState = 3;
pub const OT_JOINER_STATE_ENTRUST: otJoinerState = 4;
pub const OT_JOINER_STATE_JOINED: otJoinerState = 5;
#[doc = " This enumeration defines the Joiner State."]
#[doc = ""]
pub type otJoinerState = ::std::os::raw::c_uint;
#[doc = " This structure represents a Joiner Discerner."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otJoinerDiscerner {
    #[doc = "< Discerner value (the lowest `mLength` bits specify the discerner)."]
    pub mValue: u64,
    #[doc = "< Length (number of bits) - must be non-zero and at most `OT_JOINER_MAX_DISCERNER_LENGTH`."]
    pub mLength: u8,
}
#[doc = " This function pointer is called to notify the completion of a join operation."]
#[doc = ""]
#[doc = " @param[in]  aError    OT_ERROR_NONE if the join process succeeded."]
#[doc = "                       OT_ERROR_SECURITY if the join process failed due to security credentials."]
#[doc = "                       OT_ERROR_NOT_FOUND if no joinable network was discovered."]
#[doc = "                       OT_ERROR_RESPONSE_TIMEOUT if a response timed out."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otJoinerCallback = ::std::option::Option<
    unsafe extern "C" fn(aError: otError, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Enables the Thread Joiner role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPskd             A pointer to the PSKd."]
    #[doc = " @param[in]  aProvisioningUrl  A pointer to the Provisioning URL (may be NULL)."]
    #[doc = " @param[in]  aVendorName       A pointer to the Vendor Name (may be NULL)."]
    #[doc = " @param[in]  aVendorModel      A pointer to the Vendor Model (may be NULL)."]
    #[doc = " @param[in]  aVendorSwVersion  A pointer to the Vendor SW Version (may be NULL)."]
    #[doc = " @param[in]  aVendorData       A pointer to the Vendor Data (may be NULL)."]
    #[doc = " @param[in]  aCallback         A pointer to a function that is called when the join operation completes."]
    #[doc = " @param[in]  aContext          A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE              Successfully started the Joiner role."]
    #[doc = " @retval OT_ERROR_BUSY              The previous attempt is still on-going."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS      @p aPskd or @p aProvisioningUrl is invalid."]
    #[doc = " @retval OT_ERROR_INVALID_STATE     The IPv6 stack is not enabled or Thread stack is fully enabled."]
    #[doc = ""]
    pub fn otJoinerStart(
        aInstance: *mut otInstance,
        aPskd: *const ::std::os::raw::c_char,
        aProvisioningUrl: *const ::std::os::raw::c_char,
        aVendorName: *const ::std::os::raw::c_char,
        aVendorModel: *const ::std::os::raw::c_char,
        aVendorSwVersion: *const ::std::os::raw::c_char,
        aVendorData: *const ::std::os::raw::c_char,
        aCallback: otJoinerCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Disables the Thread Joiner role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otJoinerStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets the Joiner State."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_JOINER_STATE_IDLE"]
    #[doc = " @retval OT_JOINER_STATE_DISCOVER"]
    #[doc = " @retval OT_JOINER_STATE_CONNECT"]
    #[doc = " @retval OT_JOINER_STATE_CONNECTED"]
    #[doc = " @retval OT_JOINER_STATE_ENTRUST"]
    #[doc = " @retval OT_JOINER_STATE_JOINED"]
    #[doc = ""]
    pub fn otJoinerGetState(aInstance: *mut otInstance) -> otJoinerState;
}
extern "C" {
    #[doc = " Gets the Joiner ID."]
    #[doc = ""]
    #[doc = " If a Joiner Discerner is not set, Joiner ID is the first 64 bits of the result of computing SHA-256 over"]
    #[doc = " factory-assigned IEEE EUI-64. Otherwise the Joiner ID is calculated from the Joiner Discerner value."]
    #[doc = ""]
    #[doc = " The Joiner ID is also used as the device's IEEE 802.15.4 Extended Address during the commissioning process."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance  A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Joiner ID."]
    #[doc = ""]
    pub fn otJoinerGetId(aInstance: *mut otInstance) -> *const otExtAddress;
}
extern "C" {
    #[doc = " Sets the Joiner Discerner."]
    #[doc = ""]
    #[doc = " The Joiner Discerner is used to calculate the Joiner ID during the Thread Commissioning process. For more"]
    #[doc = " information, refer to #otJoinerGetId."]
    #[doc = " @note The Joiner Discerner takes the place of the Joiner EUI-64 during the joiner session of Thread Commissioning."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to the OpenThread instance."]
    #[doc = " @param[in]   aDiscerner   A pointer to a Joiner Discerner. If NULL clears any previously set discerner."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           The Joiner Discerner updated successfully."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   @p aDiscerner is not valid (specified length is not within valid range)."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  There is an ongoing Joining process so Joiner Discerner could not be changed."]
    #[doc = ""]
    pub fn otJoinerSetDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *mut otJoinerDiscerner,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Joiner Discerner. For more information, refer to #otJoinerSetDiscerner."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance       A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to Joiner Discerner or NULL if none is set."]
    #[doc = ""]
    pub fn otJoinerGetDiscerner(aInstance: *mut otInstance) -> *const otJoinerDiscerner;
}
extern "C" {
    #[doc = " This function converts a given joiner state enumeration value to a human-readable string."]
    #[doc = ""]
    #[doc = " @param[in] aState   The joiner state."]
    #[doc = ""]
    #[doc = " @returns A human-readable string representation of @p aState."]
    #[doc = ""]
    pub fn otJoinerStateToString(aState: otJoinerState) -> *const ::std::os::raw::c_char;
}
#[doc = "< Commissioner role is disabled."]
pub const OT_COMMISSIONER_STATE_DISABLED: otCommissionerState = 0;
#[doc = "< Currently petitioning to become a Commissioner."]
pub const OT_COMMISSIONER_STATE_PETITION: otCommissionerState = 1;
#[doc = "< Commissioner role is active."]
pub const OT_COMMISSIONER_STATE_ACTIVE: otCommissionerState = 2;
#[doc = " This enumeration defines the Commissioner State."]
#[doc = ""]
pub type otCommissionerState = ::std::os::raw::c_uint;
pub const OT_COMMISSIONER_JOINER_START: otCommissionerJoinerEvent = 0;
pub const OT_COMMISSIONER_JOINER_CONNECTED: otCommissionerJoinerEvent = 1;
pub const OT_COMMISSIONER_JOINER_FINALIZE: otCommissionerJoinerEvent = 2;
pub const OT_COMMISSIONER_JOINER_END: otCommissionerJoinerEvent = 3;
pub const OT_COMMISSIONER_JOINER_REMOVED: otCommissionerJoinerEvent = 4;
#[doc = " This enumeration defines a Joiner Event on the Commissioner."]
#[doc = ""]
pub type otCommissionerJoinerEvent = ::std::os::raw::c_uint;
#[doc = " This structure represents the steering data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otSteeringData {
    #[doc = "< Length of steering data (bytes)"]
    pub mLength: u8,
    #[doc = "< Byte values"]
    pub m8: [u8; 16usize],
}
#[doc = " This structure represents a Commissioning Dataset."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otCommissioningDataset {
    #[doc = "< Border Router RLOC16"]
    pub mLocator: u16,
    #[doc = "< Commissioner Session Id"]
    pub mSessionId: u16,
    #[doc = "< Steering Data"]
    pub mSteeringData: otSteeringData,
    #[doc = "< Joiner UDP Port"]
    pub mJoinerUdpPort: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl otCommissioningDataset {
    #[inline]
    pub fn mIsLocatorSet(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsLocatorSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSessionIdSet(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSessionIdSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSteeringDataSet(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSteeringDataSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsJoinerUdpPortSet(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoinerUdpPortSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsLocatorSet: bool,
        mIsSessionIdSet: bool,
        mIsSteeringDataSet: bool,
        mIsJoinerUdpPortSet: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsLocatorSet: u8 = unsafe { ::std::mem::transmute(mIsLocatorSet) };
            mIsLocatorSet as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsSessionIdSet: u8 = unsafe { ::std::mem::transmute(mIsSessionIdSet) };
            mIsSessionIdSet as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsSteeringDataSet: u8 = unsafe { ::std::mem::transmute(mIsSteeringDataSet) };
            mIsSteeringDataSet as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsJoinerUdpPortSet: u8 = unsafe { ::std::mem::transmute(mIsJoinerUdpPortSet) };
            mIsJoinerUdpPortSet as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents a Joiner PSKd."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otJoinerPskd {
    #[doc = "< Char string array (must be null terminated - +1 is for null char)."]
    pub m8: [::std::os::raw::c_char; 33usize],
}
impl Default for otJoinerPskd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Accept any Joiner (no EUI64 or Discerner is specified)."]
pub const OT_JOINER_INFO_TYPE_ANY: otJoinerInfoType = 0;
#[doc = "< Joiner EUI-64 is specified (`mSharedId.mEui64` in `otJoinerInfo`)."]
pub const OT_JOINER_INFO_TYPE_EUI64: otJoinerInfoType = 1;
#[doc = "< Joiner Discerner is specified (`mSharedId.mDiscerner` in `otJoinerInfo`)."]
pub const OT_JOINER_INFO_TYPE_DISCERNER: otJoinerInfoType = 2;
#[doc = " This enumeration defines a Joiner Info Type."]
#[doc = ""]
pub type otJoinerInfoType = ::std::os::raw::c_uint;
#[doc = " This structure represents a Joiner Info."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otJoinerInfo {
    #[doc = "< Joiner type."]
    pub mType: otJoinerInfoType,
    #[doc = "< Shared fields"]
    pub mSharedId: otJoinerInfo__bindgen_ty_1,
    #[doc = "< Joiner PSKd"]
    pub mPskd: otJoinerPskd,
    #[doc = "< Joiner expiration time in msec"]
    pub mExpirationTime: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otJoinerInfo__bindgen_ty_1 {
    #[doc = "< Joiner EUI64 (when `mType` is `OT_JOINER_INFO_TYPE_EUI64`)"]
    pub mEui64: otExtAddress,
    #[doc = "< Joiner Discerner (when `mType` is `OT_JOINER_INFO_TYPE_DISCERNER`)"]
    pub mDiscerner: otJoinerDiscerner,
}
impl Default for otJoinerInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otJoinerInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This function pointer is called whenever the commissioner state changes."]
#[doc = ""]
#[doc = " @param[in]  aState    The Commissioner state."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otCommissionerStateCallback = ::std::option::Option<
    unsafe extern "C" fn(aState: otCommissionerState, aContext: *mut ::std::os::raw::c_void),
>;
#[doc = " This function pointer is called whenever the joiner state changes."]
#[doc = ""]
#[doc = " @param[in]  aEvent       The joiner event type."]
#[doc = " @param[in]  aJoinerInfo  A pointer to the Joiner Info."]
#[doc = " @param[in]  aJoinerId    A pointer to the Joiner ID (if not known, it will be NULL)."]
#[doc = " @param[in]  aContext     A pointer to application-specific context."]
#[doc = ""]
pub type otCommissionerJoinerCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aEvent: otCommissionerJoinerEvent,
        aJoinerInfo: *const otJoinerInfo,
        aJoinerId: *const otExtAddress,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function enables the Thread Commissioner role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aStateCallback    A pointer to a function that is called when the commissioner state changes."]
    #[doc = " @param[in]  aJoinerCallback   A pointer to a function that is called with a joiner event occurs."]
    #[doc = " @param[in]  aCallbackContext  A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully started the Commissioner service."]
    #[doc = " @retval OT_ERROR_ALREADY        Commissioner is already started."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Device is not currently attached to a network."]
    #[doc = ""]
    pub fn otCommissionerStart(
        aInstance: *mut otInstance,
        aStateCallback: otCommissionerStateCallback,
        aJoinerCallback: otCommissionerJoinerCallback,
        aCallbackContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function disables the Thread Commissioner role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully stopped the Commissioner service."]
    #[doc = " @retval OT_ERROR_ALREADY  Commissioner is already stopped."]
    #[doc = ""]
    pub fn otCommissionerStop(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function returns the Commissioner Id."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Commissioner Id."]
    #[doc = ""]
    pub fn otCommissionerGetId(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function sets the Commissioner Id."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aId           A pointer to a string character array. Must be null terminated."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            Successfully set the Commissioner Id."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS    Given name is too long."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   The commissioner is active and id cannot be changed."]
    #[doc = ""]
    pub fn otCommissionerSetId(
        aInstance: *mut otInstance,
        aId: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function adds a Joiner entry."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEui64             A pointer to the Joiner's IEEE EUI-64 or NULL for any Joiner."]
    #[doc = " @param[in]  aPskd              A pointer to the PSKd."]
    #[doc = " @param[in]  aTimeout           A time after which a Joiner is automatically removed, in seconds."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully added the Joiner."]
    #[doc = " @retval OT_ERROR_NO_BUFS       No buffers available to add the Joiner."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aEui64 or @p aPskd is invalid."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerAddJoiner(
        aInstance: *mut otInstance,
        aEui64: *const otExtAddress,
        aPskd: *const ::std::os::raw::c_char,
        aTimeout: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " This function adds a Joiner entry with a given Joiner Discerner value."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDiscerner         A pointer to the Joiner Discerner."]
    #[doc = " @param[in]  aPskd              A pointer to the PSKd."]
    #[doc = " @param[in]  aTimeout           A time after which a Joiner is automatically removed, in seconds."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully added the Joiner."]
    #[doc = " @retval OT_ERROR_NO_BUFS       No buffers available to add the Joiner."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aDiscerner or @p aPskd is invalid."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerAddJoinerWithDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *const otJoinerDiscerner,
        aPskd: *const ::std::os::raw::c_char,
        aTimeout: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " This method get joiner info at aIterator position."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance   A pointer to instance."]
    #[doc = " @param[in,out]  aIterator   A pointer to the Joiner Info iterator context."]
    #[doc = " @param[out]     aJoiner     A reference to Joiner info."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully get the Joiner info."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  Not found next Joiner."]
    #[doc = ""]
    pub fn otCommissionerGetNextJoinerInfo(
        aInstance: *mut otInstance,
        aIterator: *mut u16,
        aJoiner: *mut otJoinerInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function removes a Joiner entry."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEui64             A pointer to the Joiner's IEEE EUI-64 or NULL for any Joiner."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully removed the Joiner."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     The Joiner specified by @p aEui64 was not found."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aEui64 is invalid."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerRemoveJoiner(
        aInstance: *mut otInstance,
        aEui64: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " This function removes a Joiner entry."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDiscerner         A pointer to the Joiner Discerner."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully removed the Joiner."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     The Joiner specified by @p aEui64 was not found."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aDiscerner is invalid."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerRemoveJoinerWithDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *const otJoinerDiscerner,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the Provisioning URL."]
    #[doc = ""]
    #[doc = " @param[in]    aInstance       A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the URL string."]
    #[doc = ""]
    pub fn otCommissionerGetProvisioningUrl(
        aInstance: *mut otInstance,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function sets the Provisioning URL."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance             A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aProvisioningUrl      A pointer to the Provisioning URL (may be NULL to set as empty string)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully set the Provisioning URL."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aProvisioningUrl is invalid (too long)."]
    #[doc = ""]
    pub fn otCommissionerSetProvisioningUrl(
        aInstance: *mut otInstance,
        aProvisioningUrl: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends an Announce Begin message."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance             A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannelMask          The channel mask value."]
    #[doc = " @param[in]  aCount                The number of Announcement messages per channel."]
    #[doc = " @param[in]  aPeriod               The time between two successive MLE Announce transmissions (in milliseconds)."]
    #[doc = " @param[in]  aAddress              A pointer to the IPv6 destination."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully enqueued the Announce Begin message."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate an Announce Begin message."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerAnnounceBegin(
        aInstance: *mut otInstance,
        aChannelMask: u32,
        aCount: u8,
        aPeriod: u16,
        aAddress: *const otIp6Address,
    ) -> otError;
}
#[doc = " This function pointer is called when the Commissioner receives an Energy Report."]
#[doc = ""]
#[doc = " @param[in]  aChannelMask       The channel mask value."]
#[doc = " @param[in]  aEnergyList        A pointer to the energy measurement list."]
#[doc = " @param[in]  aEnergyListLength  Number of entries in @p aEnergyListLength."]
#[doc = " @param[in]  aContext           A pointer to application-specific context."]
#[doc = ""]
pub type otCommissionerEnergyReportCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aChannelMask: u32,
        aEnergyList: *const u8,
        aEnergyListLength: u8,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function sends an Energy Scan Query message."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance             A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannelMask          The channel mask value."]
    #[doc = " @param[in]  aCount                The number of energy measurements per channel."]
    #[doc = " @param[in]  aPeriod               The time between energy measurements (milliseconds)."]
    #[doc = " @param[in]  aScanDuration         The scan duration for each energy measurement (milliseconds)."]
    #[doc = " @param[in]  aAddress              A pointer to the IPv6 destination."]
    #[doc = " @param[in]  aCallback             A pointer to a function called on receiving an Energy Report message."]
    #[doc = " @param[in]  aContext              A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully enqueued the Energy Scan Query message."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate an Energy Scan Query message."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerEnergyScan(
        aInstance: *mut otInstance,
        aChannelMask: u32,
        aCount: u8,
        aPeriod: u16,
        aScanDuration: u16,
        aAddress: *const otIp6Address,
        aCallback: otCommissionerEnergyReportCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
#[doc = " This function pointer is called when the Commissioner receives a PAN ID Conflict message."]
#[doc = ""]
#[doc = " @param[in]  aPanId             The PAN ID value."]
#[doc = " @param[in]  aChannelMask       The channel mask value."]
#[doc = " @param[in]  aContext           A pointer to application-specific context."]
#[doc = ""]
pub type otCommissionerPanIdConflictCallback = ::std::option::Option<
    unsafe extern "C" fn(aPanId: u16, aChannelMask: u32, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function sends a PAN ID Query message."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance             A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPanId                The PAN ID to query."]
    #[doc = " @param[in]  aChannelMask          The channel mask value."]
    #[doc = " @param[in]  aAddress              A pointer to the IPv6 destination."]
    #[doc = " @param[in]  aCallback             A pointer to a function called on receiving a PAN ID Conflict message."]
    #[doc = " @param[in]  aContext              A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully enqueued the PAN ID Query message."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate a PAN ID Query message."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    #[doc = " @note Only use this after successfully starting the Commissioner role with otCommissionerStart()."]
    #[doc = ""]
    pub fn otCommissionerPanIdQuery(
        aInstance: *mut otInstance,
        aPanId: u16,
        aChannelMask: u32,
        aAddress: *const otIp6Address,
        aCallback: otCommissionerPanIdConflictCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends MGMT_COMMISSIONER_GET."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aTlvs      A pointer to TLVs."]
    #[doc = " @param[in]  aLength    The length of TLVs."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully send the meshcop dataset command."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    pub fn otCommissionerSendMgmtGet(
        aInstance: *mut otInstance,
        aTlvs: *const u8,
        aLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends MGMT_COMMISSIONER_SET."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset   A pointer to commissioning dataset."]
    #[doc = " @param[in]  aTlvs      A pointer to TLVs."]
    #[doc = " @param[in]  aLength    The length of TLVs."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully send the meshcop dataset command."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The commissioner is not active."]
    #[doc = ""]
    pub fn otCommissionerSendMgmtSet(
        aInstance: *mut otInstance,
        aDataset: *const otCommissioningDataset,
        aTlvs: *const u8,
        aLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns the Commissioner Session ID."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The current commissioner session id."]
    #[doc = ""]
    pub fn otCommissionerGetSessionId(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " This function returns the Commissioner State."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_COMMISSIONER_STATE_DISABLED  Commissioner disabled."]
    #[doc = " @retval OT_COMMISSIONER_STATE_PETITION  Becoming the commissioner."]
    #[doc = " @retval OT_COMMISSIONER_STATE_ACTIVE    Commissioner enabled."]
    #[doc = ""]
    pub fn otCommissionerGetState(aInstance: *mut otInstance) -> otCommissionerState;
}
extern "C" {
    #[doc = " For FTD only, creates a new Operational Dataset to use when forming a new network."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[out] aDataset   The Operational Dataset."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully created a new Operational Dataset."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to generate random values for new parameters."]
    #[doc = ""]
    pub fn otDatasetCreateNewNetwork(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " For FTD only, gets a minimal delay timer."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval the value of minimal delay timer (in ms)."]
    #[doc = ""]
    pub fn otDatasetGetDelayTimerMinimal(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " For FTD only, sets a minimal delay timer."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance           A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDelayTimerMinimal  The value of minimal delay timer (in ms)."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE          Successfully set minimal delay timer."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS  If @p aDelayTimerMinimal is not valid."]
    #[doc = ""]
    pub fn otDatasetSetDelayTimerMinimal(
        aInstance: *mut otInstance,
        aDelayTimerMinimal: u32,
    ) -> otError;
}
#[doc = " This callback function pointer is called when a Dataset update request finishes, reporting success or failure status"]
#[doc = " of the Dataset update request."]
#[doc = ""]
#[doc = " Available when `OPENTHREAD_CONFIG_DATASET_UPDATER_ENABLE` is enabled."]
#[doc = ""]
#[doc = " @param[in] aError   The error status."]
#[doc = "                     OT_ERROR_NONE            indicates successful Dataset update."]
#[doc = "                     OT_ERROR_INVALID_STATE   indicates failure due invalid state (MLE being disabled)."]
#[doc = "                     OT_ERROR_ALREADY         indicates failure due to another device within network requesting"]
#[doc = "                                              a conflicting Dataset update."]
#[doc = ""]
#[doc = " @param[in] aContext A pointer to the arbitrary context (provided by user in `otDatasetUpdaterRequestUpdate()`)."]
#[doc = ""]
pub type otDatasetUpdaterCallback = ::std::option::Option<
    unsafe extern "C" fn(aError: otError, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function requests an update to Operational Dataset."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_DATASET_UPDATER_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @p aDataset should contain the fields to be updated and their new value. It must not contain Active or Pending"]
    #[doc = " Timestamp fields. The Delay field is optional, if not provided a default value (1000 ms) would be used."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance               A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDataset                A pointer to the Dataset containing the fields to change."]
    #[doc = " @param[in]  aCallback               A callback to indicate when Dataset update request finishes."]
    #[doc = " @param[in]  aContext                An arbitrary context passed to callback."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Dataset update started successfully (@p aCallback will be invoked on completion)."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Device is disabled (MLE is disabled)."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   The @p aDataset is not valid (contains Active or Pending Timestamp)."]
    #[doc = " @retval OT_ERROR_BUSY           Cannot start update, a previous one is ongoing."]
    #[doc = " @retval OT_ERROR_NO_BUFS        Could not allocated buffer to save Dataset."]
    #[doc = ""]
    pub fn otDatasetUpdaterRequestUpdate(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
        aCallback: otDatasetUpdaterCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function cancels an ongoing (if any) Operational Dataset update request."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_DATASET_UPDATER_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otDatasetUpdaterCancelUpdate(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function indicates whether there is an ongoing Operation Dataset update request."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_DATASET_UPDATER_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE    There is an ongoing update."]
    #[doc = " @retval FALSE   There is no ongoing update."]
    #[doc = ""]
    pub fn otDatasetUpdaterIsUpdateOngoing(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function processes a factory diagnostics command line."]
    #[doc = ""]
    #[doc = " The output of this function (the content written to @p aOutput) MUST terminate with `\\0` and the `\\0` is within the"]
    #[doc = " output buffer."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aArgsLength     The number of elements in @p aArgs."]
    #[doc = " @param[in]   aArgs           An array of arguments."]
    #[doc = " @param[out]  aOutput         The diagnostics execution result."]
    #[doc = " @param[in]   aOutputMaxLen   The output buffer size."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS       The command is supported but invalid arguments provided."]
    #[doc = " @retval  OT_ERROR_NONE               The command is successfully process."]
    #[doc = " @retval  OT_ERROR_NOT_IMPLEMENTED    The command is not supported."]
    #[doc = ""]
    pub fn otDiagProcessCmd(
        aInstance: *mut otInstance,
        aArgsLength: u8,
        aArgs: *mut *mut ::std::os::raw::c_char,
        aOutput: *mut ::std::os::raw::c_char,
        aOutputMaxLen: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " This function processes a factory diagnostics command line."]
    #[doc = ""]
    #[doc = " The output of this function (the content written to @p aOutput) MUST terminate with `\\0` and the `\\0` is within the"]
    #[doc = " output buffer."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aString         A NULL-terminated input string."]
    #[doc = " @param[out]  aOutput         The diagnostics execution result."]
    #[doc = " @param[in]   aOutputMaxLen   The output buffer size."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE               The command is successfully process."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS       The command is supported but invalid arguments provided."]
    #[doc = " @retval  OT_ERROR_NOT_IMPLEMENTED    The command is not supported."]
    #[doc = " @retval  OT_ERROR_NO_BUFS            The command string is too long."]
    #[doc = ""]
    pub fn otDiagProcessCmdLine(
        aInstance: *mut otInstance,
        aString: *const ::std::os::raw::c_char,
        aOutput: *mut ::std::os::raw::c_char,
        aOutputMaxLen: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not the factory diagnostics mode is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE if factory diagnostics mode is enabled"]
    #[doc = " @retval FALSE if factory diagnostics mode is disabled."]
    #[doc = ""]
    pub fn otDiagIsEnabled(aInstance: *mut otInstance) -> bool;
}
#[doc = " This structure represents a TXT record entry representing a key/value pair (RFC 6763 - section 6.3)."]
#[doc = ""]
#[doc = " The string buffers pointed to by `mKey` and `mValue` MUST persist and remain unchanged after an instance of such"]
#[doc = " structure is passed to OpenThread (as part of `otSrpClientService` instance)."]
#[doc = ""]
#[doc = " An array of `otDnsTxtEntry` entries are used in `otSrpClientService` to specify the full TXT record (a list of"]
#[doc = " entries)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnsTxtEntry {
    #[doc = " The TXT record key string."]
    #[doc = ""]
    #[doc = " If `mKey` is not NULL, then it MUST be a null-terminated C string. The entry is treated as key/value pair with"]
    #[doc = " `mValue` buffer providing the value."]
    #[doc = "   - The entry is encoded as follows:"]
    #[doc = "        - A single string length byte followed by \"key=value\" format (without the quotation marks)."]
    #[doc = "- In this case, the overall encoded length must be 255 bytes or less."]
    #[doc = "   - If `mValue` is NULL, then key is treated as a boolean attribute and encoded as \"key\" (with no `=`)."]
    #[doc = "   - If `mValue` is not NULL but `mValueLength` is zero, then it is treated as empty value and encoded as \"key=\"."]
    #[doc = ""]
    #[doc = " If `mKey` is NULL, then `mValue` buffer is treated as an already encoded TXT-DATA and is appended as is in the"]
    #[doc = " DNS message."]
    #[doc = ""]
    pub mKey: *const ::std::os::raw::c_char,
    #[doc = "< The TXT record value or already encoded TXT-DATA (depending on `mKey`)."]
    pub mValue: *const u8,
    #[doc = "< Number of bytes in `mValue` buffer."]
    pub mValueLength: u16,
}
impl Default for otDnsTxtEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents an iterator for TXT record entires (key/value pairs)."]
#[doc = ""]
#[doc = " The data fields in this structure are intended for use by OpenThread core and caller should not read or change them."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnsTxtEntryIterator {
    pub mPtr: *const ::std::os::raw::c_void,
    pub mData: [u16; 2usize],
    pub mChar: [::std::os::raw::c_char; 10usize],
}
impl Default for otDnsTxtEntryIterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function initializes a TXT record iterator."]
    #[doc = ""]
    #[doc = " The buffer pointer @p aTxtData and its content MUST persist and remain unchanged while @p aIterator object"]
    #[doc = " is being used."]
    #[doc = ""]
    #[doc = " @param[in] aIterator       A pointer to the iterator to initialize (MUST NOT be NULL)."]
    #[doc = " @param[in] aTxtData        A pointer to buffer containing the encoded TXT data."]
    #[doc = " @param[in] aTxtDataLength  The length (number of bytes) of @p aTxtData."]
    #[doc = ""]
    pub fn otDnsInitTxtEntryIterator(
        aIterator: *mut otDnsTxtEntryIterator,
        aTxtData: *const u8,
        aTxtDataLength: u16,
    );
}
extern "C" {
    #[doc = " This function parses the TXT data from an iterator and gets the next TXT record entry (key/value pair)."]
    #[doc = ""]
    #[doc = " The @p aIterator MUST be initialized using `otDnsInitTxtEntryIterator()` before calling this function and the TXT"]
    #[doc = " data buffer used to initialize the iterator MUST persist and remain unchanged. Otherwise the behavior of this"]
    #[doc = " function is undefined."]
    #[doc = ""]
    #[doc = " If the parsed key string length is smaller than or equal to `OT_DNS_TXT_KEY_MAX_LENGTH` (recommended max key length)"]
    #[doc = " the key string is returned in `mKey` in @p aEntry. But if the key is longer, then `mKey` is set to NULL and the"]
    #[doc = " entire encoded TXT entry string is returned in `mValue` and `mValueLength`."]
    #[doc = ""]
    #[doc = " @param[in]  aIterator   A pointer to the iterator (MUST NOT be NULL)."]
    #[doc = " @param[out] aEntry      A pointer to a `otDnsTxtEntry` structure to output the parsed/read entry (MUST NOT be NULL)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       The next entry was parsed successfully. @p aEntry is updated."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No more entries in the TXT data."]
    #[doc = " @retval OT_ERROR_PARSE      The TXT data from @p aIterator is not well-formed."]
    #[doc = ""]
    pub fn otDnsGetNextTxtEntry(
        aIterator: *mut otDnsTxtEntryIterator,
        aEntry: *mut otDnsTxtEntry,
    ) -> otError;
}
extern "C" {
    #[doc = " This function enables/disables the \"DNS name compression\" mode."]
    #[doc = ""]
    #[doc = " By default DNS name compression is enabled. When disabled, DNS names are appended as full and never compressed. This"]
    #[doc = " is applicable to OpenThread's DNS and SRP client/server modules."]
    #[doc = ""]
    #[doc = " This is intended for testing only and available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` config is enabled."]
    #[doc = ""]
    #[doc = " Note that in the case `OPENTHREAD_CONFIG_MULTIPLE_INSTANCE_ENABLE` is used, this mode applies to all OpenThread"]
    #[doc = " instances (i.e., calling this function enables/disables the compression mode on all OpenThread instances)."]
    #[doc = ""]
    #[doc = " @param[in] aEnabled   TRUE to enable the \"DNS name compression\" mode, FALSE to disable."]
    #[doc = ""]
    pub fn otDnsSetNameCompressionEnabled(aEnabled: bool);
}
extern "C" {
    #[doc = " This function indicates whether the \"DNS name compression\" mode is enabled or not."]
    #[doc = ""]
    #[doc = " This is intended for testing only and available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` config is enabled."]
    #[doc = ""]
    #[doc = " @returns TRUE if the \"DNS name compression\" mode is enabled, FALSE otherwise."]
    #[doc = ""]
    pub fn otDnsIsNameCompressionEnabled() -> bool;
}
#[doc = "< Indicates the flag is not specified."]
pub const OT_DNS_FLAG_UNSPECIFIED: otDnsRecursionFlag = 0;
#[doc = "< Indicates DNS name server can resolve the query recursively."]
pub const OT_DNS_FLAG_RECURSION_DESIRED: otDnsRecursionFlag = 1;
#[doc = "< Indicates DNS name server can not resolve the query recursively."]
pub const OT_DNS_FLAG_NO_RECURSION: otDnsRecursionFlag = 2;
#[doc = " This enumeration type represents the \"Recursion Desired\" (RD) flag in an `otDnsQueryConfig`."]
#[doc = ""]
pub type otDnsRecursionFlag = ::std::os::raw::c_uint;
#[doc = "< NAT64 mode is not specified. Use default NAT64 mode."]
pub const OT_DNS_NAT64_UNSPECIFIED: otDnsNat64Mode = 0;
#[doc = "< Allow NAT64 address translation during DNS client address resolution."]
pub const OT_DNS_NAT64_ALLOW: otDnsNat64Mode = 1;
#[doc = "< Do not allow NAT64 address translation during DNS client address resolution."]
pub const OT_DNS_NAT64_DISALLOW: otDnsNat64Mode = 2;
#[doc = " This enumeration type represents the NAT64 mode in an `otDnsQueryConfig`."]
#[doc = ""]
#[doc = " The NAT64 mode indicates whether to allow or disallow NAT64 address translation during DNS client address resolution."]
#[doc = " This mode is only used when `OPENTHREAD_CONFIG_DNS_CLIENT_NAT64_ENABLE` is enabled."]
#[doc = ""]
pub type otDnsNat64Mode = ::std::os::raw::c_uint;
pub const OT_DNS_TRANSPORT_UNSPECIFIED: otDnsTransportProto = 0;
#[doc = " DNS transport is unspecified."]
pub const OT_DNS_TRANSPORT_UDP: otDnsTransportProto = 1;
#[doc = " DNS query should be sent via UDP."]
pub const OT_DNS_TRANSPORT_TCP: otDnsTransportProto = 2;
#[doc = " This enumeration type represents the DNS transport protocol in an `otDnsQueryConfig`."]
#[doc = ""]
#[doc = " This `OT_DNS_TRANSPORT_TCP` is only supported when `OPENTHREAD_CONFIG_DNS_CLIENT_OVER_TCP_ENABLE` is enabled."]
#[doc = ""]
pub type otDnsTransportProto = ::std::os::raw::c_uint;
#[doc = " This structure represents a DNS query configuration."]
#[doc = ""]
#[doc = " Any of the fields in this structure can be set to zero to indicate that it is not specified. How the unspecified"]
#[doc = " fields are treated is determined by the function which uses the instance of `otDnsQueryConfig`."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otDnsQueryConfig {
    #[doc = "< Server address (IPv6 address/port). All zero or zero port for unspecified."]
    pub mServerSockAddr: otSockAddr,
    #[doc = "< Wait time (in msec) to rx response. Zero indicates unspecified value."]
    pub mResponseTimeout: u32,
    #[doc = "< Maximum tx attempts before reporting failure. Zero for unspecified value."]
    pub mMaxTxAttempts: u8,
    #[doc = "< Indicates whether the server can resolve the query recursively or not."]
    pub mRecursionFlag: otDnsRecursionFlag,
    #[doc = "< Allow/Disallow NAT64 address translation during address resolution."]
    pub mNat64Mode: otDnsNat64Mode,
    #[doc = "< Select default transport protocol."]
    pub mTransportProto: otDnsTransportProto,
}
impl Default for otDnsQueryConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function gets the current default query config used by DNS client."]
    #[doc = ""]
    #[doc = " When OpenThread stack starts, the default DNS query config is determined from a set of OT config options such as"]
    #[doc = " `OPENTHREAD_CONFIG_DNS_CLIENT_DEFAULT_SERVER_IP6_ADDRESS`, `_DEFAULT_SERVER_PORT`, `_DEFAULT_RESPONSE_TIMEOUT`, etc."]
    #[doc = " (see `config/dns_client.h` for all related config options)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the current default config being used by DNS client."]
    #[doc = ""]
    pub fn otDnsClientGetDefaultConfig(aInstance: *mut otInstance) -> *const otDnsQueryConfig;
}
extern "C" {
    #[doc = " This function sets the default query config on DNS client."]
    #[doc = ""]
    #[doc = " @note Any ongoing query will continue to use the config from when it was started. The new default config will be"]
    #[doc = " used for any future DNS queries."]
    #[doc = ""]
    #[doc = " The @p aConfig can be NULL. In this case the default config will be set to the defaults from OT config options"]
    #[doc = " `OPENTHREAD_CONFIG_DNS_CLIENT_DEFAULT_{}`. This resets the default query config back to to the config when the"]
    #[doc = " OpenThread stack starts."]
    #[doc = ""]
    #[doc = " In a non-NULL @p aConfig, caller can choose to leave some of the fields in `otDnsQueryConfig` instance unspecified"]
    #[doc = " (value zero). The unspecified fields are replaced by the corresponding OT config option definitions"]
    #[doc = " `OPENTHREAD_CONFIG_DNS_CLIENT_DEFAULT_{}` to form the default query config."]
    #[doc = ""]
    #[doc = " When `OPENTHREAD_CONFIG_DNS_CLIENT_DEFAULT_SERVER_ADDRESS_AUTO_SET_ENABLE` is enabled, the server's IPv6 address in"]
    #[doc = " the default config is automatically set and updated by DNS client. This is done only when user does not explicitly"]
    #[doc = " set or specify it. This behavior requires SRP client and its auto-start feature to be enabled. SRP client will then"]
    #[doc = " monitor the Thread Network Data for DNS/SRP Service entries to select an SRP server. The selected SRP server address"]
    #[doc = " is also set as the DNS server address in the default config."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aConfig     A pointer to the new query config to use as default."]
    #[doc = ""]
    pub fn otDnsClientSetDefaultConfig(
        aInstance: *mut otInstance,
        aConfig: *const otDnsQueryConfig,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnsAddressResponse {
    _unused: [u8; 0],
}
#[doc = " This function pointer is called when a DNS response is received for an address resolution query."]
#[doc = ""]
#[doc = " Within this callback the user can use `otDnsAddressResponseGet{Item}()` functions along with the @p aResponse"]
#[doc = " pointer to get more info about the response."]
#[doc = ""]
#[doc = " The @p aResponse pointer can only be used within this callback and after returning from this function it will not"]
#[doc = " stay valid, so the user MUST NOT retain the @p aResponse pointer for later use."]
#[doc = ""]
#[doc = " @param[in]  aError     The result of the DNS transaction."]
#[doc = " @param[in]  aResponse  A pointer to the response (it is always non-NULL)."]
#[doc = " @param[in]  aContext   A pointer to application-specific context."]
#[doc = ""]
#[doc = " The @p aError can have the following:"]
#[doc = ""]
#[doc = "  - OT_ERROR_NONE              A response was received successfully."]
#[doc = "  - OT_ERROR_ABORT             A DNS transaction was aborted by stack."]
#[doc = "  - OT_ERROR_RESPONSE_TIMEOUT  No DNS response has been received within timeout."]
#[doc = ""]
#[doc = " If the server rejects the address resolution request the error code from server is mapped as follow:"]
#[doc = ""]
#[doc = "  - (0)  NOERROR   Success (no error condition)                    -> OT_ERROR_NONE"]
#[doc = "  - (1)  FORMERR   Server unable to interpret due to format error  -> OT_ERROR_PARSE"]
#[doc = "  - (2)  SERVFAIL  Server encountered an internal failure          -> OT_ERROR_FAILED"]
#[doc = "  - (3)  NXDOMAIN  Name that ought to exist, does not exist        -> OT_ERROR_NOT_FOUND"]
#[doc = "  - (4)  NOTIMP    Server does not support the query type (OpCode) -> OT_ERROR_NOT_IMPLEMENTED"]
#[doc = "  - (5)  REFUSED   Server refused for policy/security reasons      -> OT_ERROR_SECURITY"]
#[doc = "  - (6)  YXDOMAIN  Some name that ought not to exist, does exist   -> OT_ERROR_DUPLICATED"]
#[doc = "  - (7)  YXRRSET   Some RRset that ought not to exist, does exist  -> OT_ERROR_DUPLICATED"]
#[doc = "  - (8)  NXRRSET   Some RRset that ought to exist, does not exist  -> OT_ERROR_NOT_FOUND"]
#[doc = "  - (9)  NOTAUTH   Service is not authoritative for zone           -> OT_ERROR_SECURITY"]
#[doc = "  - (10) NOTZONE   A name is not in the zone                       -> OT_ERROR_PARSE"]
#[doc = "  - (20) BADNAME   Bad name                                        -> OT_ERROR_PARSE"]
#[doc = "  - (21) BADALG    Bad algorithm                                   -> OT_ERROR_SECURITY"]
#[doc = "  - (22) BADTRUN   Bad truncation                                  -> OT_ERROR_PARSE"]
#[doc = "  - Other response codes                                           -> OT_ERROR_FAILED"]
#[doc = ""]
pub type otDnsAddressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aError: otError,
        aResponse: *const otDnsAddressResponse,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function sends an address resolution DNS query for AAAA (IPv6) record(s) for a given host name."]
    #[doc = ""]
    #[doc = " The @p aConfig can be NULL. In this case the default config (from `otDnsClientGetDefaultConfig()`) will be used as"]
    #[doc = " the config for this query. In a non-NULL @p aConfig, some of the fields can be left unspecified (value zero). The"]
    #[doc = " unspecified fields are then replaced by the values from the default config."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aHostName        The host name for which to query the address (MUST NOT be NULL)."]
    #[doc = " @param[in]  aCallback        A function pointer that shall be called on response reception or time-out."]
    #[doc = " @param[in]  aContext         A pointer to arbitrary context information."]
    #[doc = " @param[in]  aConfig          A pointer to the config to use for this query."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Query sent successfully. @p aCallback will be invoked to report the status."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer to prepare and send query."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The host name is not valid format."]
    #[doc = " @retval OT_ERROR_INVALID_STATE Cannot send query since Thread interface is not up."]
    #[doc = ""]
    pub fn otDnsClientResolveAddress(
        aInstance: *mut otInstance,
        aHostName: *const ::std::os::raw::c_char,
        aCallback: otDnsAddressCallback,
        aContext: *mut ::std::os::raw::c_void,
        aConfig: *const otDnsQueryConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends an address resolution DNS query for A (IPv4) record(s) for a given host name."]
    #[doc = ""]
    #[doc = " This function requires and is available when `OPENTHREAD_CONFIG_DNS_CLIENT_NAT64_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " When a successful response is received, the addresses are returned from @p aCallback as NAT64 IPv6 translated"]
    #[doc = " versions of the IPv4 addresses from the query response."]
    #[doc = ""]
    #[doc = " The @p aConfig can be NULL. In this case the default config (from `otDnsClientGetDefaultConfig()`) will be used as"]
    #[doc = " the config for this query. In a non-NULL @p aConfig, some of the fields can be left unspecified (value zero). The"]
    #[doc = " unspecified fields are then replaced by the values from the default config."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aHostName        The host name for which to query the address (MUST NOT be NULL)."]
    #[doc = " @param[in]  aCallback        A function pointer that shall be called on response reception or time-out."]
    #[doc = " @param[in]  aContext         A pointer to arbitrary context information."]
    #[doc = " @param[in]  aConfig          A pointer to the config to use for this query."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Query sent successfully. @p aCallback will be invoked to report the status."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer to prepare and send query."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The host name is not valid format or NAT64 is not enabled in config."]
    #[doc = " @retval OT_ERROR_INVALID_STATE Cannot send query since Thread interface is not up."]
    #[doc = ""]
    pub fn otDnsClientResolveIp4Address(
        aInstance: *mut otInstance,
        aHostName: *const ::std::os::raw::c_char,
        aCallback: otDnsAddressCallback,
        aContext: *mut ::std::os::raw::c_void,
        aConfig: *const otDnsQueryConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the full host name associated with an address resolution DNS response."]
    #[doc = ""]
    #[doc = " This function MUST only be used from `otDnsAddressCallback`."]
    #[doc = ""]
    #[doc = " @param[in]  aResponse         A pointer to the response."]
    #[doc = " @param[out] aNameBuffer       A buffer to char array to output the full host name (MUST NOT be NULL)."]
    #[doc = " @param[in]  aNameBufferSize   The size of @p aNameBuffer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     The full host name was read successfully."]
    #[doc = " @retval OT_ERROR_NO_BUFS  The name does not fit in @p aNameBuffer."]
    #[doc = ""]
    pub fn otDnsAddressResponseGetHostName(
        aResponse: *const otDnsAddressResponse,
        aNameBuffer: *mut ::std::os::raw::c_char,
        aNameBufferSize: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets an IPv6 address associated with an address resolution DNS response."]
    #[doc = ""]
    #[doc = " This function MUST only be used from `otDnsAddressCallback`."]
    #[doc = ""]
    #[doc = " The response may include multiple IPv6 address records. @p aIndex can be used to iterate through the list of"]
    #[doc = " addresses. Index zero gets the first address and so on. When we reach end of the list, `OT_ERROR_NOT_FOUND` is"]
    #[doc = " returned."]
    #[doc = ""]
    #[doc = " @param[in]  aResponse     A pointer to the response."]
    #[doc = " @param[in]  aIndex        The address record index to retrieve."]
    #[doc = " @param[out] aAddress      A pointer to a IPv6 address to output the address (MUST NOT be NULL)."]
    #[doc = " @param[out] aTtl          A pointer to an `uint32_t` to output TTL for the address. It can be NULL if caller does not"]
    #[doc = "                           want to get the TTL."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           The address was read successfully."]
    #[doc = " @retval OT_ERROR_NOT_FOUND      No address record in @p aResponse at @p aIndex."]
    #[doc = " @retval OT_ERROR_PARSE          Could not parse the records in the @p aResponse."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  No NAT64 prefix (applicable only when NAT64 is allowed)."]
    #[doc = ""]
    pub fn otDnsAddressResponseGetAddress(
        aResponse: *const otDnsAddressResponse,
        aIndex: u16,
        aAddress: *mut otIp6Address,
        aTtl: *mut u32,
    ) -> otError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnsBrowseResponse {
    _unused: [u8; 0],
}
#[doc = " This function pointer is called when a DNS response is received for a browse (service instance enumeration) query."]
#[doc = ""]
#[doc = " Within this callback the user can use `otDnsBrowseResponseGet{Item}()` functions along with the @p aResponse"]
#[doc = " pointer to get more info about the response."]
#[doc = ""]
#[doc = " The @p aResponse pointer can only be used within this callback and after returning from this function it will not"]
#[doc = " stay valid, so the user MUST NOT retain the @p aResponse pointer for later use."]
#[doc = ""]
#[doc = " @param[in]  aError     The result of the DNS transaction."]
#[doc = " @param[in]  aResponse  A pointer to the response (it is always non-NULL)."]
#[doc = " @param[in]  aContext   A pointer to application-specific context."]
#[doc = ""]
#[doc = " For the full list of possible values for @p aError, please see `otDnsAddressCallback()`."]
#[doc = ""]
pub type otDnsBrowseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aError: otError,
        aResponse: *const otDnsBrowseResponse,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " This structure provides info for a DNS service instance."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otDnsServiceInfo {
    #[doc = "< Service record TTL (in seconds)."]
    pub mTtl: u32,
    #[doc = "< Service port number."]
    pub mPort: u16,
    #[doc = "< Service priority."]
    pub mPriority: u16,
    #[doc = "< Service weight."]
    pub mWeight: u16,
    #[doc = "< Buffer to output the service host name (can be NULL if not needed)."]
    pub mHostNameBuffer: *mut ::std::os::raw::c_char,
    #[doc = "< Size of `mHostNameBuffer`."]
    pub mHostNameBufferSize: u16,
    #[doc = "< The host IPv6 address. Set to all zero if not available."]
    pub mHostAddress: otIp6Address,
    #[doc = "< The host address TTL."]
    pub mHostAddressTtl: u32,
    #[doc = "< Buffer to output TXT data (can be NULL if not needed)."]
    pub mTxtData: *mut u8,
    #[doc = "< On input, size of `mTxtData` buffer. On output number bytes written."]
    pub mTxtDataSize: u16,
    #[doc = "< Indicates if TXT data could not fit in `mTxtDataSize` and was truncated."]
    pub mTxtDataTruncated: bool,
    #[doc = "< The TXT data TTL."]
    pub mTxtDataTtl: u32,
}
impl Default for otDnsServiceInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function sends a DNS browse (service instance enumeration) query for a given service name."]
    #[doc = ""]
    #[doc = " This function is available when `OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " The @p aConfig can be NULL. In this case the default config (from `otDnsClientGetDefaultConfig()`) will be used as"]
    #[doc = " the config for this query. In a non-NULL @p aConfig, some of the fields can be left unspecified (value zero). The"]
    #[doc = " unspecified fields are then replaced by the values from the default config."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aServiceName     The service name to query for (MUST NOT be NULL)."]
    #[doc = " @param[in]  aCallback        A function pointer that shall be called on response reception or time-out."]
    #[doc = " @param[in]  aContext         A pointer to arbitrary context information."]
    #[doc = " @param[in]  aConfig          A pointer to the config to use for this query."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE        Query sent successfully. @p aCallback will be invoked to report the status."]
    #[doc = " @retval OT_ERROR_NO_BUFS     Insufficient buffer to prepare and send query."]
    #[doc = ""]
    pub fn otDnsClientBrowse(
        aInstance: *mut otInstance,
        aServiceName: *const ::std::os::raw::c_char,
        aCallback: otDnsBrowseCallback,
        aContext: *mut ::std::os::raw::c_void,
        aConfig: *const otDnsQueryConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the service name associated with a DNS browse (service instance enumeration) response."]
    #[doc = ""]
    #[doc = " This function MUST only be used from `otDnsBrowseCallback`."]
    #[doc = ""]
    #[doc = " @param[in]  aResponse         A pointer to the response."]
    #[doc = " @param[out] aNameBuffer       A buffer to char array to output the service name (MUST NOT be NULL)."]
    #[doc = " @param[in]  aNameBufferSize   The size of @p aNameBuffer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     The service name was read successfully."]
    #[doc = " @retval OT_ERROR_NO_BUFS  The name does not fit in @p aNameBuffer."]
    #[doc = ""]
    pub fn otDnsBrowseResponseGetServiceName(
        aResponse: *const otDnsBrowseResponse,
        aNameBuffer: *mut ::std::os::raw::c_char,
        aNameBufferSize: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets a service instance associated with a DNS browse (service instance enumeration) response."]
    #[doc = ""]
    #[doc = " This function MUST only be used from `otDnsBrowseCallback`."]
    #[doc = ""]
    #[doc = " The response may include multiple service instance records. @p aIndex can be used to iterate through the list. Index"]
    #[doc = " zero gives the the first record. When we reach end of the list, `OT_ERROR_NOT_FOUND` is returned."]
    #[doc = ""]
    #[doc = " Note that this function gets the service instance label and not the full service instance name which is of the form"]
    #[doc = " `<Instance>.<Service>.<Domain>`."]
    #[doc = ""]
    #[doc = " @param[in]  aResponse          A pointer to the response."]
    #[doc = " @param[in]  aIndex             The service instance record index to retrieve."]
    #[doc = " @param[out] aLabelBuffer       A buffer to char array to output the service instance label (MUST NOT be NULL)."]
    #[doc = " @param[in]  aLabelBufferSize   The size of @p aLabelBuffer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          The service instance was read successfully."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The name does not fit in @p aNameBuffer."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No service instance record in @p aResponse at @p aIndex."]
    #[doc = " @retval OT_ERROR_PARSE         Could not parse the records in the @p aResponse."]
    #[doc = ""]
    pub fn otDnsBrowseResponseGetServiceInstance(
        aResponse: *const otDnsBrowseResponse,
        aIndex: u16,
        aLabelBuffer: *mut ::std::os::raw::c_char,
        aLabelBufferSize: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets info for a service instance from a DNS browse (service instance enumeration) response."]
    #[doc = ""]
    #[doc = " This function MUST only be used from `otDnsBrowseCallback`."]
    #[doc = ""]
    #[doc = " A browse DNS response should include the SRV, TXT, and AAAA records for the service instances that are enumerated"]
    #[doc = " (note that it is a SHOULD and not a MUST requirement). This function tries to retrieve this info for a given service"]
    #[doc = " instance when available."]
    #[doc = ""]
    #[doc = " - If no matching SRV record is found in @p aResponse, `OT_ERROR_NOT_FOUND` is returned."]
    #[doc = " - If a matching SRV record is found in @p aResponse, @p aServiceInfo is updated and `OT_ERROR_NONE` is returned."]
    #[doc = " - If no matching TXT record is found in @p aResponse, `mTxtDataSize` in @p aServiceInfo is set to zero."]
    #[doc = " - If TXT data length is greater than `mTxtDataSize`, it is read partially and `mTxtDataTruncated` is set to true."]
    #[doc = " - If no matching AAAA record is found in @p aResponse, `mHostAddress is set to all zero or unspecified address."]
    #[doc = " - If there are multiple AAAA records for the host name in @p aResponse, `mHostAddress` is set to the first one. The"]
    #[doc = "   other addresses can be retrieved using `otDnsBrowseResponseGetHostAddress()`."]
    #[doc = ""]
    #[doc = " @param[in]  aResponse          A pointer to the response."]
    #[doc = " @param[in]  aInstanceLabel     The service instance label (MUST NOT be NULL)."]
    #[doc = " @param[out] aServiceInfo       A `ServiceInfo` to output the service instance information (MUST NOT be NULL)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          The service instance info was read. @p aServiceInfo is updated."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     Could not find a matching SRV record for @p aInstanceLabel."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The host name and/or TXT data could not fit in the given buffers."]
    #[doc = " @retval OT_ERROR_PARSE         Could not parse the records in the @p aResponse."]
    #[doc = ""]
    pub fn otDnsBrowseResponseGetServiceInfo(
        aResponse: *const otDnsBrowseResponse,
        aInstanceLabel: *const ::std::os::raw::c_char,
        aServiceInfo: *mut otDnsServiceInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the host IPv6 address from a DNS browse (service instance enumeration) response."]
    #[doc = ""]
    #[doc = " This function MUST only be used from `otDnsBrowseCallback`."]
    #[doc = ""]
    #[doc = " The response can include zero or more IPv6 address records. @p aIndex can be used to iterate through the list of"]
    #[doc = " addresses. Index zero gets the first address and so on. When we reach end of the list, `OT_ERROR_NOT_FOUND` is"]
    #[doc = " returned."]
    #[doc = ""]
    #[doc = " @param[in]  aResponse     A pointer to the response."]
    #[doc = " @param[in]  aHostName     The host name to get the address (MUST NOT be NULL)."]
    #[doc = " @param[in]  aIndex        The address record index to retrieve."]
    #[doc = " @param[out] aAddress      A pointer to a IPv6 address to output the address (MUST NOT be NULL)."]
    #[doc = " @param[out] aTtl          A pointer to an `uint32_t` to output TTL for the address. It can be NULL if caller does"]
    #[doc = "                           not want to get the TTL."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       The address was read successfully."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No address record for @p aHostname in @p aResponse at @p aIndex."]
    #[doc = " @retval OT_ERROR_PARSE      Could not parse the records in the @p aResponse."]
    #[doc = ""]
    pub fn otDnsBrowseResponseGetHostAddress(
        aResponse: *const otDnsBrowseResponse,
        aHostName: *const ::std::os::raw::c_char,
        aIndex: u16,
        aAddress: *mut otIp6Address,
        aTtl: *mut u32,
    ) -> otError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnsServiceResponse {
    _unused: [u8; 0],
}
#[doc = " This function pointer is called when a DNS response is received for a service instance resolution query."]
#[doc = ""]
#[doc = " Within this callback the user can use `otDnsServiceResponseGet{Item}()` functions along with the @p aResponse"]
#[doc = " pointer to get more info about the response."]
#[doc = ""]
#[doc = " The @p aResponse pointer can only be used within this callback and after returning from this function it will not"]
#[doc = " stay valid, so the user MUST NOT retain the @p aResponse pointer for later use."]
#[doc = ""]
#[doc = " @param[in]  aError     The result of the DNS transaction."]
#[doc = " @param[in]  aResponse  A pointer to the response (it is always non-NULL)."]
#[doc = " @param[in]  aContext   A pointer to application-specific context."]
#[doc = ""]
#[doc = " For the full list of possible values for @p aError, please see `otDnsAddressCallback()`."]
#[doc = ""]
pub type otDnsServiceCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aError: otError,
        aResponse: *const otDnsServiceResponse,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function sends a DNS service instance resolution query for a given service instance."]
    #[doc = ""]
    #[doc = " This function is available when `OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " The @p aConfig can be NULL. In this case the default config (from `otDnsClientGetDefaultConfig()`) will be used as"]
    #[doc = " the config for this query. In a non-NULL @p aConfig, some of the fields can be left unspecified (value zero). The"]
    #[doc = " unspecified fields are then replaced by the values from the default config."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aInstanceLabel     The service instance label."]
    #[doc = " @param[in]  aServiceName       The service name (together with @p aInstanceLabel form full instance name)."]
    #[doc = " @param[in]  aCallback          A function pointer that shall be called on response reception or time-out."]
    #[doc = " @param[in]  aContext           A pointer to arbitrary context information."]
    #[doc = " @param[in]  aConfig            A pointer to the config to use for this query."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Query sent successfully. @p aCallback will be invoked to report the status."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Insufficient buffer to prepare and send query."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aInstanceLabel is NULL."]
    #[doc = ""]
    pub fn otDnsClientResolveService(
        aInstance: *mut otInstance,
        aInstanceLabel: *const ::std::os::raw::c_char,
        aServiceName: *const ::std::os::raw::c_char,
        aCallback: otDnsServiceCallback,
        aContext: *mut ::std::os::raw::c_void,
        aConfig: *const otDnsQueryConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the service instance name associated with a DNS service instance resolution response."]
    #[doc = ""]
    #[doc = " This function MUST only be used from `otDnsServiceCallback`."]
    #[doc = ""]
    #[doc = " @param[in]  aResponse         A pointer to the response."]
    #[doc = " @param[out] aLabelBuffer      A buffer to char array to output the service instance label (MUST NOT be NULL)."]
    #[doc = " @param[in]  aLabelBufferSize  The size of @p aLabelBuffer."]
    #[doc = " @param[out] aNameBuffer       A buffer to char array to output the rest of service name (can be NULL if user is"]
    #[doc = "                               not interested in getting the name."]
    #[doc = " @param[in]  aNameBufferSize   The size of @p aNameBuffer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     The service name was read successfully."]
    #[doc = " @retval OT_ERROR_NO_BUFS  Either the label or name does not fit in the given buffers."]
    #[doc = ""]
    pub fn otDnsServiceResponseGetServiceName(
        aResponse: *const otDnsServiceResponse,
        aLabelBuffer: *mut ::std::os::raw::c_char,
        aLabelBufferSize: u8,
        aNameBuffer: *mut ::std::os::raw::c_char,
        aNameBufferSize: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets info for a service instance from a DNS service instance resolution response."]
    #[doc = ""]
    #[doc = " This function MUST only be used from `otDnsServiceCallback`."]
    #[doc = ""]
    #[doc = " - If no matching SRV record is found in @p aResponse, `OT_ERROR_NOT_FOUND` is returned."]
    #[doc = " - If a matching SRV record is found in @p aResponse, @p aServiceInfo is updated and `OT_ERROR_NONE` is returned."]
    #[doc = " - If no matching TXT record is found in @p aResponse, `mTxtDataSize` in @p aServiceInfo is set to zero."]
    #[doc = " - If TXT data length is greater than `mTxtDataSize`, it is read partially and `mTxtDataTruncated` is set to true."]
    #[doc = " - If no matching AAAA record is found in @p aResponse, `mHostAddress is set to all zero or unspecified address."]
    #[doc = " - If there are multiple AAAA records for the host name in @p aResponse, `mHostAddress` is set to the first one. The"]
    #[doc = "   other addresses can be retrieved using `otDnsServiceResponseGetHostAddress()`."]
    #[doc = ""]
    #[doc = " @param[in]  aResponse          A pointer to the response."]
    #[doc = " @param[out] aServiceInfo       A `ServiceInfo` to output the service instance information (MUST NOT be NULL)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          The service instance info was read. @p aServiceInfo is updated."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     Could not find a matching SRV record in @p aResponse."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The host name and/or TXT data could not fit in the given buffers."]
    #[doc = " @retval OT_ERROR_PARSE         Could not parse the records in the @p aResponse."]
    #[doc = ""]
    pub fn otDnsServiceResponseGetServiceInfo(
        aResponse: *const otDnsServiceResponse,
        aServiceInfo: *mut otDnsServiceInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the host IPv6 address from a DNS service instance resolution response."]
    #[doc = ""]
    #[doc = " This function MUST only be used from `otDnsServiceCallback`."]
    #[doc = ""]
    #[doc = " The response can include zero or more IPv6 address records. @p aIndex can be used to iterate through the list of"]
    #[doc = " addresses. Index zero gets the first address and so on. When we reach end of the list, `OT_ERROR_NOT_FOUND` is"]
    #[doc = " returned."]
    #[doc = ""]
    #[doc = " @param[in]  aResponse     A pointer to the response."]
    #[doc = " @param[in]  aHostName     The host name to get the address (MUST NOT be NULL)."]
    #[doc = " @param[in]  aIndex        The address record index to retrieve."]
    #[doc = " @param[out] aAddress      A pointer to a IPv6 address to output the address (MUST NOT be NULL)."]
    #[doc = " @param[out] aTtl          A pointer to an `uint32_t` to output TTL for the address. It can be NULL if caller does"]
    #[doc = "                           not want to get the TTL."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       The address was read successfully."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No address record for @p aHostname in @p aResponse at @p aIndex."]
    #[doc = " @retval OT_ERROR_PARSE      Could not parse the records in the @p aResponse."]
    #[doc = ""]
    pub fn otDnsServiceResponseGetHostAddress(
        aResponse: *const otDnsServiceResponse,
        aHostName: *const ::std::os::raw::c_char,
        aIndex: u16,
        aAddress: *mut otIp6Address,
        aTtl: *mut u32,
    ) -> otError;
}
#[doc = " This function is called when a DNS-SD query subscribes one of:"]
#[doc = "      1. a service name."]
#[doc = "      2. a service instance name."]
#[doc = "      3. a host name."]
#[doc = ""]
#[doc = " The DNS-SD query implementation is responsible for identifying what @p aFullName is."]
#[doc = " If @p aFullName is a service name or service instance name, the DNS-SD query implementation should discover"]
#[doc = " corresponding service instance information and notify the DNS-SD server using"]
#[doc = " `otDnssdQueryHandleDiscoveredServiceInstance`."]
#[doc = " If @p aFullName is a host name, the DNS-SD query implementation should"]
#[doc = " discover the host information and notify the DNS-SD server using `otDnssdQueryHandleDiscoveredHost`."]
#[doc = ""]
#[doc = " @note There can be multiple subscription to the same name. DNS-SD query implementation should record the number of"]
#[doc = " active subscriptions and stop notifying when there is no active subscription for @p aFullName."]
#[doc = ""]
#[doc = " @param[in] aContext      A pointer to the application-specific context."]
#[doc = " @param[in] aFullName     The null-terminated full service name (e.g. \"_ipps._tcp.default.service.arpa.\"),"]
#[doc = "                          or full service instance name (e.g. \"OpenThread._ipps._tcp.default.service.arpa.\"),"]
#[doc = "                          or full host name (e.g. \"ot-host.default.service.arpa.\")."]
#[doc = ""]
#[doc = " @sa otDnssdQueryHandleDiscoveredServiceInstance"]
#[doc = " @sa otDnssdQueryHandleDiscoveredHost"]
#[doc = ""]
pub type otDnssdQuerySubscribeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aFullName: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " This function is called when a DNS-SD query unsubscribes one of:"]
#[doc = "      1. a service name."]
#[doc = "      2. a service instance name."]
#[doc = "      3. a host name."]
#[doc = ""]
#[doc = " The DNS-SD query implementation is responsible for identifying what @p aFullName is."]
#[doc = ""]
#[doc = " @note There can be multiple subscription to the same name. DNS-SD query implementation should record the number of"]
#[doc = " active subscriptions and stop notifying when there is no active subscription for @p aFullName."]
#[doc = ""]
#[doc = " @param[in] aContext      A pointer to the application-specific context."]
#[doc = " @param[in] aFullName     The null-terminated full service name (e.g. \"_ipps._tcp.default.service.arpa.\"), or"]
#[doc = "                          full service instance name (e.g. \"OpenThread._ipps._tcp.default.service.arpa.\")."]
#[doc = ""]
pub type otDnssdQueryUnsubscribeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aFullName: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " This opaque type represents a DNS-SD query."]
#[doc = ""]
pub type otDnssdQuery = ::std::os::raw::c_void;
#[doc = " This structure represents information of a discovered service instance for a DNS-SD query."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnssdServiceInstanceInfo {
    #[doc = "< Full instance name (e.g. \"OpenThread._ipps._tcp.default.service.arpa.\")."]
    pub mFullName: *const ::std::os::raw::c_char,
    #[doc = "< Host name (e.g. \"ot-host.default.service.arpa.\")."]
    pub mHostName: *const ::std::os::raw::c_char,
    #[doc = "< Number of host IPv6 addresses."]
    pub mAddressNum: u8,
    #[doc = "< Host IPv6 addresses."]
    pub mAddresses: *const otIp6Address,
    #[doc = "< Service port."]
    pub mPort: u16,
    #[doc = "< Service priority."]
    pub mPriority: u16,
    #[doc = "< Service weight."]
    pub mWeight: u16,
    #[doc = "< Service TXT RDATA length."]
    pub mTxtLength: u16,
    #[doc = "< Service TXT RDATA."]
    pub mTxtData: *const u8,
    #[doc = "< Service TTL (in seconds)."]
    pub mTtl: u32,
}
impl Default for otDnssdServiceInstanceInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents information of a discovered host for a DNS-SD query."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnssdHostInfo {
    #[doc = "< Number of host IPv6 addresses."]
    pub mAddressNum: u8,
    #[doc = "< Host IPv6 addresses."]
    pub mAddresses: *const otIp6Address,
    #[doc = "< Service TTL (in seconds)."]
    pub mTtl: u32,
}
impl Default for otDnssdHostInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Service type unspecified."]
pub const OT_DNSSD_QUERY_TYPE_NONE: otDnssdQueryType = 0;
#[doc = "< Service type browse service."]
pub const OT_DNSSD_QUERY_TYPE_BROWSE: otDnssdQueryType = 1;
#[doc = "< Service type resolve service instance."]
pub const OT_DNSSD_QUERY_TYPE_RESOLVE: otDnssdQueryType = 2;
#[doc = "< Service type resolve hostname."]
pub const OT_DNSSD_QUERY_TYPE_RESOLVE_HOST: otDnssdQueryType = 3;
#[doc = " This enumeration specifies a DNS-SD query type."]
#[doc = ""]
pub type otDnssdQueryType = ::std::os::raw::c_uint;
#[doc = " This structure contains the counters of DNS-SD server."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otDnssdCounters {
    #[doc = "< The number of successful responses"]
    pub mSuccessResponse: u32,
    #[doc = "< The number of server failure responses"]
    pub mServerFailureResponse: u32,
    #[doc = "< The number of format error responses"]
    pub mFormatErrorResponse: u32,
    #[doc = "< The number of name error responses"]
    pub mNameErrorResponse: u32,
    #[doc = "< The number of 'not implemented' responses"]
    pub mNotImplementedResponse: u32,
    #[doc = "< The number of other responses"]
    pub mOtherResponse: u32,
    #[doc = "< The number of queries completely resolved by the local SRP server"]
    pub mResolvedBySrp: u32,
}
extern "C" {
    #[doc = " This function sets DNS-SD server query callbacks."]
    #[doc = ""]
    #[doc = " The DNS-SD server calls @p aSubscribe to subscribe to a service or service instance to resolve a DNS-SD query and @p"]
    #[doc = " aUnsubscribe to unsubscribe when the query is resolved or timeout."]
    #[doc = ""]
    #[doc = " @note @p aSubscribe and @p aUnsubscribe must be both set or unset."]
    #[doc = ""]
    #[doc = " @param[in] aInstance     The OpenThread instance structure."]
    #[doc = " @param[in] aSubscribe    A pointer to the callback function to subscribe a service or service instance."]
    #[doc = " @param[in] aUnsubscribe  A pointer to the callback function to unsubscribe a service or service instance."]
    #[doc = " @param[in] aContext      A pointer to the application-specific context."]
    #[doc = ""]
    pub fn otDnssdQuerySetCallbacks(
        aInstance: *mut otInstance,
        aSubscribe: otDnssdQuerySubscribeCallback,
        aUnsubscribe: otDnssdQueryUnsubscribeCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function notifies a discovered service instance."]
    #[doc = ""]
    #[doc = " The external query resolver (e.g. Discovery Proxy) should call this function to notify OpenThread core of the"]
    #[doc = " subscribed services or service instances."]
    #[doc = ""]
    #[doc = " @note @p aInstanceInfo must not contain unspecified or link-local or loop-back or multicast IP addresses."]
    #[doc = ""]
    #[doc = " @param[in] aInstance         The OpenThread instance structure."]
    #[doc = " @param[in] aServiceFullName  The null-terminated full service name."]
    #[doc = " @param[in] aInstanceInfo     A pointer to the discovered service instance information."]
    #[doc = ""]
    pub fn otDnssdQueryHandleDiscoveredServiceInstance(
        aInstance: *mut otInstance,
        aServiceFullName: *const ::std::os::raw::c_char,
        aInstanceInfo: *mut otDnssdServiceInstanceInfo,
    );
}
extern "C" {
    #[doc = " This function notifies a discovered host."]
    #[doc = ""]
    #[doc = " The external query resolver (e.g. Discovery Proxy) should call this function to notify OpenThread core of the"]
    #[doc = " subscribed hosts."]
    #[doc = ""]
    #[doc = " @note @p aHostInfo must not contain unspecified or link-local or loop-back or multicast IP addresses."]
    #[doc = ""]
    #[doc = " @param[in] aInstance         The OpenThread instance structure."]
    #[doc = " @param[in] aHostFullName     The null-terminated full host name."]
    #[doc = " @param[in] aHostInfo         A pointer to the discovered service instance information."]
    #[doc = ""]
    pub fn otDnssdQueryHandleDiscoveredHost(
        aInstance: *mut otInstance,
        aHostFullName: *const ::std::os::raw::c_char,
        aHostInfo: *mut otDnssdHostInfo,
    );
}
extern "C" {
    #[doc = " This function acquires the next query in the DNS-SD server."]
    #[doc = ""]
    #[doc = " @param[in] aInstance         The OpenThread instance structure."]
    #[doc = " @param[in] aQuery            The query pointer. Pass NULL to get the first query."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the query or NULL if no more queries."]
    #[doc = ""]
    pub fn otDnssdGetNextQuery(
        aInstance: *mut otInstance,
        aQuery: *const otDnssdQuery,
    ) -> *const otDnssdQuery;
}
extern "C" {
    #[doc = " This function acquires the DNS-SD query type and name for a specific query."]
    #[doc = ""]
    #[doc = " @param[in]   aQuery            The query pointer acquired from `otDnssdGetNextQuery`."]
    #[doc = " @param[out]  aNameOutput       The name output buffer, which should be `OT_DNS_MAX_NAME_SIZE` bytes long."]
    #[doc = ""]
    #[doc = " @returns The DNS-SD query type."]
    #[doc = ""]
    pub fn otDnssdGetQueryTypeAndName(
        aQuery: *const otDnssdQuery,
        aNameOutput: *mut [::std::os::raw::c_char; 255usize],
    ) -> otDnssdQueryType;
}
extern "C" {
    #[doc = " This function returns the counters of the DNS-SD server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the counters of the DNS-SD server."]
    #[doc = ""]
    pub fn otDnssdGetCounters(aInstance: *mut otInstance) -> *const otDnssdCounters;
}
extern "C" {
    #[doc = " Enable or disable forwarding DNS queries to platform DNS upstream API."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnabled   A boolean to enable/disable forwarding DNS queries to upstream."]
    #[doc = ""]
    #[doc = " @sa otPlatDnsStartUpstreamQuery"]
    #[doc = " @sa otPlatDnsCancelUpstreamQuery"]
    #[doc = " @sa otPlatDnsUpstreamQueryDone"]
    #[doc = ""]
    pub fn otDnssdUpstreamQuerySetEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " Returns whether the DNSSD server will forward DNS queries to the platform DNS upstream API."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @retval     TRUE       If the DNSSD server will forward DNS queries."]
    #[doc = " @retval     FALSE      If the DNSSD server will not forward DNS queries."]
    #[doc = ""]
    #[doc = " @sa otDnssdUpstreamQuerySetEnabled"]
    #[doc = ""]
    pub fn otDnssdUpstreamQueryIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " @note This API is deprecated and use of it is discouraged."]
    #[doc = ""]
    pub fn otHeapCAlloc(aCount: usize, aSize: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @note This API is deprecated and use of it is discouraged."]
    #[doc = ""]
    pub fn otHeapFree(aPointer: *mut ::std::os::raw::c_void);
}
#[doc = "< Destination Unreachable"]
pub const OT_ICMP6_TYPE_DST_UNREACH: otIcmp6Type = 1;
#[doc = "< Packet To Big"]
pub const OT_ICMP6_TYPE_PACKET_TO_BIG: otIcmp6Type = 2;
#[doc = "< Time Exceeded"]
pub const OT_ICMP6_TYPE_TIME_EXCEEDED: otIcmp6Type = 3;
#[doc = "< Parameter Problem"]
pub const OT_ICMP6_TYPE_PARAMETER_PROBLEM: otIcmp6Type = 4;
#[doc = "< Echo Request"]
pub const OT_ICMP6_TYPE_ECHO_REQUEST: otIcmp6Type = 128;
#[doc = "< Echo Reply"]
pub const OT_ICMP6_TYPE_ECHO_REPLY: otIcmp6Type = 129;
#[doc = "< Router Solicitation"]
pub const OT_ICMP6_TYPE_ROUTER_SOLICIT: otIcmp6Type = 133;
#[doc = "< Router Advertisement"]
pub const OT_ICMP6_TYPE_ROUTER_ADVERT: otIcmp6Type = 134;
#[doc = "< Neighbor Solicitation"]
pub const OT_ICMP6_TYPE_NEIGHBOR_SOLICIT: otIcmp6Type = 135;
#[doc = "< Neighbor Advertisement"]
pub const OT_ICMP6_TYPE_NEIGHBOR_ADVERT: otIcmp6Type = 136;
#[doc = " ICMPv6 Message Types"]
#[doc = ""]
pub type otIcmp6Type = ::std::os::raw::c_uint;
#[doc = "< Destination Unreachable No Route"]
pub const OT_ICMP6_CODE_DST_UNREACH_NO_ROUTE: otIcmp6Code = 0;
#[doc = "< Fragment Reassembly Time Exceeded"]
pub const OT_ICMP6_CODE_FRAGM_REAS_TIME_EX: otIcmp6Code = 1;
#[doc = " ICMPv6 Message Codes"]
#[doc = ""]
pub type otIcmp6Code = ::std::os::raw::c_uint;
#[doc = " @struct otIcmp6Header"]
#[doc = ""]
#[doc = " This structure represents an ICMPv6 header."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIcmp6Header {
    #[doc = "< Type"]
    pub mType: u8,
    #[doc = "< Code"]
    pub mCode: u8,
    #[doc = "< Checksum"]
    pub mChecksum: u16,
    #[doc = "< Message-specific data"]
    pub mData: otIcmp6Header__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIcmp6Header__bindgen_ty_1 {
    pub m8: [u8; 4usize],
    pub m16: [u16; 2usize],
    pub m32: [u32; 1usize],
}
impl Default for otIcmp6Header__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otIcmp6Header {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This callback allows OpenThread to inform the application of a received ICMPv6 message."]
#[doc = ""]
#[doc = " @param[in]  aContext      A pointer to arbitrary context information."]
#[doc = " @param[in]  aMessage      A pointer to the received message."]
#[doc = " @param[in]  aMessageInfo  A pointer to message information associated with @p aMessage."]
#[doc = " @param[in]  aIcmpHeader   A pointer to the received ICMPv6 header."]
#[doc = ""]
pub type otIcmp6ReceiveCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aIcmpHeader: *const otIcmp6Header,
    ),
>;
#[doc = " This structure implements ICMPv6 message handler."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otIcmp6Handler {
    #[doc = "< The ICMPv6 received callback"]
    pub mReceiveCallback: otIcmp6ReceiveCallback,
    #[doc = "< A pointer to arbitrary context information."]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< A pointer to the next handler in the list."]
    pub mNext: *mut otIcmp6Handler,
}
impl Default for otIcmp6Handler {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< ICMPv6 Echo processing disabled"]
pub const OT_ICMP6_ECHO_HANDLER_DISABLED: otIcmp6EchoMode = 0;
#[doc = "< ICMPv6 Echo processing enabled only for unicast requests only"]
pub const OT_ICMP6_ECHO_HANDLER_UNICAST_ONLY: otIcmp6EchoMode = 1;
#[doc = "< ICMPv6 Echo processing enabled only for multicast requests only"]
pub const OT_ICMP6_ECHO_HANDLER_MULTICAST_ONLY: otIcmp6EchoMode = 2;
#[doc = "< ICMPv6 Echo processing enabled for unicast and multicast requests"]
pub const OT_ICMP6_ECHO_HANDLER_ALL: otIcmp6EchoMode = 3;
#[doc = " ICMPv6 Echo Reply Modes"]
#[doc = ""]
pub type otIcmp6EchoMode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function indicates whether or not ICMPv6 Echo processing is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ICMP6_ECHO_HANDLER_DISABLED        ICMPv6 Echo processing is disabled."]
    #[doc = " @retval OT_ICMP6_ECHO_HANDLER_UNICAST_ONLY    ICMPv6 Echo processing enabled for unicast requests only"]
    #[doc = " @retval OT_ICMP6_ECHO_HANDLER_MULTICAST_ONLY  ICMPv6 Echo processing enabled for multicast requests only"]
    #[doc = " @retval OT_ICMP6_ECHO_HANDLER_ALL             ICMPv6 Echo processing enabled for unicast and multicast requests"]
    #[doc = ""]
    pub fn otIcmp6GetEchoMode(aInstance: *mut otInstance) -> otIcmp6EchoMode;
}
extern "C" {
    #[doc = " This function sets whether or not ICMPv6 Echo processing is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMode     The ICMPv6 Echo processing mode."]
    #[doc = ""]
    pub fn otIcmp6SetEchoMode(aInstance: *mut otInstance, aMode: otIcmp6EchoMode);
}
extern "C" {
    #[doc = " This function registers a handler to provide received ICMPv6 messages."]
    #[doc = ""]
    #[doc = " @note A handler structure @p aHandler has to be stored in persistent (static) memory."]
    #[doc = "       OpenThread does not make a copy of handler structure."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aHandler  A pointer to a handler containing callback that is called when"]
    #[doc = "                       an ICMPv6 message is received."]
    #[doc = ""]
    pub fn otIcmp6RegisterHandler(
        aInstance: *mut otInstance,
        aHandler: *mut otIcmp6Handler,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends an ICMPv6 Echo Request via the Thread interface."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage      A pointer to the message buffer containing the ICMPv6 payload."]
    #[doc = " @param[in]  aMessageInfo  A reference to message information associated with @p aMessage."]
    #[doc = " @param[in]  aIdentifier   An identifier to aid in matching Echo Replies to this Echo Request."]
    #[doc = "                           May be zero."]
    #[doc = ""]
    pub fn otIcmp6SendEchoRequest(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aIdentifier: u16,
    ) -> otError;
}
#[doc = " This function pointer is called if signal jam detection is enabled and a jam is detected."]
#[doc = ""]
#[doc = " @param[in]  aJamState Current jam state (`true` if jam is detected, `false` otherwise)."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otJamDetectionCallback = ::std::option::Option<
    unsafe extern "C" fn(aJamState: bool, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Set the Jam Detection RSSI Threshold (in dBm)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aRssiThreshold  The RSSI threshold."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully set the threshold."]
    #[doc = ""]
    pub fn otJamDetectionSetRssiThreshold(
        aInstance: *mut otInstance,
        aRssiThreshold: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Jam Detection RSSI Threshold (in dBm)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Jam Detection RSSI Threshold."]
    pub fn otJamDetectionGetRssiThreshold(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Set the Jam Detection Detection Window (in seconds)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aWindow              The Jam Detection window (valid range is 1 to 63)"]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully set the window."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The given input parameter not within valid range (1-63)"]
    #[doc = ""]
    pub fn otJamDetectionSetWindow(aInstance: *mut otInstance, aWindow: u8) -> otError;
}
extern "C" {
    #[doc = " Get the Jam Detection Detection Window (in seconds)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Jam Detection Window."]
    #[doc = ""]
    pub fn otJamDetectionGetWindow(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the Jam Detection Busy Period (in seconds)."]
    #[doc = ""]
    #[doc = " The number of aggregate seconds within the detection window where the RSSI must be above"]
    #[doc = " threshold to trigger detection."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aBusyPeriod          The Jam Detection busy period (should be non-zero and"]
    #[doc = "less than or equal to Jam Detection Window)"]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully set the window."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The given input is not within the valid range."]
    #[doc = ""]
    pub fn otJamDetectionSetBusyPeriod(aInstance: *mut otInstance, aBusyPeriod: u8) -> otError;
}
extern "C" {
    #[doc = " Get the Jam Detection Busy Period (in seconds)"]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Jam Detection Busy Period."]
    #[doc = ""]
    pub fn otJamDetectionGetBusyPeriod(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Start the jamming detection."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aCallback            A pointer to a function called to notify of jamming state change."]
    #[doc = " @param[in]  aContext             A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE         Successfully started the jamming detection."]
    #[doc = " @retval OT_ERROR_ALREADY      Jam detection has been started before."]
    #[doc = ""]
    pub fn otJamDetectionStart(
        aInstance: *mut otInstance,
        aCallback: otJamDetectionCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Stop the jamming detection."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE         Successfully stopped the jamming detection."]
    #[doc = " @retval OT_ERROR_ALREADY      Jam detection is already stopped."]
    #[doc = ""]
    pub fn otJamDetectionStop(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Get the Jam Detection Status (enabled/disabled)"]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Jam Detection status (true if enabled, false otherwise)."]
    #[doc = ""]
    pub fn otJamDetectionIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get the Jam Detection State"]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Jam Detection state (`true` jam is detected, `false' otherwise)."]
    #[doc = ""]
    pub fn otJamDetectionGetState(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get the current history bitmap."]
    #[doc = ""]
    #[doc = " This value provides information about current state of jamming detection"]
    #[doc = " module for monitoring/debugging purpose. It returns a 64-bit value where"]
    #[doc = " each bit corresponds to one second interval starting with bit 0 for the"]
    #[doc = " most recent interval and bit 63 for the oldest intervals (63 sec earlier)."]
    #[doc = " The bit is set to 1 if the jamming detection module observed/detected"]
    #[doc = " high signal level during the corresponding one second interval."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The current history bitmap."]
    #[doc = ""]
    pub fn otJamDetectionGetHistoryBitmap(aInstance: *mut otInstance) -> u64;
}
#[doc = " This structure represents link-specific information for messages received from the Thread radio."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otThreadLinkInfo {
    #[doc = "< Source PAN ID"]
    pub mPanId: u16,
    #[doc = "< 802.15.4 Channel"]
    pub mChannel: u8,
    #[doc = "< Received Signal Strength in dBm."]
    pub mRss: i8,
    #[doc = "< Link Quality Indicator for a received message."]
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< The time sync sequence."]
    pub mTimeSyncSeq: u8,
    #[doc = "< The time offset to the Thread network time, in microseconds."]
    pub mNetworkTimeOffset: i64,
    #[doc = "< Radio link type."]
    pub mRadioType: u8,
}
impl otThreadLinkInfo {
    #[inline]
    pub fn mLinkSecurity(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkSecurity(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsDstPanIdBroadcast(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsDstPanIdBroadcast(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mLinkSecurity: bool,
        mIsDstPanIdBroadcast: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mLinkSecurity: u8 = unsafe { ::std::mem::transmute(mLinkSecurity) };
            mLinkSecurity as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsDstPanIdBroadcast: u8 = unsafe { ::std::mem::transmute(mIsDstPanIdBroadcast) };
            mIsDstPanIdBroadcast as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type otMacFilterIterator = u8;
#[doc = "< Address filter is disabled."]
pub const OT_MAC_FILTER_ADDRESS_MODE_DISABLED: otMacFilterAddressMode = 0;
#[doc = "< Allowlist address filter mode is enabled."]
pub const OT_MAC_FILTER_ADDRESS_MODE_ALLOWLIST: otMacFilterAddressMode = 1;
#[doc = "< Denylist address filter mode is enabled."]
pub const OT_MAC_FILTER_ADDRESS_MODE_DENYLIST: otMacFilterAddressMode = 2;
#[doc = " Defines address mode of the mac filter."]
#[doc = ""]
pub type otMacFilterAddressMode = ::std::os::raw::c_uint;
#[doc = " This structure represents a Mac Filter entry."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMacFilterEntry {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Received signal strength"]
    pub mRssIn: i8,
}
#[doc = " This structure represents the MAC layer counters."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMacCounters {
    #[doc = " The total number of unique MAC frame transmission requests."]
    #[doc = ""]
    #[doc = " Note that this counter is incremented for each MAC transmission request only by one,"]
    #[doc = " regardless of the amount of CCA failures, CSMA-CA attempts, or retransmissions."]
    #[doc = ""]
    #[doc = " This increment rule applies to the following counters:"]
    #[doc = "   - @p mTxUnicast"]
    #[doc = "   - @p mTxBroadcast"]
    #[doc = "   - @p mTxAckRequested"]
    #[doc = "   - @p mTxNoAckRequested"]
    #[doc = "   - @p mTxData"]
    #[doc = "   - @p mTxDataPoll"]
    #[doc = "   - @p mTxBeacon"]
    #[doc = "   - @p mTxBeaconRequest"]
    #[doc = "   - @p mTxOther"]
    #[doc = "   - @p mTxErrAbort"]
    #[doc = "   - @p mTxErrBusyChannel"]
    #[doc = ""]
    #[doc = " The following equations are valid:"]
    #[doc = "   - @p mTxTotal = @p mTxUnicast + @p mTxBroadcast"]
    #[doc = "   - @p mTxTotal = @p mTxAckRequested + @p mTxNoAckRequested"]
    #[doc = "   - @p mTxTotal = @p mTxData + @p mTxDataPoll + @p mTxBeacon + @p mTxBeaconRequest + @p mTxOther"]
    #[doc = ""]
    pub mTxTotal: u32,
    #[doc = " The total number of unique unicast MAC frame transmission requests."]
    #[doc = ""]
    pub mTxUnicast: u32,
    #[doc = " The total number of unique broadcast MAC frame transmission requests."]
    #[doc = ""]
    pub mTxBroadcast: u32,
    #[doc = " The total number of unique MAC frame transmission requests with requested acknowledgment."]
    #[doc = ""]
    pub mTxAckRequested: u32,
    #[doc = " The total number of unique MAC frame transmission requests that were acked."]
    #[doc = ""]
    pub mTxAcked: u32,
    #[doc = " The total number of unique MAC frame transmission requests without requested acknowledgment."]
    #[doc = ""]
    pub mTxNoAckRequested: u32,
    #[doc = " The total number of unique MAC Data frame transmission requests."]
    #[doc = ""]
    pub mTxData: u32,
    #[doc = " The total number of unique MAC Data Poll frame transmission requests."]
    #[doc = ""]
    pub mTxDataPoll: u32,
    #[doc = " The total number of unique MAC Beacon frame transmission requests."]
    #[doc = ""]
    pub mTxBeacon: u32,
    #[doc = " The total number of unique MAC Beacon Request frame transmission requests."]
    #[doc = ""]
    pub mTxBeaconRequest: u32,
    #[doc = " The total number of unique other MAC frame transmission requests."]
    #[doc = ""]
    #[doc = " This counter is currently used for counting out-of-band frames."]
    #[doc = ""]
    pub mTxOther: u32,
    #[doc = " The total number of MAC retransmission attempts."]
    #[doc = ""]
    #[doc = " Note that this counter is incremented by one for each retransmission attempt that may be"]
    #[doc = " triggered by lack of acknowledgement, CSMA/CA failure, or other type of transmission error."]
    #[doc = " The @p mTxRetry counter is incremented both for unicast and broadcast MAC frames."]
    #[doc = ""]
    #[doc = " Modify the following configuration parameters to control the amount of retransmissions in the system:"]
    #[doc = ""]
    #[doc = " - OPENTHREAD_CONFIG_MAC_DEFAULT_MAX_FRAME_RETRIES_DIRECT"]
    #[doc = " - OPENTHREAD_CONFIG_MAC_DEFAULT_MAX_FRAME_RETRIES_INDIRECT"]
    #[doc = " - OPENTHREAD_CONFIG_MAC_TX_NUM_BCAST"]
    #[doc = " - OPENTHREAD_CONFIG_MAC_MAX_CSMA_BACKOFFS_DIRECT"]
    #[doc = " - OPENTHREAD_CONFIG_MAC_MAX_CSMA_BACKOFFS_INDIRECT"]
    #[doc = ""]
    #[doc = " Currently, this counter is invalid if the platform's radio driver capability includes"]
    #[doc = " @ref OT_RADIO_CAPS_TRANSMIT_RETRIES."]
    #[doc = ""]
    pub mTxRetry: u32,
    #[doc = " The total number of unique MAC transmission packets that meet maximal retry limit for direct packets."]
    #[doc = ""]
    pub mTxDirectMaxRetryExpiry: u32,
    #[doc = " The total number of unique MAC transmission packets that meet maximal retry limit for indirect packets."]
    #[doc = ""]
    pub mTxIndirectMaxRetryExpiry: u32,
    #[doc = " The total number of CCA failures."]
    #[doc = ""]
    #[doc = " The meaning of this counter can be different and it depends on the platform's radio driver capabilities."]
    #[doc = ""]
    #[doc = " If @ref OT_RADIO_CAPS_CSMA_BACKOFF is enabled, this counter represents the total number of full CSMA/CA"]
    #[doc = " failed attempts and it is incremented by one also for each retransmission (in case of a CSMA/CA fail)."]
    #[doc = ""]
    #[doc = " If @ref OT_RADIO_CAPS_TRANSMIT_RETRIES is enabled, this counter represents the total number of full CSMA/CA"]
    #[doc = " failed attempts and it is incremented by one for each individual data frame request (regardless of the"]
    #[doc = " amount of retransmissions)."]
    #[doc = ""]
    pub mTxErrCca: u32,
    #[doc = " The total number of unique MAC transmission request failures cause by an abort error."]
    #[doc = ""]
    pub mTxErrAbort: u32,
    #[doc = " The total number of unique MAC transmission requests failures caused by a busy channel (a CSMA/CA fail)."]
    #[doc = ""]
    pub mTxErrBusyChannel: u32,
    #[doc = " The total number of received frames."]
    #[doc = ""]
    #[doc = " This counter counts all frames reported by the platform's radio driver, including frames"]
    #[doc = " that were dropped, for example because of an FCS error."]
    #[doc = ""]
    pub mRxTotal: u32,
    #[doc = " The total number of unicast frames received."]
    #[doc = ""]
    pub mRxUnicast: u32,
    #[doc = " The total number of broadcast frames received."]
    #[doc = ""]
    pub mRxBroadcast: u32,
    #[doc = " The total number of MAC Data frames received."]
    #[doc = ""]
    pub mRxData: u32,
    #[doc = " The total number of MAC Data Poll frames received."]
    #[doc = ""]
    pub mRxDataPoll: u32,
    #[doc = " The total number of MAC Beacon frames received."]
    #[doc = ""]
    pub mRxBeacon: u32,
    #[doc = " The total number of MAC Beacon Request frames received."]
    #[doc = ""]
    pub mRxBeaconRequest: u32,
    #[doc = " The total number of other types of frames received."]
    #[doc = ""]
    pub mRxOther: u32,
    #[doc = " The total number of frames dropped by MAC Filter module, for example received from denylisted node."]
    #[doc = ""]
    pub mRxAddressFiltered: u32,
    #[doc = " The total number of frames dropped by destination address check, for example received frame for other node."]
    #[doc = ""]
    pub mRxDestAddrFiltered: u32,
    #[doc = " The total number of frames dropped due to duplication, that is when the frame has been already received."]
    #[doc = ""]
    #[doc = " This counter may be incremented, for example when ACK frame generated by the receiver hasn't reached"]
    #[doc = " transmitter node which performed retransmission."]
    #[doc = ""]
    pub mRxDuplicated: u32,
    #[doc = " The total number of frames dropped because of missing or malformed content."]
    #[doc = ""]
    pub mRxErrNoFrame: u32,
    #[doc = " The total number of frames dropped due to unknown neighbor."]
    #[doc = ""]
    pub mRxErrUnknownNeighbor: u32,
    #[doc = " The total number of frames dropped due to invalid source address."]
    #[doc = ""]
    pub mRxErrInvalidSrcAddr: u32,
    #[doc = " The total number of frames dropped due to security error."]
    #[doc = ""]
    #[doc = " This counter may be incremented, for example when lower than expected Frame Counter is used"]
    #[doc = " to encrypt the frame."]
    #[doc = ""]
    pub mRxErrSec: u32,
    #[doc = " The total number of frames dropped due to invalid FCS."]
    #[doc = ""]
    pub mRxErrFcs: u32,
    #[doc = " The total number of frames dropped due to other error."]
    #[doc = ""]
    pub mRxErrOther: u32,
}
#[doc = " This structure represents a received IEEE 802.15.4 Beacon."]
#[doc = ""]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct otActiveScanResult {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Thread Network Name"]
    pub mNetworkName: otNetworkName,
    #[doc = "< Thread Extended PAN ID"]
    pub mExtendedPanId: otExtendedPanId,
    #[doc = "< Steering Data"]
    pub mSteeringData: otSteeringData,
    #[doc = "< IEEE 802.15.4 PAN ID"]
    pub mPanId: u16,
    #[doc = "< Joiner UDP Port"]
    pub mJoinerUdpPort: u16,
    #[doc = "< IEEE 802.15.4 Channel"]
    pub mChannel: u8,
    #[doc = "< RSSI (dBm)"]
    pub mRssi: i8,
    #[doc = "< LQI"]
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl otActiveScanResult {
    #[inline]
    pub fn mVersion(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mVersion(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsNative(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsNative(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDiscover(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDiscover(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsJoinable(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoinable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mVersion: ::std::os::raw::c_uint,
        mIsNative: bool,
        mDiscover: bool,
        mIsJoinable: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mVersion: u32 = unsafe { ::std::mem::transmute(mVersion) };
            mVersion as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsNative: u8 = unsafe { ::std::mem::transmute(mIsNative) };
            mIsNative as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mDiscover: u8 = unsafe { ::std::mem::transmute(mDiscover) };
            mDiscover as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mIsJoinable: u8 = unsafe { ::std::mem::transmute(mIsJoinable) };
            mIsJoinable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents an energy scan result."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otEnergyScanResult {
    #[doc = "< IEEE 802.15.4 Channel"]
    pub mChannel: u8,
    #[doc = "< The max RSSI (dBm)"]
    pub mMaxRssi: i8,
}
#[doc = " This function pointer is called during an IEEE 802.15.4 Active Scan when an IEEE 802.15.4 Beacon is received or"]
#[doc = " the scan completes."]
#[doc = ""]
#[doc = " @param[in]  aResult   A valid pointer to the beacon information or NULL when the active scan completes."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otHandleActiveScanResult = ::std::option::Option<
    unsafe extern "C" fn(aResult: *mut otActiveScanResult, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function starts an IEEE 802.15.4 Active Scan"]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aScanChannels     A bit vector indicating which channels to scan (e.g. OT_CHANNEL_11_MASK)."]
    #[doc = " @param[in]  aScanDuration     The time in milliseconds to spend scanning each channel."]
    #[doc = " @param[in]  aCallback         A pointer to a function called on receiving a beacon or scan completes."]
    #[doc = " @param[in]  aCallbackContext  A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE  Accepted the Active Scan request."]
    #[doc = " @retval OT_ERROR_BUSY  Already performing an Active Scan."]
    #[doc = ""]
    pub fn otLinkActiveScan(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aScanDuration: u16,
        aCallback: otHandleActiveScanResult,
        aCallbackContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not an IEEE 802.15.4 Active Scan is currently in progress."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns true if an IEEE 802.15.4 Active Scan is in progress, false otherwise."]
    pub fn otLinkIsActiveScanInProgress(aInstance: *mut otInstance) -> bool;
}
#[doc = " This function pointer is called during an IEEE 802.15.4 Energy Scan when the result for a channel is ready or the"]
#[doc = " scan completes."]
#[doc = ""]
#[doc = " @param[in]  aResult   A valid pointer to the energy scan result information or NULL when the energy scan completes."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otHandleEnergyScanResult = ::std::option::Option<
    unsafe extern "C" fn(aResult: *mut otEnergyScanResult, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function starts an IEEE 802.15.4 Energy Scan"]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aScanChannels     A bit vector indicating on which channels to perform energy scan."]
    #[doc = " @param[in]  aScanDuration     The time in milliseconds to spend scanning each channel."]
    #[doc = " @param[in]  aCallback         A pointer to a function called to pass on scan result on indicate scan completion."]
    #[doc = " @param[in]  aCallbackContext  A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE  Accepted the Energy Scan request."]
    #[doc = " @retval OT_ERROR_BUSY  Could not start the energy scan."]
    #[doc = ""]
    pub fn otLinkEnergyScan(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aScanDuration: u16,
        aCallback: otHandleEnergyScanResult,
        aCallbackContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not an IEEE 802.15.4 Energy Scan is currently in progress."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns true if an IEEE 802.15.4 Energy Scan is in progress, false otherwise."]
    #[doc = ""]
    pub fn otLinkIsEnergyScanInProgress(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function enqueues an IEEE 802.15.4 Data Request message for transmission."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully enqueued an IEEE 802.15.4 Data Request message."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Device is not in rx-off-when-idle mode."]
    #[doc = " @retval OT_ERROR_NO_BUFS        Insufficient message buffers available."]
    #[doc = ""]
    pub fn otLinkSendDataRequest(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not an IEEE 802.15.4 MAC is in the transmit state."]
    #[doc = ""]
    #[doc = " MAC module is in the transmit state during CSMA/CA procedure, CCA, Data, Beacon or Data Request frame transmission"]
    #[doc = " and receiving an ACK of a transmitted frame. MAC module is not in the transmit state during transmission of an ACK"]
    #[doc = " frame or a Beacon Request frame."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns true if an IEEE 802.15.4 MAC is in the transmit state, false otherwise."]
    #[doc = ""]
    pub fn otLinkIsInTransmitState(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get the IEEE 802.15.4 channel."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The IEEE 802.15.4 channel."]
    #[doc = ""]
    #[doc = " @sa otLinkSetChannel"]
    #[doc = ""]
    pub fn otLinkGetChannel(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the IEEE 802.15.4 channel"]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled.  A successful call to this function invalidates the"]
    #[doc = " Active and Pending Operational Datasets in non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannel    The IEEE 802.15.4 channel."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE           Successfully set the channel."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS   If @p aChannel is not in the range [11, 26] or is not in the supported channel mask."]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otLinkGetChannel"]
    #[doc = ""]
    pub fn otLinkSetChannel(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
extern "C" {
    #[doc = " Get the supported channel mask of MAC layer."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The supported channel mask as `uint32_t` with bit 0 (lsb) mapping to channel 0, bit 1 to channel 1, so on."]
    #[doc = ""]
    pub fn otLinkGetSupportedChannelMask(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Set the supported channel mask of MAC layer."]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannelMask  The supported channel mask (bit 0 or lsb mapping to channel 0, and so on)."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE           Successfully set the supported channel mask."]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    pub fn otLinkSetSupportedChannelMask(aInstance: *mut otInstance, aChannelMask: u32) -> otError;
}
extern "C" {
    #[doc = " Gets the IEEE 802.15.4 Extended Address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the IEEE 802.15.4 Extended Address."]
    #[doc = ""]
    pub fn otLinkGetExtendedAddress(aInstance: *mut otInstance) -> *const otExtAddress;
}
extern "C" {
    #[doc = " Sets the IEEE 802.15.4 Extended Address."]
    #[doc = ""]
    #[doc = " @note Only succeeds when Thread protocols are disabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the IEEE 802.15.4 Extended Address."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   @p aExtAddress was NULL."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    pub fn otLinkSetExtendedAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the factory-assigned IEEE EUI-64."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance  A pointer to the OpenThread instance."]
    #[doc = " @param[out]  aEui64     A pointer to where the factory-assigned IEEE EUI-64 is placed."]
    #[doc = ""]
    pub fn otLinkGetFactoryAssignedIeeeEui64(aInstance: *mut otInstance, aEui64: *mut otExtAddress);
}
extern "C" {
    #[doc = " Get the IEEE 802.15.4 PAN ID."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The IEEE 802.15.4 PAN ID."]
    #[doc = ""]
    #[doc = " @sa otLinkSetPanId"]
    #[doc = ""]
    pub fn otLinkGetPanId(aInstance: *mut otInstance) -> otPanId;
}
extern "C" {
    #[doc = " Set the IEEE 802.15.4 PAN ID."]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled.  A successful call to this function also invalidates"]
    #[doc = " the Active and Pending Operational Datasets in non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPanId       The IEEE 802.15.4 PAN ID."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the PAN ID."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   If aPanId is not in the range [0, 65534]."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otLinkGetPanId"]
    #[doc = ""]
    pub fn otLinkSetPanId(aInstance: *mut otInstance, aPanId: otPanId) -> otError;
}
extern "C" {
    #[doc = " Get the data poll period of sleepy end device."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  The data poll period of sleepy end device in milliseconds."]
    #[doc = ""]
    #[doc = " @sa otLinkSetPollPeriod"]
    #[doc = ""]
    pub fn otLinkGetPollPeriod(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Set/clear user-specified/external data poll period for sleepy end device."]
    #[doc = ""]
    #[doc = " @note This function updates only poll period of sleepy end device. To update child timeout the function"]
    #[doc = "       `otThreadSetChildTimeout()` shall be called."]
    #[doc = ""]
    #[doc = " @note Minimal non-zero value should be `OPENTHREAD_CONFIG_MAC_MINIMUM_POLL_PERIOD` (10ms)."]
    #[doc = "       Or zero to clear user-specified poll period."]
    #[doc = ""]
    #[doc = " @note User-specified value should be no more than the maximal value 0x3FFFFFF ((1 << 26) - 1) allowed,"]
    #[doc = " otherwise it would be clipped by the maximal value."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPollPeriod  data poll period in milliseconds."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set/cleared user-specified poll period."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   If aPollPeriod is invalid."]
    #[doc = ""]
    #[doc = " @sa otLinkGetPollPeriod"]
    #[doc = ""]
    pub fn otLinkSetPollPeriod(aInstance: *mut otInstance, aPollPeriod: u32) -> otError;
}
extern "C" {
    #[doc = " Get the IEEE 802.15.4 Short Address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the IEEE 802.15.4 Short Address."]
    #[doc = ""]
    pub fn otLinkGetShortAddress(aInstance: *mut otInstance) -> otShortAddress;
}
extern "C" {
    #[doc = " This method returns the maximum number of frame retries during direct transmission."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The maximum number of retries during direct transmission."]
    #[doc = ""]
    pub fn otLinkGetMaxFrameRetriesDirect(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " This method sets the maximum number of frame retries during direct transmission."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance               A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMaxFrameRetriesDirect  The maximum number of retries during direct transmission."]
    #[doc = ""]
    pub fn otLinkSetMaxFrameRetriesDirect(aInstance: *mut otInstance, aMaxFrameRetriesDirect: u8);
}
extern "C" {
    #[doc = " This method returns the maximum number of frame retries during indirect transmission."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The maximum number of retries during indirect transmission."]
    #[doc = ""]
    pub fn otLinkGetMaxFrameRetriesIndirect(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " This method sets the maximum number of frame retries during indirect transmission."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance                 A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMaxFrameRetriesIndirect  The maximum number of retries during indirect transmission."]
    #[doc = ""]
    pub fn otLinkSetMaxFrameRetriesIndirect(
        aInstance: *mut otInstance,
        aMaxFrameRetriesIndirect: u8,
    );
}
extern "C" {
    #[doc = " This function gets the address mode of MAC filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  the address mode."]
    #[doc = ""]
    pub fn otLinkFilterGetAddressMode(aInstance: *mut otInstance) -> otMacFilterAddressMode;
}
extern "C" {
    #[doc = " This function sets the address mode of MAC filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMode      The address mode to set."]
    #[doc = ""]
    pub fn otLinkFilterSetAddressMode(aInstance: *mut otInstance, aMode: otMacFilterAddressMode);
}
extern "C" {
    #[doc = " This method adds an Extended Address to MAC filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress  A pointer to the Extended Address (MUST NOT be NULL)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully added @p aExtAddress to MAC filter."]
    #[doc = " @retval OT_ERROR_NO_BUFS        No available entry exists."]
    #[doc = ""]
    pub fn otLinkFilterAddAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " This method removes an Extended Address from MAC filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " No action is performed if there is no existing entry in Filter matching the given Extended Address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress  A pointer to the Extended Address (MUST NOT be NULL)."]
    #[doc = ""]
    pub fn otLinkFilterRemoveAddress(aInstance: *mut otInstance, aExtAddress: *const otExtAddress);
}
extern "C" {
    #[doc = " This method clears all the Extended Addresses from MAC filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otLinkFilterClearAddresses(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method gets an in-use address filter entry."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator  A pointer to the MAC filter iterator context. To get the first in-use address filter"]
    #[doc = "                            entry, it should be set to OT_MAC_FILTER_ITERATOR_INIT. MUST NOT be NULL."]
    #[doc = " @param[out]     aEntry     A pointer to where the information is placed. MUST NOT be NULL."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved an in-use address filter entry."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No subsequent entry exists."]
    #[doc = ""]
    pub fn otLinkFilterGetNextAddress(
        aInstance: *mut otInstance,
        aIterator: *mut otMacFilterIterator,
        aEntry: *mut otMacFilterEntry,
    ) -> otError;
}
extern "C" {
    #[doc = " This method adds a fixed received signal strength (in dBm) entry for the messages from a given Extended Address in"]
    #[doc = " MAC Filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address. MUST NOT be NULL."]
    #[doc = " @param[in]  aRss         A received signal strength (in dBm)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully added an entry for @p aExtAddress and @p aRss."]
    #[doc = " @retval OT_ERROR_NO_BUFS        No available entry exists."]
    #[doc = ""]
    pub fn otLinkFilterAddRssIn(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
        aRss: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " This method removes a MAC Filter entry for fixed received signal strength setting for a given Extended Address."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " No action is performed if there is no existing entry in Filter matching the given Extended Address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address. MUST NOT be NULL."]
    #[doc = ""]
    pub fn otLinkFilterRemoveRssIn(aInstance: *mut otInstance, aExtAddress: *const otExtAddress);
}
extern "C" {
    #[doc = " This method sets the default received signal strength (in dBm) on MAC Filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " The default RSS value is used for all received frames from addresses for which there is no explicit RSS-IN entry"]
    #[doc = " in the Filter list (added using `otLinkFilterAddRssIn()`)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aRss         The default received signal strength (in dBm) to set."]
    #[doc = ""]
    pub fn otLinkFilterSetDefaultRssIn(aInstance: *mut otInstance, aRss: i8);
}
extern "C" {
    #[doc = " This method clears any previously set default received signal strength (in dBm) on MAC Filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otLinkFilterClearDefaultRssIn(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method clears all the received signal strength entries (including default RSS-in) on MAC Filter."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otLinkFilterClearAllRssIn(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method gets an in-use RssIn filter entry."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator  A pointer to the MAC filter iterator context. MUST NOT be NULL."]
    #[doc = "                            To get the first entry, it should be set to OT_MAC_FILTER_ITERATOR_INIT."]
    #[doc = " @param[out]     aEntry     A pointer to where the information is placed. The last entry would have the extended"]
    #[doc = "                            address as all 0xff to indicate the default received signal strength if it was set."]
    #[doc = "@p aEntry MUST NOT be NULL."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the next entry."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No subsequent entry exists."]
    #[doc = ""]
    pub fn otLinkFilterGetNextRssIn(
        aInstance: *mut otInstance,
        aIterator: *mut otMacFilterIterator,
        aEntry: *mut otMacFilterEntry,
    ) -> otError;
}
extern "C" {
    #[doc = " This function enables/disables IEEE 802.15.4 radio filter mode."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " The radio filter is mainly intended for testing. It can be used to temporarily block all tx/rx on the 802.15.4 radio."]
    #[doc = " When radio filter is enabled, radio is put to sleep instead of receive (to ensure device does not receive any frame"]
    #[doc = " and/or potentially send ack). Also the frame transmission requests return immediately without sending the frame over"]
    #[doc = " the air (return \"no ack\" error if ack is requested, otherwise return success)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in] aFilterEnabled    TRUE to enable radio filter, FALSE to disable"]
    #[doc = ""]
    pub fn otLinkSetRadioFilterEnabled(aInstance: *mut otInstance, aFilterEnabled: bool);
}
extern "C" {
    #[doc = " This function indicates whether the IEEE 802.15.4 radio filter is enabled or not."]
    #[doc = ""]
    #[doc = " This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @retval TRUE   If the radio filter is enabled."]
    #[doc = " @retval FALSE  If the radio filter is disabled."]
    #[doc = ""]
    pub fn otLinkIsRadioFilterEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This method converts received signal strength to link quality."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aRss       The received signal strength value to be converted."]
    #[doc = ""]
    #[doc = " @return Link quality value mapping to @p aRss."]
    #[doc = ""]
    pub fn otLinkConvertRssToLinkQuality(aInstance: *mut otInstance, aRss: i8) -> u8;
}
extern "C" {
    #[doc = " This method converts link quality to typical received signal strength."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aLinkQuality  LinkQuality value, should be in range [0,3]."]
    #[doc = ""]
    #[doc = " @return Typical platform received signal strength mapping to @p aLinkQuality."]
    #[doc = ""]
    pub fn otLinkConvertLinkQualityToRss(aInstance: *mut otInstance, aLinkQuality: u8) -> i8;
}
extern "C" {
    #[doc = " This method gets histogram of retries for a single direct packet until success."]
    #[doc = ""]
    #[doc = " This function is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aNumberOfEntries   A pointer to where the size of returned histogram array is placed."]
    #[doc = ""]
    #[doc = " @returns     A pointer to the histogram of retries (in a form of an array)."]
    #[doc = "              The n-th element indicates that the packet has been sent with n-th retry."]
    pub fn otLinkGetTxDirectRetrySuccessHistogram(
        aInstance: *mut otInstance,
        aNumberOfEntries: *mut u8,
    ) -> *const u32;
}
extern "C" {
    #[doc = " This method gets histogram of retries for a single indirect packet until success."]
    #[doc = ""]
    #[doc = " This function is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aNumberOfEntries   A pointer to where the size of returned histogram array is placed."]
    #[doc = ""]
    #[doc = " @returns     A pointer to the histogram of retries (in a form of an array)."]
    #[doc = "              The n-th element indicates that the packet has been sent with n-th retry."]
    #[doc = ""]
    pub fn otLinkGetTxIndirectRetrySuccessHistogram(
        aInstance: *mut otInstance,
        aNumberOfEntries: *mut u8,
    ) -> *const u32;
}
extern "C" {
    #[doc = " This method clears histogram statistics for direct and indirect transmissions."]
    #[doc = ""]
    #[doc = " This function is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance          A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otLinkResetTxRetrySuccessHistogram(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the MAC layer counters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the MAC layer counters."]
    #[doc = ""]
    pub fn otLinkGetCounters(aInstance: *mut otInstance) -> *const otMacCounters;
}
extern "C" {
    #[doc = " Resets the MAC layer counters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otLinkResetCounters(aInstance: *mut otInstance);
}
#[doc = " This function pointer is called when an IEEE 802.15.4 frame is received."]
#[doc = ""]
#[doc = " @note This callback is called after FCS processing and @p aFrame may not contain the actual FCS that was received."]
#[doc = ""]
#[doc = " @note This callback is called before IEEE 802.15.4 security processing."]
#[doc = ""]
#[doc = " @param[in]  aFrame    A pointer to the received IEEE 802.15.4 frame."]
#[doc = " @param[in]  aIsTx     Whether this frame is transmitted, not received."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otLinkPcapCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aFrame: *const otRadioFrame,
        aIsTx: bool,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function registers a callback to provide received raw IEEE 802.15.4 frames."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPcapCallback     A pointer to a function that is called when receiving an IEEE 802.15.4 link frame or"]
    #[doc = "                               NULL to disable the callback."]
    #[doc = " @param[in]  aCallbackContext  A pointer to application-specific context."]
    #[doc = ""]
    pub fn otLinkSetPcapCallback(
        aInstance: *mut otInstance,
        aPcapCallback: otLinkPcapCallback,
        aCallbackContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function indicates whether or not promiscuous mode is enabled at the link layer."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval true   Promiscuous mode is enabled."]
    #[doc = " @retval false  Promiscuous mode is not enabled."]
    #[doc = ""]
    pub fn otLinkIsPromiscuous(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function enables or disables the link layer promiscuous mode."]
    #[doc = ""]
    #[doc = " @note Promiscuous mode may only be enabled when the Thread interface is disabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPromiscuous  true to enable promiscuous mode, or false otherwise."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully enabled promiscuous mode."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Could not enable promiscuous mode because"]
    #[doc = "                                 the Thread interface is enabled."]
    #[doc = ""]
    pub fn otLinkSetPromiscuous(aInstance: *mut otInstance, aPromiscuous: bool) -> otError;
}
extern "C" {
    #[doc = " This function gets the CSL channel."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The CSL channel."]
    #[doc = ""]
    pub fn otLinkCslGetChannel(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Sets the CSL channel."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChannel       The CSL sample channel. Channel value should be `0` (Set CSL Channel unspecified) or"]
    #[doc = "                            within the range [1, 10] (if 915-MHz supported) and [11, 26] (if 2.4 GHz supported)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the CSL parameters."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   Invalid @p aChannel."]
    #[doc = ""]
    pub fn otLinkCslSetChannel(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
extern "C" {
    #[doc = " This function gets the CSL period."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The CSL period in units of 10 symbols."]
    #[doc = ""]
    pub fn otLinkCslGetPeriod(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the CSL period in units of 10 symbols. Disable CSL by setting this parameter to `0`."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPeriod        The CSL period in units of 10 symbols."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the CSL period."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   Invalid CSL period."]
    #[doc = ""]
    pub fn otLinkCslSetPeriod(aInstance: *mut otInstance, aPeriod: u16) -> otError;
}
extern "C" {
    #[doc = " This function gets the CSL timeout."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The CSL timeout in seconds."]
    #[doc = ""]
    pub fn otLinkCslGetTimeout(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the CSL timeout in seconds."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aTimeout       The CSL timeout in seconds."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the CSL timeout."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   Invalid CSL timeout."]
    #[doc = ""]
    pub fn otLinkCslSetTimeout(aInstance: *mut otInstance, aTimeout: u32) -> otError;
}
extern "C" {
    #[doc = " This function returns the current CCA (Clear Channel Assessment) failure rate."]
    #[doc = ""]
    #[doc = " The rate is maintained over a window of (roughly) last `OPENTHREAD_CONFIG_CCA_FAILURE_RATE_AVERAGING_WINDOW`"]
    #[doc = " frame transmissions."]
    #[doc = ""]
    #[doc = " @returns The CCA failure rate with maximum value `0xffff` corresponding to 100% failure rate."]
    #[doc = ""]
    pub fn otLinkGetCcaFailureRate(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " This function enables or disables the link layer."]
    #[doc = ""]
    #[doc = " @note The link layer may only be enabled / disabled when the Thread Interface is disabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnable       true to enable the link layer, or false otherwise."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully enabled / disabled the link layer."]
    #[doc = " @retval OT_ERROR_INVALID_STATE Could not disable the link layer because"]
    #[doc = "                                the Thread interface is enabled."]
    #[doc = ""]
    pub fn otLinkSetEnabled(aInstance: *mut otInstance, aEnable: bool) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not the link layer is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval true   Link layer is enabled."]
    #[doc = " @retval false  Link layer is not enabled."]
    #[doc = ""]
    pub fn otLinkIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function instructs the device to send an empty IEEE 802.15.4 data frame."]
    #[doc = ""]
    #[doc = " This function is only supported on an Rx-Off-When-Idle device to send an empty data frame to its parent."]
    #[doc = " Note: available only when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully enqueued an empty message."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Device is not in Rx-Off-When-Idle mode."]
    #[doc = " @retval OT_ERROR_NO_BUFS        Insufficient message buffers available."]
    #[doc = ""]
    pub fn otLinkSendEmptyData(aInstance: *mut otInstance) -> otError;
}
#[doc = " This function pointer on receipt of a IEEE 802.15.4 frame."]
#[doc = ""]
#[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
#[doc = " @param[in]  aFrame       A pointer to the received frame or NULL if the receive operation was aborted."]
#[doc = " @param[in]  aError       OT_ERROR_NONE when successfully received a frame."]
#[doc = "                          OT_ERROR_ABORT when reception was aborted and a frame was not received."]
#[doc = ""]
pub type otLinkRawReceiveDone = ::std::option::Option<
    unsafe extern "C" fn(aInstance: *mut otInstance, aFrame: *mut otRadioFrame, aError: otError),
>;
extern "C" {
    #[doc = " This function enables/disables the raw link-layer."]
    #[doc = ""]
    #[doc = " @param[in] aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in] aCallback     A pointer to a function called on receipt of a IEEE 802.15.4 frame. NULL to disable the"]
    #[doc = " raw-link layer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_FAILED          The radio could not be enabled/disabled."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   If the OpenThread IPv6 interface is already enabled."]
    #[doc = " @retval OT_ERROR_NONE            If the enable state was successfully set."]
    #[doc = ""]
    pub fn otLinkRawSetReceiveDone(
        aInstance: *mut otInstance,
        aCallback: otLinkRawReceiveDone,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not the raw link-layer is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance     A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval true     The raw link-layer is enabled."]
    #[doc = " @retval false    The raw link-layer is disabled."]
    #[doc = ""]
    pub fn otLinkRawIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function gets the status of promiscuous mode."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval true     Promiscuous mode is enabled."]
    #[doc = " @retval false    Promiscuous mode is disabled."]
    #[doc = ""]
    pub fn otLinkRawGetPromiscuous(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function enables or disables promiscuous mode."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnable      A value to enable or disable promiscuous mode."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             If successful."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawSetPromiscuous(aInstance: *mut otInstance, aEnable: bool) -> otError;
}
extern "C" {
    #[doc = " Set the Short Address for address filtering."]
    #[doc = ""]
    #[doc = " @param[in] aInstance      A pointer to an OpenThread instance."]
    #[doc = " @param[in] aShortAddress  The IEEE 802.15.4 Short Address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             If successful."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawSetShortAddress(aInstance: *mut otInstance, aShortAddress: u16) -> otError;
}
extern "C" {
    #[doc = " Transition the radio from Receive to Sleep."]
    #[doc = " Turn off the radio."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully transitioned to Sleep."]
    #[doc = " @retval OT_ERROR_BUSY             The radio was transmitting"]
    #[doc = " @retval OT_ERROR_INVALID_STATE    The radio was disabled"]
    #[doc = ""]
    pub fn otLinkRawSleep(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Transitioning the radio from Sleep to Receive."]
    #[doc = " Turn on the radio."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully transitioned to Receive."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    The radio was disabled or transmitting."]
    #[doc = ""]
    pub fn otLinkRawReceive(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " The radio transitions from Transmit to Receive."]
    #[doc = " This method returns a pointer to the transmit buffer."]
    #[doc = ""]
    #[doc = " The caller forms the IEEE 802.15.4 frame in this buffer then calls otLinkRawTransmit()"]
    #[doc = " to request transmission."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the transmit buffer or NULL if the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawGetTransmitBuffer(aInstance: *mut otInstance) -> *mut otRadioFrame;
}
#[doc = " This function pointer on receipt of a IEEE 802.15.4 frame."]
#[doc = ""]
#[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
#[doc = " @param[in]  aFrame           A pointer to the frame that was transmitted."]
#[doc = " @param[in]  aAckFrame        A pointer to the ACK frame."]
#[doc = " @param[in]  aError           OT_ERROR_NONE when the frame was transmitted."]
#[doc = "                              OT_ERROR_NO_ACK when the frame was transmitted but no ACK was received"]
#[doc = "                              OT_ERROR_CHANNEL_ACCESS_FAILURE when the transmission could not take place"]
#[doc = "due to activity on the channel."]
#[doc = "                              OT_ERROR_ABORT when transmission was aborted for other reasons."]
#[doc = ""]
pub type otLinkRawTransmitDone = ::std::option::Option<
    unsafe extern "C" fn(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aAckFrame: *mut otRadioFrame,
        aError: otError,
    ),
>;
extern "C" {
    #[doc = " This method begins the transmit sequence on the radio."]
    #[doc = ""]
    #[doc = " The caller must form the IEEE 802.15.4 frame in the buffer provided by otLinkRawGetTransmitBuffer() before"]
    #[doc = " requesting transmission.  The channel and transmit power are also included in the otRadioFrame structure."]
    #[doc = ""]
    #[doc = " The transmit sequence consists of:"]
    #[doc = " 1. Transitioning the radio to Transmit from Receive."]
    #[doc = " 2. Transmits the PSDU on the given channel and at the given transmit power."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aCallback    A pointer to a function called on completion of the transmission."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully transitioned to Transmit."]
    #[doc = " @retval OT_ERROR_INVALID_STATE The radio was not in the Receive state."]
    #[doc = ""]
    pub fn otLinkRawTransmit(
        aInstance: *mut otInstance,
        aCallback: otLinkRawTransmitDone,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the most recent RSSI measurement."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The RSSI in dBm when it is valid. 127 when RSSI is invalid."]
    #[doc = ""]
    pub fn otLinkRawGetRssi(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Get the radio capabilities."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The radio capability bit vector. The stack enables or disables some functions based on this value."]
    #[doc = ""]
    pub fn otLinkRawGetCaps(aInstance: *mut otInstance) -> otRadioCaps;
}
#[doc = " This function pointer on receipt of a IEEE 802.15.4 frame."]
#[doc = ""]
#[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
#[doc = " @param[in]  aEnergyScanMaxRssi   The maximum RSSI encountered on the scanned channel."]
#[doc = ""]
pub type otLinkRawEnergyScanDone =
    ::std::option::Option<unsafe extern "C" fn(aInstance: *mut otInstance, aEnergyScanMaxRssi: i8)>;
extern "C" {
    #[doc = " This method begins the energy scan sequence on the radio."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aScanChannel     The channel to perform the energy scan on."]
    #[doc = " @param[in]  aScanDuration    The duration, in milliseconds, for the channel to be scanned."]
    #[doc = " @param[in]  aCallback        A pointer to a function called on completion of a scanned channel."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully started scanning the channel."]
    #[doc = " @retval OT_ERROR_BUSY             The radio is performing enery scanning."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  The radio doesn't support energy scanning."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawEnergyScan(
        aInstance: *mut otInstance,
        aScanChannel: u8,
        aScanDuration: u16,
        aCallback: otLinkRawEnergyScanDone,
    ) -> otError;
}
extern "C" {
    #[doc = " Enable/Disable source match for frame pending."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnable      Enable/disable source match for frame pending."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             If successful."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawSrcMatchEnable(aInstance: *mut otInstance, aEnable: bool) -> otError;
}
extern "C" {
    #[doc = " Adding short address to the source match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aShortAddress    The short address to be added."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully added short address to the source match table."]
    #[doc = " @retval OT_ERROR_NO_BUFS          No available entry in the source match table."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawSrcMatchAddShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Adding extended address to the source match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress      The extended address to be added."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully added extended address to the source match table."]
    #[doc = " @retval OT_ERROR_NO_BUFS          No available entry in the source match table."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawSrcMatchAddExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Removing short address to the source match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aShortAddress    The short address to be removed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully removed short address from the source match table."]
    #[doc = " @retval OT_ERROR_NO_ADDRESS       The short address is not in source match table."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawSrcMatchClearShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Removing extended address to the source match table of the radio."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress      The extended address to be removed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully removed the extended address from the source match table."]
    #[doc = " @retval OT_ERROR_NO_ADDRESS       The extended address is not in source match table."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawSrcMatchClearExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Removing all the short addresses from the source match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             If successful."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawSrcMatchClearShortEntries(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Removing all the extended addresses from the source match table."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             If successful."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawSrcMatchClearExtEntries(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Update MAC keys and key index."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aKeyIdMode   The key ID mode."]
    #[doc = " @param[in]   aKeyId       The key index."]
    #[doc = " @param[in]   aPrevKey     The previous MAC key."]
    #[doc = " @param[in]   aCurrKey     The current MAC key."]
    #[doc = " @param[in]   aNextKey     The next MAC key."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             If successful."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawSetMacKey(
        aInstance: *mut otInstance,
        aKeyIdMode: u8,
        aKeyId: u8,
        aPrevKey: *const otMacKey,
        aCurrKey: *const otMacKey,
        aNextKey: *const otMacKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the current MAC frame counter value."]
    #[doc = ""]
    #[doc = " This function always sets the MAC counter to the new given value @p aMacFrameCounter independent of the current"]
    #[doc = " value."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aMacFrameCounter  The MAC frame counter value."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             If successful."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawSetMacFrameCounter(
        aInstance: *mut otInstance,
        aMacFrameCounter: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the current MAC frame counter value only if the new value is larger than the current one."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aMacFrameCounter  The MAC frame counter value."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             If successful."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled."]
    #[doc = ""]
    pub fn otLinkRawSetMacFrameCounterIfLarger(
        aInstance: *mut otInstance,
        aMacFrameCounter: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " Get current platform time (64bits width) of the radio chip."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The current radio time in microseconds."]
    #[doc = ""]
    pub fn otLinkRawGetRadioTime(aInstance: *mut otInstance) -> u64;
}
extern "C" {
    #[doc = " This function returns the current log level."]
    #[doc = ""]
    #[doc = " If dynamic log level feature `OPENTHREAD_CONFIG_LOG_LEVEL_DYNAMIC_ENABLE` is enabled, this function returns the"]
    #[doc = " currently set dynamic log level. Otherwise, this function returns the build-time configured log level."]
    #[doc = ""]
    #[doc = " @returns The log level."]
    #[doc = ""]
    pub fn otLoggingGetLevel() -> otLogLevel;
}
extern "C" {
    #[doc = " This function sets the log level."]
    #[doc = ""]
    #[doc = " @note This function requires `OPENTHREAD_CONFIG_LOG_LEVEL_DYNAMIC_ENABLE=1`."]
    #[doc = ""]
    #[doc = " @param[in]  aLogLevel               The log level."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            Successfully updated log level."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS    Log level value is invalid."]
    #[doc = ""]
    pub fn otLoggingSetLevel(aLogLevel: otLogLevel) -> otError;
}
extern "C" {
    #[doc = " This function emits a log message at critical log level."]
    #[doc = ""]
    #[doc = " This function is intended for use by platform. If `OPENTHREAD_CONFIG_LOG_PLATFORM` is not set or the current log"]
    #[doc = " level is below critical, this function does not emit any log message."]
    #[doc = ""]
    #[doc = " @param[in]  aFormat  The format string."]
    #[doc = " @param[in]  ...      Arguments for the format specification."]
    #[doc = ""]
    pub fn otLogCritPlat(aFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " This function emits a log message at warning log level."]
    #[doc = ""]
    #[doc = " This function is intended for use by platform. If `OPENTHREAD_CONFIG_LOG_PLATFORM` is not set or the current log"]
    #[doc = " level is below warning, this function does not emit any log message."]
    #[doc = ""]
    #[doc = " @param[in]  aFormat  The format string."]
    #[doc = " @param[in]  ...      Arguments for the format specification."]
    #[doc = ""]
    pub fn otLogWarnPlat(aFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " This function emits a log message at note log level."]
    #[doc = ""]
    #[doc = " This function is intended for use by platform. If `OPENTHREAD_CONFIG_LOG_PLATFORM` is not set or the current log"]
    #[doc = " level is below note, this function does not emit any log message."]
    #[doc = ""]
    #[doc = " @param[in]  aFormat  The format string."]
    #[doc = " @param[in]  ...      Arguments for the format specification."]
    #[doc = ""]
    pub fn otLogNotePlat(aFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " This function emits a log message at info log level."]
    #[doc = ""]
    #[doc = " This function is intended for use by platform. If `OPENTHREAD_CONFIG_LOG_PLATFORM` is not set or the current log"]
    #[doc = " level is below info, this function does not emit any log message."]
    #[doc = ""]
    #[doc = " @param[in]  aFormat  The format string."]
    #[doc = " @param[in]  ...      Arguments for the format specification."]
    #[doc = ""]
    pub fn otLogInfoPlat(aFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " This function emits a log message at debug log level."]
    #[doc = ""]
    #[doc = " This function is intended for use by platform. If `OPENTHREAD_CONFIG_LOG_PLATFORM` is not set or the current log"]
    #[doc = " level is below debug, this function does not emit any log message."]
    #[doc = ""]
    #[doc = " @param[in]  aFormat  The format string."]
    #[doc = " @param[in]  ...      Arguments for the format specification."]
    #[doc = ""]
    pub fn otLogDebgPlat(aFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " This function generates a memory dump at critical log level."]
    #[doc = ""]
    #[doc = " If `OPENTHREAD_CONFIG_LOG_PLATFORM` or `OPENTHREAD_CONFIG_LOG_PKT_DUMP` is not set or the current log level is below"]
    #[doc = " critical this function does not emit any log message."]
    #[doc = ""]
    #[doc = " @param[in]  aText         A string that is printed before the bytes."]
    #[doc = " @param[in]  aData         A pointer to the data buffer."]
    #[doc = " @param[in]  aDataLength   Number of bytes in @p aData."]
    #[doc = ""]
    pub fn otDumpCritPlat(
        aText: *const ::std::os::raw::c_char,
        aData: *const ::std::os::raw::c_void,
        aDataLength: u16,
    );
}
extern "C" {
    #[doc = " This function generates a memory dump at warning log level."]
    #[doc = ""]
    #[doc = " If `OPENTHREAD_CONFIG_LOG_PLATFORM` or `OPENTHREAD_CONFIG_LOG_PKT_DUMP` is not set or the current log level is below"]
    #[doc = " warning this function does not emit any log message."]
    #[doc = ""]
    #[doc = " @param[in]  aText         A string that is printed before the bytes."]
    #[doc = " @param[in]  aData         A pointer to the data buffer."]
    #[doc = " @param[in]  aDataLength   Number of bytes in @p aData."]
    #[doc = ""]
    pub fn otDumpWarnPlat(
        aText: *const ::std::os::raw::c_char,
        aData: *const ::std::os::raw::c_void,
        aDataLength: u16,
    );
}
extern "C" {
    #[doc = " This function generates a memory dump at note log level."]
    #[doc = ""]
    #[doc = " If `OPENTHREAD_CONFIG_LOG_PLATFORM` or `OPENTHREAD_CONFIG_LOG_PKT_DUMP` is not set or the current log level is below"]
    #[doc = " note this function does not emit any log message."]
    #[doc = ""]
    #[doc = " @param[in]  aText         A string that is printed before the bytes."]
    #[doc = " @param[in]  aData         A pointer to the data buffer."]
    #[doc = " @param[in]  aDataLength   Number of bytes in @p aData."]
    #[doc = ""]
    pub fn otDumpNotePlat(
        aText: *const ::std::os::raw::c_char,
        aData: *const ::std::os::raw::c_void,
        aDataLength: u16,
    );
}
extern "C" {
    #[doc = " This function generates a memory dump at info log level."]
    #[doc = ""]
    #[doc = " If `OPENTHREAD_CONFIG_LOG_PLATFORM` or `OPENTHREAD_CONFIG_LOG_PKT_DUMP` is not set or the current log level is below"]
    #[doc = " info this function does not emit any log message."]
    #[doc = ""]
    #[doc = " @param[in]  aText         A string that is printed before the bytes."]
    #[doc = " @param[in]  aData         A pointer to the data buffer."]
    #[doc = " @param[in]  aDataLength   Number of bytes in @p aData."]
    #[doc = ""]
    pub fn otDumpInfoPlat(
        aText: *const ::std::os::raw::c_char,
        aData: *const ::std::os::raw::c_void,
        aDataLength: u16,
    );
}
extern "C" {
    #[doc = " This function generates a memory dump at debug log level."]
    #[doc = ""]
    #[doc = " If `OPENTHREAD_CONFIG_LOG_PLATFORM` or `OPENTHREAD_CONFIG_LOG_PKT_DUMP` is not set or the current log level is below"]
    #[doc = " debug this function does not emit any log message."]
    #[doc = ""]
    #[doc = " @param[in]  aText         A string that is printed before the bytes."]
    #[doc = " @param[in]  aData         A pointer to the data buffer."]
    #[doc = " @param[in]  aDataLength   Number of bytes in @p aData."]
    #[doc = ""]
    pub fn otDumpDebgPlat(
        aText: *const ::std::os::raw::c_char,
        aData: *const ::std::os::raw::c_void,
        aDataLength: u16,
    );
}
extern "C" {
    #[doc = " This function emits a log message at a given log level."]
    #[doc = ""]
    #[doc = " This function is intended for use by CLI only. If `OPENTHREAD_CONFIG_LOG_CLI` is not set or the current log"]
    #[doc = " level is below the given log level, this function does not emit any log message."]
    #[doc = ""]
    #[doc = " @param[in]  aLogLevel The log level."]
    #[doc = " @param[in]  aFormat   The format string."]
    #[doc = " @param[in]  ...       Arguments for the format specification."]
    #[doc = ""]
    pub fn otLogCli(aLogLevel: otLogLevel, aFormat: *const ::std::os::raw::c_char, ...);
}
#[doc = " This type represents information associated with a radio link."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otRadioLinkInfo {
    #[doc = "< Preference level of radio link"]
    pub mPreference: u8,
}
#[doc = " This type represents multi radio link information associated with a neighbor."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMultiRadioNeighborInfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Additional info for 15.4 radio link (applicable when supported)."]
    pub mIeee802154Info: otRadioLinkInfo,
    #[doc = "< Additional info for TREL radio link (applicable when supported)."]
    pub mTrelUdp6Info: otRadioLinkInfo,
}
impl otMultiRadioNeighborInfo {
    #[inline]
    pub fn mSupportsIeee802154(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mSupportsIeee802154(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mSupportsTrelUdp6(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mSupportsTrelUdp6(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mSupportsIeee802154: bool,
        mSupportsTrelUdp6: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mSupportsIeee802154: u8 = unsafe { ::std::mem::transmute(mSupportsIeee802154) };
            mSupportsIeee802154 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mSupportsTrelUdp6: u8 = unsafe { ::std::mem::transmute(mSupportsTrelUdp6) };
            mSupportsTrelUdp6 as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " This function gets the multi radio link information associated with a neighbor with a given Extended Address."]
    #[doc = ""]
    #[doc = " This function requires the multi radio link feature to be enabled (please see `config/radio_link.h`)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress    The Extended Address of neighbor."]
    #[doc = " @param[out] aNeighborInfo  A pointer to `otMultiRadioNeighborInfo` to output the neighbor info (on success)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE        Neighbor was found and @p aNeighborInfo was updated successfully."]
    #[doc = " @retval OT_ERROR_NOT_FOUND   Could not find a neighbor with @p aExtAddress."]
    #[doc = ""]
    pub fn otMultiRadioGetNeighborInfo(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
        aNeighborInfo: *mut otMultiRadioNeighborInfo,
    ) -> otError;
}
#[doc = " @struct otIp4Address"]
#[doc = ""]
#[doc = " This structure represents an IPv4 address."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp4Address {
    pub mFields: otIp4Address__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIp4Address__bindgen_ty_1 {
    #[doc = "< 8-bit fields"]
    pub m8: [u8; 4usize],
    #[doc = "< 32-bit representation"]
    pub m32: u32,
}
impl Default for otIp4Address__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otIp4Address {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otIp4Cidr"]
#[doc = ""]
#[doc = " This structure represents an IPv4 CIDR block."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otIp4Cidr {
    pub mAddress: otIp4Address,
    pub mLength: u8,
}
impl Default for otIp4Cidr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Represents the counters for NAT64."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNat64Counters {
    #[doc = "< Number of packets translated from IPv4 to IPv6."]
    pub m4To6Packets: u64,
    #[doc = "< Sum of size of packets translated from IPv4 to IPv6."]
    pub m4To6Bytes: u64,
    #[doc = "< Number of packets translated from IPv6 to IPv4."]
    pub m6To4Packets: u64,
    #[doc = "< Sum of size of packets translated from IPv6 to IPv4."]
    pub m6To4Bytes: u64,
}
#[doc = " Represents the counters for the protocols supported by NAT64."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNat64ProtocolCounters {
    #[doc = "< Counters for sum of all protocols."]
    pub mTotal: otNat64Counters,
    #[doc = "< Counters for ICMP and ICMPv6."]
    pub mIcmp: otNat64Counters,
    #[doc = "< Counters for UDP."]
    pub mUdp: otNat64Counters,
    #[doc = "< Counters for TCP."]
    pub mTcp: otNat64Counters,
}
#[doc = "< Packet drop for unknown reasons."]
pub const OT_NAT64_DROP_REASON_UNKNOWN: otNat64DropReason = 0;
#[doc = "< Packet drop due to failed to parse the datagram."]
pub const OT_NAT64_DROP_REASON_ILLEGAL_PACKET: otNat64DropReason = 1;
#[doc = "< Packet drop due to unsupported IP protocol."]
pub const OT_NAT64_DROP_REASON_UNSUPPORTED_PROTO: otNat64DropReason = 2;
#[doc = "< Packet drop due to no mappings found or mapping pool exhausted."]
pub const OT_NAT64_DROP_REASON_NO_MAPPING: otNat64DropReason = 3;
pub const OT_NAT64_DROP_REASON_COUNT: otNat64DropReason = 4;
#[doc = " Packet drop reasons."]
#[doc = ""]
pub type otNat64DropReason = ::std::os::raw::c_uint;
#[doc = " Represents the counters of dropped packets due to errors when handling NAT64 packets."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNat64ErrorCounters {
    #[doc = "< Errors translating IPv4 packets."]
    pub mCount4To6: [u64; 4usize],
    #[doc = "< Errors translating IPv6 packets."]
    pub mCount6To4: [u64; 4usize],
}
extern "C" {
    #[doc = " Gets NAT64 translator counters."]
    #[doc = ""]
    #[doc = " The counter is counted since the instance initialized."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[out] aCounters A pointer to an `otNat64Counters` where the counters of NAT64 translator will be placed."]
    #[doc = ""]
    pub fn otNat64GetCounters(aInstance: *mut otInstance, aCounters: *mut otNat64ProtocolCounters);
}
extern "C" {
    #[doc = " Gets the NAT64 translator error counters."]
    #[doc = ""]
    #[doc = " The counters are initialized to zero when the OpenThread instance is initialized."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[out] aCounters A pointer to an `otNat64Counters` where the counters of NAT64 translator will be placed."]
    #[doc = ""]
    pub fn otNat64GetErrorCounters(
        aInstance: *mut otInstance,
        aCounters: *mut otNat64ErrorCounters,
    );
}
#[doc = " Represents an address mapping record for NAT64."]
#[doc = ""]
#[doc = " @note The counters will be reset for each mapping session even for the same address pair. Applications can use `mId`"]
#[doc = " to identify different sessions to calculate the packets correctly."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNat64AddressMapping {
    #[doc = "< The unique id for a mapping session."]
    pub mId: u64,
    #[doc = "< The IPv4 address of the mapping."]
    pub mIp4: otIp4Address,
    #[doc = "< The IPv6 address of the mapping."]
    pub mIp6: otIp6Address,
    #[doc = "< Remaining time before expiry in milliseconds."]
    pub mRemainingTimeMs: u32,
    pub mCounters: otNat64ProtocolCounters,
}
impl Default for otNat64AddressMapping {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Used to iterate through NAT64 address mappings."]
#[doc = ""]
#[doc = " The fields in this type are opaque (intended for use by OpenThread core only) and therefore should not be"]
#[doc = " accessed or used by caller."]
#[doc = ""]
#[doc = " Before using an iterator, it MUST be initialized using `otNat64AddressMappingIteratorInit()`."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otNat64AddressMappingIterator {
    pub mPtr: *mut ::std::os::raw::c_void,
}
impl Default for otNat64AddressMappingIterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Initializes an `otNat64AddressMappingIterator`."]
    #[doc = ""]
    #[doc = " An iterator MUST be initialized before it is used."]
    #[doc = ""]
    #[doc = " An iterator can be initialized again to restart from the beginning of the mapping info."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  The OpenThread instance."]
    #[doc = " @param[out] aIterator  A pointer to the iterator to initialize."]
    #[doc = ""]
    pub fn otNat64InitAddressMappingIterator(
        aInstance: *mut otInstance,
        aIterator: *mut otNat64AddressMappingIterator,
    );
}
extern "C" {
    #[doc = " Gets the next AddressMapping info (using an iterator)."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance      A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator      A pointer to the iterator. On success the iterator will be updated to point to next"]
    #[doc = "                                NAT64 address mapping record. To get the first entry the iterator should be set to"]
    #[doc = "                                OT_NAT64_ADDRESS_MAPPING_ITERATOR_INIT."]
    #[doc = " @param[out]     aMapping       A pointer to an `otNat64AddressMapping` where information of next NAT64 address"]
    #[doc = "                                mapping record is placed (on success)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully found the next NAT64 address mapping info (@p aMapping was successfully"]
    #[doc = "                             updated)."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No subsequent NAT64 address mapping info was found."]
    #[doc = ""]
    pub fn otNat64GetNextAddressMapping(
        aInstance: *mut otInstance,
        aIterator: *mut otNat64AddressMappingIterator,
        aMapping: *mut otNat64AddressMapping,
    ) -> otError;
}
#[doc = "< NAT64 is disabled."]
pub const OT_NAT64_STATE_DISABLED: otNat64State = 0;
#[doc = "< NAT64 is enabled, but one or more dependencies of NAT64 are not running."]
pub const OT_NAT64_STATE_NOT_RUNNING: otNat64State = 1;
#[doc = "< NAT64 is enabled, but this BR is not an active NAT64 BR."]
pub const OT_NAT64_STATE_IDLE: otNat64State = 2;
#[doc = "< The BR is publishing a NAT64 prefix and/or translating packets."]
pub const OT_NAT64_STATE_ACTIVE: otNat64State = 3;
#[doc = " States of NAT64."]
#[doc = ""]
pub type otNat64State = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Gets the state of NAT64 translator."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_NAT64_STATE_DISABLED    NAT64 translator is disabled."]
    #[doc = " @retval OT_NAT64_STATE_NOT_RUNNING NAT64 translator is enabled, but the translator is not configured with a valid"]
    #[doc = "                                    NAT64 prefix and a CIDR."]
    #[doc = " @retval OT_NAT64_STATE_ACTIVE      NAT64 translator is enabled, and is translating packets."]
    #[doc = ""]
    pub fn otNat64GetTranslatorState(aInstance: *mut otInstance) -> otNat64State;
}
extern "C" {
    #[doc = " Gets the state of NAT64 prefix manager."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_NAT64_STATE_DISABLED    NAT64 prefix manager is disabled."]
    #[doc = " @retval OT_NAT64_STATE_NOT_RUNNING NAT64 prefix manager is enabled, but is not running (because the routing manager"]
    #[doc = "                                    is not running)."]
    #[doc = " @retval OT_NAT64_STATE_IDLE        NAT64 prefix manager is enabled, but is not publishing a NAT64 prefix. Usually"]
    #[doc = "                                    when there is another border router publishing a NAT64 prefix with higher"]
    #[doc = "                                    priority."]
    #[doc = " @retval OT_NAT64_STATE_ACTIVE      NAT64 prefix manager is enabled, and is publishing NAT64 prefix to the Thread"]
    #[doc = "                                    network."]
    #[doc = ""]
    pub fn otNat64GetPrefixManagerState(aInstance: *mut otInstance) -> otNat64State;
}
extern "C" {
    #[doc = " Enable or disable NAT64 functions."]
    #[doc = ""]
    #[doc = " Note: This includes the NAT64 Translator (when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled) and the NAT64"]
    #[doc = " Prefix Manager (when `OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE` is enabled)."]
    #[doc = ""]
    #[doc = " When `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled, setting disabled to true resets the"]
    #[doc = " mapping table in the translator."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` or `OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE` is"]
    #[doc = " enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnabled   A boolean to enable/disable the NAT64 functions"]
    #[doc = ""]
    #[doc = " @sa otNat64GetTranslatorState"]
    #[doc = " @sa otNat64GetPrefixManagerState"]
    #[doc = ""]
    pub fn otNat64SetEnabled(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " Allocate a new message buffer for sending an IPv4 message to the NAT64 translator."]
    #[doc = ""]
    #[doc = " Message buffers allocated by this function will have 20 bytes (difference between the size of IPv6 headers"]
    #[doc = " and IPv4 header sizes) reserved."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @note If @p aSettings is `NULL`, the link layer security is enabled and the message priority is set to"]
    #[doc = " OT_MESSAGE_PRIORITY_NORMAL by default."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSettings  A pointer to the message settings or NULL to set default settings."]
    #[doc = ""]
    #[doc = " @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid."]
    #[doc = ""]
    #[doc = " @sa otNat64Send"]
    #[doc = ""]
    pub fn otIp4NewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Sets the CIDR used when setting the source address of the outgoing translated IPv4 packets."]
    #[doc = ""]
    #[doc = " This function is available only when OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE is enabled."]
    #[doc = ""]
    #[doc = " @note A valid CIDR must have a non-zero prefix length. The actual addresses pool is limited by the size of the"]
    #[doc = " mapping pool and the number of addresses available in the CIDR block."]
    #[doc = ""]
    #[doc = " @note This function can be called at any time, but the NAT64 translator will be reset and all existing sessions will"]
    #[doc = " be expired when updating the configured CIDR."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in] aCidr      A pointer to an otIp4Cidr for the IPv4 CIDR block for NAT64."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS   The given CIDR is not a valid IPv4 CIDR for NAT64."]
    #[doc = " @retval  OT_ERROR_NONE           Successfully set the CIDR for NAT64."]
    #[doc = ""]
    #[doc = " @sa otBorderRouterSend"]
    #[doc = " @sa otBorderRouterSetReceiveCallback"]
    #[doc = ""]
    pub fn otNat64SetIp4Cidr(aInstance: *mut otInstance, aCidr: *const otIp4Cidr) -> otError;
}
extern "C" {
    #[doc = " Translates an IPv4 datagram to an IPv6 datagram and sends via the Thread interface."]
    #[doc = ""]
    #[doc = " The caller transfers ownership of @p aMessage when making this call. OpenThread will free @p aMessage when"]
    #[doc = " processing is complete, including when a value other than `OT_ERROR_NONE` is returned."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage  A pointer to the message buffer containing the IPv4 datagram."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE                    Successfully processed the message."]
    #[doc = " @retval OT_ERROR_DROP                    Message was well-formed but not fully processed due to packet processing"]
    #[doc = "                                          rules."]
    #[doc = " @retval OT_ERROR_NO_BUFS                 Could not allocate necessary message buffers when processing the datagram."]
    #[doc = " @retval OT_ERROR_NO_ROUTE                No route to host."]
    #[doc = " @retval OT_ERROR_INVALID_SOURCE_ADDRESS  Source address is invalid, e.g. an anycast address or a multicast address."]
    #[doc = " @retval OT_ERROR_PARSE                   Encountered a malformed header when processing the message."]
    #[doc = ""]
    pub fn otNat64Send(aInstance: *mut otInstance, aMessage: *mut otMessage) -> otError;
}
#[doc = " This function pointer is called when an IPv4 datagram (translated by NAT64 translator) is received."]
#[doc = ""]
#[doc = " @param[in]  aMessage  A pointer to the message buffer containing the received IPv6 datagram. This function transfers"]
#[doc = "                       the ownership of the @p aMessage to the receiver of the callback. The message should be"]
#[doc = "                       freed by the receiver of the callback after it is processed."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
pub type otNat64ReceiveIp4Callback = ::std::option::Option<
    unsafe extern "C" fn(aMessage: *mut otMessage, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Registers a callback to provide received IPv4 datagrams."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aCallback         A pointer to a function that is called when an IPv4 datagram is received or"]
    #[doc = "                               NULL to disable the callback."]
    #[doc = " @param[in]  aCallbackContext  A pointer to application-specific context."]
    #[doc = ""]
    pub fn otNat64SetReceiveIp4Callback(
        aInstance: *mut otInstance,
        aCallback: otNat64ReceiveIp4Callback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Gets the IPv4 CIDR configured in the NAT64 translator."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[out] aCidr             A pointer to an otIp4Cidr. Where the CIDR will be filled."]
    #[doc = ""]
    pub fn otNat64GetCidr(aInstance: *mut otInstance, aCidr: *mut otIp4Cidr) -> otError;
}
extern "C" {
    #[doc = " Test if two IPv4 addresses are the same."]
    #[doc = ""]
    #[doc = " @param[in]  aFirst   A pointer to the first IPv4 address to compare."]
    #[doc = " @param[in]  aSecond  A pointer to the second IPv4 address to compare."]
    #[doc = ""]
    #[doc = " @retval TRUE   The two IPv4 addresses are the same."]
    #[doc = " @retval FALSE  The two IPv4 addresses are not the same."]
    #[doc = ""]
    pub fn otIp4IsAddressEqual(aFirst: *const otIp4Address, aSecond: *const otIp4Address) -> bool;
}
extern "C" {
    #[doc = " Set @p aIp4Address by performing NAT64 address translation from @p aIp6Address as specified"]
    #[doc = " in RFC 6052."]
    #[doc = ""]
    #[doc = " The NAT64 @p aPrefixLength MUST be one of the following values: 32, 40, 48, 56, 64, or 96, otherwise the behavior"]
    #[doc = " of this method is undefined."]
    #[doc = ""]
    #[doc = " @param[in]  aPrefixLength  The prefix length to use for IPv4/IPv6 translation."]
    #[doc = " @param[in]  aIp6Address    A pointer to an IPv6 address."]
    #[doc = " @param[out] aIp4Address    A pointer to output the IPv4 address."]
    #[doc = ""]
    pub fn otIp4ExtractFromIp6Address(
        aPrefixLength: u8,
        aIp6Address: *const otIp6Address,
        aIp4Address: *mut otIp4Address,
    );
}
extern "C" {
    #[doc = " Converts the address to a string."]
    #[doc = ""]
    #[doc = " The string format uses quad-dotted notation of four bytes in the address (e.g., \"127.0.0.1\")."]
    #[doc = ""]
    #[doc = " If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be"]
    #[doc = " truncated but the outputted string is always null-terminated."]
    #[doc = ""]
    #[doc = " @param[in]  aAddress  A pointer to an IPv4 address (MUST NOT be NULL)."]
    #[doc = " @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be `nullptr`)."]
    #[doc = " @param[in]  aSize     The size of @p aBuffer (in bytes)."]
    #[doc = ""]
    pub fn otIp4AddressToString(
        aAddress: *const otIp4Address,
        aBuffer: *mut ::std::os::raw::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " Converts the IPv4 CIDR to a string."]
    #[doc = ""]
    #[doc = " The string format uses quad-dotted notation of four bytes in the address with the length of prefix (e.g.,"]
    #[doc = " \"127.0.0.1/32\")."]
    #[doc = ""]
    #[doc = " If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be"]
    #[doc = " truncated but the outputted string is always null-terminated."]
    #[doc = ""]
    #[doc = " @param[in]  aCidr     A pointer to an IPv4 CIDR (MUST NOT be NULL)."]
    #[doc = " @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be `nullptr`)."]
    #[doc = " @param[in]  aSize     The size of @p aBuffer (in bytes)."]
    #[doc = ""]
    pub fn otIp4CidrToString(
        aCidr: *const otIp4Cidr,
        aBuffer: *mut ::std::os::raw::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " Converts a human-readable IPv4 address string into a binary representation."]
    #[doc = ""]
    #[doc = " @param[in]   aString   A pointer to a NULL-terminated string."]
    #[doc = " @param[out]  aAddress  A pointer to an IPv4 address."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully parsed the string."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  Failed to parse the string."]
    #[doc = ""]
    pub fn otIp4AddressFromString(
        aString: *const ::std::os::raw::c_char,
        aAddress: *mut otIp4Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the IPv6 address by performing NAT64 address translation from the preferred NAT64 prefix and the given IPv4"]
    #[doc = " address as specified in RFC 6052."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aIp4Address  A pointer to the IPv4 address to translate to IPv6."]
    #[doc = " @param[out]  aIp6Address  A pointer to the synthesized IPv6 address."]
    #[doc = ""]
    #[doc = " @returns  OT_ERROR_NONE           Successfully synthesized the IPv6 address from NAT64 prefix and IPv4 address."]
    #[doc = " @returns  OT_ERROR_INVALID_STATE  No valid NAT64 prefix in the network data."]
    #[doc = ""]
    pub fn otNat64SynthesizeIp6Address(
        aInstance: *mut otInstance,
        aIp4Address: *const otIp4Address,
        aIp6Address: *mut otIp6Address,
    ) -> otError;
}
#[doc = " This function pointer is called to send HDLC encoded NCP data."]
#[doc = ""]
#[doc = " @param[in]  aBuf        A pointer to a buffer with an output."]
#[doc = " @param[in]  aBufLength  A length of the output data stored in the buffer."]
#[doc = ""]
#[doc = " @returns                Number of bytes processed by the callback."]
#[doc = ""]
pub type otNcpHdlcSendCallback = ::std::option::Option<
    unsafe extern "C" fn(aBuf: *const u8, aBufLength: u16) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " This function is called after NCP send finished."]
    #[doc = ""]
    pub fn otNcpHdlcSendDone();
}
extern "C" {
    #[doc = " This function is called after HDLC encoded NCP data received."]
    #[doc = ""]
    #[doc = " @param[in]  aBuf        A pointer to a buffer."]
    #[doc = " @param[in]  aBufLength  The length of the data stored in the buffer."]
    #[doc = ""]
    pub fn otNcpHdlcReceive(aBuf: *const u8, aBufLength: u16);
}
extern "C" {
    #[doc = " Initialize the NCP based on HDLC framing."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        The OpenThread instance structure."]
    #[doc = " @param[in]  aSendCallback    The function pointer used to send NCP data."]
    #[doc = ""]
    pub fn otNcpHdlcInit(aInstance: *mut otInstance, aSendCallback: otNcpHdlcSendCallback);
}
extern "C" {
    #[doc = " Initialize the NCP based on SPI framing."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  The OpenThread instance structure."]
    #[doc = ""]
    pub fn otNcpSpiInit(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " @brief Send data to the host via a specific stream."]
    #[doc = ""]
    #[doc = " This function attempts to send the given data to the host"]
    #[doc = " using the given aStreamId. This is useful for reporting"]
    #[doc = " error messages, implementing debug/diagnostic consoles,"]
    #[doc = " and potentially other types of datastreams."]
    #[doc = ""]
    #[doc = " The write either is accepted in its entirety or rejected."]
    #[doc = " Partial writes are not attempted."]
    #[doc = ""]
    #[doc = " @param[in]  aStreamId  A numeric identifier for the stream to write to."]
    #[doc = "                        If set to '0', will default to the debug stream."]
    #[doc = " @param[in]  aDataPtr   A pointer to the data to send on the stream."]
    #[doc = "                        If aDataLen is non-zero, this param MUST NOT be NULL."]
    #[doc = " @param[in]  aDataLen   The number of bytes of data from aDataPtr to send."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE         The data was queued for delivery to the host."]
    #[doc = " @retval OT_ERROR_BUSY         There are not enough resources to complete this"]
    #[doc = "                               request. This is usually a temporary condition."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS The given aStreamId was invalid."]
    pub fn otNcpStreamWrite(
        aStreamId: ::std::os::raw::c_int,
        aDataPtr: *const u8,
        aDataLen: ::std::os::raw::c_int,
    ) -> otError;
}
extern "C" {
    #[doc = " Writes OpenThread Log using `otNcpStreamWrite`."]
    #[doc = ""]
    #[doc = " @param[in]  aLogLevel   The log level."]
    #[doc = " @param[in]  aLogRegion  The log region."]
    #[doc = " @param[in]  aFormat     A pointer to the format string."]
    #[doc = " @param[in]  aArgs       va_list matching aFormat."]
    pub fn otNcpPlatLogv(
        aLogLevel: otLogLevel,
        aLogRegion: otLogRegion,
        aFormat: *const ::std::os::raw::c_char,
        aArgs: *mut __va_list_tag,
    );
}
#[doc = " Defines delegate (function pointer) type to control behavior of peek/poke operation."]
#[doc = ""]
#[doc = " This delegate function is called to decide whether to allow peek or poke of a specific memory region. It is used"]
#[doc = " if NCP support for peek/poke commands is enabled."]
#[doc = ""]
#[doc = " @param[in] aAddress    Start address of memory region."]
#[doc = " @param[in] aCount      Number of bytes to peek or poke."]
#[doc = ""]
#[doc = " @returns  TRUE to allow peek/poke of the given memory region, FALSE otherwise."]
#[doc = ""]
pub type otNcpDelegateAllowPeekPoke =
    ::std::option::Option<unsafe extern "C" fn(aAddress: u32, aCount: u16) -> bool>;
extern "C" {
    #[doc = " This method registers peek/poke delegate functions with NCP module."]
    #[doc = ""]
    #[doc = " The delegate functions are called by NCP module to decide whether to allow peek or poke of a specific memory region."]
    #[doc = " If the delegate pointer is set to NULL, it allows peek/poke operation for any address."]
    #[doc = ""]
    #[doc = " @param[in] aAllowPeekDelegate      Delegate function pointer for peek operation."]
    #[doc = " @param[in] aAllowPokeDelegate      Delegate function pointer for poke operation."]
    #[doc = ""]
    pub fn otNcpRegisterPeekPokeDelagates(
        aAllowPeekDelegate: otNcpDelegateAllowPeekPoke,
        aAllowPokeDelegate: otNcpDelegateAllowPeekPoke,
    );
}
#[doc = "< The Thread stack is disabled."]
pub const OT_DEVICE_ROLE_DISABLED: otDeviceRole = 0;
#[doc = "< Not currently participating in a Thread network/partition."]
pub const OT_DEVICE_ROLE_DETACHED: otDeviceRole = 1;
#[doc = "< The Thread Child role."]
pub const OT_DEVICE_ROLE_CHILD: otDeviceRole = 2;
#[doc = "< The Thread Router role."]
pub const OT_DEVICE_ROLE_ROUTER: otDeviceRole = 3;
#[doc = "< The Thread Leader role."]
pub const OT_DEVICE_ROLE_LEADER: otDeviceRole = 4;
#[doc = " Represents a Thread device role."]
#[doc = ""]
pub type otDeviceRole = ::std::os::raw::c_uint;
#[doc = " This structure represents an MLE Link Mode configuration."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otLinkModeConfig {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otLinkModeConfig {
    #[inline]
    pub fn mRxOnWhenIdle(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRxOnWhenIdle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDeviceType(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDeviceType(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNetworkData(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNetworkData(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mRxOnWhenIdle: bool,
        mDeviceType: bool,
        mNetworkData: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mRxOnWhenIdle: u8 = unsafe { ::std::mem::transmute(mRxOnWhenIdle) };
            mRxOnWhenIdle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mDeviceType: u8 = unsafe { ::std::mem::transmute(mDeviceType) };
            mDeviceType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mNetworkData: u8 = unsafe { ::std::mem::transmute(mNetworkData) };
            mNetworkData as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure holds diagnostic information for a neighboring Thread node"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNeighborInfo {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Time last heard"]
    pub mAge: u32,
    #[doc = "< RLOC16"]
    pub mRloc16: u16,
    #[doc = "< Link Frame Counter"]
    pub mLinkFrameCounter: u32,
    #[doc = "< MLE Frame Counter"]
    pub mMleFrameCounter: u32,
    #[doc = "< Link Quality In"]
    pub mLinkQualityIn: u8,
    #[doc = "< Average RSSI"]
    pub mAverageRssi: i8,
    #[doc = "< Last observed RSSI"]
    pub mLastRssi: i8,
    #[doc = "< Link Margin"]
    pub mLinkMargin: u8,
    #[doc = "< Frame error rate (0xffff->100%). Requires error tracking feature."]
    pub mFrameErrorRate: u16,
    #[doc = "< (IPv6) msg error rate (0xffff->100%). Requires error tracking feature."]
    pub mMessageErrorRate: u16,
    #[doc = "< Thread version of the neighbor"]
    pub mVersion: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl otNeighborInfo {
    #[inline]
    pub fn mRxOnWhenIdle(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRxOnWhenIdle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mFullThreadDevice(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullThreadDevice(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mFullNetworkData(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullNetworkData(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsChild(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsChild(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mRxOnWhenIdle: bool,
        mFullThreadDevice: bool,
        mFullNetworkData: bool,
        mIsChild: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mRxOnWhenIdle: u8 = unsafe { ::std::mem::transmute(mRxOnWhenIdle) };
            mRxOnWhenIdle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mFullThreadDevice: u8 = unsafe { ::std::mem::transmute(mFullThreadDevice) };
            mFullThreadDevice as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mFullNetworkData: u8 = unsafe { ::std::mem::transmute(mFullNetworkData) };
            mFullNetworkData as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsChild: u8 = unsafe { ::std::mem::transmute(mIsChild) };
            mIsChild as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type otNeighborInfoIterator = i16;
#[doc = " This structure represents the Thread Leader Data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otLeaderData {
    #[doc = "< Partition ID"]
    pub mPartitionId: u32,
    #[doc = "< Leader Weight"]
    pub mWeighting: u8,
    #[doc = "< Full Network Data Version"]
    pub mDataVersion: u8,
    #[doc = "< Stable Network Data Version"]
    pub mStableDataVersion: u8,
    #[doc = "< Leader Router ID"]
    pub mLeaderRouterId: u8,
}
#[doc = " This structure holds diagnostic information for a Thread Router"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otRouterInfo {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< RLOC16"]
    pub mRloc16: u16,
    #[doc = "< Router ID"]
    pub mRouterId: u8,
    #[doc = "< Next hop to router"]
    pub mNextHop: u8,
    #[doc = "< Path cost to router"]
    pub mPathCost: u8,
    #[doc = "< Link Quality In"]
    pub mLinkQualityIn: u8,
    #[doc = "< Link Quality Out"]
    pub mLinkQualityOut: u8,
    #[doc = "< Time last heard"]
    pub mAge: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Thread version"]
    pub mVersion: u8,
    #[doc = "< CSL clock accuracy, in ± ppm"]
    pub mCslClockAccuracy: u8,
    #[doc = "< CSL uncertainty, in ±10 us"]
    pub mCslUncertainty: u8,
}
impl otRouterInfo {
    #[inline]
    pub fn mAllocated(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAllocated(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mLinkEstablished(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkEstablished(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mAllocated: bool,
        mLinkEstablished: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mAllocated: u8 = unsafe { ::std::mem::transmute(mAllocated) };
            mAllocated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mLinkEstablished: u8 = unsafe { ::std::mem::transmute(mLinkEstablished) };
            mLinkEstablished as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents the IP level counters."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otIpCounters {
    #[doc = "< The number of IPv6 packets successfully transmitted."]
    pub mTxSuccess: u32,
    #[doc = "< The number of IPv6 packets successfully received."]
    pub mRxSuccess: u32,
    #[doc = "< The number of IPv6 packets failed to transmit."]
    pub mTxFailure: u32,
    #[doc = "< The number of IPv6 packets failed to receive."]
    pub mRxFailure: u32,
}
#[doc = " This structure represents the Thread MLE counters."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMleCounters {
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_DISABLED role."]
    pub mDisabledRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_DETACHED role."]
    pub mDetachedRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_CHILD role."]
    pub mChildRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_ROUTER role."]
    pub mRouterRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_LEADER role."]
    pub mLeaderRole: u16,
    #[doc = "< Number of attach attempts while device was detached."]
    pub mAttachAttempts: u16,
    #[doc = "< Number of changes to partition ID."]
    pub mPartitionIdChanges: u16,
    #[doc = "< Number of attempts to attach to a better partition."]
    pub mBetterPartitionAttachAttempts: u16,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_DISABLED role."]
    pub mDisabledTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_DETACHED role."]
    pub mDetachedTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_CHILD role."]
    pub mChildTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_ROUTER role."]
    pub mRouterTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_LEADER role."]
    pub mLeaderTime: u64,
    #[doc = "< Number of milliseconds tracked by previous counters."]
    pub mTrackedTime: u64,
    #[doc = " Number of times device changed its parent."]
    #[doc = ""]
    #[doc = " A parent change can happen if device detaches from its current parent and attaches to a different one, or even"]
    #[doc = " while device is attached when the periodic parent search feature is enabled  (please see option"]
    #[doc = " OPENTHREAD_CONFIG_PARENT_SEARCH_ENABLE)."]
    #[doc = ""]
    pub mParentChanges: u16,
}
#[doc = " This structure represents the MLE Parent Response data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otThreadParentResponseInfo {
    #[doc = "< IEEE 802.15.4 Extended Address of the Parent"]
    pub mExtAddr: otExtAddress,
    #[doc = "< Short address of the Parent"]
    pub mRloc16: u16,
    #[doc = "< Rssi of the Parent"]
    pub mRssi: i8,
    #[doc = "< Parent priority"]
    pub mPriority: i8,
    #[doc = "< Parent Link Quality 3"]
    pub mLinkQuality3: u8,
    #[doc = "< Parent Link Quality 2"]
    pub mLinkQuality2: u8,
    #[doc = "< Parent Link Quality 1"]
    pub mLinkQuality1: u8,
    #[doc = "< Is the node receiving parent response attached"]
    pub mIsAttached: bool,
}
#[doc = " This callback informs the application that the detaching process has finished."]
#[doc = ""]
#[doc = " @param[in] aContext A pointer to application-specific context."]
#[doc = ""]
pub type otDetachGracefullyCallback =
    ::std::option::Option<unsafe extern "C" fn(aContext: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " This function starts Thread protocol operation."]
    #[doc = ""]
    #[doc = " The interface must be up when calling this function."]
    #[doc = ""]
    #[doc = " Calling this function with @p aEnabled set to FALSE stops any ongoing processes of detaching started by"]
    #[doc = " otThreadDetachGracefully(). Its callback will be called."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in] aEnabled  TRUE if Thread is enabled, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully started Thread protocol operation."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  The network interface was not not up."]
    #[doc = ""]
    pub fn otThreadSetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " This function gets the Thread protocol version."]
    #[doc = ""]
    #[doc = " @returns the Thread protocol version."]
    #[doc = ""]
    pub fn otThreadGetVersion() -> u16;
}
extern "C" {
    #[doc = " This function indicates whether a node is the only router on the network."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE   It is the only router in the network."]
    #[doc = " @retval FALSE  It is a child or is not a single router in the network."]
    #[doc = ""]
    pub fn otThreadIsSingleton(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function starts a Thread Discovery scan."]
    #[doc = ""]
    #[doc = " @note A successful call to this function enables the rx-on-when-idle mode for the entire scan procedure."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance              A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aScanChannels          A bit vector indicating which channels to scan (e.g. OT_CHANNEL_11_MASK)."]
    #[doc = " @param[in]  aPanId                 The PAN ID filter (set to Broadcast PAN to disable filter)."]
    #[doc = " @param[in]  aJoiner                Value of the Joiner Flag in the Discovery Request TLV."]
    #[doc = " @param[in]  aEnableEui64Filtering  TRUE to filter responses on EUI-64, FALSE otherwise."]
    #[doc = " @param[in]  aCallback              A pointer to a function called on receiving an MLE Discovery Response or"]
    #[doc = "                                    scan completes."]
    #[doc = " @param[in]  aCallbackContext       A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully started a Thread Discovery Scan."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  The IPv6 interface is not enabled (netif is not up)."]
    #[doc = " @retval OT_ERROR_NO_BUFS        Could not allocate message for Discovery Request."]
    #[doc = " @retval OT_ERROR_BUSY           Thread Discovery Scan is already in progress."]
    #[doc = ""]
    pub fn otThreadDiscover(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aPanId: u16,
        aJoiner: bool,
        aEnableEui64Filtering: bool,
        aCallback: otHandleActiveScanResult,
        aCallbackContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function determines if an MLE Thread Discovery is currently in progress."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otThreadIsDiscoverInProgress(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This method sets the Thread Joiner Advertisement when discovering Thread network."]
    #[doc = ""]
    #[doc = " Thread Joiner Advertisement is used to allow a Joiner to advertise its own application-specific information"]
    #[doc = " (such as Vendor ID, Product ID, Discriminator, etc.) via a newly-proposed Joiner Advertisement TLV,"]
    #[doc = " and to make this information available to Commissioners or Commissioner Candidates without human interaction."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aOui             The Vendor IEEE OUI value that will be included in the Joiner Advertisement. Only the"]
    #[doc = "                              least significant 3 bytes will be used, and the most significant byte will be ignored."]
    #[doc = " @param[in]  aAdvData         A pointer to the AdvData that will be included in the Joiner Advertisement."]
    #[doc = " @param[in]  aAdvDataLength   The length of AdvData in bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE         Successfully set Joiner Advertisement."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS Invalid AdvData."]
    #[doc = ""]
    pub fn otThreadSetJoinerAdvertisement(
        aInstance: *mut otInstance,
        aOui: u32,
        aAdvData: *const u8,
        aAdvDataLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread Child Timeout (in seconds) used when operating in the Child role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Thread Child Timeout value in seconds."]
    #[doc = ""]
    #[doc = " @sa otThreadSetChildTimeout"]
    #[doc = ""]
    pub fn otThreadGetChildTimeout(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the Thread Child Timeout (in seconds) used when operating in the Child role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aTimeout  The timeout value in seconds."]
    #[doc = ""]
    #[doc = " @sa otThreadGetChildTimeout"]
    #[doc = ""]
    pub fn otThreadSetChildTimeout(aInstance: *mut otInstance, aTimeout: u32);
}
extern "C" {
    #[doc = " Gets the IEEE 802.15.4 Extended PAN ID."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the IEEE 802.15.4 Extended PAN ID."]
    #[doc = ""]
    #[doc = " @sa otThreadSetExtendedPanId"]
    #[doc = ""]
    pub fn otThreadGetExtendedPanId(aInstance: *mut otInstance) -> *const otExtendedPanId;
}
extern "C" {
    #[doc = " Sets the IEEE 802.15.4 Extended PAN ID."]
    #[doc = ""]
    #[doc = " @note Can only be called while Thread protocols are disabled. A successful"]
    #[doc = " call to this function invalidates the Active and Pending Operational Datasets in"]
    #[doc = " non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtendedPanId  A pointer to the IEEE 802.15.4 Extended PAN ID."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the Extended PAN ID."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otThreadGetExtendedPanId"]
    #[doc = ""]
    pub fn otThreadSetExtendedPanId(
        aInstance: *mut otInstance,
        aExtendedPanId: *const otExtendedPanId,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns a pointer to the Leader's RLOC."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aLeaderRloc  A pointer to the Leader's RLOC."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          The Leader's RLOC was successfully written to @p aLeaderRloc."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aLeaderRloc was NULL."]
    #[doc = " @retval OT_ERROR_DETACHED      Not currently attached to a Thread Partition."]
    #[doc = ""]
    pub fn otThreadGetLeaderRloc(
        aInstance: *mut otInstance,
        aLeaderRloc: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the MLE Link Mode configuration."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The MLE Link Mode configuration."]
    #[doc = ""]
    #[doc = " @sa otThreadSetLinkMode"]
    #[doc = ""]
    pub fn otThreadGetLinkMode(aInstance: *mut otInstance) -> otLinkModeConfig;
}
extern "C" {
    #[doc = " Set the MLE Link Mode configuration."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aConfig   A pointer to the Link Mode configuration."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE  Successfully set the MLE Link Mode configuration."]
    #[doc = ""]
    #[doc = " @sa otThreadGetLinkMode"]
    #[doc = ""]
    pub fn otThreadSetLinkMode(aInstance: *mut otInstance, aConfig: otLinkModeConfig) -> otError;
}
extern "C" {
    #[doc = " Get the Thread Network Key."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aNetworkKey   A pointer to an `otNetworkkey` to return the Thread Network Key."]
    #[doc = ""]
    #[doc = " @sa otThreadSetNetworkKey"]
    #[doc = ""]
    pub fn otThreadGetNetworkKey(aInstance: *mut otInstance, aNetworkKey: *mut otNetworkKey);
}
extern "C" {
    #[doc = " Get the `otNetworkKeyRef` for Thread Network Key."]
    #[doc = ""]
    #[doc = " This function requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance   A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns Reference to the Thread Network Key stored in memory."]
    #[doc = ""]
    #[doc = " @sa otThreadSetNetworkKeyRef"]
    #[doc = ""]
    pub fn otThreadGetNetworkKeyRef(aInstance: *mut otInstance) -> otNetworkKeyRef;
}
extern "C" {
    #[doc = " Set the Thread Network Key."]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled.  A successful"]
    #[doc = " call to this function invalidates the Active and Pending Operational Datasets in"]
    #[doc = " non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aKey        A pointer to a buffer containing the Thread Network Key."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            Successfully set the Thread Network Key."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otThreadGetNetworkKey"]
    #[doc = ""]
    pub fn otThreadSetNetworkKey(aInstance: *mut otInstance, aKey: *const otNetworkKey) -> otError;
}
extern "C" {
    #[doc = " Set the Thread Network Key as a `otNetworkKeyRef`."]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled.  A successful"]
    #[doc = " call to this function invalidates the Active and Pending Operational Datasets in"]
    #[doc = " non-volatile memory."]
    #[doc = ""]
    #[doc = " This function requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aKeyRef     Reference to the Thread Network Key."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            Successfully set the Thread Network Key."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otThreadGetNetworkKeyRef"]
    #[doc = ""]
    pub fn otThreadSetNetworkKeyRef(
        aInstance: *mut otInstance,
        aKeyRef: otNetworkKeyRef,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread Routing Locator (RLOC) address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Thread Routing Locator (RLOC) address."]
    #[doc = ""]
    pub fn otThreadGetRloc(aInstance: *mut otInstance) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Gets the Mesh Local EID address."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Mesh Local EID address."]
    #[doc = ""]
    pub fn otThreadGetMeshLocalEid(aInstance: *mut otInstance) -> *const otIp6Address;
}
extern "C" {
    #[doc = " This function returns a pointer to the Mesh Local Prefix."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Mesh Local Prefix."]
    #[doc = ""]
    pub fn otThreadGetMeshLocalPrefix(aInstance: *mut otInstance) -> *const otMeshLocalPrefix;
}
extern "C" {
    #[doc = " This function sets the Mesh Local Prefix."]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled.  A successful"]
    #[doc = " call to this function invalidates the Active and Pending Operational Datasets in"]
    #[doc = " non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMeshLocalPrefix  A pointer to the Mesh Local Prefix."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the Mesh Local Prefix."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    pub fn otThreadSetMeshLocalPrefix(
        aInstance: *mut otInstance,
        aMeshLocalPrefix: *const otMeshLocalPrefix,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread link-local IPv6 address."]
    #[doc = ""]
    #[doc = " The Thread link local address is derived using IEEE802.15.4 Extended Address as Interface Identifier."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to Thread link-local IPv6 address."]
    #[doc = ""]
    pub fn otThreadGetLinkLocalIp6Address(aInstance: *mut otInstance) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Gets the Thread Link-Local All Thread Nodes multicast address."]
    #[doc = ""]
    #[doc = " The address is a link-local Unicast Prefix-Based Multicast Address [RFC 3306], with:"]
    #[doc = "   - flgs set to 3 (P = 1 and T = 1)"]
    #[doc = "   - scop set to 2"]
    #[doc = "   - plen set to 64"]
    #[doc = "   - network prefix set to the Mesh Local Prefix"]
    #[doc = "   - group ID set to 1"]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to Thread Link-Local All Thread Nodes multicast address."]
    #[doc = ""]
    pub fn otThreadGetLinkLocalAllThreadNodesMulticastAddress(
        aInstance: *mut otInstance,
    ) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Gets the Thread Realm-Local All Thread Nodes multicast address."]
    #[doc = ""]
    #[doc = " The address is a realm-local Unicast Prefix-Based Multicast Address [RFC 3306], with:"]
    #[doc = "   - flgs set to 3 (P = 1 and T = 1)"]
    #[doc = "   - scop set to 3"]
    #[doc = "   - plen set to 64"]
    #[doc = "   - network prefix set to the Mesh Local Prefix"]
    #[doc = "   - group ID set to 1"]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to Thread Realm-Local All Thread Nodes multicast address."]
    #[doc = ""]
    pub fn otThreadGetRealmLocalAllThreadNodesMulticastAddress(
        aInstance: *mut otInstance,
    ) -> *const otIp6Address;
}
extern "C" {
    #[doc = " This function retrieves the Service ALOC for given Service ID."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aServiceId    Service ID to get ALOC for."]
    #[doc = " @param[out]  aServiceAloc  A pointer to output the Service ALOC. MUST NOT BE NULL."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE      Successfully retrieved the Service ALOC."]
    #[doc = " @retval OT_ERROR_DETACHED  The Thread interface is not currently attached to a Thread Partition."]
    pub fn otThreadGetServiceAloc(
        aInstance: *mut otInstance,
        aServiceId: u8,
        aServiceAloc: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Thread Network Name."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Thread Network Name."]
    #[doc = ""]
    #[doc = " @sa otThreadSetNetworkName"]
    #[doc = ""]
    pub fn otThreadGetNetworkName(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the Thread Network Name."]
    #[doc = ""]
    #[doc = " This function succeeds only when Thread protocols are disabled.  A successful"]
    #[doc = " call to this function invalidates the Active and Pending Operational Datasets in"]
    #[doc = " non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aNetworkName  A pointer to the Thread Network Name."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the Thread Network Name."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otThreadGetNetworkName"]
    #[doc = ""]
    pub fn otThreadSetNetworkName(
        aInstance: *mut otInstance,
        aNetworkName: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread Domain Name."]
    #[doc = ""]
    #[doc = " @note Available since Thread 1.2."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Thread Domain Name."]
    #[doc = ""]
    #[doc = " @sa otThreadSetDomainName"]
    #[doc = ""]
    pub fn otThreadGetDomainName(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the Thread Domain Name. Only succeeds when Thread protocols are disabled."]
    #[doc = ""]
    #[doc = " @note Available since Thread 1.2."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDomainName   A pointer to the Thread Domain Name."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the Thread Domain Name."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otThreadGetDomainName"]
    #[doc = ""]
    pub fn otThreadSetDomainName(
        aInstance: *mut otInstance,
        aDomainName: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets or clears the Interface Identifier manually specified for the Thread Domain Unicast Address."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_DUA_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @note Only available since Thread 1.2."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aIid        A pointer to the Interface Identifier to set or NULL to clear."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set/cleared the Interface Identifier."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   The specified Interface Identifier is reserved."]
    #[doc = ""]
    #[doc = " @sa otThreadGetFixedDuaInterfaceIdentifier"]
    pub fn otThreadSetFixedDuaInterfaceIdentifier(
        aInstance: *mut otInstance,
        aIid: *const otIp6InterfaceIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Interface Identifier manually specified for the Thread Domain Unicast Address."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_DUA_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @note Only available since Thread 1.2."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Interface Identifier which was set manually, or NULL if none was set."]
    #[doc = ""]
    #[doc = " @sa otThreadSetFixedDuaInterfaceIdentifier"]
    #[doc = ""]
    pub fn otThreadGetFixedDuaInterfaceIdentifier(
        aInstance: *mut otInstance,
    ) -> *const otIp6InterfaceIdentifier;
}
extern "C" {
    #[doc = " Gets the thrKeySequenceCounter."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The thrKeySequenceCounter value."]
    #[doc = ""]
    #[doc = " @sa otThreadSetKeySequenceCounter"]
    #[doc = ""]
    pub fn otThreadGetKeySequenceCounter(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the thrKeySequenceCounter."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aKeySequenceCounter  The thrKeySequenceCounter value."]
    #[doc = ""]
    #[doc = " @sa otThreadGetKeySequenceCounter"]
    #[doc = ""]
    pub fn otThreadSetKeySequenceCounter(aInstance: *mut otInstance, aKeySequenceCounter: u32);
}
extern "C" {
    #[doc = " Gets the thrKeySwitchGuardTime (in hours)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The thrKeySwitchGuardTime value (in hours)."]
    #[doc = ""]
    #[doc = " @sa otThreadSetKeySwitchGuardTime"]
    #[doc = ""]
    pub fn otThreadGetKeySwitchGuardTime(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the thrKeySwitchGuardTime (in hours)."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aKeySwitchGuardTime  The thrKeySwitchGuardTime value (in hours)."]
    #[doc = ""]
    #[doc = " @sa otThreadGetKeySwitchGuardTime"]
    #[doc = ""]
    pub fn otThreadSetKeySwitchGuardTime(aInstance: *mut otInstance, aKeySwitchGuardTime: u32);
}
extern "C" {
    #[doc = " Detach from the Thread network."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully detached from the Thread network."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread is disabled."]
    #[doc = ""]
    pub fn otThreadBecomeDetached(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Attempt to reattach as a child."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully begin attempt to become a child."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread is disabled."]
    #[doc = ""]
    pub fn otThreadBecomeChild(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function gets the next neighbor information. It is used to go through the entries of"]
    #[doc = " the neighbor table."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator  A pointer to the iterator context. To get the first neighbor entry"]
    #[doc = "it should be set to OT_NEIGHBOR_INFO_ITERATOR_INIT."]
    #[doc = " @param[out]     aInfo      A pointer to the neighbor information."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE         Successfully found the next neighbor entry in table."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No subsequent neighbor entry exists in the table."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aIterator or @p aInfo was NULL."]
    #[doc = ""]
    pub fn otThreadGetNextNeighborInfo(
        aInstance: *mut otInstance,
        aIterator: *mut otNeighborInfoIterator,
        aInfo: *mut otNeighborInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the device role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_DEVICE_ROLE_DISABLED  The Thread stack is disabled."]
    #[doc = " @retval OT_DEVICE_ROLE_DETACHED  The device is not currently participating in a Thread network/partition."]
    #[doc = " @retval OT_DEVICE_ROLE_CHILD     The device is currently operating as a Thread Child."]
    #[doc = " @retval OT_DEVICE_ROLE_ROUTER    The device is currently operating as a Thread Router."]
    #[doc = " @retval OT_DEVICE_ROLE_LEADER    The device is currently operating as a Thread Leader."]
    #[doc = ""]
    pub fn otThreadGetDeviceRole(aInstance: *mut otInstance) -> otDeviceRole;
}
extern "C" {
    #[doc = " Convert the device role to human-readable string."]
    #[doc = ""]
    #[doc = " @param[in] aRole   The device role to convert."]
    #[doc = ""]
    #[doc = " @returns A string representing @p aRole."]
    #[doc = ""]
    pub fn otThreadDeviceRoleToString(aRole: otDeviceRole) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function get the Thread Leader Data."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aLeaderData  A pointer to where the leader data is placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the leader data."]
    #[doc = " @retval OT_ERROR_DETACHED      Not currently attached."]
    #[doc = ""]
    pub fn otThreadGetLeaderData(
        aInstance: *mut otInstance,
        aLeaderData: *mut otLeaderData,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Leader's Router ID."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Leader's Router ID."]
    #[doc = ""]
    pub fn otThreadGetLeaderRouterId(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Get the Leader's Weight."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Leader's Weight."]
    #[doc = ""]
    pub fn otThreadGetLeaderWeight(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Get the Partition ID."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Partition ID."]
    #[doc = ""]
    pub fn otThreadGetPartitionId(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Get the RLOC16."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The RLOC16."]
    #[doc = ""]
    pub fn otThreadGetRloc16(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " The function retrieves diagnostic information for a Thread Router as parent."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aParentInfo  A pointer to where the parent router information is placed."]
    #[doc = ""]
    pub fn otThreadGetParentInfo(
        aInstance: *mut otInstance,
        aParentInfo: *mut otRouterInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " The function retrieves the average RSSI for the Thread Parent."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aParentRssi  A pointer to where the parent RSSI should be placed."]
    #[doc = ""]
    pub fn otThreadGetParentAverageRssi(
        aInstance: *mut otInstance,
        aParentRssi: *mut i8,
    ) -> otError;
}
extern "C" {
    #[doc = " The function retrieves the RSSI of the last packet from the Thread Parent."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aLastRssi    A pointer to where the last RSSI should be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the RSSI data."]
    #[doc = " @retval OT_ERROR_FAILED        Unable to get RSSI data."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aLastRssi is NULL."]
    #[doc = ""]
    pub fn otThreadGetParentLastRssi(aInstance: *mut otInstance, aLastRssi: *mut i8) -> otError;
}
extern "C" {
    #[doc = " Starts the process for child to search for a better parent while staying attached to its current parent."]
    #[doc = ""]
    #[doc = " Must be used when device is attached as a child."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully started the process to search for a better parent."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Device role is not child."]
    #[doc = ""]
    pub fn otThreadSearchForBetterParent(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Gets the IPv6 counters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the IPv6 counters."]
    #[doc = ""]
    pub fn otThreadGetIp6Counters(aInstance: *mut otInstance) -> *const otIpCounters;
}
extern "C" {
    #[doc = " Resets the IPv6 counters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otThreadResetIp6Counters(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets the Thread MLE counters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the Thread MLE counters."]
    #[doc = ""]
    pub fn otThreadGetMleCounters(aInstance: *mut otInstance) -> *const otMleCounters;
}
extern "C" {
    #[doc = " Resets the Thread MLE counters."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otThreadResetMleCounters(aInstance: *mut otInstance);
}
#[doc = " This function pointer is called every time an MLE Parent Response message is received."]
#[doc = ""]
#[doc = " @param[in]  aInfo     A pointer to a location on stack holding the stats data."]
#[doc = " @param[in]  aContext  A pointer to callback client-specific context."]
#[doc = ""]
pub type otThreadParentResponseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aInfo: *mut otThreadParentResponseInfo,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function registers a callback to receive MLE Parent Response data."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aCallback  A pointer to a function that is called upon receiving an MLE Parent Response message."]
    #[doc = " @param[in]  aContext   A pointer to callback client-specific context."]
    #[doc = ""]
    pub fn otThreadRegisterParentResponseCallback(
        aInstance: *mut otInstance,
        aCallback: otThreadParentResponseCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
#[doc = " This structure represents the Thread Discovery Request data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otThreadDiscoveryRequestInfo {
    #[doc = "< IEEE 802.15.4 Extended Address of the requester"]
    pub mExtAddress: otExtAddress,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otThreadDiscoveryRequestInfo {
    #[inline]
    pub fn mVersion(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mVersion(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsJoiner(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoiner(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mVersion: u8, mIsJoiner: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mVersion: u8 = unsafe { ::std::mem::transmute(mVersion) };
            mVersion as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsJoiner: u8 = unsafe { ::std::mem::transmute(mIsJoiner) };
            mIsJoiner as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This function pointer is called every time an MLE Discovery Request message is received."]
#[doc = ""]
#[doc = " @param[in]  aInfo     A pointer to the Discovery Request info data."]
#[doc = " @param[in]  aContext  A pointer to callback application-specific context."]
#[doc = ""]
pub type otThreadDiscoveryRequestCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aInfo: *const otThreadDiscoveryRequestInfo,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function sets a callback to receive MLE Discovery Request data."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aCallback  A pointer to a function that is called upon receiving an MLE Discovery Request message."]
    #[doc = " @param[in]  aContext   A pointer to callback application-specific context."]
    #[doc = ""]
    pub fn otThreadSetDiscoveryRequestCallback(
        aInstance: *mut otInstance,
        aCallback: otThreadDiscoveryRequestCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
#[doc = " This function pointer type defines the callback to notify the outcome of a `otThreadLocateAnycastDestination()`"]
#[doc = " request."]
#[doc = ""]
#[doc = " @param[in] aContext            A pointer to an arbitrary context (provided when callback is registered)."]
#[doc = " @param[in] aError              The error when handling the request. OT_ERROR_NONE indicates success."]
#[doc = "                                OT_ERROR_RESPONSE_TIMEOUT indicates a destination could not be found."]
#[doc = "                                OT_ERROR_ABORT indicates the request was aborted."]
#[doc = " @param[in] aMeshLocalAddress   A pointer to the mesh-local EID of the closest destination of the anycast address"]
#[doc = "                                when @p aError is OT_ERROR_NONE, NULL otherwise."]
#[doc = " @param[in] aRloc16             The RLOC16 of the destination if found, otherwise invalid RLOC16 (0xfffe)."]
#[doc = ""]
pub type otThreadAnycastLocatorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aError: otError,
        aMeshLocalAddress: *const otIp6Address,
        aRloc16: u16,
    ),
>;
extern "C" {
    #[doc = " This function requests the closest destination of a given anycast address to be located."]
    #[doc = ""]
    #[doc = " This function is only available when `OPENTHREAD_CONFIG_TMF_ANYCAST_LOCATOR_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " If a previous request is ongoing, a subsequent call to this function will cancel and replace the earlier request."]
    #[doc = ""]
    #[doc = " @param[in] aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in] aAnycastAddress   The anycast address to locate. MUST NOT be NULL."]
    #[doc = " @param[in] aCallback         The callback function to report the result."]
    #[doc = " @param[in] aContext          An arbitrary context used with @p aCallback."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          The request started successfully. @p aCallback will be invoked to report the result."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The @p aAnycastAddress is not a valid anycast address or @p aCallback is NULL."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Out of buffer to prepare and send the request message."]
    #[doc = ""]
    pub fn otThreadLocateAnycastDestination(
        aInstance: *mut otInstance,
        aAnycastAddress: *const otIp6Address,
        aCallback: otThreadAnycastLocatorCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether an anycast locate request is currently in progress."]
    #[doc = ""]
    #[doc = " This function is only available when `OPENTHREAD_CONFIG_TMF_ANYCAST_LOCATOR_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns TRUE if an anycast locate request is currently in progress, FALSE otherwise."]
    #[doc = ""]
    pub fn otThreadIsAnycastLocateInProgress(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function sends a Proactive Address Notification (ADDR_NTF.ntf) message."]
    #[doc = ""]
    #[doc = " This function is only available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDestination  The destination to send the ADDR_NTF.ntf message."]
    #[doc = " @param[in]  aTarget       The target address of the ADDR_NTF.ntf message."]
    #[doc = " @param[in]  aMlIid        The ML-IID of the ADDR_NTF.ntf message."]
    #[doc = ""]
    pub fn otThreadSendAddressNotification(
        aInstance: *mut otInstance,
        aDestination: *mut otIp6Address,
        aTarget: *mut otIp6Address,
        aMlIid: *mut otIp6InterfaceIdentifier,
    );
}
extern "C" {
    #[doc = " This function sends a Proactive Backbone Notification (PRO_BB.ntf) message on the Backbone link."]
    #[doc = ""]
    #[doc = " This function is only available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance                    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aTarget                      The target address of the PRO_BB.ntf message."]
    #[doc = " @param[in]  aMlIid                       The ML-IID of the PRO_BB.ntf message."]
    #[doc = " @param[in]  aTimeSinceLastTransaction    Time since last transaction (in seconds)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully sent PRO_BB.ntf on backbone link."]
    #[doc = " @retval OT_ERROR_NO_BUFS        If insufficient message buffers available."]
    #[doc = ""]
    pub fn otThreadSendProactiveBackboneNotification(
        aInstance: *mut otInstance,
        aTarget: *mut otIp6Address,
        aMlIid: *mut otIp6InterfaceIdentifier,
        aTimeSinceLastTransaction: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " This function notifies other nodes in the network (if any) and then stops Thread protocol operation."]
    #[doc = ""]
    #[doc = " It sends an Address Release if it's a router, or sets its child timeout to 0 if it's a child."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in] aCallback A pointer to a function that is called upon finishing detaching."]
    #[doc = " @param[in] aContext  A pointer to callback application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE Successfully started detaching."]
    #[doc = " @retval OT_ERROR_BUSY Detaching is already in progress."]
    #[doc = ""]
    pub fn otThreadDetachGracefully(
        aInstance: *mut otInstance,
        aCallback: otDetachGracefullyCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
#[doc = "< MAC Extended Address TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_EXT_ADDRESS: _bindgen_ty_11 = 0;
#[doc = "< Address16 TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_SHORT_ADDRESS: _bindgen_ty_11 = 1;
#[doc = "< Mode TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_MODE: _bindgen_ty_11 = 2;
#[doc = "< Timeout TLV (the maximum polling time period for SEDs)"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_TIMEOUT: _bindgen_ty_11 = 3;
#[doc = "< Connectivity TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_CONNECTIVITY: _bindgen_ty_11 = 4;
#[doc = "< Route64 TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_ROUTE: _bindgen_ty_11 = 5;
#[doc = "< Leader Data TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_LEADER_DATA: _bindgen_ty_11 = 6;
#[doc = "< Network Data TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_NETWORK_DATA: _bindgen_ty_11 = 7;
#[doc = "< IPv6 Address List TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_IP6_ADDR_LIST: _bindgen_ty_11 = 8;
#[doc = "< MAC Counters TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_MAC_COUNTERS: _bindgen_ty_11 = 9;
#[doc = "< Battery Level TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_BATTERY_LEVEL: _bindgen_ty_11 = 14;
#[doc = "< Supply Voltage TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_SUPPLY_VOLTAGE: _bindgen_ty_11 = 15;
#[doc = "< Child Table TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_CHILD_TABLE: _bindgen_ty_11 = 16;
#[doc = "< Channel Pages TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_CHANNEL_PAGES: _bindgen_ty_11 = 17;
#[doc = "< Type List TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_TYPE_LIST: _bindgen_ty_11 = 18;
#[doc = "< Max Child Timeout TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_MAX_CHILD_TIMEOUT: _bindgen_ty_11 = 19;
#[doc = "< Version TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_VERSION: _bindgen_ty_11 = 24;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub type otNetworkDiagIterator = u16;
#[doc = " This structure represents a Network Diagnostic Connectivity value."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNetworkDiagConnectivity {
    #[doc = " The priority of the sender as a parent."]
    pub mParentPriority: i8,
    #[doc = " The number of neighboring devices with which the sender shares a link of quality 3."]
    pub mLinkQuality3: u8,
    #[doc = " The number of neighboring devices with which the sender shares a link of quality 2."]
    pub mLinkQuality2: u8,
    #[doc = " The number of neighboring devices with which the sender shares a link of quality 1."]
    pub mLinkQuality1: u8,
    #[doc = " The sender's routing cost to the Leader."]
    pub mLeaderCost: u8,
    #[doc = " The most recent ID sequence number received by the sender."]
    pub mIdSequence: u8,
    #[doc = " The number of active Routers in the sender's Thread Network Partition."]
    pub mActiveRouters: u8,
    #[doc = " The guaranteed buffer capacity in octets for all IPv6 datagrams destined to a given SED. Optional."]
    pub mSedBufferSize: u16,
    #[doc = " The guaranteed queue capacity in number of IPv6 datagrams destined to a given SED. Optional."]
    pub mSedDatagramCount: u8,
}
#[doc = " This structure represents a Network Diagnostic Route data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNetworkDiagRouteData {
    #[doc = "< The Assigned Router ID."]
    pub mRouterId: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otNetworkDiagRouteData {
    #[inline]
    pub fn mLinkQualityOut(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkQualityOut(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mLinkQualityIn(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkQualityIn(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mRouteCost(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mRouteCost(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mLinkQualityOut: u8,
        mLinkQualityIn: u8,
        mRouteCost: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let mLinkQualityOut: u8 = unsafe { ::std::mem::transmute(mLinkQualityOut) };
            mLinkQualityOut as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let mLinkQualityIn: u8 = unsafe { ::std::mem::transmute(mLinkQualityIn) };
            mLinkQualityIn as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let mRouteCost: u8 = unsafe { ::std::mem::transmute(mRouteCost) };
            mRouteCost as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents a Network Diagnostic Route TLV value."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otNetworkDiagRoute {
    #[doc = " The sequence number associated with the set of Router ID assignments in #mRouteData."]
    pub mIdSequence: u8,
    #[doc = " Number of elements in #mRouteData."]
    pub mRouteCount: u8,
    #[doc = " Link Quality and Routing Cost data."]
    pub mRouteData: [otNetworkDiagRouteData; 63usize],
}
impl Default for otNetworkDiagRoute {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents a Network Diagnostic Mac Counters value."]
#[doc = ""]
#[doc = " See <a href=\"https://www.ietf.org/rfc/rfc2863\">RFC 2863</a> for definitions of member fields."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNetworkDiagMacCounters {
    pub mIfInUnknownProtos: u32,
    pub mIfInErrors: u32,
    pub mIfOutErrors: u32,
    pub mIfInUcastPkts: u32,
    pub mIfInBroadcastPkts: u32,
    pub mIfInDiscards: u32,
    pub mIfOutUcastPkts: u32,
    pub mIfOutBroadcastPkts: u32,
    pub mIfOutDiscards: u32,
}
#[doc = " This structure represents a Network Diagnostic Child Table Entry."]
#[doc = ""]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNetworkDiagChildEntry {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = " Link mode bits."]
    pub mMode: otLinkModeConfig,
}
impl otNetworkDiagChildEntry {
    #[inline]
    pub fn mTimeout(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mTimeout(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mLinkQuality(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkQuality(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mChildId(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_mChildId(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mTimeout: u16,
        mLinkQuality: u8,
        mChildId: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let mTimeout: u16 = unsafe { ::std::mem::transmute(mTimeout) };
            mTimeout as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let mLinkQuality: u8 = unsafe { ::std::mem::transmute(mLinkQuality) };
            mLinkQuality as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let mChildId: u16 = unsafe { ::std::mem::transmute(mChildId) };
            mChildId as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents a Network Diagnostic TLV."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetworkDiagTlv {
    #[doc = " The Network Diagnostic TLV type."]
    pub mType: u8,
    pub mData: otNetworkDiagTlv__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otNetworkDiagTlv__bindgen_ty_1 {
    pub mExtAddress: otExtAddress,
    pub mAddr16: u16,
    pub mMode: otLinkModeConfig,
    pub mTimeout: u32,
    pub mConnectivity: otNetworkDiagConnectivity,
    pub mRoute: otNetworkDiagRoute,
    pub mLeaderData: otLeaderData,
    pub mMacCounters: otNetworkDiagMacCounters,
    pub mBatteryLevel: u8,
    pub mSupplyVoltage: u16,
    pub mMaxChildTimeout: u32,
    pub mVersion: u16,
    pub mNetworkData: otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_1,
    pub mIp6AddrList: otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_2,
    pub mChildTable: otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_3,
    pub mChannelPages: otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_1 {
    pub mCount: u8,
    pub m8: [u8; 254usize],
}
impl Default for otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_2 {
    pub mCount: u8,
    pub mList: [otIp6Address; 15usize],
}
impl Default for otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_3 {
    pub mCount: u8,
    pub mTable: [otNetworkDiagChildEntry; 84usize],
}
impl Default for otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_4 {
    pub mCount: u8,
    pub m8: [u8; 254usize],
}
impl Default for otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otNetworkDiagTlv__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otNetworkDiagTlv {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function gets the next Network Diagnostic TLV in the message."]
    #[doc = ""]
    #[doc = " @param[in]      aMessage         A pointer to a message."]
    #[doc = " @param[in,out]  aIterator        A pointer to the Network Diagnostic iterator context. To get the first"]
    #[doc = "                                  Network Diagnostic TLV it should be set to OT_NETWORK_DIAGNOSTIC_ITERATOR_INIT."]
    #[doc = " @param[out]     aNetworkDiagTlv  A pointer to where the Network Diagnostic TLV information will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully found the next Network Diagnostic TLV."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No subsequent Network Diagnostic TLV exists in the message."]
    #[doc = " @retval OT_ERROR_PARSE      Parsing the next Network Diagnostic failed."]
    #[doc = ""]
    #[doc = " @Note A subsequent call to this function is allowed only when current return value is OT_ERROR_NONE."]
    #[doc = ""]
    pub fn otThreadGetNextDiagnosticTlv(
        aMessage: *const otMessage,
        aIterator: *mut otNetworkDiagIterator,
        aNetworkDiagTlv: *mut otNetworkDiagTlv,
    ) -> otError;
}
#[doc = " This function pointer is called when Network Diagnostic Get response is received."]
#[doc = ""]
#[doc = " @param[in]  aError        The error when failed to get the response."]
#[doc = " @param[in]  aMessage      A pointer to the message buffer containing the received Network Diagnostic"]
#[doc = "                           Get response payload. Available only when @p aError is `OT_ERROR_NONE`."]
#[doc = " @param[in]  aMessageInfo  A pointer to the message info for @p aMessage. Available only when"]
#[doc = "                           @p aError is `OT_ERROR_NONE`."]
#[doc = " @param[in]  aContext      A pointer to application-specific context."]
#[doc = ""]
pub type otReceiveDiagnosticGetCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aError: otError,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Send a Network Diagnostic Get request."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDestination      A pointer to destination address."]
    #[doc = " @param[in]  aTlvTypes         An array of Network Diagnostic TLV types."]
    #[doc = " @param[in]  aCount            Number of types in aTlvTypes."]
    #[doc = " @param[in]  aCallback         A pointer to a function that is called when Network Diagnostic Get response"]
    #[doc = "                               is received or NULL to disable the callback."]
    #[doc = " @param[in]  aCallbackContext  A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully queued the DIAG_GET.req."]
    #[doc = " @retval OT_ERROR_NO_BUFS Insufficient message buffers available to send DIAG_GET.req."]
    #[doc = ""]
    pub fn otThreadSendDiagnosticGet(
        aInstance: *mut otInstance,
        aDestination: *const otIp6Address,
        aTlvTypes: *const u8,
        aCount: u8,
        aCallback: otReceiveDiagnosticGetCallback,
        aCallbackContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Send a Network Diagnostic Reset request."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDestination   A pointer to destination address."]
    #[doc = " @param[in]  aTlvTypes      An array of Network Diagnostic TLV types. Currently only Type 9 is allowed."]
    #[doc = " @param[in]  aCount         Number of types in aTlvTypes"]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully queued the DIAG_RST.ntf."]
    #[doc = " @retval OT_ERROR_NO_BUFS Insufficient message buffers available to send DIAG_RST.ntf."]
    #[doc = ""]
    pub fn otThreadSendDiagnosticReset(
        aInstance: *mut otInstance,
        aDestination: *const otIp6Address,
        aTlvTypes: *const u8,
        aCount: u8,
    ) -> otError;
}
#[doc = "< The device hasn't attached to a network."]
pub const OT_NETWORK_TIME_UNSYNCHRONIZED: otNetworkTimeStatus = -1;
#[doc = "< The device hasn’t received time sync for more than two periods time."]
pub const OT_NETWORK_TIME_RESYNC_NEEDED: otNetworkTimeStatus = 0;
#[doc = "< The device network time is synchronized."]
pub const OT_NETWORK_TIME_SYNCHRONIZED: otNetworkTimeStatus = 1;
#[doc = " This enumeration represents OpenThread time synchronization status."]
#[doc = ""]
pub type otNetworkTimeStatus = ::std::os::raw::c_int;
#[doc = " This function pointer is called when a network time sync or status change occurs."]
#[doc = ""]
pub type otNetworkTimeSyncCallbackFn =
    ::std::option::Option<unsafe extern "C" fn(aCallbackContext: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Get the Thread network time."]
    #[doc = ""]
    #[doc = " @param[in]     aInstance     The OpenThread instance structure."]
    #[doc = " @param[in,out] aNetworkTime  The Thread network time in microseconds."]
    #[doc = ""]
    #[doc = " @returns The time synchronization status."]
    #[doc = ""]
    pub fn otNetworkTimeGet(
        aInstance: *mut otInstance,
        aNetworkTime: *mut u64,
    ) -> otNetworkTimeStatus;
}
extern "C" {
    #[doc = " Set the time synchronization period."]
    #[doc = ""]
    #[doc = " This function can only be called while Thread protocols are disabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance         The OpenThread instance structure."]
    #[doc = " @param[in] aTimeSyncPeriod   The time synchronization period, in seconds."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the time sync period."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    pub fn otNetworkTimeSetSyncPeriod(aInstance: *mut otInstance, aTimeSyncPeriod: u16) -> otError;
}
extern "C" {
    #[doc = " Get the time synchronization period."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns The time synchronization period."]
    #[doc = ""]
    pub fn otNetworkTimeGetSyncPeriod(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Set the time synchronization XTAL accuracy threshold for Router-Capable device."]
    #[doc = ""]
    #[doc = " This function can only be called while Thread protocols are disabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        The OpenThread instance structure."]
    #[doc = " @param[in] aXTALThreshold   The XTAL accuracy threshold for Router, in PPM."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the time sync period."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    pub fn otNetworkTimeSetXtalThreshold(
        aInstance: *mut otInstance,
        aXTALThreshold: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the time synchronization XTAL accuracy threshold for Router."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns The XTAL accuracy threshold for Router, in PPM."]
    #[doc = ""]
    pub fn otNetworkTimeGetXtalThreshold(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Set a callback to be called when a network time sync or status change occurs"]
    #[doc = ""]
    #[doc = " This callback shall be called only when the network time offset jumps by"]
    #[doc = " OPENTHREAD_CONFIG_TIME_SYNC_JUMP_NOTIF_MIN_US or when the status changes."]
    #[doc = ""]
    #[doc = " @param[in] aInstance The OpenThread instance structure."]
    #[doc = " @param[in] aCallbackFn The callback function to be called"]
    #[doc = " @param[in] aCallbackContext The context to be passed to the callback function upon invocation"]
    #[doc = ""]
    pub fn otNetworkTimeSyncSetCallback(
        aInstance: *mut otInstance,
        aCallbackFn: otNetworkTimeSyncCallbackFn,
        aCallbackContext: *mut ::std::os::raw::c_void,
    );
}
#[doc = " This structure represents a ping reply."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otPingSenderReply {
    #[doc = "< Sender IPv6 address (address from which ping reply was received)."]
    pub mSenderAddress: otIp6Address,
    #[doc = "< Round trip time in msec."]
    pub mRoundTripTime: u16,
    #[doc = "< Data size (number of bytes) in reply (excluding IPv6 and ICMP6 headers)."]
    pub mSize: u16,
    #[doc = "< Sequence number."]
    pub mSequenceNumber: u16,
    #[doc = "< Hop limit."]
    pub mHopLimit: u8,
}
impl Default for otPingSenderReply {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents statistics of a ping request."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otPingSenderStatistics {
    #[doc = "< The number of ping requests already sent."]
    pub mSentCount: u16,
    #[doc = "< The number of ping replies received."]
    pub mReceivedCount: u16,
    #[doc = "< The total round trip time of ping requests."]
    pub mTotalRoundTripTime: u32,
    #[doc = "< The min round trip time among ping requests."]
    pub mMinRoundTripTime: u16,
    #[doc = "< The max round trip time among ping requests."]
    pub mMaxRoundTripTime: u16,
    #[doc = "< Whether this is a multicast ping request."]
    pub mIsMulticast: bool,
}
#[doc = " This function pointer type specifies the callback to notify receipt of a ping reply."]
#[doc = ""]
#[doc = " @param[in] aReply      A pointer to a `otPingSenderReply` containing info about the received ping reply."]
#[doc = " @param[in] aContext    A pointer to application-specific context."]
#[doc = ""]
pub type otPingSenderReplyCallback = ::std::option::Option<
    unsafe extern "C" fn(aReply: *const otPingSenderReply, aContext: *mut ::std::os::raw::c_void),
>;
#[doc = " This function pointer type specifies the callback to report the ping statistics."]
#[doc = ""]
#[doc = " @param[in] aStatistics      A pointer to a `otPingSenderStatistics` containing info about the received ping"]
#[doc = "                             statistics."]
#[doc = " @param[in] aContext         A pointer to application-specific context."]
#[doc = ""]
pub type otPingSenderStatisticsCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aStatistics: *const otPingSenderStatistics,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " This structure represents a ping request configuration."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otPingSenderConfig {
    #[doc = "< Source address of the ping."]
    pub mSource: otIp6Address,
    #[doc = "< Destination address to ping."]
    pub mDestination: otIp6Address,
    #[doc = "< Callback function to report replies (can be NULL if not needed)."]
    pub mReplyCallback: otPingSenderReplyCallback,
    #[doc = "< Callback function to report statistics (can be NULL if not needed)."]
    pub mStatisticsCallback: otPingSenderStatisticsCallback,
    #[doc = "< A pointer to the callback application-specific context."]
    pub mCallbackContext: *mut ::std::os::raw::c_void,
    #[doc = "< Data size (# of bytes) excludes IPv6/ICMPv6 header. Zero for default."]
    pub mSize: u16,
    #[doc = "< Number of ping messages to send. Zero to use default."]
    pub mCount: u16,
    #[doc = "< Ping tx interval in milliseconds. Zero to use default."]
    pub mInterval: u32,
    #[doc = "< Time in milliseconds to wait for final reply after sending final request."]
    #[doc = "< Zero to use default."]
    pub mTimeout: u16,
    #[doc = "< Hop limit (used if `mAllowZeroHopLimit` is false). Zero for default."]
    pub mHopLimit: u8,
    #[doc = "< Indicates whether hop limit is zero."]
    pub mAllowZeroHopLimit: bool,
}
impl Default for otPingSenderConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function starts a ping."]
    #[doc = ""]
    #[doc = " @param[in] aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in] aConfig              The ping config to use."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           The ping started successfully."]
    #[doc = " @retval OT_ERROR_BUSY           Could not start since busy with a previous ongoing ping request."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   The @p aConfig contains invalid parameters (e.g., ping interval is too long)."]
    #[doc = ""]
    #[doc = ""]
    pub fn otPingSenderPing(
        aInstance: *mut otInstance,
        aConfig: *const otPingSenderConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This function stops an ongoing ping."]
    #[doc = ""]
    #[doc = " @param[in] aInstance            A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otPingSenderStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Set the alarm to fire at @p aDt microseconds after @p aT0."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  The OpenThread instance structure."]
    #[doc = " @param[in]  aT0        The reference time."]
    #[doc = " @param[in]  aDt        The time delay in microseconds from @p aT0."]
    #[doc = ""]
    pub fn otPlatAlarmMicroStartAt(aInstance: *mut otInstance, aT0: u32, aDt: u32);
}
extern "C" {
    #[doc = " Stop the alarm."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    pub fn otPlatAlarmMicroStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the current time."]
    #[doc = ""]
    #[doc = " @returns  The current time in microseconds."]
    #[doc = ""]
    pub fn otPlatAlarmMicroGetNow() -> u32;
}
extern "C" {
    #[doc = " Signal that the alarm has fired."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatAlarmMicroFired(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Set the alarm to fire at @p aDt milliseconds after @p aT0."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aT0        The reference time."]
    #[doc = " @param[in] aDt        The time delay in milliseconds from @p aT0."]
    pub fn otPlatAlarmMilliStartAt(aInstance: *mut otInstance, aT0: u32, aDt: u32);
}
extern "C" {
    #[doc = " Stop the alarm."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatAlarmMilliStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the current time."]
    #[doc = ""]
    #[doc = " @returns The current time in milliseconds."]
    pub fn otPlatAlarmMilliGetNow() -> u32;
}
extern "C" {
    #[doc = " Signal that the alarm has fired."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatAlarmMilliFired(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Signal diagnostics module that the alarm has fired."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatDiagAlarmFired(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Standard printf() to the debug uart with no log decoration."]
    #[doc = ""]
    #[doc = " @param[in]   fmt   printf formatter text"]
    #[doc = ""]
    #[doc = " This is a debug convenience function that is not intended to be"]
    #[doc = " used in anything other then \"debug scenarios\" by a developer."]
    #[doc = ""]
    #[doc = " lf -> cr/lf mapping is automatically handled via otPlatDebugUart_putchar()"]
    #[doc = ""]
    #[doc = " @sa otPlatDebugUart_vprintf() for limitations"]
    #[doc = ""]
    #[doc = " This is a WEAK symbol that can easily be overridden as needed."]
    pub fn otPlatDebugUart_printf(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Standard vprintf() to the debug uart, with no log decoration."]
    #[doc = ""]
    #[doc = " @param[in]   fmt   printf formatter text"]
    #[doc = " @param[in]   ap    va_list value for print parameters."]
    #[doc = ""]
    #[doc = " Implementation limitation: this formats the text into"]
    #[doc = " a purposely small text buffer on the stack, thus long"]
    #[doc = " messages may be truncated."]
    #[doc = ""]
    #[doc = " This is a WEAK symbol that can easily be overridden as needed."]
    #[doc = ""]
    #[doc = " For example, some platforms might override this via a non-WEAK"]
    #[doc = " symbol because the platform provides a UART_vprintf() like"]
    #[doc = " function that can handle an arbitrary length output."]
    pub fn otPlatDebugUart_vprintf(fmt: *const ::std::os::raw::c_char, ap: *mut __va_list_tag);
}
extern "C" {
    #[doc = " Platform specific write single byte to Debug Uart"]
    #[doc = " This should not perform CR/LF mapping."]
    #[doc = ""]
    #[doc = " This function MUST be implemented by the platform"]
    #[doc = ""]
    #[doc = " @param[in] c   what to transmit"]
    pub fn otPlatDebugUart_putchar_raw(c: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Poll/test debug uart if a key has been pressed."]
    #[doc = " It would be common to a stub function that returns 0."]
    #[doc = ""]
    #[doc = " This function MUST be implemented by the platform"]
    #[doc = ""]
    #[doc = " @retval zero - nothing ready"]
    #[doc = " @retval nonzero - otPlatDebugUart_getc() will succeed."]
    pub fn otPlatDebugUart_kbhit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll/Read a byte from the debug uart"]
    #[doc = ""]
    #[doc = " This function MUST be implemented by the platform"]
    #[doc = ""]
    #[doc = " @retval (negative) no data available, see otPlatDebugUart_kbhit()"]
    #[doc = " @retval (0x00..0x0ff) data byte value"]
    #[doc = ""]
    pub fn otPlatDebugUart_getc() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write byte to the uart, expand cr/lf as need."]
    #[doc = ""]
    #[doc = " A WEAK default implementation is provided"]
    #[doc = " that can be overridden as needed."]
    #[doc = ""]
    #[doc = " @param[in] c   the byte to transmit"]
    pub fn otPlatDebugUart_putchar(c: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " identical to \"man 3 puts\" - terminates with lf"]
    #[doc = " Which is then mapped to cr/lf as required"]
    #[doc = ""]
    #[doc = " A WEAK default implementation is provided"]
    #[doc = " that can be overridden as needed."]
    #[doc = ""]
    #[doc = " @param[in]   s   the string to print with a lf at the end"]
    pub fn otPlatDebugUart_puts(s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Write N bytes to the UART, mapping cr/lf"]
    #[doc = ""]
    #[doc = " @param[in]  pBytes   pointer to bytes to transmit."]
    #[doc = " @param[in]  nBytes   how many bytes to transmit."]
    pub fn otPlatDebugUart_write_bytes(pBytes: *const u8, nBytes: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " puts() without a terminal newline."]
    #[doc = " see: \"man 3 puts\", without a adding a terminal lf"]
    #[doc = ""]
    #[doc = " @param[in]  s       the string to print without a lf at the end"]
    #[doc = ""]
    #[doc = " Note, the terminal \"lf\" mapped to cr/lf via"]
    #[doc = " the function otPlatDebugUart_putchar()"]
    pub fn otPlatDebugUart_puts_no_nl(s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Some platforms (simulation) can log to a file."]
    #[doc = ""]
    #[doc = " @returns OT_ERROR_NONE"]
    #[doc = " @returns OT_ERROR_FAILED"]
    #[doc = ""]
    #[doc = " Platforms that desire this MUST provide an implementation."]
    #[doc = ""]
    pub fn otPlatDebugUart_logfile(filename: *const ::std::os::raw::c_char) -> otError;
}
#[doc = "< Input mode without pull resistor."]
pub const OT_GPIO_MODE_INPUT: otGpioMode = 0;
#[doc = "< Output mode."]
pub const OT_GPIO_MODE_OUTPUT: otGpioMode = 1;
#[doc = " This enumeration defines the gpio modes."]
#[doc = ""]
pub type otGpioMode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function processes a factory diagnostics command line."]
    #[doc = ""]
    #[doc = " The output of this function (the content written to @p aOutput) MUST terminate with `\\0` and the `\\0` is within the"]
    #[doc = " output buffer."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance       The OpenThread instance for current request."]
    #[doc = " @param[in]   aArgsLength     The number of arguments in @p aArgs."]
    #[doc = " @param[in]   aArgs           The arguments of diagnostics command line."]
    #[doc = " @param[out]  aOutput         The diagnostics execution result."]
    #[doc = " @param[in]   aOutputMaxLen   The output buffer size."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS       The command is supported but invalid arguments provided."]
    #[doc = " @retval  OT_ERROR_NONE               The command is successfully process."]
    #[doc = " @retval  OT_ERROR_INVALID_COMMAND    The command is not valid or not supported."]
    #[doc = ""]
    pub fn otPlatDiagProcess(
        aInstance: *mut otInstance,
        aArgsLength: u8,
        aArgs: *mut *mut ::std::os::raw::c_char,
        aOutput: *mut ::std::os::raw::c_char,
        aOutputMaxLen: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " This function enables/disables the factory diagnostics mode."]
    #[doc = ""]
    #[doc = " @param[in]  aMode  TRUE to enable diagnostics mode, FALSE otherwise."]
    #[doc = ""]
    pub fn otPlatDiagModeSet(aMode: bool);
}
extern "C" {
    #[doc = " This function indicates whether or not factory diagnostics mode is enabled."]
    #[doc = ""]
    #[doc = " @returns TRUE if factory diagnostics mode is enabled, FALSE otherwise."]
    #[doc = ""]
    pub fn otPlatDiagModeGet() -> bool;
}
extern "C" {
    #[doc = " This function sets the channel to use for factory diagnostics."]
    #[doc = ""]
    #[doc = " @param[in]  aChannel  The channel value."]
    #[doc = ""]
    pub fn otPlatDiagChannelSet(aChannel: u8);
}
extern "C" {
    #[doc = " This function sets the transmit power to use for factory diagnostics."]
    #[doc = ""]
    #[doc = " @param[in]  aTxPower  The transmit power value."]
    #[doc = ""]
    pub fn otPlatDiagTxPowerSet(aTxPower: i8);
}
extern "C" {
    #[doc = " This function processes the received radio frame."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance   The OpenThread instance for current request."]
    #[doc = " @param[in]   aFrame      The received radio frame."]
    #[doc = " @param[in]   aError      The received radio frame status."]
    #[doc = ""]
    pub fn otPlatDiagRadioReceived(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " This function processes the alarm event."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance   The OpenThread instance for current request."]
    #[doc = ""]
    pub fn otPlatDiagAlarmCallback(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function sets the gpio value."]
    #[doc = ""]
    #[doc = " @param[in]  aGpio   The gpio number."]
    #[doc = " @param[in]  aValue  true to set the gpio to high level, or false otherwise."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the gpio."]
    #[doc = " @retval OT_ERROR_FAILED           A platform error occurred while setting the gpio."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     @p aGpio is not supported."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    Diagnostic mode was not enabled or @p aGpio is not configured as output."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented or configured on the platform."]
    #[doc = ""]
    pub fn otPlatDiagGpioSet(aGpio: u32, aValue: bool) -> otError;
}
extern "C" {
    #[doc = " This function gets the gpio value."]
    #[doc = ""]
    #[doc = " @param[in]   aGpio   The gpio number."]
    #[doc = " @param[out]  aValue  A pointer where to put gpio value."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully got the gpio value."]
    #[doc = " @retval OT_ERROR_FAILED           A platform error occurred while getting the gpio value."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     @p aGpio is not supported or @p aValue is NULL."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    Diagnostic mode was not enabled or @p aGpio is not configured as input."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented or configured on the platform."]
    #[doc = ""]
    pub fn otPlatDiagGpioGet(aGpio: u32, aValue: *mut bool) -> otError;
}
extern "C" {
    #[doc = " This function sets the gpio mode."]
    #[doc = ""]
    #[doc = " @param[in]   aGpio   The gpio number."]
    #[doc = " @param[out]  aMode   The gpio mode."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the gpio mode."]
    #[doc = " @retval OT_ERROR_FAILED           A platform error occurred while setting the gpio mode."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     @p aGpio or @p aMode is not supported."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    Diagnostic mode was not enabled."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented or configured on the platform."]
    #[doc = ""]
    pub fn otPlatDiagGpioSetMode(aGpio: u32, aMode: otGpioMode) -> otError;
}
extern "C" {
    #[doc = " This function gets the gpio mode."]
    #[doc = ""]
    #[doc = " @param[in]   aGpio   The gpio number."]
    #[doc = " @param[out]  aMode   A pointer where to put gpio mode."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully got the gpio mode."]
    #[doc = " @retval OT_ERROR_FAILED           Mode returned by the platform is not implemented in OpenThread or a platform error"]
    #[doc = "                                   occurred while getting the gpio mode."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     @p aGpio is not supported or @p aMode is NULL."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    Diagnostic mode was not enabled."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented or configured on the platform."]
    #[doc = ""]
    pub fn otPlatDiagGpioGetMode(aGpio: u32, aMode: *mut otGpioMode) -> otError;
}
extern "C" {
    #[doc = " Set the radio raw power setting for diagnostics module."]
    #[doc = ""]
    #[doc = " @param[in] aInstance               The OpenThread instance structure."]
    #[doc = " @param[in] aRawPowerSetting        A pointer to the raw power setting byte array."]
    #[doc = " @param[in] aRawPowerSettingLength  The length of the @p aRawPowerSetting."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the raw power setting."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     The @p aRawPowerSetting is NULL or the @p aRawPowerSettingLength is too long."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This method is not implemented."]
    #[doc = ""]
    pub fn otPlatDiagRadioSetRawPowerSetting(
        aInstance: *mut otInstance,
        aRawPowerSetting: *const u8,
        aRawPowerSettingLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the radio raw power setting for diagnostics module."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance               The OpenThread instance structure."]
    #[doc = " @param[out]     aRawPowerSetting        A pointer to the raw power setting byte array."]
    #[doc = " @param[in,out]  aRawPowerSettingLength  On input, a pointer to the size of @p aRawPowerSetting."]
    #[doc = "                                         On output, a pointer to the length of the raw power setting data."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully set the raw power setting."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     The @p aRawPowerSetting or @p aRawPowerSettingLength is NULL or"]
    #[doc = "                                   @aRawPowerSettingLength is too short."]
    #[doc = " @retval OT_ERROR_NOT_FOUND        The raw power setting is not set."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This method is not implemented."]
    #[doc = ""]
    pub fn otPlatDiagRadioGetRawPowerSetting(
        aInstance: *mut otInstance,
        aRawPowerSetting: *mut u8,
        aRawPowerSettingLength: *mut u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Enable/disable the platform layer to use the raw power setting set by `otPlatDiagRadioSetRawPowerSetting()`."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance The OpenThread instance structure."]
    #[doc = " @param[in]  aEnable   TRUE to enable or FALSE to disable the raw power setting."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully enabled/disabled the raw power setting."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This method is not implemented."]
    #[doc = ""]
    pub fn otPlatDiagRadioRawPowerSettingEnable(
        aInstance: *mut otInstance,
        aEnable: bool,
    ) -> otError;
}
extern "C" {
    #[doc = " Start/stop the platform layer to transmit continuous carrier wave."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance The OpenThread instance structure."]
    #[doc = " @param[in]  aEnable   TRUE to enable or FALSE to disable the platform layer to transmit continuous carrier wave."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             Successfully enabled/disabled ."]
    #[doc = " @retval OT_ERROR_INVALID_STATE    The radio was not in the Receive state."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This method is not implemented."]
    #[doc = ""]
    pub fn otPlatDiagRadioTransmitCarrier(aInstance: *mut otInstance, aEnable: bool) -> otError;
}
extern "C" {
    #[doc = " Get the power settings for the given channel."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance               The OpenThread instance structure."]
    #[doc = " @param[in]      aChannel                The radio channel."]
    #[doc = " @param[out]     aTargetPower            The target power in 0.01 dBm."]
    #[doc = " @param[out]     aActualPower            The actual power in 0.01 dBm."]
    #[doc = " @param[out]     aRawPowerSetting        A pointer to the raw power setting byte array."]
    #[doc = " @param[in,out]  aRawPowerSettingLength  On input, a pointer to the size of @p aRawPowerSetting."]
    #[doc = "                                         On output, a pointer to the length of the raw power setting data."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE             Successfully got the target power."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS     The @p aChannel is invalid, @aTargetPower, @p aActualPower, @p aRawPowerSetting or"]
    #[doc = "                                    @p aRawPowerSettingLength is NULL or @aRawPowerSettingLength is too short."]
    #[doc = " @retval  OT_ERROR_NOT_FOUND        The power settings for the @p aChannel was not found."]
    #[doc = " @retval  OT_ERROR_NOT_IMPLEMENTED  This method is not implemented."]
    #[doc = ""]
    pub fn otPlatDiagRadioGetPowerSettings(
        aInstance: *mut otInstance,
        aChannel: u8,
        aTargetPower: *mut i16,
        aActualPower: *mut i16,
        aRawPowerSetting: *mut u8,
        aRawPowerSettingLength: *mut u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Fill buffer with entropy."]
    #[doc = ""]
    #[doc = " This function MUST be implemented using a true random number generator (TRNG)."]
    #[doc = ""]
    #[doc = " @param[out]  aOutput              A pointer to where the true random values are placed.  Must not be NULL."]
    #[doc = " @param[in]   aOutputLength        Size of @p aBuffer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully filled @p aBuffer with true random values."]
    #[doc = " @retval OT_ERROR_FAILED        Failed to fill @p aBuffer with true random values."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aBuffer was set to NULL."]
    #[doc = ""]
    pub fn otPlatEntropyGet(aOutput: *mut u8, aOutputLength: u16) -> otError;
}
extern "C" {
    #[doc = " This function initializes the flash driver."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    pub fn otPlatFlashInit(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function gets the size of the swap space."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    #[doc = " @returns The size of the swap space in bytes."]
    #[doc = ""]
    pub fn otPlatFlashGetSwapSize(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " This function erases the swap space indicated by @p aSwapIndex."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   The OpenThread instance structure."]
    #[doc = " @param[in] aSwapIndex  A value in [0, 1] that indicates the swap space."]
    #[doc = ""]
    pub fn otPlatFlashErase(aInstance: *mut otInstance, aSwapIndex: u8);
}
extern "C" {
    #[doc = " This function reads @p aSize bytes into @p aData."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = " @param[in]  aSwapIndex  A value in [0, 1] that indicates the swap space."]
    #[doc = " @param[in]  aOffset     A byte offset within the swap space."]
    #[doc = " @param[out] aData       A pointer to the data buffer for reading."]
    #[doc = " @param[in]  aSize       Number of bytes to read."]
    #[doc = ""]
    pub fn otPlatFlashRead(
        aInstance: *mut otInstance,
        aSwapIndex: u8,
        aOffset: u32,
        aData: *mut ::std::os::raw::c_void,
        aSize: u32,
    );
}
extern "C" {
    #[doc = " This function writes @p aSize bytes from @p aData."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   The OpenThread instance structure."]
    #[doc = " @param[in]  aSwapIndex  A value in [0, 1] that indicates the swap space."]
    #[doc = " @param[in]  aOffset     A byte offset within the swap space."]
    #[doc = " @param[out] aData       A pointer to the data to write."]
    #[doc = " @param[in]  aSize       Number of bytes to write."]
    #[doc = ""]
    #[doc = ""]
    pub fn otPlatFlashWrite(
        aInstance: *mut otInstance,
        aSwapIndex: u8,
        aOffset: u32,
        aData: *const ::std::os::raw::c_void,
        aSize: u32,
    );
}
extern "C" {
    #[doc = " This method tells whether an infra interface has the given IPv6 address assigned."]
    #[doc = ""]
    #[doc = " @param[in]  aInfraIfIndex  The index of the infra interface."]
    #[doc = " @param[in]  aAddress       The IPv6 address."]
    #[doc = ""]
    #[doc = " @returns  TRUE if the infra interface has given IPv6 address assigned, FALSE otherwise."]
    #[doc = ""]
    pub fn otPlatInfraIfHasAddress(aInfraIfIndex: u32, aAddress: *const otIp6Address) -> bool;
}
extern "C" {
    #[doc = " This method sends an ICMPv6 Neighbor Discovery message on given infrastructure interface."]
    #[doc = ""]
    #[doc = " See RFC 4861: https://tools.ietf.org/html/rfc4861."]
    #[doc = ""]
    #[doc = " @param[in]  aInfraIfIndex  The index of the infrastructure interface this message is sent to."]
    #[doc = " @param[in]  aDestAddress   The destination address this message is sent to."]
    #[doc = " @param[in]  aBuffer        The ICMPv6 message buffer. The ICMPv6 checksum is left zero and the"]
    #[doc = "                            platform should do the checksum calculate."]
    #[doc = " @param[in]  aBufferLength  The length of the message buffer."]
    #[doc = ""]
    #[doc = " @note  Per RFC 4861, the implementation should send the message with IPv6 link-local source address"]
    #[doc = "        of interface @p aInfraIfIndex and IP Hop Limit 255."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully sent the ICMPv6 message."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to send the ICMPv6 message."]
    #[doc = ""]
    pub fn otPlatInfraIfSendIcmp6Nd(
        aInfraIfIndex: u32,
        aDestAddress: *const otIp6Address,
        aBuffer: *const u8,
        aBufferLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " The infra interface driver calls this method to notify OpenThread"]
    #[doc = " that an ICMPv6 Neighbor Discovery message is received."]
    #[doc = ""]
    #[doc = " See RFC 4861: https://tools.ietf.org/html/rfc4861."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      The OpenThread instance structure."]
    #[doc = " @param[in]  aInfraIfIndex  The index of the infrastructure interface on which the ICMPv6 message is received."]
    #[doc = " @param[in]  aSrcAddress    The source address this message is received from."]
    #[doc = " @param[in]  aBuffer        The ICMPv6 message buffer."]
    #[doc = " @param[in]  aBufferLength  The length of the ICMPv6 message buffer."]
    #[doc = ""]
    #[doc = " @note  Per RFC 4861, the caller should enforce that the source address MUST be a IPv6 link-local"]
    #[doc = "        address and the IP Hop Limit MUST be 255."]
    #[doc = ""]
    pub fn otPlatInfraIfRecvIcmp6Nd(
        aInstance: *mut otInstance,
        aInfraIfIndex: u32,
        aSrcAddress: *const otIp6Address,
        aBuffer: *const u8,
        aBufferLength: u16,
    );
}
extern "C" {
    #[doc = " The infra interface driver calls this method to notify OpenThread"]
    #[doc = " of the interface state changes."]
    #[doc = ""]
    #[doc = " It is fine for the platform to call to method even when the running state"]
    #[doc = " of the interface hasn't changed. In this case, the Routing Manager state is"]
    #[doc = " not affected."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          The OpenThread instance structure."]
    #[doc = " @param[in]  aInfraIfIndex      The index of the infrastructure interface."]
    #[doc = " @param[in]  aIsRunning         A boolean that indicates whether the infrastructure"]
    #[doc = "                                interface is running."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE           Successfully updated the infra interface status."]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  The Routing Manager is not initialized."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS   The @p aInfraIfIndex doesn't match the infra interface the"]
    #[doc = "                                  Routing Manager are initialized with."]
    #[doc = ""]
    pub fn otPlatInfraIfStateChanged(
        aInstance: *mut otInstance,
        aInfraIfIndex: u32,
        aIsRunning: bool,
    ) -> otError;
}
extern "C" {
    #[doc = " Send a request to discover the NAT64 prefix on the infrastructure interface with @p aInfraIfIndex."]
    #[doc = ""]
    #[doc = " OpenThread will call this method periodically to monitor the presence or change of NAT64 prefix."]
    #[doc = ""]
    #[doc = " @param[in]  aInfraIfIndex  The index of the infrastructure interface to discover the NAT64 prefix."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE    Successfully request NAT64 prefix discovery."]
    #[doc = " @retval  OT_ERROR_FAILED  Failed to request NAT64 prefix discovery."]
    #[doc = ""]
    pub fn otPlatInfraIfDiscoverNat64Prefix(aInfraIfIndex: u32) -> otError;
}
extern "C" {
    #[doc = " The infra interface driver calls this method to notify OpenThread that"]
    #[doc = " the discovery of NAT64 prefix is done."]
    #[doc = ""]
    #[doc = " This method is expected to be invoked after calling otPlatInfraIfDiscoverNat64Prefix."]
    #[doc = " If no NAT64 prefix is discovered, @p aIp6Prefix shall point to an empty prefix with zero length."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      The OpenThread instance structure."]
    #[doc = " @param[in]  aInfraIfIndex  The index of the infrastructure interface on which the NAT64 prefix is discovered."]
    #[doc = " @param[in]  aIp6Prefix     A pointer to NAT64 prefix."]
    #[doc = ""]
    pub fn otPlatInfraIfDiscoverNat64PrefixDone(
        aInstance: *mut otInstance,
        aInfraIfIndex: u32,
        aIp6Prefix: *const otIp6Prefix,
    );
}
extern "C" {
    #[doc = " Dynamically allocates new memory. On platforms that support it, should just redirect to calloc. For"]
    #[doc = " those that don't support calloc, should support the same functionality:"]
    #[doc = ""]
    #[doc = "   \"The calloc() function contiguously allocates enough space for count objects that are size bytes of"]
    #[doc = "   memory each and returns a pointer to the allocated memory. The allocated memory is filled with bytes"]
    #[doc = "   of value zero.\""]
    #[doc = ""]
    #[doc = " This function is required for OPENTHREAD_CONFIG_HEAP_EXTERNAL_ENABLE."]
    #[doc = ""]
    #[doc = " @param[in] aNum   The number of blocks to allocate"]
    #[doc = " @param[in] aSize  The size of each block to allocate"]
    #[doc = ""]
    #[doc = " @retval void*  The pointer to the front of the memory allocated"]
    #[doc = " @retval NULL   Failed to allocate the memory requested."]
    pub fn otPlatCAlloc(aNum: usize, aSize: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Frees memory that was dynamically allocated."]
    #[doc = ""]
    #[doc = " This function is required for OPENTHREAD_CONFIG_HEAP_EXTERNAL_ENABLE."]
    #[doc = ""]
    #[doc = " @param[in] aPtr  A pointer the memory blocks to free. The pointer may be NULL."]
    pub fn otPlatFree(aPtr: *mut ::std::os::raw::c_void);
}
#[doc = " This struct represents an OpenThread message buffer."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otMessageBuffer {
    #[doc = "< Pointer to the next buffer."]
    pub mNext: *mut otMessageBuffer,
}
impl Default for otMessageBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Initialize the platform implemented message pool."]
    #[doc = ""]
    #[doc = " This function is used when `OPENTHREAD_CONFIG_PLATFORM_MESSAGE_MANAGEMENT` is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance            A pointer to the OpenThread instance."]
    #[doc = " @param[in] aMinNumFreeBuffers   An uint16 containing the minimum number of free buffers desired by OpenThread."]
    #[doc = " @param[in] aBufferSize          The size in bytes of a buffer object."]
    #[doc = ""]
    pub fn otPlatMessagePoolInit(
        aInstance: *mut otInstance,
        aMinNumFreeBuffers: u16,
        aBufferSize: usize,
    );
}
extern "C" {
    #[doc = " Allocate a buffer from the platform managed buffer pool."]
    #[doc = ""]
    #[doc = " This function is used when `OPENTHREAD_CONFIG_PLATFORM_MESSAGE_MANAGEMENT` is enabled."]
    #[doc = ""]
    #[doc = " The returned buffer instance MUST have at least `aBufferSize` bytes (as specified in `otPlatMessagePoolInit()`)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance            A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the buffer or NULL if no buffers are available."]
    #[doc = ""]
    pub fn otPlatMessagePoolNew(aInstance: *mut otInstance) -> *mut otMessageBuffer;
}
extern "C" {
    #[doc = " This function is used to free a buffer back to the platform managed buffer pool."]
    #[doc = ""]
    #[doc = " This function is used when `OPENTHREAD_CONFIG_PLATFORM_MESSAGE_MANAGEMENT` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to the OpenThread instance."]
    #[doc = " @param[in]  aBuffer    The buffer to free."]
    #[doc = ""]
    pub fn otPlatMessagePoolFree(aInstance: *mut otInstance, aBuffer: *mut otMessageBuffer);
}
extern "C" {
    #[doc = " Get the number of free buffers."]
    #[doc = ""]
    #[doc = " This function is used when `OPENTHREAD_CONFIG_PLATFORM_MESSAGE_MANAGEMENT` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The number of buffers currently free and available to OpenThread."]
    #[doc = ""]
    pub fn otPlatMessagePoolNumFreeBuffers(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " This function performs a software reset on the platform, if supported."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    pub fn otPlatReset(aInstance: *mut otInstance);
}
pub const OT_PLAT_RESET_REASON_POWER_ON: otPlatResetReason = 0;
pub const OT_PLAT_RESET_REASON_EXTERNAL: otPlatResetReason = 1;
pub const OT_PLAT_RESET_REASON_SOFTWARE: otPlatResetReason = 2;
pub const OT_PLAT_RESET_REASON_FAULT: otPlatResetReason = 3;
pub const OT_PLAT_RESET_REASON_CRASH: otPlatResetReason = 4;
pub const OT_PLAT_RESET_REASON_ASSERT: otPlatResetReason = 5;
pub const OT_PLAT_RESET_REASON_OTHER: otPlatResetReason = 6;
pub const OT_PLAT_RESET_REASON_UNKNOWN: otPlatResetReason = 7;
pub const OT_PLAT_RESET_REASON_WATCHDOG: otPlatResetReason = 8;
pub const OT_PLAT_RESET_REASON_COUNT: otPlatResetReason = 9;
#[doc = " Enumeration of possible reset reason codes."]
#[doc = ""]
#[doc = " These are in the same order as the Spinel reset reason codes."]
#[doc = ""]
pub type otPlatResetReason = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function returns the reason for the last platform reset."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = ""]
    pub fn otPlatGetResetReason(aInstance: *mut otInstance) -> otPlatResetReason;
}
extern "C" {
    #[doc = " This function provides a platform specific implementation for assert."]
    #[doc = ""]
    #[doc = " @param[in] aFilename    The name of the file where the assert occurred."]
    #[doc = " @param[in] aLineNumber  The line number in the file where the assert occurred."]
    #[doc = ""]
    pub fn otPlatAssertFail(
        aFilename: *const ::std::os::raw::c_char,
        aLineNumber: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " This function performs a platform specific operation to wake the host MCU."]
    #[doc = " This is used only for NCP configurations."]
    #[doc = ""]
    pub fn otPlatWakeHost();
}
#[doc = " NCP's MCU stays on and active all the time."]
#[doc = ""]
#[doc = " When the NCP's desired power state is set to `ON`, host can send messages to NCP without requiring any \"poke\" or"]
#[doc = " external triggers."]
#[doc = ""]
#[doc = " @note The `ON` power state only determines the MCU's power mode and is not related to radio's state."]
#[doc = ""]
pub const OT_PLAT_MCU_POWER_STATE_ON: otPlatMcuPowerState = 0;
#[doc = " NCP's MCU can enter low-power (energy-saving) state."]
#[doc = ""]
#[doc = " When the NCP's desired power state is set to `LOW_POWER`, host is expected to \"poke\" the NCP (e.g., an external"]
#[doc = " trigger like an interrupt) before it can communicate with the NCP (send a message to the NCP). The \"poke\""]
#[doc = " mechanism is determined by the platform code (based on NCP's interface to the host)."]
#[doc = ""]
#[doc = " While power state is set to `LOW_POWER`, NCP can still (at any time) send messages to host. Note that receiving"]
#[doc = " a message from the NCP does NOT indicate that the NCP's power state has changed, i.e., host is expected to"]
#[doc = " continue to \"poke\" when it wants to talk to the NCP until the power state is explicitly changed (by a successful"]
#[doc = " call to `otPlatSetMcuPowerState()` changing the state to `ON`)."]
#[doc = ""]
#[doc = " @note The `LOW_POWER` power state only determines the MCU's power mode and is not related to radio's state"]
#[doc = " (radio is managed by OpenThread core and device role, e.g., device being sleepy or not."]
#[doc = ""]
pub const OT_PLAT_MCU_POWER_STATE_LOW_POWER: otPlatMcuPowerState = 1;
#[doc = " NCP is fully off."]
#[doc = ""]
#[doc = " An NCP hardware reset (via a RESET pin) is required to bring the NCP back to `SPINEL_MCU_POWER_STATE_ON`."]
#[doc = " RAM is not retained after reset."]
#[doc = ""]
pub const OT_PLAT_MCU_POWER_STATE_OFF: otPlatMcuPowerState = 2;
#[doc = " Enumeration of micro-controller's power states."]
#[doc = ""]
#[doc = " These values are used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL` is enabled."]
#[doc = ""]
#[doc = " The power state specifies the desired power state of NCP's micro-controller (MCU) when the underlying platform's"]
#[doc = " operating system enters idle mode (i.e., all active tasks/events are processed and the MCU can potentially enter a"]
#[doc = " energy-saving power state)."]
#[doc = ""]
#[doc = " The power state primarily determines how the host should interact with the NCP and whether the host needs an"]
#[doc = " external trigger (a \"poke\") to NCP before it can communicate with the NCP or not."]
#[doc = ""]
#[doc = " After a reset, the MCU power state MUST be `OT_PLAT_POWER_STATE_ON`."]
#[doc = ""]
pub type otPlatMcuPowerState = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function sets the desired MCU power state."]
    #[doc = ""]
    #[doc = " This is only applicable and used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL`"]
    #[doc = " is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance      A pointer to OpenThread instance."]
    #[doc = " @param[in] aState         The new MCU power state."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     The power state updated successfully."]
    #[doc = " @retval OT_ERROR_FAILED   The given MCU power state is not supported by the platform."]
    #[doc = ""]
    pub fn otPlatSetMcuPowerState(
        aInstance: *mut otInstance,
        aState: otPlatMcuPowerState,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the current desired MCU power state."]
    #[doc = ""]
    #[doc = " This is only applicable and used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL`"]
    #[doc = " is enabled."]
    #[doc = ""]
    #[doc = " After a reset, the power state MUST return `OT_PLAT_POWER_STATE_ON`. During operation, power state SHOULD only"]
    #[doc = " change through an explicit successful call to `otPlatSetMcuPowerState()`."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The current power state."]
    #[doc = ""]
    pub fn otPlatGetMcuPowerState(aInstance: *mut otInstance) -> otPlatMcuPowerState;
}
extern "C" {
    #[doc = " This function exports status information to OTNS."]
    #[doc = ""]
    #[doc = " The status information is represented by a null-terminated string with format recognizable by OTNS."]
    #[doc = " Each call to `otPlatOtnsStatus` can send multiple statuses, separated by ';', e.x. \"parid=577fbc37;lrid=5\"."]
    #[doc = " Each status contains key and value separated by '='."]
    #[doc = " Status value can be further separated into multiple fields using ',',"]
    #[doc = " e.x. \"ping_request=fdde:ad00:beef:0:459e:d7b4:b65e:5480,4,112000\"."]
    #[doc = ""]
    #[doc = " New statuses should follow these conventions."]
    #[doc = ""]
    #[doc = " Currently, OTNS only supports virtual time simulation."]
    #[doc = ""]
    #[doc = " @param[in]  aStatus  The status string."]
    #[doc = ""]
    pub fn otPlatOtnsStatus(aStatus: *const ::std::os::raw::c_char);
}
#[doc = "< Active Operational Dataset."]
pub const OT_SETTINGS_KEY_ACTIVE_DATASET: _bindgen_ty_12 = 1;
#[doc = "< Pending Operational Dataset."]
pub const OT_SETTINGS_KEY_PENDING_DATASET: _bindgen_ty_12 = 2;
#[doc = "< Thread network information."]
pub const OT_SETTINGS_KEY_NETWORK_INFO: _bindgen_ty_12 = 3;
#[doc = "< Parent information."]
pub const OT_SETTINGS_KEY_PARENT_INFO: _bindgen_ty_12 = 4;
#[doc = "< Child information."]
pub const OT_SETTINGS_KEY_CHILD_INFO: _bindgen_ty_12 = 5;
#[doc = "< SLAAC key to generate semantically opaque IID."]
pub const OT_SETTINGS_KEY_SLAAC_IID_SECRET_KEY: _bindgen_ty_12 = 7;
#[doc = "< Duplicate Address Detection (DAD) information."]
pub const OT_SETTINGS_KEY_DAD_INFO: _bindgen_ty_12 = 8;
#[doc = "< SRP client ECDSA public/private key pair."]
pub const OT_SETTINGS_KEY_SRP_ECDSA_KEY: _bindgen_ty_12 = 11;
#[doc = "< The SRP client info (selected SRP server address)."]
pub const OT_SETTINGS_KEY_SRP_CLIENT_INFO: _bindgen_ty_12 = 12;
#[doc = "< The SRP server info (UDP port)."]
pub const OT_SETTINGS_KEY_SRP_SERVER_INFO: _bindgen_ty_12 = 13;
#[doc = "< BR ULA prefix."]
pub const OT_SETTINGS_KEY_BR_ULA_PREFIX: _bindgen_ty_12 = 15;
#[doc = "< BR local on-link prefixes."]
pub const OT_SETTINGS_KEY_BR_ON_LINK_PREFIXES: _bindgen_ty_12 = 16;
pub const OT_SETTINGS_KEY_VENDOR_RESERVED_MIN: _bindgen_ty_12 = 32768;
pub const OT_SETTINGS_KEY_VENDOR_RESERVED_MAX: _bindgen_ty_12 = 65535;
#[doc = " This enumeration defines the keys of settings."]
#[doc = ""]
#[doc = " Note: When adding a new settings key, if the settings corresponding to the key contains security sensitive"]
#[doc = "       information, the developer MUST add the key to the array `aSensitiveKeys` which is passed in"]
#[doc = "       `otPlatSettingsInit()`."]
#[doc = ""]
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Performs any initialization for the settings subsystem, if necessary."]
    #[doc = ""]
    #[doc = " This function also sets the sensitive keys that should be stored in the secure area."]
    #[doc = ""]
    #[doc = " Note that the memory pointed by @p aSensitiveKeys MUST not be released before @p aInstance is destroyed."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance             The OpenThread instance structure."]
    #[doc = " @param[in]  aSensitiveKeys        A pointer to an array containing the list of sensitive keys. May be NULL only if"]
    #[doc = "                                   @p aSensitiveKeysLength is 0, which means that there is no sensitive keys."]
    #[doc = " @param[in]  aSensitiveKeysLength  The number of entries in the @p aSensitiveKeys array."]
    #[doc = ""]
    pub fn otPlatSettingsInit(
        aInstance: *mut otInstance,
        aSensitiveKeys: *const u16,
        aSensitiveKeysLength: u16,
    );
}
extern "C" {
    #[doc = " Performs any de-initialization for the settings subsystem, if necessary."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance The OpenThread instance structure."]
    #[doc = ""]
    pub fn otPlatSettingsDeinit(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Fetches the value of a setting."]
    #[doc = ""]
    #[doc = " This function fetches the value of the setting identified"]
    #[doc = " by @p aKey and write it to the memory pointed to by aValue."]
    #[doc = " It then writes the length to the integer pointed to by"]
    #[doc = " @p aValueLength. The initial value of @p aValueLength is the"]
    #[doc = " maximum number of bytes to be written to @p aValue."]
    #[doc = ""]
    #[doc = " This function can be used to check for the existence of"]
    #[doc = " a key without fetching the value by setting @p aValue and"]
    #[doc = " @p aValueLength to NULL. You can also check the length of"]
    #[doc = " the setting without fetching it by setting only aValue"]
    #[doc = " to NULL."]
    #[doc = ""]
    #[doc = " Note that the underlying storage implementation is not"]
    #[doc = " required to maintain the order of settings with multiple"]
    #[doc = " values. The order of such values MAY change after ANY"]
    #[doc = " write operation to the store."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance     The OpenThread instance structure."]
    #[doc = " @param[in]      aKey          The key associated with the requested setting."]
    #[doc = " @param[in]      aIndex        The index of the specific item to get."]
    #[doc = " @param[out]     aValue        A pointer to where the value of the setting should be written. May be set to NULL if"]
    #[doc = "                               just testing for the presence or length of a setting."]
    #[doc = " @param[in,out]  aValueLength  A pointer to the length of the value. When called, this pointer should point to an"]
    #[doc = "                               integer containing the maximum value size that can be written to @p aValue. At return,"]
    #[doc = "                               the actual length of the setting is written. This may be set to NULL if performing"]
    #[doc = "                               a presence check."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             The given setting was found and fetched successfully."]
    #[doc = " @retval OT_ERROR_NOT_FOUND        The given setting was not found in the setting store."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform."]
    pub fn otPlatSettingsGet(
        aInstance: *mut otInstance,
        aKey: u16,
        aIndex: ::std::os::raw::c_int,
        aValue: *mut u8,
        aValueLength: *mut u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets or replaces the value of a setting."]
    #[doc = ""]
    #[doc = " This function sets or replaces the value of a setting"]
    #[doc = " identified by @p aKey."]
    #[doc = ""]
    #[doc = " Calling this function successfully may cause unrelated"]
    #[doc = " settings with multiple values to be reordered."]
    #[doc = ""]
    #[doc = " OpenThread stack guarantees to use `otPlatSettingsSet()`"]
    #[doc = " method for a @p aKey that was either previously set using"]
    #[doc = " `otPlatSettingsSet()` (i.e., contains a single value) or"]
    #[doc = " is empty and/or fully deleted (contains no value)."]
    #[doc = ""]
    #[doc = " Platform layer can rely and use this fact for optimizing"]
    #[doc = " its implementation."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     The OpenThread instance structure."]
    #[doc = " @param[in]  aKey          The key associated with the setting to change."]
    #[doc = " @param[in]  aValue        A pointer to where the new value of the setting should be read from. MUST NOT be NULL if"]
    #[doc = "                           @p aValueLength is non-zero."]
    #[doc = " @param[in]  aValueLength  The length of the data pointed to by aValue. May be zero."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             The given setting was changed or staged."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform."]
    #[doc = " @retval OT_ERROR_NO_BUFS          No space remaining to store the given setting."]
    pub fn otPlatSettingsSet(
        aInstance: *mut otInstance,
        aKey: u16,
        aValue: *const u8,
        aValueLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Adds a value to a setting."]
    #[doc = ""]
    #[doc = " This function adds the value to a setting"]
    #[doc = " identified by @p aKey, without replacing any existing"]
    #[doc = " values."]
    #[doc = ""]
    #[doc = " Note that the underlying implementation is not required"]
    #[doc = " to maintain the order of the items associated with a"]
    #[doc = " specific key. The added value may be added to the end,"]
    #[doc = " the beginning, or even somewhere in the middle. The order"]
    #[doc = " of any pre-existing values may also change."]
    #[doc = ""]
    #[doc = " Calling this function successfully may cause unrelated"]
    #[doc = " settings with multiple values to be reordered."]
    #[doc = ""]
    #[doc = " OpenThread stack guarantees to use `otPlatSettingsAdd()`"]
    #[doc = " method for a @p aKey that was either previously managed by"]
    #[doc = " `otPlatSettingsAdd()` (i.e., contains one or more items) or"]
    #[doc = " is empty and/or fully deleted (contains no value)."]
    #[doc = ""]
    #[doc = " Platform layer can rely and use this fact for optimizing"]
    #[doc = " its implementation."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     The OpenThread instance structure."]
    #[doc = " @param[in]  aKey          The key associated with the setting to change."]
    #[doc = " @param[in]  aValue        A pointer to where the new value of the setting should be read from. MUST NOT be NULL"]
    #[doc = "                           if @p aValueLength is non-zero."]
    #[doc = " @param[in]  aValueLength  The length of the data pointed to by @p aValue. May be zero."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             The given setting was added or staged to be added."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform."]
    #[doc = " @retval OT_ERROR_NO_BUFS          No space remaining to store the given setting."]
    pub fn otPlatSettingsAdd(
        aInstance: *mut otInstance,
        aKey: u16,
        aValue: *const u8,
        aValueLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes a setting from the setting store."]
    #[doc = ""]
    #[doc = " This function deletes a specific value from the"]
    #[doc = " setting identified by aKey from the settings store."]
    #[doc = ""]
    #[doc = " Note that the underlying implementation is not required"]
    #[doc = " to maintain the order of the items associated with a"]
    #[doc = " specific key."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    #[doc = " @param[in] aKey       The key associated with the requested setting."]
    #[doc = " @param[in] aIndex     The index of the value to be removed. If set to -1, all values for this @p aKey will be"]
    #[doc = "                       removed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             The given key and index was found and removed successfully."]
    #[doc = " @retval OT_ERROR_NOT_FOUND        The given key or index was not found in the setting store."]
    #[doc = " @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform."]
    pub fn otPlatSettingsDelete(
        aInstance: *mut otInstance,
        aKey: u16,
        aIndex: ::std::os::raw::c_int,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes all settings from the setting store."]
    #[doc = ""]
    #[doc = " This function deletes all settings from the settings"]
    #[doc = " store, resetting it to its initial factory state."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatSettingsWipe(aInstance: *mut otInstance);
}
#[doc = " Indicates that a SPI transaction has completed with the given length. The data written to the slave has been written"]
#[doc = " to the pointer indicated by the `aInputBuf` argument to the previous call to `otPlatSpiSlavePrepareTransaction()`."]
#[doc = ""]
#[doc = " Once this function is called, `otPlatSpiSlavePrepareTransaction()` is invalid and must be called again for the next"]
#[doc = " transaction to be valid."]
#[doc = ""]
#[doc = " Note that this function is always called at the end of a transaction, even if `otPlatSpiSlavePrepareTransaction()`"]
#[doc = " has not yet been called. In such cases, `aOutputBufLen` and `aInputBufLen` will be zero."]
#[doc = ""]
#[doc = " This callback can be called from ISR context. The return value from this function indicates if any further"]
#[doc = " processing is required. If `TRUE` is returned the platform spi-slave driver implementation must invoke the"]
#[doc = " transaction process callback (`aProcessCallback` set in `otPlatSpiSlaveEnable()`) which unlike this callback must be"]
#[doc = " called from the same OS context that any other OpenThread API/callback is called."]
#[doc = ""]
#[doc = " @param[in] aContext           Context pointer passed into `otPlatSpiSlaveEnable()`."]
#[doc = " @param[in] aOutputBuf         Value of `aOutputBuf` from last call to `otPlatSpiSlavePrepareTransaction()`."]
#[doc = " @param[in] aOutputBufLen      Value of `aOutputBufLen` from last call to `otPlatSpiSlavePrepareTransaction()`."]
#[doc = " @param[in] aInputBuf          Value of aInputBuf from last call to `otPlatSpiSlavePrepareTransaction()`."]
#[doc = " @param[in] aInputBufLen       Value of aInputBufLen from last call to `otPlatSpiSlavePrepareTransaction()`"]
#[doc = " @param[in] aTransactionLength Length of the completed transaction, in bytes."]
#[doc = ""]
#[doc = " @returns  TRUE if after this call returns the platform should invoke the process callback `aProcessCallback`,"]
#[doc = "           FALSE if there is nothing to process and no need to invoke the process callback."]
pub type otPlatSpiSlaveTransactionCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aOutputBuf: *mut u8,
        aOutputBufLen: u16,
        aInputBuf: *mut u8,
        aInputBufLen: u16,
        aTransactionLength: u16,
    ) -> bool,
>;
#[doc = " Invoked after a transaction complete callback is called and returns `TRUE` to do any further processing required."]
#[doc = " Unlike `otPlatSpiSlaveTransactionCompleteCallback` which can be called from any OS context (e.g., ISR), this"]
#[doc = " callback MUST be called from the same OS context as any other OpenThread API/callback."]
#[doc = ""]
#[doc = " @param[in] aContext           Context pointer passed into `otPlatSpiSlaveEnable()`."]
#[doc = ""]
pub type otPlatSpiSlaveTransactionProcessCallback =
    ::std::option::Option<unsafe extern "C" fn(aContext: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Initialize the SPI slave interface."]
    #[doc = ""]
    #[doc = " Note that SPI slave is not fully ready until a transaction is prepared using `otPlatSPISlavePrepareTransaction()`."]
    #[doc = ""]
    #[doc = " If `otPlatSPISlavePrepareTransaction() is not called before the master begins a transaction, the resulting SPI"]
    #[doc = " transaction will send all `0xFF` bytes and discard all received bytes."]
    #[doc = ""]
    #[doc = " @param[in] aCompleteCallback  Pointer to transaction complete callback."]
    #[doc = " @param[in] aProcessCallback   Pointer to process callback."]
    #[doc = " @param[in] aContext           Context pointer to be passed to callbacks."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully enabled the SPI Slave interface."]
    #[doc = " @retval OT_ERROR_ALREADY  SPI Slave interface is already enabled."]
    #[doc = " @retval OT_ERROR_FAILED   Failed to enable the SPI Slave interface."]
    #[doc = ""]
    pub fn otPlatSpiSlaveEnable(
        aCompleteCallback: otPlatSpiSlaveTransactionCompleteCallback,
        aProcessCallback: otPlatSpiSlaveTransactionProcessCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Shutdown and disable the SPI slave interface."]
    pub fn otPlatSpiSlaveDisable();
}
extern "C" {
    #[doc = " Prepare data for the next SPI transaction. Data pointers MUST remain valid until the transaction complete callback"]
    #[doc = " is called by the SPI slave driver, or until after the next call to `otPlatSpiSlavePrepareTransaction()`."]
    #[doc = ""]
    #[doc = " This function may be called more than once before the SPI master initiates the transaction. Each *successful* call"]
    #[doc = " to this function will cause the previous values from earlier calls to be discarded."]
    #[doc = ""]
    #[doc = " Not calling this function after a completed transaction is the same as if this function was previously called with"]
    #[doc = " both buffer lengths set to zero and `aRequestTransactionFlag` set to `false`."]
    #[doc = ""]
    #[doc = " Once `aOutputBufLen` bytes of `aOutputBuf` has been clocked out, the MISO pin shall be set high until the master"]
    #[doc = " finishes the SPI transaction. This is the functional equivalent of padding the end of `aOutputBuf` with `0xFF` bytes"]
    #[doc = " out to the length of the transaction."]
    #[doc = ""]
    #[doc = " Once `aInputBufLen` bytes of aInputBuf have been clocked in from MOSI, all subsequent values from the MOSI pin are"]
    #[doc = " ignored until the SPI master finishes the transaction."]
    #[doc = ""]
    #[doc = " Note that even if `aInputBufLen` or `aOutputBufLen` (or both) are exhausted before the SPI master finishes a"]
    #[doc = " transaction, the ongoing size of the transaction must still be kept track of to be passed to the transaction"]
    #[doc = " complete callback. For example, if `aInputBufLen` is equal to 10 and `aOutputBufLen` equal to 20 and the SPI master"]
    #[doc = " clocks out 30 bytes, the value 30 is passed to the transaction complete callback."]
    #[doc = ""]
    #[doc = " If a `NULL` pointer is passed in as `aOutputBuf` or `aInputBuf` it means that that buffer pointer should not change"]
    #[doc = " from its previous/current value. In this case, the corresponding length argument should be ignored. For example,"]
    #[doc = " `otPlatSpiSlavePrepareTransaction(NULL, 0, aInputBuf, aInputLen, false)` changes the input buffer pointer and its"]
    #[doc = " length but keeps the output buffer pointer same as before."]
    #[doc = ""]
    #[doc = " Any call to this function while a transaction is in progress will cause all of the arguments to be ignored and the"]
    #[doc = " return value to be `OT_ERROR_BUSY`."]
    #[doc = ""]
    #[doc = " @param[in] aOutputBuf              Data to be written to MISO pin"]
    #[doc = " @param[in] aOutputBufLen           Size of the output buffer, in bytes"]
    #[doc = " @param[in] aInputBuf               Data to be read from MOSI pin"]
    #[doc = " @param[in] aInputBufLen            Size of the input buffer, in bytes"]
    #[doc = " @param[in] aRequestTransactionFlag Set to true if host interrupt should be set"]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Transaction was successfully prepared."]
    #[doc = " @retval OT_ERROR_BUSY           A transaction is currently in progress."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  otPlatSpiSlaveEnable() hasn't been called."]
    #[doc = ""]
    pub fn otPlatSpiSlavePrepareTransaction(
        aOutputBuf: *mut u8,
        aOutputBufLen: u16,
        aInputBuf: *mut u8,
        aInputBufLen: u16,
        aRequestTransactionFlag: bool,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the current time (64bits width)."]
    #[doc = ""]
    #[doc = " @returns The current time in microseconds."]
    #[doc = ""]
    pub fn otPlatTimeGet() -> u64;
}
extern "C" {
    #[doc = " Get the device's XTAL accuracy."]
    #[doc = ""]
    #[doc = " @returns The device's XTAL accuracy, in ppm."]
    #[doc = ""]
    pub fn otPlatTimeGetXtalAccuracy() -> u16;
}
extern "C" {
    #[doc = " This function initializes and enables TREL platform layer."]
    #[doc = ""]
    #[doc = " Upon this call, the platform layer MUST perform the following:"]
    #[doc = ""]
    #[doc = " 1) TREL platform layer MUST open a UDP socket to listen for and receive TREL messages from peers. The socket is"]
    #[doc = " bound to an ephemeral port number chosen by the platform layer. The port number MUST be returned in @p aUdpPort."]
    #[doc = " The socket is also bound to network interface(s) on which TREL is to be supported. The socket and the chosen port"]
    #[doc = " should stay valid while TREL is enabled."]
    #[doc = ""]
    #[doc = " 2) Platform layer MUST initiate an ongoing DNS-SD browse on the service name \"_trel._udp\" within the local browsing"]
    #[doc = " domain to discover other devices supporting TREL. The ongoing browse will produce two different types of events:"]
    #[doc = " \"add\" events and \"remove\" events.  When the browse is started, it should produce an \"add\" event for every TREL peer"]
    #[doc = " currently present on the network.  Whenever a TREL peer goes offline, a \"remove\" event should be produced. \"remove\""]
    #[doc = " events are not guaranteed, however. When a TREL service instance is discovered, a new ongoing DNS-SD query for an"]
    #[doc = " AAAA record should be started on the hostname indicated in the SRV record of the discovered instance. If multiple"]
    #[doc = " host IPv6 addressees are discovered for a peer, one with highest scope among all addresses MUST be reported (if"]
    #[doc = " there are multiple address at same scope, one must be selected randomly)."]
    #[doc = ""]
    #[doc = " TREL platform MUST signal back the discovered peer info using `otPlatTrelHandleDiscoveredPeerInfo()` callback. This"]
    #[doc = " callback MUST be invoked when a new peer is discovered, when there is a change in an existing entry (e.g., new"]
    #[doc = " TXT record or new port number or new IPv6 address), or when the peer is removed."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  The OpenThread instance."]
    #[doc = " @param[out] aUdpPort   A pointer to return the selected port number by platform layer."]
    #[doc = ""]
    pub fn otPlatTrelEnable(aInstance: *mut otInstance, aUdpPort: *mut u16);
}
extern "C" {
    #[doc = " This function disables TREL platform layer."]
    #[doc = ""]
    #[doc = " After this call, the platform layer MUST stop DNS-SD browse on the service name \"_trel._udp\", stop advertising the"]
    #[doc = " TREL DNS-SD service (from `otPlatTrelRegisterService()`) and MUST close the UDP socket used to receive TREL messages."]
    #[doc = ""]
    #[doc = " @pram[in]  aInstance  The OpenThread instance."]
    #[doc = ""]
    pub fn otPlatTrelDisable(aInstance: *mut otInstance);
}
#[doc = " This structure represents a TREL peer info discovered using DNS-SD browse on the service name \"_trel._udp\"."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otPlatTrelPeerInfo {
    #[doc = " This boolean flag indicates whether the entry is being removed or added."]
    #[doc = ""]
    #[doc = " - TRUE indicates that peer is removed."]
    #[doc = " - FALSE indicates that it is a new entry or an update to an existing entry."]
    #[doc = ""]
    pub mRemoved: bool,
    #[doc = " The TXT record data (encoded as specified by DNS-SD) from the SRV record of the discovered TREL peer service"]
    #[doc = " instance."]
    #[doc = ""]
    pub mTxtData: *const u8,
    #[doc = "< Number of bytes in @p mTxtData buffer."]
    pub mTxtLength: u16,
    #[doc = " The TREL peer socket address (IPv6 address and port number)."]
    #[doc = ""]
    #[doc = " The port number is determined from the SRV record of the discovered TREL peer service instance. The IPv6 address"]
    #[doc = " is determined from the DNS-SD query for AAAA records on the hostname indicated in the SRV record of the"]
    #[doc = " discovered service instance. If multiple host IPv6 addressees are discovered, one with highest scope is used."]
    #[doc = ""]
    pub mSockAddr: otSockAddr,
}
impl Default for otPlatTrelPeerInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This is a callback function from platform layer to report a discovered TREL peer info."]
    #[doc = ""]
    #[doc = " @note The @p aInfo structure and its content (e.g., the `mTxtData` buffer) does not need to persist after returning"]
    #[doc = " from this call. OpenThread code will make a copy of all the info it needs."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   The OpenThread instance."]
    #[doc = " @param[in] aInfo       A pointer to the TREL peer info."]
    #[doc = ""]
    pub fn otPlatTrelHandleDiscoveredPeerInfo(
        aInstance: *mut otInstance,
        aInfo: *const otPlatTrelPeerInfo,
    );
}
extern "C" {
    #[doc = " This function registers a new service to be advertised using DNS-SD [RFC6763]."]
    #[doc = ""]
    #[doc = " The service name is \"_trel._udp\". The platform should use its own hostname, which when combined with the service"]
    #[doc = " name and the local DNS-SD domain name will produce the full service instance name, for example"]
    #[doc = " \"example-host._trel._udp.local.\"."]
    #[doc = ""]
    #[doc = " The domain under which the service instance name appears will be 'local' for mDNS, and will be whatever domain is"]
    #[doc = " used for service registration in the case of a non-mDNS local DNS-SD service."]
    #[doc = ""]
    #[doc = " A subsequent call to this function updates the previous service. It is used to update the TXT record data and/or the"]
    #[doc = " port number."]
    #[doc = ""]
    #[doc = " The @p aTxtData buffer is not persisted after the return from this function. The platform layer MUST NOT keep the"]
    #[doc = " pointer and instead copy the content if needed."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   The OpenThread instance."]
    #[doc = " @param[in] aPort       The port number to include in the SRV record of the advertised service."]
    #[doc = " @param[in] aTxtData    A pointer to the TXT record data (encoded) to be include in the advertised service."]
    #[doc = " @param[in] aTxtLength  The length of @p aTxtData (number of bytes)."]
    #[doc = ""]
    #[doc = ""]
    pub fn otPlatTrelRegisterService(
        aInstance: *mut otInstance,
        aPort: u16,
        aTxtData: *const u8,
        aTxtLength: u8,
    );
}
extern "C" {
    #[doc = " This function requests a TREL UDP packet to be sent to a given destination."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        The OpenThread instance structure."]
    #[doc = " @param[in] aUdpPayload      A pointer to UDP payload."]
    #[doc = " @param[in] aUdpPayloadLen   The payload length (number of bytes)."]
    #[doc = " @param[in] aDestSockAddr    The destination socket address."]
    #[doc = ""]
    pub fn otPlatTrelSend(
        aInstance: *mut otInstance,
        aUdpPayload: *const u8,
        aUdpPayloadLen: u16,
        aDestSockAddr: *const otSockAddr,
    );
}
extern "C" {
    #[doc = " This function is a callback from platform to notify of a received TREL UDP packet."]
    #[doc = ""]
    #[doc = " @note The buffer content (up to its specified length) may get changed during processing by OpenThread core (e.g.,"]
    #[doc = " decrypted in place), so the platform implementation should expect that after returning from this function the"]
    #[doc = " @p aBuffer content may have been altered."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        The OpenThread instance structure."]
    #[doc = " @param[in] aBuffer          A buffer containing the received UDP payload."]
    #[doc = " @param[in] aLength          UDP payload length (number of bytes)."]
    #[doc = ""]
    pub fn otPlatTrelHandleReceived(aInstance: *mut otInstance, aBuffer: *mut u8, aLength: u16);
}
#[doc = " This callback allows OpenThread to provide specific handlers for certain UDP messages."]
#[doc = ""]
#[doc = " @retval  true    The message is handled by this receiver and should not be further processed."]
#[doc = " @retval  false   The message is not handled by this receiver."]
#[doc = ""]
pub type otUdpHandler = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aMessage: *const otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> bool,
>;
#[doc = " This structure represents a UDP receiver."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otUdpReceiver {
    #[doc = "< A pointer to the next UDP receiver (internal use only)."]
    pub mNext: *mut otUdpReceiver,
    #[doc = "< A function pointer to the receiver callback."]
    pub mHandler: otUdpHandler,
    #[doc = "< A pointer to application-specific context."]
    pub mContext: *mut ::std::os::raw::c_void,
}
impl Default for otUdpReceiver {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function adds a UDP receiver."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aUdpReceiver    A pointer to the UDP receiver."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE       The receiver is successfully added."]
    #[doc = " @retval  OT_ERROR_ALREADY    The UDP receiver was already added."]
    #[doc = ""]
    pub fn otUdpAddReceiver(
        aInstance: *mut otInstance,
        aUdpReceiver: *mut otUdpReceiver,
    ) -> otError;
}
extern "C" {
    #[doc = " This function removes a UDP receiver."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aUdpReceiver    A pointer to the UDP receiver."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE       The receiver is successfully removed."]
    #[doc = " @retval  OT_ERROR_NOT_FOUND  The UDP receiver was not added."]
    #[doc = ""]
    pub fn otUdpRemoveReceiver(
        aInstance: *mut otInstance,
        aUdpReceiver: *mut otUdpReceiver,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends a UDP message without socket."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage      A pointer to a message without UDP header."]
    #[doc = " @param[in]  aMessageInfo  A pointer to a message info associated with @p aMessage."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE     Successfully enqueued the message into an output interface."]
    #[doc = " @retval OT_ERROR_NO_BUFS  Insufficient available buffer to add the IPv6 headers."]
    #[doc = ""]
    pub fn otUdpSendDatagram(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *mut otMessageInfo,
    ) -> otError;
}
#[doc = " This callback allows OpenThread to inform the application of a received UDP message."]
#[doc = ""]
pub type otUdpReceive = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ),
>;
#[doc = " This structure represents a UDP socket."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otUdpSocket {
    #[doc = "< The local IPv6 socket address."]
    pub mSockName: otSockAddr,
    #[doc = "< The peer IPv6 socket address."]
    pub mPeerName: otSockAddr,
    #[doc = "< A function pointer to the application callback."]
    pub mHandler: otUdpReceive,
    #[doc = "< A pointer to application-specific context."]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< A handle to platform's UDP."]
    pub mHandle: *mut ::std::os::raw::c_void,
    #[doc = "< A pointer to the next UDP socket (internal use only)."]
    pub mNext: *mut otUdpSocket,
}
impl Default for otUdpSocket {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Unspecified network interface."]
pub const OT_NETIF_UNSPECIFIED: otNetifIdentifier = 0;
#[doc = "< The Thread interface."]
pub const OT_NETIF_THREAD: otNetifIdentifier = 1;
#[doc = "< The Backbone interface."]
pub const OT_NETIF_BACKBONE: otNetifIdentifier = 2;
#[doc = " This enumeration defines the OpenThread network interface identifiers."]
#[doc = ""]
pub type otNetifIdentifier = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Allocate a new message buffer for sending a UDP message."]
    #[doc = ""]
    #[doc = " @note If @p aSettings is 'NULL', the link layer security is enabled and the message priority is set to"]
    #[doc = " OT_MESSAGE_PRIORITY_NORMAL by default."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSettings  A pointer to the message settings or NULL to use default settings."]
    #[doc = ""]
    #[doc = " @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid."]
    #[doc = ""]
    #[doc = " @sa otMessageFree"]
    #[doc = ""]
    pub fn otUdpNewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Open a UDP/IPv6 socket."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSocket    A pointer to a UDP socket structure."]
    #[doc = " @param[in]  aCallback  A pointer to the application callback function."]
    #[doc = " @param[in]  aContext   A pointer to application-specific context."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully opened the socket."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to open the socket."]
    #[doc = ""]
    pub fn otUdpOpen(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aCallback: otUdpReceive,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Check if a UDP socket is open."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSocket    A pointer to a UDP socket structure."]
    #[doc = ""]
    #[doc = " @returns Whether the UDP socket is open."]
    #[doc = ""]
    pub fn otUdpIsOpen(aInstance: *mut otInstance, aSocket: *const otUdpSocket) -> bool;
}
extern "C" {
    #[doc = " Close a UDP/IPv6 socket."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSocket    A pointer to a UDP socket structure."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE   Successfully closed the socket."]
    #[doc = " @retval OT_ERROR_FAILED Failed to close UDP Socket."]
    #[doc = ""]
    pub fn otUdpClose(aInstance: *mut otInstance, aSocket: *mut otUdpSocket) -> otError;
}
extern "C" {
    #[doc = " Bind a UDP/IPv6 socket."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSocket    A pointer to a UDP socket structure."]
    #[doc = " @param[in]  aSockName  A pointer to an IPv6 socket address structure."]
    #[doc = " @param[in]  aNetif     The network interface to bind."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE   Bind operation was successful."]
    #[doc = " @retval OT_ERROR_FAILED Failed to bind UDP socket."]
    #[doc = ""]
    pub fn otUdpBind(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aSockName: *const otSockAddr,
        aNetif: otNetifIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " Connect a UDP/IPv6 socket."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSocket    A pointer to a UDP socket structure."]
    #[doc = " @param[in]  aSockName  A pointer to an IPv6 socket address structure."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE   Connect operation was successful."]
    #[doc = " @retval OT_ERROR_FAILED Failed to connect UDP socket."]
    #[doc = ""]
    pub fn otUdpConnect(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aSockName: *const otSockAddr,
    ) -> otError;
}
extern "C" {
    #[doc = " Send a UDP/IPv6 message."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aSocket       A pointer to a UDP socket structure."]
    #[doc = " @param[in]  aMessage      A pointer to a message buffer."]
    #[doc = " @param[in]  aMessageInfo  A pointer to a message info structure."]
    #[doc = ""]
    #[doc = " If the return value is OT_ERROR_NONE, OpenThread takes ownership of @p aMessage, and the caller should no longer"]
    #[doc = " reference @p aMessage. If the return value is not OT_ERROR_NONE, the caller retains ownership of @p aMessage,"]
    #[doc = " including freeing @p aMessage if the message buffer is no longer needed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           The message is successfully scheduled for sending."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   Invalid arguments are given."]
    #[doc = " @retval OT_ERROR_NO_BUFS        Insufficient available buffer to add the UDP and IPv6 headers."]
    #[doc = ""]
    pub fn otUdpSend(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the head of linked list of UDP Sockets."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the head of UDP Socket linked list."]
    #[doc = ""]
    pub fn otUdpGetSockets(aInstance: *mut otInstance) -> *mut otUdpSocket;
}
#[doc = " This function pointer delivers the UDP packet to host and host should send the packet through its own network stack."]
#[doc = ""]
#[doc = " @param[in]  aMessage   A pointer to the UDP Message."]
#[doc = " @param[in]  aPeerPort  The destination UDP port."]
#[doc = " @param[in]  aPeerAddr  A pointer to the destination IPv6 address."]
#[doc = " @param[in]  aSockPort  The source UDP port."]
#[doc = " @param[in]  aContext   A pointer to application-specific context."]
#[doc = ""]
pub type otUdpForwarder = ::std::option::Option<
    unsafe extern "C" fn(
        aMessage: *mut otMessage,
        aPeerPort: u16,
        aPeerAddr: *mut otIp6Address,
        aSockPort: u16,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Set UDP forward callback to deliver UDP packets to host."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aForwarder           A pointer to a function called to forward UDP packet to host."]
    #[doc = " @param[in]  aContext             A pointer to application-specific context."]
    #[doc = ""]
    pub fn otUdpForwardSetForwarder(
        aInstance: *mut otInstance,
        aForwarder: otUdpForwarder,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Handle a UDP packet received from host."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMessage             A pointer to the UDP Message."]
    #[doc = " @param[in]  aPeerPort            The source UDP port."]
    #[doc = " @param[in]  aPeerAddr            A pointer to the source address."]
    #[doc = " @param[in]  aSockPort            The destination UDP port."]
    #[doc = ""]
    #[doc = " @warning No matter the call success or fail, the message is freed."]
    #[doc = ""]
    pub fn otUdpForwardReceive(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aPeerPort: u16,
        aPeerAddr: *const otIp6Address,
        aSockPort: u16,
    );
}
extern "C" {
    #[doc = " Determines if the given UDP port is exclusively opened by OpenThread API."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance            A pointer to an OpenThread instance."]
    #[doc = " @param[in]  port                 UDP port number to verify."]
    #[doc = ""]
    #[doc = " @retval true    The port is being used exclusively by OpenThread."]
    #[doc = " @retval false   The port is not used by any of the OpenThread API or is shared (e.g. is Backbone socket)."]
    #[doc = ""]
    pub fn otUdpIsPortInUse(aInstance: *mut otInstance, port: u16) -> bool;
}
extern "C" {
    #[doc = " This function initializes the UDP socket by platform."]
    #[doc = ""]
    #[doc = " @param[in]   aUdpSocket  A pointer to the UDP socket."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE   Successfully initialized UDP socket by platform."]
    #[doc = " @retval  OT_ERROR_FAILED Failed to initialize UDP Socket."]
    #[doc = ""]
    pub fn otPlatUdpSocket(aUdpSocket: *mut otUdpSocket) -> otError;
}
extern "C" {
    #[doc = " This function closes the UDP socket by platform."]
    #[doc = ""]
    #[doc = " @param[in]   aUdpSocket  A pointer to the UDP socket."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE   Successfully closed UDP socket by platform."]
    #[doc = " @retval  OT_ERROR_FAILED Failed to close UDP Socket."]
    #[doc = ""]
    pub fn otPlatUdpClose(aUdpSocket: *mut otUdpSocket) -> otError;
}
extern "C" {
    #[doc = " This function binds the UDP socket by platform."]
    #[doc = ""]
    #[doc = " @param[in]   aUdpSocket  A pointer to the UDP socket."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE   Successfully binded UDP socket by platform."]
    #[doc = " @retval  OT_ERROR_FAILED Failed to bind UDP socket."]
    #[doc = ""]
    pub fn otPlatUdpBind(aUdpSocket: *mut otUdpSocket) -> otError;
}
extern "C" {
    #[doc = " This function binds the UDP socket to a platform network interface."]
    #[doc = ""]
    #[doc = " Note: only available when `OPENTHREAD_CONFIG_PLATFORM_UDP_ENABLE` is used."]
    #[doc = ""]
    #[doc = " @param[in]   aUdpSocket          A pointer to the UDP socket."]
    #[doc = " @param[in]   aNetifIdentifier    The network interface identifier."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE   Successfully bound UDP socket."]
    #[doc = " @retval  OT_ERROR_FAILED Failed to bind UDP."]
    #[doc = ""]
    pub fn otPlatUdpBindToNetif(
        aUdpSocket: *mut otUdpSocket,
        aNetifIdentifier: otNetifIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " This function connects UDP socket by platform."]
    #[doc = ""]
    #[doc = " @param[in]   aUdpSocket  A pointer to the UDP socket."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE   Successfully connected by platform."]
    #[doc = " @retval  OT_ERROR_FAILED Failed to connect UDP socket."]
    #[doc = ""]
    pub fn otPlatUdpConnect(aUdpSocket: *mut otUdpSocket) -> otError;
}
extern "C" {
    #[doc = " This function sends UDP payload by platform."]
    #[doc = ""]
    #[doc = " @param[in]   aUdpSocket      A pointer to the UDP socket."]
    #[doc = " @param[in]   aMessage        A pointer to the message to send."]
    #[doc = " @param[in]   aMessageInfo    A pointer to the message info associated with @p aMessage."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE   Successfully sent by platform, and @p aMessage is freed."]
    #[doc = " @retval  OT_ERROR_FAILED Failed to binded UDP socket."]
    #[doc = ""]
    pub fn otPlatUdpSend(
        aUdpSocket: *mut otUdpSocket,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function configures the UDP socket to join a UDP multicast group."]
    #[doc = ""]
    #[doc = " Note: only available when `OPENTHREAD_CONFIG_PLATFORM_UDP_ENABLE` is used."]
    #[doc = ""]
    #[doc = " @param[in]   aUdpSocket          A pointer to the UDP socket."]
    #[doc = " @param[in]   aNetifIdentifier    The network interface identifier."]
    #[doc = " @param[in]   aAddress            The UDP multicast group address."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE   Successfully joined the multicast group."]
    #[doc = " @retval  OT_ERROR_FAILED Failed to join the multicast group."]
    #[doc = ""]
    pub fn otPlatUdpJoinMulticastGroup(
        aUdpSocket: *mut otUdpSocket,
        aNetifIdentifier: otNetifIdentifier,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " This function configures the UDP socket to leave a UDP multicast group."]
    #[doc = ""]
    #[doc = " Note: only available when `OPENTHREAD_CONFIG_PLATFORM_UDP_ENABLE` is used."]
    #[doc = ""]
    #[doc = " @param[in]   aUdpSocket          A pointer to the UDP socket."]
    #[doc = " @param[in]   aNetifIdentifier    The network interface identifier."]
    #[doc = " @param[in]   aAddress            The UDP multicast group address."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE   Successfully left the multicast group."]
    #[doc = " @retval  OT_ERROR_FAILED Failed to leave the multicast group."]
    #[doc = ""]
    pub fn otPlatUdpLeaveMulticastGroup(
        aUdpSocket: *mut otUdpSocket,
        aNetifIdentifier: otNetifIdentifier,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " This function generates and returns a random `uint32_t` value."]
    #[doc = ""]
    #[doc = " @returns    A random `uint32_t` value."]
    #[doc = ""]
    pub fn otRandomNonCryptoGetUint32() -> u32;
}
extern "C" {
    #[doc = " This function generates and returns a random byte."]
    #[doc = ""]
    #[doc = " @returns A random `uint8_t` value."]
    #[doc = ""]
    pub fn otRandomNonCryptoGetUint8() -> u8;
}
extern "C" {
    #[doc = " This function generates and returns a random `uint16_t` value."]
    #[doc = ""]
    #[doc = " @returns A random `uint16_t` value."]
    #[doc = ""]
    pub fn otRandomNonCryptoGetUint16() -> u16;
}
extern "C" {
    #[doc = " This function generates and returns a random `uint8_t` value within a given range `[aMin, aMax)`."]
    #[doc = ""]
    #[doc = " @param[in]  aMin  A minimum value (this value can be included in returned random result)."]
    #[doc = " @param[in]  aMax  A maximum value (this value is excluded from returned random result)."]
    #[doc = ""]
    #[doc = " @returns    A random `uint8_t` value in the given range (i.e., aMin <= random value < aMax)."]
    pub fn otRandomNonCryptoGetUint8InRange(aMin: u8, aMax: u8) -> u8;
}
extern "C" {
    #[doc = " This function generates and returns a random `uint16_t` value within a given range `[aMin, aMax)`."]
    #[doc = ""]
    #[doc = " @note The returned random value can include the @p aMin value but excludes the @p aMax."]
    #[doc = ""]
    #[doc = " @param[in]  aMin  A minimum value (this value can be included in returned random result)."]
    #[doc = " @param[in]  aMax  A maximum value (this value is excluded from returned random result)."]
    #[doc = ""]
    #[doc = " @returns    A random `uint16_t` value in the given range (i.e., aMin <= random value < aMax)."]
    pub fn otRandomNonCryptoGetUint16InRange(aMin: u16, aMax: u16) -> u16;
}
extern "C" {
    #[doc = " This function generates and returns a random `uint32_t` value within a given range `[aMin, aMax)`."]
    #[doc = ""]
    #[doc = " @note The returned random value can include the @p aMin value but excludes the @p aMax."]
    #[doc = ""]
    #[doc = " @param[in]  aMin  A minimum value (this value can be included in returned random result)."]
    #[doc = " @param[in]  aMax  A maximum value (this value is excluded from returned random result)."]
    #[doc = ""]
    #[doc = " @returns    A random `uint32_t` value in the given range (i.e., aMin <= random value < aMax)."]
    #[doc = ""]
    pub fn otRandomNonCryptoGetUint32InRange(aMin: u32, aMax: u32) -> u32;
}
extern "C" {
    #[doc = " This function fills a given buffer with random bytes."]
    #[doc = ""]
    #[doc = " @param[out] aBuffer  A pointer to a buffer to fill with the random bytes."]
    #[doc = " @param[in]  aSize    Size of buffer (number of bytes to fill)."]
    #[doc = ""]
    pub fn otRandomNonCryptoFillBuffer(aBuffer: *mut u8, aSize: u16);
}
extern "C" {
    #[doc = " This function adds a random jitter within a given range to a given value."]
    #[doc = ""]
    #[doc = " @param[in]  aValue     A value to which the random jitter is added."]
    #[doc = " @param[in]  aJitter    Maximum jitter. Random jitter is selected from the range `[-aJitter, aJitter]`."]
    #[doc = ""]
    #[doc = " @returns    The given value with an added random jitter."]
    #[doc = ""]
    pub fn otRandomNonCryptoAddJitter(aValue: u32, aJitter: u16) -> u32;
}
extern "C" {
    #[doc = " This method provides a full or stable copy of the local Thread Network Data."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]      aStable      TRUE when copying the stable version, FALSE when copying the full version."]
    #[doc = " @param[out]     aData        A pointer to the data buffer."]
    #[doc = " @param[in,out]  aDataLength  On entry, size of the data buffer pointed to by @p aData."]
    #[doc = "                              On exit, number of copied bytes."]
    #[doc = ""]
    pub fn otServerGetNetDataLocal(
        aInstance: *mut otInstance,
        aStable: bool,
        aData: *mut u8,
        aDataLength: *mut u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Add a service configuration to the local network data."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aConfig   A pointer to the service configuration."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully added the configuration to the local network data."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  One or more configuration parameters were invalid."]
    #[doc = " @retval OT_ERROR_NO_BUFS       Not enough room is available to add the configuration to the local network data."]
    #[doc = ""]
    #[doc = " @sa otServerRemoveService"]
    #[doc = " @sa otServerRegister"]
    #[doc = ""]
    pub fn otServerAddService(
        aInstance: *mut otInstance,
        aConfig: *const otServiceConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove a service configuration from the local network data."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance          A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnterpriseNumber  Enterprise Number of the service entry to be deleted."]
    #[doc = " @param[in]  aServiceData       A pointer to an Service Data to look for during deletion."]
    #[doc = " @param[in]  aServiceDataLength The length of @p aServiceData in bytes."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully removed the configuration from the local network data."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  Could not find the Border Router entry."]
    #[doc = ""]
    #[doc = " @sa otServerAddService"]
    #[doc = " @sa otServerRegister"]
    #[doc = ""]
    pub fn otServerRemoveService(
        aInstance: *mut otInstance,
        aEnterpriseNumber: u32,
        aServiceData: *const u8,
        aServiceDataLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the next service in the local Network Data."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in,out]  aIterator  A pointer to the Network Data iterator context. To get the first service entry"]
    #[doc = "it should be set to OT_NETWORK_DATA_ITERATOR_INIT."]
    #[doc = " @param[out]     aConfig    A pointer to where the service information will be placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       Successfully found the next service."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  No subsequent service exists in the Thread Network Data."]
    #[doc = ""]
    pub fn otServerGetNextService(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aConfig: *mut otServiceConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Immediately register the local network data with the Leader."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE  Successfully queued a Server Data Request message for delivery."]
    #[doc = ""]
    #[doc = " @sa otServerAddService"]
    #[doc = " @sa otServerRemoveService"]
    #[doc = ""]
    pub fn otServerRegister(aInstance: *mut otInstance) -> otError;
}
#[doc = " This structure implements SNTP Query parameters."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSntpQuery {
    #[doc = "< A reference to the message info related with SNTP Server."]
    pub mMessageInfo: *const otMessageInfo,
}
impl Default for otSntpQuery {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This function pointer is called when a SNTP response is received."]
#[doc = ""]
#[doc = " @param[in]  aContext   A pointer to application-specific context."]
#[doc = " @param[in]  aTime      Specifies the time at the server when the response left for the client, in UNIX time."]
#[doc = " @param[in]  aResult    A result of the SNTP transaction."]
#[doc = ""]
#[doc = " @retval  OT_ERROR_NONE              A response was received successfully and time is provided"]
#[doc = "                                     in @p aTime."]
#[doc = " @retval  OT_ERROR_ABORT             A SNTP transaction was aborted by stack."]
#[doc = " @retval  OT_ERROR_BUSY              The Kiss-o'-death packet has been received."]
#[doc = " @retval  OT_ERROR_RESPONSE_TIMEOUT  No SNTP response has been received within timeout."]
#[doc = " @retval  OT_ERROR_FAILED            A response was received but contains incorrect data."]
#[doc = ""]
pub type otSntpResponseHandler = ::std::option::Option<
    unsafe extern "C" fn(aContext: *mut ::std::os::raw::c_void, aTime: u64, aResult: otError),
>;
extern "C" {
    #[doc = " This function sends a SNTP query."]
    #[doc = ""]
    #[doc = " This function is available only if feature `OPENTHREAD_CONFIG_SNTP_CLIENT_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aQuery      A pointer to specify SNTP query parameters."]
    #[doc = " @param[in]  aHandler    A function pointer that shall be called on response reception or time-out."]
    #[doc = " @param[in]  aContext    A pointer to arbitrary context information."]
    #[doc = ""]
    pub fn otSntpClientQuery(
        aInstance: *mut otInstance,
        aQuery: *const otSntpQuery,
        aHandler: otSntpResponseHandler,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the unix era number."]
    #[doc = ""]
    #[doc = " The default value of unix era is set to 0. The subsequent eras start after year 2106."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aUnixEra    Unix era number."]
    #[doc = ""]
    pub fn otSntpClientSetUnixEra(aInstance: *mut otInstance, aUnixEra: u32);
}
#[doc = "< Item to be added/registered."]
pub const OT_SRP_CLIENT_ITEM_STATE_TO_ADD: otSrpClientItemState = 0;
#[doc = "< Item is being added/registered."]
pub const OT_SRP_CLIENT_ITEM_STATE_ADDING: otSrpClientItemState = 1;
#[doc = "< Item to be refreshed (re-register to renew lease)."]
pub const OT_SRP_CLIENT_ITEM_STATE_TO_REFRESH: otSrpClientItemState = 2;
#[doc = "< Item is being refreshed."]
pub const OT_SRP_CLIENT_ITEM_STATE_REFRESHING: otSrpClientItemState = 3;
#[doc = "< Item to be removed."]
pub const OT_SRP_CLIENT_ITEM_STATE_TO_REMOVE: otSrpClientItemState = 4;
#[doc = "< Item is being removed."]
pub const OT_SRP_CLIENT_ITEM_STATE_REMOVING: otSrpClientItemState = 5;
#[doc = "< Item is registered with server."]
pub const OT_SRP_CLIENT_ITEM_STATE_REGISTERED: otSrpClientItemState = 6;
#[doc = "< Item is removed."]
pub const OT_SRP_CLIENT_ITEM_STATE_REMOVED: otSrpClientItemState = 7;
#[doc = " This enumeration specifies an SRP client item (service or host info) state."]
#[doc = ""]
pub type otSrpClientItemState = ::std::os::raw::c_uint;
#[doc = " This structure represents an SRP client host info."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSrpClientHostInfo {
    #[doc = "< Host name (label) string (NULL if not yet set)."]
    pub mName: *const ::std::os::raw::c_char,
    #[doc = "< Array of host IPv6 addresses (NULL if not set or auto address is enabled)."]
    pub mAddresses: *const otIp6Address,
    #[doc = "< Number of IPv6 addresses in `mAddresses` array."]
    pub mNumAddresses: u8,
    #[doc = "< Indicates whether auto address mode is enabled or not."]
    pub mAutoAddress: bool,
    #[doc = "< Host info state."]
    pub mState: otSrpClientItemState,
}
impl Default for otSrpClientHostInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents an SRP client service."]
#[doc = ""]
#[doc = " The values in this structure, including the string buffers for the names and the TXT record entries, MUST persist"]
#[doc = " and stay constant after an instance of this structure is passed to OpenThread from `otSrpClientAddService()` or"]
#[doc = " `otSrpClientRemoveService()`."]
#[doc = ""]
#[doc = " The `mState`, `mData`, `mNext` fields are used/managed by OT core only. Their value is ignored when an instance of"]
#[doc = " `otSrpClientService` is passed in `otSrpClientAddService()` or `otSrpClientRemoveService()` or other functions. The"]
#[doc = " caller does not need to set these fields."]
#[doc = ""]
#[doc = " The `mLease` and `mKeyLease` fields specify the desired lease and key lease intervals for this service. Zero value"]
#[doc = " indicates that the interval is unspecified and then the default lease or key lease intervals from"]
#[doc = " `otSrpClientGetLeaseInterval()` and `otSrpClientGetKeyLeaseInterval()` are used for this service. If the key lease"]
#[doc = " interval (whether set explicitly or determined from the default) is shorter than the lease interval for a service,"]
#[doc = " SRP client will re-use the lease interval value for key lease interval as well. For example, if in service `mLease`"]
#[doc = " is explicitly set to 2 days and `mKeyLease` is set to zero and default key lease is set to 1 day, then when"]
#[doc = " registering this service, the requested key lease for this service is also set to 2 days."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSrpClientService {
    #[doc = "< The service labels (e.g., \"_mt._udp\", not the full domain name)."]
    pub mName: *const ::std::os::raw::c_char,
    #[doc = "< The service instance name label (not the full name)."]
    pub mInstanceName: *const ::std::os::raw::c_char,
    #[doc = "< Array of sub-type labels (must end with `NULL` or can be `NULL`)."]
    pub mSubTypeLabels: *const *const ::std::os::raw::c_char,
    #[doc = "< Array of TXT entries (`mNumTxtEntries` gives num of entries)."]
    pub mTxtEntries: *const otDnsTxtEntry,
    #[doc = "< The service port number."]
    pub mPort: u16,
    #[doc = "< The service priority."]
    pub mPriority: u16,
    #[doc = "< The service weight."]
    pub mWeight: u16,
    #[doc = "< Number of entries in the `mTxtEntries` array."]
    pub mNumTxtEntries: u8,
    #[doc = "< Service state (managed by OT core)."]
    pub mState: otSrpClientItemState,
    #[doc = "< Internal data (used by OT core)."]
    pub mData: u32,
    #[doc = "< Pointer to next entry in a linked-list (managed by OT core)."]
    pub mNext: *mut otSrpClientService,
    #[doc = "< Desired lease interval in sec - zero to use default."]
    pub mLease: u32,
    #[doc = "< Desired key lease interval in sec - zero to use default."]
    pub mKeyLease: u32,
}
impl Default for otSrpClientService {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This function pointer type defines the callback used by SRP client to notify user of changes/events/errors."]
#[doc = ""]
#[doc = " This callback is invoked on a successful registration of an update (i.e., add/remove of host-info and/or some"]
#[doc = " service(s)) with the SRP server, or if there is a failure or error (e.g., server rejects a update request or client"]
#[doc = " times out waiting for response, etc)."]
#[doc = ""]
#[doc = " In case of a successful reregistration of an update, `aError` parameter would be `OT_ERROR_NONE` and the host info"]
#[doc = " and the full list of services is provided as input parameters to the callback. Note that host info and services each"]
#[doc = " track its own state in the corresponding `mState` member variable of the related data structure (the state"]
#[doc = " indicating whether the host-info/service is registered or removed or still being added/removed, etc)."]
#[doc = ""]
#[doc = " The list of removed services is passed as its own linked-list `aRemovedServices` in the callback. Note that when the"]
#[doc = " callback is invoked, the SRP client (OpenThread implementation) is done with the removed service instances listed in"]
#[doc = " `aRemovedServices` and no longer tracks/stores them (i.e., if from the callback we call `otSrpClientGetServices()`"]
#[doc = " the removed services will not be present in the returned list). Providing a separate list of removed services in"]
#[doc = " the callback helps indicate to user which items are now removed and allow user to re-claim/reuse the instances."]
#[doc = ""]
#[doc = " If the server rejects an SRP update request, the DNS response code (RFC 2136) is mapped to the following errors:"]
#[doc = ""]
#[doc = "  - (0)  NOERROR   Success (no error condition)                    -> OT_ERROR_NONE"]
#[doc = "  - (1)  FORMERR   Server unable to interpret due to format error  -> OT_ERROR_PARSE"]
#[doc = "  - (2)  SERVFAIL  Server encountered an internal failure          -> OT_ERROR_FAILED"]
#[doc = "  - (3)  NXDOMAIN  Name that ought to exist, does not exist        -> OT_ERROR_NOT_FOUND"]
#[doc = "  - (4)  NOTIMP    Server does not support the query type (OpCode) -> OT_ERROR_NOT_IMPLEMENTED"]
#[doc = "  - (5)  REFUSED   Server refused for policy/security reasons      -> OT_ERROR_SECURITY"]
#[doc = "  - (6)  YXDOMAIN  Some name that ought not to exist, does exist   -> OT_ERROR_DUPLICATED"]
#[doc = "  - (7)  YXRRSET   Some RRset that ought not to exist, does exist  -> OT_ERROR_DUPLICATED"]
#[doc = "  - (8)  NXRRSET   Some RRset that ought to exist, does not exist  -> OT_ERROR_NOT_FOUND"]
#[doc = "  - (9)  NOTAUTH   Service is not authoritative for zone           -> OT_ERROR_SECURITY"]
#[doc = "  - (10) NOTZONE   A name is not in the zone                       -> OT_ERROR_PARSE"]
#[doc = "  - (20) BADNAME   Bad name                                        -> OT_ERROR_PARSE"]
#[doc = "  - (21) BADALG    Bad algorithm                                   -> OT_ERROR_SECURITY"]
#[doc = "  - (22) BADTRUN   Bad truncation                                  -> OT_ERROR_PARSE"]
#[doc = "  - Other response codes                                           -> OT_ERROR_FAILED"]
#[doc = ""]
#[doc = " The following errors are also possible:"]
#[doc = ""]
#[doc = "  - OT_ERROR_RESPONSE_TIMEOUT : Timed out waiting for response from server (client would continue to retry)."]
#[doc = "  - OT_ERROR_INVALID_ARGS     : The provided service structure is invalid (e.g., bad service name or `otDnsTxtEntry`)."]
#[doc = "  - OT_ERROR_NO_BUFS          : Insufficient buffer to prepare or send the update message."]
#[doc = ""]
#[doc = " Note that in case of any failure, the client continues the operation, i.e. it prepares and (re)transmits the SRP"]
#[doc = " update message to the server, after some wait interval. The retry wait interval starts from the minimum value and"]
#[doc = " is increased by the growth factor every failure up to the max value (please see configuration parameter"]
#[doc = " `OPENTHREAD_CONFIG_SRP_CLIENT_MIN_RETRY_WAIT_INTERVAL` and the related ones for more details)."]
#[doc = ""]
#[doc = " @param[in] aError            The error (see above)."]
#[doc = " @param[in] aHostInfo         A pointer to host info."]
#[doc = " @param[in] aServices         The head of linked-list containing all services (excluding the ones removed). NULL if"]
#[doc = "                              the list is empty."]
#[doc = " @param[in] aRemovedServices  The head of linked-list containing all removed services. NULL if the list is empty."]
#[doc = " @param[in] aContext          A pointer to an arbitrary context (provided when callback was registered)."]
#[doc = ""]
pub type otSrpClientCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aError: otError,
        aHostInfo: *const otSrpClientHostInfo,
        aServices: *const otSrpClientService,
        aRemovedServices: *const otSrpClientService,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " This function pointer type defines the callback used by SRP client to notify user when it is auto-started or stopped."]
#[doc = ""]
#[doc = " This is only used when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled."]
#[doc = ""]
#[doc = " This callback is invoked when auto-start mode is enabled and the SRP client is either automatically started or"]
#[doc = " stopped."]
#[doc = ""]
#[doc = " @param[in] aServerSockAddr   A non-NULL pointer indicates SRP server was started and pointer will give the"]
#[doc = "                              selected server socket address. A NULL pointer indicates SRP server was stopped."]
#[doc = " @param[in] aContext          A pointer to an arbitrary context (provided when callback was registered)."]
#[doc = ""]
pub type otSrpClientAutoStartCallback = ::std::option::Option<
    unsafe extern "C" fn(aServerSockAddr: *const otSockAddr, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function starts the SRP client operation."]
    #[doc = ""]
    #[doc = " SRP client will prepare and send \"SRP Update\" message to the SRP server once all the following conditions are met:"]
    #[doc = ""]
    #[doc = "  - The SRP client is started - `otSrpClientStart()` is called."]
    #[doc = "  - Host name is set - `otSrpClientSetHostName()` is called."]
    #[doc = "  - At least one host IPv6 address is set - `otSrpClientSetHostName()` is called."]
    #[doc = "  - At least one service is added - `otSrpClientAddService()` is called."]
    #[doc = ""]
    #[doc = " It does not matter in which order these functions are called. When all conditions are met, the SRP client will"]
    #[doc = " wait for a short delay before preparing an \"SRP Update\" message and sending it to server. This delay allows for user"]
    #[doc = " to add multiple services and/or IPv6 addresses before the first SRP Update message is sent (ensuring a single SRP"]
    #[doc = " Update is sent containing all the info). The config `OPENTHREAD_CONFIG_SRP_CLIENT_UPDATE_TX_DELAY` specifies the"]
    #[doc = " delay interval."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        A pointer to the OpenThread instance."]
    #[doc = " @param[in] aServerSockAddr  The socket address (IPv6 address and port number) of the SRP server."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       SRP client operation started successfully or it is already running with same server"]
    #[doc = "                             socket address and callback."]
    #[doc = " @retval OT_ERROR_BUSY       SRP client is busy running with a different socket address."]
    #[doc = " @retval OT_ERROR_FAILED     Failed to open/connect the client's UDP socket."]
    #[doc = ""]
    pub fn otSrpClientStart(
        aInstance: *mut otInstance,
        aServerSockAddr: *const otSockAddr,
    ) -> otError;
}
extern "C" {
    #[doc = " This function stops the SRP client operation."]
    #[doc = ""]
    #[doc = " This function stops any further interactions with the SRP server. Note that it does not remove or clear host info"]
    #[doc = " and/or list of services. It marks all services to be added/removed again once the client is (re)started."]
    #[doc = ""]
    #[doc = " @param[in] aInstance       A pointer to the OpenThread instance."]
    #[doc = ""]
    pub fn otSrpClientStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function indicates whether the SRP client is running or not."]
    #[doc = ""]
    #[doc = " @param[in] aInstance       A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns TRUE if the SRP client is running, FALSE otherwise."]
    #[doc = ""]
    pub fn otSrpClientIsRunning(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function gets the socket address (IPv6 address and port number) of the SRP server which is being used by SRP"]
    #[doc = " client."]
    #[doc = ""]
    #[doc = " If the client is not running, the address is unspecified (all zero) with zero port number."]
    #[doc = ""]
    #[doc = " @param[in] aInstance       A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the SRP server's socket address (is always non-NULL)."]
    #[doc = ""]
    pub fn otSrpClientGetServerAddress(aInstance: *mut otInstance) -> *const otSockAddr;
}
extern "C" {
    #[doc = " This function sets the callback to notify caller of events/changes from SRP client."]
    #[doc = ""]
    #[doc = " The SRP client allows a single callback to be registered. So consecutive calls to this function will overwrite any"]
    #[doc = " previously set callback functions."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   A pointer to the OpenThread instance."]
    #[doc = " @param[in] aCallback   The callback to notify of events and changes. Can be NULL if not needed."]
    #[doc = " @param[in] aContext    An arbitrary context used with @p aCallback."]
    #[doc = ""]
    pub fn otSrpClientSetCallback(
        aInstance: *mut otInstance,
        aCallback: otSrpClientCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function enables the auto-start mode."]
    #[doc = ""]
    #[doc = " This is only available when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " Config option `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_DEFAULT_MODE` specifies the default auto-start mode (whether"]
    #[doc = " it is enabled or disabled at the start of OT stack)."]
    #[doc = ""]
    #[doc = " When auto-start is enabled, the SRP client will monitor the Thread Network Data to discover SRP servers and select"]
    #[doc = " the preferred server and automatically start and stop the client when an SRP server is detected."]
    #[doc = ""]
    #[doc = " There are three categories of Network Data entries indicating presence of SRP sever. They are preferred in the"]
    #[doc = " following order:"]
    #[doc = ""]
    #[doc = "   1) Preferred unicast entries where server address is included in the service data. If there are multiple options,"]
    #[doc = "      the one with numerically lowest IPv6 address is preferred."]
    #[doc = ""]
    #[doc = "   2) Anycast entries each having a seq number. A larger sequence number in the sense specified by Serial Number"]
    #[doc = "      Arithmetic logic in RFC-1982 is considered more recent and therefore preferred. The largest seq number using"]
    #[doc = "      serial number arithmetic is preferred if it is well-defined (i.e., the seq number is larger than all other"]
    #[doc = "      seq numbers). If it is not well-defined, then the numerically largest seq number is preferred."]
    #[doc = ""]
    #[doc = "   3) Unicast entries where the server address info is included in server data. If there are multiple options, the"]
    #[doc = "      one with numerically lowest IPv6 address is preferred."]
    #[doc = ""]
    #[doc = " When there is a change in the Network Data entries, client will check that the currently selected server is still"]
    #[doc = " present in the Network Data and is still the preferred one. Otherwise the client will switch to the new preferred"]
    #[doc = " server or stop if there is none."]
    #[doc = ""]
    #[doc = " When the SRP client is explicitly started through a successful call to `otSrpClientStart()`, the given SRP server"]
    #[doc = " address in `otSrpClientStart()` will continue to be used regardless of the state of auto-start mode and whether the"]
    #[doc = " same SRP server address is discovered or not in the Thread Network Data. In this case, only an explicit"]
    #[doc = " `otSrpClientStop()` call will stop the client."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   A pointer to the OpenThread instance."]
    #[doc = " @param[in] aCallback   A callback to notify when client is auto-started/stopped. Can be NULL if not needed."]
    #[doc = " @param[in] aContext    A context to be passed when invoking @p aCallback."]
    #[doc = ""]
    pub fn otSrpClientEnableAutoStartMode(
        aInstance: *mut otInstance,
        aCallback: otSrpClientAutoStartCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function disables the auto-start mode."]
    #[doc = ""]
    #[doc = " This is only available when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " Disabling the auto-start mode will not stop the client if it is already running but the client stops monitoring"]
    #[doc = " the Thread Network Data to verify that the selected SRP server is still present in it."]
    #[doc = ""]
    #[doc = " Note that a call to `otSrpClientStop()` will also disable the auto-start mode."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   A pointer to the OpenThread instance."]
    #[doc = ""]
    pub fn otSrpClientDisableAutoStartMode(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function indicates the current state of auto-start mode (enabled or disabled)."]
    #[doc = ""]
    #[doc = " This is only available when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns TRUE if the auto-start mode is enabled, FALSE otherwise."]
    #[doc = ""]
    pub fn otSrpClientIsAutoStartModeEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function gets the TTL value in every record included in SRP update requests."]
    #[doc = ""]
    #[doc = " Note that this is the TTL requested by the SRP client. The server may choose to accept a different TTL."]
    #[doc = ""]
    #[doc = " By default, the TTL will equal the lease interval. Passing 0 or a value larger than the lease interval via"]
    #[doc = " `otSrpClientSetTtl()` will also cause the TTL to equal the lease interval."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The TTL (in seconds)."]
    #[doc = ""]
    pub fn otSrpClientGetTtl(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " This function sets the TTL value in every record included in SRP update requests."]
    #[doc = ""]
    #[doc = " Changing the TTL does not impact the TTL of already registered services/host-info."]
    #[doc = " It only affects future SRP update messages (i.e., adding new services and/or refreshes of the existing services)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   A pointer to the OpenThread instance."]
    #[doc = " @param[in] aTtl        The TTL (in seconds). If value is zero or greater than lease interval, the TTL is set to the"]
    #[doc = "                        lease interval."]
    #[doc = ""]
    pub fn otSrpClientSetTtl(aInstance: *mut otInstance, aTtl: u32);
}
extern "C" {
    #[doc = " This function gets the default lease interval used in SRP update requests."]
    #[doc = ""]
    #[doc = " The default interval is used only for `otSrpClientService` instances with `mLease` set to zero."]
    #[doc = ""]
    #[doc = " Note that this is the lease duration requested by the SRP client. The server may choose to accept a different lease"]
    #[doc = " interval."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The lease interval (in seconds)."]
    #[doc = ""]
    pub fn otSrpClientGetLeaseInterval(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " This function sets the default lease interval used in SRP update requests."]
    #[doc = ""]
    #[doc = " The default interval is used only for `otSrpClientService` instances with `mLease` set to zero."]
    #[doc = ""]
    #[doc = " Changing the lease interval does not impact the accepted lease interval of already registered services/host-info."]
    #[doc = " It only affects any future SRP update messages (i.e., adding new services and/or refreshes of the existing services)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   A pointer to the OpenThread instance."]
    #[doc = " @param[in] aInterval   The lease interval (in seconds). If zero, the default value specified by"]
    #[doc = "                        `OPENTHREAD_CONFIG_SRP_CLIENT_DEFAULT_LEASE` would be used."]
    #[doc = ""]
    pub fn otSrpClientSetLeaseInterval(aInstance: *mut otInstance, aInterval: u32);
}
extern "C" {
    #[doc = " This function gets the default key lease interval used in SRP update requests."]
    #[doc = ""]
    #[doc = " The default interval is used only for `otSrpClientService` instances with `mKeyLease` set to zero."]
    #[doc = ""]
    #[doc = " Note that this is the lease duration requested by the SRP client. The server may choose to accept a different lease"]
    #[doc = " interval."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The key lease interval (in seconds)."]
    #[doc = ""]
    pub fn otSrpClientGetKeyLeaseInterval(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " This function sets the default key lease interval used in SRP update requests."]
    #[doc = ""]
    #[doc = " The default interval is used only for `otSrpClientService` instances with `mKeyLease` set to zero."]
    #[doc = ""]
    #[doc = " Changing the lease interval does not impact the accepted lease interval of already registered services/host-info."]
    #[doc = " It only affects any future SRP update messages (i.e., adding new services and/or refreshes of existing services)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance    A pointer to the OpenThread instance."]
    #[doc = " @param[in] aInterval    The key lease interval (in seconds). If zero, the default value specified by"]
    #[doc = "                         `OPENTHREAD_CONFIG_SRP_CLIENT_DEFAULT_KEY_LEASE` would be used."]
    #[doc = ""]
    pub fn otSrpClientSetKeyLeaseInterval(aInstance: *mut otInstance, aInterval: u32);
}
extern "C" {
    #[doc = " This function gets the host info."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to host info structure."]
    #[doc = ""]
    pub fn otSrpClientGetHostInfo(aInstance: *mut otInstance) -> *const otSrpClientHostInfo;
}
extern "C" {
    #[doc = " This function sets the host name label."]
    #[doc = ""]
    #[doc = " After a successful call to this function, `otSrpClientCallback` will be called to report the status of host info"]
    #[doc = " registration with SRP server."]
    #[doc = ""]
    #[doc = " The name string buffer pointed to by @p aName MUST persist and stay unchanged after returning from this function."]
    #[doc = " OpenThread will keep the pointer to the string."]
    #[doc = ""]
    #[doc = " The host name can be set before client is started or after start but before host info is registered with server"]
    #[doc = " (host info should be in either `STATE_TO_ADD` or `STATE_REMOVED`)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   A pointer to the OpenThread instance."]
    #[doc = " @param[in] aName       A pointer to host name label string (MUST NOT be NULL). Pointer to the string buffer MUST"]
    #[doc = "                        persist and remain valid and constant after return from this function."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            The host name label was set successfully."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS    The @p aName is NULL."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   The host name is already set and registered with the server."]
    #[doc = ""]
    pub fn otSrpClientSetHostName(
        aInstance: *mut otInstance,
        aName: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function enables auto host address mode."]
    #[doc = ""]
    #[doc = " When enabled host IPv6 addresses are automatically set by SRP client using all the unicast addresses on Thread netif"]
    #[doc = " excluding all link-local and mesh-local addresses. If there is no valid address, then Mesh Local EID address is"]
    #[doc = " added. The SRP client will automatically re-register when/if addresses on Thread netif are updated (new addresses"]
    #[doc = " are added or existing addresses are removed)."]
    #[doc = ""]
    #[doc = " The auto host address mode can be enabled before start or during operation of SRP client except when the host info"]
    #[doc = " is being removed (client is busy handling a remove request from an call to `otSrpClientRemoveHostAndServices()` and"]
    #[doc = " host info still being in  either `STATE_TO_REMOVE` or `STATE_REMOVING` states)."]
    #[doc = ""]
    #[doc = " After auto host address mode is enabled, it can be disabled by a call to `otSrpClientSetHostAddresses()` which"]
    #[doc = " then explicitly sets the host addresses."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            Successfully enabled auto host address mode."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   Host is being removed and therefore cannot enable auto host address mode."]
    #[doc = ""]
    pub fn otSrpClientEnableAutoHostAddress(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function sets/updates the list of host IPv6 address."]
    #[doc = ""]
    #[doc = " Host IPv6 addresses can be set/changed before start or during operation of SRP client (e.g. to add/remove or change"]
    #[doc = " a previously registered host address), except when the host info is being removed (client is busy handling a remove"]
    #[doc = " request from an earlier call to `otSrpClientRemoveHostAndServices()` and host info still being in  either"]
    #[doc = " `STATE_TO_REMOVE` or `STATE_REMOVING` states)."]
    #[doc = ""]
    #[doc = " The host IPv6 address array pointed to by @p aIp6Addresses MUST persist and remain unchanged after returning from"]
    #[doc = " this function (with `OT_ERROR_NONE`). OpenThread will save the pointer to the array."]
    #[doc = ""]
    #[doc = " After a successful call to this function, `otSrpClientCallback` will be called to report the status of the address"]
    #[doc = " registration with SRP server."]
    #[doc = ""]
    #[doc = " Calling this function disables auto host address mode if it was previously enabled from a successful call to"]
    #[doc = " `otSrpClientEnableAutoHostAddress()`."]
    #[doc = ""]
    #[doc = " @param[in] aInstance           A pointer to the OpenThread instance."]
    #[doc = " @param[in] aIp6Addresses       A pointer to the an array containing the host IPv6 addresses."]
    #[doc = " @param[in] aNumAddresses       The number of addresses in the @p aIp6Addresses array."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            The host IPv6 address list change started successfully. The `otSrpClientCallback`"]
    #[doc = "                                  will be called to report the status of registering addresses with server."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS    The address list is invalid (e.g., must contain at least one address)."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   Host is being removed and therefore cannot change host address."]
    #[doc = ""]
    pub fn otSrpClientSetHostAddresses(
        aInstance: *mut otInstance,
        aIp6Addresses: *const otIp6Address,
        aNumAddresses: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function adds a service to be registered with server."]
    #[doc = ""]
    #[doc = " After a successful call to this function, `otSrpClientCallback` will be called to report the status of the service"]
    #[doc = " addition/registration with SRP server."]
    #[doc = ""]
    #[doc = " The `otSrpClientService` instance being pointed to by @p aService MUST persist and remain unchanged after returning"]
    #[doc = " from this function (with `OT_ERROR_NONE`). OpenThread will save the pointer to the service instance."]
    #[doc = ""]
    #[doc = " The `otSrpClientService` instance is not longer tracked by OpenThread and can be reclaimed only when"]
    #[doc = ""]
    #[doc = "  -  It is removed explicitly by a call to `otSrpClientRemoveService()` or removed along with other services by a"]
    #[doc = "     call to `otSrpClientRemoveHostAndServices() and only after the `otSrpClientCallback` is called indicating the"]
    #[doc = "     service was removed. Or,"]
    #[doc = "  -  A call to `otSrpClientClearHostAndServices()` which removes the host and all related services immediately."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        A pointer to the OpenThread instance."]
    #[doc = " @param[in] aService         A pointer to a `otSrpClientService` instance to add."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          The addition of service started successfully. The `otSrpClientCallback` will be"]
    #[doc = "                                called to report the status."]
    #[doc = " @retval OT_ERROR_ALREADY       A service with the same service and instance names is already in the list."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  The service structure is invalid (e.g., bad service name or `otDnsTxtEntry`)."]
    #[doc = ""]
    pub fn otSrpClientAddService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientService,
    ) -> otError;
}
extern "C" {
    #[doc = " This function requests a service to be unregistered with server."]
    #[doc = ""]
    #[doc = " After a successful call to this function, `otSrpClientCallback` will be called to report the status of remove"]
    #[doc = " request with SRP server."]
    #[doc = ""]
    #[doc = " The `otSrpClientService` instance being pointed to by @p aService MUST persist and remain unchanged after returning"]
    #[doc = " from this function (with `OT_ERROR_NONE`). OpenThread will keep the service instance during the remove process."]
    #[doc = " Only after the `otSrpClientCallback` is called indicating the service instance is removed from SRP client"]
    #[doc = " service list and can be be freed/reused."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        A pointer to the OpenThread instance."]
    #[doc = " @param[in] aService         A pointer to a `otSrpClientService` instance to remove."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       The removal of service started successfully. The `otSrpClientCallback` will be called to"]
    #[doc = "                             report the status."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  The service could not be found in the list."]
    #[doc = ""]
    pub fn otSrpClientRemoveService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientService,
    ) -> otError;
}
extern "C" {
    #[doc = " This function clears a service, immediately removing it from the client service list."]
    #[doc = ""]
    #[doc = " Unlike `otSrpClientRemoveService()` which sends an update message to the server to remove the service, this function"]
    #[doc = " clears the service from the client's service list without any interaction with the server. On a successful call to"]
    #[doc = " this function, the `otSrpClientCallback` will NOT be called and the @p aService entry can be reclaimed and re-used"]
    #[doc = " by the caller immediately."]
    #[doc = ""]
    #[doc = " This function can be used along with a subsequent call to `otSrpClientAddService()` (potentially reusing the same @p"]
    #[doc = " aService entry with the same service and instance names) to update some of the parameters in an existing service."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        A pointer to the OpenThread instance."]
    #[doc = " @param[in] aService         A pointer to a `otSrpClientService` instance to delete."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       The @p aService is deleted successfully. It can be reclaimed and re-used immediately."]
    #[doc = " @retval OT_ERROR_NOT_FOUND  The service could not be found in the list."]
    #[doc = ""]
    pub fn otSrpClientClearService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientService,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the list of services being managed by client."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the head of linked-list of all services or NULL if the list is empty."]
    #[doc = ""]
    pub fn otSrpClientGetServices(aInstance: *mut otInstance) -> *const otSrpClientService;
}
extern "C" {
    #[doc = " This function starts the remove process of the host info and all services."]
    #[doc = ""]
    #[doc = " After returning from this function, `otSrpClientCallback` will be called to report the status of remove request with"]
    #[doc = " SRP server."]
    #[doc = ""]
    #[doc = " If the host info is to be permanently removed from server, @p aRemoveKeyLease should be set to `true` which removes"]
    #[doc = " the key lease associated with host on server. Otherwise, the key lease record is kept as before, which ensures"]
    #[doc = " that the server holds the host name in reserve for when the client is once again able to provide and register its"]
    #[doc = " service(s)."]
    #[doc = ""]
    #[doc = " The @p aSendUnregToServer determines the behavior when the host info is not yet registered with the server. If"]
    #[doc = " @p aSendUnregToServer is set to `false` (which is the default/expected value) then the SRP client will immediately"]
    #[doc = " remove the host info and services without sending an update message to server (no need to update the server if"]
    #[doc = " nothing is yet registered with it). If @p aSendUnregToServer is set to `true` then the SRP client will send an"]
    #[doc = " update message to the server. Note that if the host info is registered then the value of @p aSendUnregToServer does"]
    #[doc = " not matter and the SRP client will always send an update message to server requesting removal of all info."]
    #[doc = ""]
    #[doc = " One situation where @p aSendUnregToServer can be useful is on a device reset/reboot, caller may want to remove any"]
    #[doc = " previously registered services with the server. In this case, caller can `otSrpClientSetHostName()` and then request"]
    #[doc = " `otSrpClientRemoveHostAndServices()` with `aSendUnregToServer` as `true`."]
    #[doc = ""]
    #[doc = " @param[in] aInstance          A pointer to the OpenThread instance."]
    #[doc = " @param[in] aRemoveKeyLease    A boolean indicating whether or not the host key lease should also be removed."]
    #[doc = " @param[in] aSendUnregToServer A boolean indicating whether to send update to server when host info is not registered."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE       The removal of host info and services started successfully. The `otSrpClientCallback`"]
    #[doc = "                             will be called to report the status."]
    #[doc = " @retval OT_ERROR_ALREADY    The host info is already removed."]
    #[doc = ""]
    pub fn otSrpClientRemoveHostAndServices(
        aInstance: *mut otInstance,
        aRemoveKeyLease: bool,
        aSendUnregToServer: bool,
    ) -> otError;
}
extern "C" {
    #[doc = " This function clears all host info and all the services."]
    #[doc = ""]
    #[doc = " Unlike `otSrpClientRemoveHostAndServices()` which sends an update message to the server to remove all the info, this"]
    #[doc = " function clears all the info immediately without any interaction with the server."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        A pointer to the OpenThread instance."]
    #[doc = ""]
    pub fn otSrpClientClearHostAndServices(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function gets the domain name being used by SRP client."]
    #[doc = ""]
    #[doc = " This function requires `OPENTHREAD_CONFIG_SRP_CLIENT_DOMAIN_NAME_API_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " If domain name is not set, \"default.service.arpa\" will be used."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The domain name string."]
    #[doc = ""]
    pub fn otSrpClientGetDomainName(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function sets the domain name to be used by SRP client."]
    #[doc = ""]
    #[doc = " This function requires `OPENTHREAD_CONFIG_SRP_CLIENT_DOMAIN_NAME_API_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " If not set \"default.service.arpa\" will be used."]
    #[doc = ""]
    #[doc = " The name string buffer pointed to by @p aName MUST persist and stay unchanged after returning from this function."]
    #[doc = " OpenThread will keep the pointer to the string."]
    #[doc = ""]
    #[doc = " The domain name can be set before client is started or after start but before host info is registered with server"]
    #[doc = " (host info should be in either `STATE_TO_ADD` or `STATE_TO_REMOVE`)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance     A pointer to the OpenThread instance."]
    #[doc = " @param[in] aName         A pointer to the domain name string. If NULL sets it to default \"default.service.arpa\"."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            The domain name label was set successfully."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   The host info is already registered with server."]
    #[doc = ""]
    pub fn otSrpClientSetDomainName(
        aInstance: *mut otInstance,
        aName: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function converts a `otSrpClientItemState` to a string."]
    #[doc = ""]
    #[doc = " @param[in] aItemState  An item state."]
    #[doc = ""]
    #[doc = " @returns A string representation of @p aItemState."]
    #[doc = ""]
    pub fn otSrpClientItemStateToString(
        aItemState: otSrpClientItemState,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function enables/disables \"service key record inclusion\" mode."]
    #[doc = ""]
    #[doc = " When enabled, SRP client will include KEY record in Service Description Instructions in the SRP update messages"]
    #[doc = " that it sends."]
    #[doc = ""]
    #[doc = " This function is available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` configuration is enabled."]
    #[doc = ""]
    #[doc = " @note KEY record is optional in Service Description Instruction (it is required and always included in the Host"]
    #[doc = " Description Instruction). The default behavior of SRP client is to not include it. This function is intended to"]
    #[doc = " override the default behavior for testing only."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to the OpenThread instance."]
    #[doc = " @param[in] aEnabled   TRUE to enable, FALSE to disable the \"service key record inclusion\" mode."]
    #[doc = ""]
    pub fn otSrpClientSetServiceKeyRecordEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " This method indicates whether the \"service key record inclusion\" mode is enabled or disabled."]
    #[doc = ""]
    #[doc = " This function is available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` configuration is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance     A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns TRUE if \"service key record inclusion\" mode is enabled, FALSE otherwise."]
    #[doc = ""]
    pub fn otSrpClientIsServiceKeyRecordEnabled(aInstance: *mut otInstance) -> bool;
}
#[doc = " This struct represents a SRP client service pool entry."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSrpClientBuffersServiceEntry {
    #[doc = "< The SRP client service structure."]
    pub mService: otSrpClientService,
    #[doc = "< The SRP client TXT entry."]
    pub mTxtEntry: otDnsTxtEntry,
}
impl Default for otSrpClientBuffersServiceEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function gets the string buffer to use for SRP client host name."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to the OpenThread instance."]
    #[doc = " @param[out] aSize      Pointer to a variable to return the size (number of bytes) of the string buffer (MUST NOT be"]
    #[doc = "                        NULL)."]
    #[doc = ""]
    #[doc = " @returns A pointer to char buffer to use for SRP client host name."]
    #[doc = ""]
    pub fn otSrpClientBuffersGetHostNameString(
        aInstance: *mut otInstance,
        aSize: *mut u16,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function gets the array of IPv6 address entries to use as SRP client host address list."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to the OpenThread instance."]
    #[doc = " @param[out] aArrayLength  Pointer to a variable to return the array length i.e., number of IPv6 address entries in"]
    #[doc = "                           the array (MUST NOT be NULL)."]
    #[doc = ""]
    #[doc = " @returns A pointer to an array of `otIp6Address` entries (number of entries is returned in @p aArrayLength)."]
    #[doc = ""]
    pub fn otSrpClientBuffersGetHostAddressesArray(
        aInstance: *mut otInstance,
        aArrayLength: *mut u8,
    ) -> *mut otIp6Address;
}
extern "C" {
    #[doc = " This function allocates a new service entry from the pool."]
    #[doc = ""]
    #[doc = " The returned service entry instance will be initialized as follows:"]
    #[doc = ""]
    #[doc = "  - `mService.mName` will point to an allocated string buffer which can be retrieved using the function"]
    #[doc = "    `otSrpClientBuffersGetServiceEntryServiceNameString()`."]
    #[doc = "  - `mService.mInstanceName` will point to an allocated string buffer which can be retrieved using the function"]
    #[doc = "    `otSrpClientBuffersGetServiceEntryInstanceNameString()`."]
    #[doc = "  - `mService.mSubTypeLabels` points to an array that is returned from `otSrpClientBuffersGetSubTypeLabelsArray()`."]
    #[doc = "  - `mService.mTxtEntries` will point to `mTxtEntry`."]
    #[doc = "  - `mService.mNumTxtEntries` will be set to one."]
    #[doc = "  - Other `mService` fields (port, priority, weight) are set to zero."]
    #[doc = "  - `mTxtEntry.mKey` is set to NULL (value is treated as already encoded)."]
    #[doc = "  - `mTxtEntry.mValue` will point to an allocated buffer which can be retrieved using the function"]
    #[doc = "    `otSrpClientBuffersGetServiceEntryTxtBuffer()`."]
    #[doc = "  - `mTxtEntry.mValueLength` is set to zero."]
    #[doc = "  - All related data/string buffers and arrays are cleared to all zero."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   A pointer to the OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the newly allocated service entry or NULL if not more entry available in the pool."]
    #[doc = ""]
    pub fn otSrpClientBuffersAllocateService(
        aInstance: *mut otInstance,
    ) -> *mut otSrpClientBuffersServiceEntry;
}
extern "C" {
    #[doc = " This function frees a previously allocated service entry."]
    #[doc = ""]
    #[doc = " The @p aService MUST be previously allocated using `otSrpClientBuffersAllocateService()` and not yet freed. Otherwise"]
    #[doc = " the behavior of this function is undefined."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   A pointer to the OpenThread instance."]
    #[doc = " @param[in] aService    A pointer to the service entry to free (MUST NOT be NULL)."]
    #[doc = ""]
    pub fn otSrpClientBuffersFreeService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientBuffersServiceEntry,
    );
}
extern "C" {
    #[doc = " This function frees all previously allocated service entries."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   A pointer to the OpenThread instance."]
    #[doc = ""]
    pub fn otSrpClientBuffersFreeAllServices(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function gets the string buffer for service name from a service entry."]
    #[doc = ""]
    #[doc = " @param[in]  aEntry   A pointer to a previously allocated service entry (MUST NOT be NULL)."]
    #[doc = " @param[out] aSize    A pointer to a variable to return the size (number of bytes) of the string buffer (MUST NOT be"]
    #[doc = "                      NULL)."]
    #[doc = ""]
    #[doc = " @returns A pointer to the string buffer."]
    #[doc = ""]
    pub fn otSrpClientBuffersGetServiceEntryServiceNameString(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aSize: *mut u16,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function gets the string buffer for service instance name from a service entry."]
    #[doc = ""]
    #[doc = " @param[in]  aEntry   A pointer to a previously allocated service entry (MUST NOT be NULL)."]
    #[doc = " @param[out] aSize    A pointer to a variable to return the size (number of bytes) of the string buffer (MUST NOT be"]
    #[doc = "                      NULL)."]
    #[doc = ""]
    #[doc = " @returns A pointer to the string buffer."]
    #[doc = ""]
    pub fn otSrpClientBuffersGetServiceEntryInstanceNameString(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aSize: *mut u16,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function gets the buffer for TXT record from a service entry."]
    #[doc = ""]
    #[doc = " @param[in]  aEntry   A pointer to a previously allocated service entry (MUST NOT be NULL)."]
    #[doc = " @param[out] aSize    A pointer to a variable to return the size (number of bytes) of the buffer (MUST NOT be NULL)."]
    #[doc = ""]
    #[doc = " @returns A pointer to the buffer."]
    #[doc = ""]
    pub fn otSrpClientBuffersGetServiceEntryTxtBuffer(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aSize: *mut u16,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " This function gets the array for service subtype labels from the service entry."]
    #[doc = ""]
    #[doc = " @param[in]  aEntry          A pointer to a previously allocated service entry (MUST NOT be NULL)."]
    #[doc = " @param[out] aArrayLength    A pointer to a variable to return the array length (MUST NOT be NULL)."]
    #[doc = ""]
    #[doc = " @returns A pointer to the array."]
    #[doc = ""]
    pub fn otSrpClientBuffersGetSubTypeLabelsArray(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aArrayLength: *mut u16,
    ) -> *mut *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSrpServerHost {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSrpServerService {
    _unused: [u8; 0],
}
#[doc = " The ID of a SRP service update transaction on the SRP Server."]
#[doc = ""]
pub type otSrpServerServiceUpdateId = u32;
#[doc = " The service flag type to indicate which services to include or exclude when searching in (or iterating over) the"]
#[doc = " list of SRP services."]
#[doc = ""]
#[doc = " This is a combination of bit-flags. The specific bit-flags are defined in the enumeration `OT_SRP_SERVER_FLAG_*`."]
#[doc = ""]
pub type otSrpServerServiceFlags = u8;
#[doc = "< Include base services (not a sub-type)."]
pub const OT_SRP_SERVER_SERVICE_FLAG_BASE_TYPE: _bindgen_ty_13 = 1;
#[doc = "< Include sub-type services."]
pub const OT_SRP_SERVER_SERVICE_FLAG_SUB_TYPE: _bindgen_ty_13 = 2;
#[doc = "< Include active (not deleted) services."]
pub const OT_SRP_SERVER_SERVICE_FLAG_ACTIVE: _bindgen_ty_13 = 4;
#[doc = "< Include deleted services."]
pub const OT_SRP_SERVER_SERVICE_FLAG_DELETED: _bindgen_ty_13 = 8;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
#[doc = " This constant defines an `otSrpServerServiceFlags` combination accepting any service (base/sub-type,"]
#[doc = " active/deleted)."]
#[doc = ""]
pub const OT_SRP_SERVER_FLAGS_ANY_SERVICE: _bindgen_ty_14 = 15;
#[doc = " This constant defines an `otSrpServerServiceFlags` combination accepting base service only."]
#[doc = ""]
pub const OT_SRP_SERVER_FLAGS_BASE_TYPE_SERVICE_ONLY: _bindgen_ty_14 = 13;
#[doc = " This constant defines an `otSrpServerServiceFlags` combination accepting sub-type service only."]
#[doc = ""]
pub const OT_SRP_SERVER_FLAGS_SUB_TYPE_SERVICE_ONLY: _bindgen_ty_14 = 14;
#[doc = " This constant defines an `otSrpServerServiceFlags` combination accepting any active service (not deleted)."]
#[doc = ""]
pub const OT_SRP_SERVER_FLAGS_ANY_TYPE_ACTIVE_SERVICE: _bindgen_ty_14 = 7;
#[doc = " This constant defines an `otSrpServerServiceFlags` combination accepting any deleted service."]
#[doc = ""]
pub const OT_SRP_SERVER_FLAGS_ANY_TYPE_DELETED_SERVICE: _bindgen_ty_14 = 7;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
#[doc = "< The SRP server is disabled."]
pub const OT_SRP_SERVER_STATE_DISABLED: otSrpServerState = 0;
#[doc = "< The SRP server is enabled and running."]
pub const OT_SRP_SERVER_STATE_RUNNING: otSrpServerState = 1;
#[doc = "< The SRP server is enabled but stopped."]
pub const OT_SRP_SERVER_STATE_STOPPED: otSrpServerState = 2;
#[doc = " This enumeration represents the state of the SRP server."]
#[doc = ""]
pub type otSrpServerState = ::std::os::raw::c_uint;
#[doc = "< Unicast address mode."]
pub const OT_SRP_SERVER_ADDRESS_MODE_UNICAST: otSrpServerAddressMode = 0;
#[doc = "< Anycast address mode."]
pub const OT_SRP_SERVER_ADDRESS_MODE_ANYCAST: otSrpServerAddressMode = 1;
#[doc = " This enumeration represents the address mode used by the SRP server."]
#[doc = ""]
#[doc = " Address mode specifies how the address and port number are determined by the SRP server and how this info is"]
#[doc = " published in the Thread Network Data."]
#[doc = ""]
pub type otSrpServerAddressMode = ::std::os::raw::c_uint;
#[doc = " This structure includes SRP server TTL configurations."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otSrpServerTtlConfig {
    #[doc = "< The minimum TTL in seconds."]
    pub mMinTtl: u32,
    #[doc = "< The maximum TTL in seconds."]
    pub mMaxTtl: u32,
}
#[doc = " This structure includes SRP server LEASE and KEY-LEASE configurations."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otSrpServerLeaseConfig {
    #[doc = "< The minimum LEASE interval in seconds."]
    pub mMinLease: u32,
    #[doc = "< The maximum LEASE interval in seconds."]
    pub mMaxLease: u32,
    #[doc = "< The minimum KEY-LEASE interval in seconds."]
    pub mMinKeyLease: u32,
    #[doc = "< The maximum KEY-LEASE interval in seconds."]
    pub mMaxKeyLease: u32,
}
#[doc = " This structure includes SRP server lease information of a host/service."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otSrpServerLeaseInfo {
    #[doc = "< The lease time of a host/service in milliseconds."]
    pub mLease: u32,
    #[doc = "< The key lease time of a host/service in milliseconds."]
    pub mKeyLease: u32,
    #[doc = "< The remaining lease time of the host/service in milliseconds."]
    pub mRemainingLease: u32,
    #[doc = "< The remaining key lease time of a host/service in milliseconds."]
    pub mRemainingKeyLease: u32,
}
#[doc = " This structure includes the statistics of SRP server responses."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otSrpServerResponseCounters {
    #[doc = "< The number of successful responses."]
    pub mSuccess: u32,
    #[doc = "< The number of server failure responses."]
    pub mServerFailure: u32,
    #[doc = "< The number of format error responses."]
    pub mFormatError: u32,
    #[doc = "< The number of 'name exists' responses."]
    pub mNameExists: u32,
    #[doc = "< The number of refused responses."]
    pub mRefused: u32,
    #[doc = "< The number of other responses."]
    pub mOther: u32,
}
extern "C" {
    #[doc = " This function returns the domain authorized to the SRP server."]
    #[doc = ""]
    #[doc = " If the domain if not set by SetDomain, \"default.service.arpa.\" will be returned."]
    #[doc = " A trailing dot is always appended even if the domain is set without it."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns A pointer to the dot-joined domain string."]
    #[doc = ""]
    pub fn otSrpServerGetDomain(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function sets the domain on the SRP server."]
    #[doc = ""]
    #[doc = " A trailing dot will be appended to @p aDomain if it is not already there."]
    #[doc = " This function should only be called before the SRP server is enabled."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDomain    The domain to be set. MUST NOT be NULL."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE           Successfully set the domain to @p aDomain."]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  The SRP server is already enabled and the Domain cannot be changed."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS   The argument @p aDomain is not a valid DNS domain name."]
    #[doc = " @retval  OT_ERROR_NO_BUFS        There is no memory to store content of @p aDomain."]
    #[doc = ""]
    pub fn otSrpServerSetDomain(
        aInstance: *mut otInstance,
        aDomain: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns the state of the SRP server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The current state of the SRP server."]
    #[doc = ""]
    pub fn otSrpServerGetState(aInstance: *mut otInstance) -> otSrpServerState;
}
extern "C" {
    #[doc = " This function returns the port the SRP server is listening to."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  The port of the SRP server. It returns 0 if the server is not running."]
    #[doc = ""]
    pub fn otSrpServerGetPort(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " This function returns the address mode being used by the SRP server."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The SRP server's address mode."]
    #[doc = ""]
    pub fn otSrpServerGetAddressMode(aInstance: *mut otInstance) -> otSrpServerAddressMode;
}
extern "C" {
    #[doc = " This function sets the address mode to be used by the SRP server."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in] aMode      The address mode to use."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the address mode."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  The SRP server is enabled and the address mode cannot be changed."]
    #[doc = ""]
    pub fn otSrpServerSetAddressMode(
        aInstance: *mut otInstance,
        aMode: otSrpServerAddressMode,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns the sequence number used with anycast address mode."]
    #[doc = ""]
    #[doc = " The sequence number is included in \"DNS/SRP Service Anycast Address\" entry published in the Network Data."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The anycast sequence number."]
    #[doc = ""]
    pub fn otSrpServerGetAnycastModeSequenceNumber(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " This function sets the sequence number used with anycast address mode."]
    #[doc = ""]
    #[doc = " @param[in] aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in] aSequenceNumber  The sequence number to use."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE            Successfully set the address mode."]
    #[doc = " @retval OT_ERROR_INVALID_STATE   The SRP server is enabled and the sequence number cannot be changed."]
    #[doc = ""]
    pub fn otSrpServerSetAnycastModeSequenceNumber(
        aInstance: *mut otInstance,
        aSequenceNumber: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function enables/disables the SRP server."]
    #[doc = ""]
    #[doc = " On a Border Router, it is recommended to use `otSrpServerSetAutoEnableMode()` instead."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnabled   A boolean to enable/disable the SRP server."]
    #[doc = ""]
    pub fn otSrpServerSetEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " This function enables/disables the auto-enable mode on SRP server."]
    #[doc = ""]
    #[doc = " This function requires `OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE` feature."]
    #[doc = ""]
    #[doc = " When this mode is enabled, the Border Routing Manager controls if/when to enable or disable the SRP server."]
    #[doc = " SRP sever is auto-enabled if/when Border Routing is started and it is done with the initial prefix and route"]
    #[doc = " configurations (when the OMR and on-link prefixes are determined, advertised in emitted Router Advertisement message"]
    #[doc = " on infrastructure side and published in the Thread Network Data). The SRP server is auto-disabled if/when BR is"]
    #[doc = " stopped (e.g., if the infrastructure network interface is brought down or if BR gets detached)."]
    #[doc = ""]
    #[doc = " This mode can be disabled by a `otSrpServerSetAutoEnableMode()` call with @p aEnabled set to `false` or if the SRP"]
    #[doc = " server is explicitly enabled or disabled by a call to `otSrpServerSetEnabled()` function. Disabling auto-enable mode"]
    #[doc = " using `otSrpServerSetAutoEnableMode(false)` will not change the current state of SRP sever (e.g., if it is enabled"]
    #[doc = " it stays enabled)."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in] aEnbaled    A boolean to enable/disable the auto-enable mode."]
    #[doc = ""]
    pub fn otSrpServerSetAutoEnableMode(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " This function indicates whether the auto-enable mode is enabled or disabled."]
    #[doc = ""]
    #[doc = " This function requires `OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE` feature."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE   The auto-enable mode is enabled."]
    #[doc = " @retval FALSE  The auto-enable mode is disabled."]
    #[doc = ""]
    pub fn otSrpServerIsAutoEnableMode(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function returns SRP server TTL configuration."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aTtlConfig  A pointer to an `otSrpServerTtlConfig` instance."]
    #[doc = ""]
    pub fn otSrpServerGetTtlConfig(
        aInstance: *mut otInstance,
        aTtlConfig: *mut otSrpServerTtlConfig,
    );
}
extern "C" {
    #[doc = " This function sets SRP server TTL configuration."]
    #[doc = ""]
    #[doc = " The granted TTL will always be no greater than the max lease interval configured via `otSrpServerSetLeaseConfig()`,"]
    #[doc = " regardless of the minimum and maximum TTL configuration."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aTtlConfig  A pointer to an `otSrpServerTtlConfig` instance."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE          Successfully set the TTL configuration."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS  The TTL configuration is not valid."]
    #[doc = ""]
    pub fn otSrpServerSetTtlConfig(
        aInstance: *mut otInstance,
        aTtlConfig: *const otSrpServerTtlConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns SRP server LEASE and KEY-LEASE configurations."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aLeaseConfig  A pointer to an `otSrpServerLeaseConfig` instance."]
    #[doc = ""]
    pub fn otSrpServerGetLeaseConfig(
        aInstance: *mut otInstance,
        aLeaseConfig: *mut otSrpServerLeaseConfig,
    );
}
extern "C" {
    #[doc = " This function sets SRP server LEASE and KEY-LEASE configurations."]
    #[doc = ""]
    #[doc = " When a non-zero LEASE time is requested from a client, the granted value will be"]
    #[doc = " limited in range [aMinLease, aMaxLease]; and a non-zero KEY-LEASE will be granted"]
    #[doc = " in range [aMinKeyLease, aMaxKeyLease]. For zero LEASE or KEY-LEASE time, zero will"]
    #[doc = " be granted."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aLeaseConfig  A pointer to an `otSrpServerLeaseConfig` instance."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE          Successfully set the LEASE and KEY-LEASE ranges."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS  The LEASE or KEY-LEASE range is not valid."]
    #[doc = ""]
    pub fn otSrpServerSetLeaseConfig(
        aInstance: *mut otInstance,
        aLeaseConfig: *const otSrpServerLeaseConfig,
    ) -> otError;
}
#[doc = " This function handles SRP service updates."]
#[doc = ""]
#[doc = " This function is called by the SRP server to notify that a SRP host and possibly SRP services"]
#[doc = " are being updated. It is important that the SRP updates are not committed until the handler"]
#[doc = " returns the result by calling otSrpServerHandleServiceUpdateResult or times out after @p aTimeout."]
#[doc = ""]
#[doc = " A SRP service observer should always call otSrpServerHandleServiceUpdateResult with error code"]
#[doc = " OT_ERROR_NONE immediately after receiving the update events."]
#[doc = ""]
#[doc = " A more generic handler may perform validations on the SRP host/services and rejects the SRP updates"]
#[doc = " if any validation fails. For example, an Advertising Proxy should advertise (or remove) the host and"]
#[doc = " services on a multicast-capable link and returns specific error code if any failure occurs."]
#[doc = ""]
#[doc = " @param[in]  aId       The service update transaction ID. This ID must be passed back with"]
#[doc = "                       `otSrpServerHandleServiceUpdateResult`."]
#[doc = " @param[in]  aHost     A pointer to the otSrpServerHost object which contains the SRP updates. The"]
#[doc = "                       handler should publish/un-publish the host and each service points to this"]
#[doc = "                       host with below rules:"]
#[doc = "                         1. If the host is not deleted (indicated by `otSrpServerHostIsDeleted`),"]
#[doc = "                            then it should be published or updated with mDNS. Otherwise, the host"]
#[doc = "                            should be un-published (remove AAAA RRs)."]
#[doc = "                         2. For each service points to this host, it must be un-published if the host"]
#[doc = "                            is to be un-published. Otherwise, the handler should publish or update the"]
#[doc = "                            service when it is not deleted (indicated by `otSrpServerServiceIsDeleted`)"]
#[doc = "                            and un-publish it when deleted."]
#[doc = " @param[in]  aTimeout  The maximum time in milliseconds for the handler to process the service event."]
#[doc = " @param[in]  aContext  A pointer to application-specific context."]
#[doc = ""]
#[doc = " @sa otSrpServerSetServiceUpdateHandler"]
#[doc = " @sa otSrpServerHandleServiceUpdateResult"]
#[doc = ""]
pub type otSrpServerServiceUpdateHandler = ::std::option::Option<
    unsafe extern "C" fn(
        aId: otSrpServerServiceUpdateId,
        aHost: *const otSrpServerHost,
        aTimeout: u32,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function sets the SRP service updates handler on SRP server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aServiceHandler  A pointer to a service handler. Use NULL to remove the handler."]
    #[doc = " @param[in]  aContext         A pointer to arbitrary context information."]
    #[doc = "                              May be NULL if not used."]
    #[doc = ""]
    pub fn otSrpServerSetServiceUpdateHandler(
        aInstance: *mut otInstance,
        aServiceHandler: otSrpServerServiceUpdateHandler,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function reports the result of processing a SRP update to the SRP server."]
    #[doc = ""]
    #[doc = " The Service Update Handler should call this function to return the result of its"]
    #[doc = " processing of a SRP update."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aId        The service update transaction ID. This should be the same ID"]
    #[doc = "                        provided via `otSrpServerServiceUpdateHandler`."]
    #[doc = " @param[in]  aError     An error to be returned to the SRP server. Use OT_ERROR_DUPLICATED"]
    #[doc = "                        to represent DNS name conflicts."]
    #[doc = ""]
    pub fn otSrpServerHandleServiceUpdateResult(
        aInstance: *mut otInstance,
        aId: otSrpServerServiceUpdateId,
        aError: otError,
    );
}
extern "C" {
    #[doc = " This function returns the next registered host on the SRP server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aHost      A pointer to current host; use NULL to get the first host."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the registered host. NULL, if no more hosts can be found."]
    #[doc = ""]
    pub fn otSrpServerGetNextHost(
        aInstance: *mut otInstance,
        aHost: *const otSrpServerHost,
    ) -> *const otSrpServerHost;
}
extern "C" {
    #[doc = " This function returns the response counters of the SRP server."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the response counters of the SRP server."]
    #[doc = ""]
    pub fn otSrpServerGetResponseCounters(
        aInstance: *mut otInstance,
    ) -> *const otSrpServerResponseCounters;
}
extern "C" {
    #[doc = " This function tells if the SRP service host has been deleted."]
    #[doc = ""]
    #[doc = " A SRP service host can be deleted but retains its name for future uses."]
    #[doc = " In this case, the host instance is not removed from the SRP server/registry."]
    #[doc = ""]
    #[doc = " @param[in]  aHost  A pointer to the SRP service host."]
    #[doc = ""]
    #[doc = " @returns  TRUE if the host has been deleted, FALSE if not."]
    #[doc = ""]
    pub fn otSrpServerHostIsDeleted(aHost: *const otSrpServerHost) -> bool;
}
extern "C" {
    #[doc = " This function returns the full name of the host."]
    #[doc = ""]
    #[doc = " @param[in]  aHost  A pointer to the SRP service host."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the null-terminated host name string."]
    #[doc = ""]
    pub fn otSrpServerHostGetFullName(
        aHost: *const otSrpServerHost,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function returns the addresses of given host."]
    #[doc = ""]
    #[doc = " @param[in]   aHost          A pointer to the SRP service host."]
    #[doc = " @param[out]  aAddressesNum  A pointer to where we should output the number of the addresses to."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the array of IPv6 Address."]
    #[doc = ""]
    pub fn otSrpServerHostGetAddresses(
        aHost: *const otSrpServerHost,
        aAddressesNum: *mut u8,
    ) -> *const otIp6Address;
}
extern "C" {
    #[doc = " This function returns the LEASE and KEY-LEASE information of a given host."]
    #[doc = ""]
    #[doc = " @param[in]   aHost       A pointer to the SRP server host."]
    #[doc = " @param[out]  aLeaseInfo  A pointer to where to output the LEASE and KEY-LEASE information."]
    #[doc = ""]
    pub fn otSrpServerHostGetLeaseInfo(
        aHost: *const otSrpServerHost,
        aLeaseInfo: *mut otSrpServerLeaseInfo,
    );
}
extern "C" {
    #[doc = " This function returns the next service (excluding any sub-type services) of given host."]
    #[doc = ""]
    #[doc = " @note This function is being deprecated and will be removed. `otSrpServerHostFindNextService()` can be used"]
    #[doc = "       instead."]
    #[doc = ""]
    #[doc = " @param[in]  aHost     A pointer to the SRP service host."]
    #[doc = " @param[in]  aService  A pointer to current SRP service instance; use NULL to get the first service."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the next service or NULL if there is no more services."]
    #[doc = ""]
    pub fn otSrpServerHostGetNextService(
        aHost: *const otSrpServerHost,
        aService: *const otSrpServerService,
    ) -> *const otSrpServerService;
}
extern "C" {
    #[doc = " This function finds the next matching service on the host."]
    #[doc = ""]
    #[doc = " The combination of flags and service and instance names enables iterating over the full list of services and/or a"]
    #[doc = " subset of them matching certain conditions, or finding a specific service."]
    #[doc = ""]
    #[doc = " To iterate over all services of a host:"]
    #[doc = "   service = otSrpServerHostFindNextService(host, service, OT_SRP_SERVER_FLAGS_ANY_SERVICE, NULL, NULL);"]
    #[doc = ""]
    #[doc = " To iterate over base services only (exclude sub-types):"]
    #[doc = "   service = otSrpServerHostFindNextService(host, service, OT_SRP_SERVER_FLAGS_BASE_TYPE_SERVICE_ONLY, NULL, NULL);"]
    #[doc = ""]
    #[doc = " To iterate over sub-types of a specific instance name `instanceName`:"]
    #[doc = "   service = otSrpServerHostFindNextService(host, service, OT_SRP_SERVER_FLAGS_SUB_TYPE_SERVICE_ONLY, NULL,"]
    #[doc = "                                            instanceName);"]
    #[doc = ""]
    #[doc = " To find a specific service with service name `serviceName` and service instance name `instanceName`:"]
    #[doc = "   service = otSrpServerHostFindNextService(host, NULL, OT_SRP_SERVER_FLAGS_ANY_SERVICE, serviceName, instanceName);"]
    #[doc = ""]
    #[doc = " To find the base type service with a given service instance name `instanceName`:"]
    #[doc = "   service = otSrpServerHostFindNextService(host, NULL, OT_SRP_SERVER_FLAGS_BASE_TYPE_SERVICE_ONLY, NULL,"]
    #[doc = "                                            instanceName);"]
    #[doc = ""]
    #[doc = " @param[in] aHost          A pointer to the SRP service host (MUST NOT be NULL)."]
    #[doc = " @param[in] aPrevService   A pointer to the previous service or NULL to start from the beginning of the list."]
    #[doc = " @param[in] aFlags         Flags indicating which services to include (base/sub-type, active/deleted)."]
    #[doc = " @param[in] aServiceName   The service name to match. Set to NULL to accept any name."]
    #[doc = " @param[in] aInstanceName  The service instance name to match. Set to NULL to accept any name."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the next matching service or NULL if no matching service could be found."]
    #[doc = ""]
    pub fn otSrpServerHostFindNextService(
        aHost: *const otSrpServerHost,
        aPrevService: *const otSrpServerService,
        aFlags: otSrpServerServiceFlags,
        aServiceName: *const ::std::os::raw::c_char,
        aInstanceName: *const ::std::os::raw::c_char,
    ) -> *const otSrpServerService;
}
extern "C" {
    #[doc = " This function indicates whether or not the SRP service has been deleted."]
    #[doc = ""]
    #[doc = " A SRP service can be deleted but retains its name for future uses."]
    #[doc = " In this case, the service instance is not removed from the SRP server/registry."]
    #[doc = " It is guaranteed that all services are deleted if the host is deleted."]
    #[doc = ""]
    #[doc = " @param[in]  aService  A pointer to the SRP service."]
    #[doc = ""]
    #[doc = " @returns  TRUE if the service has been deleted, FALSE if not."]
    #[doc = ""]
    pub fn otSrpServerServiceIsDeleted(aService: *const otSrpServerService) -> bool;
}
extern "C" {
    #[doc = " This function indicates whether or not the SRP service is sub-type."]
    #[doc = ""]
    #[doc = " @param[in]  aService  A pointer to the SRP service."]
    #[doc = ""]
    #[doc = " @returns  TRUE if the service is a sub-type, FALSE if not."]
    #[doc = ""]
    pub fn otSrpServerServiceIsSubType(aService: *const otSrpServerService) -> bool;
}
extern "C" {
    #[doc = " This function returns the full service instance name of the service."]
    #[doc = ""]
    #[doc = " @note This function is being deprecated and will be removed. `otSrpServerServiceGetInstanceName()` can be used"]
    #[doc = "       instead."]
    #[doc = ""]
    #[doc = " @param[in]  aService  A pointer to the SRP service."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the null-terminated service instance name string."]
    #[doc = ""]
    pub fn otSrpServerServiceGetFullName(
        aService: *const otSrpServerService,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function returns the full service instance name of the service."]
    #[doc = ""]
    #[doc = " @param[in]  aService  A pointer to the SRP service."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the null-terminated service instance name string."]
    #[doc = ""]
    pub fn otSrpServerServiceGetInstanceName(
        aService: *const otSrpServerService,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function returns the full service name of the service."]
    #[doc = ""]
    #[doc = " @param[in]  aService  A pointer to the SRP service."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the null-terminated service name string."]
    #[doc = ""]
    pub fn otSrpServerServiceGetServiceName(
        aService: *const otSrpServerService,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function gets the sub-type label from service name."]
    #[doc = ""]
    #[doc = " This function is intended to be used when the @p aService is a sub-type, i.e., `otSrpServerServiceIsSubType()` for"]
    #[doc = " the service returns TRUE. If it is not a sub-type this function returns `OT_ERROR_INVALID_ARGS`."]
    #[doc = ""]
    #[doc = " The full service name for a sub-type service follows \"<sub-label>._sub.<service-labels>.<domain>.\". This function"]
    #[doc = " copies the `<sub-label>` into the @p aLabel buffer."]
    #[doc = ""]
    #[doc = " The @p aLabel is ensured to always be null-terminated after returning even in case of failure."]
    #[doc = ""]
    #[doc = " @param[in]  aService           A pointer to the SRP service."]
    #[doc = " @param[out] aLabel             A pointer to a buffer to copy the sub-type label name into."]
    #[doc = " @param[in]  aMaxSize           Maximum size of @p aLabel buffer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          @p aLabel was updated successfully."]
    #[doc = " @retval OT_ERROR_NO_BUFS       The sub-type label could not fit in @p aLabel buffer (number of chars from label"]
    #[doc = "                                that could fit are copied in @p aLabel ensuring it is null-terminated)."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  SRP service is not a sub-type."]
    #[doc = ""]
    pub fn otSrpServerServiceGetServiceSubTypeLabel(
        aService: *const otSrpServerService,
        aLabel: *mut ::std::os::raw::c_char,
        aMaxSize: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns the port of the service instance."]
    #[doc = ""]
    #[doc = " @param[in]  aService  A pointer to the SRP service."]
    #[doc = ""]
    #[doc = " @returns  The port of the service."]
    #[doc = ""]
    pub fn otSrpServerServiceGetPort(aService: *const otSrpServerService) -> u16;
}
extern "C" {
    #[doc = " This function returns the weight of the service instance."]
    #[doc = ""]
    #[doc = " @param[in]  aService  A pointer to the SRP service."]
    #[doc = ""]
    #[doc = " @returns  The weight of the service."]
    #[doc = ""]
    pub fn otSrpServerServiceGetWeight(aService: *const otSrpServerService) -> u16;
}
extern "C" {
    #[doc = " This function returns the priority of the service instance."]
    #[doc = ""]
    #[doc = " @param[in]  aService  A pointer to the SRP service."]
    #[doc = ""]
    #[doc = " @returns  The priority of the service."]
    #[doc = ""]
    pub fn otSrpServerServiceGetPriority(aService: *const otSrpServerService) -> u16;
}
extern "C" {
    #[doc = " This function returns the TTL of the service instance."]
    #[doc = ""]
    #[doc = " @param[in]  aService  A pointer to the SRP service."]
    #[doc = ""]
    #[doc = " @returns  The TTL of the service instance.."]
    #[doc = ""]
    pub fn otSrpServerServiceGetTtl(aService: *const otSrpServerService) -> u32;
}
extern "C" {
    #[doc = " This function returns the TXT record data of the service instance."]
    #[doc = ""]
    #[doc = " @param[in]  aService        A pointer to the SRP service."]
    #[doc = " @param[out] aDataLength     A pointer to return the TXT record data length. MUST NOT be NULL."]
    #[doc = ""]
    #[doc = " @returns A pointer to the buffer containing the TXT record data (the TXT data length is returned in @p aDataLength)."]
    #[doc = ""]
    pub fn otSrpServerServiceGetTxtData(
        aService: *const otSrpServerService,
        aDataLength: *mut u16,
    ) -> *const u8;
}
extern "C" {
    #[doc = " This function returns the host which the service instance reside on."]
    #[doc = ""]
    #[doc = " @param[in]  aService  A pointer to the SRP service."]
    #[doc = ""]
    #[doc = " @returns  A pointer to the host instance."]
    #[doc = ""]
    pub fn otSrpServerServiceGetHost(aService: *const otSrpServerService)
        -> *const otSrpServerHost;
}
extern "C" {
    #[doc = " This function returns the LEASE and KEY-LEASE information of a given service."]
    #[doc = ""]
    #[doc = " @param[in]   aService    A pointer to the SRP server service."]
    #[doc = " @param[out]  aLeaseInfo  A pointer to where to output the LEASE and KEY-LEASE information."]
    #[doc = ""]
    pub fn otSrpServerServiceGetLeaseInfo(
        aService: *const otSrpServerService,
        aLeaseInfo: *mut otSrpServerLeaseInfo,
    );
}
extern "C" {
    #[doc = " Run all queued OpenThread tasklets at the time this is called."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otTaskletsProcess(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Indicates whether or not OpenThread has tasklets pending."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE   If there are tasklets pending."]
    #[doc = " @retval FALSE  If there are no tasklets pending."]
    #[doc = ""]
    pub fn otTaskletsArePending(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " OpenThread calls this function when the tasklet queue transitions from empty to non-empty."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    pub fn otTaskletsSignalPending(aInstance: *mut otInstance);
}
#[doc = " A linked buffer structure for use with TCP."]
#[doc = ""]
#[doc = " A single otLinkedBuffer structure references an array of bytes in memory,"]
#[doc = " via mData and mLength. The mNext field is used to form a chain of"]
#[doc = " otLinkedBuffer structures."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otLinkedBuffer {
    #[doc = "< Pointer to the next linked buffer in the chain, or NULL if it is the end."]
    pub mNext: *mut otLinkedBuffer,
    #[doc = "< Pointer to data referenced by this linked buffer."]
    pub mData: *const u8,
    #[doc = "< Length of this linked buffer (number of bytes)."]
    pub mLength: usize,
}
impl Default for otLinkedBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This callback informs the application that the TCP 3-way handshake is"]
#[doc = " complete and that the connection is now established."]
#[doc = ""]
#[doc = " @param[in]  aEndpoint  The TCP endpoint whose connection is now established."]
#[doc = ""]
pub type otTcpEstablished =
    ::std::option::Option<unsafe extern "C" fn(aEndpoint: *mut otTcpEndpoint)>;
#[doc = " This callback informs the application that data in the provided"]
#[doc = " @p aData have been acknowledged by the connection peer and that @p aData and"]
#[doc = " the data it contains can be reclaimed by the application."]
#[doc = ""]
#[doc = " The @p aData are guaranteed to be identical to those passed in to TCP via"]
#[doc = " otTcpSendByReference(), including any extensions effected via"]
#[doc = " otTcpSendByExtension()."]
#[doc = ""]
#[doc = " @param[in]  aEndpoint  The TCP endpoint for the connection."]
#[doc = " @param[in]  aData      A pointer to the otLinkedBuffer that can be reclaimed."]
#[doc = ""]
pub type otTcpSendDone = ::std::option::Option<
    unsafe extern "C" fn(aEndpoint: *mut otTcpEndpoint, aData: *mut otLinkedBuffer),
>;
#[doc = " This callback informs the application if forward progress has been made in"]
#[doc = " transferring data from the send buffer to the recipient. This callback is"]
#[doc = " not necessary for correct TCP operation. Most applications can just rely on"]
#[doc = " the otTcpSendDone() callback to reclaim linked buffers once the TCP stack is"]
#[doc = " done using them. The purpose of this callback is to support advanced"]
#[doc = " applications that benefit from finer-grained information about how the"]
#[doc = " the connection is making forward progress in transferring data to the"]
#[doc = " connection peer."]
#[doc = ""]
#[doc = " This callback's operation is closely tied to TCP's send buffer. The send"]
#[doc = " buffer can be understood as having two regions. First, there is the"]
#[doc = " \"in-flight\" region at the head (front) of the send buffer. It corresponds"]
#[doc = " to data which has been sent to the recipient, but is not yet acknowledged."]
#[doc = " Second, there is the \"backlog\" region, which consists of all data in the"]
#[doc = " send buffer that is not in the \"in-flight\" region. The \"backlog\" region"]
#[doc = " corresponds to data that is queued for sending, but has not yet been sent."]
#[doc = ""]
#[doc = " The callback is invoked in response to two types of events. First, the"]
#[doc = " \"in-flight\" region of the send buffer may shrink (e.g., when the recipient"]
#[doc = " acknowledges data that we sent earlier). Second, the \"backlog\" region of the"]
#[doc = " send buffer may shrink (e.g., new data was sent out). These two conditions"]
#[doc = " often occur at the same time, in response to an ACK segment from the"]
#[doc = " connection peer, which is why they are combined in a single callback."]
#[doc = ""]
#[doc = " The TCP stack only uses the @p aInSendBuffer bytes at the tail of the send"]
#[doc = " buffer; when @p aInSendBuffer decreases by an amount x, it means that x"]
#[doc = " additional bytes that were formerly at the head of the send buffer are no"]
#[doc = " longer part of the send buffer and can now be reclaimed (i.e., overwritten)"]
#[doc = " by the application. Note that the otLinkedBuffer structure itself can only"]
#[doc = " be reclaimed once all bytes that it references are no longer part of the"]
#[doc = " send buffer."]
#[doc = ""]
#[doc = " This callback subsumes otTcpSendDone(), in the following sense: applications"]
#[doc = " can determine when linked buffers can be reclaimed by comparing"]
#[doc = " @p aInSendBuffer with how many bytes are in each linked buffer. However, we"]
#[doc = " expect otTcpSendDone(), which directly conveys which otLinkedBuffers can be"]
#[doc = " reclaimed, to be much simpler to use. If both callbacks are registered and"]
#[doc = " are triggered by the same event (e.g., the same ACK segment received), then"]
#[doc = " the otTcpSendDone() callback will be triggered first, followed by this"]
#[doc = " callback."]
#[doc = ""]
#[doc = " Additionally, this callback provides @p aBacklog, which indicates how many"]
#[doc = " bytes of data in the send buffer are not yet in flight. For applications"]
#[doc = " that only want to add data to the send buffer when there is an assurance"]
#[doc = " that it will be sent out soon, it may be desirable to only send out data"]
#[doc = " when @p aBacklog is suitably small (0 or close to 0). For example, an"]
#[doc = " application may use @p aBacklog so that it can react to queue buildup by"]
#[doc = " dropping or aggregating data to avoid creating a backlog of data."]
#[doc = ""]
#[doc = " After a call to otTcpSendByReference() or otTcpSendByExtension() with a"]
#[doc = " positive number of bytes, the otTcpForwardProgress() callback is guaranteed"]
#[doc = " to be called, to indicate when the bytes that were added to the send buffer"]
#[doc = " are sent out. The call to otTcpForwardProgress() may be made immediately"]
#[doc = " after the bytes are added to the send buffer (if some of those bytes are"]
#[doc = " immediately sent out, reducing the backlog), or sometime in the future (once"]
#[doc = " the connection sends out some or all of the data, reducing the backlog). By"]
#[doc = " \"immediately,\" we mean that the callback is immediately scheduled for"]
#[doc = " execution in a tasklet; to avoid reentrancy-related complexity, the"]
#[doc = " otTcpForwardProgress() callback is never directly called from the"]
#[doc = " otTcpSendByReference() or otTcpSendByExtension() functions."]
#[doc = ""]
#[doc = " @param[in]  aEndpoint      The TCP endpoint for the connection."]
#[doc = " @param[in]  aInSendBuffer  The number of bytes in the send buffer (sum of \"in-flight\" and \"backlog\" regions)."]
#[doc = " @param[in]  aBacklog       The number of bytes that are queued for sending but have not yet been sent (the \"backlog\""]
#[doc = "                            region)."]
#[doc = ""]
pub type otTcpForwardProgress = ::std::option::Option<
    unsafe extern "C" fn(aEndpoint: *mut otTcpEndpoint, aInSendBuffer: usize, aBacklog: usize),
>;
#[doc = " This callback indicates the number of bytes available for consumption from"]
#[doc = " the receive buffer."]
#[doc = ""]
#[doc = " It is called whenever bytes are added to the receive buffer and when the"]
#[doc = " end of stream is reached. If the end of the stream has been reached (i.e.,"]
#[doc = " if no more data will become available to read because the connection peer"]
#[doc = " has closed their end of the connection for writing), then @p aEndOfStream is"]
#[doc = " true. Finally, @p aBytesRemaining indicates how much capacity is left in the"]
#[doc = " receive buffer to hold additional data that arrives."]
#[doc = ""]
#[doc = " @param[in]  aEndpoint        The TCP endpoint for the connection."]
#[doc = " @param[in]  aBytesAvailable  The number of bytes in the connection's receive buffer."]
#[doc = " @param[in]  aEndOfStream     Indicates if additional data, beyond what is already in the connection's receive buffer,"]
#[doc = "                              can be received."]
#[doc = " @param[in]  aBytesRemaining  The number of additional bytes that can be received before the receive buffer becomes"]
#[doc = "                              full."]
#[doc = ""]
pub type otTcpReceiveAvailable = ::std::option::Option<
    unsafe extern "C" fn(
        aEndpoint: *mut otTcpEndpoint,
        aBytesAvailable: usize,
        aEndOfStream: bool,
        aBytesRemaining: usize,
    ),
>;
pub const OT_TCP_DISCONNECTED_REASON_NORMAL: otTcpDisconnectedReason = 0;
pub const OT_TCP_DISCONNECTED_REASON_REFUSED: otTcpDisconnectedReason = 1;
pub const OT_TCP_DISCONNECTED_REASON_RESET: otTcpDisconnectedReason = 2;
pub const OT_TCP_DISCONNECTED_REASON_TIME_WAIT: otTcpDisconnectedReason = 3;
pub const OT_TCP_DISCONNECTED_REASON_TIMED_OUT: otTcpDisconnectedReason = 4;
pub type otTcpDisconnectedReason = ::std::os::raw::c_uint;
#[doc = " This callback indicates that the connection was broken and should no longer"]
#[doc = " be used, or that a connection has entered the TIME-WAIT state."]
#[doc = ""]
#[doc = " It can occur if a connection establishment attempt (initiated by calling"]
#[doc = " otTcpConnect()) fails, or any point thereafter (e.g., if the connection"]
#[doc = " times out or an RST segment is received from the connection peer). Once this"]
#[doc = " callback fires, all resources that the application provided for this"]
#[doc = " connection (i.e., any `otLinkedBuffers` and memory they reference, but not"]
#[doc = " the TCP endpoint itself or space for the receive buffers) can be reclaimed."]
#[doc = " In the case of a connection entering the TIME-WAIT state, this callback is"]
#[doc = " called twice, once upon entry into the TIME-WAIT state (with"]
#[doc = " OT_TCP_DISCONNECTED_REASON_TIME_WAIT, and again when the TIME-WAIT state"]
#[doc = " expires (with OT_TCP_DISCONNECTED_REASON_NORMAL)."]
#[doc = ""]
#[doc = " @param[in]  aEndpoint  The TCP endpoint whose connection has been lost."]
#[doc = " @param[in]  aReason    The reason why the connection was lost."]
#[doc = ""]
pub type otTcpDisconnected = ::std::option::Option<
    unsafe extern "C" fn(aEndpoint: *mut otTcpEndpoint, aReason: otTcpDisconnectedReason),
>;
#[doc = " This structure represents a TCP endpoint."]
#[doc = ""]
#[doc = " An TCP endpoint acts an endpoint of TCP connection. It can be used to"]
#[doc = " initiate TCP connections, and, once a TCP connection is established, send"]
#[doc = " data to and receive data from the connection peer."]
#[doc = ""]
#[doc = " The application should not inspect the fields of this structure directly; it"]
#[doc = " should only interact with it via the TCP API functions whose signatures are"]
#[doc = " provided in this file."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otTcpEndpoint {
    pub mTcb: otTcpEndpoint__bindgen_ty_1,
    #[doc = "< A pointer to the next TCP endpoint (internal use only)"]
    pub mNext: *mut otTcpEndpoint,
    #[doc = "< A pointer to application-specific context"]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< \"Established\" callback function"]
    pub mEstablishedCallback: otTcpEstablished,
    #[doc = "< \"Send done\" callback function"]
    pub mSendDoneCallback: otTcpSendDone,
    #[doc = "< \"Forward progress\" callback function"]
    pub mForwardProgressCallback: otTcpForwardProgress,
    #[doc = "< \"Receive available\" callback function"]
    pub mReceiveAvailableCallback: otTcpReceiveAvailable,
    #[doc = "< \"Disconnected\" callback function"]
    pub mDisconnectedCallback: otTcpDisconnected,
    pub mTimers: [u32; 4usize],
    pub mReceiveLinks: [otLinkedBuffer; 2usize],
    pub mSockAddr: otSockAddr,
    pub mPendingCallbacks: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otTcpEndpoint__bindgen_ty_1 {
    pub mSize: [u8; 656usize],
    pub mAlign: u64,
}
impl Default for otTcpEndpoint__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otTcpEndpoint {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure contains arguments to the otTcpEndpointInitialize() function."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otTcpEndpointInitializeArgs {
    #[doc = "< Pointer to application-specific context"]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< \"Established\" callback function"]
    pub mEstablishedCallback: otTcpEstablished,
    #[doc = "< \"Send done\" callback function"]
    pub mSendDoneCallback: otTcpSendDone,
    #[doc = "< \"Forward progress\" callback function"]
    pub mForwardProgressCallback: otTcpForwardProgress,
    #[doc = "< \"Receive available\" callback function"]
    pub mReceiveAvailableCallback: otTcpReceiveAvailable,
    #[doc = "< \"Disconnected\" callback function"]
    pub mDisconnectedCallback: otTcpDisconnected,
    #[doc = "< Pointer to memory provided to the system for the TCP receive buffer"]
    pub mReceiveBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< Size of memory provided to the system for the TCP receive buffer"]
    pub mReceiveBufferSize: usize,
}
impl Default for otTcpEndpointInitializeArgs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Initializes a TCP endpoint."]
    #[doc = ""]
    #[doc = " Calling this function causes OpenThread to keep track of the TCP endpoint"]
    #[doc = " and store and retrieve TCP data inside the @p aEndpoint. The application"]
    #[doc = " should refrain from directly accessing or modifying the fields in"]
    #[doc = " @p aEndpoint. If the application needs to reclaim the memory backing"]
    #[doc = " @p aEndpoint, it should call otTcpEndpointDeinitialize()."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEndpoint  A pointer to a TCP endpoint structure."]
    #[doc = " @param[in]  aArgs      A pointer to a structure of arguments."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully opened the TCP endpoint."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to open the TCP endpoint."]
    #[doc = ""]
    pub fn otTcpEndpointInitialize(
        aInstance: *mut otInstance,
        aEndpoint: *mut otTcpEndpoint,
        aArgs: *const otTcpEndpointInitializeArgs,
    ) -> otError;
}
extern "C" {
    #[doc = " Obtains the otInstance that was associated with @p aEndpoint upon"]
    #[doc = " initialization."]
    #[doc = ""]
    #[doc = " @param[in]  aEndpoint  The TCP endpoint whose instance to obtain."]
    #[doc = ""]
    #[doc = " @returns  The otInstance pointer associated with @p aEndpoint."]
    #[doc = ""]
    pub fn otTcpEndpointGetInstance(aEndpoint: *mut otTcpEndpoint) -> *mut otInstance;
}
extern "C" {
    #[doc = " Obtains the context pointer that was associated with @p aEndpoint upon"]
    #[doc = " initialization."]
    #[doc = ""]
    #[doc = " @param[in]  aEndpoint  The TCP endpoint whose context to obtain."]
    #[doc = ""]
    #[doc = " @returns  The context pointer associated with @p aEndpoint."]
    #[doc = ""]
    pub fn otTcpEndpointGetContext(aEndpoint: *mut otTcpEndpoint) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Obtains a pointer to a TCP endpoint's local host and port."]
    #[doc = ""]
    #[doc = " The contents of the host and port may be stale if this socket is not in a"]
    #[doc = " connected state and has not been bound after it was last disconnected."]
    #[doc = ""]
    #[doc = " @param[in]  aEndpoint  The TCP endpoint whose local host and port to obtain."]
    #[doc = ""]
    #[doc = " @returns  The local host and port of @p aEndpoint."]
    #[doc = ""]
    pub fn otTcpGetLocalAddress(aEndpoint: *const otTcpEndpoint) -> *const otSockAddr;
}
extern "C" {
    #[doc = " Obtains a pointer to a TCP endpoint's peer's host and port."]
    #[doc = ""]
    #[doc = " The contents of the host and port may be stale if this socket is not in a"]
    #[doc = " connected state."]
    #[doc = ""]
    #[doc = " @param[in]  aEndpoint  The TCP endpoint whose peer's host and port to obtain."]
    #[doc = ""]
    #[doc = " @returns  The host and port of the connection peer of @p aEndpoint."]
    #[doc = ""]
    pub fn otTcpGetPeerAddress(aEndpoint: *const otTcpEndpoint) -> *const otSockAddr;
}
extern "C" {
    #[doc = " Binds the TCP endpoint to an IP address and port."]
    #[doc = ""]
    #[doc = " @param[in]  aEndpoint   A pointer to the TCP endpoint structure to bind."]
    #[doc = " @param[in]  aSockName   The address and port to which to bind this TCP endpoint."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully bound the TCP endpoint."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to bind the TCP endpoint."]
    #[doc = ""]
    pub fn otTcpBind(aEndpoint: *mut otTcpEndpoint, aSockName: *const otSockAddr) -> otError;
}
pub const OT_TCP_CONNECT_NO_FAST_OPEN: _bindgen_ty_15 = 1;
#[doc = " This enumeration defines flags passed to otTcpConnect()."]
#[doc = ""]
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Records the remote host and port for this connection."]
    #[doc = ""]
    #[doc = " Caller must wait for `otTcpEstablished` callback indicating that TCP"]
    #[doc = " connection establishment handshake is done before it can start sending data"]
    #[doc = " e.g., calling `otTcpSendByReference()`."]
    #[doc = ""]
    #[doc = " The TCP Fast Open is not yet supported and @p aFlags is ignored."]
    #[doc = ""]
    #[doc = " @param[in]  aEndpoint  A pointer to the TCP endpoint structure to connect."]
    #[doc = " @param[in]  aSockName  The IP address and port of the host to which to connect."]
    #[doc = " @param[in]  aFlags     Flags specifying options for this operation (see enumeration above)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully completed the operation."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to complete the operation."]
    #[doc = ""]
    pub fn otTcpConnect(
        aEndpoint: *mut otTcpEndpoint,
        aSockName: *const otSockAddr,
        aFlags: u32,
    ) -> otError;
}
pub const OT_TCP_SEND_MORE_TO_COME: _bindgen_ty_16 = 1;
#[doc = " This enumeration defines flags passed to @p otTcpSendByReference."]
#[doc = ""]
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Adds data referenced by the linked buffer pointed to by @p aBuffer to the"]
    #[doc = " send buffer."]
    #[doc = ""]
    #[doc = " Upon a successful call to this function, the linked buffer and data it"]
    #[doc = " references are owned by the TCP stack; they should not be modified by the"]
    #[doc = " application until a \"send done\" callback returns ownership of those objects"]
    #[doc = " to the application. It is acceptable to call this function to add another"]
    #[doc = " linked buffer to the send queue, even if the \"send done\" callback for a"]
    #[doc = " previous invocation of this function has not yet fired."]
    #[doc = ""]
    #[doc = " Note that @p aBuffer should not be chained; its mNext field should be"]
    #[doc = " NULL. If additional data will be added right after this call, then the"]
    #[doc = " OT_TCP_SEND_MORE_TO_COME flag should be used as a hint to the TCP"]
    #[doc = " implementation."]
    #[doc = ""]
    #[doc = " @param[in]  aEndpoint  A pointer to the TCP endpoint structure representing the TCP endpoint on which to send data."]
    #[doc = " @param[in]  aBuffer    A pointer to the linked buffer chain referencing data to add to the send buffer."]
    #[doc = " @param[in]  aFlags     Flags specifying options for this operation (see enumeration above)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully added data to the send buffer."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to add data to the send buffer."]
    #[doc = ""]
    pub fn otTcpSendByReference(
        aEndpoint: *mut otTcpEndpoint,
        aBuffer: *mut otLinkedBuffer,
        aFlags: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " Adds data to the send buffer by extending the length of the final"]
    #[doc = " otLinkedBuffer in the send buffer by the specified amount."]
    #[doc = ""]
    #[doc = " If the send buffer is empty, then the operation fails."]
    #[doc = ""]
    #[doc = " @param[in]  aEndpoint  A pointer to the TCP endpoint structure representing the TCP endpoint on which to send data."]
    #[doc = " @param[in]  aNumBytes  The number of bytes by which to extend the length of the final linked buffer."]
    #[doc = " @param[in]  aFlags     Flags specifying options for this operation (see enumeration above)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully added data to the send buffer."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to add data to the send buffer."]
    #[doc = ""]
    pub fn otTcpSendByExtension(
        aEndpoint: *mut otTcpEndpoint,
        aNumBytes: usize,
        aFlags: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " Provides the application with a linked buffer chain referencing data"]
    #[doc = " currently in the TCP receive buffer."]
    #[doc = ""]
    #[doc = " The linked buffer chain is valid until the \"receive ready\" callback is next"]
    #[doc = " invoked, or until the next call to otTcpReceiveContiguify() or"]
    #[doc = " otTcpCommitReceive()."]
    #[doc = ""]
    #[doc = " @param[in]   aEndpoint  A pointer to the TCP endpoint structure representing the TCP endpoint on which to receive"]
    #[doc = "                         data."]
    #[doc = " @param[out]  aBuffer    A pointer to the linked buffer chain referencing data currently in the receive buffer."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully completed the operation."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to complete the operation."]
    #[doc = ""]
    pub fn otTcpReceiveByReference(
        aEndpoint: *mut otTcpEndpoint,
        aBuffer: *mut *const otLinkedBuffer,
    ) -> otError;
}
extern "C" {
    #[doc = " Reorganizes the receive buffer to be entirely contiguous in memory."]
    #[doc = ""]
    #[doc = " This is optional; an application can simply traverse the linked buffer"]
    #[doc = " chain obtained by calling @p otTcpReceiveByReference. Some"]
    #[doc = " applications may wish to call this function to make the receive buffer"]
    #[doc = " contiguous to simplify their data processing, but this comes at the expense"]
    #[doc = " of CPU time to reorganize the data in the receive buffer."]
    #[doc = ""]
    #[doc = " @param[in]   aEndpoint  A pointer to the TCP endpoint whose receive buffer to reorganize."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully completed the operation."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to complete the operation."]
    #[doc = ""]
    pub fn otTcpReceiveContiguify(aEndpoint: *mut otTcpEndpoint) -> otError;
}
extern "C" {
    #[doc = " Informs the TCP stack that the application has finished processing"]
    #[doc = " @p aNumBytes bytes of data at the start of the receive buffer and that the"]
    #[doc = " TCP stack need not continue maintaining those bytes in the receive buffer."]
    #[doc = ""]
    #[doc = " @param[in]  aEndpoint  A pointer to the TCP endpoint structure representing the TCP endpoint on which to receive"]
    #[doc = "                        data."]
    #[doc = " @param[in]  aNumBytes  The number of bytes consumed."]
    #[doc = " @param[in]  aFlags     Flags specifying options for this operation (none yet)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully completed the receive operation."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to complete the receive operation."]
    #[doc = ""]
    pub fn otTcpCommitReceive(
        aEndpoint: *mut otTcpEndpoint,
        aNumBytes: usize,
        aFlags: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " Informs the connection peer that this TCP endpoint will not send more data."]
    #[doc = ""]
    #[doc = " This should be used when the application has no more data to send to the"]
    #[doc = " connection peer. For this connection, future reads on the connection peer"]
    #[doc = " will result in the \"end of stream\" condition, and future writes on this"]
    #[doc = " connection endpoint will fail."]
    #[doc = ""]
    #[doc = " The \"end of stream\" condition only applies after any data previously"]
    #[doc = " provided to the TCP stack to send out has been received by the connection"]
    #[doc = " peer."]
    #[doc = ""]
    #[doc = " @param[in]  aEndpoint  A pointer to the TCP endpoint structure representing the TCP endpoint to shut down."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully queued the \"end of stream\" condition for transmission."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to queue the \"end of stream\" condition for transmission."]
    #[doc = ""]
    pub fn otTcpSendEndOfStream(aEndpoint: *mut otTcpEndpoint) -> otError;
}
extern "C" {
    #[doc = " Forcibly ends the TCP connection associated with this TCP endpoint."]
    #[doc = ""]
    #[doc = " This immediately makes the TCP endpoint free for use for another connection"]
    #[doc = " and empties the send and receive buffers, transferring ownership of any data"]
    #[doc = " provided by the application in otTcpSendByReference() and"]
    #[doc = " otTcpSendByExtension() calls back to the application. The TCP endpoint's"]
    #[doc = " callbacks and memory for the receive buffer remain associated with the"]
    #[doc = " TCP endpoint."]
    #[doc = ""]
    #[doc = " @param[in]  aEndpoint  A pointer to the TCP endpoint structure representing the TCP endpoint to abort."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully aborted the TCP endpoint's connection."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to abort the TCP endpoint's connection."]
    #[doc = ""]
    pub fn otTcpAbort(aEndpoint: *mut otTcpEndpoint) -> otError;
}
extern "C" {
    #[doc = " Deinitializes this TCP endpoint."]
    #[doc = ""]
    #[doc = " This means that OpenThread no longer keeps track of this TCP endpoint and"]
    #[doc = " deallocates all resources it has internally allocated for this TCP endpoint."]
    #[doc = " The application can reuse the memory backing the TCP endpoint as it sees fit."]
    #[doc = ""]
    #[doc = " If it corresponds to a live TCP connection, the connection is terminated"]
    #[doc = " unceremoniously (as in otTcpAbort()). All resources the application has"]
    #[doc = " provided for this TCP endpoint (linked buffers for the send buffer, memory"]
    #[doc = " for the receive buffer, the @p aEndpoint structure itself, etc.) are"]
    #[doc = " immediately returned to the application."]
    #[doc = ""]
    #[doc = " @param[in]  aEndpoint  A pointer to the TCP endpoint structure to deinitialize."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully deinitialized the TCP endpoint."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to deinitialize the TCP endpoint."]
    #[doc = ""]
    pub fn otTcpEndpointDeinitialize(aEndpoint: *mut otTcpEndpoint) -> otError;
}
#[doc = "< Accept the incoming connection."]
pub const OT_TCP_INCOMING_CONNECTION_ACTION_ACCEPT: otTcpIncomingConnectionAction = 0;
#[doc = "< Defer (silently ignore) the incoming connection."]
pub const OT_TCP_INCOMING_CONNECTION_ACTION_DEFER: otTcpIncomingConnectionAction = 1;
#[doc = "< Refuse the incoming connection."]
pub const OT_TCP_INCOMING_CONNECTION_ACTION_REFUSE: otTcpIncomingConnectionAction = 2;
#[doc = " This enumeration defines incoming connection actions."]
#[doc = ""]
#[doc = " This is used in otTcpAcceptReady() callback."]
#[doc = ""]
pub type otTcpIncomingConnectionAction = ::std::os::raw::c_uint;
#[doc = " This callback indicates that an incoming connection that matches this TCP"]
#[doc = " listener has arrived."]
#[doc = ""]
#[doc = " The typical response is for the application to accept the incoming"]
#[doc = " connection. It does so by populating @p aAcceptInto with a pointer to the"]
#[doc = " otTcpEndpoint into which to accept the incoming connection. This"]
#[doc = " otTcpEndpoint must already be initialized using otTcpEndpointInitialize()."]
#[doc = " Then, the application returns OT_TCP_INCOMING_CONNECTION_ACTION_ACCEPT."]
#[doc = ""]
#[doc = " Alternatively, the application can decline to accept the incoming"]
#[doc = " connection. There are two ways for the application to do this. First, if the"]
#[doc = " application returns OT_TCP_INCOMING_CONNECTION_ACTION_DEFER, then OpenThread"]
#[doc = " silently ignores the connection establishment request; the connection peer"]
#[doc = " will likely retransmit the request, at which point the callback will be"]
#[doc = " called again. This is valuable if resources are not presently available to"]
#[doc = " accept the connection, but they may be available when the connection peer"]
#[doc = " retransmits its connection establishment attempt. Second, if the application"]
#[doc = " returns OT_TCP_INCOMING_CONNECTION_ACTION_REFUSE, then OpenThread sends a"]
#[doc = " \"connection refused\" message to the host that attempted to establish a"]
#[doc = " connection. If the application declines the incoming connection, it is not"]
#[doc = " required to populate @p aAcceptInto."]
#[doc = ""]
#[doc = " @param[in]   aListener    The TCP listener that matches the incoming connection."]
#[doc = " @param[in]   aPeer        The host and port from which the incoming connection originates."]
#[doc = " @param[out]  aAcceptInto  The TCP endpoint into which to accept the incoming connection."]
#[doc = ""]
#[doc = " @returns  Description of how to handle the incoming connection."]
#[doc = ""]
pub type otTcpAcceptReady = ::std::option::Option<
    unsafe extern "C" fn(
        aListener: *mut otTcpListener,
        aPeer: *const otSockAddr,
        aAcceptInto: *mut *mut otTcpEndpoint,
    ) -> otTcpIncomingConnectionAction,
>;
#[doc = " This callback indicates that the TCP connection is now ready for two-way"]
#[doc = " communication."]
#[doc = ""]
#[doc = " In the case of TCP Fast Open, this may be before the TCP"]
#[doc = " connection handshake has actually completed. The application is provided"]
#[doc = " with the context pointers both for the TCP listener that accepted the"]
#[doc = " connection and the TCP endpoint into which it was accepted. The provided"]
#[doc = " context is the one associated with the TCP listener."]
#[doc = ""]
#[doc = " @param[in]  aListener  The TCP listener that matches the incoming connection."]
#[doc = " @param[in]  aEndpoint  The TCP endpoint into which the incoming connection was accepted."]
#[doc = " @param[in]  aPeer      the host and port from which the incoming connection originated."]
#[doc = ""]
pub type otTcpAcceptDone = ::std::option::Option<
    unsafe extern "C" fn(
        aListener: *mut otTcpListener,
        aEndpoint: *mut otTcpEndpoint,
        aPeer: *const otSockAddr,
    ),
>;
#[doc = " This structure represents a TCP listener."]
#[doc = ""]
#[doc = " A TCP listener is used to listen for and accept incoming TCP connections."]
#[doc = ""]
#[doc = " The application should not inspect the fields of this structure directly; it"]
#[doc = " should only interact with it via the TCP API functions whose signatures are"]
#[doc = " provided in this file."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otTcpListener {
    pub mTcbListen: otTcpListener__bindgen_ty_1,
    #[doc = "< A pointer to the next TCP listener (internal use only)"]
    pub mNext: *mut otTcpListener,
    #[doc = "< A pointer to application-specific context"]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< \"Accept ready\" callback function"]
    pub mAcceptReadyCallback: otTcpAcceptReady,
    #[doc = "< \"Accept done\" callback function"]
    pub mAcceptDoneCallback: otTcpAcceptDone,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otTcpListener__bindgen_ty_1 {
    pub mSize: [u8; 40usize],
    pub mAlign: *mut ::std::os::raw::c_void,
}
impl Default for otTcpListener__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otTcpListener {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure contains arguments to the otTcpListenerInitialize() function."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otTcpListenerInitializeArgs {
    #[doc = "< Pointer to application-specific context"]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< \"Accept ready\" callback function"]
    pub mAcceptReadyCallback: otTcpAcceptReady,
    #[doc = "< \"Accept done\" callback function"]
    pub mAcceptDoneCallback: otTcpAcceptDone,
}
impl Default for otTcpListenerInitializeArgs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Initializes a TCP listener."]
    #[doc = ""]
    #[doc = " Calling this function causes OpenThread to keep track of the TCP listener"]
    #[doc = " and store and retrieve TCP data inside @p aListener. The application should"]
    #[doc = " refrain from directly accessing or modifying the fields in @p aListener. If"]
    #[doc = " the application needs to reclaim the memory backing @p aListener, it should"]
    #[doc = " call otTcpListenerDeinitialize()."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aListener  A pointer to a TCP listener structure."]
    #[doc = " @param[in]  aArgs      A pointer to a structure of arguments."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully opened the TCP listener."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to open the TCP listener."]
    #[doc = ""]
    pub fn otTcpListenerInitialize(
        aInstance: *mut otInstance,
        aListener: *mut otTcpListener,
        aArgs: *const otTcpListenerInitializeArgs,
    ) -> otError;
}
extern "C" {
    #[doc = " Obtains the otInstance that was associated with @p aListener upon"]
    #[doc = " initialization."]
    #[doc = ""]
    #[doc = " @param[in]  aListener  The TCP listener whose instance to obtain."]
    #[doc = ""]
    #[doc = " @returns  The otInstance pointer associated with @p aListener."]
    #[doc = ""]
    pub fn otTcpListenerGetInstance(aListener: *mut otTcpListener) -> *mut otInstance;
}
extern "C" {
    #[doc = " Obtains the context pointer that was associated with @p aListener upon"]
    #[doc = " initialization."]
    #[doc = ""]
    #[doc = " @param[in]  aListener  The TCP listener whose context to obtain."]
    #[doc = ""]
    #[doc = " @returns  The context pointer associated with @p aListener."]
    #[doc = ""]
    pub fn otTcpListenerGetContext(aListener: *mut otTcpListener) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Causes incoming TCP connections that match the specified IP address and port"]
    #[doc = " to trigger this TCP listener's callbacks."]
    #[doc = ""]
    #[doc = " @param[in]  aListener  A pointer to the TCP listener structure that should begin listening."]
    #[doc = " @param[in]  aSockName  The address and port on which to listen for incoming connections."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully initiated listening on the TCP listener."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to initiate listening on the TCP listener."]
    #[doc = ""]
    pub fn otTcpListen(aListener: *mut otTcpListener, aSockName: *const otSockAddr) -> otError;
}
extern "C" {
    #[doc = " Causes this TCP listener to stop listening for incoming connections."]
    #[doc = ""]
    #[doc = " @param[in]  aListener  A pointer to the TCP listener structure that should stop listening."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully stopped listening on the TCP listener."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to stop listening on the TCP listener."]
    #[doc = ""]
    pub fn otTcpStopListening(aListener: *mut otTcpListener) -> otError;
}
extern "C" {
    #[doc = " Deinitializes this TCP listener."]
    #[doc = ""]
    #[doc = " This means that OpenThread no longer keeps track of this TCP listener and"]
    #[doc = " deallocates all resources it has internally allocated for this TCP listener."]
    #[doc = " The application can reuse the memory backing the TCP listener as it sees"]
    #[doc = " fit."]
    #[doc = ""]
    #[doc = " If the TCP listener is currently listening, it stops listening."]
    #[doc = ""]
    #[doc = " @param[in]  aListener  A pointer to the TCP listener structure to deinitialize."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE    Successfully deinitialized the TCP listener."]
    #[doc = " @retval OT_ERROR_FAILED  Failed to deinitialize the TCP listener."]
    #[doc = ""]
    pub fn otTcpListenerDeinitialize(aListener: *mut otTcpListener) -> otError;
}
#[doc = " This structure holds diagnostic information for a Thread Child"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otChildInfo {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Timeout"]
    pub mTimeout: u32,
    #[doc = "< Time last heard"]
    pub mAge: u32,
    #[doc = "< RLOC16"]
    pub mRloc16: u16,
    #[doc = "< Child ID"]
    pub mChildId: u16,
    #[doc = "< Network Data Version"]
    pub mNetworkDataVersion: u8,
    #[doc = "< Link Quality In"]
    pub mLinkQualityIn: u8,
    #[doc = "< Average RSSI"]
    pub mAverageRssi: i8,
    #[doc = "< Last observed RSSI"]
    pub mLastRssi: i8,
    #[doc = "< Frame error rate (0xffff->100%). Requires error tracking feature."]
    pub mFrameErrorRate: u16,
    #[doc = "< (IPv6) msg error rate (0xffff->100%). Requires error tracking feature."]
    pub mMessageErrorRate: u16,
    #[doc = "< Number of queued messages for the child."]
    pub mQueuedMessageCnt: u16,
    #[doc = "< Supervision interval (in seconds)."]
    pub mSupervisionInterval: u16,
    #[doc = "< MLE version"]
    pub mVersion: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl otChildInfo {
    #[inline]
    pub fn mRxOnWhenIdle(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRxOnWhenIdle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mFullThreadDevice(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullThreadDevice(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mFullNetworkData(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullNetworkData(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsStateRestoring(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsStateRestoring(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsCslSynced(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsCslSynced(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mRxOnWhenIdle: bool,
        mFullThreadDevice: bool,
        mFullNetworkData: bool,
        mIsStateRestoring: bool,
        mIsCslSynced: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mRxOnWhenIdle: u8 = unsafe { ::std::mem::transmute(mRxOnWhenIdle) };
            mRxOnWhenIdle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mFullThreadDevice: u8 = unsafe { ::std::mem::transmute(mFullThreadDevice) };
            mFullThreadDevice as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mFullNetworkData: u8 = unsafe { ::std::mem::transmute(mFullNetworkData) };
            mFullNetworkData as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsStateRestoring: u8 = unsafe { ::std::mem::transmute(mIsStateRestoring) };
            mIsStateRestoring as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsCslSynced: u8 = unsafe { ::std::mem::transmute(mIsCslSynced) };
            mIsCslSynced as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type otChildIp6AddressIterator = u16;
pub const OT_CACHE_ENTRY_STATE_CACHED: otCacheEntryState = 0;
pub const OT_CACHE_ENTRY_STATE_SNOOPED: otCacheEntryState = 1;
pub const OT_CACHE_ENTRY_STATE_QUERY: otCacheEntryState = 2;
pub const OT_CACHE_ENTRY_STATE_RETRY_QUERY: otCacheEntryState = 3;
#[doc = " This enumeration defines the EID cache entry state."]
#[doc = ""]
pub type otCacheEntryState = ::std::os::raw::c_uint;
#[doc = " This structure represents an EID cache entry."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otCacheEntryInfo {
    #[doc = "< Target EID"]
    pub mTarget: otIp6Address,
    #[doc = "< RLOC16"]
    pub mRloc16: otShortAddress,
    #[doc = "< Entry state"]
    pub mState: otCacheEntryState,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Last transaction time (applicable in cached state)."]
    pub mLastTransTime: u32,
    #[doc = "< Mesh Local EID (applicable if entry in cached state)."]
    pub mMeshLocalEid: otIp6Address,
    #[doc = "< Timeout in seconds (applicable if in snooped/query/retry-query states)."]
    pub mTimeout: u16,
    #[doc = "< Retry delay in seconds (applicable if in query-retry state)."]
    pub mRetryDelay: u16,
}
impl Default for otCacheEntryInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otCacheEntryInfo {
    #[inline]
    pub fn mCanEvict(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCanEvict(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mValidLastTrans(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mValidLastTrans(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mCanEvict: bool,
        mValidLastTrans: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mCanEvict: u8 = unsafe { ::std::mem::transmute(mCanEvict) };
            mCanEvict as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mValidLastTrans: u8 = unsafe { ::std::mem::transmute(mValidLastTrans) };
            mValidLastTrans as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This type represents an iterator used for iterating through the EID cache table entries."]
#[doc = ""]
#[doc = " To initialize the iterator and start from the first entry in the cache table, set all its fields in the structure to"]
#[doc = " zero (e.g., `memset` the iterator to zero)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCacheEntryIterator {
    #[doc = "< Opaque data used by the core implementation. Should not be changed by user."]
    pub mData: [*const ::std::os::raw::c_void; 2usize],
}
impl Default for otCacheEntryIterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Gets the maximum number of children currently allowed."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The maximum number of children currently allowed."]
    #[doc = ""]
    #[doc = " @sa otThreadSetMaxAllowedChildren"]
    #[doc = ""]
    pub fn otThreadGetMaxAllowedChildren(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the maximum number of children currently allowed."]
    #[doc = ""]
    #[doc = " This parameter can only be set when Thread protocol operation has been stopped."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMaxChildren  The maximum allowed children."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE           Successfully set the max."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS   If @p aMaxChildren is not in the range [1, OPENTHREAD_CONFIG_MLE_MAX_CHILDREN]."]
    #[doc = " @retval  OT_ERROR_INVALID_STATE  If Thread isn't stopped."]
    #[doc = ""]
    #[doc = " @sa otThreadGetMaxAllowedChildren"]
    #[doc = ""]
    pub fn otThreadSetMaxAllowedChildren(aInstance: *mut otInstance, aMaxChildren: u16) -> otError;
}
extern "C" {
    #[doc = " This method indicates whether or not the device is router-eligible."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE   If device is router-eligible."]
    #[doc = " @retval FALSE  If device is not router-eligible."]
    #[doc = ""]
    pub fn otThreadIsRouterEligible(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function sets whether or not the device is router-eligible."]
    #[doc = ""]
    #[doc = " If @p aEligible is false and the device is currently operating as a router, this call will cause the device to"]
    #[doc = " detach and attempt to reattach as a child."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEligible  TRUE to configure the device as router-eligible, FALSE otherwise."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE         Successfully set the router-eligible configuration."]
    #[doc = " @retval OT_ERROR_NOT_CAPABLE  The device is not capable of becoming a router."]
    #[doc = ""]
    pub fn otThreadSetRouterEligible(aInstance: *mut otInstance, aEligible: bool) -> otError;
}
extern "C" {
    #[doc = " Set the preferred Router Id."]
    #[doc = ""]
    #[doc = " Upon becoming a router/leader the node attempts to use this Router Id. If the preferred Router Id is not set or if"]
    #[doc = " it can not be used, a randomly generated router id is picked. This property can be set only when the device role is"]
    #[doc = " either detached or disabled."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aRouterId    The preferred Router Id."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully set the preferred Router Id."]
    #[doc = " @retval OT_ERROR_INVALID_STATE Could not set (role is not detached or disabled)"]
    #[doc = ""]
    pub fn otThreadSetPreferredRouterId(aInstance: *mut otInstance, aRouterId: u8) -> otError;
}
#[doc = "< Battery powered."]
pub const OT_POWER_SUPPLY_BATTERY: otPowerSupply = 0;
#[doc = "< Externally powered (mains-powered)."]
pub const OT_POWER_SUPPLY_EXTERNAL: otPowerSupply = 1;
#[doc = "< Stable external power with a battery backup or UPS."]
pub const OT_POWER_SUPPLY_EXTERNAL_STABLE: otPowerSupply = 2;
#[doc = "< Potentially unstable ext power (e.g. light bulb powered via a switch)."]
pub const OT_POWER_SUPPLY_EXTERNAL_UNSTABLE: otPowerSupply = 3;
#[doc = " This enumeration represents the power supply property on a device."]
#[doc = ""]
#[doc = " This is used as a property in `otDeviceProperties` to calculate the leader weight."]
#[doc = ""]
pub type otPowerSupply = ::std::os::raw::c_uint;
#[doc = " This structure represents the device properties which are used for calculating the local leader weight on a"]
#[doc = " device."]
#[doc = ""]
#[doc = " The parameters are set based on device's capability, whether acting as border router, its power supply config, etc."]
#[doc = ""]
#[doc = " `mIsUnstable` indicates operational stability of device and is determined via a vendor specific mechanism. It can"]
#[doc = " include the following cases:"]
#[doc = "  - Device internally detects that it loses external power supply more often than usual. What is usual is"]
#[doc = "    determined by the vendor."]
#[doc = "  - Device internally detects that it reboots more often than usual. What is usual is determined by the vendor."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDeviceProperties {
    #[doc = "< Power supply config."]
    pub mPowerSupply: otPowerSupply,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Weight adjustment. Should be -16 to +16 (clamped otherwise)."]
    pub mLeaderWeightAdjustment: i8,
}
impl Default for otDeviceProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otDeviceProperties {
    #[inline]
    pub fn mIsBorderRouter(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsBorderRouter(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mSupportsCcm(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mSupportsCcm(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsUnstable(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsUnstable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsBorderRouter: bool,
        mSupportsCcm: bool,
        mIsUnstable: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsBorderRouter: u8 = unsafe { ::std::mem::transmute(mIsBorderRouter) };
            mIsBorderRouter as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mSupportsCcm: u8 = unsafe { ::std::mem::transmute(mSupportsCcm) };
            mSupportsCcm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsUnstable: u8 = unsafe { ::std::mem::transmute(mIsUnstable) };
            mIsUnstable as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Get the current device properties."]
    #[doc = ""]
    #[doc = " @returns The device properties `otDeviceProperties`."]
    #[doc = ""]
    pub fn otThreadGetDeviceProperties(aInstance: *mut otInstance) -> *const otDeviceProperties;
}
extern "C" {
    #[doc = " Set the device properties which are then used to determine and set the Leader Weight."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance           A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDeviceProperties   The device properties."]
    #[doc = ""]
    pub fn otThreadSetDeviceProperties(
        aInstance: *mut otInstance,
        aDeviceProperties: *const otDeviceProperties,
    );
}
extern "C" {
    #[doc = " Gets the Thread Leader Weight used when operating in the Leader role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Thread Leader Weight value."]
    #[doc = ""]
    #[doc = " @sa otThreadSetLeaderWeight"]
    #[doc = " @sa otThreadSetDeviceProperties"]
    #[doc = ""]
    pub fn otThreadGetLocalLeaderWeight(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Sets the Thread Leader Weight used when operating in the Leader role."]
    #[doc = ""]
    #[doc = " This function directly sets the Leader Weight to the new value, replacing its previous value (which may have been"]
    #[doc = " determined from the current `otDeviceProperties`)."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aWeight   The Thread Leader Weight value."]
    #[doc = ""]
    #[doc = " @sa otThreadGetLeaderWeight"]
    #[doc = ""]
    pub fn otThreadSetLocalLeaderWeight(aInstance: *mut otInstance, aWeight: u8);
}
extern "C" {
    #[doc = " Get the preferred Thread Leader Partition Id used when operating in the Leader role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Thread Leader Partition Id value."]
    #[doc = ""]
    pub fn otThreadGetPreferredLeaderPartitionId(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Set the preferred Thread Leader Partition Id used when operating in the Leader role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPartitionId  The Thread Leader Partition Id value."]
    #[doc = ""]
    pub fn otThreadSetPreferredLeaderPartitionId(aInstance: *mut otInstance, aPartitionId: u32);
}
extern "C" {
    #[doc = " Gets the Joiner UDP Port."]
    #[doc = ""]
    #[doc = " @param[in] aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Joiner UDP Port number."]
    #[doc = ""]
    #[doc = " @sa otThreadSetJoinerUdpPort"]
    #[doc = ""]
    pub fn otThreadGetJoinerUdpPort(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the Joiner UDP Port."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aJoinerUdpPort  The Joiner UDP Port number."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE  Successfully set the Joiner UDP Port."]
    #[doc = ""]
    #[doc = " @sa otThreadGetJoinerUdpPort"]
    #[doc = ""]
    pub fn otThreadSetJoinerUdpPort(aInstance: *mut otInstance, aJoinerUdpPort: u16) -> otError;
}
extern "C" {
    #[doc = " Set Steering data out of band."]
    #[doc = ""]
    #[doc = " Configuration option `OPENTHREAD_CONFIG_MLE_STEERING_DATA_SET_OOB_ENABLE` should be set to enable setting of steering"]
    #[doc = " data out of band."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aExtAddress     Address used to update the steering data."]
    #[doc = "                             All zeros to clear the steering data (no steering data)."]
    #[doc = "                             All 0xFFs to set steering data/bloom filter to accept/allow all."]
    #[doc = "                             A specific EUI64 which is then added to current steering data/bloom filter."]
    #[doc = ""]
    pub fn otThreadSetSteeringData(aInstance: *mut otInstance, aExtAddress: *const otExtAddress);
}
extern "C" {
    #[doc = " Get the CONTEXT_ID_REUSE_DELAY parameter used in the Leader role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The CONTEXT_ID_REUSE_DELAY value."]
    #[doc = ""]
    #[doc = " @sa otThreadSetContextIdReuseDelay"]
    #[doc = ""]
    pub fn otThreadGetContextIdReuseDelay(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Set the CONTEXT_ID_REUSE_DELAY parameter used in the Leader role."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDelay    The CONTEXT_ID_REUSE_DELAY value."]
    #[doc = ""]
    #[doc = " @sa otThreadGetContextIdReuseDelay"]
    #[doc = ""]
    pub fn otThreadSetContextIdReuseDelay(aInstance: *mut otInstance, aDelay: u32);
}
extern "C" {
    #[doc = " Get the NETWORK_ID_TIMEOUT parameter used in the Router role."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The NETWORK_ID_TIMEOUT value."]
    #[doc = ""]
    #[doc = " @sa otThreadSetNetworkIdTimeout"]
    #[doc = ""]
    pub fn otThreadGetNetworkIdTimeout(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the NETWORK_ID_TIMEOUT parameter used in the Leader role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aTimeout  The NETWORK_ID_TIMEOUT value."]
    #[doc = ""]
    #[doc = " @sa otThreadGetNetworkIdTimeout"]
    #[doc = ""]
    pub fn otThreadSetNetworkIdTimeout(aInstance: *mut otInstance, aTimeout: u8);
}
extern "C" {
    #[doc = " Get the ROUTER_UPGRADE_THRESHOLD parameter used in the REED role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The ROUTER_UPGRADE_THRESHOLD value."]
    #[doc = ""]
    #[doc = " @sa otThreadSetRouterUpgradeThreshold"]
    #[doc = ""]
    pub fn otThreadGetRouterUpgradeThreshold(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the ROUTER_UPGRADE_THRESHOLD parameter used in the Leader role."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aThreshold  The ROUTER_UPGRADE_THRESHOLD value."]
    #[doc = ""]
    #[doc = " @sa otThreadGetRouterUpgradeThreshold"]
    #[doc = ""]
    pub fn otThreadSetRouterUpgradeThreshold(aInstance: *mut otInstance, aThreshold: u8);
}
extern "C" {
    #[doc = " Get the MLE_CHILD_ROUTER_LINKS parameter used in the REED role."]
    #[doc = ""]
    #[doc = " This parameter specifies the max number of neighboring routers with which the device (as an FED)"]
    #[doc = "  will try to establish link."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The MLE_CHILD_ROUTER_LINKS value."]
    #[doc = ""]
    #[doc = " @sa otThreadSetChildRouterLinks"]
    #[doc = ""]
    pub fn otThreadGetChildRouterLinks(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the MLE_CHILD_ROUTER_LINKS parameter used in the REED role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance         A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aChildRouterLinks The MLE_CHILD_ROUTER_LINKS value."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the value."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otThreadGetChildRouterLinks"]
    #[doc = ""]
    pub fn otThreadSetChildRouterLinks(
        aInstance: *mut otInstance,
        aChildRouterLinks: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Release a Router ID that has been allocated by the device in the Leader role."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aRouterId  The Router ID to release. Valid range is [0, 62]."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully released the router id."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   @p aRouterId is not in the range [0, 62]."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  The device is not currently operating as a leader."]
    #[doc = " @retval OT_ERROR_NOT_FOUND      The router id is not currently allocated."]
    #[doc = ""]
    pub fn otThreadReleaseRouterId(aInstance: *mut otInstance, aRouterId: u8) -> otError;
}
extern "C" {
    #[doc = " Attempt to become a router."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully begin attempt to become a router."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread is disabled."]
    pub fn otThreadBecomeRouter(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Become a leader and start a new partition."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully became a leader and started a new partition."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread is disabled."]
    pub fn otThreadBecomeLeader(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Get the ROUTER_DOWNGRADE_THRESHOLD parameter used in the Router role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The ROUTER_DOWNGRADE_THRESHOLD value."]
    #[doc = ""]
    #[doc = " @sa otThreadSetRouterDowngradeThreshold"]
    #[doc = ""]
    pub fn otThreadGetRouterDowngradeThreshold(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the ROUTER_DOWNGRADE_THRESHOLD parameter used in the Leader role."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aThreshold  The ROUTER_DOWNGRADE_THRESHOLD value."]
    #[doc = ""]
    #[doc = " @sa otThreadGetRouterDowngradeThreshold"]
    #[doc = ""]
    pub fn otThreadSetRouterDowngradeThreshold(aInstance: *mut otInstance, aThreshold: u8);
}
extern "C" {
    #[doc = " Get the ROUTER_SELECTION_JITTER parameter used in the REED/Router role."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The ROUTER_SELECTION_JITTER value."]
    #[doc = ""]
    #[doc = " @sa otThreadSetRouterSelectionJitter"]
    #[doc = ""]
    pub fn otThreadGetRouterSelectionJitter(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the ROUTER_SELECTION_JITTER parameter used in the REED/Router role."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance      A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aRouterJitter  The ROUTER_SELECTION_JITTER value."]
    #[doc = ""]
    #[doc = " @sa otThreadGetRouterSelectionJitter"]
    #[doc = ""]
    pub fn otThreadSetRouterSelectionJitter(aInstance: *mut otInstance, aRouterJitter: u8);
}
extern "C" {
    #[doc = " Gets diagnostic information for an attached Child by its Child ID or RLOC16."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aChildId    The Child ID or RLOC16 for the attached child."]
    #[doc = " @param[out]  aChildInfo  A pointer to where the child information is placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          @p aChildInfo was successfully updated with the info for the given ID."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No valid child with this Child ID."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  If @p aChildInfo is NULL."]
    #[doc = ""]
    pub fn otThreadGetChildInfoById(
        aInstance: *mut otInstance,
        aChildId: u16,
        aChildInfo: *mut otChildInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " The function retains diagnostic information for an attached Child by the internal table index."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aChildIndex  The table index."]
    #[doc = " @param[out]  aChildInfo   A pointer to where the child information is placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE             @p aChildInfo was successfully updated with the info for the given index."]
    #[doc = " @retval OT_ERROR_NOT_FOUND        No valid child at this index."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS     Either @p aChildInfo is NULL, or @p aChildIndex is out of range (higher"]
    #[doc = "                                   than max table index)."]
    #[doc = ""]
    #[doc = " @sa otGetMaxAllowedChildren"]
    #[doc = ""]
    pub fn otThreadGetChildInfoByIndex(
        aInstance: *mut otInstance,
        aChildIndex: u16,
        aChildInfo: *mut otChildInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the next IPv6 address (using an iterator) for a given child."]
    #[doc = ""]
    #[doc = " @param[in]      aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]      aChildIndex  The child index."]
    #[doc = " @param[in,out]  aIterator    A pointer to the iterator. On success the iterator will be updated to point to next"]
    #[doc = "                              entry in the list. To get the first IPv6 address the iterator should be set to"]
    #[doc = "                              OT_CHILD_IP6_ADDRESS_ITERATOR_INIT."]
    #[doc = " @param[out]     aAddress     A pointer to an IPv6 address where the child's next address is placed (on success)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully found the next IPv6 address (@p aAddress was successfully updated)."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     The child has no subsequent IPv6 address entry."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aIterator or @p aAddress are NULL, or child at @p aChildIndex is not valid."]
    #[doc = ""]
    #[doc = " @sa otThreadGetChildInfoByIndex"]
    #[doc = ""]
    pub fn otThreadGetChildNextIp6Address(
        aInstance: *mut otInstance,
        aChildIndex: u16,
        aIterator: *mut otChildIp6AddressIterator,
        aAddress: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the current Router ID Sequence."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The Router ID Sequence."]
    #[doc = ""]
    pub fn otThreadGetRouterIdSequence(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " The function returns the maximum allowed router ID"]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The maximum allowed router ID."]
    #[doc = ""]
    pub fn otThreadGetMaxRouterId(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " The function retains diagnostic information for a given Thread Router."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance    A pointer to an OpenThread instance."]
    #[doc = " @param[in]   aRouterId    The router ID or RLOC16 for a given router."]
    #[doc = " @param[out]  aRouterInfo  A pointer to where the router information is placed."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully retrieved the router info for given id."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No router entry with the given id."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS  @p aRouterInfo is NULL."]
    #[doc = ""]
    pub fn otThreadGetRouterInfo(
        aInstance: *mut otInstance,
        aRouterId: u16,
        aRouterInfo: *mut otRouterInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the next EID cache entry (using an iterator)."]
    #[doc = ""]
    #[doc = " @param[in]     aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[out]    aEntryInfo  A pointer to where the EID cache entry information is placed."]
    #[doc = " @param[in,out] aIterator   A pointer to an iterator. It will be updated to point to next entry on success. To get"]
    #[doc = "                            the first entry, initialize the iterator by setting all its fields to zero"]
    #[doc = "                            (e.g., `memset` the iterator structure to zero)."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE          Successfully populated @p aEntryInfo for next EID cache entry."]
    #[doc = " @retval OT_ERROR_NOT_FOUND     No more entries in the address cache table."]
    #[doc = ""]
    pub fn otThreadGetNextCacheEntry(
        aInstance: *mut otInstance,
        aEntryInfo: *mut otCacheEntryInfo,
        aIterator: *mut otCacheEntryIterator,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Thread PSKc"]
    #[doc = ""]
    #[doc = " @param[in]   aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aPskc       A pointer to an `otPskc` to return the retrieved Thread PSKc."]
    #[doc = ""]
    #[doc = " @sa otThreadSetPskc"]
    #[doc = ""]
    pub fn otThreadGetPskc(aInstance: *mut otInstance, aPskc: *mut otPskc);
}
extern "C" {
    #[doc = " Get Key Reference to Thread PSKc stored"]
    #[doc = ""]
    #[doc = " This function requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance   A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns Key Reference to PSKc"]
    #[doc = ""]
    #[doc = " @sa otThreadSetPskcRef"]
    #[doc = ""]
    pub fn otThreadGetPskcRef(aInstance: *mut otInstance) -> otPskcRef;
}
extern "C" {
    #[doc = " Set the Thread PSKc"]
    #[doc = ""]
    #[doc = " This function will only succeed when Thread protocols are disabled.  A successful"]
    #[doc = " call to this function will also invalidate the Active and Pending Operational Datasets in"]
    #[doc = " non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aPskc       A pointer to the new Thread PSKc."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the Thread PSKc."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otThreadGetPskc"]
    #[doc = ""]
    pub fn otThreadSetPskc(aInstance: *mut otInstance, aPskc: *const otPskc) -> otError;
}
extern "C" {
    #[doc = " Set the Thread PSKc"]
    #[doc = ""]
    #[doc = " This function requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled."]
    #[doc = ""]
    #[doc = " This function will only succeed when Thread protocols are disabled.  A successful"]
    #[doc = " call to this function will also invalidate the Active and Pending Operational Datasets in"]
    #[doc = " non-volatile memory."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance   A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aKeyRef     Key Reference to the new Thread PSKc."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the Thread PSKc."]
    #[doc = " @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled."]
    #[doc = ""]
    #[doc = " @sa otThreadGetPskcRef"]
    #[doc = ""]
    pub fn otThreadSetPskcRef(aInstance: *mut otInstance, aKeyRef: otPskcRef) -> otError;
}
extern "C" {
    #[doc = " Get the assigned parent priority."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance   A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The assigned parent priority value, -2 means not assigned."]
    #[doc = ""]
    #[doc = " @sa otThreadSetParentPriority"]
    #[doc = ""]
    pub fn otThreadGetParentPriority(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Set the parent priority."]
    #[doc = ""]
    #[doc = " @note This API is reserved for testing and demo purposes only. Changing settings with"]
    #[doc = " this API will render a production application non-compliant with the Thread Specification."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aParentPriority  The parent priority value."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set the parent priority."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   If the parent priority value is not among 1, 0, -1 and -2."]
    #[doc = ""]
    #[doc = " @sa otThreadGetParentPriority"]
    #[doc = ""]
    pub fn otThreadSetParentPriority(aInstance: *mut otInstance, aParentPriority: i8) -> otError;
}
extern "C" {
    #[doc = " Gets the maximum number of IP addresses that each MTD child may register with this device as parent."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance    A pointer to an OpenThread instance."]
    #[doc = ""]
    #[doc = " @returns The maximum number of IP addresses that each MTD child may register with this device as parent."]
    #[doc = ""]
    #[doc = " @sa otThreadSetMaxChildIpAddresses"]
    #[doc = ""]
    pub fn otThreadGetMaxChildIpAddresses(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Sets or restores the maximum number of IP addresses that each MTD child may register with this"]
    #[doc = " device as parent."]
    #[doc = ""]
    #[doc = " Pass `0` to clear the setting and restore the default."]
    #[doc = ""]
    #[doc = " Available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled."]
    #[doc = ""]
    #[doc = " @note Only used by Thread Test Harness to limit the address registrations of the reference"]
    #[doc = " parent in order to test the MTD DUT reaction."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance        A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMaxIpAddresses  The maximum number of IP addresses that each MTD child may register with this"]
    #[doc = "                              device as parent. 0 to clear the setting and restore the default."]
    #[doc = ""]
    #[doc = " @retval OT_ERROR_NONE           Successfully set/cleared the number."]
    #[doc = " @retval OT_ERROR_INVALID_ARGS   If exceeds the allowed maximum number."]
    #[doc = ""]
    #[doc = " @sa otThreadGetMaxChildIpAddresses"]
    #[doc = ""]
    pub fn otThreadSetMaxChildIpAddresses(
        aInstance: *mut otInstance,
        aMaxIpAddresses: u8,
    ) -> otError;
}
#[doc = "< A child is being added."]
pub const OT_NEIGHBOR_TABLE_EVENT_CHILD_ADDED: otNeighborTableEvent = 0;
#[doc = "< A child is being removed."]
pub const OT_NEIGHBOR_TABLE_EVENT_CHILD_REMOVED: otNeighborTableEvent = 1;
#[doc = "< An existing child's mode is changed."]
pub const OT_NEIGHBOR_TABLE_EVENT_CHILD_MODE_CHANGED: otNeighborTableEvent = 2;
#[doc = "< A router is being added."]
pub const OT_NEIGHBOR_TABLE_EVENT_ROUTER_ADDED: otNeighborTableEvent = 3;
#[doc = "< A router is being removed."]
pub const OT_NEIGHBOR_TABLE_EVENT_ROUTER_REMOVED: otNeighborTableEvent = 4;
#[doc = " This enumeration defines the constants used in `otNeighborTableCallback` to indicate changes in neighbor table."]
#[doc = ""]
pub type otNeighborTableEvent = ::std::os::raw::c_uint;
#[doc = " This type represent a neighbor table entry info (child or router) and is used as a parameter in the neighbor table"]
#[doc = " callback `otNeighborTableCallback`."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNeighborTableEntryInfo {
    #[doc = "< The OpenThread instance."]
    pub mInstance: *mut otInstance,
    pub mInfo: otNeighborTableEntryInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otNeighborTableEntryInfo__bindgen_ty_1 {
    #[doc = "< The child neighbor info."]
    pub mChild: otChildInfo,
    #[doc = "< The router neighbor info."]
    pub mRouter: otNeighborInfo,
}
impl Default for otNeighborTableEntryInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otNeighborTableEntryInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This function pointer is called to notify that there is a change in the neighbor table."]
#[doc = ""]
#[doc = " @param[in]  aEvent      A event flag."]
#[doc = " @param[in]  aEntryInfo  A pointer to table entry info."]
#[doc = ""]
pub type otNeighborTableCallback = ::std::option::Option<
    unsafe extern "C" fn(aEvent: otNeighborTableEvent, aEntryInfo: *const otNeighborTableEntryInfo),
>;
extern "C" {
    #[doc = " This function registers a neighbor table callback function."]
    #[doc = ""]
    #[doc = " The provided callback (if non-NULL) will be invoked when there is a change in the neighbor table (e.g., a child or a"]
    #[doc = " router neighbor entry is being added/removed or an existing child's mode is changed)."]
    #[doc = ""]
    #[doc = " Subsequent calls to this method will overwrite the previous callback.  Note that this callback in invoked while the"]
    #[doc = " neighbor/child table is being updated and always before the `otStateChangedCallback`."]
    #[doc = ""]
    #[doc = " @param[in] aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in] aCallback  A pointer to callback handler function."]
    #[doc = ""]
    pub fn otThreadRegisterNeighborTableCallback(
        aInstance: *mut otInstance,
        aCallback: otNeighborTableCallback,
    );
}
extern "C" {
    #[doc = " This function sets whether the device was commissioned using CCM."]
    #[doc = ""]
    #[doc = " @note This API requires `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE`, and is only used by Thread Test Harness"]
    #[doc = "       to indicate whether this device was commissioned using CCM."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnabled   TRUE if the device was commissioned using CCM, FALSE otherwise."]
    #[doc = ""]
    pub fn otThreadSetCcmEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " This function sets whether the Security Policy TLV version-threshold for routing (VR field) is enabled."]
    #[doc = ""]
    #[doc = " @note This API requires `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE`, and is only used by Thread Test Harness"]
    #[doc = "       to indicate that thread protocol version check VR should be skipped."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnabled   TRUE to enable Security Policy TLV version-threshold for routing, FALSE otherwise."]
    #[doc = ""]
    pub fn otThreadSetThreadVersionCheckEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " This function gets the range of router IDs that are allowed to assign to nodes within the thread network."]
    #[doc = ""]
    #[doc = " @note This API requires `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE`, and is only used for test purpose. All the"]
    #[doc = " router IDs in the range [aMinRouterId, aMaxRouterId] are allowed."]
    #[doc = ""]
    #[doc = " @param[in]   aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[out]  aMinRouterId  The minimum router ID."]
    #[doc = " @param[out]  aMaxRouterId  The maximum router ID."]
    #[doc = ""]
    #[doc = " @sa otThreadSetRouterIdRange"]
    #[doc = ""]
    pub fn otThreadGetRouterIdRange(
        aInstance: *mut otInstance,
        aMinRouterId: *mut u8,
        aMaxRouterId: *mut u8,
    );
}
extern "C" {
    #[doc = " This function sets the range of router IDs that are allowed to assign to nodes within the thread network."]
    #[doc = ""]
    #[doc = " @note This API requires `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE`, and is only used for test purpose. All the"]
    #[doc = " router IDs in the range [aMinRouterId, aMaxRouterId] are allowed."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aMinRouterId  The minimum router ID."]
    #[doc = " @param[in]  aMaxRouterId  The maximum router ID."]
    #[doc = ""]
    #[doc = " @retval  OT_ERROR_NONE           Successfully set the range."]
    #[doc = " @retval  OT_ERROR_INVALID_ARGS   aMinRouterId > aMaxRouterId, or the range is not covered by [0, 62]."]
    #[doc = ""]
    #[doc = " @sa otThreadGetRouterIdRange"]
    #[doc = ""]
    pub fn otThreadSetRouterIdRange(
        aInstance: *mut otInstance,
        aMinRouterId: u8,
        aMaxRouterId: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not a Router ID is currently allocated."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance     A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aRouterId     The router ID to check."]
    #[doc = ""]
    #[doc = " @retval TRUE  The @p aRouterId is allocated."]
    #[doc = " @retval FALSE The @p aRouterId is not allocated."]
    #[doc = ""]
    pub fn otThreadIsRouterIdAllocated(aInstance: *mut otInstance, aRouterId: u8) -> bool;
}
extern "C" {
    #[doc = " This function gets the next hop and path cost towards a given RLOC16 destination."]
    #[doc = ""]
    #[doc = " This function can be used with either @p aNextHopRloc16 or @p aPathCost being NULL indicating caller does not want"]
    #[doc = " to get the value."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance       A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aDesRloct16     The RLOC16 of destination."]
    #[doc = " @param[out] aNextHopRloc16  A pointer to return RLOC16 of next hop, 0xfffe if no next hop."]
    #[doc = " @param[out] aPathCost       A pointer to return path cost towards destination."]
    #[doc = ""]
    pub fn otThreadGetNextHopAndPathCost(
        aInstance: *mut otInstance,
        aDestRloc16: u16,
        aNextHopRloc16: *mut u16,
        aPathCost: *mut u8,
    );
}
#[doc = " This struct represents a TREL peer."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otTrelPeer {
    #[doc = "< The Extended MAC Address of TREL peer."]
    pub mExtAddress: otExtAddress,
    #[doc = "< The Extended PAN Identifier of TREL peer."]
    pub mExtPanId: otExtendedPanId,
    #[doc = "< The IPv6 socket address of TREL peer."]
    pub mSockAddr: otSockAddr,
}
impl Default for otTrelPeer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This type represents an iterator for iterating over TREL peer table entries."]
#[doc = ""]
pub type otTrelPeerIterator = u16;
extern "C" {
    #[doc = " Enables or disables TREL operation."]
    #[doc = ""]
    #[doc = " When @p aEnable is true, this function initiates an ongoing DNS-SD browse on the service name \"_trel._udp\" within the"]
    #[doc = " local browsing domain to discover other devices supporting TREL. Device also registers a new service to be advertised"]
    #[doc = " using DNS-SD, with the service name is \"_trel._udp\" indicating its support for TREL. Device is then ready to receive"]
    #[doc = " TREL messages from peers."]
    #[doc = ""]
    #[doc = " When @p aEnable is false, this function stops the DNS-SD browse on the service name \"_trel._udp\", stops advertising"]
    #[doc = " TREL DNS-SD service, and clears the TREL peer table."]
    #[doc = ""]
    #[doc = " @note By default the OpenThread stack enables the TREL operation on start."]
    #[doc = ""]
    #[doc = " @param[in]  aInstance  A pointer to an OpenThread instance."]
    #[doc = " @param[in]  aEnable    A boolean to enable/disable the TREL operation."]
    #[doc = ""]
    pub fn otTrelSetEnabled(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " This function indicates whether the TREL operation is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   The OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE if the TREL operation is enabled."]
    #[doc = " @retval FALSE if the TREL operation is disabled."]
    #[doc = ""]
    pub fn otTrelIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function initializes a peer table iterator."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   The OpenThread instance."]
    #[doc = " @param[in] aIterator   The iterator to initialize."]
    #[doc = ""]
    pub fn otTrelInitPeerIterator(aInstance: *mut otInstance, aIterator: *mut otTrelPeerIterator);
}
extern "C" {
    #[doc = " This function iterates over the peer table entries and get the next entry from the table"]
    #[doc = ""]
    #[doc = " @param[in] aInstance   The OpenThread instance."]
    #[doc = " @param[in] aIterator   The iterator. MUST be initialized."]
    #[doc = ""]
    #[doc = " @returns A pointer to the next `otTrelPeer` entry or `NULL` if no more entries in the table."]
    #[doc = ""]
    pub fn otTrelGetNextPeer(
        aInstance: *mut otInstance,
        aIterator: *mut otTrelPeerIterator,
    ) -> *const otTrelPeer;
}
extern "C" {
    #[doc = " This function sets the filter mode (enables/disables filtering)."]
    #[doc = ""]
    #[doc = " When filter mode is enabled, any rx and tx traffic through TREL interface is silently dropped. This is mainly"]
    #[doc = " intended for use during testing."]
    #[doc = ""]
    #[doc = " Unlike `otTrel{Enable/Disable}()` which fully starts/stops the TREL operation, when filter mode is enabled the"]
    #[doc = " TREL interface continues to be enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   The OpenThread instance."]
    #[doc = " @param[in] aFiltered   TRUE to enable filter mode, FALSE to disable filter mode."]
    #[doc = ""]
    pub fn otTrelSetFilterEnabled(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " This function indicates whether or not the filter mode is enabled."]
    #[doc = ""]
    #[doc = " @param[in] aInstance   The OpenThread instance."]
    #[doc = ""]
    #[doc = " @retval TRUE if the TREL filter mode is enabled."]
    #[doc = " @retval FALSE if the TREL filter mode is disabled."]
    #[doc = ""]
    pub fn otTrelIsFilterEnabled(aInstance: *mut otInstance) -> bool;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
