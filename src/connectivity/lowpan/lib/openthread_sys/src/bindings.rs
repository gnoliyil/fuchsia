/* automatically generated by rust-bindgen 0.63.0 */

// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index =
                    if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const OT_LOG_LEVEL_NONE: u32 = 0;
pub const OT_LOG_LEVEL_CRIT: u32 = 1;
pub const OT_LOG_LEVEL_WARN: u32 = 2;
pub const OT_LOG_LEVEL_NOTE: u32 = 3;
pub const OT_LOG_LEVEL_INFO: u32 = 4;
pub const OT_LOG_LEVEL_DEBG: u32 = 5;
pub const OPENTHREAD_API_VERSION: u32 = 327;
pub const OT_UPTIME_STRING_SIZE: u32 = 24;
pub const OT_CRYPTO_SHA256_HASH_SIZE: u32 = 32;
pub const OT_CRYPTO_ECDSA_MAX_DER_SIZE: u32 = 125;
pub const OT_CRYPTO_ECDSA_PUBLIC_KEY_SIZE: u32 = 64;
pub const OT_CRYPTO_ECDSA_SIGNATURE_SIZE: u32 = 64;
pub const OT_CRYPTO_PBDKF2_MAX_SALT_SIZE: u32 = 30;
pub const OT_PANID_BROADCAST: u32 = 65535;
pub const OT_EXT_ADDRESS_SIZE: u32 = 8;
pub const OT_MAC_KEY_SIZE: u32 = 16;
pub const OT_IP6_PREFIX_SIZE: u32 = 8;
pub const OT_IP6_PREFIX_BITSIZE: u32 = 64;
pub const OT_IP6_IID_SIZE: u32 = 8;
pub const OT_IP6_ADDRESS_SIZE: u32 = 16;
pub const OT_IP6_ADDRESS_STRING_SIZE: u32 = 40;
pub const OT_IP6_SOCK_ADDR_STRING_SIZE: u32 = 48;
pub const OT_IP6_PREFIX_STRING_SIZE: u32 = 45;
pub const OT_IP6_MAX_MLR_ADDRESSES: u32 = 15;
pub const OT_NETWORK_DATA_ITERATOR_INIT: u32 = 0;
pub const OT_SERVICE_DATA_MAX_SIZE: u32 = 252;
pub const OT_SERVER_DATA_MAX_SIZE: u32 = 248;
pub const OT_BACKBONE_ROUTER_MULTICAST_LISTENER_ITERATOR_INIT: u32 = 0;
pub const OT_BORDER_AGENT_ID_LENGTH: u32 = 16;
pub const OT_DEFAULT_COAP_PORT: u32 = 5683;
pub const OT_COAP_DEFAULT_TOKEN_LENGTH: u32 = 2;
pub const OT_COAP_MAX_TOKEN_LENGTH: u32 = 8;
pub const OT_COAP_MAX_RETRANSMIT: u32 = 20;
pub const OT_COAP_MIN_ACK_TIMEOUT: u32 = 1000;
pub const OT_DEFAULT_COAP_SECURE_PORT: u32 = 5684;
pub const OT_NETWORK_KEY_SIZE: u32 = 16;
pub const OT_NETWORK_NAME_MAX_SIZE: u32 = 16;
pub const OT_EXT_PAN_ID_SIZE: u32 = 8;
pub const OT_MESH_LOCAL_PREFIX_SIZE: u32 = 8;
pub const OT_PSKC_MAX_SIZE: u32 = 16;
pub const OT_CHANNEL_1_MASK: u32 = 2;
pub const OT_CHANNEL_2_MASK: u32 = 4;
pub const OT_CHANNEL_3_MASK: u32 = 8;
pub const OT_CHANNEL_4_MASK: u32 = 16;
pub const OT_CHANNEL_5_MASK: u32 = 32;
pub const OT_CHANNEL_6_MASK: u32 = 64;
pub const OT_CHANNEL_7_MASK: u32 = 128;
pub const OT_CHANNEL_8_MASK: u32 = 256;
pub const OT_CHANNEL_9_MASK: u32 = 512;
pub const OT_CHANNEL_10_MASK: u32 = 1024;
pub const OT_CHANNEL_11_MASK: u32 = 2048;
pub const OT_CHANNEL_12_MASK: u32 = 4096;
pub const OT_CHANNEL_13_MASK: u32 = 8192;
pub const OT_CHANNEL_14_MASK: u32 = 16384;
pub const OT_CHANNEL_15_MASK: u32 = 32768;
pub const OT_CHANNEL_16_MASK: u32 = 65536;
pub const OT_CHANNEL_17_MASK: u32 = 131072;
pub const OT_CHANNEL_18_MASK: u32 = 262144;
pub const OT_CHANNEL_19_MASK: u32 = 524288;
pub const OT_CHANNEL_20_MASK: u32 = 1048576;
pub const OT_CHANNEL_21_MASK: u32 = 2097152;
pub const OT_CHANNEL_22_MASK: u32 = 4194304;
pub const OT_CHANNEL_23_MASK: u32 = 8388608;
pub const OT_CHANNEL_24_MASK: u32 = 16777216;
pub const OT_CHANNEL_25_MASK: u32 = 33554432;
pub const OT_CHANNEL_26_MASK: u32 = 67108864;
pub const OT_OPERATIONAL_DATASET_MAX_LENGTH: u32 = 254;
pub const OT_JOINER_MAX_DISCERNER_LENGTH: u32 = 64;
pub const OT_COMMISSIONING_PASSPHRASE_MIN_SIZE: u32 = 6;
pub const OT_COMMISSIONING_PASSPHRASE_MAX_SIZE: u32 = 255;
pub const OT_PROVISIONING_URL_MAX_SIZE: u32 = 64;
pub const OT_STEERING_DATA_MAX_LENGTH: u32 = 16;
pub const OT_JOINER_MAX_PSKD_LENGTH: u32 = 32;
pub const OPENTHREAD_POSIX_CONFIG_RCP_TIME_SYNC_INTERVAL: u32 = 60000000;
pub const OPENTHREAD_SPINEL_CONFIG_ABORT_ON_UNEXPECTED_RCP_RESET_ENABLE: u32 = 1;
pub const OT_DNS_MAX_NAME_SIZE: u32 = 255;
pub const OT_DNS_MAX_LABEL_SIZE: u32 = 64;
pub const OT_DNS_TXT_KEY_MIN_LENGTH: u32 = 1;
pub const OT_DNS_TXT_KEY_MAX_LENGTH: u32 = 9;
pub const OT_ICMP6_HEADER_DATA_SIZE: u32 = 4;
pub const OT_MAC_FILTER_FIXED_RSS_DISABLED: u32 = 127;
pub const OT_MAC_FILTER_ITERATOR_INIT: u32 = 0;
pub const OT_IP4_ADDRESS_SIZE: u32 = 4;
pub const OT_IP4_ADDRESS_STRING_SIZE: u32 = 17;
pub const OT_IP4_CIDR_STRING_SIZE: u32 = 20;
pub const OT_NETWORK_BASE_TLV_MAX_LENGTH: u32 = 254;
pub const OT_NETWORK_MAX_ROUTER_ID: u32 = 62;
pub const OT_NEIGHBOR_INFO_ITERATOR_INIT: u32 = 0;
pub const OT_JOINER_ADVDATA_MAX_LENGTH: u32 = 64;
pub const OT_DURATION_STRING_SIZE: u32 = 21;
pub const OT_NETWORK_DIAGNOSTIC_TYPELIST_MAX_ENTRIES: u32 = 19;
pub const OT_NETWORK_DIAGNOSTIC_CHILD_TABLE_ENTRY_SIZE: u32 = 3;
pub const OT_NETWORK_DIAGNOSTIC_ITERATOR_INIT: u32 = 0;
pub const OT_NETWORK_DIAGNOSTIC_MAX_VENDOR_NAME_TLV_LENGTH: u32 = 32;
pub const OT_NETWORK_DIAGNOSTIC_MAX_VENDOR_MODEL_TLV_LENGTH: u32 = 32;
pub const OT_NETWORK_DIAGNOSTIC_MAX_VENDOR_SW_VERSION_TLV_LENGTH: u32 = 16;
pub const OT_NETWORK_DIAGNOSTIC_MAX_THREAD_STACK_VERSION_TLV_LENGTH: u32 = 64;
pub const OT_TIME_SYNC_INVALID_SEQ: u32 = 0;
pub const OT_SNTP_DEFAULT_SERVER_IP: &[u8; 19usize] = b"2001:4860:4806:8::\0";
pub const OT_SNTP_DEFAULT_SERVER_PORT: u32 = 123;
pub const OT_TCP_ENDPOINT_TCB_SIZE_BASE: u32 = 368;
pub const OT_TCP_ENDPOINT_TCB_NUM_PTR: u32 = 36;
pub const OT_TCP_RECEIVE_BUFFER_SIZE_FEW_HOPS: u32 = 2598;
pub const OT_TCP_RECEIVE_BUFFER_SIZE_MANY_HOPS: u32 = 4157;
pub const OT_TCP_LISTENER_TCB_SIZE_BASE: u32 = 16;
pub const OT_TCP_LISTENER_TCB_NUM_PTR: u32 = 3;
pub const OT_CHILD_IP6_ADDRESS_ITERATOR_INIT: u32 = 0;
#[doc = " No error."]
pub const OT_ERROR_NONE: otError = 0;
#[doc = " Operational failed."]
pub const OT_ERROR_FAILED: otError = 1;
#[doc = " Message was dropped."]
pub const OT_ERROR_DROP: otError = 2;
#[doc = " Insufficient buffers."]
pub const OT_ERROR_NO_BUFS: otError = 3;
#[doc = " No route available."]
pub const OT_ERROR_NO_ROUTE: otError = 4;
#[doc = " Service is busy and could not service the operation."]
pub const OT_ERROR_BUSY: otError = 5;
#[doc = " Failed to parse message."]
pub const OT_ERROR_PARSE: otError = 6;
#[doc = " Input arguments are invalid."]
pub const OT_ERROR_INVALID_ARGS: otError = 7;
#[doc = " Security checks failed."]
pub const OT_ERROR_SECURITY: otError = 8;
#[doc = " Address resolution requires an address query operation."]
pub const OT_ERROR_ADDRESS_QUERY: otError = 9;
#[doc = " Address is not in the source match table."]
pub const OT_ERROR_NO_ADDRESS: otError = 10;
#[doc = " Operation was aborted."]
pub const OT_ERROR_ABORT: otError = 11;
#[doc = " Function or method is not implemented."]
pub const OT_ERROR_NOT_IMPLEMENTED: otError = 12;
#[doc = " Cannot complete due to invalid state."]
pub const OT_ERROR_INVALID_STATE: otError = 13;
#[doc = " No acknowledgment was received after macMaxFrameRetries (IEEE 802.15.4-2006)."]
pub const OT_ERROR_NO_ACK: otError = 14;
#[doc = " A transmission could not take place due to activity on the channel, i.e., the CSMA-CA mechanism has failed\n (IEEE 802.15.4-2006)."]
pub const OT_ERROR_CHANNEL_ACCESS_FAILURE: otError = 15;
#[doc = " Not currently attached to a Thread Partition."]
pub const OT_ERROR_DETACHED: otError = 16;
#[doc = " FCS check failure while receiving."]
pub const OT_ERROR_FCS: otError = 17;
#[doc = " No frame received."]
pub const OT_ERROR_NO_FRAME_RECEIVED: otError = 18;
#[doc = " Received a frame from an unknown neighbor."]
pub const OT_ERROR_UNKNOWN_NEIGHBOR: otError = 19;
#[doc = " Received a frame from an invalid source address."]
pub const OT_ERROR_INVALID_SOURCE_ADDRESS: otError = 20;
#[doc = " Received a frame filtered by the address filter (allowlisted or denylisted)."]
pub const OT_ERROR_ADDRESS_FILTERED: otError = 21;
#[doc = " Received a frame filtered by the destination address check."]
pub const OT_ERROR_DESTINATION_ADDRESS_FILTERED: otError = 22;
#[doc = " The requested item could not be found."]
pub const OT_ERROR_NOT_FOUND: otError = 23;
#[doc = " The operation is already in progress."]
pub const OT_ERROR_ALREADY: otError = 24;
#[doc = " The creation of IPv6 address failed."]
pub const OT_ERROR_IP6_ADDRESS_CREATION_FAILURE: otError = 26;
#[doc = " Operation prevented by mode flags"]
pub const OT_ERROR_NOT_CAPABLE: otError = 27;
#[doc = " Coap response or acknowledgment or DNS, SNTP response not received."]
pub const OT_ERROR_RESPONSE_TIMEOUT: otError = 28;
#[doc = " Received a duplicated frame."]
pub const OT_ERROR_DUPLICATED: otError = 29;
#[doc = " Message is being dropped from reassembly list due to timeout."]
pub const OT_ERROR_REASSEMBLY_TIMEOUT: otError = 30;
#[doc = " Message is not a TMF Message."]
pub const OT_ERROR_NOT_TMF: otError = 31;
#[doc = " Received a non-lowpan data frame."]
pub const OT_ERROR_NOT_LOWPAN_DATA_FRAME: otError = 32;
#[doc = " The link margin was too low."]
pub const OT_ERROR_LINK_MARGIN_LOW: otError = 34;
#[doc = " Input (CLI) command is invalid."]
pub const OT_ERROR_INVALID_COMMAND: otError = 35;
#[doc = " Special error code used to indicate success/error status is pending and not yet known.\n"]
pub const OT_ERROR_PENDING: otError = 36;
#[doc = " Request rejected."]
pub const OT_ERROR_REJECTED: otError = 37;
#[doc = " The number of defined errors."]
pub const OT_NUM_ERRORS: otError = 38;
#[doc = " Generic error (should not use)."]
pub const OT_ERROR_GENERIC: otError = 255;
#[doc = " This enumeration represents error codes used throughout OpenThread.\n"]
pub type otError = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function converts an otError enum into a string.\n\n @param[in]  aError     An otError enum.\n\n @returns  A string representation of an otError.\n"]
    pub fn otThreadErrorToString(aError: otError) -> *const ::std::os::raw::c_char;
}
pub type va_list = __builtin_va_list;
#[doc = " This type represents the log level.\n"]
pub type otLogLevel = ::std::os::raw::c_int;
#[doc = "< OpenThread API"]
pub const OT_LOG_REGION_API: otLogRegion = 1;
#[doc = "< MLE"]
pub const OT_LOG_REGION_MLE: otLogRegion = 2;
#[doc = "< EID-to-RLOC mapping."]
pub const OT_LOG_REGION_ARP: otLogRegion = 3;
#[doc = "< Network Data"]
pub const OT_LOG_REGION_NET_DATA: otLogRegion = 4;
#[doc = "< ICMPv6"]
pub const OT_LOG_REGION_ICMP: otLogRegion = 5;
#[doc = "< IPv6"]
pub const OT_LOG_REGION_IP6: otLogRegion = 6;
#[doc = "< TCP"]
pub const OT_LOG_REGION_TCP: otLogRegion = 7;
#[doc = "< IEEE 802.15.4 MAC"]
pub const OT_LOG_REGION_MAC: otLogRegion = 8;
#[doc = "< Memory"]
pub const OT_LOG_REGION_MEM: otLogRegion = 9;
#[doc = "< NCP"]
pub const OT_LOG_REGION_NCP: otLogRegion = 10;
#[doc = "< Mesh Commissioning Protocol"]
pub const OT_LOG_REGION_MESH_COP: otLogRegion = 11;
#[doc = "< Network Diagnostic"]
pub const OT_LOG_REGION_NET_DIAG: otLogRegion = 12;
#[doc = "< Platform"]
pub const OT_LOG_REGION_PLATFORM: otLogRegion = 13;
#[doc = "< CoAP"]
pub const OT_LOG_REGION_COAP: otLogRegion = 14;
#[doc = "< CLI"]
pub const OT_LOG_REGION_CLI: otLogRegion = 15;
#[doc = "< OpenThread Core"]
pub const OT_LOG_REGION_CORE: otLogRegion = 16;
#[doc = "< Utility module"]
pub const OT_LOG_REGION_UTIL: otLogRegion = 17;
#[doc = "< Backbone Router (available since Thread 1.2)"]
pub const OT_LOG_REGION_BBR: otLogRegion = 18;
#[doc = "< Multicast Listener Registration (available since Thread 1.2)"]
pub const OT_LOG_REGION_MLR: otLogRegion = 19;
#[doc = "< Domain Unicast Address (available since Thread 1.2)"]
pub const OT_LOG_REGION_DUA: otLogRegion = 20;
#[doc = "< Border Router"]
pub const OT_LOG_REGION_BR: otLogRegion = 21;
#[doc = "< Service Registration Protocol (SRP)"]
pub const OT_LOG_REGION_SRP: otLogRegion = 22;
#[doc = "< DNS"]
pub const OT_LOG_REGION_DNS: otLogRegion = 23;
#[doc = " This enumeration represents log regions.\n\n The support for log region is removed and instead each core module can define its own name to appended to the logs.\n However, the `otLogRegion` enumeration is still defined as before to help with platforms which we may be using it\n in their `otPlatLog()` implementation. The OT core will always emit all logs with `OT_LOG_REGION_CORE`.\n"]
pub type otLogRegion = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function outputs logs.\n\n Note that the support for log region is removed. The OT core will always emit all logs with `OT_LOG_REGION_CORE`\n as @p aLogRegion.\n\n @param[in]  aLogLevel   The log level.\n @param[in]  aLogRegion  The log region.\n @param[in]  aFormat     A pointer to the format string.\n @param[in]  ...         Arguments for the format specification.\n"]
    pub fn otPlatLog(
        aLogLevel: otLogLevel,
        aLogRegion: otLogRegion,
        aFormat: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " This (optional) platform function outputs a prepared log line.\n\n Note that this function is optional and if not provided by platform layer, a default (weak) implementation is\n provided and used by OpenThread core as `otPlatLog(aLogLevel, aLogResion, \"%s\", aLogLine)`.\n\n @param[in]  aLogLevel   The log level.\n @param[in]  aLogRegion  The log region.\n @param[in]  aLogLine    A pointer to a log line string.\n"]
    pub fn otPlatLogLine(
        aLogLevel: otLogLevel,
        aLogRegion: otLogRegion,
        aLogLine: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " This function handles OpenThread log level changes.\n\n This platform function is called whenever the OpenThread log level changes.\n This platform function is optional since an empty weak implementation has been provided.\n\n @note Only applicable when `OPENTHREAD_CONFIG_LOG_LEVEL_DYNAMIC_ENABLE=1`.\n\n @param[in]  aLogLevel  The new OpenThread log level.\n"]
    pub fn otPlatLogHandleLevelChanged(aLogLevel: otLogLevel);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otInstance {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " This function initializes the OpenThread library.\n\n This function initializes OpenThread and prepares it for subsequent OpenThread API calls. This function must be\n called before any other calls to OpenThread.\n\n This function is available and can only be used when support for multiple OpenThread instances is enabled.\n\n @param[in]     aInstanceBuffer      The buffer for OpenThread to use for allocating the otInstance structure.\n @param[in,out] aInstanceBufferSize  On input, the size of aInstanceBuffer. On output, if not enough space for\n                                     otInstance, the number of bytes required for otInstance.\n\n @returns  A pointer to the new OpenThread instance.\n\n @sa otInstanceFinalize\n"]
    pub fn otInstanceInit(
        aInstanceBuffer: *mut ::std::os::raw::c_void,
        aInstanceBufferSize: *mut usize,
    ) -> *mut otInstance;
}
extern "C" {
    #[doc = " This function initializes the static single instance of the OpenThread library.\n\n This function initializes OpenThread and prepares it for subsequent OpenThread API calls. This function must be\n called before any other calls to OpenThread.\n\n This function is available and can only be used when support for multiple OpenThread instances is disabled.\n\n @returns A pointer to the single OpenThread instance.\n"]
    pub fn otInstanceInitSingle() -> *mut otInstance;
}
extern "C" {
    #[doc = " Gets the instance identifier.\n\n The instance identifier is set to a random value when the instance is constructed, and then its value will not\n change after initialization.\n\n @returns The instance identifier.\n"]
    pub fn otInstanceGetId(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " This function indicates whether or not the instance is valid/initialized.\n\n The instance is considered valid if it is acquired and initialized using either `otInstanceInitSingle()` (in single\n instance case) or `otInstanceInit()` (in multi instance case). A subsequent call to `otInstanceFinalize()` causes\n the instance to be considered as uninitialized.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns TRUE if the given instance is valid/initialized, FALSE otherwise.\n"]
    pub fn otInstanceIsInitialized(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function disables the OpenThread library.\n\n Call this function when OpenThread is no longer in use.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n"]
    pub fn otInstanceFinalize(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function returns the current instance uptime (in msec).\n\n This function requires `OPENTHREAD_CONFIG_UPTIME_ENABLE` to be enabled.\n\n The uptime is given as number of milliseconds since OpenThread instance was initialized.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns The uptime (number of milliseconds).\n"]
    pub fn otInstanceGetUptime(aInstance: *mut otInstance) -> u64;
}
extern "C" {
    #[doc = " This function returns the current instance uptime as a human-readable string.\n\n This function requires `OPENTHREAD_CONFIG_UPTIME_ENABLE` to be enabled.\n\n The string follows the format \"<hh>:<mm>:<ss>.<mmmm>\" for hours, minutes, seconds and millisecond (if uptime is\n shorter than one day) or \"<dd>d.<hh>:<mm>:<ss>.<mmmm>\" (if longer than a day).\n\n If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated\n but the outputted string is always null-terminated.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[out] aBuffer   A pointer to a char array to output the string.\n @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_UPTIME_STRING_SIZE`.\n"]
    pub fn otInstanceGetUptimeAsString(
        aInstance: *mut otInstance,
        aBuffer: *mut ::std::os::raw::c_char,
        aSize: u16,
    );
}
#[doc = "< IPv6 address was added"]
pub const OT_CHANGED_IP6_ADDRESS_ADDED: _bindgen_ty_1 = 1;
#[doc = "< IPv6 address was removed"]
pub const OT_CHANGED_IP6_ADDRESS_REMOVED: _bindgen_ty_1 = 2;
#[doc = "< Role (disabled, detached, child, router, leader) changed"]
pub const OT_CHANGED_THREAD_ROLE: _bindgen_ty_1 = 4;
#[doc = "< The link-local address changed"]
pub const OT_CHANGED_THREAD_LL_ADDR: _bindgen_ty_1 = 8;
#[doc = "< The mesh-local address changed"]
pub const OT_CHANGED_THREAD_ML_ADDR: _bindgen_ty_1 = 16;
#[doc = "< RLOC was added"]
pub const OT_CHANGED_THREAD_RLOC_ADDED: _bindgen_ty_1 = 32;
#[doc = "< RLOC was removed"]
pub const OT_CHANGED_THREAD_RLOC_REMOVED: _bindgen_ty_1 = 64;
#[doc = "< Partition ID changed"]
pub const OT_CHANGED_THREAD_PARTITION_ID: _bindgen_ty_1 = 128;
#[doc = "< Thread Key Sequence changed"]
pub const OT_CHANGED_THREAD_KEY_SEQUENCE_COUNTER: _bindgen_ty_1 = 256;
#[doc = "< Thread Network Data changed"]
pub const OT_CHANGED_THREAD_NETDATA: _bindgen_ty_1 = 512;
#[doc = "< Child was added"]
pub const OT_CHANGED_THREAD_CHILD_ADDED: _bindgen_ty_1 = 1024;
#[doc = "< Child was removed"]
pub const OT_CHANGED_THREAD_CHILD_REMOVED: _bindgen_ty_1 = 2048;
#[doc = "< Subscribed to a IPv6 multicast address"]
pub const OT_CHANGED_IP6_MULTICAST_SUBSCRIBED: _bindgen_ty_1 = 4096;
#[doc = "< Unsubscribed from a IPv6 multicast address"]
pub const OT_CHANGED_IP6_MULTICAST_UNSUBSCRIBED: _bindgen_ty_1 = 8192;
#[doc = "< Thread network channel changed"]
pub const OT_CHANGED_THREAD_CHANNEL: _bindgen_ty_1 = 16384;
#[doc = "< Thread network PAN Id changed"]
pub const OT_CHANGED_THREAD_PANID: _bindgen_ty_1 = 32768;
#[doc = "< Thread network name changed"]
pub const OT_CHANGED_THREAD_NETWORK_NAME: _bindgen_ty_1 = 65536;
#[doc = "< Thread network extended PAN ID changed"]
pub const OT_CHANGED_THREAD_EXT_PANID: _bindgen_ty_1 = 131072;
#[doc = "< Network key changed"]
pub const OT_CHANGED_NETWORK_KEY: _bindgen_ty_1 = 262144;
#[doc = "< PSKc changed"]
pub const OT_CHANGED_PSKC: _bindgen_ty_1 = 524288;
#[doc = "< Security Policy changed"]
pub const OT_CHANGED_SECURITY_POLICY: _bindgen_ty_1 = 1048576;
#[doc = "< Channel Manager new pending Thread channel changed"]
pub const OT_CHANGED_CHANNEL_MANAGER_NEW_CHANNEL: _bindgen_ty_1 = 2097152;
#[doc = "< Supported channel mask changed"]
pub const OT_CHANGED_SUPPORTED_CHANNEL_MASK: _bindgen_ty_1 = 4194304;
#[doc = "< Commissioner state changed"]
pub const OT_CHANGED_COMMISSIONER_STATE: _bindgen_ty_1 = 8388608;
#[doc = "< Thread network interface state changed"]
pub const OT_CHANGED_THREAD_NETIF_STATE: _bindgen_ty_1 = 16777216;
#[doc = "< Backbone Router state changed"]
pub const OT_CHANGED_THREAD_BACKBONE_ROUTER_STATE: _bindgen_ty_1 = 33554432;
#[doc = "< Local Backbone Router configuration changed"]
pub const OT_CHANGED_THREAD_BACKBONE_ROUTER_LOCAL: _bindgen_ty_1 = 67108864;
#[doc = "< Joiner state changed"]
pub const OT_CHANGED_JOINER_STATE: _bindgen_ty_1 = 134217728;
#[doc = "< Active Operational Dataset changed"]
pub const OT_CHANGED_ACTIVE_DATASET: _bindgen_ty_1 = 268435456;
#[doc = "< Pending Operational Dataset changed"]
pub const OT_CHANGED_PENDING_DATASET: _bindgen_ty_1 = 536870912;
#[doc = "< The state of NAT64 translator changed"]
pub const OT_CHANGED_NAT64_TRANSLATOR_STATE: _bindgen_ty_1 = 1073741824;
#[doc = " This enumeration defines flags that are passed as part of `otStateChangedCallback`.\n"]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " This type represents a bit-field indicating specific state/configuration that has changed. See `OT_CHANGED_*`\n definitions.\n"]
pub type otChangedFlags = u32;
#[doc = " This function pointer is called to notify certain configuration or state changes within OpenThread.\n\n @param[in]  aFlags    A bit-field indicating specific state that has changed.  See `OT_CHANGED_*` definitions.\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otStateChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(aFlags: otChangedFlags, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function registers a callback to indicate when certain configuration or state changes within OpenThread.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aCallback  A pointer to a function that is called with certain configuration or state changes.\n @param[in]  aContext   A pointer to application-specific context.\n\n @retval OT_ERROR_NONE     Added the callback to the list of callbacks.\n @retval OT_ERROR_ALREADY  The callback was already registered.\n @retval OT_ERROR_NO_BUFS  Could not add the callback due to resource constraints.\n"]
    pub fn otSetStateChangedCallback(
        aInstance: *mut otInstance,
        aCallback: otStateChangedCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function removes a callback to indicate when certain configuration or state changes within OpenThread.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aCallback   A pointer to a function that is called with certain configuration or state changes.\n @param[in]  aContext    A pointer to application-specific context.\n"]
    pub fn otRemoveStateChangeCallback(
        aInstance: *mut otInstance,
        aCallback: otStateChangedCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This method triggers a platform reset.\n\n The reset process ensures that all the OpenThread state/info (stored in volatile memory) is erased. Note that the\n `otPlatformReset` does not erase any persistent state/info saved in non-volatile memory.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otInstanceReset(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Deletes all the settings stored on non-volatile memory, and then triggers a platform reset.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otInstanceFactoryReset(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method resets the internal states of the OpenThread radio stack.\n\n Callbacks and configurations are preserved.\n\n This API is only available under radio builds (`OPENTHREAD_RADIO = 1`).\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otInstanceResetRadioStack(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function erases all the OpenThread persistent info (network settings) stored on non-volatile memory.\n Erase is successful only if the device is in `disabled` state/role.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE           All persistent info/state was erased successfully.\n @retval OT_ERROR_INVALID_STATE  Device is not in `disabled` state/role.\n"]
    pub fn otInstanceErasePersistentInfo(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function gets the OpenThread version string.\n\n @returns A pointer to the OpenThread version.\n"]
    pub fn otGetVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function gets the OpenThread radio version string.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the OpenThread radio version.\n"]
    pub fn otGetRadioVersionString(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
#[doc = " This structure represents Backbone Router configuration.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otBackboneRouterConfig {
    #[doc = "< Only used when get Primary Backbone Router information in the Thread Network"]
    pub mServer16: u16,
    #[doc = "< Reregistration Delay (in seconds)"]
    pub mReregistrationDelay: u16,
    #[doc = "< Multicast Listener Registration Timeout (in seconds)"]
    pub mMlrTimeout: u32,
    #[doc = "< Sequence Number"]
    pub mSequenceNumber: u8,
}
extern "C" {
    #[doc = " This function gets the Primary Backbone Router information in the Thread Network.\n\n @param[in]   aInstance            A pointer to an OpenThread instance.\n @param[out]  aConfig              A pointer to where to put Primary Backbone Router information.\n\n @retval OT_ERROR_NONE              Successfully got Primary Backbone Router information.\n @retval OT_ERROR_NOT_FOUND         No Primary Backbone Router exists.\n"]
    pub fn otBackboneRouterGetPrimary(
        aInstance: *mut otInstance,
        aConfig: *mut otBackboneRouterConfig,
    ) -> otError;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMessage {
    _unused: [u8; 0],
}
#[doc = "< Low priority level."]
pub const OT_MESSAGE_PRIORITY_LOW: otMessagePriority = 0;
#[doc = "< Normal priority level."]
pub const OT_MESSAGE_PRIORITY_NORMAL: otMessagePriority = 1;
#[doc = "< High priority level."]
pub const OT_MESSAGE_PRIORITY_HIGH: otMessagePriority = 2;
#[doc = " This enumeration defines the OpenThread message priority levels.\n"]
pub type otMessagePriority = ::std::os::raw::c_uint;
#[doc = " This structure represents a message settings.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMessageSettings {
    #[doc = "< TRUE if the message should be secured at Layer 2."]
    pub mLinkSecurityEnabled: bool,
    #[doc = "< Priority level (MUST be a `OT_MESSAGE_PRIORITY_*` from `otMessagePriority`)."]
    pub mPriority: u8,
}
extern "C" {
    #[doc = " Free an allocated message buffer.\n\n @param[in]  aMessage  A pointer to a message buffer.\n\n @sa otMessageAppend\n @sa otMessageGetLength\n @sa otMessageSetLength\n @sa otMessageGetOffset\n @sa otMessageSetOffset\n @sa otMessageRead\n @sa otMessageWrite\n"]
    pub fn otMessageFree(aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " Get the message length in bytes.\n\n @param[in]  aMessage  A pointer to a message buffer.\n\n @returns The message length in bytes.\n\n @sa otMessageFree\n @sa otMessageAppend\n @sa otMessageSetLength\n @sa otMessageGetOffset\n @sa otMessageSetOffset\n @sa otMessageRead\n @sa otMessageWrite\n @sa otMessageSetLength\n"]
    pub fn otMessageGetLength(aMessage: *const otMessage) -> u16;
}
extern "C" {
    #[doc = " Set the message length in bytes.\n\n @param[in]  aMessage  A pointer to a message buffer.\n @param[in]  aLength   A length in bytes.\n\n @retval OT_ERROR_NONE     Successfully set the message length.\n @retval OT_ERROR_NO_BUFS  No available buffers to grow the message.\n\n @sa otMessageFree\n @sa otMessageAppend\n @sa otMessageGetLength\n @sa otMessageGetOffset\n @sa otMessageSetOffset\n @sa otMessageRead\n @sa otMessageWrite\n"]
    pub fn otMessageSetLength(aMessage: *mut otMessage, aLength: u16) -> otError;
}
extern "C" {
    #[doc = " Get the message offset in bytes.\n\n @param[in]  aMessage  A pointer to a message buffer.\n\n @returns The message offset value.\n\n @sa otMessageFree\n @sa otMessageAppend\n @sa otMessageGetLength\n @sa otMessageSetLength\n @sa otMessageSetOffset\n @sa otMessageRead\n @sa otMessageWrite\n"]
    pub fn otMessageGetOffset(aMessage: *const otMessage) -> u16;
}
extern "C" {
    #[doc = " Set the message offset in bytes.\n\n @param[in]  aMessage  A pointer to a message buffer.\n @param[in]  aOffset   An offset in bytes.\n\n @sa otMessageFree\n @sa otMessageAppend\n @sa otMessageGetLength\n @sa otMessageSetLength\n @sa otMessageGetOffset\n @sa otMessageRead\n @sa otMessageWrite\n"]
    pub fn otMessageSetOffset(aMessage: *mut otMessage, aOffset: u16);
}
extern "C" {
    #[doc = " This function indicates whether or not link security is enabled for the message.\n\n @param[in]  aMessage  A pointer to a message buffer.\n\n @retval TRUE   If link security is enabled.\n @retval FALSE  If link security is not enabled.\n"]
    pub fn otMessageIsLinkSecurityEnabled(aMessage: *const otMessage) -> bool;
}
extern "C" {
    #[doc = " This function sets/forces the message to be forwarded using direct transmission.\n Default setting for a new message is `false`.\n\n @param[in]  aMessage  A pointer to a message buffer.\n @param[in]  aEnabled  If `true`, the message is forced to use direct transmission. If `false`, the message follows\n                       the normal procedure.\n"]
    pub fn otMessageSetDirectTransmission(aMessage: *mut otMessage, aEnabled: bool);
}
extern "C" {
    #[doc = " This function returns the average RSS (received signal strength) associated with the message.\n\n @returns The average RSS value (in dBm) or OT_RADIO_RSSI_INVALID if no average RSS is available.\n"]
    pub fn otMessageGetRss(aMessage: *const otMessage) -> i8;
}
extern "C" {
    #[doc = " Append bytes to a message.\n\n @param[in]  aMessage  A pointer to a message buffer.\n @param[in]  aBuf      A pointer to the data to append.\n @param[in]  aLength   Number of bytes to append.\n\n @retval OT_ERROR_NONE     Successfully appended to the message\n @retval OT_ERROR_NO_BUFS  No available buffers to grow the message.\n\n @sa otMessageFree\n @sa otMessageGetLength\n @sa otMessageSetLength\n @sa otMessageGetOffset\n @sa otMessageSetOffset\n @sa otMessageRead\n @sa otMessageWrite\n"]
    pub fn otMessageAppend(
        aMessage: *mut otMessage,
        aBuf: *const ::std::os::raw::c_void,
        aLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Read bytes from a message.\n\n @param[in]  aMessage  A pointer to a message buffer.\n @param[in]  aOffset   An offset in bytes.\n @param[in]  aBuf      A pointer to a buffer that message bytes are read to.\n @param[in]  aLength   Number of bytes to read.\n\n @returns The number of bytes read.\n\n @sa otMessageFree\n @sa otMessageAppend\n @sa otMessageGetLength\n @sa otMessageSetLength\n @sa otMessageGetOffset\n @sa otMessageSetOffset\n @sa otMessageWrite\n"]
    pub fn otMessageRead(
        aMessage: *const otMessage,
        aOffset: u16,
        aBuf: *mut ::std::os::raw::c_void,
        aLength: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Write bytes to a message.\n\n @param[in]  aMessage  A pointer to a message buffer.\n @param[in]  aOffset   An offset in bytes.\n @param[in]  aBuf      A pointer to a buffer that message bytes are written from.\n @param[in]  aLength   Number of bytes to write.\n\n @returns The number of bytes written.\n\n @sa otMessageFree\n @sa otMessageAppend\n @sa otMessageGetLength\n @sa otMessageSetLength\n @sa otMessageGetOffset\n @sa otMessageSetOffset\n @sa otMessageRead\n"]
    pub fn otMessageWrite(
        aMessage: *mut otMessage,
        aOffset: u16,
        aBuf: *const ::std::os::raw::c_void,
        aLength: u16,
    ) -> ::std::os::raw::c_int;
}
#[doc = " This structure represents an OpenThread message queue."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otMessageQueue {
    #[doc = "< Opaque data used by the implementation."]
    pub mData: *mut ::std::os::raw::c_void,
}
impl Default for otMessageQueue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents information about a message queue.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMessageQueueInfo {
    #[doc = "< Number of messages in the queue."]
    pub mNumMessages: u16,
    #[doc = "< Number of data buffers used by messages in the queue."]
    pub mNumBuffers: u16,
    #[doc = "< Total number of bytes used by all messages in the queue."]
    pub mTotalBytes: u32,
}
#[doc = " This structure represents the message buffer information for different queues used by OpenThread stack.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otBufferInfo {
    #[doc = "< The total number of buffers in the messages pool (0xffff if unknown)."]
    pub mTotalBuffers: u16,
    #[doc = "< The number of free buffers (0xffff if unknown)."]
    pub mFreeBuffers: u16,
    #[doc = " The maximum number of used buffers at the same time since OT stack initialization or last call to\n `otMessageResetBufferInfo()`.\n"]
    pub mMaxUsedBuffers: u16,
    #[doc = "< Info about 6LoWPAN send queue."]
    pub m6loSendQueue: otMessageQueueInfo,
    #[doc = "< Info about 6LoWPAN reassembly queue."]
    pub m6loReassemblyQueue: otMessageQueueInfo,
    #[doc = "< Info about IPv6 send queue."]
    pub mIp6Queue: otMessageQueueInfo,
    #[doc = "< Info about MPL send queue."]
    pub mMplQueue: otMessageQueueInfo,
    #[doc = "< Info about MLE delayed message queue."]
    pub mMleQueue: otMessageQueueInfo,
    #[doc = "< Info about CoAP/TMF send queue."]
    pub mCoapQueue: otMessageQueueInfo,
    #[doc = "< Info about CoAP secure send queue."]
    pub mCoapSecureQueue: otMessageQueueInfo,
    #[doc = "< Info about application CoAP send queue."]
    pub mApplicationCoapQueue: otMessageQueueInfo,
}
extern "C" {
    #[doc = " Initialize the message queue.\n\n This function MUST be called once and only once for a `otMessageQueue` instance before any other `otMessageQueue`\n functions. The behavior is undefined if other queue APIs are used with an `otMessageQueue` before it being\n initialized or if it is initialized more than once.\n\n @param[in]  aQueue     A pointer to a message queue.\n"]
    pub fn otMessageQueueInit(aQueue: *mut otMessageQueue);
}
extern "C" {
    #[doc = " This function adds a message to the end of the given message queue.\n\n @param[in]  aQueue    A pointer to the message queue.\n @param[in]  aMessage  The message to add.\n"]
    pub fn otMessageQueueEnqueue(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " This function adds a message at the head/front of the given message queue.\n\n @param[in]  aQueue    A pointer to the message queue.\n @param[in]  aMessage  The message to add.\n"]
    pub fn otMessageQueueEnqueueAtHead(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " This function removes a message from the given message queue.\n\n @param[in]  aQueue    A pointer to the message queue.\n @param[in]  aMessage  The message to remove.\n"]
    pub fn otMessageQueueDequeue(aQueue: *mut otMessageQueue, aMessage: *mut otMessage);
}
extern "C" {
    #[doc = " This function returns a pointer to the message at the head of the queue.\n\n @param[in]  aQueue    A pointer to a message queue.\n\n @returns  A pointer to the message at the head of queue or NULL if queue is empty.\n"]
    pub fn otMessageQueueGetHead(aQueue: *mut otMessageQueue) -> *mut otMessage;
}
extern "C" {
    #[doc = " This function returns a pointer to the next message in the queue by iterating forward (from head to tail).\n\n @param[in]  aQueue    A pointer to a message queue.\n @param[in]  aMessage  A pointer to current message buffer.\n\n @returns  A pointer to the next message in the queue after `aMessage` or NULL if `aMessage is the tail of queue.\n           NULL is returned if `aMessage` is not in the queue `aQueue`.\n"]
    pub fn otMessageQueueGetNext(
        aQueue: *mut otMessageQueue,
        aMessage: *const otMessage,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Get the Message Buffer information.\n\n @param[in]   aInstance    A pointer to the OpenThread instance.\n @param[out]  aBufferInfo  A pointer where the message buffer information is written.\n"]
    pub fn otMessageGetBufferInfo(aInstance: *mut otInstance, aBufferInfo: *mut otBufferInfo);
}
extern "C" {
    #[doc = " Reset the Message Buffer information counter tracking the maximum number buffers in use at the same time.\n\n This resets `mMaxUsedBuffers` in `otBufferInfo`.\n\n @param[in]   aInstance    A pointer to the OpenThread instance.\n"]
    pub fn otMessageResetBufferInfo(aInstance: *mut otInstance);
}
#[doc = "< Key Type: Raw Data."]
pub const OT_CRYPTO_KEY_TYPE_RAW: otCryptoKeyType = 0;
#[doc = "< Key Type: AES."]
pub const OT_CRYPTO_KEY_TYPE_AES: otCryptoKeyType = 1;
#[doc = "< Key Type: HMAC."]
pub const OT_CRYPTO_KEY_TYPE_HMAC: otCryptoKeyType = 2;
#[doc = "< Key Type: ECDSA."]
pub const OT_CRYPTO_KEY_TYPE_ECDSA: otCryptoKeyType = 3;
#[doc = " This enumeration defines the key types.\n"]
pub type otCryptoKeyType = ::std::os::raw::c_uint;
#[doc = "< Key Algorithm: Vendor Defined."]
pub const OT_CRYPTO_KEY_ALG_VENDOR: otCryptoKeyAlgorithm = 0;
#[doc = "< Key Algorithm: AES ECB."]
pub const OT_CRYPTO_KEY_ALG_AES_ECB: otCryptoKeyAlgorithm = 1;
#[doc = "< Key Algorithm: HMAC SHA-256."]
pub const OT_CRYPTO_KEY_ALG_HMAC_SHA_256: otCryptoKeyAlgorithm = 2;
#[doc = "< Key Algorithm: ECDSA."]
pub const OT_CRYPTO_KEY_ALG_ECDSA: otCryptoKeyAlgorithm = 3;
#[doc = " This enumeration defines the key algorithms.\n"]
pub type otCryptoKeyAlgorithm = ::std::os::raw::c_uint;
#[doc = "< Key Usage: Key Usage is empty."]
pub const OT_CRYPTO_KEY_USAGE_NONE: _bindgen_ty_2 = 0;
#[doc = "< Key Usage: Key can be exported."]
pub const OT_CRYPTO_KEY_USAGE_EXPORT: _bindgen_ty_2 = 1;
#[doc = "< Key Usage: Encryption (vendor defined)."]
pub const OT_CRYPTO_KEY_USAGE_ENCRYPT: _bindgen_ty_2 = 2;
#[doc = "< Key Usage: AES ECB."]
pub const OT_CRYPTO_KEY_USAGE_DECRYPT: _bindgen_ty_2 = 4;
#[doc = "< Key Usage: Sign Hash."]
pub const OT_CRYPTO_KEY_USAGE_SIGN_HASH: _bindgen_ty_2 = 8;
#[doc = "< Key Usage: Verify Hash."]
pub const OT_CRYPTO_KEY_USAGE_VERIFY_HASH: _bindgen_ty_2 = 16;
#[doc = " This enumeration defines the key usage flags.\n"]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[doc = "< Key Persistence: Key is volatile."]
pub const OT_CRYPTO_KEY_STORAGE_VOLATILE: otCryptoKeyStorage = 0;
#[doc = "< Key Persistence: Key is persistent."]
pub const OT_CRYPTO_KEY_STORAGE_PERSISTENT: otCryptoKeyStorage = 1;
#[doc = " This enumeration defines the key storage types.\n"]
pub type otCryptoKeyStorage = ::std::os::raw::c_uint;
#[doc = " This datatype represents the key reference.\n"]
pub type otCryptoKeyRef = u32;
#[doc = " @struct otCryptoKey\n\n This structure represents the Key Material required for Crypto operations.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCryptoKey {
    #[doc = "< Pointer to the buffer containing key. NULL indicates to use `mKeyRef`."]
    pub mKey: *const u8,
    #[doc = "< The key length in bytes (applicable when `mKey` is not NULL)."]
    pub mKeyLength: u16,
    #[doc = "< The PSA key ref (requires `mKey` to be NULL)."]
    pub mKeyRef: u32,
}
impl Default for otCryptoKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otCryptoContext\n\n This structure stores the context object for platform APIs.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCryptoContext {
    #[doc = "< Pointer to the context."]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< The length of the context in bytes."]
    pub mContextSize: u16,
}
impl Default for otCryptoContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otPlatCryptoSha256Hash\n\n This structure represents a SHA-256 hash.\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otPlatCryptoSha256Hash {
    #[doc = "< Hash bytes."]
    pub m8: [u8; 32usize],
}
#[doc = " @struct otPlatCryptoEcdsaKeyPair\n\n This structure represents an ECDSA key pair (public and private keys).\n\n The key pair is stored using Distinguished Encoding Rules (DER) format (per RFC 5915).\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otPlatCryptoEcdsaKeyPair {
    pub mDerBytes: [u8; 125usize],
    pub mDerLength: u8,
}
impl Default for otPlatCryptoEcdsaKeyPair {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otPlatCryptoEcdsaPublicKey\n\n This struct represents a ECDSA public key.\n\n The public key is stored as a byte sequence representation of an uncompressed curve point (RFC 6605 - sec 4).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct otPlatCryptoEcdsaPublicKey {
    pub m8: [u8; 64usize],
}
impl Default for otPlatCryptoEcdsaPublicKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otPlatCryptoEcdsaSignature\n\n This struct represents an ECDSA signature.\n\n The signature is encoded as the concatenated binary representation of two MPIs `r` and `s` which are calculated\n during signing (RFC 6605 - section 4).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct otPlatCryptoEcdsaSignature {
    pub m8: [u8; 64usize],
}
impl Default for otPlatCryptoEcdsaSignature {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Initialize the Crypto module.\n"]
    pub fn otPlatCryptoInit();
}
extern "C" {
    #[doc = " Import a key into PSA ITS.\n\n @param[in,out] aKeyRef           Pointer to the key ref to be used for crypto operations.\n @param[in]     aKeyType          Key Type encoding for the key.\n @param[in]     aKeyAlgorithm     Key algorithm encoding for the key.\n @param[in]     aKeyUsage         Key Usage encoding for the key (combinations of `OT_CRYPTO_KEY_USAGE_*`).\n @param[in]     aKeyPersistence   Key Persistence for this key\n @param[in]     aKey              Actual key to be imported.\n @param[in]     aKeyLen           Length of the key to be imported.\n\n @retval OT_ERROR_NONE          Successfully imported the key.\n @retval OT_ERROR_FAILED        Failed to import the key.\n @retval OT_ERROR_INVALID_ARGS  @p aKey was set to NULL.\n\n @note If OT_CRYPTO_KEY_STORAGE_PERSISTENT is passed for aKeyPersistence then @p aKeyRef is input and platform\n       should use the given aKeyRef and MUST not change it.\n\n       If OT_CRYPTO_KEY_STORAGE_VOLATILE is passed for aKeyPersistence then @p aKeyRef is output, the initial\n       value does not matter and platform API MUST update it to return the new key ref.\n\n       This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoImportKey(
        aKeyRef: *mut otCryptoKeyRef,
        aKeyType: otCryptoKeyType,
        aKeyAlgorithm: otCryptoKeyAlgorithm,
        aKeyUsage: ::std::os::raw::c_int,
        aKeyPersistence: otCryptoKeyStorage,
        aKey: *const u8,
        aKeyLen: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " Export a key stored in PSA ITS.\n\n @param[in]   aKeyRef           The key ref to be used for crypto operations.\n @param[out]  aBuffer           Pointer to the buffer where key needs to be exported.\n @param[in]   aBufferLen        Length of the buffer passed to store the exported key.\n @param[out]  aKeyLen           Pointer to return the length of the exported key.\n\n @retval OT_ERROR_NONE          Successfully exported  @p aKeyRef.\n @retval OT_ERROR_FAILED        Failed to export @p aKeyRef.\n @retval OT_ERROR_INVALID_ARGS  @p aBuffer was NULL\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoExportKey(
        aKeyRef: otCryptoKeyRef,
        aBuffer: *mut u8,
        aBufferLen: usize,
        aKeyLen: *mut usize,
    ) -> otError;
}
extern "C" {
    #[doc = " Destroy a key stored in PSA ITS.\n\n @param[in]   aKeyRef          The key ref to be destroyed\n\n @retval OT_ERROR_NONE          Successfully destroyed the key.\n @retval OT_ERROR_FAILED        Failed to destroy the key.\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoDestroyKey(aKeyRef: otCryptoKeyRef) -> otError;
}
extern "C" {
    #[doc = " Check if the key ref passed has an associated key in PSA ITS.\n\n @param[in]  aKeyRef          The Key Ref to check.\n\n @retval TRUE                 There is an associated key with @p aKeyRef.\n @retval FALSE                There is no associated key with @p aKeyRef.\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoHasKey(aKeyRef: otCryptoKeyRef) -> bool;
}
extern "C" {
    #[doc = " Initialize the HMAC operation.\n\n @param[in]  aContext          Context for HMAC operation.\n\n @retval OT_ERROR_NONE          Successfully initialized HMAC operation.\n @retval OT_ERROR_FAILED        Failed to initialize HMAC operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n\n @note The platform driver shall point the context to the correct object such as psa_mac_operation_t or\n       mbedtls_md_context_t.\n"]
    pub fn otPlatCryptoHmacSha256Init(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Uninitialize the HMAC operation.\n\n @param[in]  aContext          Context for HMAC operation.\n\n @retval OT_ERROR_NONE          Successfully uninitialized HMAC operation.\n @retval OT_ERROR_FAILED        Failed to uninitialized HMAC operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n"]
    pub fn otPlatCryptoHmacSha256Deinit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Start HMAC operation.\n\n @param[in]  aContext           Context for HMAC operation.\n @param[in]  aKey               Key material to be used for HMAC operation.\n\n @retval OT_ERROR_NONE          Successfully started HMAC operation.\n @retval OT_ERROR_FAILED        Failed to start HMAC operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey was NULL\n"]
    pub fn otPlatCryptoHmacSha256Start(
        aContext: *mut otCryptoContext,
        aKey: *const otCryptoKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Update the HMAC operation with new input.\n\n @param[in]  aContext           Context for HMAC operation.\n @param[in]  aBuf               A pointer to the input buffer.\n @param[in]  aBufLength         The length of @p aBuf in bytes.\n\n @retval OT_ERROR_NONE          Successfully updated HMAC with new input operation.\n @retval OT_ERROR_FAILED        Failed to update HMAC operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL\n"]
    pub fn otPlatCryptoHmacSha256Update(
        aContext: *mut otCryptoContext,
        aBuf: *const ::std::os::raw::c_void,
        aBufLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Complete the HMAC operation.\n\n @param[in]  aContext           Context for HMAC operation.\n @param[out] aBuf               A pointer to the output buffer.\n @param[in]  aBufLength         The length of @p aBuf in bytes.\n\n @retval OT_ERROR_NONE          Successfully completed HMAC operation.\n @retval OT_ERROR_FAILED        Failed to complete HMAC operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL\n"]
    pub fn otPlatCryptoHmacSha256Finish(
        aContext: *mut otCryptoContext,
        aBuf: *mut u8,
        aBufLength: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " Initialise the AES operation.\n\n @param[in]  aContext           Context for AES operation.\n\n @retval OT_ERROR_NONE          Successfully Initialised AES operation.\n @retval OT_ERROR_FAILED        Failed to Initialise AES operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n @retval OT_ERROR_NO_BUFS       Cannot allocate the context.\n\n @note The platform driver shall point the context to the correct object such as psa_key_id\n       or mbedtls_aes_context_t.\n"]
    pub fn otPlatCryptoAesInit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Set the key for AES operation.\n\n @param[in]  aContext           Context for AES operation.\n @param[out] aKey               Key to use for AES operation.\n\n @retval OT_ERROR_NONE          Successfully set the key for AES operation.\n @retval OT_ERROR_FAILED        Failed to set the key for AES operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey was NULL\n"]
    pub fn otPlatCryptoAesSetKey(
        aContext: *mut otCryptoContext,
        aKey: *const otCryptoKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Encrypt the given data.\n\n @param[in]  aContext           Context for AES operation.\n @param[in]  aInput             Pointer to the input buffer.\n @param[in]  aOutput            Pointer to the output buffer.\n\n @retval OT_ERROR_NONE          Successfully encrypted @p aInput.\n @retval OT_ERROR_FAILED        Failed to encrypt @p aInput.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aKey or @p aOutput were NULL\n"]
    pub fn otPlatCryptoAesEncrypt(
        aContext: *mut otCryptoContext,
        aInput: *const u8,
        aOutput: *mut u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Free the AES context.\n\n @param[in]  aContext           Context for AES operation.\n\n @retval OT_ERROR_NONE          Successfully freed AES context.\n @retval OT_ERROR_FAILED        Failed to free AES context.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n"]
    pub fn otPlatCryptoAesFree(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Initialise the HKDF context.\n\n @param[in]  aContext           Context for HKDF operation.\n\n @retval OT_ERROR_NONE          Successfully Initialised AES operation.\n @retval OT_ERROR_FAILED        Failed to Initialise AES operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n\n @note The platform driver shall point the context to the correct object such as psa_key_derivation_operation_t\n       or HmacSha256::Hash\n"]
    pub fn otPlatCryptoHkdfInit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Perform HKDF Expand step.\n\n @param[in]  aContext           Operation context for HKDF operation.\n @param[in]  aInfo              Pointer to the Info sequence.\n @param[in]  aInfoLength        Length of the Info sequence.\n @param[out] aOutputKey         Pointer to the output Key.\n @param[in]  aOutputKeyLength   Size of the output key buffer.\n\n @retval OT_ERROR_NONE          HKDF Expand was successful.\n @retval OT_ERROR_FAILED        HKDF Expand failed.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n"]
    pub fn otPlatCryptoHkdfExpand(
        aContext: *mut otCryptoContext,
        aInfo: *const u8,
        aInfoLength: u16,
        aOutputKey: *mut u8,
        aOutputKeyLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Perform HKDF Extract step.\n\n @param[in]  aContext           Operation context for HKDF operation.\n @param[in]  aSalt              Pointer to the Salt for HKDF.\n @param[in]  aSaltLength        Length of Salt.\n @param[in]  aInputKey          Pointer to the input key.\n\n @retval OT_ERROR_NONE          HKDF Extract was successful.\n @retval OT_ERROR_FAILED        HKDF Extract failed.\n"]
    pub fn otPlatCryptoHkdfExtract(
        aContext: *mut otCryptoContext,
        aSalt: *const u8,
        aSaltLength: u16,
        aInputKey: *const otCryptoKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Uninitialize the HKDF context.\n\n @param[in]  aContext           Context for HKDF operation.\n\n @retval OT_ERROR_NONE          Successfully un-initialised HKDF operation.\n @retval OT_ERROR_FAILED        Failed to un-initialised HKDF operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n"]
    pub fn otPlatCryptoHkdfDeinit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Initialise the SHA-256 operation.\n\n @param[in]  aContext           Context for SHA-256 operation.\n\n @retval OT_ERROR_NONE          Successfully initialised SHA-256 operation.\n @retval OT_ERROR_FAILED        Failed to initialise SHA-256 operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n\n\n @note The platform driver shall point the context to the correct object such as psa_hash_operation_t\n       or mbedtls_sha256_context."]
    pub fn otPlatCryptoSha256Init(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Uninitialize the SHA-256 operation.\n\n @param[in]  aContext           Context for SHA-256 operation.\n\n @retval OT_ERROR_NONE          Successfully un-initialised SHA-256 operation.\n @retval OT_ERROR_FAILED        Failed to un-initialised SHA-256 operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n"]
    pub fn otPlatCryptoSha256Deinit(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Start SHA-256 operation.\n\n @param[in]  aContext           Context for SHA-256 operation.\n\n @retval OT_ERROR_NONE          Successfully started SHA-256 operation.\n @retval OT_ERROR_FAILED        Failed to start SHA-256 operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext was NULL\n"]
    pub fn otPlatCryptoSha256Start(aContext: *mut otCryptoContext) -> otError;
}
extern "C" {
    #[doc = " Update SHA-256 operation with new input.\n\n @param[in]  aContext           Context for SHA-256 operation.\n @param[in]  aBuf               A pointer to the input buffer.\n @param[in]  aBufLength         The length of @p aBuf in bytes.\n\n @retval OT_ERROR_NONE          Successfully updated SHA-256 with new input operation.\n @retval OT_ERROR_FAILED        Failed to update SHA-256 operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aBuf was NULL\n"]
    pub fn otPlatCryptoSha256Update(
        aContext: *mut otCryptoContext,
        aBuf: *const ::std::os::raw::c_void,
        aBufLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Finish SHA-256 operation.\n\n @param[in]  aContext           Context for SHA-256 operation.\n @param[in]  aHash              A pointer to the output buffer, where hash needs to be stored.\n @param[in]  aHashSize          The length of @p aHash in bytes.\n\n @retval OT_ERROR_NONE          Successfully completed the SHA-256 operation.\n @retval OT_ERROR_FAILED        Failed to complete SHA-256 operation.\n @retval OT_ERROR_INVALID_ARGS  @p aContext or @p aHash was NULL\n"]
    pub fn otPlatCryptoSha256Finish(
        aContext: *mut otCryptoContext,
        aHash: *mut u8,
        aHashSize: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Initialize cryptographically-secure pseudorandom number generator (CSPRNG).\n"]
    pub fn otPlatCryptoRandomInit();
}
extern "C" {
    #[doc = " Deinitialize cryptographically-secure pseudorandom number generator (CSPRNG).\n"]
    pub fn otPlatCryptoRandomDeinit();
}
extern "C" {
    #[doc = " Fills a given buffer with cryptographically secure random bytes.\n\n @param[out] aBuffer            A pointer to a buffer to fill with the random bytes.\n @param[in]  aSize              Size of buffer (number of bytes to fill).\n\n @retval OT_ERROR_NONE          Successfully filled buffer with random values.\n @retval OT_ERROR_FAILED        Operation failed.\n"]
    pub fn otPlatCryptoRandomGet(aBuffer: *mut u8, aSize: u16) -> otError;
}
extern "C" {
    #[doc = " Generate and populate the output buffer with a new ECDSA key-pair.\n\n @param[out] aKeyPair           A pointer to an ECDSA key-pair structure to store the generated key-pair.\n\n @retval OT_ERROR_NONE          A new key-pair was generated successfully.\n @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for key generation.\n @retval OT_ERROR_NOT_CAPABLE   Feature not supported.\n @retval OT_ERROR_FAILED        Failed to generate key-pair.\n"]
    pub fn otPlatCryptoEcdsaGenerateKey(aKeyPair: *mut otPlatCryptoEcdsaKeyPair) -> otError;
}
extern "C" {
    #[doc = " Get the associated public key from the input context.\n\n @param[in]  aKeyPair           A pointer to an ECDSA key-pair structure where the key-pair is stored.\n @param[out] aPublicKey         A pointer to an ECDSA public key structure to store the public key.\n\n @retval OT_ERROR_NONE          Public key was retrieved successfully, and @p aBuffer is updated.\n @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format).\n @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL.\n"]
    pub fn otPlatCryptoEcdsaGetPublicKey(
        aKeyPair: *const otPlatCryptoEcdsaKeyPair,
        aPublicKey: *mut otPlatCryptoEcdsaPublicKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Calculate the ECDSA signature for a hashed message using the private key from the input context.\n\n This method uses the deterministic digital signature generation procedure from RFC 6979.\n\n @param[in]  aKeyPair           A pointer to an ECDSA key-pair structure where the key-pair is stored.\n @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature calculation\n                                is stored.\n @param[out] aSignature         A pointer to an ECDSA signature structure to output the calculated signature.\n\n @retval OT_ERROR_NONE          The signature was calculated successfully, @p aSignature was updated.\n @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format).\n @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature calculation.\n @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL.\n"]
    pub fn otPlatCryptoEcdsaSign(
        aKeyPair: *const otPlatCryptoEcdsaKeyPair,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *mut otPlatCryptoEcdsaSignature,
    ) -> otError;
}
extern "C" {
    #[doc = " Use the key from the input context to verify the ECDSA signature of a hashed message.\n\n @param[in]  aPublicKey         A pointer to an ECDSA public key structure where the public key for signature\n                                verification is stored.\n @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature verification\n                                is stored.\n @param[in]  aSignature         A pointer to an ECDSA signature structure where the signature value to be verified is\n                                stored.\n\n @retval OT_ERROR_NONE          The signature was verified successfully.\n @retval OT_ERROR_SECURITY      The signature is invalid.\n @retval OT_ERROR_INVALID_ARGS  The key or hash is invalid.\n @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature verification.\n"]
    pub fn otPlatCryptoEcdsaVerify(
        aPublicKey: *const otPlatCryptoEcdsaPublicKey,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *const otPlatCryptoEcdsaSignature,
    ) -> otError;
}
extern "C" {
    #[doc = " Calculate the ECDSA signature for a hashed message using the Key reference passed.\n\n This method uses the deterministic digital signature generation procedure from RFC 6979.\n\n @param[in]  aKeyRef            Key Reference to the slot where the key-pair is stored.\n @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature calculation\n                                is stored.\n @param[out] aSignature         A pointer to an ECDSA signature structure to output the calculated signature.\n\n @retval OT_ERROR_NONE          The signature was calculated successfully, @p aSignature was updated.\n @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format).\n @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature calculation.\n @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL.\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoEcdsaSignUsingKeyRef(
        aKeyRef: otCryptoKeyRef,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *mut otPlatCryptoEcdsaSignature,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the associated public key from the key reference passed.\n\n The public key is stored differently depending on the crypto backend library being used\n (OPENTHREAD_CONFIG_CRYPTO_LIB).\n\n This API must make sure to return the public key as a byte sequence representation of an\n uncompressed curve point (RFC 6605 - sec 4)\n\n @param[in]  aKeyRef            Key Reference to the slot where the key-pair is stored.\n @param[out] aPublicKey         A pointer to an ECDSA public key structure to store the public key.\n\n @retval OT_ERROR_NONE          Public key was retrieved successfully, and @p aBuffer is updated.\n @retval OT_ERROR_PARSE         The key-pair DER format could not be parsed (invalid format).\n @retval OT_ERROR_INVALID_ARGS  The @p aContext is NULL.\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoEcdsaExportPublicKey(
        aKeyRef: otCryptoKeyRef,
        aPublicKey: *mut otPlatCryptoEcdsaPublicKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Generate and import a new ECDSA key-pair at reference passed.\n\n @param[in]  aKeyRef            Key Reference to the slot where the key-pair is stored.\n\n @retval OT_ERROR_NONE          A new key-pair was generated successfully.\n @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for key generation.\n @retval OT_ERROR_NOT_CAPABLE   Feature not supported.\n @retval OT_ERROR_FAILED        Failed to generate key-pair.\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoEcdsaGenerateAndImportKey(aKeyRef: otCryptoKeyRef) -> otError;
}
extern "C" {
    #[doc = " Use the keyref to verify the ECDSA signature of a hashed message.\n\n @param[in]  aKeyRef            Key Reference to the slot where the key-pair is stored.\n @param[in]  aHash              A pointer to a SHA-256 hash structure where the hash value for signature verification\n                                is stored.\n @param[in]  aSignature         A pointer to an ECDSA signature structure where the signature value to be verified is\n                                stored.\n\n @retval OT_ERROR_NONE          The signature was verified successfully.\n @retval OT_ERROR_SECURITY      The signature is invalid.\n @retval OT_ERROR_INVALID_ARGS  The key or hash is invalid.\n @retval OT_ERROR_NO_BUFS       Failed to allocate buffer for signature verification.\n\n @note This API is only used by OT core when `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` is enabled.\n"]
    pub fn otPlatCryptoEcdsaVerifyUsingKeyRef(
        aKeyRef: otCryptoKeyRef,
        aHash: *const otPlatCryptoSha256Hash,
        aSignature: *const otPlatCryptoEcdsaSignature,
    ) -> otError;
}
extern "C" {
    #[doc = " Perform PKCS#5 PBKDF2 using CMAC (AES-CMAC-PRF-128).\n\n @param[in]     aPassword          Password to use when generating key.\n @param[in]     aPasswordLen       Length of password.\n @param[in]     aSalt              Salt to use when generating key.\n @param[in]     aSaltLen           Length of salt.\n @param[in]     aIterationCounter  Iteration count.\n @param[in]     aKeyLen            Length of generated key in bytes.\n @param[out]    aKey               A pointer to the generated key.\n"]
    pub fn otPlatCryptoPbkdf2GenerateKey(
        aPassword: *const u8,
        aPasswordLen: u16,
        aSalt: *const u8,
        aSaltLen: u16,
        aIterationCounter: u32,
        aKeyLen: u16,
        aKey: *mut u8,
    );
}
#[doc = "< aMaxPHYPacketSize (IEEE 802.15.4-2006)"]
pub const OT_RADIO_FRAME_MAX_SIZE: _bindgen_ty_3 = 127;
#[doc = "< Minimal size of frame FCS + CONTROL"]
pub const OT_RADIO_FRAME_MIN_SIZE: _bindgen_ty_3 = 3;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_SYMBOLS_PER_OCTET: _bindgen_ty_3 = 2;
#[doc = "< 2.4 GHz IEEE 802.15.4 (bits per second)"]
pub const OT_RADIO_BIT_RATE: _bindgen_ty_3 = 250000;
#[doc = "< Number of bits per octet"]
pub const OT_RADIO_BITS_PER_OCTET: _bindgen_ty_3 = 8;
#[doc = "< The O-QPSK PHY symbol rate when operating in the 780MHz, 915MHz, 2380MHz, 2450MHz"]
pub const OT_RADIO_SYMBOL_RATE: _bindgen_ty_3 = 62500;
#[doc = "< Symbol duration time in unit of microseconds"]
pub const OT_RADIO_SYMBOL_TIME: _bindgen_ty_3 = 16;
#[doc = "< Time for 10 symbols in unit of microseconds"]
pub const OT_RADIO_TEN_SYMBOLS_TIME: _bindgen_ty_3 = 160;
#[doc = "< LQI measurement not supported"]
pub const OT_RADIO_LQI_NONE: _bindgen_ty_3 = 0;
#[doc = "< Invalid or unknown RSSI value"]
pub const OT_RADIO_RSSI_INVALID: _bindgen_ty_3 = 127;
#[doc = "< Invalid or unknown power value"]
pub const OT_RADIO_POWER_INVALID: _bindgen_ty_3 = 127;
#[doc = " @defgroup radio-types Radio Types\n\n @brief\n   This module includes the platform abstraction for a radio frame.\n\n @{\n"]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_0: _bindgen_ty_4 = 0;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_0_MASK: _bindgen_ty_4 = 1;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_2: _bindgen_ty_4 = 2;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_CHANNEL_PAGE_2_MASK: _bindgen_ty_4 = 4;
#[doc = " This enumeration defines the channel page.\n"]
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MIN: _bindgen_ty_5 = 1;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MAX: _bindgen_ty_5 = 10;
#[doc = "< 915 MHz IEEE 802.15.4-2006"]
pub const OT_RADIO_915MHZ_OQPSK_CHANNEL_MASK: _bindgen_ty_5 = 2046;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MIN: _bindgen_ty_5 = 11;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MAX: _bindgen_ty_5 = 26;
#[doc = "< 2.4 GHz IEEE 802.15.4-2006"]
pub const OT_RADIO_2P4GHZ_OQPSK_CHANNEL_MASK: _bindgen_ty_5 = 134215680;
#[doc = " This enumeration defines the frequency band channel range.\n"]
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[doc = " This type represents radio capabilities.\n\n The value is a bit-field indicating the capabilities supported by the radio. See `OT_RADIO_CAPS_*` definitions.\n"]
pub type otRadioCaps = u8;
#[doc = "< Radio supports no capability."]
pub const OT_RADIO_CAPS_NONE: _bindgen_ty_6 = 0;
#[doc = "< Radio supports AckTime event."]
pub const OT_RADIO_CAPS_ACK_TIMEOUT: _bindgen_ty_6 = 1;
#[doc = "< Radio supports Energy Scans."]
pub const OT_RADIO_CAPS_ENERGY_SCAN: _bindgen_ty_6 = 2;
#[doc = "< Radio supports tx retry logic with collision avoidance (CSMA)."]
pub const OT_RADIO_CAPS_TRANSMIT_RETRIES: _bindgen_ty_6 = 4;
#[doc = "< Radio supports CSMA backoff for frame transmission (but no retry)."]
pub const OT_RADIO_CAPS_CSMA_BACKOFF: _bindgen_ty_6 = 8;
#[doc = "< Radio supports direct transition from sleep to TX with CSMA."]
pub const OT_RADIO_CAPS_SLEEP_TO_TX: _bindgen_ty_6 = 16;
#[doc = "< Radio supports tx security."]
pub const OT_RADIO_CAPS_TRANSMIT_SEC: _bindgen_ty_6 = 32;
#[doc = "< Radio supports tx at specific time."]
pub const OT_RADIO_CAPS_TRANSMIT_TIMING: _bindgen_ty_6 = 64;
#[doc = "< Radio supports rx at specific time."]
pub const OT_RADIO_CAPS_RECEIVE_TIMING: _bindgen_ty_6 = 128;
#[doc = " This enumeration defines constants that are used to indicate different radio capabilities. See `otRadioCaps`.\n"]
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[doc = " This type represents the IEEE 802.15.4 PAN ID.\n"]
pub type otPanId = u16;
#[doc = " This type represents the IEEE 802.15.4 Short Address.\n"]
pub type otShortAddress = u16;
#[doc = "< Size of IE header in bytes."]
pub const OT_IE_HEADER_SIZE: _bindgen_ty_7 = 2;
#[doc = "< Size of CSL IE content in bytes."]
pub const OT_CSL_IE_SIZE: _bindgen_ty_7 = 4;
#[doc = "< Max length for header IE in ACK."]
pub const OT_ACK_IE_MAX_SIZE: _bindgen_ty_7 = 16;
#[doc = "< Max length of Link Metrics data in Vendor-Specific IE."]
pub const OT_ENH_PROBING_IE_DATA_MAX_SIZE: _bindgen_ty_7 = 2;
#[doc = " This enumeration defines constants about size of header IE in ACK.\n"]
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[doc = " @struct otExtAddress\n\n This structure represents the IEEE 802.15.4 Extended Address.\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otExtAddress {
    #[doc = "< IEEE 802.15.4 Extended Address bytes"]
    pub m8: [u8; 8usize],
}
#[doc = " @struct otMacKey\n\n This structure represents a MAC Key.\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMacKey {
    #[doc = "< MAC Key bytes."]
    pub m8: [u8; 16usize],
}
#[doc = " This type represents a MAC Key Ref used by PSA.\n"]
pub type otMacKeyRef = otCryptoKeyRef;
#[doc = " @struct otMacKeyMaterial\n\n This structure represents a MAC Key.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMacKeyMaterial {
    pub mKeyMaterial: otMacKeyMaterial__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otMacKeyMaterial__bindgen_ty_1 {
    #[doc = "< Reference to the key stored."]
    pub mKeyRef: otMacKeyRef,
    #[doc = "< Key stored as literal."]
    pub mKey: otMacKey,
}
impl Default for otMacKeyMaterial__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otMacKeyMaterial {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Use Literal Keys."]
pub const OT_KEY_TYPE_LITERAL_KEY: otRadioKeyType = 0;
#[doc = "< Use Reference to Key."]
pub const OT_KEY_TYPE_KEY_REF: otRadioKeyType = 1;
#[doc = " This enumeration defines constants about key types.\n"]
pub type otRadioKeyType = ::std::os::raw::c_uint;
#[doc = " This structure represents the IEEE 802.15.4 Header IE (Information Element) related information of a radio frame."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otRadioIeInfo {
    #[doc = "< The time offset to the Thread network time."]
    pub mNetworkTimeOffset: i64,
    #[doc = "< The Time IE offset from the start of PSDU."]
    pub mTimeIeOffset: u8,
    #[doc = "< The Time sync sequence."]
    pub mTimeSyncSeq: u8,
}
#[doc = " This structure represents an IEEE 802.15.4 radio frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otRadioFrame {
    #[doc = "< The PSDU."]
    pub mPsdu: *mut u8,
    #[doc = "< Length of the PSDU."]
    pub mLength: u16,
    #[doc = "< Channel used to transmit/receive the frame."]
    pub mChannel: u8,
    #[doc = "< Radio link type - should be ignored by radio driver."]
    pub mRadioType: u8,
    pub mInfo: otRadioFrame__bindgen_ty_1,
}
#[doc = " The union of transmit and receive information for a radio frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union otRadioFrame__bindgen_ty_1 {
    pub mTxInfo: otRadioFrame__bindgen_ty_1__bindgen_ty_1,
    pub mRxInfo: otRadioFrame__bindgen_ty_1__bindgen_ty_2,
}
#[doc = " Structure representing radio frame transmit information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otRadioFrame__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The key material used for AES-CCM frame security."]
    pub mAesKey: *const otMacKeyMaterial,
    #[doc = "< The pointer to the Header IE(s) related information."]
    pub mIeInfo: *mut otRadioIeInfo,
    #[doc = "< The delay time for this transmission (based on `mTxDelayBaseTime`)."]
    pub mTxDelay: u32,
    #[doc = "< The base time for the transmission delay."]
    pub mTxDelayBaseTime: u32,
    #[doc = "< Maximum number of backoffs attempts before declaring CCA failure."]
    pub mMaxCsmaBackoffs: u8,
    #[doc = "< Maximum number of retries allowed after a transmission failure."]
    pub mMaxFrameRetries: u8,
    #[doc = " The RX channel after frame TX is done (after all frame retries - ack received, or timeout, or abort).\n\n Radio platforms can choose to fully ignore this. OT stack will make sure to call `otPlatRadioReceive()`\n with the desired RX channel after a frame TX is done and signaled in `otPlatRadioTxDone()` callback.\n Radio platforms that don't provide `OT_RADIO_CAPS_TRANSMIT_RETRIES` must always ignore this.\n\n This is intended for situations where there may be delay in interactions between OT stack and radio, as\n an example this is used in RCP/host architecture to make sure RCP switches to PAN channel more quickly.\n In particular, this can help with CSL tx to a sleepy child, where the child may use a different channel\n for CSL than the PAN channel. After frame tx, we want the radio/RCP to go back to the PAN channel\n quickly to ensure that parent does not miss tx from child afterwards, e.g., child responding to the\n earlier CSL transmitted frame from parent using PAN channel while radio still staying on CSL channel.\n\n The switch to the RX channel MUST happen after the frame TX is fully done, i.e., after all retries and\n when ack is received (when \"Ack Request\" flag is set on the TX frame) or ack timeout. Note that ack is\n expected on the same channel that frame is sent on.\n"]
    pub mRxChannelAfterTxDone: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u32,
}
impl Default for otRadioFrame__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otRadioFrame__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn mIsHeaderUpdated(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsHeaderUpdated(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsARetx(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsARetx(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mCsmaCaEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCsmaCaEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mCslPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCslPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSecurityProcessed(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSecurityProcessed(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsHeaderUpdated: bool,
        mIsARetx: bool,
        mCsmaCaEnabled: bool,
        mCslPresent: bool,
        mIsSecurityProcessed: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsHeaderUpdated: u8 = unsafe { ::std::mem::transmute(mIsHeaderUpdated) };
            mIsHeaderUpdated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsARetx: u8 = unsafe { ::std::mem::transmute(mIsARetx) };
            mIsARetx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mCsmaCaEnabled: u8 = unsafe { ::std::mem::transmute(mCsmaCaEnabled) };
            mCsmaCaEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mCslPresent: u8 = unsafe { ::std::mem::transmute(mCslPresent) };
            mCslPresent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsSecurityProcessed: u8 = unsafe { ::std::mem::transmute(mIsSecurityProcessed) };
            mIsSecurityProcessed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Structure representing radio frame receive information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otRadioFrame__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " The timestamp when the frame was received in microseconds.\n\n The value SHALL be the time when the SFD was received.\n"]
    pub mTimestamp: u64,
    #[doc = "< ACK security frame counter (applicable when `mAckedWithSecEnhAck` is set)."]
    pub mAckFrameCounter: u32,
    #[doc = "< ACK security key index (applicable when `mAckedWithSecEnhAck` is set)."]
    pub mAckKeyId: u8,
    #[doc = "< Received signal strength indicator in dBm for received frames."]
    pub mRssi: i8,
    #[doc = "< Link Quality Indicator for received frames."]
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otRadioFrame__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn mAckedWithFramePending(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAckedWithFramePending(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAckedWithSecEnhAck(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAckedWithSecEnhAck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mAckedWithFramePending: bool,
        mAckedWithSecEnhAck: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mAckedWithFramePending: u8 =
                unsafe { ::std::mem::transmute(mAckedWithFramePending) };
            mAckedWithFramePending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mAckedWithSecEnhAck: u8 = unsafe { ::std::mem::transmute(mAckedWithSecEnhAck) };
            mAckedWithSecEnhAck as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for otRadioFrame__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otRadioFrame {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const OT_RADIO_STATE_DISABLED: otRadioState = 0;
pub const OT_RADIO_STATE_SLEEP: otRadioState = 1;
pub const OT_RADIO_STATE_RECEIVE: otRadioState = 2;
pub const OT_RADIO_STATE_TRANSMIT: otRadioState = 3;
pub const OT_RADIO_STATE_INVALID: otRadioState = 255;
#[doc = " This structure represents the state of a radio.\n Initially, a radio is in the Disabled state."]
pub type otRadioState = ::std::os::raw::c_uint;
#[doc = " This structure represents radio coexistence metrics."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otRadioCoexMetrics {
    #[doc = "< Number of grant glitches."]
    pub mNumGrantGlitch: u32,
    #[doc = "< Number of tx requests."]
    pub mNumTxRequest: u32,
    #[doc = "< Number of tx requests while grant was active."]
    pub mNumTxGrantImmediate: u32,
    #[doc = "< Number of tx requests while grant was inactive."]
    pub mNumTxGrantWait: u32,
    #[doc = "< Number of tx requests while grant was inactive that were ultimately granted."]
    pub mNumTxGrantWaitActivated: u32,
    #[doc = "< Number of tx requests while grant was inactive that timed out."]
    pub mNumTxGrantWaitTimeout: u32,
    #[doc = "< Number of tx that were in progress when grant was deactivated."]
    pub mNumTxGrantDeactivatedDuringRequest: u32,
    #[doc = "< Number of tx requests that were not granted within 50us."]
    pub mNumTxDelayedGrant: u32,
    #[doc = "< Average time in usec from tx request to grant."]
    pub mAvgTxRequestToGrantTime: u32,
    #[doc = "< Number of rx requests."]
    pub mNumRxRequest: u32,
    #[doc = "< Number of rx requests while grant was active."]
    pub mNumRxGrantImmediate: u32,
    #[doc = "< Number of rx requests while grant was inactive."]
    pub mNumRxGrantWait: u32,
    #[doc = "< Number of rx requests while grant was inactive that were ultimately granted."]
    pub mNumRxGrantWaitActivated: u32,
    #[doc = "< Number of rx requests while grant was inactive that timed out."]
    pub mNumRxGrantWaitTimeout: u32,
    #[doc = "< Number of rx that were in progress when grant was deactivated."]
    pub mNumRxGrantDeactivatedDuringRequest: u32,
    #[doc = "< Number of rx requests that were not granted within 50us."]
    pub mNumRxDelayedGrant: u32,
    #[doc = "< Average time in usec from rx request to grant."]
    pub mAvgRxRequestToGrantTime: u32,
    #[doc = "< Number of rx requests that completed without receiving grant."]
    pub mNumRxGrantNone: u32,
    #[doc = "< Stats collection stopped due to saturation."]
    pub mStopped: bool,
}
#[doc = " This structure represents what metrics are specified to query.\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otLinkMetrics {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otLinkMetrics {
    #[inline]
    pub fn mPduCount(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPduCount(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mLqi(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLqi(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mLinkMargin(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkMargin(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mRssi(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRssi(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mReserved(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mReserved(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPduCount: bool,
        mLqi: bool,
        mLinkMargin: bool,
        mRssi: bool,
        mReserved: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mPduCount: u8 = unsafe { ::std::mem::transmute(mPduCount) };
            mPduCount as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mLqi: u8 = unsafe { ::std::mem::transmute(mLqi) };
            mLqi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mLinkMargin: u8 = unsafe { ::std::mem::transmute(mLinkMargin) };
            mLinkMargin as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mRssi: u8 = unsafe { ::std::mem::transmute(mRssi) };
            mRssi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mReserved: u8 = unsafe { ::std::mem::transmute(mReserved) };
            mReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Get the radio capabilities.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns The radio capability bit vector (see `OT_RADIO_CAP_*` definitions).\n"]
    pub fn otPlatRadioGetCaps(aInstance: *mut otInstance) -> otRadioCaps;
}
extern "C" {
    #[doc = " Get the radio version string.\n\n This is an optional radio driver platform function. If not provided by platform radio driver, OpenThread uses\n the OpenThread version instead (@sa otGetVersionString()).\n\n @param[in]  aInstance   The OpenThread instance structure.\n\n @returns A pointer to the OpenThread radio version.\n"]
    pub fn otPlatRadioGetVersionString(aInstance: *mut otInstance)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the radio receive sensitivity value.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns The radio receive sensitivity value in dBm.\n"]
    pub fn otPlatRadioGetReceiveSensitivity(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Gets the factory-assigned IEEE EUI-64 for this interface.\n\n @param[in]  aInstance   The OpenThread instance structure.\n @param[out] aIeeeEui64  A pointer to the factory-assigned IEEE EUI-64.\n"]
    pub fn otPlatRadioGetIeeeEui64(aInstance: *mut otInstance, aIeeeEui64: *mut u8);
}
extern "C" {
    #[doc = " Set the PAN ID for address filtering.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aPanId     The IEEE 802.15.4 PAN ID.\n"]
    pub fn otPlatRadioSetPanId(aInstance: *mut otInstance, aPanId: otPanId);
}
extern "C" {
    #[doc = " Set the Extended Address for address filtering.\n\n @param[in] aInstance    The OpenThread instance structure.\n @param[in] aExtAddress  A pointer to the IEEE 802.15.4 Extended Address stored in little-endian byte order.\n\n"]
    pub fn otPlatRadioSetExtendedAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    );
}
extern "C" {
    #[doc = " Set the Short Address for address filtering.\n\n @param[in] aInstance      The OpenThread instance structure.\n @param[in] aShortAddress  The IEEE 802.15.4 Short Address.\n"]
    pub fn otPlatRadioSetShortAddress(aInstance: *mut otInstance, aShortAddress: otShortAddress);
}
extern "C" {
    #[doc = " Get the radio's transmit power in dBm.\n\n @note The transmit power returned will be no larger than the power specified in the max power table for\n the current channel.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[out] aPower    The transmit power in dBm.\n\n @retval OT_ERROR_NONE             Successfully retrieved the transmit power.\n @retval OT_ERROR_INVALID_ARGS     @p aPower was NULL.\n @retval OT_ERROR_NOT_IMPLEMENTED  Transmit power configuration via dBm is not implemented.\n"]
    pub fn otPlatRadioGetTransmitPower(aInstance: *mut otInstance, aPower: *mut i8) -> otError;
}
extern "C" {
    #[doc = " Set the radio's transmit power in dBm.\n\n @note The real transmit power will be no larger than the power specified in the max power table for\n the current channel.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aPower     The transmit power in dBm.\n\n @retval OT_ERROR_NONE             Successfully set the transmit power.\n @retval OT_ERROR_NOT_IMPLEMENTED  Transmit power configuration via dBm is not implemented.\n"]
    pub fn otPlatRadioSetTransmitPower(aInstance: *mut otInstance, aPower: i8) -> otError;
}
extern "C" {
    #[doc = " Get the radio's CCA ED threshold in dBm measured at antenna connector per IEEE 802.15.4 - 2015 section 10.1.4.\n\n @param[in] aInstance    The OpenThread instance structure.\n @param[out] aThreshold  The CCA ED threshold in dBm.\n\n @retval OT_ERROR_NONE             Successfully retrieved the CCA ED threshold.\n @retval OT_ERROR_INVALID_ARGS     @p aThreshold was NULL.\n @retval OT_ERROR_NOT_IMPLEMENTED  CCA ED threshold configuration via dBm is not implemented.\n"]
    pub fn otPlatRadioGetCcaEnergyDetectThreshold(
        aInstance: *mut otInstance,
        aThreshold: *mut i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Set the radio's CCA ED threshold in dBm measured at antenna connector per IEEE 802.15.4 - 2015 section 10.1.4.\n\n @param[in] aInstance   The OpenThread instance structure.\n @param[in] aThreshold  The CCA ED threshold in dBm.\n\n @retval OT_ERROR_NONE             Successfully set the transmit power.\n @retval OT_ERROR_INVALID_ARGS     Given threshold is out of range.\n @retval OT_ERROR_NOT_IMPLEMENTED  CCA ED threshold configuration via dBm is not implemented.\n"]
    pub fn otPlatRadioSetCcaEnergyDetectThreshold(
        aInstance: *mut otInstance,
        aThreshold: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the external FEM's Rx LNA gain in dBm.\n\n @param[in]  aInstance  The OpenThread instance structure.\n @param[out] aGain     The external FEM's Rx LNA gain in dBm.\n\n @retval OT_ERROR_NONE             Successfully retrieved the external FEM's LNA gain.\n @retval OT_ERROR_INVALID_ARGS     @p aGain was NULL.\n @retval OT_ERROR_NOT_IMPLEMENTED  External FEM's LNA setting is not implemented.\n"]
    pub fn otPlatRadioGetFemLnaGain(aInstance: *mut otInstance, aGain: *mut i8) -> otError;
}
extern "C" {
    #[doc = " Sets the external FEM's Rx LNA gain in dBm.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aGain      The external FEM's Rx LNA gain in dBm.\n\n @retval OT_ERROR_NONE             Successfully set the external FEM's LNA gain.\n @retval OT_ERROR_NOT_IMPLEMENTED  External FEM's LNA gain setting is not implemented.\n"]
    pub fn otPlatRadioSetFemLnaGain(aInstance: *mut otInstance, aGain: i8) -> otError;
}
extern "C" {
    #[doc = " Get the status of promiscuous mode.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @retval TRUE   Promiscuous mode is enabled.\n @retval FALSE  Promiscuous mode is disabled.\n"]
    pub fn otPlatRadioGetPromiscuous(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Enable or disable promiscuous mode.\n\n @param[in]  aInstance The OpenThread instance structure.\n @param[in]  aEnable   TRUE to enable or FALSE to disable promiscuous mode.\n"]
    pub fn otPlatRadioSetPromiscuous(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " Update MAC keys and key index\n\n This function is used when radio provides OT_RADIO_CAPS_TRANSMIT_SEC capability.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[in]   aKeyIdMode   The key ID mode.\n @param[in]   aKeyId       Current MAC key index.\n @param[in]   aPrevKey     A pointer to the previous MAC key.\n @param[in]   aCurrKey     A pointer to the current MAC key.\n @param[in]   aNextKey     A pointer to the next MAC key.\n @param[in]   aKeyType     Key Type used.\n"]
    pub fn otPlatRadioSetMacKey(
        aInstance: *mut otInstance,
        aKeyIdMode: u8,
        aKeyId: u8,
        aPrevKey: *const otMacKeyMaterial,
        aCurrKey: *const otMacKeyMaterial,
        aNextKey: *const otMacKeyMaterial,
        aKeyType: otRadioKeyType,
    );
}
extern "C" {
    #[doc = " This method sets the current MAC frame counter value.\n\n This function is used when radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability.\n\n @param[in]   aInstance         A pointer to an OpenThread instance.\n @param[in]   aMacFrameCounter  The MAC frame counter value.\n"]
    pub fn otPlatRadioSetMacFrameCounter(aInstance: *mut otInstance, aMacFrameCounter: u32);
}
extern "C" {
    #[doc = " This method sets the current MAC frame counter value only if the new given value is larger than the current value.\n\n This function is used when radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability.\n\n @param[in]   aInstance         A pointer to an OpenThread instance.\n @param[in]   aMacFrameCounter  The MAC frame counter value.\n"]
    pub fn otPlatRadioSetMacFrameCounterIfLarger(aInstance: *mut otInstance, aMacFrameCounter: u32);
}
extern "C" {
    #[doc = " Get the current estimated time (in microseconds) of the radio chip.\n\n This microsecond timer must be a free-running timer. The timer must continue to advance with microsecond precision\n even when the radio is in the sleep state.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n\n @returns The current time in microseconds. UINT64_MAX when platform does not support or radio time is not ready.\n"]
    pub fn otPlatRadioGetNow(aInstance: *mut otInstance) -> u64;
}
extern "C" {
    #[doc = " Get the bus speed in bits/second between the host and the radio chip.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n\n @returns The bus speed in bits/second between the host and the radio chip.\n          Return 0 when the MAC and above layer and Radio layer resides on the same chip.\n"]
    pub fn otPlatRadioGetBusSpeed(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Get current state of the radio.\n\n This function is not required by OpenThread. It may be used for debugging and/or application-specific purposes.\n\n @note This function may be not implemented. It does not affect OpenThread.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @return  Current state of the radio.\n"]
    pub fn otPlatRadioGetState(aInstance: *mut otInstance) -> otRadioState;
}
extern "C" {
    #[doc = " Enable the radio.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @retval OT_ERROR_NONE     Successfully enabled.\n @retval OT_ERROR_FAILED   The radio could not be enabled.\n"]
    pub fn otPlatRadioEnable(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Disable the radio.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @retval OT_ERROR_NONE            Successfully transitioned to Disabled.\n @retval OT_ERROR_INVALID_STATE   The radio was not in sleep state.\n"]
    pub fn otPlatRadioDisable(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Check whether radio is enabled or not.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns TRUE if the radio is enabled, FALSE otherwise.\n"]
    pub fn otPlatRadioIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Transition the radio from Receive to Sleep (turn off the radio).\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @retval OT_ERROR_NONE          Successfully transitioned to Sleep.\n @retval OT_ERROR_BUSY          The radio was transmitting.\n @retval OT_ERROR_INVALID_STATE The radio was disabled.\n"]
    pub fn otPlatRadioSleep(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Transition the radio from Sleep to Receive (turn on the radio).\n\n @param[in]  aInstance  The OpenThread instance structure.\n @param[in]  aChannel   The channel to use for receiving.\n\n @retval OT_ERROR_NONE          Successfully transitioned to Receive.\n @retval OT_ERROR_INVALID_STATE The radio was disabled or transmitting.\n"]
    pub fn otPlatRadioReceive(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
extern "C" {
    #[doc = " Schedule a radio reception window at a specific time and duration.\n\n @param[in]  aChannel   The radio channel on which to receive.\n @param[in]  aStart     The receive window start time, in microseconds.\n @param[in]  aDuration  The receive window duration, in microseconds\n\n @retval OT_ERROR_NONE    Successfully scheduled receive window.\n @retval OT_ERROR_FAILED  The receive window could not be scheduled."]
    pub fn otPlatRadioReceiveAt(
        aInstance: *mut otInstance,
        aChannel: u8,
        aStart: u32,
        aDuration: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread of a received frame.\n\n @param[in]  aInstance The OpenThread instance structure.\n @param[in]  aFrame    A pointer to the received frame or NULL if the receive operation failed.\n @param[in]  aError    OT_ERROR_NONE when successfully received a frame,\n                       OT_ERROR_ABORT when reception was aborted and a frame was not received,\n                       OT_ERROR_NO_BUFS when a frame could not be received due to lack of rx buffer space.\n"]
    pub fn otPlatRadioReceiveDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread diagnostics module of a received frame.\n\n This function is used when diagnostics is enabled.\n\n @param[in]  aInstance The OpenThread instance structure.\n @param[in]  aFrame    A pointer to the received frame or NULL if the receive operation failed.\n @param[in]  aError    OT_ERROR_NONE when successfully received a frame,\n                       OT_ERROR_ABORT when reception was aborted and a frame was not received,\n                       OT_ERROR_NO_BUFS when a frame could not be received due to lack of rx buffer space.\n"]
    pub fn otPlatDiagRadioReceiveDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " Get the radio transmit frame buffer.\n\n OpenThread forms the IEEE 802.15.4 frame in this buffer then calls `otPlatRadioTransmit()` to request transmission.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns A pointer to the transmit frame buffer.\n"]
    pub fn otPlatRadioGetTransmitBuffer(aInstance: *mut otInstance) -> *mut otRadioFrame;
}
extern "C" {
    #[doc = " Begin the transmit sequence on the radio.\n\n The caller must form the IEEE 802.15.4 frame in the buffer provided by `otPlatRadioGetTransmitBuffer()` before\n requesting transmission.  The channel and transmit power are also included in the otRadioFrame structure.\n\n The transmit sequence consists of:\n 1. Transitioning the radio to Transmit from one of the following states:\n    - Receive if RX is on when the device is idle or OT_RADIO_CAPS_SLEEP_TO_TX is not supported\n    - Sleep if RX is off when the device is idle and OT_RADIO_CAPS_SLEEP_TO_TX is supported.\n 2. Transmits the psdu on the given channel and at the given transmit power.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aFrame     A pointer to the frame to be transmitted.\n\n @retval OT_ERROR_NONE          Successfully transitioned to Transmit.\n @retval OT_ERROR_INVALID_STATE The radio was not in the Receive state.\n"]
    pub fn otPlatRadioTransmit(aInstance: *mut otInstance, aFrame: *mut otRadioFrame) -> otError;
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread that the transmission has started.\n\n @note  This function should be called by the same thread that executes all of the other OpenThread code. It should\n        not be called by ISR or any other task.\n\n @param[in]  aInstance  A pointer to the OpenThread instance structure.\n @param[in]  aFrame     A pointer to the frame that is being transmitted.\n"]
    pub fn otPlatRadioTxStarted(aInstance: *mut otInstance, aFrame: *mut otRadioFrame);
}
extern "C" {
    #[doc = " The radio driver calls this function to notify OpenThread that the transmit operation has completed,\n providing both the transmitted frame and, if applicable, the received ack frame.\n\n When radio provides `OT_RADIO_CAPS_TRANSMIT_SEC` capability, radio platform layer updates @p aFrame\n with the security frame counter and key index values maintained by the radio.\n\n @param[in]  aInstance  The OpenThread instance structure.\n @param[in]  aFrame     A pointer to the frame that was transmitted.\n @param[in]  aAckFrame  A pointer to the ACK frame, NULL if no ACK was received.\n @param[in]  aError     OT_ERROR_NONE when the frame was transmitted,\n                        OT_ERROR_NO_ACK when the frame was transmitted but no ACK was received,\n                        OT_ERROR_CHANNEL_ACCESS_FAILURE tx could not take place due to activity on the channel,\n                        OT_ERROR_ABORT when transmission was aborted for other reasons.\n"]
    pub fn otPlatRadioTxDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aAckFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread diagnostics module that the transmission has completed.\n\n This function is used when diagnostics is enabled.\n\n @param[in]  aInstance      The OpenThread instance structure.\n @param[in]  aFrame         A pointer to the frame that was transmitted.\n @param[in]  aError         OT_ERROR_NONE when the frame was transmitted,\n                            OT_ERROR_CHANNEL_ACCESS_FAILURE tx could not take place due to activity on the channel,\n                            OT_ERROR_ABORT when transmission was aborted for other reasons.\n"]
    pub fn otPlatDiagRadioTransmitDone(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " Get the most recent RSSI measurement.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns The RSSI in dBm when it is valid.  127 when RSSI is invalid.\n"]
    pub fn otPlatRadioGetRssi(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Begin the energy scan sequence on the radio.\n\n This function is used when radio provides OT_RADIO_CAPS_ENERGY_SCAN capability.\n\n @param[in] aInstance      The OpenThread instance structure.\n @param[in] aScanChannel   The channel to perform the energy scan on.\n @param[in] aScanDuration  The duration, in milliseconds, for the channel to be scanned.\n\n @retval OT_ERROR_NONE             Successfully started scanning the channel.\n @retval OT_ERROR_BUSY             The radio is performing energy scanning.\n @retval OT_ERROR_NOT_IMPLEMENTED  The radio doesn't support energy scanning.\n"]
    pub fn otPlatRadioEnergyScan(
        aInstance: *mut otInstance,
        aScanChannel: u8,
        aScanDuration: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " The radio driver calls this method to notify OpenThread that the energy scan is complete.\n\n This function is used when radio provides OT_RADIO_CAPS_ENERGY_SCAN capability.\n\n @param[in]  aInstance           The OpenThread instance structure.\n @param[in]  aEnergyScanMaxRssi  The maximum RSSI encountered on the scanned channel.\n"]
    pub fn otPlatRadioEnergyScanDone(aInstance: *mut otInstance, aEnergyScanMaxRssi: i8);
}
extern "C" {
    #[doc = " Enable/Disable source address match feature.\n\n The source address match feature controls how the radio layer decides the \"frame pending\" bit for acks sent in\n response to data request commands from children.\n\n If disabled, the radio layer must set the \"frame pending\" on all acks to data request commands.\n\n If enabled, the radio layer uses the source address match table to determine whether to set or clear the \"frame\n pending\" bit in an ack to a data request command.\n\n The source address match table provides the list of children for which there is a pending frame. Either a short\n address or an extended/long address can be added to the source address match table.\n\n @param[in]  aInstance   The OpenThread instance structure.\n @param[in]  aEnable     Enable/disable source address match feature.\n"]
    pub fn otPlatRadioEnableSrcMatch(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " Add a short address to the source address match table.\n\n @param[in]  aInstance      The OpenThread instance structure.\n @param[in]  aShortAddress  The short address to be added.\n\n @retval OT_ERROR_NONE      Successfully added short address to the source match table.\n @retval OT_ERROR_NO_BUFS   No available entry in the source match table.\n"]
    pub fn otPlatRadioAddSrcMatchShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: otShortAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Add an extended address to the source address match table.\n\n @param[in]  aInstance    The OpenThread instance structure.\n @param[in]  aExtAddress  The extended address to be added stored in little-endian byte order.\n\n @retval OT_ERROR_NONE      Successfully added extended address to the source match table.\n @retval OT_ERROR_NO_BUFS   No available entry in the source match table.\n"]
    pub fn otPlatRadioAddSrcMatchExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove a short address from the source address match table.\n\n @param[in]  aInstance      The OpenThread instance structure.\n @param[in]  aShortAddress  The short address to be removed.\n\n @retval OT_ERROR_NONE        Successfully removed short address from the source match table.\n @retval OT_ERROR_NO_ADDRESS  The short address is not in source address match table.\n"]
    pub fn otPlatRadioClearSrcMatchShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: otShortAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove an extended address from the source address match table.\n\n @param[in]  aInstance    The OpenThread instance structure.\n @param[in]  aExtAddress  The extended address to be removed stored in little-endian byte order.\n\n @retval OT_ERROR_NONE        Successfully removed the extended address from the source match table.\n @retval OT_ERROR_NO_ADDRESS  The extended address is not in source address match table.\n"]
    pub fn otPlatRadioClearSrcMatchExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Clear all short addresses from the source address match table.\n\n @param[in]  aInstance   The OpenThread instance structure.\n"]
    pub fn otPlatRadioClearSrcMatchShortEntries(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Clear all the extended/long addresses from source address match table.\n\n @param[in]  aInstance   The OpenThread instance structure.\n"]
    pub fn otPlatRadioClearSrcMatchExtEntries(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the radio supported channel mask that the device is allowed to be on.\n\n @param[in]  aInstance   The OpenThread instance structure.\n\n @returns The radio supported channel mask.\n"]
    pub fn otPlatRadioGetSupportedChannelMask(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Gets the radio preferred channel mask that the device prefers to form on.\n\n @param[in]  aInstance   The OpenThread instance structure.\n\n @returns The radio preferred channel mask.\n"]
    pub fn otPlatRadioGetPreferredChannelMask(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Enable the radio coex.\n\n This function is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aEnabled   TRUE to enable the radio coex, FALSE otherwise.\n\n @retval OT_ERROR_NONE     Successfully enabled.\n @retval OT_ERROR_FAILED   The radio coex could not be enabled.\n"]
    pub fn otPlatRadioSetCoexEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " Check whether radio coex is enabled or not.\n\n This function is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns TRUE if the radio coex is enabled, FALSE otherwise.\n"]
    pub fn otPlatRadioIsCoexEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get the radio coexistence metrics.\n\n This function is used when feature OPENTHREAD_CONFIG_PLATFORM_RADIO_COEX_ENABLE is enabled.\n\n @param[in]  aInstance     The OpenThread instance structure.\n @param[out] aCoexMetrics  A pointer to the coexistence metrics structure.\n\n @retval OT_ERROR_NONE          Successfully retrieved the coex metrics.\n @retval OT_ERROR_INVALID_ARGS  @p aCoexMetrics was NULL."]
    pub fn otPlatRadioGetCoexMetrics(
        aInstance: *mut otInstance,
        aCoexMetrics: *mut otRadioCoexMetrics,
    ) -> otError;
}
extern "C" {
    #[doc = " Enable or disable CSL receiver.\n\n @param[in]  aInstance     The OpenThread instance structure.\n @param[in]  aCslPeriod    CSL period, 0 for disabling CSL.\n @param[in]  aShortAddr    The short source address of CSL receiver's peer.\n @param[in]  aExtAddr      The extended source address of CSL receiver's peer.\n\n @note Platforms should use CSL peer addresses to include CSL IE when generating enhanced acks.\n\n @retval  kErrorNotImplemented Radio driver doesn't support CSL.\n @retval  kErrorFailed         Other platform specific errors.\n @retval  kErrorNone           Successfully enabled or disabled CSL.\n"]
    pub fn otPlatRadioEnableCsl(
        aInstance: *mut otInstance,
        aCslPeriod: u32,
        aShortAddr: otShortAddress,
        aExtAddr: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Update CSL sample time in radio driver.\n\n Sample time is stored in radio driver as a copy to calculate phase when sending ACK with CSL IE.\n\n @param[in]  aInstance         The OpenThread instance structure.\n @param[in]  aCslSampleTime    The latest sample time.\n"]
    pub fn otPlatRadioUpdateCslSampleTime(aInstance: *mut otInstance, aCslSampleTime: u32);
}
extern "C" {
    #[doc = " Get the current accuracy, in units of ± ppm, of the clock used for scheduling CSL operations.\n\n @note Platforms may optimize this value based on operational conditions (i.e.: temperature).\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n\n @returns The current CSL rx/tx scheduling drift, in units of ± ppm.\n"]
    pub fn otPlatRadioGetCslAccuracy(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " The fixed uncertainty of the Device for scheduling CSL Transmissions in units of 10 microseconds.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n\n @returns The CSL Uncertainty in units of 10 us.\n"]
    pub fn otPlatRadioGetCslUncertainty(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the max transmit power for a specific channel.\n\n @param[in]  aInstance    The OpenThread instance structure.\n @param[in]  aChannel     The radio channel.\n @param[in]  aMaxPower    The max power in dBm, passing OT_RADIO_RSSI_INVALID will disable this channel.\n\n @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented\n @retval  OT_ERROR_INVALID_ARGS     The specified channel is not valid.\n @retval  OT_ERROR_FAILED           Other platform specific errors.\n @retval  OT_ERROR_NONE             Successfully set max transmit power.\n"]
    pub fn otPlatRadioSetChannelMaxTransmitPower(
        aInstance: *mut otInstance,
        aChannel: u8,
        aMaxPower: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Set the region code.\n\n The radio region format is the 2-bytes ascii representation of the\n ISO 3166 alpha-2 code.\n\n @param[in]  aInstance    The OpenThread instance structure.\n @param[in]  aRegionCode  The radio region.\n\n @retval  OT_ERROR_FAILED           Other platform specific errors.\n @retval  OT_ERROR_NONE             Successfully set region code.\n @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.\n"]
    pub fn otPlatRadioSetRegion(aInstance: *mut otInstance, aRegionCode: u16) -> otError;
}
extern "C" {
    #[doc = " Get the region code.\n\n The radio region format is the 2-bytes ascii representation of the\n ISO 3166 alpha-2 code.\n\n @param[in]  aInstance    The OpenThread instance structure.\n @param[out] aRegionCode  The radio region.\n\n @retval  OT_ERROR_INVALID_ARGS     @p aRegionCode is nullptr.\n @retval  OT_ERROR_FAILED           Other platform specific errors.\n @retval  OT_ERROR_NONE             Successfully got region code.\n @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.\n"]
    pub fn otPlatRadioGetRegion(aInstance: *mut otInstance, aRegionCode: *mut u16) -> otError;
}
extern "C" {
    #[doc = " Enable/disable or update Enhanced-ACK Based Probing in radio for a specific Initiator.\n\n After Enhanced-ACK Based Probing is configured by a specific Probing Initiator, the Enhanced-ACK sent to that\n node should include Vendor-Specific IE containing Link Metrics data. This method informs the radio to start/stop to\n collect Link Metrics data and include Vendor-Specific IE that containing the data in Enhanced-ACK sent to that\n Probing Initiator.\n\n @param[in]  aInstance     The OpenThread instance structure.\n @param[in]  aLinkMetrics  This parameter specifies what metrics to query. Per spec 4.11.3.4.4.6, at most 2 metrics\n                           can be specified. The probing would be disabled if @p `aLinkMetrics` is bitwise 0.\n @param[in]  aShortAddress The short address of the Probing Initiator.\n @param[in]  aExtAddress   The extended source address of the Probing Initiator. @p aExtAddr MUST NOT be `NULL`.\n\n @retval  OT_ERROR_NONE            Successfully configured the Enhanced-ACK Based Probing.\n @retval  OT_ERROR_INVALID_ARGS    @p aExtAddress is `NULL`.\n @retval  OT_ERROR_NOT_FOUND       The Initiator indicated by @p aShortAddress is not found when trying to clear.\n @retval  OT_ERROR_NO_BUFS         No more Initiator can be supported.\n @retval  OT_ERROR_NOT_IMPLEMENTED The feature is not implemented.\n"]
    pub fn otPlatRadioConfigureEnhAckProbing(
        aInstance: *mut otInstance,
        aLinkMetrics: otLinkMetrics,
        aShortAddress: otShortAddress,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Add a calibrated power of the specified channel to the power calibration table.\n\n @note This API is an optional radio platform API. It's up to the platform layer to implement it.\n\n The @p aActualPower is the actual measured output power when the parameters of the radio hardware modules\n are set to the @p aRawPowerSetting.\n\n The raw power setting is an opaque byte array. OpenThread doesn't define the format of the raw power setting.\n Its format is radio hardware related and it should be defined by the developers in the platform radio driver.\n For example, if the radio hardware contains both the radio chip and the FEM chip, the raw power setting can be\n a combination of the radio power register and the FEM gain value.\n\n @param[in] aInstance               The OpenThread instance structure.\n @param[in] aChannel                The radio channel.\n @param[in] aActualPower            The actual power in 0.01dBm.\n @param[in] aRawPowerSetting        A pointer to the raw power setting byte array.\n @param[in] aRawPowerSettingLength  The length of the @p aRawPowerSetting.\n\n @retval OT_ERROR_NONE             Successfully added the calibrated power to the power calibration table.\n @retval OT_ERROR_NO_BUFS          No available entry in the power calibration table.\n @retval OT_ERROR_INVALID_ARGS     The @p aChannel, @p aActualPower or @p aRawPowerSetting is invalid or the\n                                   @p aActualPower already exists in the power calibration table.\n @retval OT_ERROR_NOT_IMPLEMENTED  This feature is not implemented.\n"]
    pub fn otPlatRadioAddCalibratedPower(
        aInstance: *mut otInstance,
        aChannel: u8,
        aActualPower: i16,
        aRawPowerSetting: *const u8,
        aRawPowerSettingLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Clear all calibrated powers from the power calibration table.\n\n @note This API is an optional radio platform API. It's up to the platform layer to implement it.\n\n @param[in]  aInstance   The OpenThread instance structure.\n\n @retval OT_ERROR_NONE             Successfully cleared all calibrated powers from the power calibration table.\n @retval OT_ERROR_NOT_IMPLEMENTED  This feature is not implemented.\n"]
    pub fn otPlatRadioClearCalibratedPowers(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Set the target power for the given channel.\n\n @note This API is an optional radio platform API. It's up to the platform layer to implement it.\n       If this API is implemented, the function `otPlatRadioSetTransmitPower()` should be disabled.\n\n The radio driver should set the actual output power to be less than or equal to the target power and as close\n as possible to the target power.\n\n @param[in]  aInstance     The OpenThread instance structure.\n @param[in]  aChannel      The radio channel.\n @param[in]  aTargetPower  The target power in 0.01dBm. Passing `INT16_MAX` will disable this channel to use the\n                           target power.\n\n @retval  OT_ERROR_NONE             Successfully set the target power.\n @retval  OT_ERROR_INVALID_ARGS     The @p aChannel or @p aTargetPower is invalid.\n @retval  OT_ERROR_NOT_IMPLEMENTED  The feature is not implemented.\n"]
    pub fn otPlatRadioSetChannelTargetPower(
        aInstance: *mut otInstance,
        aChannel: u8,
        aTargetPower: i16,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the raw power setting for the given channel.\n\n @note OpenThread `src/core/utils` implements a default implementation of the API `otPlatRadioAddCalibratedPower()`,\n       `otPlatRadioClearCalibratedPowers()` and `otPlatRadioSetChannelTargetPower()`. This API is provided by\n       the default implementation to get the raw power setting for the given channel. If the platform doesn't\n       use the default implementation, it can ignore this API.\n\n Platform radio layer should parse the raw power setting based on the radio layer defined format and set the\n parameters of each radio hardware module.\n\n @param[in]      aInstance               The OpenThread instance structure.\n @param[in]      aChannel                The radio channel.\n @param[out]     aRawPowerSetting        A pointer to the raw power setting byte array.\n @param[in,out]  aRawPowerSettingLength  On input, a pointer to the size of @p aRawPowerSetting.\n                                         On output, a pointer to the length of the raw power setting data.\n\n @retval  OT_ERROR_NONE          Successfully got the target power.\n @retval  OT_ERROR_INVALID_ARGS  The @p aChannel is invalid, @p aRawPowerSetting or @p aRawPowerSettingLength is NULL\n                                 or @aRawPowerSettingLength is too short.\n @retval  OT_ERROR_NOT_FOUND     The raw power setting for the @p aChannel was not found.\n"]
    pub fn otPlatRadioGetRawPowerSetting(
        aInstance: *mut otInstance,
        aChannel: u8,
        aRawPowerSetting: *mut u8,
        aRawPowerSettingLength: *mut u16,
    ) -> otError;
}
#[doc = " @struct otIp6InterfaceIdentifier\n\n This structure represents the Interface Identifier of an IPv6 address.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6InterfaceIdentifier {
    #[doc = "< The Interface Identifier accessor fields"]
    pub mFields: otIp6InterfaceIdentifier__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIp6InterfaceIdentifier__bindgen_ty_1 {
    #[doc = "< 8-bit fields"]
    pub m8: [u8; 8usize],
    #[doc = "< 16-bit fields"]
    pub m16: [u16; 4usize],
    #[doc = "< 32-bit fields"]
    pub m32: [u32; 2usize],
}
impl Default for otIp6InterfaceIdentifier__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otIp6InterfaceIdentifier {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otIp6NetworkPrefix\n\n This structure represents the Network Prefix of an IPv6 address (most significant 64 bits of the address).\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otIp6NetworkPrefix {
    #[doc = "< The Network Prefix."]
    pub m8: [u8; 8usize],
}
#[doc = " @struct otIp6AddressComponents\n\n This structure represents the components of an IPv6 address.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6AddressComponents {
    #[doc = "< The Network Prefix (most significant 64 bits of the address)"]
    pub mNetworkPrefix: otIp6NetworkPrefix,
    #[doc = "< The Interface Identifier (least significant 64 bits of the address)"]
    pub mIid: otIp6InterfaceIdentifier,
}
impl Default for otIp6AddressComponents {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otIp6Address\n\n This structure represents an IPv6 address.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6Address {
    #[doc = "< IPv6 accessor fields"]
    pub mFields: otIp6Address__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIp6Address__bindgen_ty_1 {
    #[doc = "< 8-bit fields"]
    pub m8: [u8; 16usize],
    #[doc = "< 16-bit fields"]
    pub m16: [u16; 8usize],
    #[doc = "< 32-bit fields"]
    pub m32: [u32; 4usize],
    #[doc = "< IPv6 address components"]
    pub mComponents: otIp6AddressComponents,
}
impl Default for otIp6Address__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otIp6Address {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents an IPv6 prefix.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp6Prefix {
    #[doc = "< The IPv6 prefix."]
    pub mPrefix: otIp6Address,
    #[doc = "< The IPv6 prefix length (in bits)."]
    pub mLength: u8,
}
impl Default for otIp6Prefix {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Thread assigned address (ALOC, RLOC, MLEID, etc)"]
pub const OT_ADDRESS_ORIGIN_THREAD: _bindgen_ty_8 = 0;
#[doc = "< SLAAC assigned address"]
pub const OT_ADDRESS_ORIGIN_SLAAC: _bindgen_ty_8 = 1;
#[doc = "< DHCPv6 assigned address"]
pub const OT_ADDRESS_ORIGIN_DHCPV6: _bindgen_ty_8 = 2;
#[doc = "< Manually assigned address"]
pub const OT_ADDRESS_ORIGIN_MANUAL: _bindgen_ty_8 = 3;
#[doc = " IPv6 Address origins\n"]
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[doc = " This structure represents an IPv6 network interface unicast address.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetifAddress {
    #[doc = "< The IPv6 unicast address."]
    pub mAddress: otIp6Address,
    #[doc = "< The Prefix length (in bits)."]
    pub mPrefixLength: u8,
    #[doc = "< The IPv6 address origin."]
    pub mAddressOrigin: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< A pointer to the next network interface address."]
    pub mNext: *mut otNetifAddress,
}
impl Default for otNetifAddress {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otNetifAddress {
    #[inline]
    pub fn mPreferred(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPreferred(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mValid(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mValid(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mScopeOverrideValid(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mScopeOverrideValid(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mScopeOverride(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mScopeOverride(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mRloc(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRloc(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPreferred: bool,
        mValid: bool,
        mScopeOverrideValid: bool,
        mScopeOverride: ::std::os::raw::c_uint,
        mRloc: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mPreferred: u8 = unsafe { ::std::mem::transmute(mPreferred) };
            mPreferred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mValid: u8 = unsafe { ::std::mem::transmute(mValid) };
            mValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mScopeOverrideValid: u8 = unsafe { ::std::mem::transmute(mScopeOverrideValid) };
            mScopeOverrideValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let mScopeOverride: u32 = unsafe { ::std::mem::transmute(mScopeOverride) };
            mScopeOverride as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mRloc: u8 = unsafe { ::std::mem::transmute(mRloc) };
            mRloc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents an IPv6 network interface multicast address.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetifMulticastAddress {
    #[doc = "< The IPv6 multicast address."]
    pub mAddress: otIp6Address,
    #[doc = "< A pointer to the next network interface multicast address."]
    pub mNext: *const otNetifMulticastAddress,
}
impl Default for otNetifMulticastAddress {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents an IPv6 socket address.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otSockAddr {
    #[doc = "< An IPv6 address."]
    pub mAddress: otIp6Address,
    #[doc = "< A transport-layer port."]
    pub mPort: u16,
}
impl Default for otSockAddr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Non-ECT"]
pub const OT_ECN_NOT_CAPABLE: _bindgen_ty_9 = 0;
#[doc = "< ECT(0)"]
pub const OT_ECN_CAPABLE_0: _bindgen_ty_9 = 2;
#[doc = "< ECT(1)"]
pub const OT_ECN_CAPABLE_1: _bindgen_ty_9 = 1;
#[doc = "< Congestion encountered (CE)"]
pub const OT_ECN_MARKED: _bindgen_ty_9 = 3;
#[doc = " ECN statuses, represented as in the IP header.\n"]
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[doc = " This structure represents the local and peer IPv6 socket addresses.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otMessageInfo {
    #[doc = "< The local IPv6 address."]
    pub mSockAddr: otIp6Address,
    #[doc = "< The peer IPv6 address."]
    pub mPeerAddr: otIp6Address,
    #[doc = "< The local transport-layer port."]
    pub mSockPort: u16,
    #[doc = "< The peer transport-layer port."]
    pub mPeerPort: u16,
    #[doc = "< A pointer to link-specific information."]
    pub mLinkInfo: *const ::std::os::raw::c_void,
    #[doc = "< The IPv6 Hop Limit value. Only applies if `mAllowZeroHopLimit` is FALSE.\n< If `0`, IPv6 Hop Limit is default value `OPENTHREAD_CONFIG_IP6_HOP_LIMIT_DEFAULT`.\n< Otherwise, specifies the IPv6 Hop Limit."]
    pub mHopLimit: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl Default for otMessageInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otMessageInfo {
    #[inline]
    pub fn mEcn(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mEcn(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsHostInterface(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsHostInterface(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAllowZeroHopLimit(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAllowZeroHopLimit(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mMulticastLoop(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mMulticastLoop(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mEcn: u8,
        mIsHostInterface: bool,
        mAllowZeroHopLimit: bool,
        mMulticastLoop: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let mEcn: u8 = unsafe { ::std::mem::transmute(mEcn) };
            mEcn as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsHostInterface: u8 = unsafe { ::std::mem::transmute(mIsHostInterface) };
            mIsHostInterface as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mAllowZeroHopLimit: u8 = unsafe { ::std::mem::transmute(mAllowZeroHopLimit) };
            mAllowZeroHopLimit as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mMulticastLoop: u8 = unsafe { ::std::mem::transmute(mMulticastLoop) };
            mMulticastLoop as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< IPv6 Hop-by-Hop Option"]
pub const OT_IP6_PROTO_HOP_OPTS: _bindgen_ty_10 = 0;
#[doc = "< Transmission Control Protocol"]
pub const OT_IP6_PROTO_TCP: _bindgen_ty_10 = 6;
#[doc = "< User Datagram"]
pub const OT_IP6_PROTO_UDP: _bindgen_ty_10 = 17;
#[doc = "< IPv6 encapsulation"]
pub const OT_IP6_PROTO_IP6: _bindgen_ty_10 = 41;
#[doc = "< Routing Header for IPv6"]
pub const OT_IP6_PROTO_ROUTING: _bindgen_ty_10 = 43;
#[doc = "< Fragment Header for IPv6"]
pub const OT_IP6_PROTO_FRAGMENT: _bindgen_ty_10 = 44;
#[doc = "< ICMP for IPv6"]
pub const OT_IP6_PROTO_ICMP6: _bindgen_ty_10 = 58;
#[doc = "< No Next Header for IPv6"]
pub const OT_IP6_PROTO_NONE: _bindgen_ty_10 = 59;
#[doc = "< Destination Options for IPv6"]
pub const OT_IP6_PROTO_DST_OPTS: _bindgen_ty_10 = 60;
#[doc = " Internet Protocol Numbers.\n"]
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Brings the IPv6 interface up or down.\n\n Call this to enable or disable IPv6 communication.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n @param[in] aEnabled  TRUE to enable IPv6, FALSE otherwise.\n\n @retval OT_ERROR_NONE            Successfully brought the IPv6 interface up/down.\n @retval OT_ERROR_INVALID_STATE   IPv6 interface is not available since device is operating in raw-link mode\n                                  (applicable only when `OPENTHREAD_CONFIG_LINK_RAW_ENABLE` feature is enabled).\n"]
    pub fn otIp6SetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " Indicates whether or not the IPv6 interface is up.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @retval TRUE   The IPv6 interface is enabled.\n @retval FALSE  The IPv6 interface is disabled.\n"]
    pub fn otIp6IsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Adds a Network Interface Address to the Thread interface.\n\n The passed-in instance @p aAddress is copied by the Thread interface. The Thread interface only\n supports a fixed number of externally added unicast addresses. See `OPENTHREAD_CONFIG_IP6_MAX_EXT_UCAST_ADDRS`.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aAddress  A pointer to a Network Interface Address.\n\n @retval OT_ERROR_NONE          Successfully added (or updated) the Network Interface Address.\n @retval OT_ERROR_INVALID_ARGS  The IP Address indicated by @p aAddress is an internal address.\n @retval OT_ERROR_NO_BUFS       The Network Interface is already storing the maximum allowed external addresses."]
    pub fn otIp6AddUnicastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otNetifAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes a Network Interface Address from the Thread interface.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aAddress  A pointer to an IP Address.\n\n @retval OT_ERROR_NONE          Successfully removed the Network Interface Address.\n @retval OT_ERROR_INVALID_ARGS  The IP Address indicated by @p aAddress is an internal address.\n @retval OT_ERROR_NOT_FOUND     The IP Address indicated by @p aAddress was not found."]
    pub fn otIp6RemoveUnicastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the list of IPv6 addresses assigned to the Thread interface.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the first Network Interface Address."]
    pub fn otIp6GetUnicastAddresses(aInstance: *mut otInstance) -> *const otNetifAddress;
}
extern "C" {
    #[doc = " Subscribes the Thread interface to a Network Interface Multicast Address.\n\n The passed in instance @p aAddress will be copied by the Thread interface. The Thread interface only\n supports a fixed number of externally added multicast addresses. See `OPENTHREAD_CONFIG_IP6_MAX_EXT_MCAST_ADDRS`.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aAddress  A pointer to an IP Address.\n\n @retval OT_ERROR_NONE           Successfully subscribed to the Network Interface Multicast Address.\n @retval OT_ERROR_ALREADY        The multicast address is already subscribed.\n @retval OT_ERROR_INVALID_ARGS   The IP Address indicated by @p aAddress is an invalid multicast address.\n @retval OT_ERROR_REJECTED       The IP Address indicated by @p aAddress is an internal multicast address.\n @retval OT_ERROR_NO_BUFS        The Network Interface is already storing the maximum allowed external multicast\n                                 addresses.\n"]
    pub fn otIp6SubscribeMulticastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Unsubscribes the Thread interface to a Network Interface Multicast Address.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aAddress  A pointer to an IP Address.\n\n @retval OT_ERROR_NONE          Successfully unsubscribed to the Network Interface Multicast Address.\n @retval OT_ERROR_REJECTED      The IP Address indicated by @p aAddress is an internal address.\n @retval OT_ERROR_NOT_FOUND     The IP Address indicated by @p aAddress was not found.\n"]
    pub fn otIp6UnsubscribeMulticastAddress(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the list of IPv6 multicast addresses subscribed to the Thread interface.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the first Network Interface Multicast Address.\n"]
    pub fn otIp6GetMulticastAddresses(aInstance: *mut otInstance)
        -> *const otNetifMulticastAddress;
}
extern "C" {
    #[doc = " Checks if multicast promiscuous mode is enabled on the Thread interface.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @sa otIp6SetMulticastPromiscuousEnabled\n"]
    pub fn otIp6IsMulticastPromiscuousEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Enables or disables multicast promiscuous mode on the Thread interface.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aEnabled   TRUE to enable Multicast Promiscuous mode, FALSE otherwise.\n\n @sa otIp6IsMulticastPromiscuousEnabled\n"]
    pub fn otIp6SetMulticastPromiscuousEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " Allocate a new message buffer for sending an IPv6 message.\n\n @note If @p aSettings is 'NULL', the link layer security is enabled and the message priority is set to\n OT_MESSAGE_PRIORITY_NORMAL by default.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSettings  A pointer to the message settings or NULL to set default settings.\n\n @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid.\n\n @sa otMessageFree\n"]
    pub fn otIp6NewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Allocate a new message buffer and write the IPv6 datagram to the message buffer for sending an IPv6 message.\n\n @note If @p aSettings is NULL, the link layer security is enabled and the message priority is obtained from IPv6\n       message itself.\n       If @p aSettings is not NULL, the @p aSetting->mPriority is ignored and obtained from IPv6 message itself.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aData        A pointer to the IPv6 datagram buffer.\n @param[in]  aDataLength  The size of the IPv6 datagram buffer pointed by @p aData.\n @param[in]  aSettings    A pointer to the message settings or NULL to set default settings.\n\n @returns A pointer to the message or NULL if malformed IPv6 header or insufficient message buffers are available.\n\n @sa otMessageFree\n"]
    pub fn otIp6NewMessageFromBuffer(
        aInstance: *mut otInstance,
        aData: *const u8,
        aDataLength: u16,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
#[doc = " This function pointer is called when an IPv6 datagram is received.\n\n @param[in]  aMessage  A pointer to the message buffer containing the received IPv6 datagram. This function transfers\n                       the ownership of the @p aMessage to the receiver of the callback. The message should be\n                       freed by the receiver of the callback after it is processed (see otMessageFree()).\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otIp6ReceiveCallback = ::std::option::Option<
    unsafe extern "C" fn(aMessage: *mut otMessage, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function registers a callback to provide received IPv6 datagrams.\n\n By default, this callback does not pass Thread control traffic.  See otIp6SetReceiveFilterEnabled() to\n change the Thread control traffic filter setting.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aCallback         A pointer to a function that is called when an IPv6 datagram is received or\n                               NULL to disable the callback.\n @param[in]  aCallbackContext  A pointer to application-specific context.\n\n @sa otIp6IsReceiveFilterEnabled\n @sa otIp6SetReceiveFilterEnabled\n"]
    pub fn otIp6SetReceiveCallback(
        aInstance: *mut otInstance,
        aCallback: otIp6ReceiveCallback,
        aCallbackContext: *mut ::std::os::raw::c_void,
    );
}
#[doc = " @struct otIp6AddressInfo\n\n This structure represents IPv6 address information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otIp6AddressInfo {
    #[doc = "< A pointer to the IPv6 address."]
    pub mAddress: *const otIp6Address,
    #[doc = "< The prefix length of mAddress if it is a unicast address."]
    pub mPrefixLength: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl Default for otIp6AddressInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otIp6AddressInfo {
    #[inline]
    pub fn mScope(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mScope(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mPreferred(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPreferred(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mScope: u8, mPreferred: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mScope: u8 = unsafe { ::std::mem::transmute(mScope) };
            mScope as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mPreferred: u8 = unsafe { ::std::mem::transmute(mPreferred) };
            mPreferred as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This function pointer is called when an internal IPv6 address is added or removed.\n\n @param[in]   aAddressInfo        A pointer to the IPv6 address information.\n @param[in]   aIsAdded            TRUE if the @p aAddress was added, FALSE if @p aAddress was removed.\n @param[in]   aContext            A pointer to application-specific context.\n"]
pub type otIp6AddressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aAddressInfo: *const otIp6AddressInfo,
        aIsAdded: bool,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function registers a callback to notify internal IPv6 address changes.\n\n @param[in]   aInstance           A pointer to an OpenThread instance.\n @param[in]   aCallback           A pointer to a function that is called when an internal IPv6 address is added or\n                                  removed. NULL to disable the callback.\n @param[in]   aCallbackContext    A pointer to application-specific context.\n"]
    pub fn otIp6SetAddressCallback(
        aInstance: *mut otInstance,
        aCallback: otIp6AddressCallback,
        aCallbackContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function indicates whether or not Thread control traffic is filtered out when delivering IPv6 datagrams\n via the callback specified in otIp6SetReceiveCallback().\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns  TRUE if Thread control traffic is filtered out, FALSE otherwise.\n\n @sa otIp6SetReceiveCallback\n @sa otIp6SetReceiveFilterEnabled\n"]
    pub fn otIp6IsReceiveFilterEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function sets whether or not Thread control traffic is filtered out when delivering IPv6 datagrams\n via the callback specified in otIp6SetReceiveCallback().\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aEnabled  TRUE if Thread control traffic is filtered out, FALSE otherwise.\n\n @sa otIp6SetReceiveCallback\n @sa otIsReceiveIp6FilterEnabled\n"]
    pub fn otIp6SetReceiveFilterEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " This function sends an IPv6 datagram via the Thread interface.\n\n The caller transfers ownership of @p aMessage when making this call. OpenThread will free @p aMessage when\n processing is complete, including when a value other than `OT_ERROR_NONE` is returned.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aMessage  A pointer to the message buffer containing the IPv6 datagram.\n\n @retval OT_ERROR_NONE                    Successfully processed the message.\n @retval OT_ERROR_DROP                    Message was well-formed but not fully processed due to packet processing\n rules.\n @retval OT_ERROR_NO_BUFS                 Could not allocate necessary message buffers when processing the datagram.\n @retval OT_ERROR_NO_ROUTE                No route to host.\n @retval OT_ERROR_INVALID_SOURCE_ADDRESS  Source address is invalid, e.g. an anycast address or a multicast address.\n @retval OT_ERROR_PARSE                   Encountered a malformed header when processing the message.\n"]
    pub fn otIp6Send(aInstance: *mut otInstance, aMessage: *mut otMessage) -> otError;
}
extern "C" {
    #[doc = " This function adds a port to the allowed unsecured port list.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aPort     The port value.\n\n @retval OT_ERROR_NONE         The port was successfully added to the allowed unsecure port list.\n @retval OT_ERROR_INVALID_ARGS The port is invalid (value 0 is reserved for internal use).\n @retval OT_ERROR_NO_BUFS      The unsecure port list is full.\n"]
    pub fn otIp6AddUnsecurePort(aInstance: *mut otInstance, aPort: u16) -> otError;
}
extern "C" {
    #[doc = " This function removes a port from the allowed unsecure port list.\n\n @note This function removes @p aPort by overwriting @p aPort with the element after @p aPort in the internal port\n       list. Be careful when calling otIp6GetUnsecurePorts() followed by otIp6RemoveUnsecurePort() to remove unsecure\n       ports.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aPort     The port value.\n\n @retval OT_ERROR_NONE         The port was successfully removed from the allowed unsecure port list.\n @retval OT_ERROR_INVALID_ARGS The port is invalid (value 0 is reserved for internal use).\n @retval OT_ERROR_NOT_FOUND    The port was not found in the unsecure port list.\n"]
    pub fn otIp6RemoveUnsecurePort(aInstance: *mut otInstance, aPort: u16) -> otError;
}
extern "C" {
    #[doc = " This function removes all ports from the allowed unsecure port list.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n"]
    pub fn otIp6RemoveAllUnsecurePorts(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function returns a pointer to the unsecure port list.\n\n @note Port value 0 is used to indicate an invalid entry.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aNumEntries  The number of entries in the list.\n\n @returns A pointer to the unsecure port list.\n"]
    pub fn otIp6GetUnsecurePorts(aInstance: *mut otInstance, aNumEntries: *mut u8) -> *const u16;
}
extern "C" {
    #[doc = " Test if two IPv6 addresses are the same.\n\n @param[in]  aFirst   A pointer to the first IPv6 address to compare.\n @param[in]  aSecond  A pointer to the second IPv6 address to compare.\n\n @retval TRUE   The two IPv6 addresses are the same.\n @retval FALSE  The two IPv6 addresses are not the same.\n"]
    pub fn otIp6IsAddressEqual(aFirst: *const otIp6Address, aSecond: *const otIp6Address) -> bool;
}
extern "C" {
    #[doc = " Test if two IPv6 prefixes are the same.\n\n @param[in]  aFirst   A pointer to the first IPv6 prefix to compare.\n @param[in]  aSecond  A pointer to the second IPv6 prefix to compare.\n\n @retval TRUE   The two IPv6 prefixes are the same.\n @retval FALSE  The two IPv6 prefixes are not the same.\n"]
    pub fn otIp6ArePrefixesEqual(aFirst: *const otIp6Prefix, aSecond: *const otIp6Prefix) -> bool;
}
extern "C" {
    #[doc = " This function converts a human-readable IPv6 address string into a binary representation.\n\n @param[in]   aString   A pointer to a NULL-terminated string.\n @param[out]  aAddress  A pointer to an IPv6 address.\n\n @retval OT_ERROR_NONE   Successfully parsed @p aString and updated @p aAddress.\n @retval OT_ERROR_PARSE  Failed to parse @p aString as an IPv6 address.\n"]
    pub fn otIp6AddressFromString(
        aString: *const ::std::os::raw::c_char,
        aAddress: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " This function converts a human-readable IPv6 prefix string into a binary representation.\n\n The @p aString parameter should be a string in the format \"<address>/<plen>\", where `<address>` is an IPv6\n address and `<plen>` is a prefix length.\n\n @param[in]   aString  A pointer to a NULL-terminated string.\n @param[out]  aPrefix  A pointer to an IPv6 prefix.\n\n @retval OT_ERROR_NONE   Successfully parsed the string as an IPv6 prefix and updated @p aPrefix.\n @retval OT_ERROR_PARSE  Failed to parse @p aString as an IPv6 prefix.\n"]
    pub fn otIp6PrefixFromString(
        aString: *const ::std::os::raw::c_char,
        aPrefix: *mut otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " This function converts a given IPv6 address to a human-readable string.\n\n The IPv6 address string is formatted as 16 hex values separated by ':' (i.e., \"%x:%x:%x:...:%x\").\n\n If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated\n but the outputted string is always null-terminated.\n\n @param[in]  aAddress  A pointer to an IPv6 address (MUST NOT be NULL).\n @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL).\n @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_ADDRESS_STRING_SIZE`.\n"]
    pub fn otIp6AddressToString(
        aAddress: *const otIp6Address,
        aBuffer: *mut ::std::os::raw::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " This function converts a given IPv6 socket address to a human-readable string.\n\n The IPv6 socket address string is formatted as [`address`]:`port` where `address` is shown\n as 16 hex values separated by `:` and `port` is the port number in decimal format,\n for example \"[%x:%x:...:%x]:%u\".\n\n If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated\n but the outputted string is always null-terminated.\n\n @param[in]  aSockAddr A pointer to an IPv6 socket address (MUST NOT be NULL).\n @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL).\n @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_SOCK_ADDR_STRING_SIZE`.\n"]
    pub fn otIp6SockAddrToString(
        aSockAddr: *const otSockAddr,
        aBuffer: *mut ::std::os::raw::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " This function converts a given IPv6 prefix to a human-readable string.\n\n The IPv6 address string is formatted as \"%x:%x:%x:...[::]/plen\".\n\n If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated\n but the outputted string is always null-terminated.\n\n @param[in]  aPrefix   A pointer to an IPv6 prefix (MUST NOT be NULL).\n @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be NULL).\n @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_IP6_PREFIX_STRING_SIZE`.\n"]
    pub fn otIp6PrefixToString(
        aPrefix: *const otIp6Prefix,
        aBuffer: *mut ::std::os::raw::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " This function returns the prefix match length (bits) for two IPv6 addresses.\n\n @param[in]  aFirst   A pointer to the first IPv6 address.\n @param[in]  aSecond  A pointer to the second IPv6 address.\n\n @returns  The prefix match length in bits.\n"]
    pub fn otIp6PrefixMatch(aFirst: *const otIp6Address, aSecond: *const otIp6Address) -> u8;
}
extern "C" {
    #[doc = " This method gets a prefix with @p aLength from @p aAddress.\n\n @param[in]  aAddress   A pointer to an IPv6 address.\n @param[in]  aLength    The length of prefix in bits.\n @param[out] aPrefix    A pointer to output the IPv6 prefix.\n"]
    pub fn otIp6GetPrefix(aAddress: *const otIp6Address, aLength: u8, aPrefix: *mut otIp6Prefix);
}
extern "C" {
    #[doc = " This function indicates whether or not a given IPv6 address is the Unspecified Address.\n\n @param[in]  aAddress   A pointer to an IPv6 address.\n\n @retval TRUE   If the IPv6 address is the Unspecified Address.\n @retval FALSE  If the IPv6 address is not the Unspecified Address.\n"]
    pub fn otIp6IsAddressUnspecified(aAddress: *const otIp6Address) -> bool;
}
extern "C" {
    #[doc = " This function perform OpenThread source address selection.\n\n @param[in]      aInstance     A pointer to an OpenThread instance.\n @param[in,out]  aMessageInfo  A pointer to the message information.\n\n @retval  OT_ERROR_NONE       Found a source address and is filled into mSockAddr of @p aMessageInfo.\n @retval  OT_ERROR_NOT_FOUND  No source address was found and @p aMessageInfo is unchanged.\n"]
    pub fn otIp6SelectSourceAddress(
        aInstance: *mut otInstance,
        aMessageInfo: *mut otMessageInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether the SLAAC module is enabled or not.\n\n This function requires the build-time feature `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` to be enabled.\n\n @retval TRUE    SLAAC module is enabled.\n @retval FALSE   SLAAC module is disabled.\n"]
    pub fn otIp6IsSlaacEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function enables/disables the SLAAC module.\n\n This function requires the build-time feature `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` to be enabled.\n\n When SLAAC module is enabled, SLAAC addresses (based on on-mesh prefixes in Network Data) are added to the interface.\n When SLAAC module is disabled any previously added SLAAC address is removed.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n @param[in] aEnabled  TRUE to enable, FALSE to disable.\n"]
    pub fn otIp6SetSlaacEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
#[doc = " This function pointer allows user to filter prefixes and not allow an SLAAC address based on a prefix to be added.\n\n `otIp6SetSlaacPrefixFilter()` can be used to set the filter handler. The filter handler is invoked by SLAAC module\n when it is about to add a SLAAC address based on a prefix. Its boolean return value determines whether the address\n is filtered (not added) or not.\n\n @param[in] aInstance   A pointer to an OpenThread instance.\n @param[in] aPrefix     A pointer to prefix for which SLAAC address is about to be added.\n\n @retval TRUE    Indicates that the SLAAC address based on the prefix should be filtered and NOT added.\n @retval FALSE   Indicates that the SLAAC address based on the prefix should be added.\n"]
pub type otIp6SlaacPrefixFilter = ::std::option::Option<
    unsafe extern "C" fn(aInstance: *mut otInstance, aPrefix: *const otIp6Prefix) -> bool,
>;
extern "C" {
    #[doc = " This function sets the SLAAC module filter handler.\n\n This function requires the build-time feature `OPENTHREAD_CONFIG_IP6_SLAAC_ENABLE` to be enabled.\n\n The filter handler is called by SLAAC module when it is about to add a SLAAC address based on a prefix to decide\n whether the address should be added or not.\n\n A NULL filter handler disables filtering and allows all SLAAC addresses to be added.\n\n If this function is not called, the default filter used by SLAAC module will be NULL (filtering is disabled).\n\n @param[in] aInstance    A pointer to an OpenThread instance.\n @param[in] aFilter      A pointer to SLAAC prefix filter handler, or NULL to disable filtering.\n"]
    pub fn otIp6SetSlaacPrefixFilter(aInstance: *mut otInstance, aFilter: otIp6SlaacPrefixFilter);
}
#[doc = " This function pointer is called with results of `otIp6RegisterMulticastListeners`.\n\n @param[in]  aContext  A pointer to the user context.\n @param[in]  aError    OT_ERROR_NONE when successfully sent MLR.req and received MLR.rsp,\n                       OT_ERROR_RESPONSE_TIMEOUT when failed to receive MLR.rsp,\n                       OT_ERROR_PARSE when failed to parse MLR.rsp.\n @param[in]  aMlrStatus         The Multicast Listener Registration status when @p aError is OT_ERROR_NONE.\n @param[in]  aFailedAddresses   A pointer to the failed IPv6 addresses when @p aError is OT_ERROR_NONE.\n @param[in]  aFailedAddressNum  The number of failed IPv6 addresses when @p aError is OT_ERROR_NONE.\n\n @sa otIp6RegisterMulticastListeners\n"]
pub type otIp6RegisterMulticastListenersCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aError: otError,
        aMlrStatus: u8,
        aFailedAddresses: *const otIp6Address,
        aFailedAddressNum: u8,
    ),
>;
extern "C" {
    #[doc = " This function registers Multicast Listeners to Primary Backbone Router.\n\n Note: only available when both `OPENTHREAD_CONFIG_TMF_PROXY_MLR_ENABLE` and\n `OPENTHREAD_CONFIG_COMMISSIONER_ENABLE` are enabled)\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aAddresses   A Multicast Address Array to register.\n @param[in]  aAddressNum  The number of Multicast Address to register (0 if @p aAddresses is NULL).\n @param[in]  aTimeout     A pointer to the timeout value (in seconds) to be included in MLR.req. A timeout value of 0\n                          removes the corresponding Multicast Listener. If NULL, MLR.req would have no Timeout Tlv by\n                          default.\n @param[in]  aCallback    A pointer to the callback function.\n @param[in]  aContext     A pointer to the user context.\n\n @retval OT_ERROR_NONE           Successfully sent MLR.req. The @p aCallback will be called iff this method\n                                 returns OT_ERROR_NONE.\n @retval OT_ERROR_BUSY           If a previous registration was ongoing.\n @retval OT_ERROR_INVALID_ARGS   If one or more arguments are invalid.\n @retval OT_ERROR_INVALID_STATE  If the device was not in a valid state to send MLR.req (e.g. Commissioner not\n                                 started, Primary Backbone Router not found).\n @retval OT_ERROR_NO_BUFS        If insufficient message buffers available.\n\n @sa otIp6RegisterMulticastListenersCallback\n"]
    pub fn otIp6RegisterMulticastListeners(
        aInstance: *mut otInstance,
        aAddresses: *const otIp6Address,
        aAddressNum: u8,
        aTimeout: *const u32,
        aCallback: otIp6RegisterMulticastListenersCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the Mesh Local IID (for test purpose).\n\n Only available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled.\n\n @param[in]   aInstance   A pointer to an OpenThread instance.\n @param[in]   aIid        A pointer to the Mesh Local IID to set.\n\n @retval  OT_ERROR_NONE           Successfully set the Mesh Local IID.\n @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n"]
    pub fn otIp6SetMeshLocalIid(
        aInstance: *mut otInstance,
        aIid: *const otIp6InterfaceIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " This function converts a given IP protocol number to a human-readable string.\n\n @param[in] aIpProto   An IP protocol number (`OT_IP6_PROTO_*` enumeration).\n\n @returns A string representing @p aIpProto.\n"]
    pub fn otIp6ProtoToString(aIpProto: u8) -> *const ::std::os::raw::c_char;
}
#[doc = " This structure represents the counters for packets and bytes.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otPacketsAndBytes {
    #[doc = "< The number of packets."]
    pub mPackets: u64,
    #[doc = "< The number of bytes."]
    pub mBytes: u64,
}
#[doc = " This structure represents the counters of packets forwarded via Border Routing.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otBorderRoutingCounters {
    #[doc = "< The counters for inbound unicast."]
    pub mInboundUnicast: otPacketsAndBytes,
    #[doc = "< The counters for inbound multicast."]
    pub mInboundMulticast: otPacketsAndBytes,
    #[doc = "< The counters for outbound unicast."]
    pub mOutboundUnicast: otPacketsAndBytes,
    #[doc = "< The counters for outbound multicast."]
    pub mOutboundMulticast: otPacketsAndBytes,
    #[doc = "< The number of received RA packets."]
    pub mRaRx: u32,
    #[doc = "< The number of RA packets successfully transmitted."]
    pub mRaTxSuccess: u32,
    #[doc = "< The number of RA packets failed to transmit."]
    pub mRaTxFailure: u32,
    #[doc = "< The number of received RS packets."]
    pub mRsRx: u32,
    #[doc = "< The number of RS packets successfully transmitted."]
    pub mRsTxSuccess: u32,
    #[doc = "< The number of RS packets failed to transmit."]
    pub mRsTxFailure: u32,
}
extern "C" {
    #[doc = " Gets the Border Routing counters.\n\n This function requires the build-time feature `OPENTHREAD_CONFIG_IP6_BR_COUNTERS_ENABLE` to be enabled.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns A pointer to the Border Routing counters.\n"]
    pub fn otIp6GetBorderRoutingCounters(
        aInstance: *mut otInstance,
    ) -> *const otBorderRoutingCounters;
}
extern "C" {
    #[doc = " Resets the Border Routing counters.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otIp6ResetBorderRoutingCounters(aInstance: *mut otInstance);
}
pub type otNetworkDataIterator = u32;
#[doc = " This structure represents a Border Router configuration."]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct otBorderRouterConfig {
    #[doc = "< The IPv6 prefix."]
    pub mPrefix: otIp6Prefix,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "< The border router's RLOC16 (value ignored on config add)."]
    pub mRloc16: u16,
}
impl Default for otBorderRouterConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otBorderRouterConfig {
    #[inline]
    pub fn mPreference(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mPreference(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mPreferred(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mPreferred(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mSlaac(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mSlaac(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDhcp(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDhcp(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mConfigure(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mConfigure(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDefaultRoute(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDefaultRoute(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mOnMesh(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mOnMesh(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mStable(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mStable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNdDns(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNdDns(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDp(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDp(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPreference: ::std::os::raw::c_int,
        mPreferred: bool,
        mSlaac: bool,
        mDhcp: bool,
        mConfigure: bool,
        mDefaultRoute: bool,
        mOnMesh: bool,
        mStable: bool,
        mNdDns: bool,
        mDp: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let mPreference: u32 = unsafe { ::std::mem::transmute(mPreference) };
            mPreference as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mPreferred: u8 = unsafe { ::std::mem::transmute(mPreferred) };
            mPreferred as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mSlaac: u8 = unsafe { ::std::mem::transmute(mSlaac) };
            mSlaac as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mDhcp: u8 = unsafe { ::std::mem::transmute(mDhcp) };
            mDhcp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mConfigure: u8 = unsafe { ::std::mem::transmute(mConfigure) };
            mConfigure as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mDefaultRoute: u8 = unsafe { ::std::mem::transmute(mDefaultRoute) };
            mDefaultRoute as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mOnMesh: u8 = unsafe { ::std::mem::transmute(mOnMesh) };
            mOnMesh as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mStable: u8 = unsafe { ::std::mem::transmute(mStable) };
            mStable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let mNdDns: u8 = unsafe { ::std::mem::transmute(mNdDns) };
            mNdDns as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let mDp: u8 = unsafe { ::std::mem::transmute(mDp) };
            mDp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents 6LoWPAN Context ID information associated with a prefix in Network Data.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otLowpanContextInfo {
    #[doc = "< The 6LoWPAN Context ID."]
    pub mContextId: u8,
    #[doc = "< The compress flag."]
    pub mCompressFlag: bool,
    #[doc = "< The associated IPv6 prefix."]
    pub mPrefix: otIp6Prefix,
}
impl Default for otLowpanContextInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents an External Route configuration.\n"]
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct otExternalRouteConfig {
    #[doc = "< The IPv6 prefix."]
    pub mPrefix: otIp6Prefix,
    #[doc = "< The border router's RLOC16 (value ignored on config add)."]
    pub mRloc16: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for otExternalRouteConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otExternalRouteConfig {
    #[inline]
    pub fn mPreference(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mPreference(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mNat64(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNat64(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mStable(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mStable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNextHopIsThisDevice(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNextHopIsThisDevice(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mPreference: ::std::os::raw::c_int,
        mNat64: bool,
        mStable: bool,
        mNextHopIsThisDevice: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let mPreference: u32 = unsafe { ::std::mem::transmute(mPreference) };
            mPreference as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mNat64: u8 = unsafe { ::std::mem::transmute(mNat64) };
            mNat64 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mStable: u8 = unsafe { ::std::mem::transmute(mStable) };
            mStable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mNextHopIsThisDevice: u8 = unsafe { ::std::mem::transmute(mNextHopIsThisDevice) };
            mNextHopIsThisDevice as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Low route preference."]
pub const OT_ROUTE_PREFERENCE_LOW: otRoutePreference = -1;
#[doc = "< Medium route preference."]
pub const OT_ROUTE_PREFERENCE_MED: otRoutePreference = 0;
#[doc = "< High route preference."]
pub const OT_ROUTE_PREFERENCE_HIGH: otRoutePreference = 1;
#[doc = " Defines valid values for `mPreference` in `otExternalRouteConfig` and `otBorderRouterConfig`.\n"]
pub type otRoutePreference = ::std::os::raw::c_int;
#[doc = " This structure represents a Server configuration.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otServerConfig {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Length of server data."]
    pub mServerDataLength: u8,
    #[doc = "< Server data bytes."]
    pub mServerData: [u8; 248usize],
    #[doc = "< The Server RLOC16."]
    pub mRloc16: u16,
}
impl Default for otServerConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otServerConfig {
    #[inline]
    pub fn mStable(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mStable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mStable: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mStable: u8 = unsafe { ::std::mem::transmute(mStable) };
            mStable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents a Service configuration.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otServiceConfig {
    #[doc = "< Service ID (when iterating over the  Network Data)."]
    pub mServiceId: u8,
    #[doc = "< IANA Enterprise Number."]
    pub mEnterpriseNumber: u32,
    #[doc = "< Length of service data."]
    pub mServiceDataLength: u8,
    #[doc = "< Service data bytes."]
    pub mServiceData: [u8; 252usize],
    #[doc = "< The Server configuration."]
    pub mServerConfig: otServerConfig,
}
impl Default for otServiceConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Provide full or stable copy of the Partition's Thread Network Data.\n\n @param[in]      aInstance    A pointer to an OpenThread instance.\n @param[in]      aStable      TRUE when copying the stable version, FALSE when copying the full version.\n @param[out]     aData        A pointer to the data buffer.\n @param[in,out]  aDataLength  On entry, size of the data buffer pointed to by @p aData.\n                              On exit, number of copied bytes.\n\n @retval OT_ERROR_NONE    Successfully copied the Thread Network Data into @p aData and updated @p aDataLength.\n @retval OT_ERROR_NO_BUFS Not enough space in @p aData to fully copy the Thread Network Data.\n"]
    pub fn otNetDataGet(
        aInstance: *mut otInstance,
        aStable: bool,
        aData: *mut u8,
        aDataLength: *mut u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the current length (number of bytes) of Partition's Thread Network Data.\n\n @param[in] aInstance    A pointer to an OpenThread instance.\n\n @return The length of the Network Data.\n"]
    pub fn otNetDataGetLength(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Get the maximum observed length of the Thread Network Data since OT stack initialization or since the last call to\n `otNetDataResetMaxLength()`.\n\n @param[in] aInstance    A pointer to an OpenThread instance.\n\n @return The maximum length of the Network Data (high water mark for Network Data length).\n"]
    pub fn otNetDataGetMaxLength(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Reset the tracked maximum length of the Thread Network Data.\n\n @param[in] aInstance    A pointer to an OpenThread instance.\n\n @sa otNetDataGetMaxLength\n"]
    pub fn otNetDataResetMaxLength(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the next On Mesh Prefix in the partition's Network Data.\n\n @param[in]      aInstance  A pointer to an OpenThread instance.\n @param[in,out]  aIterator  A pointer to the Network Data iterator context. To get the first on-mesh entry\nit should be set to OT_NETWORK_DATA_ITERATOR_INIT.\n @param[out]     aConfig    A pointer to where the On Mesh Prefix information will be placed.\n\n @retval OT_ERROR_NONE       Successfully found the next On Mesh prefix.\n @retval OT_ERROR_NOT_FOUND  No subsequent On Mesh prefix exists in the Thread Network Data.\n"]
    pub fn otNetDataGetNextOnMeshPrefix(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aConfig: *mut otBorderRouterConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the next external route in the partition's Network Data.\n\n @param[in]      aInstance  A pointer to an OpenThread instance.\n @param[in,out]  aIterator  A pointer to the Network Data iterator context. To get the first external route entry\nit should be set to OT_NETWORK_DATA_ITERATOR_INIT.\n @param[out]     aConfig    A pointer to where the External Route information will be placed.\n\n @retval OT_ERROR_NONE       Successfully found the next External Route.\n @retval OT_ERROR_NOT_FOUND  No subsequent external route entry exists in the Thread Network Data.\n"]
    pub fn otNetDataGetNextRoute(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aConfig: *mut otExternalRouteConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the next service in the partition's Network Data.\n\n @param[in]      aInstance  A pointer to an OpenThread instance.\n @param[in,out]  aIterator  A pointer to the Network Data iterator context. To get the first service entry\nit should be set to OT_NETWORK_DATA_ITERATOR_INIT.\n @param[out]     aConfig    A pointer to where the service information will be placed.\n\n @retval OT_ERROR_NONE       Successfully found the next service.\n @retval OT_ERROR_NOT_FOUND  No subsequent service exists in the partition's Network Data.\n"]
    pub fn otNetDataGetNextService(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aConfig: *mut otServiceConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the next 6LoWPAN Context ID info in the partition's Network Data.\n\n @param[in]      aInstance     A pointer to an OpenThread instance.\n @param[in,out]  aIterator     A pointer to the Network Data iterator. To get the first service entry\nit should be set to OT_NETWORK_DATA_ITERATOR_INIT.\n @param[out]     aContextInfo  A pointer to where the retrieved 6LoWPAN Context ID information will be placed.\n\n @retval OT_ERROR_NONE       Successfully found the next 6LoWPAN Context ID info.\n @retval OT_ERROR_NOT_FOUND  No subsequent 6LoWPAN Context info exists in the partition's Network Data.\n"]
    pub fn otNetDataGetNextLowpanContextInfo(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aContextInfo: *mut otLowpanContextInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Network Data Version.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Network Data Version.\n"]
    pub fn otNetDataGetVersion(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Get the Stable Network Data Version.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Stable Network Data Version.\n"]
    pub fn otNetDataGetStableVersion(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Check if the steering data includes a Joiner.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aEui64             A pointer to the Joiner's IEEE EUI-64.\n\n @retval OT_ERROR_NONE          @p aEui64 is included in the steering data.\n @retval OT_ERROR_INVALID_STATE No steering data present.\n @retval OT_ERROR_NOT_FOUND     @p aEui64 is not included in the steering data.\n"]
    pub fn otNetDataSteeringDataCheckJoiner(
        aInstance: *mut otInstance,
        aEui64: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Check if the steering data includes a Joiner with a given discerner value.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aDiscerner         A pointer to the Joiner Discerner.\n\n @retval OT_ERROR_NONE          @p aDiscerner is included in the steering data.\n @retval OT_ERROR_INVALID_STATE No steering data present.\n @retval OT_ERROR_NOT_FOUND     @p aDiscerner is not included in the steering data.\n"]
    pub fn otNetDataSteeringDataCheckJoinerWithDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *const otJoinerDiscerner,
    ) -> otError;
}
extern "C" {
    #[doc = " Check whether a given Prefix can act as a valid OMR prefix and also the Leader's Network Data contains this prefix.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aPrefix    A pointer to the IPv6 prefix.\n\n @returns  Whether @p aPrefix is a valid OMR prefix and Leader's Network Data contains the OMR prefix @p aPrefix.\n\n @note This API is only available when `OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE` is used.\n"]
    pub fn otNetDataContainsOmrPrefix(
        aInstance: *mut otInstance,
        aPrefix: *const otIp6Prefix,
    ) -> bool;
}
#[doc = "< Backbone function is disabled."]
pub const OT_BACKBONE_ROUTER_STATE_DISABLED: otBackboneRouterState = 0;
#[doc = "< Secondary Backbone Router."]
pub const OT_BACKBONE_ROUTER_STATE_SECONDARY: otBackboneRouterState = 1;
#[doc = "< The Primary Backbone Router."]
pub const OT_BACKBONE_ROUTER_STATE_PRIMARY: otBackboneRouterState = 2;
#[doc = " Represents the Backbone Router Status.\n"]
pub type otBackboneRouterState = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Enables or disables Backbone functionality.\n\n If enabled, a Server Data Request message `SRV_DATA.ntf` is triggered for the attached\n device if there is no Backbone Router Service in the Thread Network Data.\n\n If disabled, `SRV_DATA.ntf` is triggered if the Backbone Router is in the Primary state.\n\n Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE` is enabled.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n @param[in] aEnable   TRUE to enable Backbone functionality, FALSE otherwise.\n\n @sa otBackboneRouterGetState\n @sa otBackboneRouterGetConfig\n @sa otBackboneRouterSetConfig\n @sa otBackboneRouterRegister\n"]
    pub fn otBackboneRouterSetEnabled(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " Gets the Backbone Router #otBackboneRouterState.\n\n @param[in] aInstance       A pointer to an OpenThread instance.\n\n @retval OT_BACKBONE_ROUTER_STATE_DISABLED   Backbone functionality is disabled.\n @retval OT_BACKBONE_ROUTER_STATE_SECONDARY  Secondary Backbone Router.\n @retval OT_BACKBONE_ROUTER_STATE_PRIMARY    The Primary Backbone Router.\n\n @sa otBackboneRouterSetEnabled\n @sa otBackboneRouterGetConfig\n @sa otBackboneRouterSetConfig\n @sa otBackboneRouterRegister\n"]
    pub fn otBackboneRouterGetState(aInstance: *mut otInstance) -> otBackboneRouterState;
}
extern "C" {
    #[doc = " Gets the local Backbone Router configuration.\n\n Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE` is enabled.\n\n @param[in]   aInstance            A pointer to an OpenThread instance.\n @param[out]  aConfig              A pointer where to put local Backbone Router configuration.\n\n\n @sa otBackboneRouterSetEnabled\n @sa otBackboneRouterGetState\n @sa otBackboneRouterSetConfig\n @sa otBackboneRouterRegister\n"]
    pub fn otBackboneRouterGetConfig(
        aInstance: *mut otInstance,
        aConfig: *mut otBackboneRouterConfig,
    );
}
extern "C" {
    #[doc = " Sets the local Backbone Router configuration #otBackboneRouterConfig.\n\n A Server Data Request message `SRV_DATA.ntf` is initiated automatically if BBR Dataset changes for Primary\n Backbone Router.\n\n Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE` is enabled.\n\n @param[in]  aInstance             A pointer to an OpenThread instance.\n @param[in]  aConfig               A pointer to the Backbone Router configuration to take effect.\n\n @retval OT_ERROR_NONE          Successfully updated configuration.\n @retval OT_ERROR_INVALID_ARGS  The configuration in @p aConfig is invalid.\n\n @sa otBackboneRouterSetEnabled\n @sa otBackboneRouterGetState\n @sa otBackboneRouterGetConfig\n @sa otBackboneRouterRegister\n"]
    pub fn otBackboneRouterSetConfig(
        aInstance: *mut otInstance,
        aConfig: *const otBackboneRouterConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Explicitly registers local Backbone Router configuration.\n\n A Server Data Request message `SRV_DATA.ntf` is triggered for the attached device.\n\n Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE` is enabled.\n\n @param[in]  aInstance             A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NO_BUFS           Insufficient space to add the Backbone Router service.\n @retval OT_ERROR_NONE              Successfully queued a Server Data Request message for delivery.\n\n @sa otBackboneRouterSetEnabled\n @sa otBackboneRouterGetState\n @sa otBackboneRouterGetConfig\n @sa otBackboneRouterSetConfig\n"]
    pub fn otBackboneRouterRegister(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This method returns the Backbone Router registration jitter value.\n\n @returns The Backbone Router registration jitter value.\n\n @sa otBackboneRouterSetRegistrationJitter\n"]
    pub fn otBackboneRouterGetRegistrationJitter(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " This method sets the Backbone Router registration jitter value.\n\n @param[in]  aJitter the Backbone Router registration jitter value to set.\n\n @sa otBackboneRouterGetRegistrationJitter\n"]
    pub fn otBackboneRouterSetRegistrationJitter(aInstance: *mut otInstance, aJitter: u8);
}
extern "C" {
    #[doc = " This method gets the local Domain Prefix configuration.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[out] aConfig   A pointer to the Domain Prefix configuration.\n\n @retval OT_ERROR_NONE       Successfully got the Domain Prefix configuration.\n @retval OT_ERROR_NOT_FOUND  No Domain Prefix was configured.\n"]
    pub fn otBackboneRouterGetDomainPrefix(
        aInstance: *mut otInstance,
        aConfig: *mut otBorderRouterConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This method configures response status for next DUA registration.\n\n Note: available only when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled.\n       Only used for test and certification.\n\n TODO: (DUA) support coap error code and corresponding process for certification purpose.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n @param[in] aMlIid    A pointer to the Mesh Local IID. If NULL, respond with @p aStatus for any\n                      coming DUA.req, otherwise only respond the one with matching @p aMlIid.\n @param[in] aStatus   The status to respond.\n\n"]
    pub fn otBackboneRouterConfigNextDuaRegistrationResponse(
        aInstance: *mut otInstance,
        aMlIid: *const otIp6InterfaceIdentifier,
        aStatus: u8,
    );
}
extern "C" {
    #[doc = " Configures the response status for the next Multicast Listener Registration.\n\n Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE`,\n `OPENTHREAD_CONFIG_BACKBONE_ROUTER_MULTICAST_ROUTING_ENABLE`, and\n `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` are enabled.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n @param[in] aStatus    The status to respond.\n"]
    pub fn otBackboneRouterConfigNextMulticastListenerRegistrationResponse(
        aInstance: *mut otInstance,
        aStatus: u8,
    );
}
#[doc = "< Multicast Listener was added."]
pub const OT_BACKBONE_ROUTER_MULTICAST_LISTENER_ADDED: otBackboneRouterMulticastListenerEvent = 0;
#[doc = "< Multicast Listener was removed or expired."]
pub const OT_BACKBONE_ROUTER_MULTICAST_LISTENER_REMOVED: otBackboneRouterMulticastListenerEvent = 1;
#[doc = " Represents the Multicast Listener events.\n"]
pub type otBackboneRouterMulticastListenerEvent = ::std::os::raw::c_uint;
#[doc = " This function pointer is called whenever the Multicast Listeners change.\n\n @param[in] aContext  The user context pointer.\n @param[in] aEvent    The Multicast Listener event.\n @param[in] aAddress  The IPv6 multicast address of the Multicast Listener.\n"]
pub type otBackboneRouterMulticastListenerCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aEvent: otBackboneRouterMulticastListenerEvent,
        aAddress: *const otIp6Address,
    ),
>;
extern "C" {
    #[doc = " This method sets the Backbone Router Multicast Listener callback.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n @param[in] aCallback  A pointer to the Multicast Listener callback.\n @param[in] aContext   A user context pointer.\n"]
    pub fn otBackboneRouterSetMulticastListenerCallback(
        aInstance: *mut otInstance,
        aCallback: otBackboneRouterMulticastListenerCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Clears the Multicast Listeners.\n\n Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE`,\n `OPENTHREAD_CONFIG_BACKBONE_ROUTER_MULTICAST_ROUTING_ENABLE`, and\n `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` are enabled.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @sa otBackboneRouterMulticastListenerAdd\n @sa otBackboneRouterMulticastListenerGetNext\n"]
    pub fn otBackboneRouterMulticastListenerClear(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Adds a Multicast Listener with a timeout value, in seconds.\n\n Pass `0` to use the default MLR timeout.\n\n Available when `OPENTHREAD_CONFIG_BACKBONE_ROUTER_ENABLE`,\n `OPENTHREAD_CONFIG_BACKBONE_ROUTER_MULTICAST_ROUTING_ENABLE`, and\n `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` are enabled.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n @param[in] aAddress   The Multicast Listener address.\n @param[in] aTimeout   The timeout (in seconds) of the Multicast Listener, or 0 to use the default MLR timeout.\n\n @retval OT_ERROR_NONE          If the Multicast Listener was successfully added.\n @retval OT_ERROR_INVALID_ARGS  If the Multicast Listener address was invalid.\n @retval OT_ERROR_NO_BUFS       No space available to save the Multicast Listener.\n\n @sa otBackboneRouterMulticastListenerClear\n @sa otBackboneRouterMulticastListenerGetNext\n"]
    pub fn otBackboneRouterMulticastListenerAdd(
        aInstance: *mut otInstance,
        aAddress: *const otIp6Address,
        aTimeout: u32,
    ) -> otError;
}
pub type otBackboneRouterMulticastListenerIterator = u16;
#[doc = " This structure represents a Backbone Router Multicast Listener info.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otBackboneRouterMulticastListenerInfo {
    pub mAddress: otIp6Address,
    pub mTimeout: u32,
}
impl Default for otBackboneRouterMulticastListenerInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function gets the next Multicast Listener info (using an iterator).\n\n @param[in]      aInstance      A pointer to an OpenThread instance.\n @param[in,out]  aIterator      A pointer to the iterator. On success the iterator will be updated to point to next\n                                Multicast Listener. To get the first entry the iterator should be set to\n                                OT_BACKBONE_ROUTER_MULTICAST_LISTENER_ITERATOR_INIT.\n @param[out]     aListenerInfo  A pointer to an `otBackboneRouterMulticastListenerInfo` where information of next\n                                Multicast Listener is placed (on success).\n\n @retval OT_ERROR_NONE       Successfully found the next Multicast Listener info (@p aListenerInfo was successfully\n                             updated).\n @retval OT_ERROR_NOT_FOUND  No subsequent Multicast Listener info was found.\n\n @sa otBackboneRouterMulticastListenerClear\n @sa otBackboneRouterMulticastListenerAdd\n"]
    pub fn otBackboneRouterMulticastListenerGetNext(
        aInstance: *mut otInstance,
        aIterator: *mut otBackboneRouterMulticastListenerIterator,
        aListenerInfo: *mut otBackboneRouterMulticastListenerInfo,
    ) -> otError;
}
#[doc = "< ND Proxy was added."]
pub const OT_BACKBONE_ROUTER_NDPROXY_ADDED: otBackboneRouterNdProxyEvent = 0;
#[doc = "< ND Proxy was removed."]
pub const OT_BACKBONE_ROUTER_NDPROXY_REMOVED: otBackboneRouterNdProxyEvent = 1;
#[doc = "< ND Proxy was renewed."]
pub const OT_BACKBONE_ROUTER_NDPROXY_RENEWED: otBackboneRouterNdProxyEvent = 2;
#[doc = "< All ND Proxies were cleared."]
pub const OT_BACKBONE_ROUTER_NDPROXY_CLEARED: otBackboneRouterNdProxyEvent = 3;
#[doc = " Represents the ND Proxy events.\n"]
pub type otBackboneRouterNdProxyEvent = ::std::os::raw::c_uint;
#[doc = " This function pointer is called whenever the Nd Proxy changed.\n\n @param[in] aContext  The user context pointer.\n @param[in] aEvent    The ND Proxy event.\n @param[in] aDua      The Domain Unicast Address of the ND Proxy, or `nullptr` if @p aEvent is\n                      `OT_BACKBONE_ROUTER_NDPROXY_CLEARED`.\n"]
pub type otBackboneRouterNdProxyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aEvent: otBackboneRouterNdProxyEvent,
        aDua: *const otIp6Address,
    ),
>;
extern "C" {
    #[doc = " This method sets the Backbone Router ND Proxy callback.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n @param[in] aCallback  A pointer to the ND Proxy callback.\n @param[in] aContext   A user context pointer.\n"]
    pub fn otBackboneRouterSetNdProxyCallback(
        aInstance: *mut otInstance,
        aCallback: otBackboneRouterNdProxyCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
#[doc = " Represents the Backbone Router ND Proxy info.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otBackboneRouterNdProxyInfo {
    #[doc = "< Mesh-local IID"]
    pub mMeshLocalIid: *mut otIp6InterfaceIdentifier,
    #[doc = "< Time since last transaction (Seconds)"]
    pub mTimeSinceLastTransaction: u32,
    #[doc = "< RLOC16"]
    pub mRloc16: u16,
}
impl Default for otBackboneRouterNdProxyInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This method gets the Backbone Router ND Proxy info.\n\n @param[in]   aInstance     A pointer to an OpenThread instance.\n @param[in]   aDua          The Domain Unicast Address.\n @param[out]  aNdProxyInfo  A pointer to the ND Proxy info.\n\n @retval OT_ERROR_NONE       Successfully got the ND Proxy info.\n @retval OT_ERROR_NOT_FOUND  Failed to find the Domain Unicast Address in the ND Proxy table.\n"]
    pub fn otBackboneRouterGetNdProxyInfo(
        aInstance: *mut otInstance,
        aDua: *const otIp6Address,
        aNdProxyInfo: *mut otBackboneRouterNdProxyInfo,
    ) -> otError;
}
#[doc = "< Domain Prefix was added."]
pub const OT_BACKBONE_ROUTER_DOMAIN_PREFIX_ADDED: otBackboneRouterDomainPrefixEvent = 0;
#[doc = "< Domain Prefix was removed."]
pub const OT_BACKBONE_ROUTER_DOMAIN_PREFIX_REMOVED: otBackboneRouterDomainPrefixEvent = 1;
#[doc = "< Domain Prefix was changed."]
pub const OT_BACKBONE_ROUTER_DOMAIN_PREFIX_CHANGED: otBackboneRouterDomainPrefixEvent = 2;
#[doc = " Represents the Domain Prefix events.\n"]
pub type otBackboneRouterDomainPrefixEvent = ::std::os::raw::c_uint;
#[doc = " This function pointer is called whenever the Domain Prefix changed.\n\n @param[in] aContext       The user context pointer.\n @param[in] aEvent         The Domain Prefix event.\n @param[in] aDomainPrefix  The new Domain Prefix if added or changed, nullptr otherwise.\n"]
pub type otBackboneRouterDomainPrefixCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aEvent: otBackboneRouterDomainPrefixEvent,
        aDomainPrefix: *const otIp6Prefix,
    ),
>;
extern "C" {
    #[doc = " This method sets the Backbone Router Domain Prefix callback.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n @param[in] aCallback  A pointer to the Domain Prefix callback.\n @param[in] aContext   A user context pointer.\n"]
    pub fn otBackboneRouterSetDomainPrefixCallback(
        aInstance: *mut otInstance,
        aCallback: otBackboneRouterDomainPrefixCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
#[doc = " @struct otBorderAgentId\n\n This structure represents a Border Agent ID.\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otBorderAgentId {
    pub mId: [u8; 16usize],
}
#[doc = "< Border agent role is disabled."]
pub const OT_BORDER_AGENT_STATE_STOPPED: otBorderAgentState = 0;
#[doc = "< Border agent is started."]
pub const OT_BORDER_AGENT_STATE_STARTED: otBorderAgentState = 1;
#[doc = "< Border agent is connected with external commissioner."]
pub const OT_BORDER_AGENT_STATE_ACTIVE: otBorderAgentState = 2;
#[doc = " This enumeration defines the Border Agent state.\n"]
pub type otBorderAgentState = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Gets the #otBorderAgentState of the Thread Border Agent role.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns The current #otBorderAgentState of the Border Agent.\n"]
    pub fn otBorderAgentGetState(aInstance: *mut otInstance) -> otBorderAgentState;
}
extern "C" {
    #[doc = " Gets the UDP port of the Thread Border Agent service.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns UDP port of the Border Agent.\n"]
    pub fn otBorderAgentGetUdpPort(aInstance: *mut otInstance) -> u16;
}
#[doc = " This structure represents an iterator to iterate through the Border Router's discovered prefix table.\n\n The fields in this type are opaque (intended for use by OpenThread core only) and therefore should not be\n accessed or used by caller.\n\n Before using an iterator, it MUST be initialized using `otBorderRoutingPrefixTableInitIterator()`.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otBorderRoutingPrefixTableIterator {
    pub mPtr1: *const ::std::os::raw::c_void,
    pub mPtr2: *const ::std::os::raw::c_void,
    pub mData32: u32,
}
impl Default for otBorderRoutingPrefixTableIterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents an entry from the discovered prefix table.\n\n The entries in the discovered table track the Prefix/Route Info Options in the received Router Advertisement messages\n from other routers on infrastructure link.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otBorderRoutingPrefixTableEntry {
    #[doc = "< IPv6 address of the router."]
    pub mRouterAddress: otIp6Address,
    #[doc = "< The discovered IPv6 prefix."]
    pub mPrefix: otIp6Prefix,
    #[doc = "< Indicates whether the prefix is on-link or route prefix."]
    pub mIsOnLink: bool,
    #[doc = "< Milliseconds since last update of this prefix."]
    pub mMsecSinceLastUpdate: u32,
    #[doc = "< Valid lifetime of the prefix (in seconds)."]
    pub mValidLifetime: u32,
    #[doc = "< Route preference when `mIsOnlink` is false."]
    pub mRoutePreference: otRoutePreference,
    #[doc = "< Preferred lifetime of the on-link prefix when `mIsOnLink` is true."]
    pub mPreferredLifetime: u32,
}
impl Default for otBorderRoutingPrefixTableEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Routing Manager is uninitialized."]
pub const OT_BORDER_ROUTING_STATE_UNINITIALIZED: otBorderRoutingState = 0;
#[doc = "< Routing Manager is initialized but disabled."]
pub const OT_BORDER_ROUTING_STATE_DISABLED: otBorderRoutingState = 1;
#[doc = "< Routing Manager in initialized and enabled but currently stopped."]
pub const OT_BORDER_ROUTING_STATE_STOPPED: otBorderRoutingState = 2;
#[doc = "< Routing Manager is initialized, enabled, and running."]
pub const OT_BORDER_ROUTING_STATE_RUNNING: otBorderRoutingState = 3;
#[doc = " This enumeration represents the state of Border Routing Manager.\n"]
pub type otBorderRoutingState = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This method initializes the Border Routing Manager on given infrastructure interface.\n\n @note  This method MUST be called before any other otBorderRouting* APIs.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aInfraIfIndex      The infrastructure interface index.\n @param[in]  aInfraIfIsRunning  A boolean that indicates whether the infrastructure\n                                interface is running.\n\n @retval  OT_ERROR_NONE           Successfully started the Border Routing Manager on given infrastructure.\n @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager has already been initialized.\n @retval  OT_ERROR_INVALID_ARGS   The index of the infrastructure interface is not valid.\n @retval  OT_ERROR_FAILED         Internal failure. Usually due to failure in generating random prefixes.\n\n @sa otPlatInfraIfStateChanged.\n"]
    pub fn otBorderRoutingInit(
        aInstance: *mut otInstance,
        aInfraIfIndex: u32,
        aInfraIfIsRunning: bool,
    ) -> otError;
}
extern "C" {
    #[doc = " Enables or disables the Border Routing Manager.\n\n @note  The Border Routing Manager is disabled by default.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aEnabled   A boolean to enable/disable the routing manager.\n\n @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not initialized yet.\n @retval  OT_ERROR_NONE           Successfully enabled/disabled the Border Routing Manager.\n"]
    pub fn otBorderRoutingSetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " Gets the current state of Border Routing Manager.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns The current state of Border Routing Manager.\n"]
    pub fn otBorderRoutingGetState(aInstance: *mut otInstance) -> otBorderRoutingState;
}
extern "C" {
    #[doc = " This function gets the current preference used when advertising Route Info Options (RIO) in Router Advertisement\n messages sent over the infrastructure link.\n\n The RIO preference is determined as follows:\n\n - If explicitly set by user by calling `otBorderRoutingSetRouteInfoOptionPreference()`, the given preference is\n   used.\n - Otherwise, it is determined based on device's current role: Medium preference when in router/leader role and\n   low preference when in child role.\n\n @returns The current Route Info Option preference.\n"]
    pub fn otBorderRoutingGetRouteInfoOptionPreference(
        aInstance: *mut otInstance,
    ) -> otRoutePreference;
}
extern "C" {
    #[doc = " This function explicitly sets the preference to use when advertising Route Info Options (RIO) in Router\n Advertisement messages sent over the infrastructure link.\n\n After a call to this function, BR will use the given preference for all its advertised RIOs. The preference can be\n cleared by calling `otBorderRoutingClearRouteInfoOptionPreference()`.\n\n @param[in] aInstance     A pointer to an OpenThread instance.\n @param[in] aPreference   The route preference to use.\n"]
    pub fn otBorderRoutingSetRouteInfoOptionPreference(
        aInstance: *mut otInstance,
        aPreference: otRoutePreference,
    );
}
extern "C" {
    #[doc = " This function clears a previously set preference value for advertised Route Info Options.\n\n After a call to this function, BR will use device's role to determine the RIO preference: Medium preference when\n in router/leader role and low preference when in child role.\n\n @param[in] aInstance     A pointer to an OpenThread instance.\n"]
    pub fn otBorderRoutingClearRouteInfoOptionPreference(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets the local Off-Mesh-Routable (OMR) Prefix, for example `fdfc:1ff5:1512:5622::/64`.\n\n An OMR Prefix is a randomly generated 64-bit prefix that's published in the\n Thread network if there isn't already an OMR prefix. This prefix can be reached\n from the local Wi-Fi or Ethernet network.\n\n @param[in]   aInstance  A pointer to an OpenThread instance.\n @param[out]  aPrefix    A pointer to where the prefix will be output to.\n\n @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not initialized yet.\n @retval  OT_ERROR_NONE           Successfully retrieved the OMR prefix.\n"]
    pub fn otBorderRoutingGetOmrPrefix(
        aInstance: *mut otInstance,
        aPrefix: *mut otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the currently favored Off-Mesh-Routable (OMR) Prefix.\n\n The favored OMR prefix can be discovered from Network Data or can be this device's local OMR prefix.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aPrefix      A pointer to output the favored OMR prefix.\n @param[out]  aPreference  A pointer to output the preference associated the favored prefix.\n\n @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not running yet.\n @retval  OT_ERROR_NONE           Successfully retrieved the favored OMR prefix.\n"]
    pub fn otBorderRoutingGetFavoredOmrPrefix(
        aInstance: *mut otInstance,
        aPrefix: *mut otIp6Prefix,
        aPreference: *mut otRoutePreference,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the local On-Link Prefix for the adjacent infrastructure link.\n\n The local On-Link Prefix is a 64-bit prefix that's advertised on the infrastructure link if there isn't already a\n usable on-link prefix being advertised on the link.\n\n @param[in]   aInstance  A pointer to an OpenThread instance.\n @param[out]  aPrefix    A pointer to where the prefix will be output to.\n\n @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not initialized yet.\n @retval  OT_ERROR_NONE           Successfully retrieved the local on-link prefix.\n"]
    pub fn otBorderRoutingGetOnLinkPrefix(
        aInstance: *mut otInstance,
        aPrefix: *mut otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the currently favored On-Link Prefix.\n\n The favored prefix is either a discovered on-link prefix on the infrastructure link or the local on-link prefix.\n\n @param[in]   aInstance  A pointer to an OpenThread instance.\n @param[out]  aPrefix    A pointer to where the prefix will be output to.\n\n @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not initialized yet.\n @retval  OT_ERROR_NONE           Successfully retrieved the favored on-link prefix.\n"]
    pub fn otBorderRoutingGetFavoredOnLinkPrefix(
        aInstance: *mut otInstance,
        aPrefix: *mut otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the local NAT64 Prefix of the Border Router.\n\n NAT64 Prefix might not be advertised in the Thread network.\n\n `OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE` must be enabled.\n\n @param[in]   aInstance   A pointer to an OpenThread instance.\n @param[out]  aPrefix     A pointer to where the prefix will be output to.\n\n @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not initialized yet.\n @retval  OT_ERROR_NONE           Successfully retrieved the NAT64 prefix.\n"]
    pub fn otBorderRoutingGetNat64Prefix(
        aInstance: *mut otInstance,
        aPrefix: *mut otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the currently favored NAT64 prefix.\n\n The favored NAT64 prefix can be discovered from infrastructure link or can be this device's local NAT64 prefix.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aPrefix      A pointer to output the favored NAT64 prefix.\n @param[out]  aPreference  A pointer to output the preference associated the favored prefix.\n\n @retval  OT_ERROR_INVALID_STATE  The Border Routing Manager is not initialized yet.\n @retval  OT_ERROR_NONE           Successfully retrieved the favored NAT64 prefix.\n"]
    pub fn otBorderRoutingGetFavoredNat64Prefix(
        aInstance: *mut otInstance,
        aPrefix: *mut otIp6Prefix,
        aPreference: *mut otRoutePreference,
    ) -> otError;
}
extern "C" {
    #[doc = " This function initializes an `otBorderRoutingPrefixTableIterator`.\n\n An iterator MUST be initialized before it is used.\n\n An iterator can be initialized again to restart from the beginning of the table.\n\n When iterating over entries in the table, to ensure the update times `mMsecSinceLastUpdate` of entries are\n consistent, they are given relative to the time the iterator was initialized.\n\n @param[in]  aInstance  The OpenThread instance.\n @param[out] aIterator  A pointer to the iterator to initialize.\n"]
    pub fn otBorderRoutingPrefixTableInitIterator(
        aInstance: *mut otInstance,
        aIterator: *mut otBorderRoutingPrefixTableIterator,
    );
}
extern "C" {
    #[doc = " This function iterates over the entries in the Border Router's discovered prefix table.\n\n @param[in]     aInstance    The OpenThread instance.\n @param[in,out] aIterator    A pointer to the iterator.\n @param[out]    aEntry       A pointer to the entry to populate.\n\n @retval OT_ERROR_NONE        Iterated to the next entry, @p aEntry and @p aIterator are updated.\n @retval OT_ERROR_NOT_FOUND   No more entries in the table.\n"]
    pub fn otBorderRoutingGetNextPrefixTableEntry(
        aInstance: *mut otInstance,
        aIterator: *mut otBorderRoutingPrefixTableIterator,
        aEntry: *mut otBorderRoutingPrefixTableEntry,
    ) -> otError;
}
extern "C" {
    #[doc = " This method provides a full or stable copy of the local Thread Network Data.\n\n @param[in]      aInstance    A pointer to an OpenThread instance.\n @param[in]      aStable      TRUE when copying the stable version, FALSE when copying the full version.\n @param[out]     aData        A pointer to the data buffer.\n @param[in,out]  aDataLength  On entry, size of the data buffer pointed to by @p aData.\n                              On exit, number of copied bytes."]
    pub fn otBorderRouterGetNetData(
        aInstance: *mut otInstance,
        aStable: bool,
        aData: *mut u8,
        aDataLength: *mut u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Add a border router configuration to the local network data.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aConfig   A pointer to the border router configuration.\n\n @retval OT_ERROR_NONE          Successfully added the configuration to the local network data.\n @retval OT_ERROR_INVALID_ARGS  One or more configuration parameters were invalid.\n @retval OT_ERROR_NO_BUFS       Not enough room is available to add the configuration to the local network data.\n\n @sa otBorderRouterRemoveOnMeshPrefix\n @sa otBorderRouterRegister"]
    pub fn otBorderRouterAddOnMeshPrefix(
        aInstance: *mut otInstance,
        aConfig: *const otBorderRouterConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove a border router configuration from the local network data.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aPrefix   A pointer to an IPv6 prefix.\n\n @retval OT_ERROR_NONE       Successfully removed the configuration from the local network data.\n @retval OT_ERROR_NOT_FOUND  Could not find the Border Router entry.\n\n @sa otBorderRouterAddOnMeshPrefix\n @sa otBorderRouterRegister"]
    pub fn otBorderRouterRemoveOnMeshPrefix(
        aInstance: *mut otInstance,
        aPrefix: *const otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the next On Mesh Prefix in the local Network Data.\n\n @param[in]      aInstance  A pointer to an OpenThread instance.\n @param[in,out]  aIterator  A pointer to the Network Data iterator context. To get the first on-mesh entry\nit should be set to OT_NETWORK_DATA_ITERATOR_INIT.\n @param[out]     aConfig    A pointer to the On Mesh Prefix information.\n\n @retval OT_ERROR_NONE       Successfully found the next On Mesh prefix.\n @retval OT_ERROR_NOT_FOUND  No subsequent On Mesh prefix exists in the Thread Network Data.\n"]
    pub fn otBorderRouterGetNextOnMeshPrefix(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aConfig: *mut otBorderRouterConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Add an external route configuration to the local network data.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aConfig   A pointer to the external route configuration.\n\n @retval OT_ERROR_NONE          Successfully added the configuration to the local network data.\n @retval OT_ERROR_INVALID_ARGS  One or more configuration parameters were invalid.\n @retval OT_ERROR_NO_BUFS       Not enough room is available to add the configuration to the local network data.\n\n @sa otBorderRouterRemoveRoute\n @sa otBorderRouterRegister"]
    pub fn otBorderRouterAddRoute(
        aInstance: *mut otInstance,
        aConfig: *const otExternalRouteConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove an external route configuration from the local network data.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aPrefix   A pointer to an IPv6 prefix.\n\n @retval OT_ERROR_NONE       Successfully removed the configuration from the local network data.\n @retval OT_ERROR_NOT_FOUND  Could not find the Border Router entry.\n\n @sa otBorderRouterAddRoute\n @sa otBorderRouterRegister"]
    pub fn otBorderRouterRemoveRoute(
        aInstance: *mut otInstance,
        aPrefix: *const otIp6Prefix,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the next external route in the local Network Data.\n\n @param[in]      aInstance  A pointer to an OpenThread instance.\n @param[in,out]  aIterator  A pointer to the Network Data iterator context. To get the first external route entry\nit should be set to OT_NETWORK_DATA_ITERATOR_INIT.\n @param[out]     aConfig    A pointer to the External Route information.\n\n @retval OT_ERROR_NONE       Successfully found the next External Route.\n @retval OT_ERROR_NOT_FOUND  No subsequent external route entry exists in the Thread Network Data.\n"]
    pub fn otBorderRouterGetNextRoute(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aConfig: *mut otExternalRouteConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Immediately register the local network data with the Leader.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE  Successfully queued a Server Data Request message for delivery.\n\n @sa otBorderRouterAddOnMeshPrefix\n @sa otBorderRouterRemoveOnMeshPrefix\n @sa otBorderRouterAddRoute\n @sa otBorderRouterRemoveRoute"]
    pub fn otBorderRouterRegister(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Requests a Thread network channel change.\n\n The network switches to the given channel after a specified delay (see #otChannelManagerSetDelay()). The channel\n change is performed by updating the Pending Operational Dataset.\n\n A subsequent call will cancel an ongoing previously requested channel change.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aChannel           The new channel for the Thread network.\n"]
    pub fn otChannelManagerRequestChannelChange(aInstance: *mut otInstance, aChannel: u8);
}
extern "C" {
    #[doc = " This function gets the channel from the last successful call to `otChannelManagerRequestChannelChange()`\n\n @returns The last requested channel or zero if there has been no channel change request yet.\n"]
    pub fn otChannelManagerGetRequestedChannel(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " This function gets the delay (in seconds) used by Channel Manager for a channel change.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n\n @returns The delay (in seconds) for channel change.\n"]
    pub fn otChannelManagerGetDelay(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the delay (in seconds) used for a channel change.\n\n The delay should preferably be longer than the maximum data poll interval used by all sleepy-end-devices within the\n Thread network.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aDelay             Delay in seconds.\n\n @retval OT_ERROR_NONE          Delay was updated successfully.\n @retval OT_ERROR_INVALID_ARGS  The given delay @p aDelay is too short.\n"]
    pub fn otChannelManagerSetDelay(aInstance: *mut otInstance, aDelay: u16) -> otError;
}
extern "C" {
    #[doc = " This function requests that `ChannelManager` checks and selects a new channel and starts a channel change.\n\n Unlike the `otChannelManagerRequestChannelChange()` where the channel must be given as a parameter, this function\n asks the `ChannelManager` to select a channel by itself (based on collected channel quality info).\n\n Once called, the Channel Manager will perform the following 3 steps:\n\n 1) `ChannelManager` decides if the channel change would be helpful. This check can be skipped if\n    `aSkipQualityCheck` is set to true (forcing a channel selection to happen and skipping the quality check).\n    This step uses the collected link quality metrics on the device (such as CCA failure rate, frame and message\n    error rates per neighbor, etc.) to determine if the current channel quality is at the level that justifies\n    a channel change.\n\n 2) If the first step passes, then `ChannelManager` selects a potentially better channel. It uses the collected\n    channel quality data by `ChannelMonitor` module. The supported and favored channels are used at this step.\n    (see otChannelManagerSetSupportedChannels() and otChannelManagerSetFavoredChannels()).\n\n 3) If the newly selected channel is different from the current channel, `ChannelManager` requests/starts the\n    channel change process (internally invoking a `RequestChannelChange()`).\n\n @param[in] aInstance                A pointer to an OpenThread instance.\n @param[in] aSkipQualityCheck        Indicates whether the quality check (step 1) should be skipped.\n\n @retval OT_ERROR_NONE               Channel selection finished successfully.\n @retval OT_ERROR_NOT_FOUND          Supported channel mask is empty, therefore could not select a channel.\n"]
    pub fn otChannelManagerRequestChannelSelect(
        aInstance: *mut otInstance,
        aSkipQualityCheck: bool,
    ) -> otError;
}
extern "C" {
    #[doc = " Enables or disables the auto-channel-selection functionality.\n\n When enabled, `ChannelManager` will periodically invoke a `RequestChannelSelect(false)`. The period interval\n can be set by `SetAutoChannelSelectionInterval()`.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aEnabled     Indicates whether to enable or disable this functionality.\n"]
    pub fn otChannelManagerSetAutoChannelSelectionEnabled(
        aInstance: *mut otInstance,
        aEnabled: bool,
    );
}
extern "C" {
    #[doc = " This function indicates whether the auto-channel-selection functionality is enabled or not.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n\n @returns TRUE if enabled, FALSE if disabled.\n"]
    pub fn otChannelManagerGetAutoChannelSelectionEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Sets the period interval (in seconds) used by auto-channel-selection functionality.\n\n @param[in] aInstance   A pointer to an OpenThread instance.\n @param[in] aInterval   The interval in seconds.\n\n @retval OT_ERROR_NONE           The interval was set successfully.\n @retval OT_ERROR_INVALID_ARGS   The @p aInterval is not valid (zero).\n"]
    pub fn otChannelManagerSetAutoChannelSelectionInterval(
        aInstance: *mut otInstance,
        aInterval: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the period interval (in seconds) used by auto-channel-selection functionality.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n\n @returns The interval in seconds.\n"]
    pub fn otChannelManagerGetAutoChannelSelectionInterval(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Gets the supported channel mask.\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n\n @returns  The supported channels as a bit-mask.\n"]
    pub fn otChannelManagerGetSupportedChannels(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the supported channel mask.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aChannelMask  A channel mask.\n"]
    pub fn otChannelManagerSetSupportedChannels(aInstance: *mut otInstance, aChannelMask: u32);
}
extern "C" {
    #[doc = " Gets the favored channel mask.\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n\n @returns  The favored channels as a bit-mask.\n"]
    pub fn otChannelManagerGetFavoredChannels(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the favored channel mask.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aChannelMask  A channel mask.\n"]
    pub fn otChannelManagerSetFavoredChannels(aInstance: *mut otInstance, aChannelMask: u32);
}
extern "C" {
    #[doc = " Gets the CCA failure rate threshold.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n\n @returns  The CCA failure rate threshold. Value 0 maps to 0% and 0xffff maps to 100%.\n"]
    pub fn otChannelManagerGetCcaFailureRateThreshold(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the CCA failure rate threshold.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aThreshold    A CCA failure rate threshold. Value 0 maps to 0% and 0xffff maps to 100%.\n"]
    pub fn otChannelManagerSetCcaFailureRateThreshold(aInstance: *mut otInstance, aThreshold: u16);
}
extern "C" {
    #[doc = " Enables or disables the Channel Monitoring operation.\n\n Once operation starts, any previously collected data is cleared. However, after operation is disabled, the previous\n collected data is still valid and can be read.\n\n @note OpenThread core internally enables or disables the Channel Monitoring operation when the IPv6 interface is\n brought up or down, for example in a call to `otIp6SetEnabled()`.\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n @param[in]  aEnabled        TRUE to enable/start Channel Monitoring operation, FALSE to disable/stop it.\n\n @retval OT_ERROR_NONE      Channel Monitoring state changed successfully\n @retval OT_ERROR_ALREADY   Channel Monitoring is already in the same state.\n"]
    pub fn otChannelMonitorSetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether the Channel Monitoring operation is enabled and running.\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n\n @returns TRUE if the Channel Monitoring operation is enabled, FALSE otherwise.\n"]
    pub fn otChannelMonitorIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get channel monitoring sample interval in milliseconds.\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n\n @returns  The channel monitor sample interval in milliseconds.\n"]
    pub fn otChannelMonitorGetSampleInterval(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Get channel monitoring RSSI threshold in dBm.\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n\n @returns  The RSSI threshold in dBm.\n"]
    pub fn otChannelMonitorGetRssiThreshold(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Get channel monitoring averaging sample window length (number of samples).\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n\n @returns  The averaging sample window.\n"]
    pub fn otChannelMonitorGetSampleWindow(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Get channel monitoring total number of RSSI samples (per channel).\n\n The count indicates total number samples per channel by channel monitoring module since its start (since Thread\n network interface was enabled).\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n\n @returns  Total number of RSSI samples (per channel) taken so far.\n"]
    pub fn otChannelMonitorGetSampleCount(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Gets the current channel occupancy for a given channel.\n\n The channel occupancy value represents the average rate/percentage of RSSI samples that were above RSSI threshold\n (\"bad\" RSSI samples).\n\n For the first \"sample window\" samples, the average is maintained as the actual percentage (i.e., ratio of number\n of \"bad\" samples by total number of samples). After \"window\" samples, the averager uses an exponentially\n weighted moving average. Practically, this means the average is representative of up to `3 * window` last samples\n with highest weight given to the latest `kSampleWindow` samples.\n\n Max value of `0xffff` indicates all RSSI samples were above RSSI threshold (i.e. 100% of samples were \"bad\").\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n @param[in]  aChannel        The channel for which to get the link occupancy.\n\n @returns The current channel occupancy for the given channel.\n"]
    pub fn otChannelMonitorGetChannelOccupancy(aInstance: *mut otInstance, aChannel: u8) -> u16;
}
extern "C" {
    #[doc = " Gets the child supervision interval (in seconds) on a child.\n\n Child supervision feature provides a mechanism for a sleepy child to ask its parent to ensure to send a message to\n it within the supervision interval. If there is no transmission to the child within the supervision interval,\n parent sends a supervision message (a data message with empty payload) to the child.\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n\n @returns  The child supervision interval. Zero indicates that supervision is disabled.\n"]
    pub fn otChildSupervisionGetInterval(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the child supervision interval (in seconds) on the child.\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n @param[in]  aInterval       The supervision interval (in seconds). Zero to disable supervision.\n"]
    pub fn otChildSupervisionSetInterval(aInstance: *mut otInstance, aInterval: u16);
}
extern "C" {
    #[doc = " Gets the supervision check timeout interval (in seconds) on the child.\n\n If the device is a sleepy child and it does not hear from its parent within the specified check timeout, it initiates\n the re-attach process (MLE Child Update Request/Response exchange with its parent).\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n\n @returns  The supervision check timeout. Zero indicates that supervision check on the child is disabled.\n"]
    pub fn otChildSupervisionGetCheckTimeout(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the supervision check timeout interval (in seconds).\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n @param[in]  aTimeout        The check timeout (in seconds). Zero to disable supervision check on the child.\n"]
    pub fn otChildSupervisionSetCheckTimeout(aInstance: *mut otInstance, aTimeout: u16);
}
extern "C" {
    #[doc = " Get the value of supervision check timeout failure counter.\n\n The counter tracks the number of supervision check failures on the child. It is incremented when the child does\n not hear from its parent within the specified check timeout interval.\n"]
    pub fn otChildSupervisionGetCheckFailureCounter(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Reset the supervision check timeout failure counter to zero.\n"]
    pub fn otChildSupervisionResetCheckFailureCounter(aInstance: *mut otInstance);
}
#[doc = " This structure represents a CLI command.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCliCommand {
    #[doc = "< A pointer to the command string."]
    pub mName: *const ::std::os::raw::c_char,
    pub mCommand: ::std::option::Option<
        unsafe extern "C" fn(
            aContext: *mut ::std::os::raw::c_void,
            aArgsLength: u8,
            aArgs: *mut *mut ::std::os::raw::c_char,
        ) -> otError,
    >,
}
impl Default for otCliCommand {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This function pointer is called to notify about Console output.\n\n @param[out] aContext    A user context pointer.\n @param[in]  aFormat     The format string.\n @param[in]  aArguments  The format string arguments.\n\n @returns                Number of bytes written by the callback.\n"]
pub type otCliOutputCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aFormat: *const ::std::os::raw::c_char,
        aArguments: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Initialize the CLI module.\n\n @param[in]  aInstance   The OpenThread instance structure.\n @param[in]  aCallback   A callback method called to process CLI output.\n @param[in]  aContext    A user context pointer.\n"]
    pub fn otCliInit(
        aInstance: *mut otInstance,
        aCallback: otCliOutputCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This method is called to feed in a console input line.\n\n @param[in]  aBuf        A pointer to a null-terminated string.\n"]
    pub fn otCliInputLine(aBuf: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set a user command table.\n\n @param[in]  aUserCommands  A pointer to an array with user commands.\n @param[in]  aLength        @p aUserCommands length.\n @param[in]  aContext       @p The context passed to the handler.\n\n @retval OT_ERROR_NONE    Successfully updated command table with commands from @p aUserCommands.\n @retval OT_ERROR_FAILED  Maximum number of command entries have already been set."]
    pub fn otCliSetUserCommands(
        aUserCommands: *const otCliCommand,
        aLength: u8,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Write a number of bytes to the CLI console as a hex string.\n\n @param[in]  aBytes   A pointer to data which should be printed.\n @param[in]  aLength  @p aBytes length.\n"]
    pub fn otCliOutputBytes(aBytes: *const u8, aLength: u8);
}
extern "C" {
    #[doc = " Write formatted string to the CLI console\n\n @param[in]  aFmt   A pointer to the format string.\n @param[in]  ...    A matching list of arguments.\n"]
    pub fn otCliOutputFormat(aFmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Write error code to the CLI console\n\n If the @p aError is `OT_ERROR_PENDING` nothing will be outputted.\n\n @param[in]  aError Error code value.\n"]
    pub fn otCliAppendResult(aError: otError);
}
extern "C" {
    #[doc = " Callback to write the OpenThread Log to the CLI console\n\n @param[in]  aLogLevel   The log level.\n @param[in]  aLogRegion  The log region.\n @param[in]  aFormat     A pointer to the format string.\n @param[in]  aArgs       va_list matching aFormat.\n"]
    pub fn otCliPlatLogv(
        aLogLevel: otLogLevel,
        aLogRegion: otLogRegion,
        aFormat: *const ::std::os::raw::c_char,
        aArgs: *mut __va_list_tag,
    );
}
extern "C" {
    #[doc = " Callback to allow vendor specific commands to be added to the user command table.\n\n Available when `OPENTHREAD_CONFIG_CLI_VENDOR_COMMANDS_ENABLE` is enabled and\n `OPENTHREAD_CONFIG_CLI_MAX_USER_CMD_ENTRIES` is greater than 1.\n"]
    pub fn otCliVendorSetUserCommands();
}
#[doc = "< Confirmable"]
pub const OT_COAP_TYPE_CONFIRMABLE: otCoapType = 0;
#[doc = "< Non-confirmable"]
pub const OT_COAP_TYPE_NON_CONFIRMABLE: otCoapType = 1;
#[doc = "< Acknowledgment"]
pub const OT_COAP_TYPE_ACKNOWLEDGMENT: otCoapType = 2;
#[doc = "< Reset"]
pub const OT_COAP_TYPE_RESET: otCoapType = 3;
#[doc = " CoAP Type values (2 bit unsigned integer).\n"]
pub type otCoapType = ::std::os::raw::c_uint;
#[doc = "< Empty message code"]
pub const OT_COAP_CODE_EMPTY: otCoapCode = 0;
#[doc = "< Get"]
pub const OT_COAP_CODE_GET: otCoapCode = 1;
#[doc = "< Post"]
pub const OT_COAP_CODE_POST: otCoapCode = 2;
#[doc = "< Put"]
pub const OT_COAP_CODE_PUT: otCoapCode = 3;
#[doc = "< Delete"]
pub const OT_COAP_CODE_DELETE: otCoapCode = 4;
#[doc = "< 2.00"]
pub const OT_COAP_CODE_RESPONSE_MIN: otCoapCode = 64;
#[doc = "< Created"]
pub const OT_COAP_CODE_CREATED: otCoapCode = 65;
#[doc = "< Deleted"]
pub const OT_COAP_CODE_DELETED: otCoapCode = 66;
#[doc = "< Valid"]
pub const OT_COAP_CODE_VALID: otCoapCode = 67;
#[doc = "< Changed"]
pub const OT_COAP_CODE_CHANGED: otCoapCode = 68;
#[doc = "< Content"]
pub const OT_COAP_CODE_CONTENT: otCoapCode = 69;
#[doc = "< RFC7959 Continue"]
pub const OT_COAP_CODE_CONTINUE: otCoapCode = 95;
#[doc = "< Bad Request"]
pub const OT_COAP_CODE_BAD_REQUEST: otCoapCode = 128;
#[doc = "< Unauthorized"]
pub const OT_COAP_CODE_UNAUTHORIZED: otCoapCode = 129;
#[doc = "< Bad Option"]
pub const OT_COAP_CODE_BAD_OPTION: otCoapCode = 130;
#[doc = "< Forbidden"]
pub const OT_COAP_CODE_FORBIDDEN: otCoapCode = 131;
#[doc = "< Not Found"]
pub const OT_COAP_CODE_NOT_FOUND: otCoapCode = 132;
#[doc = "< Method Not Allowed"]
pub const OT_COAP_CODE_METHOD_NOT_ALLOWED: otCoapCode = 133;
#[doc = "< Not Acceptable"]
pub const OT_COAP_CODE_NOT_ACCEPTABLE: otCoapCode = 134;
#[doc = "< RFC7959 Request Entity Incomplete"]
pub const OT_COAP_CODE_REQUEST_INCOMPLETE: otCoapCode = 136;
#[doc = "< Precondition Failed"]
pub const OT_COAP_CODE_PRECONDITION_FAILED: otCoapCode = 140;
#[doc = "< Request Entity Too Large"]
pub const OT_COAP_CODE_REQUEST_TOO_LARGE: otCoapCode = 141;
#[doc = "< Unsupported Content-Format"]
pub const OT_COAP_CODE_UNSUPPORTED_FORMAT: otCoapCode = 143;
#[doc = "< Internal Server Error"]
pub const OT_COAP_CODE_INTERNAL_ERROR: otCoapCode = 160;
#[doc = "< Not Implemented"]
pub const OT_COAP_CODE_NOT_IMPLEMENTED: otCoapCode = 161;
#[doc = "< Bad Gateway"]
pub const OT_COAP_CODE_BAD_GATEWAY: otCoapCode = 162;
#[doc = "< Service Unavailable"]
pub const OT_COAP_CODE_SERVICE_UNAVAILABLE: otCoapCode = 163;
#[doc = "< Gateway Timeout"]
pub const OT_COAP_CODE_GATEWAY_TIMEOUT: otCoapCode = 164;
#[doc = "< Proxying Not Supported"]
pub const OT_COAP_CODE_PROXY_NOT_SUPPORTED: otCoapCode = 165;
#[doc = " CoAP Code values.\n"]
pub type otCoapCode = ::std::os::raw::c_uint;
#[doc = "< If-Match"]
pub const OT_COAP_OPTION_IF_MATCH: otCoapOptionType = 1;
#[doc = "< Uri-Host"]
pub const OT_COAP_OPTION_URI_HOST: otCoapOptionType = 3;
#[doc = "< ETag"]
pub const OT_COAP_OPTION_E_TAG: otCoapOptionType = 4;
#[doc = "< If-None-Match"]
pub const OT_COAP_OPTION_IF_NONE_MATCH: otCoapOptionType = 5;
#[doc = "< Observe [RFC7641]"]
pub const OT_COAP_OPTION_OBSERVE: otCoapOptionType = 6;
#[doc = "< Uri-Port"]
pub const OT_COAP_OPTION_URI_PORT: otCoapOptionType = 7;
#[doc = "< Location-Path"]
pub const OT_COAP_OPTION_LOCATION_PATH: otCoapOptionType = 8;
#[doc = "< Uri-Path"]
pub const OT_COAP_OPTION_URI_PATH: otCoapOptionType = 11;
#[doc = "< Content-Format"]
pub const OT_COAP_OPTION_CONTENT_FORMAT: otCoapOptionType = 12;
#[doc = "< Max-Age"]
pub const OT_COAP_OPTION_MAX_AGE: otCoapOptionType = 14;
#[doc = "< Uri-Query"]
pub const OT_COAP_OPTION_URI_QUERY: otCoapOptionType = 15;
#[doc = "< Accept"]
pub const OT_COAP_OPTION_ACCEPT: otCoapOptionType = 17;
#[doc = "< Location-Query"]
pub const OT_COAP_OPTION_LOCATION_QUERY: otCoapOptionType = 20;
#[doc = "< Block2 (RFC7959)"]
pub const OT_COAP_OPTION_BLOCK2: otCoapOptionType = 23;
#[doc = "< Block1 (RFC7959)"]
pub const OT_COAP_OPTION_BLOCK1: otCoapOptionType = 27;
#[doc = "< Size2 (RFC7959)"]
pub const OT_COAP_OPTION_SIZE2: otCoapOptionType = 28;
#[doc = "< Proxy-Uri"]
pub const OT_COAP_OPTION_PROXY_URI: otCoapOptionType = 35;
#[doc = "< Proxy-Scheme"]
pub const OT_COAP_OPTION_PROXY_SCHEME: otCoapOptionType = 39;
#[doc = "< Size1"]
pub const OT_COAP_OPTION_SIZE1: otCoapOptionType = 60;
#[doc = " CoAP Option Numbers"]
pub type otCoapOptionType = ::std::os::raw::c_uint;
#[doc = " This structure represents a CoAP option.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otCoapOption {
    #[doc = "< Option Number"]
    pub mNumber: u16,
    #[doc = "< Option Length"]
    pub mLength: u16,
}
#[doc = " This structure acts as an iterator for CoAP options\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCoapOptionIterator {
    #[doc = "< CoAP message"]
    pub mMessage: *const otMessage,
    #[doc = "< CoAP message option"]
    pub mOption: otCoapOption,
    #[doc = "< Byte offset of next option"]
    pub mNextOptionOffset: u16,
}
impl Default for otCoapOptionIterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " text/plain; charset=utf-8: [RFC2046][RFC3676][RFC5147]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_TEXT_PLAIN: otCoapOptionContentFormat = 0;
#[doc = " application/cose; cose-type=\"cose-encrypt0\": [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_ENCRYPT0: otCoapOptionContentFormat = 16;
#[doc = " application/cose; cose-type=\"cose-mac0\": [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_MAC0: otCoapOptionContentFormat = 17;
#[doc = " application/cose; cose-type=\"cose-sign1\": [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_SIGN1: otCoapOptionContentFormat = 18;
#[doc = " application/link-format: [RFC6690]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_LINK_FORMAT: otCoapOptionContentFormat = 40;
#[doc = " application/xml: [RFC3023]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_XML: otCoapOptionContentFormat = 41;
#[doc = " application/octet-stream: [RFC2045][RFC2046]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_OCTET_STREAM: otCoapOptionContentFormat = 42;
#[doc = " application/exi:\n [\"Efficient XML Interchange (EXI) Format 1.0 (Second Edition)\", February 2014]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_EXI: otCoapOptionContentFormat = 47;
#[doc = " application/json: [RFC7159]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_JSON: otCoapOptionContentFormat = 50;
#[doc = " application/json-patch+json: [RFC6902]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_JSON_PATCH_JSON: otCoapOptionContentFormat = 51;
#[doc = " application/merge-patch+json: [RFC7396]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_MERGE_PATCH_JSON: otCoapOptionContentFormat = 52;
#[doc = " application/cbor: [RFC7049]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_CBOR: otCoapOptionContentFormat = 60;
#[doc = " application/cwt: [RFC8392]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_CWT: otCoapOptionContentFormat = 61;
#[doc = " application/cose; cose-type=\"cose-encrypt\": [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_ENCRYPT: otCoapOptionContentFormat = 96;
#[doc = " application/cose; cose-type=\"cose-mac\": [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_MAC: otCoapOptionContentFormat = 97;
#[doc = " application/cose; cose-type=\"cose-sign\": [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_SIGN: otCoapOptionContentFormat = 98;
#[doc = " application/cose-key: [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_KEY: otCoapOptionContentFormat = 101;
#[doc = " application/cose-key-set: [RFC8152]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COSE_KEY_SET: otCoapOptionContentFormat = 102;
#[doc = " application/senml+json: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENML_JSON: otCoapOptionContentFormat = 110;
#[doc = " application/sensml+json: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENSML_JSON: otCoapOptionContentFormat = 111;
#[doc = " application/senml+cbor: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENML_CBOR: otCoapOptionContentFormat = 112;
#[doc = " application/sensml+cbor: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENSML_CBOR: otCoapOptionContentFormat = 113;
#[doc = " application/senml-exi: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENML_EXI: otCoapOptionContentFormat = 114;
#[doc = " application/sensml-exi: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENSML_EXI: otCoapOptionContentFormat = 115;
#[doc = " application/coap-group+json: [RFC7390]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_COAP_GROUP_JSON: otCoapOptionContentFormat = 256;
#[doc = " application/senml+xml: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENML_XML: otCoapOptionContentFormat = 310;
#[doc = " application/sensml+xml: [RFC8428]"]
pub const OT_COAP_OPTION_CONTENT_FORMAT_SENSML_XML: otCoapOptionContentFormat = 311;
#[doc = " CoAP Content Format codes.  The full list is documented at\n https://www.iana.org/assignments/core-parameters/core-parameters.xhtml#content-formats"]
pub type otCoapOptionContentFormat = ::std::os::raw::c_uint;
pub const OT_COAP_OPTION_BLOCK_SZX_16: otCoapBlockSzx = 0;
pub const OT_COAP_OPTION_BLOCK_SZX_32: otCoapBlockSzx = 1;
pub const OT_COAP_OPTION_BLOCK_SZX_64: otCoapBlockSzx = 2;
pub const OT_COAP_OPTION_BLOCK_SZX_128: otCoapBlockSzx = 3;
pub const OT_COAP_OPTION_BLOCK_SZX_256: otCoapBlockSzx = 4;
pub const OT_COAP_OPTION_BLOCK_SZX_512: otCoapBlockSzx = 5;
pub const OT_COAP_OPTION_BLOCK_SZX_1024: otCoapBlockSzx = 6;
#[doc = " CoAP Block Size Exponents"]
pub type otCoapBlockSzx = ::std::os::raw::c_uint;
#[doc = " This function pointer is called when a CoAP response is received or on the request timeout.\n\n @param[in]  aContext      A pointer to application-specific context.\n @param[in]  aMessage      A pointer to the message buffer containing the response. NULL if no response was received.\n @param[in]  aMessageInfo  A pointer to the message info for @p aMessage. NULL if no response was received.\n @param[in]  aResult       A result of the CoAP transaction.\n\n @retval  OT_ERROR_NONE              A response was received successfully.\n @retval  OT_ERROR_ABORT             A CoAP transaction was reset by peer.\n @retval  OT_ERROR_RESPONSE_TIMEOUT  No response or acknowledgment received during timeout period.\n"]
pub type otCoapResponseHandler = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aResult: otError,
    ),
>;
#[doc = " This function pointer is called when a CoAP request with a given Uri-Path is received.\n\n @param[in]  aContext      A pointer to arbitrary context information.\n @param[in]  aMessage      A pointer to the message.\n @param[in]  aMessageInfo  A pointer to the message info for @p aMessage.\n"]
pub type otCoapRequestHandler = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ),
>;
#[doc = " This function pointer is called when a CoAP message with an block-wise transfer option is received.\n\n This function is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE configuration\n is enabled.\n\n @param[in]  aContext     A pointer to application-specific context.\n @param[in]  aBlock       A pointer to the block segment.\n @param[in]  aPosition    The position of @p aBlock in a sequence in bytes.\n @param[in]  aBlockLength The length of the block segment in bytes.\n @param[in]  aMore        Flag if more block segments are following.\n @param[in]  aTotalLength The total length in bytes of the transferred information (indicated by a Size1 or Size2\n                          option).\n\n @retval  OT_ERROR_NONE               Block segment was stored successfully.\n @retval  OT_ERROR_NO_BUFS            No more memory to store blocks.\n @retval  OT_ERROR_NO_FRAME_RECEIVED  Block segment missing.\n"]
pub type otCoapBlockwiseReceiveHook = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aBlock: *const u8,
        aPosition: u32,
        aBlockLength: u16,
        aMore: bool,
        aTotalLength: u32,
    ) -> otError,
>;
#[doc = " This function pointer is called before the next block in a block-wise transfer is sent.\n\n This function is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE configuration\n is enabled.\n\n @param[in]       aContext     A pointer to application-specific context.\n @param[in,out]   aBlock       A pointer to where the block segment can be written to.\n @param[in]       aPosition    The position in a sequence from which to obtain the block segment.\n @param[in,out]   aBlockLength On entry, the maximum block segment length in bytes.\n @param[out]      aMore        A pointer to the flag if more block segments will follow.\n\n @warning By changing the value of aBlockLength, the block size of the whole exchange is\n          renegotiated. It is recommended to do this after the first block has been received as\n          later changes could cause problems with other CoAP implementations.\n\n @retval  OT_ERROR_NONE           No error occurred.\n @retval  OT_ERROR_INVALID_ARGS   Block at @p aPosition does not exist.\n"]
pub type otCoapBlockwiseTransmitHook = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aBlock: *mut u8,
        aPosition: u32,
        aBlockLength: *mut u16,
        aMore: *mut bool,
    ) -> otError,
>;
#[doc = " This structure represents a CoAP resource.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCoapResource {
    #[doc = "< The URI Path string"]
    pub mUriPath: *const ::std::os::raw::c_char,
    #[doc = "< The callback for handling a received request"]
    pub mHandler: otCoapRequestHandler,
    #[doc = "< Application-specific context"]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< The next CoAP resource in the list"]
    pub mNext: *mut otCoapResource,
}
impl Default for otCoapResource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents a CoAP resource with block-wise transfer.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCoapBlockwiseResource {
    #[doc = "< The URI Path string"]
    pub mUriPath: *const ::std::os::raw::c_char,
    #[doc = "< The callback for handling a received request"]
    pub mHandler: otCoapRequestHandler,
    #[doc = " The callback for handling incoming block-wise transfer.\n  This callback is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE\n  configuration is enabled."]
    pub mReceiveHook: otCoapBlockwiseReceiveHook,
    #[doc = " The callback for handling outgoing block-wise transfer.\n  This callback is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE\n  configuration is enabled."]
    pub mTransmitHook: otCoapBlockwiseTransmitHook,
    #[doc = "< Application-specific context"]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< The next CoAP resource in the list"]
    pub mNext: *mut otCoapBlockwiseResource,
}
impl Default for otCoapBlockwiseResource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents the CoAP transmission parameters.\n\n @note mAckTimeout * ((2 ** (mMaxRetransmit + 1)) - 1) * (mAckRandomFactorNumerator / mAckRandomFactorDenominator)\n       must not exceed what can be represented by a uint32_t (0xffffffff). This limitation allows OpenThread to\n       avoid 64-bit arithmetic.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otCoapTxParameters {
    #[doc = " Minimum spacing before first retransmission when ACK is not received, in milliseconds (RFC7252 default value is\n 2000ms).\n"]
    pub mAckTimeout: u32,
    #[doc = " Numerator of ACK_RANDOM_FACTOR used to calculate maximum spacing before first retransmission when ACK is not\n received (RFC7252 default value of ACK_RANDOM_FACTOR is 1.5; must not be decreased below 1).\n"]
    pub mAckRandomFactorNumerator: u8,
    #[doc = " Denominator of ACK_RANDOM_FACTOR used to calculate maximum spacing before first retransmission when ACK is not\n received (RFC7252 default value of ACK_RANDOM_FACTOR is 1.5; must not be decreased below 1).\n"]
    pub mAckRandomFactorDenominator: u8,
    #[doc = " Maximum number of retransmissions for CoAP Confirmable messages (RFC7252 default value is 4).\n"]
    pub mMaxRetransmit: u8,
}
extern "C" {
    #[doc = " This function initializes the CoAP header.\n\n @param[in,out] aMessage   A pointer to the CoAP message to initialize.\n @param[in]     aType      CoAP message type.\n @param[in]     aCode      CoAP message code.\n"]
    pub fn otCoapMessageInit(aMessage: *mut otMessage, aType: otCoapType, aCode: otCoapCode);
}
extern "C" {
    #[doc = " This function initializes a response message.\n\n @note Both message ID and token are set according to @p aRequest.\n\n @param[in,out]  aResponse  A pointer to the CoAP response message.\n @param[in]      aRequest   A pointer to the CoAP request message.\n @param[in]      aType      CoAP message type.\n @param[in]      aCode      CoAP message code.\n\n @retval OT_ERROR_NONE     Successfully initialized the response message.\n @retval OT_ERROR_NO_BUFS  Insufficient message buffers available to initialize the response message.\n"]
    pub fn otCoapMessageInitResponse(
        aResponse: *mut otMessage,
        aRequest: *const otMessage,
        aType: otCoapType,
        aCode: otCoapCode,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the Token value and length in a header.\n\n @param[in,out]  aMessage          A pointer to the CoAP message.\n @param[in]      aToken            A pointer to the Token value.\n @param[in]      aTokenLength      The Length of @p aToken.\n\n @retval OT_ERROR_NONE     Successfully set the Token value.\n @retval OT_ERROR_NO_BUFS  Insufficient buffers to set the Token value.\n"]
    pub fn otCoapMessageSetToken(
        aMessage: *mut otMessage,
        aToken: *const u8,
        aTokenLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the Token length and randomizes its value.\n\n @param[in,out]  aMessage      A pointer to the CoAP message.\n @param[in]      aTokenLength  The Length of a Token to set.\n"]
    pub fn otCoapMessageGenerateToken(aMessage: *mut otMessage, aTokenLength: u8);
}
extern "C" {
    #[doc = " This function appends the Content Format CoAP option as specified in\n https://tools.ietf.org/html/rfc7252#page-92.  This *must* be called before\n setting otCoapMessageSetPayloadMarker if a payload is to be included in the\n message.\n\n The function is a convenience wrapper around otCoapMessageAppendUintOption,\n and if the desired format type code isn't listed in otCoapOptionContentFormat,\n this base function should be used instead.\n\n @param[in,out]  aMessage          A pointer to the CoAP message.\n @param[in]      aContentFormat    One of the content formats listed in\n                                  otCoapOptionContentFormat above.\n\n @retval OT_ERROR_NONE          Successfully appended the option.\n @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type.\n @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size.\n"]
    pub fn otCoapMessageAppendContentFormatOption(
        aMessage: *mut otMessage,
        aContentFormat: otCoapOptionContentFormat,
    ) -> otError;
}
extern "C" {
    #[doc = " This function appends a CoAP option in a header.\n\n @param[in,out]  aMessage  A pointer to the CoAP message.\n @param[in]      aNumber   The CoAP Option number.\n @param[in]      aLength   The CoAP Option length.\n @param[in]      aValue    A pointer to the CoAP value.\n\n @retval OT_ERROR_NONE          Successfully appended the option.\n @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type.\n @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size.\n"]
    pub fn otCoapMessageAppendOption(
        aMessage: *mut otMessage,
        aNumber: u16,
        aLength: u16,
        aValue: *const ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function appends an unsigned integer CoAP option as specified in\n https://tools.ietf.org/html/rfc7252#section-3.2\n\n @param[in,out]  aMessage A pointer to the CoAP message.\n @param[in]      aNumber  The CoAP Option number.\n @param[in]      aValue   The CoAP Option unsigned integer value.\n\n @retval OT_ERROR_NONE          Successfully appended the option.\n @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type.\n @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size.\n\n @see otCoapMessageGetOptionUintValue"]
    pub fn otCoapMessageAppendUintOption(
        aMessage: *mut otMessage,
        aNumber: u16,
        aValue: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " This function appends an Observe option.\n\n @param[in,out]  aMessage  A pointer to the CoAP message.\n @param[in]      aObserve  Observe field value.\n\n @retval OT_ERROR_NONE          Successfully appended the option.\n @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type.\n @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size.\n"]
    pub fn otCoapMessageAppendObserveOption(aMessage: *mut otMessage, aObserve: u32) -> otError;
}
extern "C" {
    #[doc = " This function appends a Uri-Path option.\n\n @param[in,out]  aMessage  A pointer to the CoAP message.\n @param[in]      aUriPath  A pointer to a NULL-terminated string.\n\n @retval OT_ERROR_NONE          Successfully appended the option.\n @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type.\n @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size.\n"]
    pub fn otCoapMessageAppendUriPathOptions(
        aMessage: *mut otMessage,
        aUriPath: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function converts a CoAP Block option SZX field to the actual block size\n\n @param[in]     aSize     Block size exponent.\n\n @returns The actual size exponent value.\n"]
    pub fn otCoapBlockSizeFromExponent(aSize: otCoapBlockSzx) -> u16;
}
extern "C" {
    #[doc = " This function appends a Block2 option\n\n @param[in,out]  aMessage  A pointer to the CoAP message.\n @param[in]      aNum      Current block number.\n @param[in]      aMore     Boolean to indicate more blocks are to be sent.\n @param[in]      aSize     Block Size Exponent.\n\n @retval OT_ERROR_NONE          Successfully appended the option.\n @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type.\n @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size.\n"]
    pub fn otCoapMessageAppendBlock2Option(
        aMessage: *mut otMessage,
        aNum: u32,
        aMore: bool,
        aSize: otCoapBlockSzx,
    ) -> otError;
}
extern "C" {
    #[doc = " This function appends a Block1 option\n\n @param[in,out]  aMessage  A pointer to the CoAP message.\n @param[in]      aNum      Current block number.\n @param[in]      aMore     Boolean to indicate more blocks are to be sent.\n @param[in]      aSize     Block Size Exponent.\n\n @retval OT_ERROR_NONE          Successfully appended the option.\n @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type.\n @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size.\n"]
    pub fn otCoapMessageAppendBlock1Option(
        aMessage: *mut otMessage,
        aNum: u32,
        aMore: bool,
        aSize: otCoapBlockSzx,
    ) -> otError;
}
extern "C" {
    #[doc = " This function appends a Proxy-Uri option.\n\n @param[in,out]  aMessage  A pointer to the CoAP message.\n @param[in]      aUriPath  A pointer to a NULL-terminated string.\n\n @retval OT_ERROR_NONE          Successfully appended the option.\n @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type.\n @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size.\n"]
    pub fn otCoapMessageAppendProxyUriOption(
        aMessage: *mut otMessage,
        aUriPath: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function appends a Max-Age option.\n\n @param[in,out]  aMessage  A pointer to the CoAP message.\n @param[in]      aMaxAge   The Max-Age value.\n\n @retval OT_ERROR_NONE          Successfully appended the option.\n @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type.\n @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size.\n"]
    pub fn otCoapMessageAppendMaxAgeOption(aMessage: *mut otMessage, aMaxAge: u32) -> otError;
}
extern "C" {
    #[doc = " This function appends a single Uri-Query option.\n\n @param[in,out]  aMessage  A pointer to the CoAP message.\n @param[in]      aUriQuery A pointer to NULL-terminated string, which should contain a single key=value pair.\n\n @retval OT_ERROR_NONE          Successfully appended the option.\n @retval OT_ERROR_INVALID_ARGS  The option type is not equal or greater than the last option type.\n @retval OT_ERROR_NO_BUFS       The option length exceeds the buffer size."]
    pub fn otCoapMessageAppendUriQueryOption(
        aMessage: *mut otMessage,
        aUriQuery: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function adds Payload Marker indicating beginning of the payload to the CoAP header.\n\n @param[in,out]  aMessage  A pointer to the CoAP message.\n\n @retval OT_ERROR_NONE     Payload Marker successfully added.\n @retval OT_ERROR_NO_BUFS  Header Payload Marker exceeds the buffer size.\n"]
    pub fn otCoapMessageSetPayloadMarker(aMessage: *mut otMessage) -> otError;
}
extern "C" {
    #[doc = " This function returns the Type value.\n\n @param[in]  aMessage  A pointer to the CoAP message.\n\n @returns The Type value.\n"]
    pub fn otCoapMessageGetType(aMessage: *const otMessage) -> otCoapType;
}
extern "C" {
    #[doc = " This function returns the Code value.\n\n @param[in]  aMessage  A pointer to the CoAP message.\n\n @returns The Code value.\n"]
    pub fn otCoapMessageGetCode(aMessage: *const otMessage) -> otCoapCode;
}
extern "C" {
    #[doc = " This function sets the Code value.\n\n @param[in,out]  aMessage  A pointer to the CoAP message to initialize.\n @param[in]      aCode     CoAP message code.\n"]
    pub fn otCoapMessageSetCode(aMessage: *mut otMessage, aCode: otCoapCode);
}
extern "C" {
    #[doc = " This method returns the CoAP Code as human readable string.\n\n @param[in]   aMessage    A pointer to the CoAP message.\n\n @ returns The CoAP Code as string.\n"]
    pub fn otCoapMessageCodeToString(aMessage: *const otMessage) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function returns the Message ID value.\n\n @param[in]  aMessage  A pointer to the CoAP message.\n\n @returns The Message ID value.\n"]
    pub fn otCoapMessageGetMessageId(aMessage: *const otMessage) -> u16;
}
extern "C" {
    #[doc = " This function returns the Token length.\n\n @param[in]  aMessage  A pointer to the CoAP message.\n\n @returns The Token length.\n"]
    pub fn otCoapMessageGetTokenLength(aMessage: *const otMessage) -> u8;
}
extern "C" {
    #[doc = " This function returns a pointer to the Token value.\n\n @param[in]  aMessage  A pointer to the CoAP message.\n\n @returns A pointer to the Token value.\n"]
    pub fn otCoapMessageGetToken(aMessage: *const otMessage) -> *const u8;
}
extern "C" {
    #[doc = " This function initialises an iterator for the options in the given message.\n\n @param[in,out]  aIterator A pointer to the CoAP message option iterator.\n @param[in]      aMessage  A pointer to the CoAP message.\n\n @retval  OT_ERROR_NONE   Successfully initialised.\n @retval  OT_ERROR_PARSE  Message state is inconsistent.\n"]
    pub fn otCoapOptionIteratorInit(
        aIterator: *mut otCoapOptionIterator,
        aMessage: *const otMessage,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns a pointer to the first option matching the specified option number.\n\n @param[in]  aIterator A pointer to the CoAP message option iterator.\n @param[in]  aOption   The option number sought.\n\n @returns A pointer to the first matching option. If no matching option is present NULL pointer is returned.\n"]
    pub fn otCoapOptionIteratorGetFirstOptionMatching(
        aIterator: *mut otCoapOptionIterator,
        aOption: u16,
    ) -> *const otCoapOption;
}
extern "C" {
    #[doc = " This function returns a pointer to the first option.\n\n @param[in,out]  aIterator A pointer to the CoAP message option iterator.\n\n @returns A pointer to the first option. If no option is present NULL pointer is returned.\n"]
    pub fn otCoapOptionIteratorGetFirstOption(
        aIterator: *mut otCoapOptionIterator,
    ) -> *const otCoapOption;
}
extern "C" {
    #[doc = " This function returns a pointer to the next option matching the specified option number.\n\n @param[in]  aIterator A pointer to the CoAP message option iterator.\n @param[in]  aOption   The option number sought.\n\n @returns A pointer to the next matching option. If no further matching option is present NULL pointer is returned.\n"]
    pub fn otCoapOptionIteratorGetNextOptionMatching(
        aIterator: *mut otCoapOptionIterator,
        aOption: u16,
    ) -> *const otCoapOption;
}
extern "C" {
    #[doc = " This function returns a pointer to the next option.\n\n @param[in,out]  aIterator A pointer to the CoAP message option iterator.\n\n @returns A pointer to the next option. If no more options are present NULL pointer is returned.\n"]
    pub fn otCoapOptionIteratorGetNextOption(
        aIterator: *mut otCoapOptionIterator,
    ) -> *const otCoapOption;
}
extern "C" {
    #[doc = " This function fills current option value into @p aValue assuming the current value is an unsigned integer encoded\n according to https://tools.ietf.org/html/rfc7252#section-3.2\n\n @param[in,out]   aIterator   A pointer to the CoAP message option iterator.\n @param[out]      aValue      A pointer to an unsigned integer to receive the option value.\n\n @retval  OT_ERROR_NONE       Successfully filled value.\n @retval  OT_ERROR_NOT_FOUND  No current option.\n @retval  OT_ERROR_NO_BUFS    Value is too long to fit in a uint64_t.\n\n @see otCoapMessageAppendUintOption"]
    pub fn otCoapOptionIteratorGetOptionUintValue(
        aIterator: *mut otCoapOptionIterator,
        aValue: *mut u64,
    ) -> otError;
}
extern "C" {
    #[doc = " This function fills current option value into @p aValue.\n\n @param[in,out]  aIterator A pointer to the CoAP message option iterator.\n @param[out]     aValue    A pointer to a buffer to receive the option value.\n\n @retval  OT_ERROR_NONE       Successfully filled value.\n @retval  OT_ERROR_NOT_FOUND  No current option.\n"]
    pub fn otCoapOptionIteratorGetOptionValue(
        aIterator: *mut otCoapOptionIterator,
        aValue: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function creates a new CoAP message.\n\n @note If @p aSettings is 'NULL', the link layer security is enabled and the message priority is set to\n OT_MESSAGE_PRIORITY_NORMAL by default.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSettings  A pointer to the message settings or NULL to set default settings.\n\n @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid.\n"]
    pub fn otCoapNewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " This function sends a CoAP request with custom transmission parameters.\n\n If a response for a request is expected, respective function and context information should be provided.\n If no response is expected, these arguments should be NULL pointers.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aMessage         A pointer to the message to send.\n @param[in]  aMessageInfo     A pointer to the message info associated with @p aMessage.\n @param[in]  aHandler         A function pointer that shall be called on response reception or timeout.\n @param[in]  aContext         A pointer to arbitrary context information. May be NULL if not used.\n @param[in]  aTxParameters    A pointer to transmission parameters for this request. Use NULL for defaults.\n                              Otherwise, parameters given must meet the following conditions:\n                              1. mMaxRetransmit is no more than OT_COAP_MAX_RETRANSMIT.\n                              2. mAckRandomFactorNumerator / mAckRandomFactorDenominator must not be below 1.0.\n                              3. The calculated exchange life time must not overflow uint32_t.\n\n @retval OT_ERROR_INVALID_ARGS    @p aTxParameters is invalid.\n @retval OT_ERROR_NONE            Successfully sent CoAP message.\n @retval OT_ERROR_NO_BUFS         Failed to allocate retransmission data.\n"]
    pub fn otCoapSendRequestWithParameters(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aHandler: otCoapResponseHandler,
        aContext: *mut ::std::os::raw::c_void,
        aTxParameters: *const otCoapTxParameters,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends a CoAP request block-wise with custom transmission parameters.\n\n This function is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE configuration\n is enabled.\n\n If a response for a request is expected, respective function and context information should be provided.\n If the response is expected to be block-wise, a respective hook function should be provided.\n If no response is expected, these arguments should be NULL pointers.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aMessage         A pointer to the message to send.\n @param[in]  aMessageInfo     A pointer to the message info associated with @p aMessage.\n @param[in]  aHandler         A function pointer that shall be called on response reception or timeout.\n @param[in]  aContext         A pointer to arbitrary context information. May be NULL if not used.\n @param[in]  aTxParameters    A pointer to transmission parameters for this request. Use NULL for defaults.\n @param[in]  aTransmitHook    A pointer to a hook function for outgoing block-wise transfer.\n @param[in]  aReceiveHook     A pointer to a hook function for incoming block-wise transfer.\n\n @retval OT_ERROR_NONE    Successfully sent CoAP message.\n @retval OT_ERROR_NO_BUFS Failed to allocate retransmission data.\n"]
    pub fn otCoapSendRequestBlockWiseWithParameters(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aHandler: otCoapResponseHandler,
        aContext: *mut ::std::os::raw::c_void,
        aTxParameters: *const otCoapTxParameters,
        aTransmitHook: otCoapBlockwiseTransmitHook,
        aReceiveHook: otCoapBlockwiseReceiveHook,
    ) -> otError;
}
extern "C" {
    #[doc = " This function starts the CoAP server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aPort      The local UDP port to bind to.\n\n @retval OT_ERROR_NONE    Successfully started the CoAP server.\n @retval OT_ERROR_FAILED  Failed to start the CoAP server.\n"]
    pub fn otCoapStart(aInstance: *mut otInstance, aPort: u16) -> otError;
}
extern "C" {
    #[doc = " This function stops the CoAP server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE  Successfully stopped the CoAP server.\n"]
    pub fn otCoapStop(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function adds a resource to the CoAP server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aResource  A pointer to the resource.\n"]
    pub fn otCoapAddResource(aInstance: *mut otInstance, aResource: *mut otCoapResource);
}
extern "C" {
    #[doc = " This function removes a resource from the CoAP server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aResource  A pointer to the resource.\n"]
    pub fn otCoapRemoveResource(aInstance: *mut otInstance, aResource: *mut otCoapResource);
}
extern "C" {
    #[doc = " This function adds a block-wise resource to the CoAP server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aResource  A pointer to the resource.\n"]
    pub fn otCoapAddBlockWiseResource(
        aInstance: *mut otInstance,
        aResource: *mut otCoapBlockwiseResource,
    );
}
extern "C" {
    #[doc = " This function removes a block-wise resource from the CoAP server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aResource  A pointer to the resource.\n"]
    pub fn otCoapRemoveBlockWiseResource(
        aInstance: *mut otInstance,
        aResource: *mut otCoapBlockwiseResource,
    );
}
extern "C" {
    #[doc = " This function sets the default handler for unhandled CoAP requests.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aHandler   A function pointer that shall be called when an unhandled request arrives.\n @param[in]  aContext   A pointer to arbitrary context information. May be NULL if not used.\n"]
    pub fn otCoapSetDefaultHandler(
        aInstance: *mut otInstance,
        aHandler: otCoapRequestHandler,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function sends a CoAP response from the server with custom transmission parameters.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aMessage         A pointer to the CoAP response to send.\n @param[in]  aMessageInfo     A pointer to the message info associated with @p aMessage.\n @param[in]  aTxParameters    A pointer to transmission parameters for this response. Use NULL for defaults.\n\n @retval OT_ERROR_NONE     Successfully enqueued the CoAP response message.\n @retval OT_ERROR_NO_BUFS  Insufficient buffers available to send the CoAP response.\n"]
    pub fn otCoapSendResponseWithParameters(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aTxParameters: *const otCoapTxParameters,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends a CoAP response block-wise from the server with custom transmission parameters.\n\n This function is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE configuration\n is enabled.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aMessage         A pointer to the CoAP response to send.\n @param[in]  aMessageInfo     A pointer to the message info associated with @p aMessage.\n @param[in]  aTxParameters    A pointer to transmission parameters for this response. Use NULL for defaults.\n @param[in]  aContext         A pointer to arbitrary context information. May be NULL if not used.\n @param[in]  aTransmitHook    A pointer to a hook function for outgoing block-wise transfer.\n\n @retval OT_ERROR_NONE     Successfully enqueued the CoAP response message.\n @retval OT_ERROR_NO_BUFS  Insufficient buffers available to send the CoAP response.\n"]
    pub fn otCoapSendResponseBlockWiseWithParameters(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aTxParameters: *const otCoapTxParameters,
        aContext: *mut ::std::os::raw::c_void,
        aTransmitHook: otCoapBlockwiseTransmitHook,
    ) -> otError;
}
#[doc = " This function pointer is called when the DTLS connection state changes.\n\n @param[in]  aConnected  true, if a connection was established, false otherwise.\n @param[in]  aContext    A pointer to arbitrary context information.\n"]
pub type otHandleCoapSecureClientConnect = ::std::option::Option<
    unsafe extern "C" fn(aConnected: bool, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function starts the CoAP Secure service.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aPort      The local UDP port to bind to.\n\n @retval OT_ERROR_NONE  Successfully started the CoAP Secure server.\n"]
    pub fn otCoapSecureStart(aInstance: *mut otInstance, aPort: u16) -> otError;
}
extern "C" {
    #[doc = " This function stops the CoAP Secure server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otCoapSecureStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method sets the Pre-Shared Key (PSK) and cipher suite\n DTLS_PSK_WITH_AES_128_CCM_8.\n\n @note This function requires the build-time feature `MBEDTLS_KEY_EXCHANGE_PSK_ENABLED` to be enabled.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aPsk          A pointer to the PSK.\n @param[in]  aPskLength    The PSK length.\n @param[in]  aPskIdentity  The Identity Name for the PSK.\n @param[in]  aPskIdLength  The PSK Identity Length.\n"]
    pub fn otCoapSecureSetPsk(
        aInstance: *mut otInstance,
        aPsk: *const u8,
        aPskLength: u16,
        aPskIdentity: *const u8,
        aPskIdLength: u16,
    );
}
extern "C" {
    #[doc = " This method returns the peer x509 certificate base64 encoded.\n\n @note This function requires the build-time features `MBEDTLS_BASE64_C` and\n       `MBEDTLS_SSL_KEEP_PEER_CERTIFICATE` to be enabled.\n\n @param[in]   aInstance        A pointer to an OpenThread instance.\n @param[out]  aPeerCert        A pointer to the base64 encoded certificate buffer.\n @param[out]  aCertLength      The length of the base64 encoded peer certificate.\n @param[in]   aCertBufferSize  The buffer size of aPeerCert.\n\n @retval OT_ERROR_INVALID_STATE   Not connected yet.\n @retval OT_ERROR_NONE            Successfully get the peer certificate.\n @retval OT_ERROR_NO_BUFS         Can't allocate memory for certificate.\n"]
    pub fn otCoapSecureGetPeerCertificateBase64(
        aInstance: *mut otInstance,
        aPeerCert: *mut ::std::os::raw::c_uchar,
        aCertLength: *mut usize,
        aCertBufferSize: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " This method sets the authentication mode for the coap secure connection.\n\n Disable or enable the verification of peer certificate.\n Must be called before start.\n\n @param[in]   aInstance               A pointer to an OpenThread instance.\n @param[in]   aVerifyPeerCertificate  true, to verify the peer certificate.\n"]
    pub fn otCoapSecureSetSslAuthMode(aInstance: *mut otInstance, aVerifyPeerCertificate: bool);
}
extern "C" {
    #[doc = " This method sets the local device's X509 certificate with corresponding private key for\n DTLS session with DTLS_ECDHE_ECDSA_WITH_AES_128_CCM_8.\n\n @note This function requires `MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED=1`.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aX509Cert          A pointer to the PEM formatted X509 certificate.\n @param[in]  aX509Length        The length of certificate.\n @param[in]  aPrivateKey        A pointer to the PEM formatted private key.\n @param[in]  aPrivateKeyLength  The length of the private key.\n"]
    pub fn otCoapSecureSetCertificate(
        aInstance: *mut otInstance,
        aX509Cert: *const u8,
        aX509Length: u32,
        aPrivateKey: *const u8,
        aPrivateKeyLength: u32,
    );
}
extern "C" {
    #[doc = " This method sets the trusted top level CAs. It is needed for validating the\n certificate of the peer.\n\n DTLS mode \"ECDHE ECDSA with AES 128 CCM 8\" for Application CoAPS.\n\n @note This function requires `MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED=1`.\n\n @param[in]  aInstance                A pointer to an OpenThread instance.\n @param[in]  aX509CaCertificateChain  A pointer to the PEM formatted X509 CA chain.\n @param[in]  aX509CaCertChainLength   The length of chain.\n"]
    pub fn otCoapSecureSetCaCertificateChain(
        aInstance: *mut otInstance,
        aX509CaCertificateChain: *const u8,
        aX509CaCertChainLength: u32,
    );
}
extern "C" {
    #[doc = " This method initializes DTLS session with a peer.\n\n @param[in]  aInstance               A pointer to an OpenThread instance.\n @param[in]  aSockAddr               A pointer to the remote socket address.\n @param[in]  aHandler                A pointer to a function that will be called when the DTLS connection\n                                     state changes.\n @param[in]  aContext                A pointer to arbitrary context information.\n\n @retval OT_ERROR_NONE  Successfully started DTLS connection.\n"]
    pub fn otCoapSecureConnect(
        aInstance: *mut otInstance,
        aSockAddr: *const otSockAddr,
        aHandler: otHandleCoapSecureClientConnect,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This method stops the DTLS connection.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otCoapSecureDisconnect(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method indicates whether or not the DTLS session is connected.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @retval TRUE   The DTLS session is connected.\n @retval FALSE  The DTLS session is not connected.\n"]
    pub fn otCoapSecureIsConnected(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This method indicates whether or not the DTLS session is active.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @retval TRUE  If DTLS session is active.\n @retval FALSE If DTLS session is not active.\n"]
    pub fn otCoapSecureIsConnectionActive(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This method sends a CoAP request block-wise over secure DTLS connection.\n\n This function is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE configuration\n is enabled.\n\n If a response for a request is expected, respective function and context information should be provided.\n If no response is expected, these arguments should be NULL pointers.\n If Message Id was not set in the header (equal to 0), this function will assign unique Message Id to the message.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aMessage      A reference to the message to send.\n @param[in]  aHandler      A function pointer that shall be called on response reception or time-out.\n @param[in]  aContext      A pointer to arbitrary context information.\n @param[in]  aTransmitHook A function pointer that is called on Block1 response reception.\n @param[in]  aReceiveHook  A function pointer that is called on Block2 response reception.\n\n @retval OT_ERROR_NONE           Successfully sent CoAP message.\n @retval OT_ERROR_NO_BUFS        Failed to allocate retransmission data.\n @retval OT_ERROR_INVALID_STATE  DTLS connection was not initialized.\n"]
    pub fn otCoapSecureSendRequestBlockWise(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aHandler: otCoapResponseHandler,
        aContext: *mut ::std::os::raw::c_void,
        aTransmitHook: otCoapBlockwiseTransmitHook,
        aReceiveHook: otCoapBlockwiseReceiveHook,
    ) -> otError;
}
extern "C" {
    #[doc = " This method sends a CoAP request over secure DTLS connection.\n\n If a response for a request is expected, respective function and context information should be provided.\n If no response is expected, these arguments should be NULL pointers.\n If Message Id was not set in the header (equal to 0), this function will assign unique Message Id to the message.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aMessage      A reference to the message to send.\n @param[in]  aHandler      A function pointer that shall be called on response reception or time-out.\n @param[in]  aContext      A pointer to arbitrary context information.\n\n @retval OT_ERROR_NONE           Successfully sent CoAP message.\n @retval OT_ERROR_NO_BUFS        Failed to allocate retransmission data.\n @retval OT_ERROR_INVALID_STATE  DTLS connection was not initialized.\n"]
    pub fn otCoapSecureSendRequest(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aHandler: otCoapResponseHandler,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function adds a resource to the CoAP Secure server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aResource  A pointer to the resource.\n"]
    pub fn otCoapSecureAddResource(aInstance: *mut otInstance, aResource: *mut otCoapResource);
}
extern "C" {
    #[doc = " This function removes a resource from the CoAP Secure server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aResource  A pointer to the resource.\n"]
    pub fn otCoapSecureRemoveResource(aInstance: *mut otInstance, aResource: *mut otCoapResource);
}
extern "C" {
    #[doc = " This function adds a block-wise resource to the CoAP Secure server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aResource  A pointer to the resource.\n"]
    pub fn otCoapSecureAddBlockWiseResource(
        aInstance: *mut otInstance,
        aResource: *mut otCoapBlockwiseResource,
    );
}
extern "C" {
    #[doc = " This function removes a block-wise resource from the CoAP Secure server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aResource  A pointer to the resource.\n"]
    pub fn otCoapSecureRemoveBlockWiseResource(
        aInstance: *mut otInstance,
        aResource: *mut otCoapBlockwiseResource,
    );
}
extern "C" {
    #[doc = " This function sets the default handler for unhandled CoAP Secure requests.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aHandler   A function pointer that shall be called when an unhandled request arrives.\n @param[in]  aContext   A pointer to arbitrary context information. May be NULL if not used.\n"]
    pub fn otCoapSecureSetDefaultHandler(
        aInstance: *mut otInstance,
        aHandler: otCoapRequestHandler,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This method sets the connected callback to indicate, when\n a Client connect to the CoAP Secure server.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aHandler      A pointer to a function that will be called once DTLS connection is established.\n @param[in]  aContext      A pointer to arbitrary context information. May be NULL if not used.\n"]
    pub fn otCoapSecureSetClientConnectedCallback(
        aInstance: *mut otInstance,
        aHandler: otHandleCoapSecureClientConnect,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function sends a CoAP response block-wise from the CoAP Secure server.\n\n This function is available when OPENTHREAD_CONFIG_COAP_BLOCKWISE_TRANSFER_ENABLE configuration\n is enabled.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aMessage      A pointer to the CoAP response to send.\n @param[in]  aMessageInfo  A pointer to the message info associated with @p aMessage.\n @param[in]  aContext      A pointer to arbitrary context information. May be NULL if not used.\n @param[in]  aTransmitHook A function pointer that is called on Block1 request reception.\n\n @retval OT_ERROR_NONE     Successfully enqueued the CoAP response message.\n @retval OT_ERROR_NO_BUFS  Insufficient buffers available to send the CoAP response.\n"]
    pub fn otCoapSecureSendResponseBlockWise(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aContext: *mut ::std::os::raw::c_void,
        aTransmitHook: otCoapBlockwiseTransmitHook,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends a CoAP response from the CoAP Secure server.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aMessage      A pointer to the CoAP response to send.\n @param[in]  aMessageInfo  A pointer to the message info associated with @p aMessage.\n\n @retval OT_ERROR_NONE     Successfully enqueued the CoAP response message.\n @retval OT_ERROR_NO_BUFS  Insufficient buffers available to send the CoAP response.\n"]
    pub fn otCoapSecureSendResponse(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> otError;
}
#[doc = " @struct otNetworkKey\n\n This structure represents a Thread Network Key.\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNetworkKey {
    #[doc = "< Byte values"]
    pub m8: [u8; 16usize],
}
#[doc = " This datatype represents KeyRef to NetworkKey.\n"]
pub type otNetworkKeyRef = otCryptoKeyRef;
#[doc = " This structure represents a Network Name.\n\n The `otNetworkName` is a null terminated C string (i.e., `m8` char array MUST end with null char `\\0`).\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNetworkName {
    #[doc = "< Byte values. The `+ 1` is for null char."]
    pub m8: [::std::os::raw::c_char; 17usize],
}
#[doc = " This structure represents an Extended PAN ID.\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otExtendedPanId {
    #[doc = "< Byte values"]
    pub m8: [u8; 8usize],
}
#[doc = " @struct otIp6NetworkPrefix\n\n This structure represents the Network Prefix of an IPv6 address (most significant 64 bits of the address).\n"]
pub type otMeshLocalPrefix = otIp6NetworkPrefix;
#[doc = " This structure represents PSKc.\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otPskc {
    #[doc = "< Byte values"]
    pub m8: [u8; 16usize],
}
#[doc = " This datatype represents KeyRef to PSKc.\n"]
pub type otPskcRef = otCryptoKeyRef;
#[doc = " This structure represent Security Policy.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otSecurityPolicy {
    #[doc = "< The value for thrKeyRotation in units of hours."]
    pub mRotationTime: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl otSecurityPolicy {
    #[inline]
    pub fn mObtainNetworkKeyEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mObtainNetworkKeyEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNativeCommissioningEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNativeCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mRoutersEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRoutersEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mExternalCommissioningEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mExternalCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mCommercialCommissioningEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCommercialCommissioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mAutonomousEnrollmentEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAutonomousEnrollmentEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNetworkKeyProvisioningEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNetworkKeyProvisioningEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mTobleLinkEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mTobleLinkEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNonCcmRoutersEnabled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNonCcmRoutersEnabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mVersionThresholdForRouting(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_mVersionThresholdForRouting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mObtainNetworkKeyEnabled: bool,
        mNativeCommissioningEnabled: bool,
        mRoutersEnabled: bool,
        mExternalCommissioningEnabled: bool,
        mCommercialCommissioningEnabled: bool,
        mAutonomousEnrollmentEnabled: bool,
        mNetworkKeyProvisioningEnabled: bool,
        mTobleLinkEnabled: bool,
        mNonCcmRoutersEnabled: bool,
        mVersionThresholdForRouting: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mObtainNetworkKeyEnabled: u8 =
                unsafe { ::std::mem::transmute(mObtainNetworkKeyEnabled) };
            mObtainNetworkKeyEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mNativeCommissioningEnabled: u8 =
                unsafe { ::std::mem::transmute(mNativeCommissioningEnabled) };
            mNativeCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mRoutersEnabled: u8 = unsafe { ::std::mem::transmute(mRoutersEnabled) };
            mRoutersEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mExternalCommissioningEnabled: u8 =
                unsafe { ::std::mem::transmute(mExternalCommissioningEnabled) };
            mExternalCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mCommercialCommissioningEnabled: u8 =
                unsafe { ::std::mem::transmute(mCommercialCommissioningEnabled) };
            mCommercialCommissioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mAutonomousEnrollmentEnabled: u8 =
                unsafe { ::std::mem::transmute(mAutonomousEnrollmentEnabled) };
            mAutonomousEnrollmentEnabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mNetworkKeyProvisioningEnabled: u8 =
                unsafe { ::std::mem::transmute(mNetworkKeyProvisioningEnabled) };
            mNetworkKeyProvisioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mTobleLinkEnabled: u8 = unsafe { ::std::mem::transmute(mTobleLinkEnabled) };
            mTobleLinkEnabled as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mNonCcmRoutersEnabled: u8 = unsafe { ::std::mem::transmute(mNonCcmRoutersEnabled) };
            mNonCcmRoutersEnabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let mVersionThresholdForRouting: u8 =
                unsafe { ::std::mem::transmute(mVersionThresholdForRouting) };
            mVersionThresholdForRouting as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This type represents Channel Mask.\n"]
pub type otChannelMask = u32;
#[doc = " This structure represents presence of different components in Active or Pending Operational Dataset.\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otOperationalDatasetComponents {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl otOperationalDatasetComponents {
    #[inline]
    pub fn mIsActiveTimestampPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsActiveTimestampPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsPendingTimestampPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsPendingTimestampPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsNetworkKeyPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsNetworkKeyPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsNetworkNamePresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsNetworkNamePresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsExtendedPanIdPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsExtendedPanIdPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsMeshLocalPrefixPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsMeshLocalPrefixPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsDelayPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsDelayPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsPanIdPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsPanIdPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsChannelPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsChannelPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsPskcPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsPskcPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSecurityPolicyPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSecurityPolicyPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsChannelMaskPresent(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsChannelMaskPresent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsActiveTimestampPresent: bool,
        mIsPendingTimestampPresent: bool,
        mIsNetworkKeyPresent: bool,
        mIsNetworkNamePresent: bool,
        mIsExtendedPanIdPresent: bool,
        mIsMeshLocalPrefixPresent: bool,
        mIsDelayPresent: bool,
        mIsPanIdPresent: bool,
        mIsChannelPresent: bool,
        mIsPskcPresent: bool,
        mIsSecurityPolicyPresent: bool,
        mIsChannelMaskPresent: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsActiveTimestampPresent: u8 =
                unsafe { ::std::mem::transmute(mIsActiveTimestampPresent) };
            mIsActiveTimestampPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsPendingTimestampPresent: u8 =
                unsafe { ::std::mem::transmute(mIsPendingTimestampPresent) };
            mIsPendingTimestampPresent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsNetworkKeyPresent: u8 = unsafe { ::std::mem::transmute(mIsNetworkKeyPresent) };
            mIsNetworkKeyPresent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsNetworkNamePresent: u8 = unsafe { ::std::mem::transmute(mIsNetworkNamePresent) };
            mIsNetworkNamePresent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsExtendedPanIdPresent: u8 =
                unsafe { ::std::mem::transmute(mIsExtendedPanIdPresent) };
            mIsExtendedPanIdPresent as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mIsMeshLocalPrefixPresent: u8 =
                unsafe { ::std::mem::transmute(mIsMeshLocalPrefixPresent) };
            mIsMeshLocalPrefixPresent as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mIsDelayPresent: u8 = unsafe { ::std::mem::transmute(mIsDelayPresent) };
            mIsDelayPresent as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mIsPanIdPresent: u8 = unsafe { ::std::mem::transmute(mIsPanIdPresent) };
            mIsPanIdPresent as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mIsChannelPresent: u8 = unsafe { ::std::mem::transmute(mIsChannelPresent) };
            mIsChannelPresent as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let mIsPskcPresent: u8 = unsafe { ::std::mem::transmute(mIsPskcPresent) };
            mIsPskcPresent as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let mIsSecurityPolicyPresent: u8 =
                unsafe { ::std::mem::transmute(mIsSecurityPolicyPresent) };
            mIsSecurityPolicyPresent as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let mIsChannelMaskPresent: u8 = unsafe { ::std::mem::transmute(mIsChannelMaskPresent) };
            mIsChannelMaskPresent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents a Thread Dataset timestamp component.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otTimestamp {
    pub mSeconds: u64,
    pub mTicks: u16,
    pub mAuthoritative: bool,
}
#[doc = " This structure represents an Active or Pending Operational Dataset.\n\n Components in Dataset are optional. `mComponents` structure specifies which components are present in the Dataset.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otOperationalDataset {
    #[doc = "< Active Timestamp"]
    pub mActiveTimestamp: otTimestamp,
    #[doc = "< Pending Timestamp"]
    pub mPendingTimestamp: otTimestamp,
    #[doc = "< Network Key"]
    pub mNetworkKey: otNetworkKey,
    #[doc = "< Network Name"]
    pub mNetworkName: otNetworkName,
    #[doc = "< Extended PAN ID"]
    pub mExtendedPanId: otExtendedPanId,
    #[doc = "< Mesh Local Prefix"]
    pub mMeshLocalPrefix: otMeshLocalPrefix,
    #[doc = "< Delay Timer"]
    pub mDelay: u32,
    #[doc = "< PAN ID"]
    pub mPanId: otPanId,
    #[doc = "< Channel"]
    pub mChannel: u16,
    #[doc = "< PSKc"]
    pub mPskc: otPskc,
    #[doc = "< Security Policy"]
    pub mSecurityPolicy: otSecurityPolicy,
    #[doc = "< Channel Mask"]
    pub mChannelMask: otChannelMask,
    #[doc = "< Specifies which components are set in the Dataset."]
    pub mComponents: otOperationalDatasetComponents,
}
#[doc = " This structure represents an Active or Pending Operational Dataset.\n\n The Operational Dataset is TLV encoded as specified by Thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otOperationalDatasetTlvs {
    #[doc = "< Operational Dataset TLVs."]
    pub mTlvs: [u8; 254usize],
    #[doc = "< Size of Operational Dataset in bytes."]
    pub mLength: u8,
}
impl Default for otOperationalDatasetTlvs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< meshcop Channel TLV"]
pub const OT_MESHCOP_TLV_CHANNEL: otMeshcopTlvType = 0;
#[doc = "< meshcop Pan Id TLV"]
pub const OT_MESHCOP_TLV_PANID: otMeshcopTlvType = 1;
#[doc = "< meshcop Extended Pan Id TLV"]
pub const OT_MESHCOP_TLV_EXTPANID: otMeshcopTlvType = 2;
#[doc = "< meshcop Network Name TLV"]
pub const OT_MESHCOP_TLV_NETWORKNAME: otMeshcopTlvType = 3;
#[doc = "< meshcop PSKc TLV"]
pub const OT_MESHCOP_TLV_PSKC: otMeshcopTlvType = 4;
#[doc = "< meshcop Network Key TLV"]
pub const OT_MESHCOP_TLV_NETWORKKEY: otMeshcopTlvType = 5;
#[doc = "< meshcop Network Key Sequence TLV"]
pub const OT_MESHCOP_TLV_NETWORK_KEY_SEQUENCE: otMeshcopTlvType = 6;
#[doc = "< meshcop Mesh Local Prefix TLV"]
pub const OT_MESHCOP_TLV_MESHLOCALPREFIX: otMeshcopTlvType = 7;
#[doc = "< meshcop Steering Data TLV"]
pub const OT_MESHCOP_TLV_STEERING_DATA: otMeshcopTlvType = 8;
#[doc = "< meshcop Border Agent Locator TLV"]
pub const OT_MESHCOP_TLV_BORDER_AGENT_RLOC: otMeshcopTlvType = 9;
#[doc = "< meshcop Commissioner ID TLV"]
pub const OT_MESHCOP_TLV_COMMISSIONER_ID: otMeshcopTlvType = 10;
#[doc = "< meshcop Commissioner Session ID TLV"]
pub const OT_MESHCOP_TLV_COMM_SESSION_ID: otMeshcopTlvType = 11;
#[doc = "< meshcop Security Policy TLV"]
pub const OT_MESHCOP_TLV_SECURITYPOLICY: otMeshcopTlvType = 12;
#[doc = "< meshcop Get TLV"]
pub const OT_MESHCOP_TLV_GET: otMeshcopTlvType = 13;
#[doc = "< meshcop Active Timestamp TLV"]
pub const OT_MESHCOP_TLV_ACTIVETIMESTAMP: otMeshcopTlvType = 14;
#[doc = "< meshcop Commissioner UDP Port TLV"]
pub const OT_MESHCOP_TLV_COMMISSIONER_UDP_PORT: otMeshcopTlvType = 15;
#[doc = "< meshcop State TLV"]
pub const OT_MESHCOP_TLV_STATE: otMeshcopTlvType = 16;
#[doc = "< meshcop Joiner DTLS Encapsulation TLV"]
pub const OT_MESHCOP_TLV_JOINER_DTLS: otMeshcopTlvType = 17;
#[doc = "< meshcop Joiner UDP Port TLV"]
pub const OT_MESHCOP_TLV_JOINER_UDP_PORT: otMeshcopTlvType = 18;
#[doc = "< meshcop Joiner IID TLV"]
pub const OT_MESHCOP_TLV_JOINER_IID: otMeshcopTlvType = 19;
#[doc = "< meshcop Joiner Router Locator TLV"]
pub const OT_MESHCOP_TLV_JOINER_RLOC: otMeshcopTlvType = 20;
#[doc = "< meshcop Joiner Router KEK TLV"]
pub const OT_MESHCOP_TLV_JOINER_ROUTER_KEK: otMeshcopTlvType = 21;
#[doc = "< meshcop Provisioning URL TLV"]
pub const OT_MESHCOP_TLV_PROVISIONING_URL: otMeshcopTlvType = 32;
#[doc = "< meshcop Vendor Name TLV"]
pub const OT_MESHCOP_TLV_VENDOR_NAME_TLV: otMeshcopTlvType = 33;
#[doc = "< meshcop Vendor Model TLV"]
pub const OT_MESHCOP_TLV_VENDOR_MODEL_TLV: otMeshcopTlvType = 34;
#[doc = "< meshcop Vendor SW Version TLV"]
pub const OT_MESHCOP_TLV_VENDOR_SW_VERSION_TLV: otMeshcopTlvType = 35;
#[doc = "< meshcop Vendor Data TLV"]
pub const OT_MESHCOP_TLV_VENDOR_DATA_TLV: otMeshcopTlvType = 36;
#[doc = "< meshcop Vendor Stack Version TLV"]
pub const OT_MESHCOP_TLV_VENDOR_STACK_VERSION_TLV: otMeshcopTlvType = 37;
#[doc = "< meshcop UDP encapsulation TLV"]
pub const OT_MESHCOP_TLV_UDP_ENCAPSULATION_TLV: otMeshcopTlvType = 48;
#[doc = "< meshcop IPv6 address TLV"]
pub const OT_MESHCOP_TLV_IPV6_ADDRESS_TLV: otMeshcopTlvType = 49;
#[doc = "< meshcop Pending Timestamp TLV"]
pub const OT_MESHCOP_TLV_PENDINGTIMESTAMP: otMeshcopTlvType = 51;
#[doc = "< meshcop Delay Timer TLV"]
pub const OT_MESHCOP_TLV_DELAYTIMER: otMeshcopTlvType = 52;
#[doc = "< meshcop Channel Mask TLV"]
pub const OT_MESHCOP_TLV_CHANNELMASK: otMeshcopTlvType = 53;
#[doc = "< meshcop Count TLV"]
pub const OT_MESHCOP_TLV_COUNT: otMeshcopTlvType = 54;
#[doc = "< meshcop Period TLV"]
pub const OT_MESHCOP_TLV_PERIOD: otMeshcopTlvType = 55;
#[doc = "< meshcop Scan Duration TLV"]
pub const OT_MESHCOP_TLV_SCAN_DURATION: otMeshcopTlvType = 56;
#[doc = "< meshcop Energy List TLV"]
pub const OT_MESHCOP_TLV_ENERGY_LIST: otMeshcopTlvType = 57;
#[doc = "< meshcop Discovery Request TLV"]
pub const OT_MESHCOP_TLV_DISCOVERYREQUEST: otMeshcopTlvType = 128;
#[doc = "< meshcop Discovery Response TLV"]
pub const OT_MESHCOP_TLV_DISCOVERYRESPONSE: otMeshcopTlvType = 129;
#[doc = "< meshcop Joiner Advertisement TLV"]
pub const OT_MESHCOP_TLV_JOINERADVERTISEMENT: otMeshcopTlvType = 241;
#[doc = " This enumeration represents meshcop TLV types.\n"]
pub type otMeshcopTlvType = ::std::os::raw::c_uint;
#[doc = " This function pointer is called when a response to a MGMT_SET request is received or times out.\n\n @param[in]  aResult   A result of the operation.\n @param[in]  aContext  A pointer to application-specific context.\n\n @retval  OT_ERROR_NONE              The request was accepted by the leader.\n @retval  OT_ERROR_REJECTED          The request was rejected by the leader.\n @retval  OT_ERROR_PARSE             An error occurred during parsing the response.\n @retval  OT_ERROR_ABORT             The request was reset by peer.\n @retval  OT_ERROR_RESPONSE_TIMEOUT  No response or acknowledgment received during timeout period.\n"]
pub type otDatasetMgmtSetCallback = ::std::option::Option<
    unsafe extern "C" fn(aResult: otError, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function indicates whether a valid network is present in the Active Operational Dataset or not.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns TRUE if a valid network is present in the Active Operational Dataset, FALSE otherwise.\n"]
    pub fn otDatasetIsCommissioned(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Gets the Active Operational Dataset.\n\n @param[in]   aInstance A pointer to an OpenThread instance.\n @param[out]  aDataset  A pointer to where the Active Operational Dataset will be placed.\n\n @retval OT_ERROR_NONE          Successfully retrieved the Active Operational Dataset.\n @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store.\n"]
    pub fn otDatasetGetActive(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the Active Operational Dataset.\n\n @param[in]   aInstance A pointer to an OpenThread instance.\n @param[out]  aDataset  A pointer to where the Active Operational Dataset will be placed.\n\n @retval OT_ERROR_NONE          Successfully retrieved the Active Operational Dataset.\n @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store.\n"]
    pub fn otDatasetGetActiveTlvs(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the Active Operational Dataset.\n\n If the dataset does not include an Active Timestamp, the dataset is only partially complete.\n\n If Thread is enabled on a device that has a partially complete Active Dataset, the device will attempt to attach to\n an existing Thread network using any existing information in the dataset. Only the Thread Network Key is needed to\n attach to a network.\n\n If channel is not included in the dataset, the device will send MLE Announce messages across different channels to\n find neighbors on other channels.\n\n If the device successfully attaches to a Thread network, the device will then retrieve the full Active Dataset from\n its Parent. Note that a router-capable device will not transition to the Router or Leader roles until it has a\n complete Active Dataset.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aDataset  A pointer to the Active Operational Dataset.\n\n @retval OT_ERROR_NONE             Successfully set the Active Operational Dataset.\n @retval OT_ERROR_NO_BUFS          Insufficient buffer space to set the Active Operational Dataset.\n @retval OT_ERROR_NOT_IMPLEMENTED  The platform does not implement settings functionality.\n"]
    pub fn otDatasetSetActive(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the Active Operational Dataset.\n\n If the dataset does not include an Active Timestamp, the dataset is only partially complete.\n\n If Thread is enabled on a device that has a partially complete Active Dataset, the device will attempt to attach to\n an existing Thread network using any existing information in the dataset. Only the Thread Network Key is needed to\n attach to a network.\n\n If channel is not included in the dataset, the device will send MLE Announce messages across different channels to\n find neighbors on other channels.\n\n If the device successfully attaches to a Thread network, the device will then retrieve the full Active Dataset from\n its Parent. Note that a router-capable device will not transition to the Router or Leader roles until it has a\n complete Active Dataset.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aDataset  A pointer to the Active Operational Dataset.\n\n @retval OT_ERROR_NONE             Successfully set the Active Operational Dataset.\n @retval OT_ERROR_NO_BUFS          Insufficient buffer space to set the Active Operational Dataset.\n @retval OT_ERROR_NOT_IMPLEMENTED  The platform does not implement settings functionality.\n"]
    pub fn otDatasetSetActiveTlvs(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the Pending Operational Dataset.\n\n @param[in]   aInstance A pointer to an OpenThread instance.\n @param[out]  aDataset  A pointer to where the Pending Operational Dataset will be placed.\n\n @retval OT_ERROR_NONE          Successfully retrieved the Pending Operational Dataset.\n @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store.\n"]
    pub fn otDatasetGetPending(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the Pending Operational Dataset.\n\n @param[in]   aInstance A pointer to an OpenThread instance.\n @param[out]  aDataset  A pointer to where the Pending Operational Dataset will be placed.\n\n @retval OT_ERROR_NONE          Successfully retrieved the Pending Operational Dataset.\n @retval OT_ERROR_NOT_FOUND     No corresponding value in the setting store.\n"]
    pub fn otDatasetGetPendingTlvs(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the Pending Operational Dataset.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aDataset  A pointer to the Pending Operational Dataset.\n\n @retval OT_ERROR_NONE             Successfully set the Pending Operational Dataset.\n @retval OT_ERROR_NO_BUFS          Insufficient buffer space to set the Pending Operational Dataset.\n @retval OT_ERROR_NOT_IMPLEMENTED  The platform does not implement settings functionality.\n"]
    pub fn otDatasetSetPending(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the Pending Operational Dataset.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aDataset  A pointer to the Pending Operational Dataset.\n\n @retval OT_ERROR_NONE             Successfully set the Pending Operational Dataset.\n @retval OT_ERROR_NO_BUFS          Insufficient buffer space to set the Pending Operational Dataset.\n @retval OT_ERROR_NOT_IMPLEMENTED  The platform does not implement settings functionality.\n"]
    pub fn otDatasetSetPendingTlvs(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_ACTIVE_GET.\n\n @param[in]  aInstance           A pointer to an OpenThread instance.\n @param[in]  aDatasetComponents  A pointer to a Dataset Components structure specifying which components to request.\n @param[in]  aTlvTypes           A pointer to array containing additional raw TLV types to be requested.\n @param[in]  aLength             The length of @p aTlvTypes.\n @param[in]  aAddress            A pointer to the IPv6 destination, if it is NULL, will use Leader ALOC as default.\n\n @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.\n"]
    pub fn otDatasetSendMgmtActiveGet(
        aInstance: *mut otInstance,
        aDatasetComponents: *const otOperationalDatasetComponents,
        aTlvTypes: *const u8,
        aLength: u8,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_ACTIVE_SET.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aDataset   A pointer to operational dataset.\n @param[in]  aTlvs      A pointer to TLVs.\n @param[in]  aLength    The length of TLVs.\n @param[in]  aCallback  A pointer to a function that is called on response reception or timeout.\n @param[in]  aContext   A pointer to application-specific context for @p aCallback.\n\n @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.\n @retval OT_ERROR_BUSY          A previous request is ongoing.\n"]
    pub fn otDatasetSendMgmtActiveSet(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
        aTlvs: *const u8,
        aLength: u8,
        aCallback: otDatasetMgmtSetCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_PENDING_GET.\n\n @param[in]  aInstance           A pointer to an OpenThread instance.\n @param[in]  aDatasetComponents  A pointer to a Dataset Components structure specifying which components to request.\n @param[in]  aTlvTypes           A pointer to array containing additional raw TLV types to be requested.\n @param[in]  aLength             The length of @p aTlvTypes.\n @param[in]  aAddress            A pointer to the IPv6 destination, if it is NULL, will use Leader ALOC as default.\n\n @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.\n"]
    pub fn otDatasetSendMgmtPendingGet(
        aInstance: *mut otInstance,
        aDatasetComponents: *const otOperationalDatasetComponents,
        aTlvTypes: *const u8,
        aLength: u8,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Sends MGMT_PENDING_SET.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aDataset   A pointer to operational dataset.\n @param[in]  aTlvs      A pointer to TLVs.\n @param[in]  aLength    The length of TLVs.\n @param[in]  aCallback  A pointer to a function that is called on response reception or timeout.\n @param[in]  aContext   A pointer to application-specific context for @p aCallback.\n\n @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.\n @retval OT_ERROR_BUSY          A previous request is ongoing.\n"]
    pub fn otDatasetSendMgmtPendingSet(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
        aTlvs: *const u8,
        aLength: u8,
        aCallback: otDatasetMgmtSetCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function generates PSKc from a given pass-phrase, network name, and extended PAN ID.\n\n PSKc is used to establish the Commissioner Session.\n\n @param[in]  aPassPhrase   The commissioning pass-phrase.\n @param[in]  aNetworkName  The network name for PSKc computation.\n @param[in]  aExtPanId     The extended PAN ID for PSKc computation.\n @param[out] aPskc         A pointer to variable to output the generated PSKc.\n\n @retval OT_ERROR_NONE          Successfully generate PSKc.\n @retval OT_ERROR_INVALID_ARGS  If any of the input arguments is invalid.\n"]
    pub fn otDatasetGeneratePskc(
        aPassPhrase: *const ::std::os::raw::c_char,
        aNetworkName: *const otNetworkName,
        aExtPanId: *const otExtendedPanId,
        aPskc: *mut otPskc,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets an `otNetworkName` instance from a given null terminated C string.\n\n @p aNameString must follow UTF-8 encoding and the Network Name length must not be longer than\n `OT_NETWORK_NAME_MAX_SIZE`.\n\n @param[out] aNetworkName        A pointer to the `otNetworkName` to set.\n @param[in]  aNameString         A name C string.\n\n @retval OT_ERROR_NONE           Successfully set @p aNetworkName from @p aNameString.\n @retval OT_ERROR_INVALID_ARGS   @p aNameStrng is invalid (too long or does not follow UTF-8 encoding).\n"]
    pub fn otNetworkNameFromString(
        aNetworkName: *mut otNetworkName,
        aNameString: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Parses an Operational Dataset from a given `otOperationalDatasetTlvs`.\n\n @param[in]  aDatasetTlvs  A pointer to dataset TLVs.\n @param[out] aDataset      A pointer to where the dataset will be placed.\n\n @retval OT_ERROR_NONE          Successfully set @p aDataset from @p aDatasetTlvs.\n @retval OT_ERROR_INVALID_ARGS  @p aDatasetTlvs is invalid.\n"]
    pub fn otDatasetParseTlvs(
        aDatasetTlvs: *const otOperationalDatasetTlvs,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " Converts a given Operational Dataset to `otOperationalDatasetTlvs`.\n\n @param[in]  aDataset      An Operational dataset to convert to TLVs.\n @param[out] aDatasetTlvs  A pointer to dataset TLVs to return the result.\n\n @retval OT_ERROR_NONE          Successfully converted @p aDataset and updated @p aDatasetTlvs.\n @retval OT_ERROR_INVALID_ARGS  @p aDataset is invalid, does not contain active or pending timestamps.\n"]
    pub fn otDatasetConvertToTlvs(
        aDataset: *const otOperationalDataset,
        aDatasetTlvs: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
extern "C" {
    #[doc = " Updates a given Operational Dataset.\n\n @p aDataset contains the fields to be updated and their new value.\n\n @param[in]     aDataset      Specifies the set of types and values to update.\n @param[in,out] aDatasetTlvs  A pointer to dataset TLVs to update.\n\n @retval OT_ERROR_NONE          Successfully updated @p aDatasetTlvs.\n @retval OT_ERROR_INVALID_ARGS  @p aDataset contains invalid values.\n @retval OT_ERROR_NO_BUFS       Not enough space space in @p aDatasetTlvs to apply the update.\n"]
    pub fn otDatasetUpdateTlvs(
        aDataset: *const otOperationalDataset,
        aDatasetTlvs: *mut otOperationalDatasetTlvs,
    ) -> otError;
}
pub const OT_JOINER_STATE_IDLE: otJoinerState = 0;
pub const OT_JOINER_STATE_DISCOVER: otJoinerState = 1;
pub const OT_JOINER_STATE_CONNECT: otJoinerState = 2;
pub const OT_JOINER_STATE_CONNECTED: otJoinerState = 3;
pub const OT_JOINER_STATE_ENTRUST: otJoinerState = 4;
pub const OT_JOINER_STATE_JOINED: otJoinerState = 5;
#[doc = " This enumeration defines the Joiner State.\n"]
pub type otJoinerState = ::std::os::raw::c_uint;
#[doc = " This structure represents a Joiner Discerner.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otJoinerDiscerner {
    #[doc = "< Discerner value (the lowest `mLength` bits specify the discerner)."]
    pub mValue: u64,
    #[doc = "< Length (number of bits) - must be non-zero and at most `OT_JOINER_MAX_DISCERNER_LENGTH`."]
    pub mLength: u8,
}
#[doc = " This function pointer is called to notify the completion of a join operation.\n\n @param[in]  aError    OT_ERROR_NONE if the join process succeeded.\n                       OT_ERROR_SECURITY if the join process failed due to security credentials.\n                       OT_ERROR_NOT_FOUND if no joinable network was discovered.\n                       OT_ERROR_RESPONSE_TIMEOUT if a response timed out.\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otJoinerCallback = ::std::option::Option<
    unsafe extern "C" fn(aError: otError, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Enables the Thread Joiner role.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aPskd             A pointer to the PSKd.\n @param[in]  aProvisioningUrl  A pointer to the Provisioning URL (may be NULL).\n @param[in]  aVendorName       A pointer to the Vendor Name (may be NULL).\n @param[in]  aVendorModel      A pointer to the Vendor Model (may be NULL).\n @param[in]  aVendorSwVersion  A pointer to the Vendor SW Version (may be NULL).\n @param[in]  aVendorData       A pointer to the Vendor Data (may be NULL).\n @param[in]  aCallback         A pointer to a function that is called when the join operation completes.\n @param[in]  aContext          A pointer to application-specific context.\n\n @retval OT_ERROR_NONE              Successfully started the Joiner role.\n @retval OT_ERROR_BUSY              The previous attempt is still on-going.\n @retval OT_ERROR_INVALID_ARGS      @p aPskd or @p aProvisioningUrl is invalid.\n @retval OT_ERROR_INVALID_STATE     The IPv6 stack is not enabled or Thread stack is fully enabled.\n"]
    pub fn otJoinerStart(
        aInstance: *mut otInstance,
        aPskd: *const ::std::os::raw::c_char,
        aProvisioningUrl: *const ::std::os::raw::c_char,
        aVendorName: *const ::std::os::raw::c_char,
        aVendorModel: *const ::std::os::raw::c_char,
        aVendorSwVersion: *const ::std::os::raw::c_char,
        aVendorData: *const ::std::os::raw::c_char,
        aCallback: otJoinerCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Disables the Thread Joiner role.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otJoinerStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets the Joiner State.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @retval OT_JOINER_STATE_IDLE\n @retval OT_JOINER_STATE_DISCOVER\n @retval OT_JOINER_STATE_CONNECT\n @retval OT_JOINER_STATE_CONNECTED\n @retval OT_JOINER_STATE_ENTRUST\n @retval OT_JOINER_STATE_JOINED\n"]
    pub fn otJoinerGetState(aInstance: *mut otInstance) -> otJoinerState;
}
extern "C" {
    #[doc = " Gets the Joiner ID.\n\n If a Joiner Discerner is not set, Joiner ID is the first 64 bits of the result of computing SHA-256 over\n factory-assigned IEEE EUI-64. Otherwise the Joiner ID is calculated from the Joiner Discerner value.\n\n The Joiner ID is also used as the device's IEEE 802.15.4 Extended Address during the commissioning process.\n\n @param[in]   aInstance  A pointer to the OpenThread instance.\n\n @returns A pointer to the Joiner ID.\n"]
    pub fn otJoinerGetId(aInstance: *mut otInstance) -> *const otExtAddress;
}
extern "C" {
    #[doc = " Sets the Joiner Discerner.\n\n The Joiner Discerner is used to calculate the Joiner ID during the Thread Commissioning process. For more\n information, refer to #otJoinerGetId.\n @note The Joiner Discerner takes the place of the Joiner EUI-64 during the joiner session of Thread Commissioning.\n\n @param[in]   aInstance    A pointer to the OpenThread instance.\n @param[in]   aDiscerner   A pointer to a Joiner Discerner. If NULL clears any previously set discerner.\n\n @retval OT_ERROR_NONE           The Joiner Discerner updated successfully.\n @retval OT_ERROR_INVALID_ARGS   @p aDiscerner is not valid (specified length is not within valid range).\n @retval OT_ERROR_INVALID_STATE  There is an ongoing Joining process so Joiner Discerner could not be changed.\n"]
    pub fn otJoinerSetDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *mut otJoinerDiscerner,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Joiner Discerner. For more information, refer to #otJoinerSetDiscerner.\n\n @param[in]   aInstance       A pointer to the OpenThread instance.\n\n @returns A pointer to Joiner Discerner or NULL if none is set.\n"]
    pub fn otJoinerGetDiscerner(aInstance: *mut otInstance) -> *const otJoinerDiscerner;
}
extern "C" {
    #[doc = " This function converts a given joiner state enumeration value to a human-readable string.\n\n @param[in] aState   The joiner state.\n\n @returns A human-readable string representation of @p aState.\n"]
    pub fn otJoinerStateToString(aState: otJoinerState) -> *const ::std::os::raw::c_char;
}
#[doc = "< Commissioner role is disabled."]
pub const OT_COMMISSIONER_STATE_DISABLED: otCommissionerState = 0;
#[doc = "< Currently petitioning to become a Commissioner."]
pub const OT_COMMISSIONER_STATE_PETITION: otCommissionerState = 1;
#[doc = "< Commissioner role is active."]
pub const OT_COMMISSIONER_STATE_ACTIVE: otCommissionerState = 2;
#[doc = " This enumeration defines the Commissioner State.\n"]
pub type otCommissionerState = ::std::os::raw::c_uint;
pub const OT_COMMISSIONER_JOINER_START: otCommissionerJoinerEvent = 0;
pub const OT_COMMISSIONER_JOINER_CONNECTED: otCommissionerJoinerEvent = 1;
pub const OT_COMMISSIONER_JOINER_FINALIZE: otCommissionerJoinerEvent = 2;
pub const OT_COMMISSIONER_JOINER_END: otCommissionerJoinerEvent = 3;
pub const OT_COMMISSIONER_JOINER_REMOVED: otCommissionerJoinerEvent = 4;
#[doc = " This enumeration defines a Joiner Event on the Commissioner.\n"]
pub type otCommissionerJoinerEvent = ::std::os::raw::c_uint;
#[doc = " This structure represents the steering data.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otSteeringData {
    #[doc = "< Length of steering data (bytes)"]
    pub mLength: u8,
    #[doc = "< Byte values"]
    pub m8: [u8; 16usize],
}
#[doc = " This structure represents a Commissioning Dataset.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otCommissioningDataset {
    #[doc = "< Border Router RLOC16"]
    pub mLocator: u16,
    #[doc = "< Commissioner Session Id"]
    pub mSessionId: u16,
    #[doc = "< Steering Data"]
    pub mSteeringData: otSteeringData,
    #[doc = "< Joiner UDP Port"]
    pub mJoinerUdpPort: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl otCommissioningDataset {
    #[inline]
    pub fn mIsLocatorSet(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsLocatorSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSessionIdSet(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSessionIdSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsSteeringDataSet(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsSteeringDataSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsJoinerUdpPortSet(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoinerUdpPortSet(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsLocatorSet: bool,
        mIsSessionIdSet: bool,
        mIsSteeringDataSet: bool,
        mIsJoinerUdpPortSet: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsLocatorSet: u8 = unsafe { ::std::mem::transmute(mIsLocatorSet) };
            mIsLocatorSet as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsSessionIdSet: u8 = unsafe { ::std::mem::transmute(mIsSessionIdSet) };
            mIsSessionIdSet as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsSteeringDataSet: u8 = unsafe { ::std::mem::transmute(mIsSteeringDataSet) };
            mIsSteeringDataSet as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsJoinerUdpPortSet: u8 = unsafe { ::std::mem::transmute(mIsJoinerUdpPortSet) };
            mIsJoinerUdpPortSet as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents a Joiner PSKd.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otJoinerPskd {
    #[doc = "< Char string array (must be null terminated - +1 is for null char)."]
    pub m8: [::std::os::raw::c_char; 33usize],
}
impl Default for otJoinerPskd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Accept any Joiner (no EUI64 or Discerner is specified)."]
pub const OT_JOINER_INFO_TYPE_ANY: otJoinerInfoType = 0;
#[doc = "< Joiner EUI-64 is specified (`mSharedId.mEui64` in `otJoinerInfo`)."]
pub const OT_JOINER_INFO_TYPE_EUI64: otJoinerInfoType = 1;
#[doc = "< Joiner Discerner is specified (`mSharedId.mDiscerner` in `otJoinerInfo`)."]
pub const OT_JOINER_INFO_TYPE_DISCERNER: otJoinerInfoType = 2;
#[doc = " This enumeration defines a Joiner Info Type.\n"]
pub type otJoinerInfoType = ::std::os::raw::c_uint;
#[doc = " This structure represents a Joiner Info.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otJoinerInfo {
    #[doc = "< Joiner type."]
    pub mType: otJoinerInfoType,
    #[doc = "< Shared fields"]
    pub mSharedId: otJoinerInfo__bindgen_ty_1,
    #[doc = "< Joiner PSKd"]
    pub mPskd: otJoinerPskd,
    #[doc = "< Joiner expiration time in msec"]
    pub mExpirationTime: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otJoinerInfo__bindgen_ty_1 {
    #[doc = "< Joiner EUI64 (when `mType` is `OT_JOINER_INFO_TYPE_EUI64`)"]
    pub mEui64: otExtAddress,
    #[doc = "< Joiner Discerner (when `mType` is `OT_JOINER_INFO_TYPE_DISCERNER`)"]
    pub mDiscerner: otJoinerDiscerner,
}
impl Default for otJoinerInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otJoinerInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This function pointer is called whenever the commissioner state changes.\n\n @param[in]  aState    The Commissioner state.\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otCommissionerStateCallback = ::std::option::Option<
    unsafe extern "C" fn(aState: otCommissionerState, aContext: *mut ::std::os::raw::c_void),
>;
#[doc = " This function pointer is called whenever the joiner state changes.\n\n @param[in]  aEvent       The joiner event type.\n @param[in]  aJoinerInfo  A pointer to the Joiner Info.\n @param[in]  aJoinerId    A pointer to the Joiner ID (if not known, it will be NULL).\n @param[in]  aContext     A pointer to application-specific context.\n"]
pub type otCommissionerJoinerCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aEvent: otCommissionerJoinerEvent,
        aJoinerInfo: *const otJoinerInfo,
        aJoinerId: *const otExtAddress,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function enables the Thread Commissioner role.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aStateCallback    A pointer to a function that is called when the commissioner state changes.\n @param[in]  aJoinerCallback   A pointer to a function that is called with a joiner event occurs.\n @param[in]  aCallbackContext  A pointer to application-specific context.\n\n @retval OT_ERROR_NONE           Successfully started the Commissioner service.\n @retval OT_ERROR_ALREADY        Commissioner is already started.\n @retval OT_ERROR_INVALID_STATE  Device is not currently attached to a network.\n"]
    pub fn otCommissionerStart(
        aInstance: *mut otInstance,
        aStateCallback: otCommissionerStateCallback,
        aJoinerCallback: otCommissionerJoinerCallback,
        aCallbackContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function disables the Thread Commissioner role.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE     Successfully stopped the Commissioner service.\n @retval OT_ERROR_ALREADY  Commissioner is already stopped.\n"]
    pub fn otCommissionerStop(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function returns the Commissioner Id.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n\n @returns The Commissioner Id.\n"]
    pub fn otCommissionerGetId(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function sets the Commissioner Id.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aId           A pointer to a string character array. Must be null terminated.\n\n @retval OT_ERROR_NONE            Successfully set the Commissioner Id.\n @retval OT_ERROR_INVALID_ARGS    Given name is too long.\n @retval OT_ERROR_INVALID_STATE   The commissioner is active and id cannot be changed.\n"]
    pub fn otCommissionerSetId(
        aInstance: *mut otInstance,
        aId: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function adds a Joiner entry.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aEui64             A pointer to the Joiner's IEEE EUI-64 or NULL for any Joiner.\n @param[in]  aPskd              A pointer to the PSKd.\n @param[in]  aTimeout           A time after which a Joiner is automatically removed, in seconds.\n\n @retval OT_ERROR_NONE          Successfully added the Joiner.\n @retval OT_ERROR_NO_BUFS       No buffers available to add the Joiner.\n @retval OT_ERROR_INVALID_ARGS  @p aEui64 or @p aPskd is invalid.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerAddJoiner(
        aInstance: *mut otInstance,
        aEui64: *const otExtAddress,
        aPskd: *const ::std::os::raw::c_char,
        aTimeout: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " This function adds a Joiner entry with a given Joiner Discerner value.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aDiscerner         A pointer to the Joiner Discerner.\n @param[in]  aPskd              A pointer to the PSKd.\n @param[in]  aTimeout           A time after which a Joiner is automatically removed, in seconds.\n\n @retval OT_ERROR_NONE          Successfully added the Joiner.\n @retval OT_ERROR_NO_BUFS       No buffers available to add the Joiner.\n @retval OT_ERROR_INVALID_ARGS  @p aDiscerner or @p aPskd is invalid.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerAddJoinerWithDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *const otJoinerDiscerner,
        aPskd: *const ::std::os::raw::c_char,
        aTimeout: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " This method get joiner info at aIterator position.\n\n @param[in]      aInstance   A pointer to instance.\n @param[in,out]  aIterator   A pointer to the Joiner Info iterator context.\n @param[out]     aJoiner     A reference to Joiner info.\n\n @retval OT_ERROR_NONE       Successfully get the Joiner info.\n @retval OT_ERROR_NOT_FOUND  Not found next Joiner.\n"]
    pub fn otCommissionerGetNextJoinerInfo(
        aInstance: *mut otInstance,
        aIterator: *mut u16,
        aJoiner: *mut otJoinerInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function removes a Joiner entry.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aEui64             A pointer to the Joiner's IEEE EUI-64 or NULL for any Joiner.\n\n @retval OT_ERROR_NONE          Successfully removed the Joiner.\n @retval OT_ERROR_NOT_FOUND     The Joiner specified by @p aEui64 was not found.\n @retval OT_ERROR_INVALID_ARGS  @p aEui64 is invalid.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerRemoveJoiner(
        aInstance: *mut otInstance,
        aEui64: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " This function removes a Joiner entry.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aDiscerner         A pointer to the Joiner Discerner.\n\n @retval OT_ERROR_NONE          Successfully removed the Joiner.\n @retval OT_ERROR_NOT_FOUND     The Joiner specified by @p aEui64 was not found.\n @retval OT_ERROR_INVALID_ARGS  @p aDiscerner is invalid.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerRemoveJoinerWithDiscerner(
        aInstance: *mut otInstance,
        aDiscerner: *const otJoinerDiscerner,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the Provisioning URL.\n\n @param[in]    aInstance       A pointer to an OpenThread instance.\n\n @returns A pointer to the URL string.\n"]
    pub fn otCommissionerGetProvisioningUrl(
        aInstance: *mut otInstance,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function sets the Provisioning URL.\n\n @param[in]  aInstance             A pointer to an OpenThread instance.\n @param[in]  aProvisioningUrl      A pointer to the Provisioning URL (may be NULL to set as empty string).\n\n @retval OT_ERROR_NONE          Successfully set the Provisioning URL.\n @retval OT_ERROR_INVALID_ARGS  @p aProvisioningUrl is invalid (too long).\n"]
    pub fn otCommissionerSetProvisioningUrl(
        aInstance: *mut otInstance,
        aProvisioningUrl: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends an Announce Begin message.\n\n @param[in]  aInstance             A pointer to an OpenThread instance.\n @param[in]  aChannelMask          The channel mask value.\n @param[in]  aCount                The number of Announcement messages per channel.\n @param[in]  aPeriod               The time between two successive MLE Announce transmissions (in milliseconds).\n @param[in]  aAddress              A pointer to the IPv6 destination.\n\n @retval OT_ERROR_NONE          Successfully enqueued the Announce Begin message.\n @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate an Announce Begin message.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerAnnounceBegin(
        aInstance: *mut otInstance,
        aChannelMask: u32,
        aCount: u8,
        aPeriod: u16,
        aAddress: *const otIp6Address,
    ) -> otError;
}
#[doc = " This function pointer is called when the Commissioner receives an Energy Report.\n\n @param[in]  aChannelMask       The channel mask value.\n @param[in]  aEnergyList        A pointer to the energy measurement list.\n @param[in]  aEnergyListLength  Number of entries in @p aEnergyListLength.\n @param[in]  aContext           A pointer to application-specific context.\n"]
pub type otCommissionerEnergyReportCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aChannelMask: u32,
        aEnergyList: *const u8,
        aEnergyListLength: u8,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function sends an Energy Scan Query message.\n\n @param[in]  aInstance             A pointer to an OpenThread instance.\n @param[in]  aChannelMask          The channel mask value.\n @param[in]  aCount                The number of energy measurements per channel.\n @param[in]  aPeriod               The time between energy measurements (milliseconds).\n @param[in]  aScanDuration         The scan duration for each energy measurement (milliseconds).\n @param[in]  aAddress              A pointer to the IPv6 destination.\n @param[in]  aCallback             A pointer to a function called on receiving an Energy Report message.\n @param[in]  aContext              A pointer to application-specific context.\n\n @retval OT_ERROR_NONE          Successfully enqueued the Energy Scan Query message.\n @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate an Energy Scan Query message.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerEnergyScan(
        aInstance: *mut otInstance,
        aChannelMask: u32,
        aCount: u8,
        aPeriod: u16,
        aScanDuration: u16,
        aAddress: *const otIp6Address,
        aCallback: otCommissionerEnergyReportCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
#[doc = " This function pointer is called when the Commissioner receives a PAN ID Conflict message.\n\n @param[in]  aPanId             The PAN ID value.\n @param[in]  aChannelMask       The channel mask value.\n @param[in]  aContext           A pointer to application-specific context.\n"]
pub type otCommissionerPanIdConflictCallback = ::std::option::Option<
    unsafe extern "C" fn(aPanId: u16, aChannelMask: u32, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function sends a PAN ID Query message.\n\n @param[in]  aInstance             A pointer to an OpenThread instance.\n @param[in]  aPanId                The PAN ID to query.\n @param[in]  aChannelMask          The channel mask value.\n @param[in]  aAddress              A pointer to the IPv6 destination.\n @param[in]  aCallback             A pointer to a function called on receiving a PAN ID Conflict message.\n @param[in]  aContext              A pointer to application-specific context.\n\n @retval OT_ERROR_NONE          Successfully enqueued the PAN ID Query message.\n @retval OT_ERROR_NO_BUFS       Insufficient buffers to generate a PAN ID Query message.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n\n @note Only use this after successfully starting the Commissioner role with otCommissionerStart().\n"]
    pub fn otCommissionerPanIdQuery(
        aInstance: *mut otInstance,
        aPanId: u16,
        aChannelMask: u32,
        aAddress: *const otIp6Address,
        aCallback: otCommissionerPanIdConflictCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends MGMT_COMMISSIONER_GET.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aTlvs      A pointer to TLVs.\n @param[in]  aLength    The length of TLVs.\n\n @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n"]
    pub fn otCommissionerSendMgmtGet(
        aInstance: *mut otInstance,
        aTlvs: *const u8,
        aLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends MGMT_COMMISSIONER_SET.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aDataset   A pointer to commissioning dataset.\n @param[in]  aTlvs      A pointer to TLVs.\n @param[in]  aLength    The length of TLVs.\n\n @retval OT_ERROR_NONE          Successfully send the meshcop dataset command.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer space to send.\n @retval OT_ERROR_INVALID_STATE The commissioner is not active.\n"]
    pub fn otCommissionerSendMgmtSet(
        aInstance: *mut otInstance,
        aDataset: *const otCommissioningDataset,
        aTlvs: *const u8,
        aLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns the Commissioner Session ID.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns The current commissioner session id.\n"]
    pub fn otCommissionerGetSessionId(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " This function returns the Commissioner State.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @retval OT_COMMISSIONER_STATE_DISABLED  Commissioner disabled.\n @retval OT_COMMISSIONER_STATE_PETITION  Becoming the commissioner.\n @retval OT_COMMISSIONER_STATE_ACTIVE    Commissioner enabled.\n"]
    pub fn otCommissionerGetState(aInstance: *mut otInstance) -> otCommissionerState;
}
extern "C" {
    #[doc = " For FTD only, creates a new Operational Dataset to use when forming a new network.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[out] aDataset   The Operational Dataset.\n\n @retval OT_ERROR_NONE    Successfully created a new Operational Dataset.\n @retval OT_ERROR_FAILED  Failed to generate random values for new parameters.\n"]
    pub fn otDatasetCreateNewNetwork(
        aInstance: *mut otInstance,
        aDataset: *mut otOperationalDataset,
    ) -> otError;
}
extern "C" {
    #[doc = " For FTD only, gets a minimal delay timer.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval the value of minimal delay timer (in ms).\n"]
    pub fn otDatasetGetDelayTimerMinimal(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " For FTD only, sets a minimal delay timer.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance           A pointer to an OpenThread instance.\n @param[in]  aDelayTimerMinimal  The value of minimal delay timer (in ms).\n\n @retval  OT_ERROR_NONE          Successfully set minimal delay timer.\n @retval  OT_ERROR_INVALID_ARGS  If @p aDelayTimerMinimal is not valid.\n"]
    pub fn otDatasetSetDelayTimerMinimal(
        aInstance: *mut otInstance,
        aDelayTimerMinimal: u32,
    ) -> otError;
}
#[doc = " This callback function pointer is called when a Dataset update request finishes, reporting success or failure status\n of the Dataset update request.\n\n Available when `OPENTHREAD_CONFIG_DATASET_UPDATER_ENABLE` is enabled.\n\n @param[in] aError   The error status.\n                     OT_ERROR_NONE            indicates successful Dataset update.\n                     OT_ERROR_INVALID_STATE   indicates failure due invalid state (MLE being disabled).\n                     OT_ERROR_ALREADY         indicates failure due to another device within network requesting\n                                              a conflicting Dataset update.\n\n @param[in] aContext A pointer to the arbitrary context (provided by user in `otDatasetUpdaterRequestUpdate()`).\n"]
pub type otDatasetUpdaterCallback = ::std::option::Option<
    unsafe extern "C" fn(aError: otError, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function requests an update to Operational Dataset.\n\n Available when `OPENTHREAD_CONFIG_DATASET_UPDATER_ENABLE` is enabled.\n\n @p aDataset should contain the fields to be updated and their new value. It must not contain Active or Pending\n Timestamp fields. The Delay field is optional, if not provided a default value (1000 ms) would be used.\n\n @param[in]  aInstance               A pointer to an OpenThread instance.\n @param[in]  aDataset                A pointer to the Dataset containing the fields to change.\n @param[in]  aCallback               A callback to indicate when Dataset update request finishes.\n @param[in]  aContext                An arbitrary context passed to callback.\n\n @retval OT_ERROR_NONE           Dataset update started successfully (@p aCallback will be invoked on completion).\n @retval OT_ERROR_INVALID_STATE  Device is disabled (MLE is disabled).\n @retval OT_ERROR_INVALID_ARGS   The @p aDataset is not valid (contains Active or Pending Timestamp).\n @retval OT_ERROR_BUSY           Cannot start update, a previous one is ongoing.\n @retval OT_ERROR_NO_BUFS        Could not allocated buffer to save Dataset.\n"]
    pub fn otDatasetUpdaterRequestUpdate(
        aInstance: *mut otInstance,
        aDataset: *const otOperationalDataset,
        aCallback: otDatasetUpdaterCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function cancels an ongoing (if any) Operational Dataset update request.\n\n Available when `OPENTHREAD_CONFIG_DATASET_UPDATER_ENABLE` is enabled.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n"]
    pub fn otDatasetUpdaterCancelUpdate(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function indicates whether there is an ongoing Operation Dataset update request.\n\n Available when `OPENTHREAD_CONFIG_DATASET_UPDATER_ENABLE` is enabled.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n\n @retval TRUE    There is an ongoing update.\n @retval FALSE   There is no ongoing update.\n"]
    pub fn otDatasetUpdaterIsUpdateOngoing(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function processes a factory diagnostics command line.\n\n The output of this function (the content written to @p aOutput) MUST terminate with `\\0` and the `\\0` is within the\n output buffer.\n\n @param[in]   aInstance       A pointer to an OpenThread instance.\n @param[in]   aArgsLength     The number of elements in @p aArgs.\n @param[in]   aArgs           An array of arguments.\n @param[out]  aOutput         The diagnostics execution result.\n @param[in]   aOutputMaxLen   The output buffer size.\n\n @retval  OT_ERROR_INVALID_ARGS       The command is supported but invalid arguments provided.\n @retval  OT_ERROR_NONE               The command is successfully process.\n @retval  OT_ERROR_NOT_IMPLEMENTED    The command is not supported.\n"]
    pub fn otDiagProcessCmd(
        aInstance: *mut otInstance,
        aArgsLength: u8,
        aArgs: *mut *mut ::std::os::raw::c_char,
        aOutput: *mut ::std::os::raw::c_char,
        aOutputMaxLen: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " This function processes a factory diagnostics command line.\n\n The output of this function (the content written to @p aOutput) MUST terminate with `\\0` and the `\\0` is within the\n output buffer.\n\n @param[in]   aInstance       A pointer to an OpenThread instance.\n @param[in]   aString         A NULL-terminated input string.\n @param[out]  aOutput         The diagnostics execution result.\n @param[in]   aOutputMaxLen   The output buffer size.\n\n @retval  OT_ERROR_NONE               The command is successfully process.\n @retval  OT_ERROR_INVALID_ARGS       The command is supported but invalid arguments provided.\n @retval  OT_ERROR_NOT_IMPLEMENTED    The command is not supported.\n @retval  OT_ERROR_NO_BUFS            The command string is too long.\n"]
    pub fn otDiagProcessCmdLine(
        aInstance: *mut otInstance,
        aString: *const ::std::os::raw::c_char,
        aOutput: *mut ::std::os::raw::c_char,
        aOutputMaxLen: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not the factory diagnostics mode is enabled.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @retval TRUE if factory diagnostics mode is enabled\n @retval FALSE if factory diagnostics mode is disabled.\n"]
    pub fn otDiagIsEnabled(aInstance: *mut otInstance) -> bool;
}
#[doc = " This structure represents a TXT record entry representing a key/value pair (RFC 6763 - section 6.3).\n\n The string buffers pointed to by `mKey` and `mValue` MUST persist and remain unchanged after an instance of such\n structure is passed to OpenThread (as part of `otSrpClientService` instance).\n\n An array of `otDnsTxtEntry` entries are used in `otSrpClientService` to specify the full TXT record (a list of\n entries).\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnsTxtEntry {
    #[doc = " The TXT record key string.\n\n If `mKey` is not NULL, then it MUST be a null-terminated C string. The entry is treated as key/value pair with\n `mValue` buffer providing the value.\n   - The entry is encoded as follows:\n        - A single string length byte followed by \"key=value\" format (without the quotation marks).\n- In this case, the overall encoded length must be 255 bytes or less.\n   - If `mValue` is NULL, then key is treated as a boolean attribute and encoded as \"key\" (with no `=`).\n   - If `mValue` is not NULL but `mValueLength` is zero, then it is treated as empty value and encoded as \"key=\".\n\n If `mKey` is NULL, then `mValue` buffer is treated as an already encoded TXT-DATA and is appended as is in the\n DNS message.\n"]
    pub mKey: *const ::std::os::raw::c_char,
    #[doc = "< The TXT record value or already encoded TXT-DATA (depending on `mKey`)."]
    pub mValue: *const u8,
    #[doc = "< Number of bytes in `mValue` buffer."]
    pub mValueLength: u16,
}
impl Default for otDnsTxtEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents an iterator for TXT record entries (key/value pairs).\n\n The data fields in this structure are intended for use by OpenThread core and caller should not read or change them.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnsTxtEntryIterator {
    pub mPtr: *const ::std::os::raw::c_void,
    pub mData: [u16; 2usize],
    pub mChar: [::std::os::raw::c_char; 10usize],
}
impl Default for otDnsTxtEntryIterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function initializes a TXT record iterator.\n\n The buffer pointer @p aTxtData and its content MUST persist and remain unchanged while @p aIterator object\n is being used.\n\n @param[in] aIterator       A pointer to the iterator to initialize (MUST NOT be NULL).\n @param[in] aTxtData        A pointer to buffer containing the encoded TXT data.\n @param[in] aTxtDataLength  The length (number of bytes) of @p aTxtData.\n"]
    pub fn otDnsInitTxtEntryIterator(
        aIterator: *mut otDnsTxtEntryIterator,
        aTxtData: *const u8,
        aTxtDataLength: u16,
    );
}
extern "C" {
    #[doc = " This function parses the TXT data from an iterator and gets the next TXT record entry (key/value pair).\n\n The @p aIterator MUST be initialized using `otDnsInitTxtEntryIterator()` before calling this function and the TXT\n data buffer used to initialize the iterator MUST persist and remain unchanged. Otherwise the behavior of this\n function is undefined.\n\n If the parsed key string length is smaller than or equal to `OT_DNS_TXT_KEY_MAX_LENGTH` (recommended max key length)\n the key string is returned in `mKey` in @p aEntry. But if the key is longer, then `mKey` is set to NULL and the\n entire encoded TXT entry string is returned in `mValue` and `mValueLength`.\n\n @param[in]  aIterator   A pointer to the iterator (MUST NOT be NULL).\n @param[out] aEntry      A pointer to a `otDnsTxtEntry` structure to output the parsed/read entry (MUST NOT be NULL).\n\n @retval OT_ERROR_NONE       The next entry was parsed successfully. @p aEntry is updated.\n @retval OT_ERROR_NOT_FOUND  No more entries in the TXT data.\n @retval OT_ERROR_PARSE      The TXT data from @p aIterator is not well-formed.\n"]
    pub fn otDnsGetNextTxtEntry(
        aIterator: *mut otDnsTxtEntryIterator,
        aEntry: *mut otDnsTxtEntry,
    ) -> otError;
}
extern "C" {
    #[doc = " This function enables/disables the \"DNS name compression\" mode.\n\n By default DNS name compression is enabled. When disabled, DNS names are appended as full and never compressed. This\n is applicable to OpenThread's DNS and SRP client/server modules.\n\n This is intended for testing only and available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` config is enabled.\n\n Note that in the case `OPENTHREAD_CONFIG_MULTIPLE_INSTANCE_ENABLE` is used, this mode applies to all OpenThread\n instances (i.e., calling this function enables/disables the compression mode on all OpenThread instances).\n\n @param[in] aEnabled   TRUE to enable the \"DNS name compression\" mode, FALSE to disable.\n"]
    pub fn otDnsSetNameCompressionEnabled(aEnabled: bool);
}
extern "C" {
    #[doc = " This function indicates whether the \"DNS name compression\" mode is enabled or not.\n\n This is intended for testing only and available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` config is enabled.\n\n @returns TRUE if the \"DNS name compression\" mode is enabled, FALSE otherwise.\n"]
    pub fn otDnsIsNameCompressionEnabled() -> bool;
}
#[doc = "< Indicates the flag is not specified."]
pub const OT_DNS_FLAG_UNSPECIFIED: otDnsRecursionFlag = 0;
#[doc = "< Indicates DNS name server can resolve the query recursively."]
pub const OT_DNS_FLAG_RECURSION_DESIRED: otDnsRecursionFlag = 1;
#[doc = "< Indicates DNS name server can not resolve the query recursively."]
pub const OT_DNS_FLAG_NO_RECURSION: otDnsRecursionFlag = 2;
#[doc = " This enumeration type represents the \"Recursion Desired\" (RD) flag in an `otDnsQueryConfig`.\n"]
pub type otDnsRecursionFlag = ::std::os::raw::c_uint;
#[doc = "< NAT64 mode is not specified. Use default NAT64 mode."]
pub const OT_DNS_NAT64_UNSPECIFIED: otDnsNat64Mode = 0;
#[doc = "< Allow NAT64 address translation during DNS client address resolution."]
pub const OT_DNS_NAT64_ALLOW: otDnsNat64Mode = 1;
#[doc = "< Do not allow NAT64 address translation during DNS client address resolution."]
pub const OT_DNS_NAT64_DISALLOW: otDnsNat64Mode = 2;
#[doc = " This enumeration type represents the NAT64 mode in an `otDnsQueryConfig`.\n\n The NAT64 mode indicates whether to allow or disallow NAT64 address translation during DNS client address resolution.\n This mode is only used when `OPENTHREAD_CONFIG_DNS_CLIENT_NAT64_ENABLE` is enabled.\n"]
pub type otDnsNat64Mode = ::std::os::raw::c_uint;
#[doc = "< Mode is not specified. Use default service mode."]
pub const OT_DNS_SERVICE_MODE_UNSPECIFIED: otDnsServiceMode = 0;
#[doc = "< Query for SRV record only."]
pub const OT_DNS_SERVICE_MODE_SRV: otDnsServiceMode = 1;
#[doc = "< Query for TXT record only."]
pub const OT_DNS_SERVICE_MODE_TXT: otDnsServiceMode = 2;
#[doc = "< Query for both SRV and TXT records in same message."]
pub const OT_DNS_SERVICE_MODE_SRV_TXT: otDnsServiceMode = 3;
#[doc = "< Query in parallel for SRV and TXT using separate messages."]
pub const OT_DNS_SERVICE_MODE_SRV_TXT_SEPARATE: otDnsServiceMode = 4;
#[doc = "< Query for TXT/SRV together first, if fails then query separately."]
pub const OT_DNS_SERVICE_MODE_SRV_TXT_OPTIMIZE: otDnsServiceMode = 5;
#[doc = " This enumeration type represents the service resolution mode in an `otDnsQueryConfig`.\n\n This is only used during DNS client service resolution `otDnsClientResolveService()`. It determines which\n record types to query.\n"]
pub type otDnsServiceMode = ::std::os::raw::c_uint;
pub const OT_DNS_TRANSPORT_UNSPECIFIED: otDnsTransportProto = 0;
#[doc = " DNS transport is unspecified."]
pub const OT_DNS_TRANSPORT_UDP: otDnsTransportProto = 1;
#[doc = " DNS query should be sent via UDP."]
pub const OT_DNS_TRANSPORT_TCP: otDnsTransportProto = 2;
#[doc = " This enumeration type represents the DNS transport protocol in an `otDnsQueryConfig`.\n\n This `OT_DNS_TRANSPORT_TCP` is only supported when `OPENTHREAD_CONFIG_DNS_CLIENT_OVER_TCP_ENABLE` is enabled.\n"]
pub type otDnsTransportProto = ::std::os::raw::c_uint;
#[doc = " This structure represents a DNS query configuration.\n\n Any of the fields in this structure can be set to zero to indicate that it is not specified. How the unspecified\n fields are treated is determined by the function which uses the instance of `otDnsQueryConfig`.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otDnsQueryConfig {
    #[doc = "< Server address (IPv6 addr/port). All zero or zero port for unspecified."]
    pub mServerSockAddr: otSockAddr,
    #[doc = "< Wait time (in msec) to rx response. Zero indicates unspecified value."]
    pub mResponseTimeout: u32,
    #[doc = "< Maximum tx attempts before reporting failure. Zero for unspecified value."]
    pub mMaxTxAttempts: u8,
    #[doc = "< Indicates whether the server can resolve the query recursively or not."]
    pub mRecursionFlag: otDnsRecursionFlag,
    #[doc = "< Allow/Disallow NAT64 address translation during address resolution."]
    pub mNat64Mode: otDnsNat64Mode,
    #[doc = "< Determines which records to query during service resolution."]
    pub mServiceMode: otDnsServiceMode,
    #[doc = "< Select default transport protocol."]
    pub mTransportProto: otDnsTransportProto,
}
impl Default for otDnsQueryConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function gets the current default query config used by DNS client.\n\n When OpenThread stack starts, the default DNS query config is determined from a set of OT config options such as\n `OPENTHREAD_CONFIG_DNS_CLIENT_DEFAULT_SERVER_IP6_ADDRESS`, `_DEFAULT_SERVER_PORT`, `_DEFAULT_RESPONSE_TIMEOUT`, etc.\n (see `config/dns_client.h` for all related config options).\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n\n @returns A pointer to the current default config being used by DNS client.\n"]
    pub fn otDnsClientGetDefaultConfig(aInstance: *mut otInstance) -> *const otDnsQueryConfig;
}
extern "C" {
    #[doc = " This function sets the default query config on DNS client.\n\n @note Any ongoing query will continue to use the config from when it was started. The new default config will be\n used for any future DNS queries.\n\n The @p aConfig can be NULL. In this case the default config will be set to the defaults from OT config options\n `OPENTHREAD_CONFIG_DNS_CLIENT_DEFAULT_{}`. This resets the default query config back to to the config when the\n OpenThread stack starts.\n\n In a non-NULL @p aConfig, caller can choose to leave some of the fields in `otDnsQueryConfig` instance unspecified\n (value zero). The unspecified fields are replaced by the corresponding OT config option definitions\n `OPENTHREAD_CONFIG_DNS_CLIENT_DEFAULT_{}` to form the default query config.\n\n When `OPENTHREAD_CONFIG_DNS_CLIENT_DEFAULT_SERVER_ADDRESS_AUTO_SET_ENABLE` is enabled, the server's IPv6 address in\n the default config is automatically set and updated by DNS client. This is done only when user does not explicitly\n set or specify it. This behavior requires SRP client and its auto-start feature to be enabled. SRP client will then\n monitor the Thread Network Data for DNS/SRP Service entries to select an SRP server. The selected SRP server address\n is also set as the DNS server address in the default config.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aConfig     A pointer to the new query config to use as default.\n"]
    pub fn otDnsClientSetDefaultConfig(
        aInstance: *mut otInstance,
        aConfig: *const otDnsQueryConfig,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnsAddressResponse {
    _unused: [u8; 0],
}
#[doc = " This function pointer is called when a DNS response is received for an address resolution query.\n\n Within this callback the user can use `otDnsAddressResponseGet{Item}()` functions along with the @p aResponse\n pointer to get more info about the response.\n\n The @p aResponse pointer can only be used within this callback and after returning from this function it will not\n stay valid, so the user MUST NOT retain the @p aResponse pointer for later use.\n\n @param[in]  aError     The result of the DNS transaction.\n @param[in]  aResponse  A pointer to the response (it is always non-NULL).\n @param[in]  aContext   A pointer to application-specific context.\n\n The @p aError can have the following:\n\n  - OT_ERROR_NONE              A response was received successfully.\n  - OT_ERROR_ABORT             A DNS transaction was aborted by stack.\n  - OT_ERROR_RESPONSE_TIMEOUT  No DNS response has been received within timeout.\n\n If the server rejects the address resolution request the error code from server is mapped as follow:\n\n  - (0)  NOERROR   Success (no error condition)                    -> OT_ERROR_NONE\n  - (1)  FORMERR   Server unable to interpret due to format error  -> OT_ERROR_PARSE\n  - (2)  SERVFAIL  Server encountered an internal failure          -> OT_ERROR_FAILED\n  - (3)  NXDOMAIN  Name that ought to exist, does not exist        -> OT_ERROR_NOT_FOUND\n  - (4)  NOTIMP    Server does not support the query type (OpCode) -> OT_ERROR_NOT_IMPLEMENTED\n  - (5)  REFUSED   Server refused for policy/security reasons      -> OT_ERROR_SECURITY\n  - (6)  YXDOMAIN  Some name that ought not to exist, does exist   -> OT_ERROR_DUPLICATED\n  - (7)  YXRRSET   Some RRset that ought not to exist, does exist  -> OT_ERROR_DUPLICATED\n  - (8)  NXRRSET   Some RRset that ought to exist, does not exist  -> OT_ERROR_NOT_FOUND\n  - (9)  NOTAUTH   Service is not authoritative for zone           -> OT_ERROR_SECURITY\n  - (10) NOTZONE   A name is not in the zone                       -> OT_ERROR_PARSE\n  - (20) BADNAME   Bad name                                        -> OT_ERROR_PARSE\n  - (21) BADALG    Bad algorithm                                   -> OT_ERROR_SECURITY\n  - (22) BADTRUN   Bad truncation                                  -> OT_ERROR_PARSE\n  - Other response codes                                           -> OT_ERROR_FAILED\n"]
pub type otDnsAddressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aError: otError,
        aResponse: *const otDnsAddressResponse,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function sends an address resolution DNS query for AAAA (IPv6) record(s) for a given host name.\n\n The @p aConfig can be NULL. In this case the default config (from `otDnsClientGetDefaultConfig()`) will be used as\n the config for this query. In a non-NULL @p aConfig, some of the fields can be left unspecified (value zero). The\n unspecified fields are then replaced by the values from the default config.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aHostName        The host name for which to query the address (MUST NOT be NULL).\n @param[in]  aCallback        A function pointer that shall be called on response reception or time-out.\n @param[in]  aContext         A pointer to arbitrary context information.\n @param[in]  aConfig          A pointer to the config to use for this query.\n\n @retval OT_ERROR_NONE          Query sent successfully. @p aCallback will be invoked to report the status.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer to prepare and send query.\n @retval OT_ERROR_INVALID_ARGS  The host name is not valid format.\n @retval OT_ERROR_INVALID_STATE Cannot send query since Thread interface is not up.\n"]
    pub fn otDnsClientResolveAddress(
        aInstance: *mut otInstance,
        aHostName: *const ::std::os::raw::c_char,
        aCallback: otDnsAddressCallback,
        aContext: *mut ::std::os::raw::c_void,
        aConfig: *const otDnsQueryConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends an address resolution DNS query for A (IPv4) record(s) for a given host name.\n\n This function requires and is available when `OPENTHREAD_CONFIG_DNS_CLIENT_NAT64_ENABLE` is enabled.\n\n When a successful response is received, the addresses are returned from @p aCallback as NAT64 IPv6 translated\n versions of the IPv4 addresses from the query response.\n\n The @p aConfig can be NULL. In this case the default config (from `otDnsClientGetDefaultConfig()`) will be used as\n the config for this query. In a non-NULL @p aConfig, some of the fields can be left unspecified (value zero). The\n unspecified fields are then replaced by the values from the default config.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aHostName        The host name for which to query the address (MUST NOT be NULL).\n @param[in]  aCallback        A function pointer that shall be called on response reception or time-out.\n @param[in]  aContext         A pointer to arbitrary context information.\n @param[in]  aConfig          A pointer to the config to use for this query.\n\n @retval OT_ERROR_NONE          Query sent successfully. @p aCallback will be invoked to report the status.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer to prepare and send query.\n @retval OT_ERROR_INVALID_ARGS  The host name is not valid format or NAT64 is not enabled in config.\n @retval OT_ERROR_INVALID_STATE Cannot send query since Thread interface is not up.\n"]
    pub fn otDnsClientResolveIp4Address(
        aInstance: *mut otInstance,
        aHostName: *const ::std::os::raw::c_char,
        aCallback: otDnsAddressCallback,
        aContext: *mut ::std::os::raw::c_void,
        aConfig: *const otDnsQueryConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the full host name associated with an address resolution DNS response.\n\n This function MUST only be used from `otDnsAddressCallback`.\n\n @param[in]  aResponse         A pointer to the response.\n @param[out] aNameBuffer       A buffer to char array to output the full host name (MUST NOT be NULL).\n @param[in]  aNameBufferSize   The size of @p aNameBuffer.\n\n @retval OT_ERROR_NONE     The full host name was read successfully.\n @retval OT_ERROR_NO_BUFS  The name does not fit in @p aNameBuffer.\n"]
    pub fn otDnsAddressResponseGetHostName(
        aResponse: *const otDnsAddressResponse,
        aNameBuffer: *mut ::std::os::raw::c_char,
        aNameBufferSize: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets an IPv6 address associated with an address resolution DNS response.\n\n This function MUST only be used from `otDnsAddressCallback`.\n\n The response may include multiple IPv6 address records. @p aIndex can be used to iterate through the list of\n addresses. Index zero gets the first address and so on. When we reach end of the list, `OT_ERROR_NOT_FOUND` is\n returned.\n\n @param[in]  aResponse     A pointer to the response.\n @param[in]  aIndex        The address record index to retrieve.\n @param[out] aAddress      A pointer to a IPv6 address to output the address (MUST NOT be NULL).\n @param[out] aTtl          A pointer to an `uint32_t` to output TTL for the address. It can be NULL if caller does not\n                           want to get the TTL.\n\n @retval OT_ERROR_NONE           The address was read successfully.\n @retval OT_ERROR_NOT_FOUND      No address record in @p aResponse at @p aIndex.\n @retval OT_ERROR_PARSE          Could not parse the records in the @p aResponse.\n @retval OT_ERROR_INVALID_STATE  No NAT64 prefix (applicable only when NAT64 is allowed).\n"]
    pub fn otDnsAddressResponseGetAddress(
        aResponse: *const otDnsAddressResponse,
        aIndex: u16,
        aAddress: *mut otIp6Address,
        aTtl: *mut u32,
    ) -> otError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnsBrowseResponse {
    _unused: [u8; 0],
}
#[doc = " This function pointer is called when a DNS response is received for a browse (service instance enumeration) query.\n\n Within this callback the user can use `otDnsBrowseResponseGet{Item}()` functions along with the @p aResponse\n pointer to get more info about the response.\n\n The @p aResponse pointer can only be used within this callback and after returning from this function it will not\n stay valid, so the user MUST NOT retain the @p aResponse pointer for later use.\n\n @param[in]  aError     The result of the DNS transaction.\n @param[in]  aResponse  A pointer to the response (it is always non-NULL).\n @param[in]  aContext   A pointer to application-specific context.\n\n For the full list of possible values for @p aError, please see `otDnsAddressCallback()`.\n"]
pub type otDnsBrowseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aError: otError,
        aResponse: *const otDnsBrowseResponse,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " This structure provides info for a DNS service instance.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otDnsServiceInfo {
    #[doc = "< Service record TTL (in seconds)."]
    pub mTtl: u32,
    #[doc = "< Service port number."]
    pub mPort: u16,
    #[doc = "< Service priority."]
    pub mPriority: u16,
    #[doc = "< Service weight."]
    pub mWeight: u16,
    #[doc = "< Buffer to output the service host name (can be NULL if not needed)."]
    pub mHostNameBuffer: *mut ::std::os::raw::c_char,
    #[doc = "< Size of `mHostNameBuffer`."]
    pub mHostNameBufferSize: u16,
    #[doc = "< The host IPv6 address. Set to all zero if not available."]
    pub mHostAddress: otIp6Address,
    #[doc = "< The host address TTL."]
    pub mHostAddressTtl: u32,
    #[doc = "< Buffer to output TXT data (can be NULL if not needed)."]
    pub mTxtData: *mut u8,
    #[doc = "< On input, size of `mTxtData` buffer. On output number bytes written."]
    pub mTxtDataSize: u16,
    #[doc = "< Indicates if TXT data could not fit in `mTxtDataSize` and was truncated."]
    pub mTxtDataTruncated: bool,
    #[doc = "< The TXT data TTL."]
    pub mTxtDataTtl: u32,
}
impl Default for otDnsServiceInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function sends a DNS browse (service instance enumeration) query for a given service name.\n\n This function is available when `OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE` is enabled.\n\n The @p aConfig can be NULL. In this case the default config (from `otDnsClientGetDefaultConfig()`) will be used as\n the config for this query. In a non-NULL @p aConfig, some of the fields can be left unspecified (value zero). The\n unspecified fields are then replaced by the values from the default config.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aServiceName     The service name to query for (MUST NOT be NULL).\n @param[in]  aCallback        A function pointer that shall be called on response reception or time-out.\n @param[in]  aContext         A pointer to arbitrary context information.\n @param[in]  aConfig          A pointer to the config to use for this query.\n\n @retval OT_ERROR_NONE        Query sent successfully. @p aCallback will be invoked to report the status.\n @retval OT_ERROR_NO_BUFS     Insufficient buffer to prepare and send query.\n"]
    pub fn otDnsClientBrowse(
        aInstance: *mut otInstance,
        aServiceName: *const ::std::os::raw::c_char,
        aCallback: otDnsBrowseCallback,
        aContext: *mut ::std::os::raw::c_void,
        aConfig: *const otDnsQueryConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the service name associated with a DNS browse (service instance enumeration) response.\n\n This function MUST only be used from `otDnsBrowseCallback`.\n\n @param[in]  aResponse         A pointer to the response.\n @param[out] aNameBuffer       A buffer to char array to output the service name (MUST NOT be NULL).\n @param[in]  aNameBufferSize   The size of @p aNameBuffer.\n\n @retval OT_ERROR_NONE     The service name was read successfully.\n @retval OT_ERROR_NO_BUFS  The name does not fit in @p aNameBuffer.\n"]
    pub fn otDnsBrowseResponseGetServiceName(
        aResponse: *const otDnsBrowseResponse,
        aNameBuffer: *mut ::std::os::raw::c_char,
        aNameBufferSize: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets a service instance associated with a DNS browse (service instance enumeration) response.\n\n This function MUST only be used from `otDnsBrowseCallback`.\n\n The response may include multiple service instance records. @p aIndex can be used to iterate through the list. Index\n zero gives the the first record. When we reach end of the list, `OT_ERROR_NOT_FOUND` is returned.\n\n Note that this function gets the service instance label and not the full service instance name which is of the form\n `<Instance>.<Service>.<Domain>`.\n\n @param[in]  aResponse          A pointer to the response.\n @param[in]  aIndex             The service instance record index to retrieve.\n @param[out] aLabelBuffer       A buffer to char array to output the service instance label (MUST NOT be NULL).\n @param[in]  aLabelBufferSize   The size of @p aLabelBuffer.\n\n @retval OT_ERROR_NONE          The service instance was read successfully.\n @retval OT_ERROR_NO_BUFS       The name does not fit in @p aNameBuffer.\n @retval OT_ERROR_NOT_FOUND     No service instance record in @p aResponse at @p aIndex.\n @retval OT_ERROR_PARSE         Could not parse the records in the @p aResponse.\n"]
    pub fn otDnsBrowseResponseGetServiceInstance(
        aResponse: *const otDnsBrowseResponse,
        aIndex: u16,
        aLabelBuffer: *mut ::std::os::raw::c_char,
        aLabelBufferSize: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets info for a service instance from a DNS browse (service instance enumeration) response.\n\n This function MUST only be used from `otDnsBrowseCallback`.\n\n A browse DNS response can include SRV, TXT, and AAAA records for the service instances that are enumerated. This is\n a SHOULD and not a MUST requirement, and servers/resolvers are not required to provide this. This function attempts\n to retrieve this info for a given service instance when available.\n\n - If no matching SRV record is found in @p aResponse, `OT_ERROR_NOT_FOUND` is returned. In this case, no additional\n   records (no TXT and/or AAAA) are read.\n - If a matching SRV record is found in @p aResponse, @p aServiceInfo is updated and `OT_ERROR_NONE` is returned.\n - If no matching TXT record is found in @p aResponse, `mTxtDataSize` in @p aServiceInfo is set to zero.\n - If TXT data length is greater than `mTxtDataSize`, it is read partially and `mTxtDataTruncated` is set to true.\n - If no matching AAAA record is found in @p aResponse, `mHostAddress is set to all zero or unspecified address.\n - If there are multiple AAAA records for the host name in @p aResponse, `mHostAddress` is set to the first one. The\n   other addresses can be retrieved using `otDnsBrowseResponseGetHostAddress()`.\n\n @param[in]  aResponse          A pointer to the response.\n @param[in]  aInstanceLabel     The service instance label (MUST NOT be NULL).\n @param[out] aServiceInfo       A `ServiceInfo` to output the service instance information (MUST NOT be NULL).\n\n @retval OT_ERROR_NONE          The service instance info was read. @p aServiceInfo is updated.\n @retval OT_ERROR_NOT_FOUND     Could not find a matching SRV record for @p aInstanceLabel.\n @retval OT_ERROR_NO_BUFS       The host name and/or TXT data could not fit in the given buffers.\n @retval OT_ERROR_PARSE         Could not parse the records in the @p aResponse.\n"]
    pub fn otDnsBrowseResponseGetServiceInfo(
        aResponse: *const otDnsBrowseResponse,
        aInstanceLabel: *const ::std::os::raw::c_char,
        aServiceInfo: *mut otDnsServiceInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the host IPv6 address from a DNS browse (service instance enumeration) response.\n\n This function MUST only be used from `otDnsBrowseCallback`.\n\n The response can include zero or more IPv6 address records. @p aIndex can be used to iterate through the list of\n addresses. Index zero gets the first address and so on. When we reach end of the list, `OT_ERROR_NOT_FOUND` is\n returned.\n\n @param[in]  aResponse     A pointer to the response.\n @param[in]  aHostName     The host name to get the address (MUST NOT be NULL).\n @param[in]  aIndex        The address record index to retrieve.\n @param[out] aAddress      A pointer to a IPv6 address to output the address (MUST NOT be NULL).\n @param[out] aTtl          A pointer to an `uint32_t` to output TTL for the address. It can be NULL if caller does\n                           not want to get the TTL.\n\n @retval OT_ERROR_NONE       The address was read successfully.\n @retval OT_ERROR_NOT_FOUND  No address record for @p aHostname in @p aResponse at @p aIndex.\n @retval OT_ERROR_PARSE      Could not parse the records in the @p aResponse.\n"]
    pub fn otDnsBrowseResponseGetHostAddress(
        aResponse: *const otDnsBrowseResponse,
        aHostName: *const ::std::os::raw::c_char,
        aIndex: u16,
        aAddress: *mut otIp6Address,
        aTtl: *mut u32,
    ) -> otError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnsServiceResponse {
    _unused: [u8; 0],
}
#[doc = " This function pointer is called when a DNS response is received for a service instance resolution query.\n\n Within this callback the user can use `otDnsServiceResponseGet{Item}()` functions along with the @p aResponse\n pointer to get more info about the response.\n\n The @p aResponse pointer can only be used within this callback and after returning from this function it will not\n stay valid, so the user MUST NOT retain the @p aResponse pointer for later use.\n\n @param[in]  aError     The result of the DNS transaction.\n @param[in]  aResponse  A pointer to the response (it is always non-NULL).\n @param[in]  aContext   A pointer to application-specific context.\n\n For the full list of possible values for @p aError, please see `otDnsAddressCallback()`.\n"]
pub type otDnsServiceCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aError: otError,
        aResponse: *const otDnsServiceResponse,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function starts a DNS service instance resolution for a given service instance.\n\n This function is available when `OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE` is enabled.\n\n The @p aConfig can be NULL. In this case the default config (from `otDnsClientGetDefaultConfig()`) will be used as\n the config for this query. In a non-NULL @p aConfig, some of the fields can be left unspecified (value zero). The\n unspecified fields are then replaced by the values from the default config.\n\n The function sends queries for SRV and/or TXT records for the given service instance. The `mServiceMode` field in\n `otDnsQueryConfig` determines which records to query (SRV only, TXT only, or both SRV and TXT) and how to perform\n the query (together in the same message, separately in parallel, or in optimized mode where client will try in the\n same message first and then separately if it fails to get a response).\n\n The SRV record provides information about service port, priority, and weight along with the host name associated\n with the service instance. This function DOES NOT perform address resolution for the host name discovered from SRV\n record. The server/resolver may provide AAAA/A record(s) for the host name in the Additional Data section of the\n response to SRV/TXT query and this information can be retrieved using `otDnsServiceResponseGetServiceInfo()` in\n `otDnsServiceCallback`. Users of this API MUST NOT assume that host address will always be available from\n `otDnsServiceResponseGetServiceInfo()`.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aInstanceLabel     The service instance label.\n @param[in]  aServiceName       The service name (together with @p aInstanceLabel form full instance name).\n @param[in]  aCallback          A function pointer that shall be called on response reception or time-out.\n @param[in]  aContext           A pointer to arbitrary context information.\n @param[in]  aConfig            A pointer to the config to use for this query.\n\n @retval OT_ERROR_NONE          Query sent successfully. @p aCallback will be invoked to report the status.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer to prepare and send query.\n @retval OT_ERROR_INVALID_ARGS  @p aInstanceLabel is NULL.\n"]
    pub fn otDnsClientResolveService(
        aInstance: *mut otInstance,
        aInstanceLabel: *const ::std::os::raw::c_char,
        aServiceName: *const ::std::os::raw::c_char,
        aCallback: otDnsServiceCallback,
        aContext: *mut ::std::os::raw::c_void,
        aConfig: *const otDnsQueryConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This function starts a DNS service instance resolution for a given service instance, with a potential follow-up\n address resolution for the host name discovered for the service instance.\n\n This function is available when `OPENTHREAD_CONFIG_DNS_CLIENT_SERVICE_DISCOVERY_ENABLE` is enabled.\n\n The @p aConfig can be NULL. In this case the default config (from `otDnsClientGetDefaultConfig()`) will be used as\n the config for this query. In a non-NULL @p aConfig, some of the fields can be left unspecified (value zero). The\n unspecified fields are then replaced by the values from the default config. This function cannot be used with\n `mServiceMode` in DNS config set to `OT_DNS_SERVICE_MODE_TXT` (i.e., querying for TXT record only) and will return\n `OT_ERROR_INVALID_ARGS`.\n\n This function behaves similarly to `otDnsClientResolveService()` sending queries for SRV and TXT records. However,\n if the server/resolver does not provide AAAA/A records for the host name in the response to SRV query (in the\n Additional Data section), it will perform host name resolution (sending an AAAA query) for the discovered host name\n from the SRV record. The callback @p aCallback is invoked when responses for all queries are received (i.e., both\n service and host address resolutions are finished).\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aInstanceLabel     The service instance label.\n @param[in]  aServiceName       The service name (together with @p aInstanceLabel form full instance name).\n @param[in]  aCallback          A function pointer that shall be called on response reception or time-out.\n @param[in]  aContext           A pointer to arbitrary context information.\n @param[in]  aConfig            A pointer to the config to use for this query.\n\n @retval OT_ERROR_NONE          Query sent successfully. @p aCallback will be invoked to report the status.\n @retval OT_ERROR_NO_BUFS       Insufficient buffer to prepare and send query.\n @retval OT_ERROR_INVALID_ARGS  @p aInstanceLabel is NULL, or @p aConfig is invalid.\n"]
    pub fn otDnsClientResolveServiceAndHostAddress(
        aInstance: *mut otInstance,
        aInstanceLabel: *const ::std::os::raw::c_char,
        aServiceName: *const ::std::os::raw::c_char,
        aCallback: otDnsServiceCallback,
        aContext: *mut ::std::os::raw::c_void,
        aConfig: *const otDnsQueryConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the service instance name associated with a DNS service instance resolution response.\n\n This function MUST only be used from `otDnsServiceCallback`.\n\n @param[in]  aResponse         A pointer to the response.\n @param[out] aLabelBuffer      A buffer to char array to output the service instance label (MUST NOT be NULL).\n @param[in]  aLabelBufferSize  The size of @p aLabelBuffer.\n @param[out] aNameBuffer       A buffer to char array to output the rest of service name (can be NULL if user is\n                               not interested in getting the name.\n @param[in]  aNameBufferSize   The size of @p aNameBuffer.\n\n @retval OT_ERROR_NONE     The service name was read successfully.\n @retval OT_ERROR_NO_BUFS  Either the label or name does not fit in the given buffers.\n"]
    pub fn otDnsServiceResponseGetServiceName(
        aResponse: *const otDnsServiceResponse,
        aLabelBuffer: *mut ::std::os::raw::c_char,
        aLabelBufferSize: u8,
        aNameBuffer: *mut ::std::os::raw::c_char,
        aNameBufferSize: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets info for a service instance from a DNS service instance resolution response.\n\n This function MUST only be used from a `otDnsServiceCallback` triggered from `otDnsClientResolveService()` or\n `otDnsClientResolveServiceAndHostAddress()`.\n\n When this is is used from a `otDnsClientResolveService()` callback, the DNS response from server/resolver may\n include AAAA records in its Additional Data section for the host name associated with the service instance that is\n resolved. This is a SHOULD and not a MUST requirement so servers/resolvers are not required to provide this. This\n function attempts to parse AAAA record(s) if included in the response. If it is not included `mHostAddress` is set\n to all zeros (unspecified address). To also resolve the host address, user can use the DNS client API function\n `otDnsClientResolveServiceAndHostAddress()` which will perform service resolution followed up by a host name\n address resolution query (when AAAA records are not provided by server/resolver in the SRV query response).\n\n - If a matching SRV record is found in @p aResponse, @p aServiceInfo is updated.\n - If no matching SRV record is found, `OT_ERROR_NOT_FOUND` is returned unless the query config for this query\n   used `OT_DNS_SERVICE_MODE_TXT` for `mServiceMode` (meaning the request was only for TXT record). In this case, we\n   still try to parse the SRV record from Additional Data Section of response (in case server provided the info).\n - If no matching TXT record is found in @p aResponse, `mTxtDataSize` in @p aServiceInfo is set to zero.\n - If TXT data length is greater than `mTxtDataSize`, it is read partially and `mTxtDataTruncated` is set to true.\n - If no matching AAAA record is found in @p aResponse, `mHostAddress is set to all zero or unspecified address.\n - If there are multiple AAAA records for the host name in @p aResponse, `mHostAddress` is set to the first one. The\n   other addresses can be retrieved using `otDnsServiceResponseGetHostAddress()`.\n\n @param[in]  aResponse          A pointer to the response.\n @param[out] aServiceInfo       A `ServiceInfo` to output the service instance information (MUST NOT be NULL).\n\n @retval OT_ERROR_NONE          The service instance info was read. @p aServiceInfo is updated.\n @retval OT_ERROR_NOT_FOUND     Could not find a required record in @p aResponse.\n @retval OT_ERROR_NO_BUFS       The host name and/or TXT data could not fit in the given buffers.\n @retval OT_ERROR_PARSE         Could not parse the records in the @p aResponse.\n"]
    pub fn otDnsServiceResponseGetServiceInfo(
        aResponse: *const otDnsServiceResponse,
        aServiceInfo: *mut otDnsServiceInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the host IPv6 address from a DNS service instance resolution response.\n\n This function MUST only be used from `otDnsServiceCallback`.\n\n The response can include zero or more IPv6 address records. @p aIndex can be used to iterate through the list of\n addresses. Index zero gets the first address and so on. When we reach end of the list, `OT_ERROR_NOT_FOUND` is\n returned.\n\n @param[in]  aResponse     A pointer to the response.\n @param[in]  aHostName     The host name to get the address (MUST NOT be NULL).\n @param[in]  aIndex        The address record index to retrieve.\n @param[out] aAddress      A pointer to a IPv6 address to output the address (MUST NOT be NULL).\n @param[out] aTtl          A pointer to an `uint32_t` to output TTL for the address. It can be NULL if caller does\n                           not want to get the TTL.\n\n @retval OT_ERROR_NONE       The address was read successfully.\n @retval OT_ERROR_NOT_FOUND  No address record for @p aHostname in @p aResponse at @p aIndex.\n @retval OT_ERROR_PARSE      Could not parse the records in the @p aResponse.\n"]
    pub fn otDnsServiceResponseGetHostAddress(
        aResponse: *const otDnsServiceResponse,
        aHostName: *const ::std::os::raw::c_char,
        aIndex: u16,
        aAddress: *mut otIp6Address,
        aTtl: *mut u32,
    ) -> otError;
}
#[doc = " This function is called when a DNS-SD query subscribes one of:\n      1. a service name.\n      2. a service instance name.\n      3. a host name.\n\n The DNS-SD query implementation is responsible for identifying what @p aFullName is.\n If @p aFullName is a service name or service instance name, the DNS-SD query implementation should discover\n corresponding service instance information and notify the DNS-SD server using\n `otDnssdQueryHandleDiscoveredServiceInstance`.\n If @p aFullName is a host name, the DNS-SD query implementation should\n discover the host information and notify the DNS-SD server using `otDnssdQueryHandleDiscoveredHost`.\n\n @note There can be multiple subscription to the same name. DNS-SD query implementation should record the number of\n active subscriptions and stop notifying when there is no active subscription for @p aFullName.\n\n @param[in] aContext      A pointer to the application-specific context.\n @param[in] aFullName     The null-terminated full service name (e.g. \"_ipps._tcp.default.service.arpa.\"),\n                          or full service instance name (e.g. \"OpenThread._ipps._tcp.default.service.arpa.\"),\n                          or full host name (e.g. \"ot-host.default.service.arpa.\").\n\n @sa otDnssdQueryHandleDiscoveredServiceInstance\n @sa otDnssdQueryHandleDiscoveredHost\n"]
pub type otDnssdQuerySubscribeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aFullName: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " This function is called when a DNS-SD query unsubscribes one of:\n      1. a service name.\n      2. a service instance name.\n      3. a host name.\n\n The DNS-SD query implementation is responsible for identifying what @p aFullName is.\n\n @note There can be multiple subscription to the same name. DNS-SD query implementation should record the number of\n active subscriptions and stop notifying when there is no active subscription for @p aFullName.\n\n @param[in] aContext      A pointer to the application-specific context.\n @param[in] aFullName     The null-terminated full service name (e.g. \"_ipps._tcp.default.service.arpa.\"), or\n                          full service instance name (e.g. \"OpenThread._ipps._tcp.default.service.arpa.\").\n"]
pub type otDnssdQueryUnsubscribeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aFullName: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " This opaque type represents a DNS-SD query.\n"]
pub type otDnssdQuery = ::std::os::raw::c_void;
#[doc = " This structure represents information of a discovered service instance for a DNS-SD query.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnssdServiceInstanceInfo {
    #[doc = "< Full instance name (e.g. \"OpenThread._ipps._tcp.default.service.arpa.\")."]
    pub mFullName: *const ::std::os::raw::c_char,
    #[doc = "< Host name (e.g. \"ot-host.default.service.arpa.\")."]
    pub mHostName: *const ::std::os::raw::c_char,
    #[doc = "< Number of host IPv6 addresses."]
    pub mAddressNum: u8,
    #[doc = "< Host IPv6 addresses."]
    pub mAddresses: *const otIp6Address,
    #[doc = "< Service port."]
    pub mPort: u16,
    #[doc = "< Service priority."]
    pub mPriority: u16,
    #[doc = "< Service weight."]
    pub mWeight: u16,
    #[doc = "< Service TXT RDATA length."]
    pub mTxtLength: u16,
    #[doc = "< Service TXT RDATA."]
    pub mTxtData: *const u8,
    #[doc = "< Service TTL (in seconds)."]
    pub mTtl: u32,
}
impl Default for otDnssdServiceInstanceInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents information of a discovered host for a DNS-SD query.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDnssdHostInfo {
    #[doc = "< Number of host IPv6 addresses."]
    pub mAddressNum: u8,
    #[doc = "< Host IPv6 addresses."]
    pub mAddresses: *const otIp6Address,
    #[doc = "< Service TTL (in seconds)."]
    pub mTtl: u32,
}
impl Default for otDnssdHostInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Service type unspecified."]
pub const OT_DNSSD_QUERY_TYPE_NONE: otDnssdQueryType = 0;
#[doc = "< Service type browse service."]
pub const OT_DNSSD_QUERY_TYPE_BROWSE: otDnssdQueryType = 1;
#[doc = "< Service type resolve service instance."]
pub const OT_DNSSD_QUERY_TYPE_RESOLVE: otDnssdQueryType = 2;
#[doc = "< Service type resolve hostname."]
pub const OT_DNSSD_QUERY_TYPE_RESOLVE_HOST: otDnssdQueryType = 3;
#[doc = " This enumeration specifies a DNS-SD query type.\n"]
pub type otDnssdQueryType = ::std::os::raw::c_uint;
#[doc = " This structure contains the counters of DNS-SD server.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otDnssdCounters {
    #[doc = "< The number of successful responses"]
    pub mSuccessResponse: u32,
    #[doc = "< The number of server failure responses"]
    pub mServerFailureResponse: u32,
    #[doc = "< The number of format error responses"]
    pub mFormatErrorResponse: u32,
    #[doc = "< The number of name error responses"]
    pub mNameErrorResponse: u32,
    #[doc = "< The number of 'not implemented' responses"]
    pub mNotImplementedResponse: u32,
    #[doc = "< The number of other responses"]
    pub mOtherResponse: u32,
    #[doc = "< The number of queries completely resolved by the local SRP server"]
    pub mResolvedBySrp: u32,
}
extern "C" {
    #[doc = " This function sets DNS-SD server query callbacks.\n\n The DNS-SD server calls @p aSubscribe to subscribe to a service or service instance to resolve a DNS-SD query and @p\n aUnsubscribe to unsubscribe when the query is resolved or timeout.\n\n @note @p aSubscribe and @p aUnsubscribe must be both set or unset.\n\n @param[in] aInstance     The OpenThread instance structure.\n @param[in] aSubscribe    A pointer to the callback function to subscribe a service or service instance.\n @param[in] aUnsubscribe  A pointer to the callback function to unsubscribe a service or service instance.\n @param[in] aContext      A pointer to the application-specific context.\n"]
    pub fn otDnssdQuerySetCallbacks(
        aInstance: *mut otInstance,
        aSubscribe: otDnssdQuerySubscribeCallback,
        aUnsubscribe: otDnssdQueryUnsubscribeCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function notifies a discovered service instance.\n\n The external query resolver (e.g. Discovery Proxy) should call this function to notify OpenThread core of the\n subscribed services or service instances.\n\n @note @p aInstanceInfo must not contain unspecified or link-local or loop-back or multicast IP addresses.\n\n @param[in] aInstance         The OpenThread instance structure.\n @param[in] aServiceFullName  The null-terminated full service name.\n @param[in] aInstanceInfo     A pointer to the discovered service instance information.\n"]
    pub fn otDnssdQueryHandleDiscoveredServiceInstance(
        aInstance: *mut otInstance,
        aServiceFullName: *const ::std::os::raw::c_char,
        aInstanceInfo: *mut otDnssdServiceInstanceInfo,
    );
}
extern "C" {
    #[doc = " This function notifies a discovered host.\n\n The external query resolver (e.g. Discovery Proxy) should call this function to notify OpenThread core of the\n subscribed hosts.\n\n @note @p aHostInfo must not contain unspecified or link-local or loop-back or multicast IP addresses.\n\n @param[in] aInstance         The OpenThread instance structure.\n @param[in] aHostFullName     The null-terminated full host name.\n @param[in] aHostInfo         A pointer to the discovered service instance information.\n"]
    pub fn otDnssdQueryHandleDiscoveredHost(
        aInstance: *mut otInstance,
        aHostFullName: *const ::std::os::raw::c_char,
        aHostInfo: *mut otDnssdHostInfo,
    );
}
extern "C" {
    #[doc = " This function acquires the next query in the DNS-SD server.\n\n @param[in] aInstance         The OpenThread instance structure.\n @param[in] aQuery            The query pointer. Pass NULL to get the first query.\n\n @returns  A pointer to the query or NULL if no more queries.\n"]
    pub fn otDnssdGetNextQuery(
        aInstance: *mut otInstance,
        aQuery: *const otDnssdQuery,
    ) -> *const otDnssdQuery;
}
extern "C" {
    #[doc = " This function acquires the DNS-SD query type and name for a specific query.\n\n @param[in]   aQuery            The query pointer acquired from `otDnssdGetNextQuery`.\n @param[out]  aNameOutput       The name output buffer, which should be `OT_DNS_MAX_NAME_SIZE` bytes long.\n\n @returns The DNS-SD query type.\n"]
    pub fn otDnssdGetQueryTypeAndName(
        aQuery: *const otDnssdQuery,
        aNameOutput: *mut [::std::os::raw::c_char; 255usize],
    ) -> otDnssdQueryType;
}
extern "C" {
    #[doc = " This function returns the counters of the DNS-SD server.\n\n @param[in]  aInstance  The OpenThread instance structure.\n\n @returns  A pointer to the counters of the DNS-SD server.\n"]
    pub fn otDnssdGetCounters(aInstance: *mut otInstance) -> *const otDnssdCounters;
}
extern "C" {
    #[doc = " Enable or disable forwarding DNS queries to platform DNS upstream API.\n\n Available when `OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE` is enabled.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aEnabled   A boolean to enable/disable forwarding DNS queries to upstream.\n\n @sa otPlatDnsStartUpstreamQuery\n @sa otPlatDnsCancelUpstreamQuery\n @sa otPlatDnsUpstreamQueryDone\n"]
    pub fn otDnssdUpstreamQuerySetEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " Returns whether the DNSSD server will forward DNS queries to the platform DNS upstream API.\n\n Available when `OPENTHREAD_CONFIG_DNS_UPSTREAM_QUERY_ENABLE` is enabled.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @retval     TRUE       If the DNSSD server will forward DNS queries.\n @retval     FALSE      If the DNSSD server will not forward DNS queries.\n\n @sa otDnssdUpstreamQuerySetEnabled\n"]
    pub fn otDnssdUpstreamQueryIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " @note This API is deprecated and use of it is discouraged.\n"]
    pub fn otHeapCAlloc(aCount: usize, aSize: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @note This API is deprecated and use of it is discouraged.\n"]
    pub fn otHeapFree(aPointer: *mut ::std::os::raw::c_void);
}
#[doc = "< Destination Unreachable"]
pub const OT_ICMP6_TYPE_DST_UNREACH: otIcmp6Type = 1;
#[doc = "< Packet To Big"]
pub const OT_ICMP6_TYPE_PACKET_TO_BIG: otIcmp6Type = 2;
#[doc = "< Time Exceeded"]
pub const OT_ICMP6_TYPE_TIME_EXCEEDED: otIcmp6Type = 3;
#[doc = "< Parameter Problem"]
pub const OT_ICMP6_TYPE_PARAMETER_PROBLEM: otIcmp6Type = 4;
#[doc = "< Echo Request"]
pub const OT_ICMP6_TYPE_ECHO_REQUEST: otIcmp6Type = 128;
#[doc = "< Echo Reply"]
pub const OT_ICMP6_TYPE_ECHO_REPLY: otIcmp6Type = 129;
#[doc = "< Router Solicitation"]
pub const OT_ICMP6_TYPE_ROUTER_SOLICIT: otIcmp6Type = 133;
#[doc = "< Router Advertisement"]
pub const OT_ICMP6_TYPE_ROUTER_ADVERT: otIcmp6Type = 134;
#[doc = "< Neighbor Solicitation"]
pub const OT_ICMP6_TYPE_NEIGHBOR_SOLICIT: otIcmp6Type = 135;
#[doc = "< Neighbor Advertisement"]
pub const OT_ICMP6_TYPE_NEIGHBOR_ADVERT: otIcmp6Type = 136;
#[doc = " ICMPv6 Message Types\n"]
pub type otIcmp6Type = ::std::os::raw::c_uint;
#[doc = "< Destination Unreachable No Route"]
pub const OT_ICMP6_CODE_DST_UNREACH_NO_ROUTE: otIcmp6Code = 0;
#[doc = "< Fragment Reassembly Time Exceeded"]
pub const OT_ICMP6_CODE_FRAGM_REAS_TIME_EX: otIcmp6Code = 1;
#[doc = " ICMPv6 Message Codes\n"]
pub type otIcmp6Code = ::std::os::raw::c_uint;
#[doc = " @struct otIcmp6Header\n\n This structure represents an ICMPv6 header.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIcmp6Header {
    #[doc = "< Type"]
    pub mType: u8,
    #[doc = "< Code"]
    pub mCode: u8,
    #[doc = "< Checksum"]
    pub mChecksum: u16,
    #[doc = "< Message-specific data"]
    pub mData: otIcmp6Header__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIcmp6Header__bindgen_ty_1 {
    pub m8: [u8; 4usize],
    pub m16: [u16; 2usize],
    pub m32: [u32; 1usize],
}
impl Default for otIcmp6Header__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otIcmp6Header {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This callback allows OpenThread to inform the application of a received ICMPv6 message.\n\n @param[in]  aContext      A pointer to arbitrary context information.\n @param[in]  aMessage      A pointer to the received message.\n @param[in]  aMessageInfo  A pointer to message information associated with @p aMessage.\n @param[in]  aIcmpHeader   A pointer to the received ICMPv6 header.\n"]
pub type otIcmp6ReceiveCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aIcmpHeader: *const otIcmp6Header,
    ),
>;
#[doc = " This structure implements ICMPv6 message handler.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otIcmp6Handler {
    #[doc = "< The ICMPv6 received callback"]
    pub mReceiveCallback: otIcmp6ReceiveCallback,
    #[doc = "< A pointer to arbitrary context information."]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< A pointer to the next handler in the list."]
    pub mNext: *mut otIcmp6Handler,
}
impl Default for otIcmp6Handler {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< ICMPv6 Echo processing disabled"]
pub const OT_ICMP6_ECHO_HANDLER_DISABLED: otIcmp6EchoMode = 0;
#[doc = "< ICMPv6 Echo processing enabled only for unicast requests only"]
pub const OT_ICMP6_ECHO_HANDLER_UNICAST_ONLY: otIcmp6EchoMode = 1;
#[doc = "< ICMPv6 Echo processing enabled only for multicast requests only"]
pub const OT_ICMP6_ECHO_HANDLER_MULTICAST_ONLY: otIcmp6EchoMode = 2;
#[doc = "< ICMPv6 Echo processing enabled for unicast and multicast requests"]
pub const OT_ICMP6_ECHO_HANDLER_ALL: otIcmp6EchoMode = 3;
#[doc = " ICMPv6 Echo Reply Modes\n"]
pub type otIcmp6EchoMode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function indicates whether or not ICMPv6 Echo processing is enabled.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval OT_ICMP6_ECHO_HANDLER_DISABLED        ICMPv6 Echo processing is disabled.\n @retval OT_ICMP6_ECHO_HANDLER_UNICAST_ONLY    ICMPv6 Echo processing enabled for unicast requests only\n @retval OT_ICMP6_ECHO_HANDLER_MULTICAST_ONLY  ICMPv6 Echo processing enabled for multicast requests only\n @retval OT_ICMP6_ECHO_HANDLER_ALL             ICMPv6 Echo processing enabled for unicast and multicast requests\n"]
    pub fn otIcmp6GetEchoMode(aInstance: *mut otInstance) -> otIcmp6EchoMode;
}
extern "C" {
    #[doc = " This function sets whether or not ICMPv6 Echo processing is enabled.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aMode     The ICMPv6 Echo processing mode.\n"]
    pub fn otIcmp6SetEchoMode(aInstance: *mut otInstance, aMode: otIcmp6EchoMode);
}
extern "C" {
    #[doc = " This function registers a handler to provide received ICMPv6 messages.\n\n @note A handler structure @p aHandler has to be stored in persistent (static) memory.\n       OpenThread does not make a copy of handler structure.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aHandler  A pointer to a handler containing callback that is called when\n                       an ICMPv6 message is received.\n"]
    pub fn otIcmp6RegisterHandler(
        aInstance: *mut otInstance,
        aHandler: *mut otIcmp6Handler,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends an ICMPv6 Echo Request via the Thread interface.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aMessage      A pointer to the message buffer containing the ICMPv6 payload.\n @param[in]  aMessageInfo  A reference to message information associated with @p aMessage.\n @param[in]  aIdentifier   An identifier to aid in matching Echo Replies to this Echo Request.\n                           May be zero.\n"]
    pub fn otIcmp6SendEchoRequest(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aIdentifier: u16,
    ) -> otError;
}
#[doc = " This function pointer is called if signal jam detection is enabled and a jam is detected.\n\n @param[in]  aJamState Current jam state (`true` if jam is detected, `false` otherwise).\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otJamDetectionCallback = ::std::option::Option<
    unsafe extern "C" fn(aJamState: bool, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Set the Jam Detection RSSI Threshold (in dBm).\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n @param[in]  aRssiThreshold  The RSSI threshold.\n\n @retval OT_ERROR_NONE    Successfully set the threshold.\n"]
    pub fn otJamDetectionSetRssiThreshold(
        aInstance: *mut otInstance,
        aRssiThreshold: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Jam Detection RSSI Threshold (in dBm).\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Jam Detection RSSI Threshold."]
    pub fn otJamDetectionGetRssiThreshold(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Set the Jam Detection Detection Window (in seconds).\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  aWindow              The Jam Detection window (valid range is 1 to 63)\n\n @retval OT_ERROR_NONE          Successfully set the window.\n @retval OT_ERROR_INVALID_ARGS  The given input parameter not within valid range (1-63)\n"]
    pub fn otJamDetectionSetWindow(aInstance: *mut otInstance, aWindow: u8) -> otError;
}
extern "C" {
    #[doc = " Get the Jam Detection Detection Window (in seconds).\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n\n @returns The Jam Detection Window.\n"]
    pub fn otJamDetectionGetWindow(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the Jam Detection Busy Period (in seconds).\n\n The number of aggregate seconds within the detection window where the RSSI must be above\n threshold to trigger detection.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  aBusyPeriod          The Jam Detection busy period (should be non-zero and\nless than or equal to Jam Detection Window)\n\n @retval OT_ERROR_NONE          Successfully set the window.\n @retval OT_ERROR_INVALID_ARGS  The given input is not within the valid range.\n"]
    pub fn otJamDetectionSetBusyPeriod(aInstance: *mut otInstance, aBusyPeriod: u8) -> otError;
}
extern "C" {
    #[doc = " Get the Jam Detection Busy Period (in seconds)\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n\n @returns The Jam Detection Busy Period.\n"]
    pub fn otJamDetectionGetBusyPeriod(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Start the jamming detection.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  aCallback            A pointer to a function called to notify of jamming state change.\n @param[in]  aContext             A pointer to application-specific context.\n\n @retval OT_ERROR_NONE         Successfully started the jamming detection.\n @retval OT_ERROR_ALREADY      Jam detection has been started before.\n"]
    pub fn otJamDetectionStart(
        aInstance: *mut otInstance,
        aCallback: otJamDetectionCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Stop the jamming detection.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE         Successfully stopped the jamming detection.\n @retval OT_ERROR_ALREADY      Jam detection is already stopped.\n"]
    pub fn otJamDetectionStop(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Get the Jam Detection Status (enabled/disabled)\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n\n @returns The Jam Detection status (true if enabled, false otherwise).\n"]
    pub fn otJamDetectionIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get the Jam Detection State\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n\n @returns The Jam Detection state (`true` jam is detected, `false' otherwise).\n"]
    pub fn otJamDetectionGetState(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get the current history bitmap.\n\n This value provides information about current state of jamming detection\n module for monitoring/debugging purpose. It returns a 64-bit value where\n each bit corresponds to one second interval starting with bit 0 for the\n most recent interval and bit 63 for the oldest intervals (63 sec earlier).\n The bit is set to 1 if the jamming detection module observed/detected\n high signal level during the corresponding one second interval.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n\n @returns The current history bitmap.\n"]
    pub fn otJamDetectionGetHistoryBitmap(aInstance: *mut otInstance) -> u64;
}
#[doc = " This structure represents link-specific information for messages received from the Thread radio.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otThreadLinkInfo {
    #[doc = "< Source PAN ID"]
    pub mPanId: u16,
    #[doc = "< 802.15.4 Channel"]
    pub mChannel: u8,
    #[doc = "< Received Signal Strength in dBm."]
    pub mRss: i8,
    #[doc = "< Link Quality Indicator for a received message."]
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< The time sync sequence."]
    pub mTimeSyncSeq: u8,
    #[doc = "< The time offset to the Thread network time, in microseconds."]
    pub mNetworkTimeOffset: i64,
    #[doc = "< Radio link type."]
    pub mRadioType: u8,
}
impl otThreadLinkInfo {
    #[inline]
    pub fn mLinkSecurity(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkSecurity(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsDstPanIdBroadcast(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsDstPanIdBroadcast(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mLinkSecurity: bool,
        mIsDstPanIdBroadcast: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mLinkSecurity: u8 = unsafe { ::std::mem::transmute(mLinkSecurity) };
            mLinkSecurity as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mIsDstPanIdBroadcast: u8 = unsafe { ::std::mem::transmute(mIsDstPanIdBroadcast) };
            mIsDstPanIdBroadcast as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type otMacFilterIterator = u8;
#[doc = "< Address filter is disabled."]
pub const OT_MAC_FILTER_ADDRESS_MODE_DISABLED: otMacFilterAddressMode = 0;
#[doc = "< Allowlist address filter mode is enabled."]
pub const OT_MAC_FILTER_ADDRESS_MODE_ALLOWLIST: otMacFilterAddressMode = 1;
#[doc = "< Denylist address filter mode is enabled."]
pub const OT_MAC_FILTER_ADDRESS_MODE_DENYLIST: otMacFilterAddressMode = 2;
#[doc = " Defines address mode of the mac filter.\n"]
pub type otMacFilterAddressMode = ::std::os::raw::c_uint;
#[doc = " This structure represents a Mac Filter entry.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMacFilterEntry {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Received signal strength"]
    pub mRssIn: i8,
}
#[doc = " This structure represents the MAC layer counters.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMacCounters {
    #[doc = " The total number of unique MAC frame transmission requests.\n\n Note that this counter is incremented for each MAC transmission request only by one,\n regardless of the amount of CCA failures, CSMA-CA attempts, or retransmissions.\n\n This increment rule applies to the following counters:\n   - @p mTxUnicast\n   - @p mTxBroadcast\n   - @p mTxAckRequested\n   - @p mTxNoAckRequested\n   - @p mTxData\n   - @p mTxDataPoll\n   - @p mTxBeacon\n   - @p mTxBeaconRequest\n   - @p mTxOther\n   - @p mTxErrAbort\n   - @p mTxErrBusyChannel\n\n The following equations are valid:\n   - @p mTxTotal = @p mTxUnicast + @p mTxBroadcast\n   - @p mTxTotal = @p mTxAckRequested + @p mTxNoAckRequested\n   - @p mTxTotal = @p mTxData + @p mTxDataPoll + @p mTxBeacon + @p mTxBeaconRequest + @p mTxOther\n"]
    pub mTxTotal: u32,
    #[doc = " The total number of unique unicast MAC frame transmission requests.\n"]
    pub mTxUnicast: u32,
    #[doc = " The total number of unique broadcast MAC frame transmission requests.\n"]
    pub mTxBroadcast: u32,
    #[doc = " The total number of unique MAC frame transmission requests with requested acknowledgment.\n"]
    pub mTxAckRequested: u32,
    #[doc = " The total number of unique MAC frame transmission requests that were acked.\n"]
    pub mTxAcked: u32,
    #[doc = " The total number of unique MAC frame transmission requests without requested acknowledgment.\n"]
    pub mTxNoAckRequested: u32,
    #[doc = " The total number of unique MAC Data frame transmission requests.\n"]
    pub mTxData: u32,
    #[doc = " The total number of unique MAC Data Poll frame transmission requests.\n"]
    pub mTxDataPoll: u32,
    #[doc = " The total number of unique MAC Beacon frame transmission requests.\n"]
    pub mTxBeacon: u32,
    #[doc = " The total number of unique MAC Beacon Request frame transmission requests.\n"]
    pub mTxBeaconRequest: u32,
    #[doc = " The total number of unique other MAC frame transmission requests.\n\n This counter is currently used for counting out-of-band frames.\n"]
    pub mTxOther: u32,
    #[doc = " The total number of MAC retransmission attempts.\n\n Note that this counter is incremented by one for each retransmission attempt that may be\n triggered by lack of acknowledgement, CSMA/CA failure, or other type of transmission error.\n The @p mTxRetry counter is incremented both for unicast and broadcast MAC frames.\n\n Modify the following configuration parameters to control the amount of retransmissions in the system:\n\n - OPENTHREAD_CONFIG_MAC_DEFAULT_MAX_FRAME_RETRIES_DIRECT\n - OPENTHREAD_CONFIG_MAC_DEFAULT_MAX_FRAME_RETRIES_INDIRECT\n - OPENTHREAD_CONFIG_MAC_TX_NUM_BCAST\n - OPENTHREAD_CONFIG_MAC_MAX_CSMA_BACKOFFS_DIRECT\n - OPENTHREAD_CONFIG_MAC_MAX_CSMA_BACKOFFS_INDIRECT\n\n Currently, this counter is invalid if the platform's radio driver capability includes\n @ref OT_RADIO_CAPS_TRANSMIT_RETRIES.\n"]
    pub mTxRetry: u32,
    #[doc = " The total number of unique MAC transmission packets that meet maximal retry limit for direct packets.\n"]
    pub mTxDirectMaxRetryExpiry: u32,
    #[doc = " The total number of unique MAC transmission packets that meet maximal retry limit for indirect packets.\n"]
    pub mTxIndirectMaxRetryExpiry: u32,
    #[doc = " The total number of CCA failures.\n\n The meaning of this counter can be different and it depends on the platform's radio driver capabilities.\n\n If @ref OT_RADIO_CAPS_CSMA_BACKOFF is enabled, this counter represents the total number of full CSMA/CA\n failed attempts and it is incremented by one also for each retransmission (in case of a CSMA/CA fail).\n\n If @ref OT_RADIO_CAPS_TRANSMIT_RETRIES is enabled, this counter represents the total number of full CSMA/CA\n failed attempts and it is incremented by one for each individual data frame request (regardless of the\n amount of retransmissions).\n"]
    pub mTxErrCca: u32,
    #[doc = " The total number of unique MAC transmission request failures cause by an abort error.\n"]
    pub mTxErrAbort: u32,
    #[doc = " The total number of unique MAC transmission requests failures caused by a busy channel (a CSMA/CA fail).\n"]
    pub mTxErrBusyChannel: u32,
    #[doc = " The total number of received frames.\n\n This counter counts all frames reported by the platform's radio driver, including frames\n that were dropped, for example because of an FCS error.\n"]
    pub mRxTotal: u32,
    #[doc = " The total number of unicast frames received.\n"]
    pub mRxUnicast: u32,
    #[doc = " The total number of broadcast frames received.\n"]
    pub mRxBroadcast: u32,
    #[doc = " The total number of MAC Data frames received.\n"]
    pub mRxData: u32,
    #[doc = " The total number of MAC Data Poll frames received.\n"]
    pub mRxDataPoll: u32,
    #[doc = " The total number of MAC Beacon frames received.\n"]
    pub mRxBeacon: u32,
    #[doc = " The total number of MAC Beacon Request frames received.\n"]
    pub mRxBeaconRequest: u32,
    #[doc = " The total number of other types of frames received.\n"]
    pub mRxOther: u32,
    #[doc = " The total number of frames dropped by MAC Filter module, for example received from denylisted node.\n"]
    pub mRxAddressFiltered: u32,
    #[doc = " The total number of frames dropped by destination address check, for example received frame for other node.\n"]
    pub mRxDestAddrFiltered: u32,
    #[doc = " The total number of frames dropped due to duplication, that is when the frame has been already received.\n\n This counter may be incremented, for example when ACK frame generated by the receiver hasn't reached\n transmitter node which performed retransmission.\n"]
    pub mRxDuplicated: u32,
    #[doc = " The total number of frames dropped because of missing or malformed content.\n"]
    pub mRxErrNoFrame: u32,
    #[doc = " The total number of frames dropped due to unknown neighbor.\n"]
    pub mRxErrUnknownNeighbor: u32,
    #[doc = " The total number of frames dropped due to invalid source address.\n"]
    pub mRxErrInvalidSrcAddr: u32,
    #[doc = " The total number of frames dropped due to security error.\n\n This counter may be incremented, for example when lower than expected Frame Counter is used\n to encrypt the frame.\n"]
    pub mRxErrSec: u32,
    #[doc = " The total number of frames dropped due to invalid FCS.\n"]
    pub mRxErrFcs: u32,
    #[doc = " The total number of frames dropped due to other error.\n"]
    pub mRxErrOther: u32,
}
#[doc = " This structure represents a received IEEE 802.15.4 Beacon.\n"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct otActiveScanResult {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Thread Network Name"]
    pub mNetworkName: otNetworkName,
    #[doc = "< Thread Extended PAN ID"]
    pub mExtendedPanId: otExtendedPanId,
    #[doc = "< Steering Data"]
    pub mSteeringData: otSteeringData,
    #[doc = "< IEEE 802.15.4 PAN ID"]
    pub mPanId: u16,
    #[doc = "< Joiner UDP Port"]
    pub mJoinerUdpPort: u16,
    #[doc = "< IEEE 802.15.4 Channel"]
    pub mChannel: u8,
    #[doc = "< RSSI (dBm)"]
    pub mRssi: i8,
    #[doc = "< LQI"]
    pub mLqi: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl otActiveScanResult {
    #[inline]
    pub fn mVersion(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mVersion(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsNative(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsNative(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDiscover(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDiscover(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsJoinable(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoinable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mVersion: ::std::os::raw::c_uint,
        mIsNative: bool,
        mDiscover: bool,
        mIsJoinable: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mVersion: u32 = unsafe { ::std::mem::transmute(mVersion) };
            mVersion as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsNative: u8 = unsafe { ::std::mem::transmute(mIsNative) };
            mIsNative as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mDiscover: u8 = unsafe { ::std::mem::transmute(mDiscover) };
            mDiscover as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mIsJoinable: u8 = unsafe { ::std::mem::transmute(mIsJoinable) };
            mIsJoinable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents an energy scan result.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otEnergyScanResult {
    #[doc = "< IEEE 802.15.4 Channel"]
    pub mChannel: u8,
    #[doc = "< The max RSSI (dBm)"]
    pub mMaxRssi: i8,
}
#[doc = " This function pointer is called during an IEEE 802.15.4 Active Scan when an IEEE 802.15.4 Beacon is received or\n the scan completes.\n\n @param[in]  aResult   A valid pointer to the beacon information or NULL when the active scan completes.\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otHandleActiveScanResult = ::std::option::Option<
    unsafe extern "C" fn(aResult: *mut otActiveScanResult, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function starts an IEEE 802.15.4 Active Scan\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aScanChannels     A bit vector indicating which channels to scan (e.g. OT_CHANNEL_11_MASK).\n @param[in]  aScanDuration     The time in milliseconds to spend scanning each channel.\n @param[in]  aCallback         A pointer to a function called on receiving a beacon or scan completes.\n @param[in]  aCallbackContext  A pointer to application-specific context.\n\n @retval OT_ERROR_NONE  Accepted the Active Scan request.\n @retval OT_ERROR_BUSY  Already performing an Active Scan.\n"]
    pub fn otLinkActiveScan(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aScanDuration: u16,
        aCallback: otHandleActiveScanResult,
        aCallbackContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not an IEEE 802.15.4 Active Scan is currently in progress.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns true if an IEEE 802.15.4 Active Scan is in progress, false otherwise."]
    pub fn otLinkIsActiveScanInProgress(aInstance: *mut otInstance) -> bool;
}
#[doc = " This function pointer is called during an IEEE 802.15.4 Energy Scan when the result for a channel is ready or the\n scan completes.\n\n @param[in]  aResult   A valid pointer to the energy scan result information or NULL when the energy scan completes.\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otHandleEnergyScanResult = ::std::option::Option<
    unsafe extern "C" fn(aResult: *mut otEnergyScanResult, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function starts an IEEE 802.15.4 Energy Scan\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aScanChannels     A bit vector indicating on which channels to perform energy scan.\n @param[in]  aScanDuration     The time in milliseconds to spend scanning each channel.\n @param[in]  aCallback         A pointer to a function called to pass on scan result on indicate scan completion.\n @param[in]  aCallbackContext  A pointer to application-specific context.\n\n @retval OT_ERROR_NONE  Accepted the Energy Scan request.\n @retval OT_ERROR_BUSY  Could not start the energy scan.\n"]
    pub fn otLinkEnergyScan(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aScanDuration: u16,
        aCallback: otHandleEnergyScanResult,
        aCallbackContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not an IEEE 802.15.4 Energy Scan is currently in progress.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns true if an IEEE 802.15.4 Energy Scan is in progress, false otherwise.\n"]
    pub fn otLinkIsEnergyScanInProgress(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function enqueues an IEEE 802.15.4 Data Request message for transmission.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE           Successfully enqueued an IEEE 802.15.4 Data Request message.\n @retval OT_ERROR_INVALID_STATE  Device is not in rx-off-when-idle mode.\n @retval OT_ERROR_NO_BUFS        Insufficient message buffers available.\n"]
    pub fn otLinkSendDataRequest(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not an IEEE 802.15.4 MAC is in the transmit state.\n\n MAC module is in the transmit state during CSMA/CA procedure, CCA, Data, Beacon or Data Request frame transmission\n and receiving an ACK of a transmitted frame. MAC module is not in the transmit state during transmission of an ACK\n frame or a Beacon Request frame.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns true if an IEEE 802.15.4 MAC is in the transmit state, false otherwise.\n"]
    pub fn otLinkIsInTransmitState(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " Get the IEEE 802.15.4 channel.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns The IEEE 802.15.4 channel.\n\n @sa otLinkSetChannel\n"]
    pub fn otLinkGetChannel(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the IEEE 802.15.4 channel\n\n This function succeeds only when Thread protocols are disabled.  A successful call to this function invalidates the\n Active and Pending Operational Datasets in non-volatile memory.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aChannel    The IEEE 802.15.4 channel.\n\n @retval  OT_ERROR_NONE           Successfully set the channel.\n @retval  OT_ERROR_INVALID_ARGS   If @p aChannel is not in the range [11, 26] or is not in the supported channel mask.\n @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n\n @sa otLinkGetChannel\n"]
    pub fn otLinkSetChannel(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
extern "C" {
    #[doc = " Get the supported channel mask of MAC layer.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns The supported channel mask as `uint32_t` with bit 0 (lsb) mapping to channel 0, bit 1 to channel 1, so on.\n"]
    pub fn otLinkGetSupportedChannelMask(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Set the supported channel mask of MAC layer.\n\n This function succeeds only when Thread protocols are disabled.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aChannelMask  The supported channel mask (bit 0 or lsb mapping to channel 0, and so on).\n\n @retval  OT_ERROR_NONE           Successfully set the supported channel mask.\n @retval  OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n"]
    pub fn otLinkSetSupportedChannelMask(aInstance: *mut otInstance, aChannelMask: u32) -> otError;
}
extern "C" {
    #[doc = " Gets the IEEE 802.15.4 Extended Address.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the IEEE 802.15.4 Extended Address.\n"]
    pub fn otLinkGetExtendedAddress(aInstance: *mut otInstance) -> *const otExtAddress;
}
extern "C" {
    #[doc = " Sets the IEEE 802.15.4 Extended Address.\n\n @note Only succeeds when Thread protocols are disabled.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address.\n\n @retval OT_ERROR_NONE           Successfully set the IEEE 802.15.4 Extended Address.\n @retval OT_ERROR_INVALID_ARGS   @p aExtAddress was NULL.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n"]
    pub fn otLinkSetExtendedAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the factory-assigned IEEE EUI-64.\n\n @param[in]   aInstance  A pointer to the OpenThread instance.\n @param[out]  aEui64     A pointer to where the factory-assigned IEEE EUI-64 is placed.\n"]
    pub fn otLinkGetFactoryAssignedIeeeEui64(aInstance: *mut otInstance, aEui64: *mut otExtAddress);
}
extern "C" {
    #[doc = " Get the IEEE 802.15.4 PAN ID.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The IEEE 802.15.4 PAN ID.\n\n @sa otLinkSetPanId\n"]
    pub fn otLinkGetPanId(aInstance: *mut otInstance) -> otPanId;
}
extern "C" {
    #[doc = " Set the IEEE 802.15.4 PAN ID.\n\n This function succeeds only when Thread protocols are disabled.  A successful call to this function also invalidates\n the Active and Pending Operational Datasets in non-volatile memory.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aPanId       The IEEE 802.15.4 PAN ID.\n\n @retval OT_ERROR_NONE           Successfully set the PAN ID.\n @retval OT_ERROR_INVALID_ARGS   If aPanId is not in the range [0, 65534].\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n\n @sa otLinkGetPanId\n"]
    pub fn otLinkSetPanId(aInstance: *mut otInstance, aPanId: otPanId) -> otError;
}
extern "C" {
    #[doc = " Get the data poll period of sleepy end device.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns  The data poll period of sleepy end device in milliseconds.\n\n @sa otLinkSetPollPeriod\n"]
    pub fn otLinkGetPollPeriod(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Set/clear user-specified/external data poll period for sleepy end device.\n\n @note This function updates only poll period of sleepy end device. To update child timeout the function\n       `otThreadSetChildTimeout()` shall be called.\n\n @note Minimal non-zero value should be `OPENTHREAD_CONFIG_MAC_MINIMUM_POLL_PERIOD` (10ms).\n       Or zero to clear user-specified poll period.\n\n @note User-specified value should be no more than the maximal value 0x3FFFFFF ((1 << 26) - 1) allowed,\n otherwise it would be clipped by the maximal value.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aPollPeriod  data poll period in milliseconds.\n\n @retval OT_ERROR_NONE           Successfully set/cleared user-specified poll period.\n @retval OT_ERROR_INVALID_ARGS   If aPollPeriod is invalid.\n\n @sa otLinkGetPollPeriod\n"]
    pub fn otLinkSetPollPeriod(aInstance: *mut otInstance, aPollPeriod: u32) -> otError;
}
extern "C" {
    #[doc = " Get the IEEE 802.15.4 Short Address.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the IEEE 802.15.4 Short Address.\n"]
    pub fn otLinkGetShortAddress(aInstance: *mut otInstance) -> otShortAddress;
}
extern "C" {
    #[doc = " This method returns the maximum number of frame retries during direct transmission.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The maximum number of retries during direct transmission.\n"]
    pub fn otLinkGetMaxFrameRetriesDirect(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " This method sets the maximum number of frame retries during direct transmission.\n\n @param[in]  aInstance               A pointer to an OpenThread instance.\n @param[in]  aMaxFrameRetriesDirect  The maximum number of retries during direct transmission.\n"]
    pub fn otLinkSetMaxFrameRetriesDirect(aInstance: *mut otInstance, aMaxFrameRetriesDirect: u8);
}
extern "C" {
    #[doc = " This method returns the maximum number of frame retries during indirect transmission.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The maximum number of retries during indirect transmission.\n"]
    pub fn otLinkGetMaxFrameRetriesIndirect(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " This method sets the maximum number of frame retries during indirect transmission.\n\n @param[in]  aInstance                 A pointer to an OpenThread instance.\n @param[in]  aMaxFrameRetriesIndirect  The maximum number of retries during indirect transmission.\n"]
    pub fn otLinkSetMaxFrameRetriesIndirect(
        aInstance: *mut otInstance,
        aMaxFrameRetriesIndirect: u8,
    );
}
extern "C" {
    #[doc = " This function gets the address mode of MAC filter.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns  the address mode.\n"]
    pub fn otLinkFilterGetAddressMode(aInstance: *mut otInstance) -> otMacFilterAddressMode;
}
extern "C" {
    #[doc = " This function sets the address mode of MAC filter.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aMode      The address mode to set.\n"]
    pub fn otLinkFilterSetAddressMode(aInstance: *mut otInstance, aMode: otMacFilterAddressMode);
}
extern "C" {
    #[doc = " This method adds an Extended Address to MAC filter.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aExtAddress  A pointer to the Extended Address (MUST NOT be NULL).\n\n @retval OT_ERROR_NONE           Successfully added @p aExtAddress to MAC filter.\n @retval OT_ERROR_NO_BUFS        No available entry exists.\n"]
    pub fn otLinkFilterAddAddress(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " This method removes an Extended Address from MAC filter.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n No action is performed if there is no existing entry in Filter matching the given Extended Address.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aExtAddress  A pointer to the Extended Address (MUST NOT be NULL).\n"]
    pub fn otLinkFilterRemoveAddress(aInstance: *mut otInstance, aExtAddress: *const otExtAddress);
}
extern "C" {
    #[doc = " This method clears all the Extended Addresses from MAC filter.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otLinkFilterClearAddresses(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method gets an in-use address filter entry.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n @param[in]      aInstance  A pointer to an OpenThread instance.\n @param[in,out]  aIterator  A pointer to the MAC filter iterator context. To get the first in-use address filter\n                            entry, it should be set to OT_MAC_FILTER_ITERATOR_INIT. MUST NOT be NULL.\n @param[out]     aEntry     A pointer to where the information is placed. MUST NOT be NULL.\n\n @retval OT_ERROR_NONE          Successfully retrieved an in-use address filter entry.\n @retval OT_ERROR_NOT_FOUND     No subsequent entry exists.\n"]
    pub fn otLinkFilterGetNextAddress(
        aInstance: *mut otInstance,
        aIterator: *mut otMacFilterIterator,
        aEntry: *mut otMacFilterEntry,
    ) -> otError;
}
extern "C" {
    #[doc = " This method adds a fixed received signal strength (in dBm) entry for the messages from a given Extended Address in\n MAC Filter.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address. MUST NOT be NULL.\n @param[in]  aRss         A received signal strength (in dBm).\n\n @retval OT_ERROR_NONE           Successfully added an entry for @p aExtAddress and @p aRss.\n @retval OT_ERROR_NO_BUFS        No available entry exists.\n"]
    pub fn otLinkFilterAddRssIn(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
        aRss: i8,
    ) -> otError;
}
extern "C" {
    #[doc = " This method removes a MAC Filter entry for fixed received signal strength setting for a given Extended Address.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n No action is performed if there is no existing entry in Filter matching the given Extended Address.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aExtAddress  A pointer to the IEEE 802.15.4 Extended Address. MUST NOT be NULL.\n"]
    pub fn otLinkFilterRemoveRssIn(aInstance: *mut otInstance, aExtAddress: *const otExtAddress);
}
extern "C" {
    #[doc = " This method sets the default received signal strength (in dBm) on MAC Filter.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n The default RSS value is used for all received frames from addresses for which there is no explicit RSS-IN entry\n in the Filter list (added using `otLinkFilterAddRssIn()`).\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aRss         The default received signal strength (in dBm) to set.\n"]
    pub fn otLinkFilterSetDefaultRssIn(aInstance: *mut otInstance, aRss: i8);
}
extern "C" {
    #[doc = " This method clears any previously set default received signal strength (in dBm) on MAC Filter.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n"]
    pub fn otLinkFilterClearDefaultRssIn(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method clears all the received signal strength entries (including default RSS-in) on MAC Filter.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n"]
    pub fn otLinkFilterClearAllRssIn(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This method gets an in-use RssIn filter entry.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n @param[in]      aInstance  A pointer to an OpenThread instance.\n @param[in,out]  aIterator  A pointer to the MAC filter iterator context. MUST NOT be NULL.\n                            To get the first entry, it should be set to OT_MAC_FILTER_ITERATOR_INIT.\n @param[out]     aEntry     A pointer to where the information is placed. The last entry would have the extended\n                            address as all 0xff to indicate the default received signal strength if it was set.\n@p aEntry MUST NOT be NULL.\n\n @retval OT_ERROR_NONE          Successfully retrieved the next entry.\n @retval OT_ERROR_NOT_FOUND     No subsequent entry exists.\n"]
    pub fn otLinkFilterGetNextRssIn(
        aInstance: *mut otInstance,
        aIterator: *mut otMacFilterIterator,
        aEntry: *mut otMacFilterEntry,
    ) -> otError;
}
extern "C" {
    #[doc = " This function enables/disables IEEE 802.15.4 radio filter mode.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n The radio filter is mainly intended for testing. It can be used to temporarily block all tx/rx on the 802.15.4 radio.\n When radio filter is enabled, radio is put to sleep instead of receive (to ensure device does not receive any frame\n and/or potentially send ack). Also the frame transmission requests return immediately without sending the frame over\n the air (return \"no ack\" error if ack is requested, otherwise return success).\n\n @param[in] aInstance         A pointer to an OpenThread instance.\n @param[in] aFilterEnabled    TRUE to enable radio filter, FALSE to disable\n"]
    pub fn otLinkSetRadioFilterEnabled(aInstance: *mut otInstance, aFilterEnabled: bool);
}
extern "C" {
    #[doc = " This function indicates whether the IEEE 802.15.4 radio filter is enabled or not.\n\n This function is available when OPENTHREAD_CONFIG_MAC_FILTER_ENABLE configuration is enabled.\n\n @retval TRUE   If the radio filter is enabled.\n @retval FALSE  If the radio filter is disabled.\n"]
    pub fn otLinkIsRadioFilterEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This method converts received signal strength to link quality.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aRss       The received signal strength value to be converted.\n\n @return Link quality value mapping to @p aRss.\n"]
    pub fn otLinkConvertRssToLinkQuality(aInstance: *mut otInstance, aRss: i8) -> u8;
}
extern "C" {
    #[doc = " This method converts link quality to typical received signal strength.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aLinkQuality  LinkQuality value, should be in range [0,3].\n\n @return Typical platform received signal strength mapping to @p aLinkQuality.\n"]
    pub fn otLinkConvertLinkQualityToRss(aInstance: *mut otInstance, aLinkQuality: u8) -> i8;
}
extern "C" {
    #[doc = " This method gets histogram of retries for a single direct packet until success.\n\n This function is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled.\n\n @param[in]   aInstance          A pointer to an OpenThread instance.\n @param[out]  aNumberOfEntries   A pointer to where the size of returned histogram array is placed.\n\n @returns     A pointer to the histogram of retries (in a form of an array).\n              The n-th element indicates that the packet has been sent with n-th retry."]
    pub fn otLinkGetTxDirectRetrySuccessHistogram(
        aInstance: *mut otInstance,
        aNumberOfEntries: *mut u8,
    ) -> *const u32;
}
extern "C" {
    #[doc = " This method gets histogram of retries for a single indirect packet until success.\n\n This function is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled.\n\n @param[in]   aInstance          A pointer to an OpenThread instance.\n @param[out]  aNumberOfEntries   A pointer to where the size of returned histogram array is placed.\n\n @returns     A pointer to the histogram of retries (in a form of an array).\n              The n-th element indicates that the packet has been sent with n-th retry.\n"]
    pub fn otLinkGetTxIndirectRetrySuccessHistogram(
        aInstance: *mut otInstance,
        aNumberOfEntries: *mut u8,
    ) -> *const u32;
}
extern "C" {
    #[doc = " This method clears histogram statistics for direct and indirect transmissions.\n\n This function is valid when OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_ENABLE configuration is enabled.\n\n @param[in]   aInstance          A pointer to an OpenThread instance.\n"]
    pub fn otLinkResetTxRetrySuccessHistogram(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the MAC layer counters.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the MAC layer counters.\n"]
    pub fn otLinkGetCounters(aInstance: *mut otInstance) -> *const otMacCounters;
}
extern "C" {
    #[doc = " Resets the MAC layer counters.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n"]
    pub fn otLinkResetCounters(aInstance: *mut otInstance);
}
#[doc = " This function pointer is called when an IEEE 802.15.4 frame is received.\n\n @note This callback is called after FCS processing and @p aFrame may not contain the actual FCS that was received.\n\n @note This callback is called before IEEE 802.15.4 security processing.\n\n @param[in]  aFrame    A pointer to the received IEEE 802.15.4 frame.\n @param[in]  aIsTx     Whether this frame is transmitted, not received.\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otLinkPcapCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aFrame: *const otRadioFrame,
        aIsTx: bool,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function registers a callback to provide received raw IEEE 802.15.4 frames.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aPcapCallback     A pointer to a function that is called when receiving an IEEE 802.15.4 link frame or\n                               NULL to disable the callback.\n @param[in]  aCallbackContext  A pointer to application-specific context.\n"]
    pub fn otLinkSetPcapCallback(
        aInstance: *mut otInstance,
        aPcapCallback: otLinkPcapCallback,
        aCallbackContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function indicates whether or not promiscuous mode is enabled at the link layer.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval true   Promiscuous mode is enabled.\n @retval false  Promiscuous mode is not enabled.\n"]
    pub fn otLinkIsPromiscuous(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function enables or disables the link layer promiscuous mode.\n\n @note Promiscuous mode may only be enabled when the Thread interface is disabled.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aPromiscuous  true to enable promiscuous mode, or false otherwise.\n\n @retval OT_ERROR_NONE           Successfully enabled promiscuous mode.\n @retval OT_ERROR_INVALID_STATE  Could not enable promiscuous mode because\n                                 the Thread interface is enabled.\n"]
    pub fn otLinkSetPromiscuous(aInstance: *mut otInstance, aPromiscuous: bool) -> otError;
}
extern "C" {
    #[doc = " This function gets the CSL channel.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n\n @returns The CSL channel.\n"]
    pub fn otLinkCslGetChannel(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Sets the CSL channel.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n @param[in]  aChannel       The CSL sample channel. Channel value should be `0` (Set CSL Channel unspecified) or\n                            within the range [1, 10] (if 915-MHz supported) and [11, 26] (if 2.4 GHz supported).\n\n @retval OT_ERROR_NONE           Successfully set the CSL parameters.\n @retval OT_ERROR_INVALID_ARGS   Invalid @p aChannel.\n"]
    pub fn otLinkCslSetChannel(aInstance: *mut otInstance, aChannel: u8) -> otError;
}
extern "C" {
    #[doc = " This function gets the CSL period.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n\n @returns The CSL period in units of 10 symbols.\n"]
    pub fn otLinkCslGetPeriod(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the CSL period in units of 10 symbols. Disable CSL by setting this parameter to `0`.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n @param[in]  aPeriod        The CSL period in units of 10 symbols.\n\n @retval OT_ERROR_NONE           Successfully set the CSL period.\n @retval OT_ERROR_INVALID_ARGS   Invalid CSL period.\n"]
    pub fn otLinkCslSetPeriod(aInstance: *mut otInstance, aPeriod: u16) -> otError;
}
extern "C" {
    #[doc = " This function gets the CSL timeout.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n\n @returns The CSL timeout in seconds.\n"]
    pub fn otLinkCslGetTimeout(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the CSL timeout in seconds.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n @param[in]  aTimeout       The CSL timeout in seconds.\n\n @retval OT_ERROR_NONE           Successfully set the CSL timeout.\n @retval OT_ERROR_INVALID_ARGS   Invalid CSL timeout.\n"]
    pub fn otLinkCslSetTimeout(aInstance: *mut otInstance, aTimeout: u32) -> otError;
}
extern "C" {
    #[doc = " This function returns the current CCA (Clear Channel Assessment) failure rate.\n\n The rate is maintained over a window of (roughly) last `OPENTHREAD_CONFIG_CCA_FAILURE_RATE_AVERAGING_WINDOW`\n frame transmissions.\n\n @returns The CCA failure rate with maximum value `0xffff` corresponding to 100% failure rate.\n"]
    pub fn otLinkGetCcaFailureRate(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " This function enables or disables the link layer.\n\n @note The link layer may only be enabled / disabled when the Thread Interface is disabled.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aEnable       true to enable the link layer, or false otherwise.\n\n @retval OT_ERROR_NONE          Successfully enabled / disabled the link layer.\n @retval OT_ERROR_INVALID_STATE Could not disable the link layer because\n                                the Thread interface is enabled.\n"]
    pub fn otLinkSetEnabled(aInstance: *mut otInstance, aEnable: bool) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not the link layer is enabled.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval true   Link layer is enabled.\n @retval false  Link layer is not enabled.\n"]
    pub fn otLinkIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function instructs the device to send an empty IEEE 802.15.4 data frame.\n\n This function is only supported on an Rx-Off-When-Idle device to send an empty data frame to its parent.\n Note: available only when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE           Successfully enqueued an empty message.\n @retval OT_ERROR_INVALID_STATE  Device is not in Rx-Off-When-Idle mode.\n @retval OT_ERROR_NO_BUFS        Insufficient message buffers available.\n"]
    pub fn otLinkSendEmptyData(aInstance: *mut otInstance) -> otError;
}
#[doc = " This function pointer on receipt of a IEEE 802.15.4 frame.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aFrame       A pointer to the received frame or NULL if the receive operation was aborted.\n @param[in]  aError       OT_ERROR_NONE when successfully received a frame.\n                          OT_ERROR_ABORT when reception was aborted and a frame was not received.\n"]
pub type otLinkRawReceiveDone = ::std::option::Option<
    unsafe extern "C" fn(aInstance: *mut otInstance, aFrame: *mut otRadioFrame, aError: otError),
>;
extern "C" {
    #[doc = " This function enables/disables the raw link-layer.\n\n @param[in] aInstance     A pointer to an OpenThread instance.\n @param[in] aCallback     A pointer to a function called on receipt of a IEEE 802.15.4 frame. NULL to disable the\n raw-link layer.\n\n @retval OT_ERROR_FAILED          The radio could not be enabled/disabled.\n @retval OT_ERROR_INVALID_STATE   If the OpenThread IPv6 interface is already enabled.\n @retval OT_ERROR_NONE            If the enable state was successfully set.\n"]
    pub fn otLinkRawSetReceiveDone(
        aInstance: *mut otInstance,
        aCallback: otLinkRawReceiveDone,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not the raw link-layer is enabled.\n\n @param[in] aInstance     A pointer to an OpenThread instance.\n\n @retval true     The raw link-layer is enabled.\n @retval false    The raw link-layer is disabled.\n"]
    pub fn otLinkRawIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function gets the status of promiscuous mode.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n\n @retval true     Promiscuous mode is enabled.\n @retval false    Promiscuous mode is disabled.\n"]
    pub fn otLinkRawGetPromiscuous(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function enables or disables promiscuous mode.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aEnable      A value to enable or disable promiscuous mode.\n\n @retval OT_ERROR_NONE             If successful.\n @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawSetPromiscuous(aInstance: *mut otInstance, aEnable: bool) -> otError;
}
extern "C" {
    #[doc = " Set the Short Address for address filtering.\n\n @param[in] aInstance      A pointer to an OpenThread instance.\n @param[in] aShortAddress  The IEEE 802.15.4 Short Address.\n\n @retval OT_ERROR_NONE             If successful.\n @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawSetShortAddress(aInstance: *mut otInstance, aShortAddress: u16) -> otError;
}
extern "C" {
    #[doc = " Transition the radio from Receive to Sleep.\n Turn off the radio.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE             Successfully transitioned to Sleep.\n @retval OT_ERROR_BUSY             The radio was transmitting\n @retval OT_ERROR_INVALID_STATE    The radio was disabled\n"]
    pub fn otLinkRawSleep(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Transitioning the radio from Sleep to Receive.\n Turn on the radio.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE             Successfully transitioned to Receive.\n @retval OT_ERROR_INVALID_STATE    The radio was disabled or transmitting.\n"]
    pub fn otLinkRawReceive(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " The radio transitions from Transmit to Receive.\n This method returns a pointer to the transmit buffer.\n\n The caller forms the IEEE 802.15.4 frame in this buffer then calls otLinkRawTransmit()\n to request transmission.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n\n @returns A pointer to the transmit buffer or NULL if the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawGetTransmitBuffer(aInstance: *mut otInstance) -> *mut otRadioFrame;
}
#[doc = " This function pointer on receipt of a IEEE 802.15.4 frame.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aFrame           A pointer to the frame that was transmitted.\n @param[in]  aAckFrame        A pointer to the ACK frame.\n @param[in]  aError           OT_ERROR_NONE when the frame was transmitted.\n                              OT_ERROR_NO_ACK when the frame was transmitted but no ACK was received\n                              OT_ERROR_CHANNEL_ACCESS_FAILURE when the transmission could not take place\ndue to activity on the channel.\n                              OT_ERROR_ABORT when transmission was aborted for other reasons.\n"]
pub type otLinkRawTransmitDone = ::std::option::Option<
    unsafe extern "C" fn(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aAckFrame: *mut otRadioFrame,
        aError: otError,
    ),
>;
extern "C" {
    #[doc = " This method begins the transmit sequence on the radio.\n\n The caller must form the IEEE 802.15.4 frame in the buffer provided by otLinkRawGetTransmitBuffer() before\n requesting transmission.  The channel and transmit power are also included in the otRadioFrame structure.\n\n The transmit sequence consists of:\n 1. Transitioning the radio to Transmit from Receive.\n 2. Transmits the PSDU on the given channel and at the given transmit power.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aCallback    A pointer to a function called on completion of the transmission.\n\n @retval OT_ERROR_NONE          Successfully transitioned to Transmit.\n @retval OT_ERROR_INVALID_STATE The radio was not in the Receive state.\n"]
    pub fn otLinkRawTransmit(
        aInstance: *mut otInstance,
        aCallback: otLinkRawTransmitDone,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the most recent RSSI measurement.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n\n @returns The RSSI in dBm when it is valid. 127 when RSSI is invalid.\n"]
    pub fn otLinkRawGetRssi(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Get the radio capabilities.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n\n @returns The radio capability bit vector. The stack enables or disables some functions based on this value.\n"]
    pub fn otLinkRawGetCaps(aInstance: *mut otInstance) -> otRadioCaps;
}
#[doc = " This function pointer on receipt of a IEEE 802.15.4 frame.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  aEnergyScanMaxRssi   The maximum RSSI encountered on the scanned channel.\n"]
pub type otLinkRawEnergyScanDone =
    ::std::option::Option<unsafe extern "C" fn(aInstance: *mut otInstance, aEnergyScanMaxRssi: i8)>;
extern "C" {
    #[doc = " This method begins the energy scan sequence on the radio.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aScanChannel     The channel to perform the energy scan on.\n @param[in]  aScanDuration    The duration, in milliseconds, for the channel to be scanned.\n @param[in]  aCallback        A pointer to a function called on completion of a scanned channel.\n\n @retval OT_ERROR_NONE             Successfully started scanning the channel.\n @retval OT_ERROR_BUSY             The radio is performing energy scanning.\n @retval OT_ERROR_NOT_IMPLEMENTED  The radio doesn't support energy scanning.\n @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawEnergyScan(
        aInstance: *mut otInstance,
        aScanChannel: u8,
        aScanDuration: u16,
        aCallback: otLinkRawEnergyScanDone,
    ) -> otError;
}
extern "C" {
    #[doc = " Enable/Disable source match for frame pending.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aEnable      Enable/disable source match for frame pending.\n\n @retval OT_ERROR_NONE             If successful.\n @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawSrcMatchEnable(aInstance: *mut otInstance, aEnable: bool) -> otError;
}
extern "C" {
    #[doc = " Adding short address to the source match table.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aShortAddress    The short address to be added.\n\n @retval OT_ERROR_NONE             Successfully added short address to the source match table.\n @retval OT_ERROR_NO_BUFS          No available entry in the source match table.\n @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawSrcMatchAddShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Adding extended address to the source match table.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aExtAddress      The extended address to be added.\n\n @retval OT_ERROR_NONE             Successfully added extended address to the source match table.\n @retval OT_ERROR_NO_BUFS          No available entry in the source match table.\n @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawSrcMatchAddExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Removing short address to the source match table.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aShortAddress    The short address to be removed.\n\n @retval OT_ERROR_NONE             Successfully removed short address from the source match table.\n @retval OT_ERROR_NO_ADDRESS       The short address is not in source match table.\n @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawSrcMatchClearShortEntry(
        aInstance: *mut otInstance,
        aShortAddress: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Removing extended address to the source match table of the radio.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aExtAddress      The extended address to be removed.\n\n @retval OT_ERROR_NONE             Successfully removed the extended address from the source match table.\n @retval OT_ERROR_NO_ADDRESS       The extended address is not in source match table.\n @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawSrcMatchClearExtEntry(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
    ) -> otError;
}
extern "C" {
    #[doc = " Removing all the short addresses from the source match table.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE             If successful.\n @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawSrcMatchClearShortEntries(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Removing all the extended addresses from the source match table.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE             If successful.\n @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawSrcMatchClearExtEntries(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Update MAC keys and key index.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[in]   aKeyIdMode   The key ID mode.\n @param[in]   aKeyId       The key index.\n @param[in]   aPrevKey     The previous MAC key.\n @param[in]   aCurrKey     The current MAC key.\n @param[in]   aNextKey     The next MAC key.\n\n @retval OT_ERROR_NONE             If successful.\n @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawSetMacKey(
        aInstance: *mut otInstance,
        aKeyIdMode: u8,
        aKeyId: u8,
        aPrevKey: *const otMacKey,
        aCurrKey: *const otMacKey,
        aNextKey: *const otMacKey,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the current MAC frame counter value.\n\n This function always sets the MAC counter to the new given value @p aMacFrameCounter independent of the current\n value.\n\n @param[in]   aInstance         A pointer to an OpenThread instance.\n @param[in]   aMacFrameCounter  The MAC frame counter value.\n\n @retval OT_ERROR_NONE             If successful.\n @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawSetMacFrameCounter(
        aInstance: *mut otInstance,
        aMacFrameCounter: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the current MAC frame counter value only if the new value is larger than the current one.\n\n @param[in]   aInstance         A pointer to an OpenThread instance.\n @param[in]   aMacFrameCounter  The MAC frame counter value.\n\n @retval OT_ERROR_NONE             If successful.\n @retval OT_ERROR_INVALID_STATE    If the raw link-layer isn't enabled.\n"]
    pub fn otLinkRawSetMacFrameCounterIfLarger(
        aInstance: *mut otInstance,
        aMacFrameCounter: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " Get current platform time (64bits width) of the radio chip.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n\n @returns The current radio time in microseconds.\n"]
    pub fn otLinkRawGetRadioTime(aInstance: *mut otInstance) -> u64;
}
extern "C" {
    #[doc = " This function returns the current log level.\n\n If dynamic log level feature `OPENTHREAD_CONFIG_LOG_LEVEL_DYNAMIC_ENABLE` is enabled, this function returns the\n currently set dynamic log level. Otherwise, this function returns the build-time configured log level.\n\n @returns The log level.\n"]
    pub fn otLoggingGetLevel() -> otLogLevel;
}
extern "C" {
    #[doc = " This function sets the log level.\n\n @note This function requires `OPENTHREAD_CONFIG_LOG_LEVEL_DYNAMIC_ENABLE=1`.\n\n @param[in]  aLogLevel               The log level.\n\n @retval OT_ERROR_NONE            Successfully updated log level.\n @retval OT_ERROR_INVALID_ARGS    Log level value is invalid.\n"]
    pub fn otLoggingSetLevel(aLogLevel: otLogLevel) -> otError;
}
extern "C" {
    #[doc = " This function emits a log message at critical log level.\n\n This function is intended for use by platform. If `OPENTHREAD_CONFIG_LOG_PLATFORM` is not set or the current log\n level is below critical, this function does not emit any log message.\n\n @param[in]  aFormat  The format string.\n @param[in]  ...      Arguments for the format specification.\n"]
    pub fn otLogCritPlat(aFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " This function emits a log message at warning log level.\n\n This function is intended for use by platform. If `OPENTHREAD_CONFIG_LOG_PLATFORM` is not set or the current log\n level is below warning, this function does not emit any log message.\n\n @param[in]  aFormat  The format string.\n @param[in]  ...      Arguments for the format specification.\n"]
    pub fn otLogWarnPlat(aFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " This function emits a log message at note log level.\n\n This function is intended for use by platform. If `OPENTHREAD_CONFIG_LOG_PLATFORM` is not set or the current log\n level is below note, this function does not emit any log message.\n\n @param[in]  aFormat  The format string.\n @param[in]  ...      Arguments for the format specification.\n"]
    pub fn otLogNotePlat(aFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " This function emits a log message at info log level.\n\n This function is intended for use by platform. If `OPENTHREAD_CONFIG_LOG_PLATFORM` is not set or the current log\n level is below info, this function does not emit any log message.\n\n @param[in]  aFormat  The format string.\n @param[in]  ...      Arguments for the format specification.\n"]
    pub fn otLogInfoPlat(aFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " This function emits a log message at debug log level.\n\n This function is intended for use by platform. If `OPENTHREAD_CONFIG_LOG_PLATFORM` is not set or the current log\n level is below debug, this function does not emit any log message.\n\n @param[in]  aFormat  The format string.\n @param[in]  ...      Arguments for the format specification.\n"]
    pub fn otLogDebgPlat(aFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " This function generates a memory dump at critical log level.\n\n If `OPENTHREAD_CONFIG_LOG_PLATFORM` or `OPENTHREAD_CONFIG_LOG_PKT_DUMP` is not set or the current log level is below\n critical this function does not emit any log message.\n\n @param[in]  aText         A string that is printed before the bytes.\n @param[in]  aData         A pointer to the data buffer.\n @param[in]  aDataLength   Number of bytes in @p aData.\n"]
    pub fn otDumpCritPlat(
        aText: *const ::std::os::raw::c_char,
        aData: *const ::std::os::raw::c_void,
        aDataLength: u16,
    );
}
extern "C" {
    #[doc = " This function generates a memory dump at warning log level.\n\n If `OPENTHREAD_CONFIG_LOG_PLATFORM` or `OPENTHREAD_CONFIG_LOG_PKT_DUMP` is not set or the current log level is below\n warning this function does not emit any log message.\n\n @param[in]  aText         A string that is printed before the bytes.\n @param[in]  aData         A pointer to the data buffer.\n @param[in]  aDataLength   Number of bytes in @p aData.\n"]
    pub fn otDumpWarnPlat(
        aText: *const ::std::os::raw::c_char,
        aData: *const ::std::os::raw::c_void,
        aDataLength: u16,
    );
}
extern "C" {
    #[doc = " This function generates a memory dump at note log level.\n\n If `OPENTHREAD_CONFIG_LOG_PLATFORM` or `OPENTHREAD_CONFIG_LOG_PKT_DUMP` is not set or the current log level is below\n note this function does not emit any log message.\n\n @param[in]  aText         A string that is printed before the bytes.\n @param[in]  aData         A pointer to the data buffer.\n @param[in]  aDataLength   Number of bytes in @p aData.\n"]
    pub fn otDumpNotePlat(
        aText: *const ::std::os::raw::c_char,
        aData: *const ::std::os::raw::c_void,
        aDataLength: u16,
    );
}
extern "C" {
    #[doc = " This function generates a memory dump at info log level.\n\n If `OPENTHREAD_CONFIG_LOG_PLATFORM` or `OPENTHREAD_CONFIG_LOG_PKT_DUMP` is not set or the current log level is below\n info this function does not emit any log message.\n\n @param[in]  aText         A string that is printed before the bytes.\n @param[in]  aData         A pointer to the data buffer.\n @param[in]  aDataLength   Number of bytes in @p aData.\n"]
    pub fn otDumpInfoPlat(
        aText: *const ::std::os::raw::c_char,
        aData: *const ::std::os::raw::c_void,
        aDataLength: u16,
    );
}
extern "C" {
    #[doc = " This function generates a memory dump at debug log level.\n\n If `OPENTHREAD_CONFIG_LOG_PLATFORM` or `OPENTHREAD_CONFIG_LOG_PKT_DUMP` is not set or the current log level is below\n debug this function does not emit any log message.\n\n @param[in]  aText         A string that is printed before the bytes.\n @param[in]  aData         A pointer to the data buffer.\n @param[in]  aDataLength   Number of bytes in @p aData.\n"]
    pub fn otDumpDebgPlat(
        aText: *const ::std::os::raw::c_char,
        aData: *const ::std::os::raw::c_void,
        aDataLength: u16,
    );
}
extern "C" {
    #[doc = " This function emits a log message at a given log level.\n\n This function is intended for use by CLI only. If `OPENTHREAD_CONFIG_LOG_CLI` is not set or the current log\n level is below the given log level, this function does not emit any log message.\n\n @param[in]  aLogLevel The log level.\n @param[in]  aFormat   The format string.\n @param[in]  ...       Arguments for the format specification.\n"]
    pub fn otLogCli(aLogLevel: otLogLevel, aFormat: *const ::std::os::raw::c_char, ...);
}
#[doc = " This type represents information associated with a radio link.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otRadioLinkInfo {
    #[doc = "< Preference level of radio link"]
    pub mPreference: u8,
}
#[doc = " This type represents multi radio link information associated with a neighbor.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMultiRadioNeighborInfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Additional info for 15.4 radio link (applicable when supported)."]
    pub mIeee802154Info: otRadioLinkInfo,
    #[doc = "< Additional info for TREL radio link (applicable when supported)."]
    pub mTrelUdp6Info: otRadioLinkInfo,
}
impl otMultiRadioNeighborInfo {
    #[inline]
    pub fn mSupportsIeee802154(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mSupportsIeee802154(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mSupportsTrelUdp6(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mSupportsTrelUdp6(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mSupportsIeee802154: bool,
        mSupportsTrelUdp6: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mSupportsIeee802154: u8 = unsafe { ::std::mem::transmute(mSupportsIeee802154) };
            mSupportsIeee802154 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mSupportsTrelUdp6: u8 = unsafe { ::std::mem::transmute(mSupportsTrelUdp6) };
            mSupportsTrelUdp6 as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " This function gets the multi radio link information associated with a neighbor with a given Extended Address.\n\n This function requires the multi radio link feature to be enabled (please see `config/radio_link.h`).\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n @param[in]  aExtAddress    The Extended Address of neighbor.\n @param[out] aNeighborInfo  A pointer to `otMultiRadioNeighborInfo` to output the neighbor info (on success).\n\n @retval OT_ERROR_NONE        Neighbor was found and @p aNeighborInfo was updated successfully.\n @retval OT_ERROR_NOT_FOUND   Could not find a neighbor with @p aExtAddress.\n"]
    pub fn otMultiRadioGetNeighborInfo(
        aInstance: *mut otInstance,
        aExtAddress: *const otExtAddress,
        aNeighborInfo: *mut otMultiRadioNeighborInfo,
    ) -> otError;
}
#[doc = " @struct otIp4Address\n\n This structure represents an IPv4 address.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct otIp4Address {
    pub mFields: otIp4Address__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union otIp4Address__bindgen_ty_1 {
    #[doc = "< 8-bit fields"]
    pub m8: [u8; 4usize],
    #[doc = "< 32-bit representation"]
    pub m32: u32,
}
impl Default for otIp4Address__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otIp4Address {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @struct otIp4Cidr\n\n This structure represents an IPv4 CIDR block.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otIp4Cidr {
    pub mAddress: otIp4Address,
    pub mLength: u8,
}
impl Default for otIp4Cidr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Represents the counters for NAT64.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNat64Counters {
    #[doc = "< Number of packets translated from IPv4 to IPv6."]
    pub m4To6Packets: u64,
    #[doc = "< Sum of size of packets translated from IPv4 to IPv6."]
    pub m4To6Bytes: u64,
    #[doc = "< Number of packets translated from IPv6 to IPv4."]
    pub m6To4Packets: u64,
    #[doc = "< Sum of size of packets translated from IPv6 to IPv4."]
    pub m6To4Bytes: u64,
}
#[doc = " Represents the counters for the protocols supported by NAT64.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNat64ProtocolCounters {
    #[doc = "< Counters for sum of all protocols."]
    pub mTotal: otNat64Counters,
    #[doc = "< Counters for ICMP and ICMPv6."]
    pub mIcmp: otNat64Counters,
    #[doc = "< Counters for UDP."]
    pub mUdp: otNat64Counters,
    #[doc = "< Counters for TCP."]
    pub mTcp: otNat64Counters,
}
#[doc = "< Packet drop for unknown reasons."]
pub const OT_NAT64_DROP_REASON_UNKNOWN: otNat64DropReason = 0;
#[doc = "< Packet drop due to failed to parse the datagram."]
pub const OT_NAT64_DROP_REASON_ILLEGAL_PACKET: otNat64DropReason = 1;
#[doc = "< Packet drop due to unsupported IP protocol."]
pub const OT_NAT64_DROP_REASON_UNSUPPORTED_PROTO: otNat64DropReason = 2;
#[doc = "< Packet drop due to no mappings found or mapping pool exhausted."]
pub const OT_NAT64_DROP_REASON_NO_MAPPING: otNat64DropReason = 3;
pub const OT_NAT64_DROP_REASON_COUNT: otNat64DropReason = 4;
#[doc = " Packet drop reasons.\n"]
pub type otNat64DropReason = ::std::os::raw::c_uint;
#[doc = " Represents the counters of dropped packets due to errors when handling NAT64 packets.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNat64ErrorCounters {
    #[doc = "< Errors translating IPv4 packets."]
    pub mCount4To6: [u64; 4usize],
    #[doc = "< Errors translating IPv6 packets."]
    pub mCount6To4: [u64; 4usize],
}
extern "C" {
    #[doc = " Gets NAT64 translator counters.\n\n The counter is counted since the instance initialized.\n\n Available when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[out] aCounters A pointer to an `otNat64Counters` where the counters of NAT64 translator will be placed.\n"]
    pub fn otNat64GetCounters(aInstance: *mut otInstance, aCounters: *mut otNat64ProtocolCounters);
}
extern "C" {
    #[doc = " Gets the NAT64 translator error counters.\n\n The counters are initialized to zero when the OpenThread instance is initialized.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[out] aCounters A pointer to an `otNat64Counters` where the counters of NAT64 translator will be placed.\n"]
    pub fn otNat64GetErrorCounters(
        aInstance: *mut otInstance,
        aCounters: *mut otNat64ErrorCounters,
    );
}
#[doc = " Represents an address mapping record for NAT64.\n\n @note The counters will be reset for each mapping session even for the same address pair. Applications can use `mId`\n to identify different sessions to calculate the packets correctly.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNat64AddressMapping {
    #[doc = "< The unique id for a mapping session."]
    pub mId: u64,
    #[doc = "< The IPv4 address of the mapping."]
    pub mIp4: otIp4Address,
    #[doc = "< The IPv6 address of the mapping."]
    pub mIp6: otIp6Address,
    #[doc = "< Remaining time before expiry in milliseconds."]
    pub mRemainingTimeMs: u32,
    pub mCounters: otNat64ProtocolCounters,
}
impl Default for otNat64AddressMapping {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Used to iterate through NAT64 address mappings.\n\n The fields in this type are opaque (intended for use by OpenThread core only) and therefore should not be\n accessed or used by caller.\n\n Before using an iterator, it MUST be initialized using `otNat64AddressMappingIteratorInit()`.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otNat64AddressMappingIterator {
    pub mPtr: *mut ::std::os::raw::c_void,
}
impl Default for otNat64AddressMappingIterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Initializes an `otNat64AddressMappingIterator`.\n\n An iterator MUST be initialized before it is used.\n\n An iterator can be initialized again to restart from the beginning of the mapping info.\n\n @param[in]  aInstance  The OpenThread instance.\n @param[out] aIterator  A pointer to the iterator to initialize.\n"]
    pub fn otNat64InitAddressMappingIterator(
        aInstance: *mut otInstance,
        aIterator: *mut otNat64AddressMappingIterator,
    );
}
extern "C" {
    #[doc = " Gets the next AddressMapping info (using an iterator).\n\n Available when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled.\n\n @param[in]      aInstance      A pointer to an OpenThread instance.\n @param[in,out]  aIterator      A pointer to the iterator. On success the iterator will be updated to point to next\n                                NAT64 address mapping record. To get the first entry the iterator should be set to\n                                OT_NAT64_ADDRESS_MAPPING_ITERATOR_INIT.\n @param[out]     aMapping       A pointer to an `otNat64AddressMapping` where information of next NAT64 address\n                                mapping record is placed (on success).\n\n @retval OT_ERROR_NONE       Successfully found the next NAT64 address mapping info (@p aMapping was successfully\n                             updated).\n @retval OT_ERROR_NOT_FOUND  No subsequent NAT64 address mapping info was found.\n"]
    pub fn otNat64GetNextAddressMapping(
        aInstance: *mut otInstance,
        aIterator: *mut otNat64AddressMappingIterator,
        aMapping: *mut otNat64AddressMapping,
    ) -> otError;
}
#[doc = "< NAT64 is disabled."]
pub const OT_NAT64_STATE_DISABLED: otNat64State = 0;
#[doc = "< NAT64 is enabled, but one or more dependencies of NAT64 are not running."]
pub const OT_NAT64_STATE_NOT_RUNNING: otNat64State = 1;
#[doc = "< NAT64 is enabled, but this BR is not an active NAT64 BR."]
pub const OT_NAT64_STATE_IDLE: otNat64State = 2;
#[doc = "< The BR is publishing a NAT64 prefix and/or translating packets."]
pub const OT_NAT64_STATE_ACTIVE: otNat64State = 3;
#[doc = " States of NAT64.\n"]
pub type otNat64State = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Gets the state of NAT64 translator.\n\n Available when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n\n @retval OT_NAT64_STATE_DISABLED    NAT64 translator is disabled.\n @retval OT_NAT64_STATE_NOT_RUNNING NAT64 translator is enabled, but the translator is not configured with a valid\n                                    NAT64 prefix and a CIDR.\n @retval OT_NAT64_STATE_ACTIVE      NAT64 translator is enabled, and is translating packets.\n"]
    pub fn otNat64GetTranslatorState(aInstance: *mut otInstance) -> otNat64State;
}
extern "C" {
    #[doc = " Gets the state of NAT64 prefix manager.\n\n Available when `OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE` is enabled.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n\n @retval OT_NAT64_STATE_DISABLED    NAT64 prefix manager is disabled.\n @retval OT_NAT64_STATE_NOT_RUNNING NAT64 prefix manager is enabled, but is not running (because the routing manager\n                                    is not running).\n @retval OT_NAT64_STATE_IDLE        NAT64 prefix manager is enabled, but is not publishing a NAT64 prefix. Usually\n                                    when there is another border router publishing a NAT64 prefix with higher\n                                    priority.\n @retval OT_NAT64_STATE_ACTIVE      NAT64 prefix manager is enabled, and is publishing NAT64 prefix to the Thread\n                                    network.\n"]
    pub fn otNat64GetPrefixManagerState(aInstance: *mut otInstance) -> otNat64State;
}
extern "C" {
    #[doc = " Enable or disable NAT64 functions.\n\n Note: This includes the NAT64 Translator (when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled) and the NAT64\n Prefix Manager (when `OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE` is enabled).\n\n When `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled, setting disabled to true resets the\n mapping table in the translator.\n\n Available when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` or `OPENTHREAD_CONFIG_NAT64_BORDER_ROUTING_ENABLE` is\n enabled.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aEnabled   A boolean to enable/disable the NAT64 functions\n\n @sa otNat64GetTranslatorState\n @sa otNat64GetPrefixManagerState\n"]
    pub fn otNat64SetEnabled(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " Allocate a new message buffer for sending an IPv4 message to the NAT64 translator.\n\n Message buffers allocated by this function will have 20 bytes (difference between the size of IPv6 headers\n and IPv4 header sizes) reserved.\n\n Available when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled.\n\n @note If @p aSettings is `NULL`, the link layer security is enabled and the message priority is set to\n OT_MESSAGE_PRIORITY_NORMAL by default.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSettings  A pointer to the message settings or NULL to set default settings.\n\n @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid.\n\n @sa otNat64Send\n"]
    pub fn otIp4NewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Sets the CIDR used when setting the source address of the outgoing translated IPv4 packets.\n\n This function is available only when OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE is enabled.\n\n @note A valid CIDR must have a non-zero prefix length. The actual addresses pool is limited by the size of the\n mapping pool and the number of addresses available in the CIDR block.\n\n @note This function can be called at any time, but the NAT64 translator will be reset and all existing sessions will\n be expired when updating the configured CIDR.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n @param[in] aCidr      A pointer to an otIp4Cidr for the IPv4 CIDR block for NAT64.\n\n @retval  OT_ERROR_INVALID_ARGS   The given CIDR is not a valid IPv4 CIDR for NAT64.\n @retval  OT_ERROR_NONE           Successfully set the CIDR for NAT64.\n\n @sa otBorderRouterSend\n @sa otBorderRouterSetReceiveCallback\n"]
    pub fn otNat64SetIp4Cidr(aInstance: *mut otInstance, aCidr: *const otIp4Cidr) -> otError;
}
extern "C" {
    #[doc = " Translates an IPv4 datagram to an IPv6 datagram and sends via the Thread interface.\n\n The caller transfers ownership of @p aMessage when making this call. OpenThread will free @p aMessage when\n processing is complete, including when a value other than `OT_ERROR_NONE` is returned.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aMessage  A pointer to the message buffer containing the IPv4 datagram.\n\n @retval OT_ERROR_NONE                    Successfully processed the message.\n @retval OT_ERROR_DROP                    Message was well-formed but not fully processed due to packet processing\n                                          rules.\n @retval OT_ERROR_NO_BUFS                 Could not allocate necessary message buffers when processing the datagram.\n @retval OT_ERROR_NO_ROUTE                No route to host.\n @retval OT_ERROR_INVALID_SOURCE_ADDRESS  Source address is invalid, e.g. an anycast address or a multicast address.\n @retval OT_ERROR_PARSE                   Encountered a malformed header when processing the message.\n"]
    pub fn otNat64Send(aInstance: *mut otInstance, aMessage: *mut otMessage) -> otError;
}
#[doc = " This function pointer is called when an IPv4 datagram (translated by NAT64 translator) is received.\n\n @param[in]  aMessage  A pointer to the message buffer containing the received IPv6 datagram. This function transfers\n                       the ownership of the @p aMessage to the receiver of the callback. The message should be\n                       freed by the receiver of the callback after it is processed.\n @param[in]  aContext  A pointer to application-specific context.\n"]
pub type otNat64ReceiveIp4Callback = ::std::option::Option<
    unsafe extern "C" fn(aMessage: *mut otMessage, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Registers a callback to provide received IPv4 datagrams.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aCallback         A pointer to a function that is called when an IPv4 datagram is received or\n                               NULL to disable the callback.\n @param[in]  aCallbackContext  A pointer to application-specific context.\n"]
    pub fn otNat64SetReceiveIp4Callback(
        aInstance: *mut otInstance,
        aCallback: otNat64ReceiveIp4Callback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Gets the IPv4 CIDR configured in the NAT64 translator.\n\n Available when `OPENTHREAD_CONFIG_NAT64_TRANSLATOR_ENABLE` is enabled.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[out] aCidr             A pointer to an otIp4Cidr. Where the CIDR will be filled.\n"]
    pub fn otNat64GetCidr(aInstance: *mut otInstance, aCidr: *mut otIp4Cidr) -> otError;
}
extern "C" {
    #[doc = " Test if two IPv4 addresses are the same.\n\n @param[in]  aFirst   A pointer to the first IPv4 address to compare.\n @param[in]  aSecond  A pointer to the second IPv4 address to compare.\n\n @retval TRUE   The two IPv4 addresses are the same.\n @retval FALSE  The two IPv4 addresses are not the same.\n"]
    pub fn otIp4IsAddressEqual(aFirst: *const otIp4Address, aSecond: *const otIp4Address) -> bool;
}
extern "C" {
    #[doc = " Set @p aIp4Address by performing NAT64 address translation from @p aIp6Address as specified\n in RFC 6052.\n\n The NAT64 @p aPrefixLength MUST be one of the following values: 32, 40, 48, 56, 64, or 96, otherwise the behavior\n of this method is undefined.\n\n @param[in]  aPrefixLength  The prefix length to use for IPv4/IPv6 translation.\n @param[in]  aIp6Address    A pointer to an IPv6 address.\n @param[out] aIp4Address    A pointer to output the IPv4 address.\n"]
    pub fn otIp4ExtractFromIp6Address(
        aPrefixLength: u8,
        aIp6Address: *const otIp6Address,
        aIp4Address: *mut otIp4Address,
    );
}
extern "C" {
    #[doc = " Converts the address to a string.\n\n The string format uses quad-dotted notation of four bytes in the address (e.g., \"127.0.0.1\").\n\n If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be\n truncated but the outputted string is always null-terminated.\n\n @param[in]  aAddress  A pointer to an IPv4 address (MUST NOT be NULL).\n @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be `nullptr`).\n @param[in]  aSize     The size of @p aBuffer (in bytes).\n"]
    pub fn otIp4AddressToString(
        aAddress: *const otIp4Address,
        aBuffer: *mut ::std::os::raw::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " This function converts a human-readable IPv4 CIDR string into a binary representation.\n\n @param[in]   aString   A pointer to a NULL-terminated string.\n @param[out]  aCidr     A pointer to an IPv4 CIDR.\n\n @retval OT_ERROR_NONE          Successfully parsed the string.\n @retval OT_ERROR_INVALID_ARGS  Failed to parse the string.\n"]
    pub fn otIp4CidrFromString(
        aString: *const ::std::os::raw::c_char,
        aCidr: *mut otIp4Cidr,
    ) -> otError;
}
extern "C" {
    #[doc = " Converts the IPv4 CIDR to a string.\n\n The string format uses quad-dotted notation of four bytes in the address with the length of prefix (e.g.,\n \"127.0.0.1/32\").\n\n If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be\n truncated but the outputted string is always null-terminated.\n\n @param[in]  aCidr     A pointer to an IPv4 CIDR (MUST NOT be NULL).\n @param[out] aBuffer   A pointer to a char array to output the string (MUST NOT be `nullptr`).\n @param[in]  aSize     The size of @p aBuffer (in bytes).\n"]
    pub fn otIp4CidrToString(
        aCidr: *const otIp4Cidr,
        aBuffer: *mut ::std::os::raw::c_char,
        aSize: u16,
    );
}
extern "C" {
    #[doc = " Converts a human-readable IPv4 address string into a binary representation.\n\n @param[in]   aString   A pointer to a NULL-terminated string.\n @param[out]  aAddress  A pointer to an IPv4 address.\n\n @retval OT_ERROR_NONE          Successfully parsed the string.\n @retval OT_ERROR_INVALID_ARGS  Failed to parse the string.\n"]
    pub fn otIp4AddressFromString(
        aString: *const ::std::os::raw::c_char,
        aAddress: *mut otIp4Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets the IPv6 address by performing NAT64 address translation from the preferred NAT64 prefix and the given IPv4\n address as specified in RFC 6052.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[in]   aIp4Address  A pointer to the IPv4 address to translate to IPv6.\n @param[out]  aIp6Address  A pointer to the synthesized IPv6 address.\n\n @returns  OT_ERROR_NONE           Successfully synthesized the IPv6 address from NAT64 prefix and IPv4 address.\n @returns  OT_ERROR_INVALID_STATE  No valid NAT64 prefix in the network data.\n"]
    pub fn otNat64SynthesizeIp6Address(
        aInstance: *mut otInstance,
        aIp4Address: *const otIp4Address,
        aIp6Address: *mut otIp6Address,
    ) -> otError;
}
#[doc = " This function pointer is called to send HDLC encoded NCP data.\n\n @param[in]  aBuf        A pointer to a buffer with an output.\n @param[in]  aBufLength  A length of the output data stored in the buffer.\n\n @returns                Number of bytes processed by the callback.\n"]
pub type otNcpHdlcSendCallback = ::std::option::Option<
    unsafe extern "C" fn(aBuf: *const u8, aBufLength: u16) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " This function is called after NCP send finished.\n"]
    pub fn otNcpHdlcSendDone();
}
extern "C" {
    #[doc = " This function is called after HDLC encoded NCP data received.\n\n @param[in]  aBuf        A pointer to a buffer.\n @param[in]  aBufLength  The length of the data stored in the buffer.\n"]
    pub fn otNcpHdlcReceive(aBuf: *const u8, aBufLength: u16);
}
extern "C" {
    #[doc = " Initialize the NCP based on HDLC framing.\n\n @param[in]  aInstance        The OpenThread instance structure.\n @param[in]  aSendCallback    The function pointer used to send NCP data.\n"]
    pub fn otNcpHdlcInit(aInstance: *mut otInstance, aSendCallback: otNcpHdlcSendCallback);
}
extern "C" {
    #[doc = " Initialize the NCP based on SPI framing.\n\n @param[in]  aInstance  The OpenThread instance structure.\n"]
    pub fn otNcpSpiInit(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " @brief Send data to the host via a specific stream.\n\n This function attempts to send the given data to the host\n using the given aStreamId. This is useful for reporting\n error messages, implementing debug/diagnostic consoles,\n and potentially other types of datastreams.\n\n The write either is accepted in its entirety or rejected.\n Partial writes are not attempted.\n\n @param[in]  aStreamId  A numeric identifier for the stream to write to.\n                        If set to '0', will default to the debug stream.\n @param[in]  aDataPtr   A pointer to the data to send on the stream.\n                        If aDataLen is non-zero, this param MUST NOT be NULL.\n @param[in]  aDataLen   The number of bytes of data from aDataPtr to send.\n\n @retval OT_ERROR_NONE         The data was queued for delivery to the host.\n @retval OT_ERROR_BUSY         There are not enough resources to complete this\n                               request. This is usually a temporary condition.\n @retval OT_ERROR_INVALID_ARGS The given aStreamId was invalid."]
    pub fn otNcpStreamWrite(
        aStreamId: ::std::os::raw::c_int,
        aDataPtr: *const u8,
        aDataLen: ::std::os::raw::c_int,
    ) -> otError;
}
extern "C" {
    #[doc = " Writes OpenThread Log using `otNcpStreamWrite`.\n\n @param[in]  aLogLevel   The log level.\n @param[in]  aLogRegion  The log region.\n @param[in]  aFormat     A pointer to the format string.\n @param[in]  aArgs       va_list matching aFormat."]
    pub fn otNcpPlatLogv(
        aLogLevel: otLogLevel,
        aLogRegion: otLogRegion,
        aFormat: *const ::std::os::raw::c_char,
        aArgs: *mut __va_list_tag,
    );
}
#[doc = " Defines delegate (function pointer) type to control behavior of peek/poke operation.\n\n This delegate function is called to decide whether to allow peek or poke of a specific memory region. It is used\n if NCP support for peek/poke commands is enabled.\n\n @param[in] aAddress    Start address of memory region.\n @param[in] aCount      Number of bytes to peek or poke.\n\n @returns  TRUE to allow peek/poke of the given memory region, FALSE otherwise.\n"]
pub type otNcpDelegateAllowPeekPoke =
    ::std::option::Option<unsafe extern "C" fn(aAddress: u32, aCount: u16) -> bool>;
extern "C" {
    #[doc = " This method registers peek/poke delegate functions with NCP module.\n\n The delegate functions are called by NCP module to decide whether to allow peek or poke of a specific memory region.\n If the delegate pointer is set to NULL, it allows peek/poke operation for any address.\n\n @param[in] aAllowPeekDelegate      Delegate function pointer for peek operation.\n @param[in] aAllowPokeDelegate      Delegate function pointer for poke operation.\n"]
    pub fn otNcpRegisterPeekPokeDelegates(
        aAllowPeekDelegate: otNcpDelegateAllowPeekPoke,
        aAllowPokeDelegate: otNcpDelegateAllowPeekPoke,
    );
}
#[doc = "< The Thread stack is disabled."]
pub const OT_DEVICE_ROLE_DISABLED: otDeviceRole = 0;
#[doc = "< Not currently participating in a Thread network/partition."]
pub const OT_DEVICE_ROLE_DETACHED: otDeviceRole = 1;
#[doc = "< The Thread Child role."]
pub const OT_DEVICE_ROLE_CHILD: otDeviceRole = 2;
#[doc = "< The Thread Router role."]
pub const OT_DEVICE_ROLE_ROUTER: otDeviceRole = 3;
#[doc = "< The Thread Leader role."]
pub const OT_DEVICE_ROLE_LEADER: otDeviceRole = 4;
#[doc = " Represents a Thread device role.\n"]
pub type otDeviceRole = ::std::os::raw::c_uint;
#[doc = " This structure represents an MLE Link Mode configuration."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otLinkModeConfig {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otLinkModeConfig {
    #[inline]
    pub fn mRxOnWhenIdle(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRxOnWhenIdle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mDeviceType(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mDeviceType(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mNetworkData(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mNetworkData(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mRxOnWhenIdle: bool,
        mDeviceType: bool,
        mNetworkData: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mRxOnWhenIdle: u8 = unsafe { ::std::mem::transmute(mRxOnWhenIdle) };
            mRxOnWhenIdle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mDeviceType: u8 = unsafe { ::std::mem::transmute(mDeviceType) };
            mDeviceType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mNetworkData: u8 = unsafe { ::std::mem::transmute(mNetworkData) };
            mNetworkData as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure holds diagnostic information for a neighboring Thread node\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNeighborInfo {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Seconds since last heard"]
    pub mAge: u32,
    #[doc = "< Seconds since link establishment (requires `CONFIG_UPTIME_ENABLE`)"]
    pub mConnectionTime: u32,
    #[doc = "< RLOC16"]
    pub mRloc16: u16,
    #[doc = "< Link Frame Counter"]
    pub mLinkFrameCounter: u32,
    #[doc = "< MLE Frame Counter"]
    pub mMleFrameCounter: u32,
    #[doc = "< Link Quality In"]
    pub mLinkQualityIn: u8,
    #[doc = "< Average RSSI"]
    pub mAverageRssi: i8,
    #[doc = "< Last observed RSSI"]
    pub mLastRssi: i8,
    #[doc = "< Link Margin"]
    pub mLinkMargin: u8,
    #[doc = "< Frame error rate (0xffff->100%). Requires error tracking feature."]
    pub mFrameErrorRate: u16,
    #[doc = "< (IPv6) msg error rate (0xffff->100%). Requires error tracking feature."]
    pub mMessageErrorRate: u16,
    #[doc = "< Thread version of the neighbor"]
    pub mVersion: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl otNeighborInfo {
    #[inline]
    pub fn mRxOnWhenIdle(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRxOnWhenIdle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mFullThreadDevice(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullThreadDevice(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mFullNetworkData(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullNetworkData(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsChild(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsChild(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mRxOnWhenIdle: bool,
        mFullThreadDevice: bool,
        mFullNetworkData: bool,
        mIsChild: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mRxOnWhenIdle: u8 = unsafe { ::std::mem::transmute(mRxOnWhenIdle) };
            mRxOnWhenIdle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mFullThreadDevice: u8 = unsafe { ::std::mem::transmute(mFullThreadDevice) };
            mFullThreadDevice as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mFullNetworkData: u8 = unsafe { ::std::mem::transmute(mFullNetworkData) };
            mFullNetworkData as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsChild: u8 = unsafe { ::std::mem::transmute(mIsChild) };
            mIsChild as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type otNeighborInfoIterator = i16;
#[doc = " This structure represents the Thread Leader Data.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otLeaderData {
    #[doc = "< Partition ID"]
    pub mPartitionId: u32,
    #[doc = "< Leader Weight"]
    pub mWeighting: u8,
    #[doc = "< Full Network Data Version"]
    pub mDataVersion: u8,
    #[doc = "< Stable Network Data Version"]
    pub mStableDataVersion: u8,
    #[doc = "< Leader Router ID"]
    pub mLeaderRouterId: u8,
}
#[doc = " This structure holds diagnostic information for a Thread Router\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otRouterInfo {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< RLOC16"]
    pub mRloc16: u16,
    #[doc = "< Router ID"]
    pub mRouterId: u8,
    #[doc = "< Next hop to router"]
    pub mNextHop: u8,
    #[doc = "< Path cost to router"]
    pub mPathCost: u8,
    #[doc = "< Link Quality In"]
    pub mLinkQualityIn: u8,
    #[doc = "< Link Quality Out"]
    pub mLinkQualityOut: u8,
    #[doc = "< Time last heard"]
    pub mAge: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Thread version"]
    pub mVersion: u8,
    #[doc = "< CSL clock accuracy, in ± ppm"]
    pub mCslClockAccuracy: u8,
    #[doc = "< CSL uncertainty, in ±10 us"]
    pub mCslUncertainty: u8,
}
impl otRouterInfo {
    #[inline]
    pub fn mAllocated(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mAllocated(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mLinkEstablished(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkEstablished(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mAllocated: bool,
        mLinkEstablished: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mAllocated: u8 = unsafe { ::std::mem::transmute(mAllocated) };
            mAllocated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mLinkEstablished: u8 = unsafe { ::std::mem::transmute(mLinkEstablished) };
            mLinkEstablished as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents the IP level counters.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otIpCounters {
    #[doc = "< The number of IPv6 packets successfully transmitted."]
    pub mTxSuccess: u32,
    #[doc = "< The number of IPv6 packets successfully received."]
    pub mRxSuccess: u32,
    #[doc = "< The number of IPv6 packets failed to transmit."]
    pub mTxFailure: u32,
    #[doc = "< The number of IPv6 packets failed to receive."]
    pub mRxFailure: u32,
}
#[doc = " This structure represents the Thread MLE counters.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otMleCounters {
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_DISABLED role."]
    pub mDisabledRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_DETACHED role."]
    pub mDetachedRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_CHILD role."]
    pub mChildRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_ROUTER role."]
    pub mRouterRole: u16,
    #[doc = "< Number of times device entered OT_DEVICE_ROLE_LEADER role."]
    pub mLeaderRole: u16,
    #[doc = "< Number of attach attempts while device was detached."]
    pub mAttachAttempts: u16,
    #[doc = "< Number of changes to partition ID."]
    pub mPartitionIdChanges: u16,
    #[doc = "< Number of attempts to attach to a better partition."]
    pub mBetterPartitionAttachAttempts: u16,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_DISABLED role."]
    pub mDisabledTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_DETACHED role."]
    pub mDetachedTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_CHILD role."]
    pub mChildTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_ROUTER role."]
    pub mRouterTime: u64,
    #[doc = "< Number of milliseconds device has been in OT_DEVICE_ROLE_LEADER role."]
    pub mLeaderTime: u64,
    #[doc = "< Number of milliseconds tracked by previous counters."]
    pub mTrackedTime: u64,
    #[doc = " Number of times device changed its parent.\n\n A parent change can happen if device detaches from its current parent and attaches to a different one, or even\n while device is attached when the periodic parent search feature is enabled  (please see option\n OPENTHREAD_CONFIG_PARENT_SEARCH_ENABLE).\n"]
    pub mParentChanges: u16,
}
#[doc = " This structure represents the MLE Parent Response data.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otThreadParentResponseInfo {
    #[doc = "< IEEE 802.15.4 Extended Address of the Parent"]
    pub mExtAddr: otExtAddress,
    #[doc = "< Short address of the Parent"]
    pub mRloc16: u16,
    #[doc = "< Rssi of the Parent"]
    pub mRssi: i8,
    #[doc = "< Parent priority"]
    pub mPriority: i8,
    #[doc = "< Parent Link Quality 3"]
    pub mLinkQuality3: u8,
    #[doc = "< Parent Link Quality 2"]
    pub mLinkQuality2: u8,
    #[doc = "< Parent Link Quality 1"]
    pub mLinkQuality1: u8,
    #[doc = "< Is the node receiving parent response attached"]
    pub mIsAttached: bool,
}
#[doc = " This callback informs the application that the detaching process has finished.\n\n @param[in] aContext A pointer to application-specific context.\n"]
pub type otDetachGracefullyCallback =
    ::std::option::Option<unsafe extern "C" fn(aContext: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " This function starts Thread protocol operation.\n\n The interface must be up when calling this function.\n\n Calling this function with @p aEnabled set to FALSE stops any ongoing processes of detaching started by\n otThreadDetachGracefully(). Its callback will be called.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n @param[in] aEnabled  TRUE if Thread is enabled, FALSE otherwise.\n\n @retval OT_ERROR_NONE           Successfully started Thread protocol operation.\n @retval OT_ERROR_INVALID_STATE  The network interface was not not up.\n"]
    pub fn otThreadSetEnabled(aInstance: *mut otInstance, aEnabled: bool) -> otError;
}
extern "C" {
    #[doc = " This function gets the Thread protocol version.\n\n @returns the Thread protocol version.\n"]
    pub fn otThreadGetVersion() -> u16;
}
extern "C" {
    #[doc = " This function indicates whether a node is the only router on the network.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @retval TRUE   It is the only router in the network.\n @retval FALSE  It is a child or is not a single router in the network.\n"]
    pub fn otThreadIsSingleton(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function starts a Thread Discovery scan.\n\n @note A successful call to this function enables the rx-on-when-idle mode for the entire scan procedure.\n\n @param[in]  aInstance              A pointer to an OpenThread instance.\n @param[in]  aScanChannels          A bit vector indicating which channels to scan (e.g. OT_CHANNEL_11_MASK).\n @param[in]  aPanId                 The PAN ID filter (set to Broadcast PAN to disable filter).\n @param[in]  aJoiner                Value of the Joiner Flag in the Discovery Request TLV.\n @param[in]  aEnableEui64Filtering  TRUE to filter responses on EUI-64, FALSE otherwise.\n @param[in]  aCallback              A pointer to a function called on receiving an MLE Discovery Response or\n                                    scan completes.\n @param[in]  aCallbackContext       A pointer to application-specific context.\n\n @retval OT_ERROR_NONE           Successfully started a Thread Discovery Scan.\n @retval OT_ERROR_INVALID_STATE  The IPv6 interface is not enabled (netif is not up).\n @retval OT_ERROR_NO_BUFS        Could not allocate message for Discovery Request.\n @retval OT_ERROR_BUSY           Thread Discovery Scan is already in progress.\n"]
    pub fn otThreadDiscover(
        aInstance: *mut otInstance,
        aScanChannels: u32,
        aPanId: u16,
        aJoiner: bool,
        aEnableEui64Filtering: bool,
        aCallback: otHandleActiveScanResult,
        aCallbackContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function determines if an MLE Thread Discovery is currently in progress.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n"]
    pub fn otThreadIsDiscoverInProgress(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This method sets the Thread Joiner Advertisement when discovering Thread network.\n\n Thread Joiner Advertisement is used to allow a Joiner to advertise its own application-specific information\n (such as Vendor ID, Product ID, Discriminator, etc.) via a newly-proposed Joiner Advertisement TLV,\n and to make this information available to Commissioners or Commissioner Candidates without human interaction.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aOui             The Vendor IEEE OUI value that will be included in the Joiner Advertisement. Only the\n                              least significant 3 bytes will be used, and the most significant byte will be ignored.\n @param[in]  aAdvData         A pointer to the AdvData that will be included in the Joiner Advertisement.\n @param[in]  aAdvDataLength   The length of AdvData in bytes.\n\n @retval OT_ERROR_NONE         Successfully set Joiner Advertisement.\n @retval OT_ERROR_INVALID_ARGS Invalid AdvData.\n"]
    pub fn otThreadSetJoinerAdvertisement(
        aInstance: *mut otInstance,
        aOui: u32,
        aAdvData: *const u8,
        aAdvDataLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread Child Timeout (in seconds) used when operating in the Child role.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Thread Child Timeout value in seconds.\n\n @sa otThreadSetChildTimeout\n"]
    pub fn otThreadGetChildTimeout(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the Thread Child Timeout (in seconds) used when operating in the Child role.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aTimeout  The timeout value in seconds.\n\n @sa otThreadGetChildTimeout\n"]
    pub fn otThreadSetChildTimeout(aInstance: *mut otInstance, aTimeout: u32);
}
extern "C" {
    #[doc = " Gets the IEEE 802.15.4 Extended PAN ID.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the IEEE 802.15.4 Extended PAN ID.\n\n @sa otThreadSetExtendedPanId\n"]
    pub fn otThreadGetExtendedPanId(aInstance: *mut otInstance) -> *const otExtendedPanId;
}
extern "C" {
    #[doc = " Sets the IEEE 802.15.4 Extended PAN ID.\n\n @note Can only be called while Thread protocols are disabled. A successful\n call to this function invalidates the Active and Pending Operational Datasets in\n non-volatile memory.\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n @param[in]  aExtendedPanId  A pointer to the IEEE 802.15.4 Extended PAN ID.\n\n @retval OT_ERROR_NONE           Successfully set the Extended PAN ID.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n\n @sa otThreadGetExtendedPanId\n"]
    pub fn otThreadSetExtendedPanId(
        aInstance: *mut otInstance,
        aExtendedPanId: *const otExtendedPanId,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns a pointer to the Leader's RLOC.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aLeaderRloc  A pointer to the Leader's RLOC.\n\n @retval OT_ERROR_NONE          The Leader's RLOC was successfully written to @p aLeaderRloc.\n @retval OT_ERROR_INVALID_ARGS  @p aLeaderRloc was NULL.\n @retval OT_ERROR_DETACHED      Not currently attached to a Thread Partition.\n"]
    pub fn otThreadGetLeaderRloc(
        aInstance: *mut otInstance,
        aLeaderRloc: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the MLE Link Mode configuration.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The MLE Link Mode configuration.\n\n @sa otThreadSetLinkMode\n"]
    pub fn otThreadGetLinkMode(aInstance: *mut otInstance) -> otLinkModeConfig;
}
extern "C" {
    #[doc = " Set the MLE Link Mode configuration.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aConfig   A pointer to the Link Mode configuration.\n\n @retval OT_ERROR_NONE  Successfully set the MLE Link Mode configuration.\n\n @sa otThreadGetLinkMode\n"]
    pub fn otThreadSetLinkMode(aInstance: *mut otInstance, aConfig: otLinkModeConfig) -> otError;
}
extern "C" {
    #[doc = " Get the Thread Network Key.\n\n @param[in]   aInstance     A pointer to an OpenThread instance.\n @param[out]  aNetworkKey   A pointer to an `otNetworkKey` to return the Thread Network Key.\n\n @sa otThreadSetNetworkKey\n"]
    pub fn otThreadGetNetworkKey(aInstance: *mut otInstance, aNetworkKey: *mut otNetworkKey);
}
extern "C" {
    #[doc = " Get the `otNetworkKeyRef` for Thread Network Key.\n\n This function requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled.\n\n @param[in]   aInstance   A pointer to an OpenThread instance.\n\n @returns Reference to the Thread Network Key stored in memory.\n\n @sa otThreadSetNetworkKeyRef\n"]
    pub fn otThreadGetNetworkKeyRef(aInstance: *mut otInstance) -> otNetworkKeyRef;
}
extern "C" {
    #[doc = " Set the Thread Network Key.\n\n This function succeeds only when Thread protocols are disabled.  A successful\n call to this function invalidates the Active and Pending Operational Datasets in\n non-volatile memory.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aKey        A pointer to a buffer containing the Thread Network Key.\n\n @retval OT_ERROR_NONE            Successfully set the Thread Network Key.\n @retval OT_ERROR_INVALID_STATE   Thread protocols are enabled.\n\n @sa otThreadGetNetworkKey\n"]
    pub fn otThreadSetNetworkKey(aInstance: *mut otInstance, aKey: *const otNetworkKey) -> otError;
}
extern "C" {
    #[doc = " Set the Thread Network Key as a `otNetworkKeyRef`.\n\n This function succeeds only when Thread protocols are disabled.  A successful\n call to this function invalidates the Active and Pending Operational Datasets in\n non-volatile memory.\n\n This function requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aKeyRef     Reference to the Thread Network Key.\n\n @retval OT_ERROR_NONE            Successfully set the Thread Network Key.\n @retval OT_ERROR_INVALID_STATE   Thread protocols are enabled.\n\n @sa otThreadGetNetworkKeyRef\n"]
    pub fn otThreadSetNetworkKeyRef(
        aInstance: *mut otInstance,
        aKeyRef: otNetworkKeyRef,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread Routing Locator (RLOC) address.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the Thread Routing Locator (RLOC) address.\n"]
    pub fn otThreadGetRloc(aInstance: *mut otInstance) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Gets the Mesh Local EID address.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the Mesh Local EID address.\n"]
    pub fn otThreadGetMeshLocalEid(aInstance: *mut otInstance) -> *const otIp6Address;
}
extern "C" {
    #[doc = " This function returns a pointer to the Mesh Local Prefix.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the Mesh Local Prefix.\n"]
    pub fn otThreadGetMeshLocalPrefix(aInstance: *mut otInstance) -> *const otMeshLocalPrefix;
}
extern "C" {
    #[doc = " This function sets the Mesh Local Prefix.\n\n This function succeeds only when Thread protocols are disabled.  A successful\n call to this function invalidates the Active and Pending Operational Datasets in\n non-volatile memory.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aMeshLocalPrefix  A pointer to the Mesh Local Prefix.\n\n @retval OT_ERROR_NONE           Successfully set the Mesh Local Prefix.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n"]
    pub fn otThreadSetMeshLocalPrefix(
        aInstance: *mut otInstance,
        aMeshLocalPrefix: *const otMeshLocalPrefix,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread link-local IPv6 address.\n\n The Thread link local address is derived using IEEE802.15.4 Extended Address as Interface Identifier.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to Thread link-local IPv6 address.\n"]
    pub fn otThreadGetLinkLocalIp6Address(aInstance: *mut otInstance) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Gets the Thread Link-Local All Thread Nodes multicast address.\n\n The address is a link-local Unicast Prefix-Based Multicast Address [RFC 3306], with:\n   - flgs set to 3 (P = 1 and T = 1)\n   - scop set to 2\n   - plen set to 64\n   - network prefix set to the Mesh Local Prefix\n   - group ID set to 1\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to Thread Link-Local All Thread Nodes multicast address.\n"]
    pub fn otThreadGetLinkLocalAllThreadNodesMulticastAddress(
        aInstance: *mut otInstance,
    ) -> *const otIp6Address;
}
extern "C" {
    #[doc = " Gets the Thread Realm-Local All Thread Nodes multicast address.\n\n The address is a realm-local Unicast Prefix-Based Multicast Address [RFC 3306], with:\n   - flgs set to 3 (P = 1 and T = 1)\n   - scop set to 3\n   - plen set to 64\n   - network prefix set to the Mesh Local Prefix\n   - group ID set to 1\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to Thread Realm-Local All Thread Nodes multicast address.\n"]
    pub fn otThreadGetRealmLocalAllThreadNodesMulticastAddress(
        aInstance: *mut otInstance,
    ) -> *const otIp6Address;
}
extern "C" {
    #[doc = " This function retrieves the Service ALOC for given Service ID.\n\n @param[in]   aInstance     A pointer to an OpenThread instance.\n @param[in]   aServiceId    Service ID to get ALOC for.\n @param[out]  aServiceAloc  A pointer to output the Service ALOC. MUST NOT BE NULL.\n\n @retval OT_ERROR_NONE      Successfully retrieved the Service ALOC.\n @retval OT_ERROR_DETACHED  The Thread interface is not currently attached to a Thread Partition."]
    pub fn otThreadGetServiceAloc(
        aInstance: *mut otInstance,
        aServiceId: u8,
        aServiceAloc: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Thread Network Name.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the Thread Network Name.\n\n @sa otThreadSetNetworkName\n"]
    pub fn otThreadGetNetworkName(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the Thread Network Name.\n\n This function succeeds only when Thread protocols are disabled.  A successful\n call to this function invalidates the Active and Pending Operational Datasets in\n non-volatile memory.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aNetworkName  A pointer to the Thread Network Name.\n\n @retval OT_ERROR_NONE           Successfully set the Thread Network Name.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n\n @sa otThreadGetNetworkName\n"]
    pub fn otThreadSetNetworkName(
        aInstance: *mut otInstance,
        aNetworkName: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Thread Domain Name.\n\n @note Available since Thread 1.2.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the Thread Domain Name.\n\n @sa otThreadSetDomainName\n"]
    pub fn otThreadGetDomainName(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the Thread Domain Name. Only succeeds when Thread protocols are disabled.\n\n @note Available since Thread 1.2.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aDomainName   A pointer to the Thread Domain Name.\n\n @retval OT_ERROR_NONE           Successfully set the Thread Domain Name.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n\n @sa otThreadGetDomainName\n"]
    pub fn otThreadSetDomainName(
        aInstance: *mut otInstance,
        aDomainName: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets or clears the Interface Identifier manually specified for the Thread Domain Unicast Address.\n\n Available when `OPENTHREAD_CONFIG_DUA_ENABLE` is enabled.\n\n @note Only available since Thread 1.2.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aIid        A pointer to the Interface Identifier to set or NULL to clear.\n\n @retval OT_ERROR_NONE           Successfully set/cleared the Interface Identifier.\n @retval OT_ERROR_INVALID_ARGS   The specified Interface Identifier is reserved.\n\n @sa otThreadGetFixedDuaInterfaceIdentifier"]
    pub fn otThreadSetFixedDuaInterfaceIdentifier(
        aInstance: *mut otInstance,
        aIid: *const otIp6InterfaceIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " Gets the Interface Identifier manually specified for the Thread Domain Unicast Address.\n\n Available when `OPENTHREAD_CONFIG_DUA_ENABLE` is enabled.\n\n @note Only available since Thread 1.2.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns A pointer to the Interface Identifier which was set manually, or NULL if none was set.\n\n @sa otThreadSetFixedDuaInterfaceIdentifier\n"]
    pub fn otThreadGetFixedDuaInterfaceIdentifier(
        aInstance: *mut otInstance,
    ) -> *const otIp6InterfaceIdentifier;
}
extern "C" {
    #[doc = " Gets the thrKeySequenceCounter.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The thrKeySequenceCounter value.\n\n @sa otThreadSetKeySequenceCounter\n"]
    pub fn otThreadGetKeySequenceCounter(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the thrKeySequenceCounter.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  aKeySequenceCounter  The thrKeySequenceCounter value.\n\n @sa otThreadGetKeySequenceCounter\n"]
    pub fn otThreadSetKeySequenceCounter(aInstance: *mut otInstance, aKeySequenceCounter: u32);
}
extern "C" {
    #[doc = " Gets the thrKeySwitchGuardTime (in hours).\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The thrKeySwitchGuardTime value (in hours).\n\n @sa otThreadSetKeySwitchGuardTime\n"]
    pub fn otThreadGetKeySwitchGuardTime(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Sets the thrKeySwitchGuardTime (in hours).\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  aKeySwitchGuardTime  The thrKeySwitchGuardTime value (in hours).\n\n @sa otThreadGetKeySwitchGuardTime\n"]
    pub fn otThreadSetKeySwitchGuardTime(aInstance: *mut otInstance, aKeySwitchGuardTime: u32);
}
extern "C" {
    #[doc = " Detach from the Thread network.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE           Successfully detached from the Thread network.\n @retval OT_ERROR_INVALID_STATE  Thread is disabled.\n"]
    pub fn otThreadBecomeDetached(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Attempt to reattach as a child.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE           Successfully begin attempt to become a child.\n @retval OT_ERROR_INVALID_STATE  Thread is disabled.\n"]
    pub fn otThreadBecomeChild(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function gets the next neighbor information. It is used to go through the entries of\n the neighbor table.\n\n @param[in]      aInstance  A pointer to an OpenThread instance.\n @param[in,out]  aIterator  A pointer to the iterator context. To get the first neighbor entry\nit should be set to OT_NEIGHBOR_INFO_ITERATOR_INIT.\n @param[out]     aInfo      A pointer to the neighbor information.\n\n @retval OT_ERROR_NONE         Successfully found the next neighbor entry in table.\n @retval OT_ERROR_NOT_FOUND     No subsequent neighbor entry exists in the table.\n @retval OT_ERROR_INVALID_ARGS  @p aIterator or @p aInfo was NULL.\n"]
    pub fn otThreadGetNextNeighborInfo(
        aInstance: *mut otInstance,
        aIterator: *mut otNeighborInfoIterator,
        aInfo: *mut otNeighborInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the device role.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval OT_DEVICE_ROLE_DISABLED  The Thread stack is disabled.\n @retval OT_DEVICE_ROLE_DETACHED  The device is not currently participating in a Thread network/partition.\n @retval OT_DEVICE_ROLE_CHILD     The device is currently operating as a Thread Child.\n @retval OT_DEVICE_ROLE_ROUTER    The device is currently operating as a Thread Router.\n @retval OT_DEVICE_ROLE_LEADER    The device is currently operating as a Thread Leader.\n"]
    pub fn otThreadGetDeviceRole(aInstance: *mut otInstance) -> otDeviceRole;
}
extern "C" {
    #[doc = " Convert the device role to human-readable string.\n\n @param[in] aRole   The device role to convert.\n\n @returns A string representing @p aRole.\n"]
    pub fn otThreadDeviceRoleToString(aRole: otDeviceRole) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function get the Thread Leader Data.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aLeaderData  A pointer to where the leader data is placed.\n\n @retval OT_ERROR_NONE          Successfully retrieved the leader data.\n @retval OT_ERROR_DETACHED      Not currently attached.\n"]
    pub fn otThreadGetLeaderData(
        aInstance: *mut otInstance,
        aLeaderData: *mut otLeaderData,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Leader's Router ID.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Leader's Router ID.\n"]
    pub fn otThreadGetLeaderRouterId(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Get the Leader's Weight.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Leader's Weight.\n"]
    pub fn otThreadGetLeaderWeight(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Get the Partition ID.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Partition ID.\n"]
    pub fn otThreadGetPartitionId(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Get the RLOC16.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The RLOC16.\n"]
    pub fn otThreadGetRloc16(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " The function retrieves diagnostic information for a Thread Router as parent.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aParentInfo  A pointer to where the parent router information is placed.\n"]
    pub fn otThreadGetParentInfo(
        aInstance: *mut otInstance,
        aParentInfo: *mut otRouterInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " The function retrieves the average RSSI for the Thread Parent.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aParentRssi  A pointer to where the parent RSSI should be placed.\n"]
    pub fn otThreadGetParentAverageRssi(
        aInstance: *mut otInstance,
        aParentRssi: *mut i8,
    ) -> otError;
}
extern "C" {
    #[doc = " The function retrieves the RSSI of the last packet from the Thread Parent.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[out]  aLastRssi    A pointer to where the last RSSI should be placed.\n\n @retval OT_ERROR_NONE          Successfully retrieved the RSSI data.\n @retval OT_ERROR_FAILED        Unable to get RSSI data.\n @retval OT_ERROR_INVALID_ARGS  @p aLastRssi is NULL.\n"]
    pub fn otThreadGetParentLastRssi(aInstance: *mut otInstance, aLastRssi: *mut i8) -> otError;
}
extern "C" {
    #[doc = " Starts the process for child to search for a better parent while staying attached to its current parent.\n\n Must be used when device is attached as a child.\n\n @retval OT_ERROR_NONE           Successfully started the process to search for a better parent.\n @retval OT_ERROR_INVALID_STATE  Device role is not child.\n"]
    pub fn otThreadSearchForBetterParent(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Gets the IPv6 counters.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns A pointer to the IPv6 counters.\n"]
    pub fn otThreadGetIp6Counters(aInstance: *mut otInstance) -> *const otIpCounters;
}
extern "C" {
    #[doc = " Resets the IPv6 counters.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otThreadResetIp6Counters(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Gets the Thread MLE counters.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns A pointer to the Thread MLE counters.\n"]
    pub fn otThreadGetMleCounters(aInstance: *mut otInstance) -> *const otMleCounters;
}
extern "C" {
    #[doc = " Resets the Thread MLE counters.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n"]
    pub fn otThreadResetMleCounters(aInstance: *mut otInstance);
}
#[doc = " This function pointer is called every time an MLE Parent Response message is received.\n\n This is used in `otThreadRegisterParentResponseCallback()`.\n\n @param[in]  aInfo     A pointer to a location on stack holding the stats data.\n @param[in]  aContext  A pointer to callback client-specific context.\n"]
pub type otThreadParentResponseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aInfo: *mut otThreadParentResponseInfo,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function registers a callback to receive MLE Parent Response data.\n\n This function requires `OPENTHREAD_CONFIG_MLE_PARENT_RESPONSE_CALLBACK_API_ENABLE`.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aCallback  A pointer to a function that is called upon receiving an MLE Parent Response message.\n @param[in]  aContext   A pointer to callback client-specific context.\n"]
    pub fn otThreadRegisterParentResponseCallback(
        aInstance: *mut otInstance,
        aCallback: otThreadParentResponseCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
#[doc = " This structure represents the Thread Discovery Request data.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otThreadDiscoveryRequestInfo {
    #[doc = "< IEEE 802.15.4 Extended Address of the requester"]
    pub mExtAddress: otExtAddress,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otThreadDiscoveryRequestInfo {
    #[inline]
    pub fn mVersion(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mVersion(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsJoiner(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsJoiner(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mVersion: u8, mIsJoiner: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mVersion: u8 = unsafe { ::std::mem::transmute(mVersion) };
            mVersion as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsJoiner: u8 = unsafe { ::std::mem::transmute(mIsJoiner) };
            mIsJoiner as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This function pointer is called every time an MLE Discovery Request message is received.\n\n @param[in]  aInfo     A pointer to the Discovery Request info data.\n @param[in]  aContext  A pointer to callback application-specific context.\n"]
pub type otThreadDiscoveryRequestCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aInfo: *const otThreadDiscoveryRequestInfo,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function sets a callback to receive MLE Discovery Request data.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aCallback  A pointer to a function that is called upon receiving an MLE Discovery Request message.\n @param[in]  aContext   A pointer to callback application-specific context.\n"]
    pub fn otThreadSetDiscoveryRequestCallback(
        aInstance: *mut otInstance,
        aCallback: otThreadDiscoveryRequestCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
#[doc = " This function pointer type defines the callback to notify the outcome of a `otThreadLocateAnycastDestination()`\n request.\n\n @param[in] aContext            A pointer to an arbitrary context (provided when callback is registered).\n @param[in] aError              The error when handling the request. OT_ERROR_NONE indicates success.\n                                OT_ERROR_RESPONSE_TIMEOUT indicates a destination could not be found.\n                                OT_ERROR_ABORT indicates the request was aborted.\n @param[in] aMeshLocalAddress   A pointer to the mesh-local EID of the closest destination of the anycast address\n                                when @p aError is OT_ERROR_NONE, NULL otherwise.\n @param[in] aRloc16             The RLOC16 of the destination if found, otherwise invalid RLOC16 (0xfffe).\n"]
pub type otThreadAnycastLocatorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aError: otError,
        aMeshLocalAddress: *const otIp6Address,
        aRloc16: u16,
    ),
>;
extern "C" {
    #[doc = " This function requests the closest destination of a given anycast address to be located.\n\n This function is only available when `OPENTHREAD_CONFIG_TMF_ANYCAST_LOCATOR_ENABLE` is enabled.\n\n If a previous request is ongoing, a subsequent call to this function will cancel and replace the earlier request.\n\n @param[in] aInstance         A pointer to an OpenThread instance.\n @param[in] aAnycastAddress   The anycast address to locate. MUST NOT be NULL.\n @param[in] aCallback         The callback function to report the result.\n @param[in] aContext          An arbitrary context used with @p aCallback.\n\n @retval OT_ERROR_NONE          The request started successfully. @p aCallback will be invoked to report the result.\n @retval OT_ERROR_INVALID_ARGS  The @p aAnycastAddress is not a valid anycast address or @p aCallback is NULL.\n @retval OT_ERROR_NO_BUFS       Out of buffer to prepare and send the request message.\n"]
    pub fn otThreadLocateAnycastDestination(
        aInstance: *mut otInstance,
        aAnycastAddress: *const otIp6Address,
        aCallback: otThreadAnycastLocatorCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether an anycast locate request is currently in progress.\n\n This function is only available when `OPENTHREAD_CONFIG_TMF_ANYCAST_LOCATOR_ENABLE` is enabled.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns TRUE if an anycast locate request is currently in progress, FALSE otherwise.\n"]
    pub fn otThreadIsAnycastLocateInProgress(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function sends a Proactive Address Notification (ADDR_NTF.ntf) message.\n\n This function is only available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aDestination  The destination to send the ADDR_NTF.ntf message.\n @param[in]  aTarget       The target address of the ADDR_NTF.ntf message.\n @param[in]  aMlIid        The ML-IID of the ADDR_NTF.ntf message.\n"]
    pub fn otThreadSendAddressNotification(
        aInstance: *mut otInstance,
        aDestination: *mut otIp6Address,
        aTarget: *mut otIp6Address,
        aMlIid: *mut otIp6InterfaceIdentifier,
    );
}
extern "C" {
    #[doc = " This function sends a Proactive Backbone Notification (PRO_BB.ntf) message on the Backbone link.\n\n This function is only available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled.\n\n @param[in]  aInstance                    A pointer to an OpenThread instance.\n @param[in]  aTarget                      The target address of the PRO_BB.ntf message.\n @param[in]  aMlIid                       The ML-IID of the PRO_BB.ntf message.\n @param[in]  aTimeSinceLastTransaction    Time since last transaction (in seconds).\n\n @retval OT_ERROR_NONE           Successfully sent PRO_BB.ntf on backbone link.\n @retval OT_ERROR_NO_BUFS        If insufficient message buffers available.\n"]
    pub fn otThreadSendProactiveBackboneNotification(
        aInstance: *mut otInstance,
        aTarget: *mut otIp6Address,
        aMlIid: *mut otIp6InterfaceIdentifier,
        aTimeSinceLastTransaction: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " This function notifies other nodes in the network (if any) and then stops Thread protocol operation.\n\n It sends an Address Release if it's a router, or sets its child timeout to 0 if it's a child.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n @param[in] aCallback A pointer to a function that is called upon finishing detaching.\n @param[in] aContext  A pointer to callback application-specific context.\n\n @retval OT_ERROR_NONE Successfully started detaching.\n @retval OT_ERROR_BUSY Detaching is already in progress.\n"]
    pub fn otThreadDetachGracefully(
        aInstance: *mut otInstance,
        aCallback: otDetachGracefullyCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function converts an `uint32_t` duration (in seconds) to a human-readable string.\n\n This function requires `OPENTHREAD_CONFIG_UPTIME_ENABLE` to be enabled.\n\n The string follows the format \"<hh>:<mm>:<ss>\" for hours, minutes, seconds (if duration is shorter than one day) or\n \"<dd>d.<hh>:<mm>:<ss>\" (if longer than a day).\n\n If the resulting string does not fit in @p aBuffer (within its @p aSize characters), the string will be truncated\n but the outputted string is always null-terminated.\n\n This function is intended for use with `mAge` or `mConnectionTime` in `otNeighborInfo` or `otChildInfo` structures.\n\n @param[in]  aDuration A duration interval in seconds.\n @param[out] aBuffer   A pointer to a char array to output the string.\n @param[in]  aSize     The size of @p aBuffer (in bytes). Recommended to use `OT_DURATION_STRING_SIZE`.\n"]
    pub fn otConvertDurationInSecondsToString(
        aDuration: u32,
        aBuffer: *mut ::std::os::raw::c_char,
        aSize: u16,
    );
}
#[doc = "< MAC Extended Address TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_EXT_ADDRESS: _bindgen_ty_11 = 0;
#[doc = "< Address16 TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_SHORT_ADDRESS: _bindgen_ty_11 = 1;
#[doc = "< Mode TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_MODE: _bindgen_ty_11 = 2;
#[doc = "< Timeout TLV (the maximum polling time period for SEDs)"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_TIMEOUT: _bindgen_ty_11 = 3;
#[doc = "< Connectivity TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_CONNECTIVITY: _bindgen_ty_11 = 4;
#[doc = "< Route64 TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_ROUTE: _bindgen_ty_11 = 5;
#[doc = "< Leader Data TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_LEADER_DATA: _bindgen_ty_11 = 6;
#[doc = "< Network Data TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_NETWORK_DATA: _bindgen_ty_11 = 7;
#[doc = "< IPv6 Address List TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_IP6_ADDR_LIST: _bindgen_ty_11 = 8;
#[doc = "< MAC Counters TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_MAC_COUNTERS: _bindgen_ty_11 = 9;
#[doc = "< Battery Level TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_BATTERY_LEVEL: _bindgen_ty_11 = 14;
#[doc = "< Supply Voltage TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_SUPPLY_VOLTAGE: _bindgen_ty_11 = 15;
#[doc = "< Child Table TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_CHILD_TABLE: _bindgen_ty_11 = 16;
#[doc = "< Channel Pages TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_CHANNEL_PAGES: _bindgen_ty_11 = 17;
#[doc = "< Type List TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_TYPE_LIST: _bindgen_ty_11 = 18;
#[doc = "< Max Child Timeout TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_MAX_CHILD_TIMEOUT: _bindgen_ty_11 = 19;
#[doc = "< Version TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_VERSION: _bindgen_ty_11 = 24;
#[doc = "< Vendor Name TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_NAME: _bindgen_ty_11 = 25;
#[doc = "< Vendor Model TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_MODEL: _bindgen_ty_11 = 26;
#[doc = "< Vendor SW Version TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_VENDOR_SW_VERSION: _bindgen_ty_11 = 27;
#[doc = "< Thread Stack Version TLV"]
pub const OT_NETWORK_DIAGNOSTIC_TLV_THREAD_STACK_VERSION: _bindgen_ty_11 = 28;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub type otNetworkDiagIterator = u16;
#[doc = " This structure represents a Network Diagnostic Connectivity value.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNetworkDiagConnectivity {
    #[doc = " The priority of the sender as a parent."]
    pub mParentPriority: i8,
    #[doc = " The number of neighboring devices with which the sender shares a link of quality 3."]
    pub mLinkQuality3: u8,
    #[doc = " The number of neighboring devices with which the sender shares a link of quality 2."]
    pub mLinkQuality2: u8,
    #[doc = " The number of neighboring devices with which the sender shares a link of quality 1."]
    pub mLinkQuality1: u8,
    #[doc = " The sender's routing cost to the Leader."]
    pub mLeaderCost: u8,
    #[doc = " The most recent ID sequence number received by the sender."]
    pub mIdSequence: u8,
    #[doc = " The number of active Routers in the sender's Thread Network Partition."]
    pub mActiveRouters: u8,
    #[doc = " The guaranteed buffer capacity in octets for all IPv6 datagrams destined to a given SED. Optional."]
    pub mSedBufferSize: u16,
    #[doc = " The guaranteed queue capacity in number of IPv6 datagrams destined to a given SED. Optional."]
    pub mSedDatagramCount: u8,
}
#[doc = " This structure represents a Network Diagnostic Route data.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNetworkDiagRouteData {
    #[doc = "< The Assigned Router ID."]
    pub mRouterId: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl otNetworkDiagRouteData {
    #[inline]
    pub fn mLinkQualityOut(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkQualityOut(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mLinkQualityIn(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkQualityIn(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mRouteCost(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mRouteCost(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mLinkQualityOut: u8,
        mLinkQualityIn: u8,
        mRouteCost: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let mLinkQualityOut: u8 = unsafe { ::std::mem::transmute(mLinkQualityOut) };
            mLinkQualityOut as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let mLinkQualityIn: u8 = unsafe { ::std::mem::transmute(mLinkQualityIn) };
            mLinkQualityIn as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let mRouteCost: u8 = unsafe { ::std::mem::transmute(mRouteCost) };
            mRouteCost as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents a Network Diagnostic Route TLV value.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otNetworkDiagRoute {
    #[doc = " The sequence number associated with the set of Router ID assignments in #mRouteData."]
    pub mIdSequence: u8,
    #[doc = " Number of elements in #mRouteData."]
    pub mRouteCount: u8,
    #[doc = " Link Quality and Routing Cost data."]
    pub mRouteData: [otNetworkDiagRouteData; 63usize],
}
impl Default for otNetworkDiagRoute {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents a Network Diagnostic Mac Counters value.\n\n See <a href=\"https://www.ietf.org/rfc/rfc2863\">RFC 2863</a> for definitions of member fields.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNetworkDiagMacCounters {
    pub mIfInUnknownProtos: u32,
    pub mIfInErrors: u32,
    pub mIfOutErrors: u32,
    pub mIfInUcastPkts: u32,
    pub mIfInBroadcastPkts: u32,
    pub mIfInDiscards: u32,
    pub mIfOutUcastPkts: u32,
    pub mIfOutBroadcastPkts: u32,
    pub mIfOutDiscards: u32,
}
#[doc = " This structure represents a Network Diagnostic Child Table Entry.\n"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct otNetworkDiagChildEntry {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = " Link mode bits."]
    pub mMode: otLinkModeConfig,
}
impl otNetworkDiagChildEntry {
    #[inline]
    pub fn mTimeout(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mTimeout(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mLinkQuality(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mLinkQuality(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mChildId(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_mChildId(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mTimeout: u16,
        mLinkQuality: u8,
        mChildId: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let mTimeout: u16 = unsafe { ::std::mem::transmute(mTimeout) };
            mTimeout as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let mLinkQuality: u8 = unsafe { ::std::mem::transmute(mLinkQuality) };
            mLinkQuality as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let mChildId: u16 = unsafe { ::std::mem::transmute(mChildId) };
            mChildId as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This structure represents a Network Diagnostic TLV.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetworkDiagTlv {
    #[doc = " The Network Diagnostic TLV type."]
    pub mType: u8,
    pub mData: otNetworkDiagTlv__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otNetworkDiagTlv__bindgen_ty_1 {
    pub mExtAddress: otExtAddress,
    pub mAddr16: u16,
    pub mMode: otLinkModeConfig,
    pub mTimeout: u32,
    pub mConnectivity: otNetworkDiagConnectivity,
    pub mRoute: otNetworkDiagRoute,
    pub mLeaderData: otLeaderData,
    pub mMacCounters: otNetworkDiagMacCounters,
    pub mBatteryLevel: u8,
    pub mSupplyVoltage: u16,
    pub mMaxChildTimeout: u32,
    pub mVersion: u16,
    pub mVendorName: [::std::os::raw::c_char; 33usize],
    pub mVendorModel: [::std::os::raw::c_char; 33usize],
    pub mVendorSwVersion: [::std::os::raw::c_char; 17usize],
    pub mThreadStackVersion: [::std::os::raw::c_char; 65usize],
    pub mNetworkData: otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_1,
    pub mIp6AddrList: otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_2,
    pub mChildTable: otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_3,
    pub mChannelPages: otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_1 {
    pub mCount: u8,
    pub m8: [u8; 254usize],
}
impl Default for otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_2 {
    pub mCount: u8,
    pub mList: [otIp6Address; 15usize],
}
impl Default for otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_3 {
    pub mCount: u8,
    pub mTable: [otNetworkDiagChildEntry; 84usize],
}
impl Default for otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_4 {
    pub mCount: u8,
    pub m8: [u8; 254usize],
}
impl Default for otNetworkDiagTlv__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otNetworkDiagTlv__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otNetworkDiagTlv {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function gets the next Network Diagnostic TLV in the message.\n\n Requires `OPENTHREAD_CONFIG_TMF_NETDIAG_CLIENT_ENABLE`.\n\n @param[in]      aMessage         A pointer to a message.\n @param[in,out]  aIterator        A pointer to the Network Diagnostic iterator context. To get the first\n                                  Network Diagnostic TLV it should be set to OT_NETWORK_DIAGNOSTIC_ITERATOR_INIT.\n @param[out]     aNetworkDiagTlv  A pointer to where the Network Diagnostic TLV information will be placed.\n\n @retval OT_ERROR_NONE       Successfully found the next Network Diagnostic TLV.\n @retval OT_ERROR_NOT_FOUND  No subsequent Network Diagnostic TLV exists in the message.\n @retval OT_ERROR_PARSE      Parsing the next Network Diagnostic failed.\n\n @Note A subsequent call to this function is allowed only when current return value is OT_ERROR_NONE.\n"]
    pub fn otThreadGetNextDiagnosticTlv(
        aMessage: *const otMessage,
        aIterator: *mut otNetworkDiagIterator,
        aNetworkDiagTlv: *mut otNetworkDiagTlv,
    ) -> otError;
}
#[doc = " This function pointer is called when Network Diagnostic Get response is received.\n\n @param[in]  aError        The error when failed to get the response.\n @param[in]  aMessage      A pointer to the message buffer containing the received Network Diagnostic\n                           Get response payload. Available only when @p aError is `OT_ERROR_NONE`.\n @param[in]  aMessageInfo  A pointer to the message info for @p aMessage. Available only when\n                           @p aError is `OT_ERROR_NONE`.\n @param[in]  aContext      A pointer to application-specific context.\n"]
pub type otReceiveDiagnosticGetCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aError: otError,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Send a Network Diagnostic Get request.\n\n Requires `OPENTHREAD_CONFIG_TMF_NETDIAG_CLIENT_ENABLE`.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aDestination      A pointer to destination address.\n @param[in]  aTlvTypes         An array of Network Diagnostic TLV types.\n @param[in]  aCount            Number of types in aTlvTypes.\n @param[in]  aCallback         A pointer to a function that is called when Network Diagnostic Get response\n                               is received or NULL to disable the callback.\n @param[in]  aCallbackContext  A pointer to application-specific context.\n\n @retval OT_ERROR_NONE    Successfully queued the DIAG_GET.req.\n @retval OT_ERROR_NO_BUFS Insufficient message buffers available to send DIAG_GET.req.\n"]
    pub fn otThreadSendDiagnosticGet(
        aInstance: *mut otInstance,
        aDestination: *const otIp6Address,
        aTlvTypes: *const u8,
        aCount: u8,
        aCallback: otReceiveDiagnosticGetCallback,
        aCallbackContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Send a Network Diagnostic Reset request.\n\n Requires `OPENTHREAD_CONFIG_TMF_NETDIAG_CLIENT_ENABLE`.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n @param[in]  aDestination   A pointer to destination address.\n @param[in]  aTlvTypes      An array of Network Diagnostic TLV types. Currently only Type 9 is allowed.\n @param[in]  aCount         Number of types in aTlvTypes\n\n @retval OT_ERROR_NONE    Successfully queued the DIAG_RST.ntf.\n @retval OT_ERROR_NO_BUFS Insufficient message buffers available to send DIAG_RST.ntf.\n"]
    pub fn otThreadSendDiagnosticReset(
        aInstance: *mut otInstance,
        aDestination: *const otIp6Address,
        aTlvTypes: *const u8,
        aCount: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the vendor name string.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n\n @returns The vendor name string.\n"]
    pub fn otThreadGetVendorName(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the vendor model string.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n\n @returns The vendor model string.\n"]
    pub fn otThreadGetVendorModel(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the vendor sw version string.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n\n @returns The vendor sw version string.\n"]
    pub fn otThreadGetVendorSwVersion(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the vendor name string.\n\n Requires `OPENTHREAD_CONFIG_NET_DIAG_VENDOR_INFO_SET_API_ENABLE`.\n\n @p aVendorName should be UTF8 with max length of 32 chars (`MAX_VENDOR_NAME_TLV_LENGTH`). Maximum length does not\n include the null `\\0` character.\n\n @param[in] aInstance       A pointer to an OpenThread instance.\n @param[in] aVendorName     The vendor name string.\n\n @retval OT_ERROR_NONE          Successfully set the vendor name.\n @retval OT_ERROR_INVALID_ARGS  @p aVendorName is not valid (too long or not UTF8).\n"]
    pub fn otThreadSetVendorName(
        aInstance: *mut otInstance,
        aVendorName: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Set the vendor model string.\n\n Requires `OPENTHREAD_CONFIG_NET_DIAG_VENDOR_INFO_SET_API_ENABLE`.\n\n @p aVendorModel should be UTF8 with max length of 32 chars (`MAX_VENDOR_MODEL_TLV_LENGTH`). Maximum length does not\n include the null `\\0` character.\n\n @param[in] aInstance       A pointer to an OpenThread instance.\n @param[in] aVendorModel    The vendor model string.\n\n @retval OT_ERROR_NONE          Successfully set the vendor model.\n @retval OT_ERROR_INVALID_ARGS  @p aVendorModel is not valid (too long or not UTF8).\n"]
    pub fn otThreadSetVendorModel(
        aInstance: *mut otInstance,
        aVendorModel: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " Set the vendor software version string.\n\n Requires `OPENTHREAD_CONFIG_NET_DIAG_VENDOR_INFO_SET_API_ENABLE`.\n\n @p aVendorSwVersion should be UTF8 with max length of 16 chars(`MAX_VENDOR_SW_VERSION_TLV_LENGTH`). Maximum length\n does not include the null `\\0` character.\n\n @param[in] aInstance          A pointer to an OpenThread instance.\n @param[in] aVendorSwVersion   The vendor software version string.\n\n @retval OT_ERROR_NONE          Successfully set the vendor software version.\n @retval OT_ERROR_INVALID_ARGS  @p aVendorSwVersion is not valid (too long or not UTF8).\n"]
    pub fn otThreadSetVendorSwVersion(
        aInstance: *mut otInstance,
        aVendorSwVersion: *const ::std::os::raw::c_char,
    ) -> otError;
}
#[doc = "< The device hasn't attached to a network."]
pub const OT_NETWORK_TIME_UNSYNCHRONIZED: otNetworkTimeStatus = -1;
#[doc = "< The device hasn’t received time sync for more than two periods time."]
pub const OT_NETWORK_TIME_RESYNC_NEEDED: otNetworkTimeStatus = 0;
#[doc = "< The device network time is synchronized."]
pub const OT_NETWORK_TIME_SYNCHRONIZED: otNetworkTimeStatus = 1;
#[doc = " This enumeration represents OpenThread time synchronization status.\n"]
pub type otNetworkTimeStatus = ::std::os::raw::c_int;
#[doc = " This function pointer is called when a network time sync or status change occurs.\n"]
pub type otNetworkTimeSyncCallbackFn =
    ::std::option::Option<unsafe extern "C" fn(aCallbackContext: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Get the Thread network time.\n\n @param[in]     aInstance     The OpenThread instance structure.\n @param[in,out] aNetworkTime  The Thread network time in microseconds.\n\n @returns The time synchronization status.\n"]
    pub fn otNetworkTimeGet(
        aInstance: *mut otInstance,
        aNetworkTime: *mut u64,
    ) -> otNetworkTimeStatus;
}
extern "C" {
    #[doc = " Set the time synchronization period.\n\n This function can only be called while Thread protocols are disabled.\n\n @param[in] aInstance         The OpenThread instance structure.\n @param[in] aTimeSyncPeriod   The time synchronization period, in seconds.\n\n @retval OT_ERROR_NONE           Successfully set the time sync period.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n"]
    pub fn otNetworkTimeSetSyncPeriod(aInstance: *mut otInstance, aTimeSyncPeriod: u16) -> otError;
}
extern "C" {
    #[doc = " Get the time synchronization period.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns The time synchronization period.\n"]
    pub fn otNetworkTimeGetSyncPeriod(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Set the time synchronization XTAL accuracy threshold for Router-Capable device.\n\n This function can only be called while Thread protocols are disabled.\n\n @param[in] aInstance        The OpenThread instance structure.\n @param[in] aXTALThreshold   The XTAL accuracy threshold for Router, in PPM.\n\n @retval OT_ERROR_NONE           Successfully set the time sync period.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n"]
    pub fn otNetworkTimeSetXtalThreshold(
        aInstance: *mut otInstance,
        aXTALThreshold: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the time synchronization XTAL accuracy threshold for Router.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns The XTAL accuracy threshold for Router, in PPM.\n"]
    pub fn otNetworkTimeGetXtalThreshold(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Set a callback to be called when a network time sync or status change occurs\n\n This callback shall be called only when the network time offset jumps by\n OPENTHREAD_CONFIG_TIME_SYNC_JUMP_NOTIF_MIN_US or when the status changes.\n\n @param[in] aInstance The OpenThread instance structure.\n @param[in] aCallbackFn The callback function to be called\n @param[in] aCallbackContext The context to be passed to the callback function upon invocation\n"]
    pub fn otNetworkTimeSyncSetCallback(
        aInstance: *mut otInstance,
        aCallbackFn: otNetworkTimeSyncCallbackFn,
        aCallbackContext: *mut ::std::os::raw::c_void,
    );
}
#[doc = " This structure represents a ping reply.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otPingSenderReply {
    #[doc = "< Sender IPv6 address (address from which ping reply was received)."]
    pub mSenderAddress: otIp6Address,
    #[doc = "< Round trip time in msec."]
    pub mRoundTripTime: u16,
    #[doc = "< Data size (number of bytes) in reply (excluding IPv6 and ICMP6 headers)."]
    pub mSize: u16,
    #[doc = "< Sequence number."]
    pub mSequenceNumber: u16,
    #[doc = "< Hop limit."]
    pub mHopLimit: u8,
}
impl Default for otPingSenderReply {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents statistics of a ping request.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otPingSenderStatistics {
    #[doc = "< The number of ping requests already sent."]
    pub mSentCount: u16,
    #[doc = "< The number of ping replies received."]
    pub mReceivedCount: u16,
    #[doc = "< The total round trip time of ping requests."]
    pub mTotalRoundTripTime: u32,
    #[doc = "< The min round trip time among ping requests."]
    pub mMinRoundTripTime: u16,
    #[doc = "< The max round trip time among ping requests."]
    pub mMaxRoundTripTime: u16,
    #[doc = "< Whether this is a multicast ping request."]
    pub mIsMulticast: bool,
}
#[doc = " This function pointer type specifies the callback to notify receipt of a ping reply.\n\n @param[in] aReply      A pointer to a `otPingSenderReply` containing info about the received ping reply.\n @param[in] aContext    A pointer to application-specific context.\n"]
pub type otPingSenderReplyCallback = ::std::option::Option<
    unsafe extern "C" fn(aReply: *const otPingSenderReply, aContext: *mut ::std::os::raw::c_void),
>;
#[doc = " This function pointer type specifies the callback to report the ping statistics.\n\n @param[in] aStatistics      A pointer to a `otPingSenderStatistics` containing info about the received ping\n                             statistics.\n @param[in] aContext         A pointer to application-specific context.\n"]
pub type otPingSenderStatisticsCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aStatistics: *const otPingSenderStatistics,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " This structure represents a ping request configuration.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otPingSenderConfig {
    #[doc = "< Source address of the ping."]
    pub mSource: otIp6Address,
    #[doc = "< Destination address to ping."]
    pub mDestination: otIp6Address,
    #[doc = "< Callback function to report replies (can be NULL if not needed)."]
    pub mReplyCallback: otPingSenderReplyCallback,
    #[doc = "< Callback function to report statistics (can be NULL if not needed)."]
    pub mStatisticsCallback: otPingSenderStatisticsCallback,
    #[doc = "< A pointer to the callback application-specific context."]
    pub mCallbackContext: *mut ::std::os::raw::c_void,
    #[doc = "< Data size (# of bytes) excludes IPv6/ICMPv6 header. Zero for default."]
    pub mSize: u16,
    #[doc = "< Number of ping messages to send. Zero to use default."]
    pub mCount: u16,
    #[doc = "< Ping tx interval in milliseconds. Zero to use default."]
    pub mInterval: u32,
    #[doc = "< Time in milliseconds to wait for final reply after sending final request.\n< Zero to use default."]
    pub mTimeout: u16,
    #[doc = "< Hop limit (used if `mAllowZeroHopLimit` is false). Zero for default."]
    pub mHopLimit: u8,
    #[doc = "< Indicates whether hop limit is zero."]
    pub mAllowZeroHopLimit: bool,
}
impl Default for otPingSenderConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function starts a ping.\n\n @param[in] aInstance            A pointer to an OpenThread instance.\n @param[in] aConfig              The ping config to use.\n\n @retval OT_ERROR_NONE           The ping started successfully.\n @retval OT_ERROR_BUSY           Could not start since busy with a previous ongoing ping request.\n @retval OT_ERROR_INVALID_ARGS   The @p aConfig contains invalid parameters (e.g., ping interval is too long).\n\n"]
    pub fn otPingSenderPing(
        aInstance: *mut otInstance,
        aConfig: *const otPingSenderConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This function stops an ongoing ping.\n\n @param[in] aInstance            A pointer to an OpenThread instance.\n"]
    pub fn otPingSenderStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Set the alarm to fire at @p aDt microseconds after @p aT0.\n\n For @p aT0, the platform MUST support all values in [0, 2^32-1].\n For @p aDt, the platform MUST support all values in [0, 2^31-1].\n\n @param[in]  aInstance  The OpenThread instance structure.\n @param[in]  aT0        The reference time.\n @param[in]  aDt        The time delay in microseconds from @p aT0.\n"]
    pub fn otPlatAlarmMicroStartAt(aInstance: *mut otInstance, aT0: u32, aDt: u32);
}
extern "C" {
    #[doc = " Stop the alarm.\n\n @param[in] aInstance  The OpenThread instance structure.\n"]
    pub fn otPlatAlarmMicroStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the current time.\n\n The current time MUST represent a free-running timer. When maintaining current time, the time value MUST utilize the\n entire range [0, 2^32-1] and MUST NOT wrap before 2^32.\n\n @returns  The current time in microseconds.\n"]
    pub fn otPlatAlarmMicroGetNow() -> u32;
}
extern "C" {
    #[doc = " Signal that the alarm has fired.\n\n @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatAlarmMicroFired(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Set the alarm to fire at @p aDt milliseconds after @p aT0.\n\n For @p aT0 the platform MUST support all values in [0, 2^32-1].\n For @p aDt, the platform MUST support all values in [0, 2^31-1].\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aT0        The reference time.\n @param[in] aDt        The time delay in milliseconds from @p aT0."]
    pub fn otPlatAlarmMilliStartAt(aInstance: *mut otInstance, aT0: u32, aDt: u32);
}
extern "C" {
    #[doc = " Stop the alarm.\n\n @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatAlarmMilliStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Get the current time.\n\n The current time MUST represent a free-running timer. When maintaining current time, the time value MUST utilize the\n entire range [0, 2^32-1] and MUST NOT wrap before 2^32.\n\n @returns The current time in milliseconds."]
    pub fn otPlatAlarmMilliGetNow() -> u32;
}
extern "C" {
    #[doc = " Signal that the alarm has fired.\n\n @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatAlarmMilliFired(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Signal diagnostics module that the alarm has fired.\n\n @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatDiagAlarmFired(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Standard printf() to the debug uart with no log decoration.\n\n @param[in]   fmt   printf formatter text\n\n This is a debug convenience function that is not intended to be\n used in anything other then \"debug scenarios\" by a developer.\n\n lf -> cr/lf mapping is automatically handled via otPlatDebugUart_putchar()\n\n @sa otPlatDebugUart_vprintf() for limitations\n\n This is a WEAK symbol that can easily be overridden as needed."]
    pub fn otPlatDebugUart_printf(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Standard vprintf() to the debug uart, with no log decoration.\n\n @param[in]   fmt   printf formatter text\n @param[in]   ap    va_list value for print parameters.\n\n Implementation limitation: this formats the text into\n a purposely small text buffer on the stack, thus long\n messages may be truncated.\n\n This is a WEAK symbol that can easily be overridden as needed.\n\n For example, some platforms might override this via a non-WEAK\n symbol because the platform provides a UART_vprintf() like\n function that can handle an arbitrary length output."]
    pub fn otPlatDebugUart_vprintf(fmt: *const ::std::os::raw::c_char, ap: *mut __va_list_tag);
}
extern "C" {
    #[doc = " Platform specific write single byte to Debug Uart\n This should not perform CR/LF mapping.\n\n This function MUST be implemented by the platform\n\n @param[in] c   what to transmit"]
    pub fn otPlatDebugUart_putchar_raw(c: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Poll/test debug uart if a key has been pressed.\n It would be common to a stub function that returns 0.\n\n This function MUST be implemented by the platform\n\n @retval zero - nothing ready\n @retval nonzero - otPlatDebugUart_getc() will succeed."]
    pub fn otPlatDebugUart_kbhit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll/Read a byte from the debug uart\n\n This function MUST be implemented by the platform\n\n @retval (negative) no data available, see otPlatDebugUart_kbhit()\n @retval (0x00..0x0ff) data byte value\n"]
    pub fn otPlatDebugUart_getc() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write byte to the uart, expand cr/lf as need.\n\n A WEAK default implementation is provided\n that can be overridden as needed.\n\n @param[in] c   the byte to transmit"]
    pub fn otPlatDebugUart_putchar(c: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " identical to \"man 3 puts\" - terminates with lf\n Which is then mapped to cr/lf as required\n\n A WEAK default implementation is provided\n that can be overridden as needed.\n\n @param[in]   s   the string to print with a lf at the end"]
    pub fn otPlatDebugUart_puts(s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Write N bytes to the UART, mapping cr/lf\n\n @param[in]  pBytes   pointer to bytes to transmit.\n @param[in]  nBytes   how many bytes to transmit."]
    pub fn otPlatDebugUart_write_bytes(pBytes: *const u8, nBytes: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " puts() without a terminal newline.\n see: \"man 3 puts\", without a adding a terminal lf\n\n @param[in]  s       the string to print without a lf at the end\n\n Note, the terminal \"lf\" mapped to cr/lf via\n the function otPlatDebugUart_putchar()"]
    pub fn otPlatDebugUart_puts_no_nl(s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Some platforms (simulation) can log to a file.\n\n @returns OT_ERROR_NONE\n @returns OT_ERROR_FAILED\n\n Platforms that desire this MUST provide an implementation.\n"]
    pub fn otPlatDebugUart_logfile(filename: *const ::std::os::raw::c_char) -> otError;
}
#[doc = "< Input mode without pull resistor."]
pub const OT_GPIO_MODE_INPUT: otGpioMode = 0;
#[doc = "< Output mode."]
pub const OT_GPIO_MODE_OUTPUT: otGpioMode = 1;
#[doc = " This enumeration defines the gpio modes.\n"]
pub type otGpioMode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function processes a factory diagnostics command line.\n\n The output of this function (the content written to @p aOutput) MUST terminate with `\\0` and the `\\0` is within the\n output buffer.\n\n @param[in]   aInstance       The OpenThread instance for current request.\n @param[in]   aArgsLength     The number of arguments in @p aArgs.\n @param[in]   aArgs           The arguments of diagnostics command line.\n @param[out]  aOutput         The diagnostics execution result.\n @param[in]   aOutputMaxLen   The output buffer size.\n\n @retval  OT_ERROR_INVALID_ARGS       The command is supported but invalid arguments provided.\n @retval  OT_ERROR_NONE               The command is successfully process.\n @retval  OT_ERROR_INVALID_COMMAND    The command is not valid or not supported.\n"]
    pub fn otPlatDiagProcess(
        aInstance: *mut otInstance,
        aArgsLength: u8,
        aArgs: *mut *mut ::std::os::raw::c_char,
        aOutput: *mut ::std::os::raw::c_char,
        aOutputMaxLen: usize,
    ) -> otError;
}
extern "C" {
    #[doc = " This function enables/disables the factory diagnostics mode.\n\n @param[in]  aMode  TRUE to enable diagnostics mode, FALSE otherwise.\n"]
    pub fn otPlatDiagModeSet(aMode: bool);
}
extern "C" {
    #[doc = " This function indicates whether or not factory diagnostics mode is enabled.\n\n @returns TRUE if factory diagnostics mode is enabled, FALSE otherwise.\n"]
    pub fn otPlatDiagModeGet() -> bool;
}
extern "C" {
    #[doc = " This function sets the channel to use for factory diagnostics.\n\n @param[in]  aChannel  The channel value.\n"]
    pub fn otPlatDiagChannelSet(aChannel: u8);
}
extern "C" {
    #[doc = " This function sets the transmit power to use for factory diagnostics.\n\n @param[in]  aTxPower  The transmit power value.\n"]
    pub fn otPlatDiagTxPowerSet(aTxPower: i8);
}
extern "C" {
    #[doc = " This function processes the received radio frame.\n\n @param[in]   aInstance   The OpenThread instance for current request.\n @param[in]   aFrame      The received radio frame.\n @param[in]   aError      The received radio frame status.\n"]
    pub fn otPlatDiagRadioReceived(
        aInstance: *mut otInstance,
        aFrame: *mut otRadioFrame,
        aError: otError,
    );
}
extern "C" {
    #[doc = " This function processes the alarm event.\n\n @param[in]   aInstance   The OpenThread instance for current request.\n"]
    pub fn otPlatDiagAlarmCallback(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function sets the gpio value.\n\n @param[in]  aGpio   The gpio number.\n @param[in]  aValue  true to set the gpio to high level, or false otherwise.\n\n @retval OT_ERROR_NONE             Successfully set the gpio.\n @retval OT_ERROR_FAILED           A platform error occurred while setting the gpio.\n @retval OT_ERROR_INVALID_ARGS     @p aGpio is not supported.\n @retval OT_ERROR_INVALID_STATE    Diagnostic mode was not enabled or @p aGpio is not configured as output.\n @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented or configured on the platform.\n"]
    pub fn otPlatDiagGpioSet(aGpio: u32, aValue: bool) -> otError;
}
extern "C" {
    #[doc = " This function gets the gpio value.\n\n @param[in]   aGpio   The gpio number.\n @param[out]  aValue  A pointer where to put gpio value.\n\n @retval OT_ERROR_NONE             Successfully got the gpio value.\n @retval OT_ERROR_FAILED           A platform error occurred while getting the gpio value.\n @retval OT_ERROR_INVALID_ARGS     @p aGpio is not supported or @p aValue is NULL.\n @retval OT_ERROR_INVALID_STATE    Diagnostic mode was not enabled or @p aGpio is not configured as input.\n @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented or configured on the platform.\n"]
    pub fn otPlatDiagGpioGet(aGpio: u32, aValue: *mut bool) -> otError;
}
extern "C" {
    #[doc = " This function sets the gpio mode.\n\n @param[in]   aGpio   The gpio number.\n @param[out]  aMode   The gpio mode.\n\n @retval OT_ERROR_NONE             Successfully set the gpio mode.\n @retval OT_ERROR_FAILED           A platform error occurred while setting the gpio mode.\n @retval OT_ERROR_INVALID_ARGS     @p aGpio or @p aMode is not supported.\n @retval OT_ERROR_INVALID_STATE    Diagnostic mode was not enabled.\n @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented or configured on the platform.\n"]
    pub fn otPlatDiagGpioSetMode(aGpio: u32, aMode: otGpioMode) -> otError;
}
extern "C" {
    #[doc = " This function gets the gpio mode.\n\n @param[in]   aGpio   The gpio number.\n @param[out]  aMode   A pointer where to put gpio mode.\n\n @retval OT_ERROR_NONE             Successfully got the gpio mode.\n @retval OT_ERROR_FAILED           Mode returned by the platform is not implemented in OpenThread or a platform error\n                                   occurred while getting the gpio mode.\n @retval OT_ERROR_INVALID_ARGS     @p aGpio is not supported or @p aMode is NULL.\n @retval OT_ERROR_INVALID_STATE    Diagnostic mode was not enabled.\n @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented or configured on the platform.\n"]
    pub fn otPlatDiagGpioGetMode(aGpio: u32, aMode: *mut otGpioMode) -> otError;
}
extern "C" {
    #[doc = " Set the radio raw power setting for diagnostics module.\n\n @param[in] aInstance               The OpenThread instance structure.\n @param[in] aRawPowerSetting        A pointer to the raw power setting byte array.\n @param[in] aRawPowerSettingLength  The length of the @p aRawPowerSetting.\n\n @retval OT_ERROR_NONE             Successfully set the raw power setting.\n @retval OT_ERROR_INVALID_ARGS     The @p aRawPowerSetting is NULL or the @p aRawPowerSettingLength is too long.\n @retval OT_ERROR_NOT_IMPLEMENTED  This method is not implemented.\n"]
    pub fn otPlatDiagRadioSetRawPowerSetting(
        aInstance: *mut otInstance,
        aRawPowerSetting: *const u8,
        aRawPowerSettingLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the radio raw power setting for diagnostics module.\n\n @param[in]      aInstance               The OpenThread instance structure.\n @param[out]     aRawPowerSetting        A pointer to the raw power setting byte array.\n @param[in,out]  aRawPowerSettingLength  On input, a pointer to the size of @p aRawPowerSetting.\n                                         On output, a pointer to the length of the raw power setting data.\n\n @retval OT_ERROR_NONE             Successfully set the raw power setting.\n @retval OT_ERROR_INVALID_ARGS     The @p aRawPowerSetting or @p aRawPowerSettingLength is NULL or\n                                   @aRawPowerSettingLength is too short.\n @retval OT_ERROR_NOT_FOUND        The raw power setting is not set.\n @retval OT_ERROR_NOT_IMPLEMENTED  This method is not implemented.\n"]
    pub fn otPlatDiagRadioGetRawPowerSetting(
        aInstance: *mut otInstance,
        aRawPowerSetting: *mut u8,
        aRawPowerSettingLength: *mut u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Enable/disable the platform layer to use the raw power setting set by `otPlatDiagRadioSetRawPowerSetting()`.\n\n @param[in]  aInstance The OpenThread instance structure.\n @param[in]  aEnable   TRUE to enable or FALSE to disable the raw power setting.\n\n @retval OT_ERROR_NONE             Successfully enabled/disabled the raw power setting.\n @retval OT_ERROR_NOT_IMPLEMENTED  This method is not implemented.\n"]
    pub fn otPlatDiagRadioRawPowerSettingEnable(
        aInstance: *mut otInstance,
        aEnable: bool,
    ) -> otError;
}
extern "C" {
    #[doc = " Start/stop the platform layer to transmit continuous carrier wave.\n\n @param[in]  aInstance The OpenThread instance structure.\n @param[in]  aEnable   TRUE to enable or FALSE to disable the platform layer to transmit continuous carrier wave.\n\n @retval OT_ERROR_NONE             Successfully enabled/disabled .\n @retval OT_ERROR_INVALID_STATE    The radio was not in the Receive state.\n @retval OT_ERROR_NOT_IMPLEMENTED  This method is not implemented.\n"]
    pub fn otPlatDiagRadioTransmitCarrier(aInstance: *mut otInstance, aEnable: bool) -> otError;
}
extern "C" {
    #[doc = " Start/stop the platform layer to transmit stream of characters.\n\n @param[in]  aInstance The OpenThread instance structure.\n @param[in]  aEnable   TRUE to enable or FALSE to disable the platform layer to transmit stream.\n\n @retval OT_ERROR_NONE             Successfully enabled/disabled.\n @retval OT_ERROR_INVALID_STATE    The radio was not in the Receive state.\n @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented.\n"]
    pub fn otPlatDiagRadioTransmitStream(aInstance: *mut otInstance, aEnable: bool) -> otError;
}
extern "C" {
    #[doc = " Get the power settings for the given channel.\n\n @param[in]      aInstance               The OpenThread instance structure.\n @param[in]      aChannel                The radio channel.\n @param[out]     aTargetPower            The target power in 0.01 dBm.\n @param[out]     aActualPower            The actual power in 0.01 dBm.\n @param[out]     aRawPowerSetting        A pointer to the raw power setting byte array.\n @param[in,out]  aRawPowerSettingLength  On input, a pointer to the size of @p aRawPowerSetting.\n                                         On output, a pointer to the length of the raw power setting data.\n\n @retval  OT_ERROR_NONE             Successfully got the target power.\n @retval  OT_ERROR_INVALID_ARGS     The @p aChannel is invalid, @aTargetPower, @p aActualPower, @p aRawPowerSetting or\n                                    @p aRawPowerSettingLength is NULL or @aRawPowerSettingLength is too short.\n @retval  OT_ERROR_NOT_FOUND        The power settings for the @p aChannel was not found.\n @retval  OT_ERROR_NOT_IMPLEMENTED  This method is not implemented.\n"]
    pub fn otPlatDiagRadioGetPowerSettings(
        aInstance: *mut otInstance,
        aChannel: u8,
        aTargetPower: *mut i16,
        aActualPower: *mut i16,
        aRawPowerSetting: *mut u8,
        aRawPowerSettingLength: *mut u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Fill buffer with entropy.\n\n This function MUST be implemented using a true random number generator (TRNG).\n\n @param[out]  aOutput              A pointer to where the true random values are placed.  Must not be NULL.\n @param[in]   aOutputLength        Size of @p aBuffer.\n\n @retval OT_ERROR_NONE          Successfully filled @p aBuffer with true random values.\n @retval OT_ERROR_FAILED        Failed to fill @p aBuffer with true random values.\n @retval OT_ERROR_INVALID_ARGS  @p aBuffer was set to NULL.\n"]
    pub fn otPlatEntropyGet(aOutput: *mut u8, aOutputLength: u16) -> otError;
}
extern "C" {
    #[doc = " This function initializes the flash driver.\n\n @param[in] aInstance  The OpenThread instance structure.\n"]
    pub fn otPlatFlashInit(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function gets the size of the swap space.\n\n @param[in] aInstance  The OpenThread instance structure.\n\n @returns The size of the swap space in bytes.\n"]
    pub fn otPlatFlashGetSwapSize(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " This function erases the swap space indicated by @p aSwapIndex.\n\n @param[in] aInstance   The OpenThread instance structure.\n @param[in] aSwapIndex  A value in [0, 1] that indicates the swap space.\n"]
    pub fn otPlatFlashErase(aInstance: *mut otInstance, aSwapIndex: u8);
}
extern "C" {
    #[doc = " This function reads @p aSize bytes into @p aData.\n\n @param[in]  aInstance   The OpenThread instance structure.\n @param[in]  aSwapIndex  A value in [0, 1] that indicates the swap space.\n @param[in]  aOffset     A byte offset within the swap space.\n @param[out] aData       A pointer to the data buffer for reading.\n @param[in]  aSize       Number of bytes to read.\n"]
    pub fn otPlatFlashRead(
        aInstance: *mut otInstance,
        aSwapIndex: u8,
        aOffset: u32,
        aData: *mut ::std::os::raw::c_void,
        aSize: u32,
    );
}
extern "C" {
    #[doc = " This function writes @p aSize bytes from @p aData.\n\n @param[in]  aInstance   The OpenThread instance structure.\n @param[in]  aSwapIndex  A value in [0, 1] that indicates the swap space.\n @param[in]  aOffset     A byte offset within the swap space.\n @param[out] aData       A pointer to the data to write.\n @param[in]  aSize       Number of bytes to write.\n\n"]
    pub fn otPlatFlashWrite(
        aInstance: *mut otInstance,
        aSwapIndex: u8,
        aOffset: u32,
        aData: *const ::std::os::raw::c_void,
        aSize: u32,
    );
}
extern "C" {
    #[doc = " This method tells whether an infra interface has the given IPv6 address assigned.\n\n @param[in]  aInfraIfIndex  The index of the infra interface.\n @param[in]  aAddress       The IPv6 address.\n\n @returns  TRUE if the infra interface has given IPv6 address assigned, FALSE otherwise.\n"]
    pub fn otPlatInfraIfHasAddress(aInfraIfIndex: u32, aAddress: *const otIp6Address) -> bool;
}
extern "C" {
    #[doc = " This method sends an ICMPv6 Neighbor Discovery message on given infrastructure interface.\n\n See RFC 4861: https://tools.ietf.org/html/rfc4861.\n\n @param[in]  aInfraIfIndex  The index of the infrastructure interface this message is sent to.\n @param[in]  aDestAddress   The destination address this message is sent to.\n @param[in]  aBuffer        The ICMPv6 message buffer. The ICMPv6 checksum is left zero and the\n                            platform should do the checksum calculate.\n @param[in]  aBufferLength  The length of the message buffer.\n\n @note  Per RFC 4861, the implementation should send the message with IPv6 link-local source address\n        of interface @p aInfraIfIndex and IP Hop Limit 255.\n\n @retval OT_ERROR_NONE    Successfully sent the ICMPv6 message.\n @retval OT_ERROR_FAILED  Failed to send the ICMPv6 message.\n"]
    pub fn otPlatInfraIfSendIcmp6Nd(
        aInfraIfIndex: u32,
        aDestAddress: *const otIp6Address,
        aBuffer: *const u8,
        aBufferLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " The infra interface driver calls this method to notify OpenThread\n that an ICMPv6 Neighbor Discovery message is received.\n\n See RFC 4861: https://tools.ietf.org/html/rfc4861.\n\n @param[in]  aInstance      The OpenThread instance structure.\n @param[in]  aInfraIfIndex  The index of the infrastructure interface on which the ICMPv6 message is received.\n @param[in]  aSrcAddress    The source address this message is received from.\n @param[in]  aBuffer        The ICMPv6 message buffer.\n @param[in]  aBufferLength  The length of the ICMPv6 message buffer.\n\n @note  Per RFC 4861, the caller should enforce that the source address MUST be a IPv6 link-local\n        address and the IP Hop Limit MUST be 255.\n"]
    pub fn otPlatInfraIfRecvIcmp6Nd(
        aInstance: *mut otInstance,
        aInfraIfIndex: u32,
        aSrcAddress: *const otIp6Address,
        aBuffer: *const u8,
        aBufferLength: u16,
    );
}
extern "C" {
    #[doc = " The infra interface driver calls this method to notify OpenThread\n of the interface state changes.\n\n It is fine for the platform to call to method even when the running state\n of the interface hasn't changed. In this case, the Routing Manager state is\n not affected.\n\n @param[in]  aInstance          The OpenThread instance structure.\n @param[in]  aInfraIfIndex      The index of the infrastructure interface.\n @param[in]  aIsRunning         A boolean that indicates whether the infrastructure\n                                interface is running.\n\n @retval  OT_ERROR_NONE           Successfully updated the infra interface status.\n @retval  OT_ERROR_INVALID_STATE  The Routing Manager is not initialized.\n @retval  OT_ERROR_INVALID_ARGS   The @p aInfraIfIndex doesn't match the infra interface the\n                                  Routing Manager are initialized with.\n"]
    pub fn otPlatInfraIfStateChanged(
        aInstance: *mut otInstance,
        aInfraIfIndex: u32,
        aIsRunning: bool,
    ) -> otError;
}
extern "C" {
    #[doc = " Send a request to discover the NAT64 prefix on the infrastructure interface with @p aInfraIfIndex.\n\n OpenThread will call this method periodically to monitor the presence or change of NAT64 prefix.\n\n @param[in]  aInfraIfIndex  The index of the infrastructure interface to discover the NAT64 prefix.\n\n @retval  OT_ERROR_NONE    Successfully request NAT64 prefix discovery.\n @retval  OT_ERROR_FAILED  Failed to request NAT64 prefix discovery.\n"]
    pub fn otPlatInfraIfDiscoverNat64Prefix(aInfraIfIndex: u32) -> otError;
}
extern "C" {
    #[doc = " The infra interface driver calls this method to notify OpenThread that\n the discovery of NAT64 prefix is done.\n\n This method is expected to be invoked after calling otPlatInfraIfDiscoverNat64Prefix.\n If no NAT64 prefix is discovered, @p aIp6Prefix shall point to an empty prefix with zero length.\n\n @param[in]  aInstance      The OpenThread instance structure.\n @param[in]  aInfraIfIndex  The index of the infrastructure interface on which the NAT64 prefix is discovered.\n @param[in]  aIp6Prefix     A pointer to NAT64 prefix.\n"]
    pub fn otPlatInfraIfDiscoverNat64PrefixDone(
        aInstance: *mut otInstance,
        aInfraIfIndex: u32,
        aIp6Prefix: *const otIp6Prefix,
    );
}
extern "C" {
    #[doc = " Dynamically allocates new memory. On platforms that support it, should just redirect to calloc. For\n those that don't support calloc, should support the same functionality:\n\n   \"The calloc() function contiguously allocates enough space for count objects that are size bytes of\n   memory each and returns a pointer to the allocated memory. The allocated memory is filled with bytes\n   of value zero.\"\n\n This function is required for OPENTHREAD_CONFIG_HEAP_EXTERNAL_ENABLE.\n\n @param[in] aNum   The number of blocks to allocate\n @param[in] aSize  The size of each block to allocate\n\n @retval void*  The pointer to the front of the memory allocated\n @retval NULL   Failed to allocate the memory requested."]
    pub fn otPlatCAlloc(aNum: usize, aSize: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Frees memory that was dynamically allocated.\n\n This function is required for OPENTHREAD_CONFIG_HEAP_EXTERNAL_ENABLE.\n\n @param[in] aPtr  A pointer the memory blocks to free. The pointer may be NULL."]
    pub fn otPlatFree(aPtr: *mut ::std::os::raw::c_void);
}
#[doc = " This struct represents an OpenThread message buffer.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otMessageBuffer {
    #[doc = "< Pointer to the next buffer."]
    pub mNext: *mut otMessageBuffer,
}
impl Default for otMessageBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Initialize the platform implemented message pool.\n\n This function is used when `OPENTHREAD_CONFIG_PLATFORM_MESSAGE_MANAGEMENT` is enabled.\n\n @param[in] aInstance            A pointer to the OpenThread instance.\n @param[in] aMinNumFreeBuffers   An uint16 containing the minimum number of free buffers desired by OpenThread.\n @param[in] aBufferSize          The size in bytes of a buffer object.\n"]
    pub fn otPlatMessagePoolInit(
        aInstance: *mut otInstance,
        aMinNumFreeBuffers: u16,
        aBufferSize: usize,
    );
}
extern "C" {
    #[doc = " Allocate a buffer from the platform managed buffer pool.\n\n This function is used when `OPENTHREAD_CONFIG_PLATFORM_MESSAGE_MANAGEMENT` is enabled.\n\n The returned buffer instance MUST have at least `aBufferSize` bytes (as specified in `otPlatMessagePoolInit()`).\n\n @param[in] aInstance            A pointer to the OpenThread instance.\n\n @returns A pointer to the buffer or NULL if no buffers are available.\n"]
    pub fn otPlatMessagePoolNew(aInstance: *mut otInstance) -> *mut otMessageBuffer;
}
extern "C" {
    #[doc = " This function is used to free a buffer back to the platform managed buffer pool.\n\n This function is used when `OPENTHREAD_CONFIG_PLATFORM_MESSAGE_MANAGEMENT` is enabled.\n\n @param[in]  aInstance  A pointer to the OpenThread instance.\n @param[in]  aBuffer    The buffer to free.\n"]
    pub fn otPlatMessagePoolFree(aInstance: *mut otInstance, aBuffer: *mut otMessageBuffer);
}
extern "C" {
    #[doc = " Get the number of free buffers.\n\n This function is used when `OPENTHREAD_CONFIG_PLATFORM_MESSAGE_MANAGEMENT` is enabled.\n\n @param[in]  aInstance  A pointer to the OpenThread instance.\n\n @returns The number of buffers currently free and available to OpenThread.\n"]
    pub fn otPlatMessagePoolNumFreeBuffers(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " This function performs a software reset on the platform, if supported.\n\n @param[in] aInstance  The OpenThread instance structure.\n"]
    pub fn otPlatReset(aInstance: *mut otInstance);
}
pub const OT_PLAT_RESET_REASON_POWER_ON: otPlatResetReason = 0;
pub const OT_PLAT_RESET_REASON_EXTERNAL: otPlatResetReason = 1;
pub const OT_PLAT_RESET_REASON_SOFTWARE: otPlatResetReason = 2;
pub const OT_PLAT_RESET_REASON_FAULT: otPlatResetReason = 3;
pub const OT_PLAT_RESET_REASON_CRASH: otPlatResetReason = 4;
pub const OT_PLAT_RESET_REASON_ASSERT: otPlatResetReason = 5;
pub const OT_PLAT_RESET_REASON_OTHER: otPlatResetReason = 6;
pub const OT_PLAT_RESET_REASON_UNKNOWN: otPlatResetReason = 7;
pub const OT_PLAT_RESET_REASON_WATCHDOG: otPlatResetReason = 8;
pub const OT_PLAT_RESET_REASON_COUNT: otPlatResetReason = 9;
#[doc = " Enumeration of possible reset reason codes.\n\n These are in the same order as the Spinel reset reason codes.\n"]
pub type otPlatResetReason = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function returns the reason for the last platform reset.\n\n @param[in] aInstance  The OpenThread instance structure.\n"]
    pub fn otPlatGetResetReason(aInstance: *mut otInstance) -> otPlatResetReason;
}
extern "C" {
    #[doc = " This function provides a platform specific implementation for assert.\n\n @param[in] aFilename    The name of the file where the assert occurred.\n @param[in] aLineNumber  The line number in the file where the assert occurred.\n"]
    pub fn otPlatAssertFail(
        aFilename: *const ::std::os::raw::c_char,
        aLineNumber: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " This function performs a platform specific operation to wake the host MCU.\n This is used only for NCP configurations.\n"]
    pub fn otPlatWakeHost();
}
#[doc = " NCP's MCU stays on and active all the time.\n\n When the NCP's desired power state is set to `ON`, host can send messages to NCP without requiring any \"poke\" or\n external triggers.\n\n @note The `ON` power state only determines the MCU's power mode and is not related to radio's state.\n"]
pub const OT_PLAT_MCU_POWER_STATE_ON: otPlatMcuPowerState = 0;
#[doc = " NCP's MCU can enter low-power (energy-saving) state.\n\n When the NCP's desired power state is set to `LOW_POWER`, host is expected to \"poke\" the NCP (e.g., an external\n trigger like an interrupt) before it can communicate with the NCP (send a message to the NCP). The \"poke\"\n mechanism is determined by the platform code (based on NCP's interface to the host).\n\n While power state is set to `LOW_POWER`, NCP can still (at any time) send messages to host. Note that receiving\n a message from the NCP does NOT indicate that the NCP's power state has changed, i.e., host is expected to\n continue to \"poke\" when it wants to talk to the NCP until the power state is explicitly changed (by a successful\n call to `otPlatSetMcuPowerState()` changing the state to `ON`).\n\n @note The `LOW_POWER` power state only determines the MCU's power mode and is not related to radio's state\n (radio is managed by OpenThread core and device role, e.g., device being sleepy or not.\n"]
pub const OT_PLAT_MCU_POWER_STATE_LOW_POWER: otPlatMcuPowerState = 1;
#[doc = " NCP is fully off.\n\n An NCP hardware reset (via a RESET pin) is required to bring the NCP back to `SPINEL_MCU_POWER_STATE_ON`.\n RAM is not retained after reset.\n"]
pub const OT_PLAT_MCU_POWER_STATE_OFF: otPlatMcuPowerState = 2;
#[doc = " Enumeration of micro-controller's power states.\n\n These values are used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL` is enabled.\n\n The power state specifies the desired power state of NCP's micro-controller (MCU) when the underlying platform's\n operating system enters idle mode (i.e., all active tasks/events are processed and the MCU can potentially enter a\n energy-saving power state).\n\n The power state primarily determines how the host should interact with the NCP and whether the host needs an\n external trigger (a \"poke\") to NCP before it can communicate with the NCP or not.\n\n After a reset, the MCU power state MUST be `OT_PLAT_POWER_STATE_ON`.\n"]
pub type otPlatMcuPowerState = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function sets the desired MCU power state.\n\n This is only applicable and used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL`\n is enabled.\n\n @param[in] aInstance      A pointer to OpenThread instance.\n @param[in] aState         The new MCU power state.\n\n @retval OT_ERROR_NONE     The power state updated successfully.\n @retval OT_ERROR_FAILED   The given MCU power state is not supported by the platform.\n"]
    pub fn otPlatSetMcuPowerState(
        aInstance: *mut otInstance,
        aState: otPlatMcuPowerState,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the current desired MCU power state.\n\n This is only applicable and used for NCP configuration when `OPENTHREAD_CONFIG_NCP_ENABLE_MCU_POWER_STATE_CONTROL`\n is enabled.\n\n After a reset, the power state MUST return `OT_PLAT_POWER_STATE_ON`. During operation, power state SHOULD only\n change through an explicit successful call to `otPlatSetMcuPowerState()`.\n\n @param[in] aInstance  A pointer to OpenThread instance.\n\n @returns The current power state.\n"]
    pub fn otPlatGetMcuPowerState(aInstance: *mut otInstance) -> otPlatMcuPowerState;
}
extern "C" {
    #[doc = " This function exports status information to OTNS.\n\n The status information is represented by a null-terminated string with format recognizable by OTNS.\n Each call to `otPlatOtnsStatus` can send multiple statuses, separated by ';', e.x. \"parid=577fbc37;lrid=5\".\n Each status contains key and value separated by '='.\n Status value can be further separated into multiple fields using ',',\n e.x. \"ping_request=fdde:ad00:beef:0:459e:d7b4:b65e:5480,4,112000\".\n\n New statuses should follow these conventions.\n\n Currently, OTNS only supports virtual time simulation.\n\n @param[in]  aStatus  The status string.\n"]
    pub fn otPlatOtnsStatus(aStatus: *const ::std::os::raw::c_char);
}
#[doc = "< Active Operational Dataset."]
pub const OT_SETTINGS_KEY_ACTIVE_DATASET: _bindgen_ty_12 = 1;
#[doc = "< Pending Operational Dataset."]
pub const OT_SETTINGS_KEY_PENDING_DATASET: _bindgen_ty_12 = 2;
#[doc = "< Thread network information."]
pub const OT_SETTINGS_KEY_NETWORK_INFO: _bindgen_ty_12 = 3;
#[doc = "< Parent information."]
pub const OT_SETTINGS_KEY_PARENT_INFO: _bindgen_ty_12 = 4;
#[doc = "< Child information."]
pub const OT_SETTINGS_KEY_CHILD_INFO: _bindgen_ty_12 = 5;
#[doc = "< SLAAC key to generate semantically opaque IID."]
pub const OT_SETTINGS_KEY_SLAAC_IID_SECRET_KEY: _bindgen_ty_12 = 7;
#[doc = "< Duplicate Address Detection (DAD) information."]
pub const OT_SETTINGS_KEY_DAD_INFO: _bindgen_ty_12 = 8;
#[doc = "< SRP client ECDSA public/private key pair."]
pub const OT_SETTINGS_KEY_SRP_ECDSA_KEY: _bindgen_ty_12 = 11;
#[doc = "< The SRP client info (selected SRP server address)."]
pub const OT_SETTINGS_KEY_SRP_CLIENT_INFO: _bindgen_ty_12 = 12;
#[doc = "< The SRP server info (UDP port)."]
pub const OT_SETTINGS_KEY_SRP_SERVER_INFO: _bindgen_ty_12 = 13;
#[doc = "< BR ULA prefix."]
pub const OT_SETTINGS_KEY_BR_ULA_PREFIX: _bindgen_ty_12 = 15;
#[doc = "< BR local on-link prefixes."]
pub const OT_SETTINGS_KEY_BR_ON_LINK_PREFIXES: _bindgen_ty_12 = 16;
#[doc = "< Unique Border Agent/Router ID."]
pub const OT_SETTINGS_KEY_BORDER_AGENT_ID: _bindgen_ty_12 = 17;
pub const OT_SETTINGS_KEY_VENDOR_RESERVED_MIN: _bindgen_ty_12 = 32768;
pub const OT_SETTINGS_KEY_VENDOR_RESERVED_MAX: _bindgen_ty_12 = 65535;
#[doc = " This enumeration defines the keys of settings.\n\n Note: When adding a new settings key, if the settings corresponding to the key contains security sensitive\n       information, the developer MUST add the key to the array `aSensitiveKeys` which is passed in\n       `otPlatSettingsInit()`.\n"]
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Performs any initialization for the settings subsystem, if necessary.\n\n This function also sets the sensitive keys that should be stored in the secure area.\n\n Note that the memory pointed by @p aSensitiveKeys MUST not be released before @p aInstance is destroyed.\n\n @param[in]  aInstance             The OpenThread instance structure.\n @param[in]  aSensitiveKeys        A pointer to an array containing the list of sensitive keys. May be NULL only if\n                                   @p aSensitiveKeysLength is 0, which means that there is no sensitive keys.\n @param[in]  aSensitiveKeysLength  The number of entries in the @p aSensitiveKeys array.\n"]
    pub fn otPlatSettingsInit(
        aInstance: *mut otInstance,
        aSensitiveKeys: *const u16,
        aSensitiveKeysLength: u16,
    );
}
extern "C" {
    #[doc = " Performs any de-initialization for the settings subsystem, if necessary.\n\n @param[in]  aInstance The OpenThread instance structure.\n"]
    pub fn otPlatSettingsDeinit(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Fetches the value of a setting.\n\n This function fetches the value of the setting identified\n by @p aKey and write it to the memory pointed to by aValue.\n It then writes the length to the integer pointed to by\n @p aValueLength. The initial value of @p aValueLength is the\n maximum number of bytes to be written to @p aValue.\n\n This function can be used to check for the existence of\n a key without fetching the value by setting @p aValue and\n @p aValueLength to NULL. You can also check the length of\n the setting without fetching it by setting only aValue\n to NULL.\n\n Note that the underlying storage implementation is not\n required to maintain the order of settings with multiple\n values. The order of such values MAY change after ANY\n write operation to the store.\n\n @param[in]      aInstance     The OpenThread instance structure.\n @param[in]      aKey          The key associated with the requested setting.\n @param[in]      aIndex        The index of the specific item to get.\n @param[out]     aValue        A pointer to where the value of the setting should be written. May be set to NULL if\n                               just testing for the presence or length of a setting.\n @param[in,out]  aValueLength  A pointer to the length of the value. When called, this pointer should point to an\n                               integer containing the maximum value size that can be written to @p aValue. At return,\n                               the actual length of the setting is written. This may be set to NULL if performing\n                               a presence check.\n\n @retval OT_ERROR_NONE             The given setting was found and fetched successfully.\n @retval OT_ERROR_NOT_FOUND        The given setting was not found in the setting store.\n @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform."]
    pub fn otPlatSettingsGet(
        aInstance: *mut otInstance,
        aKey: u16,
        aIndex: ::std::os::raw::c_int,
        aValue: *mut u8,
        aValueLength: *mut u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Sets or replaces the value of a setting.\n\n This function sets or replaces the value of a setting\n identified by @p aKey.\n\n Calling this function successfully may cause unrelated\n settings with multiple values to be reordered.\n\n OpenThread stack guarantees to use `otPlatSettingsSet()`\n method for a @p aKey that was either previously set using\n `otPlatSettingsSet()` (i.e., contains a single value) or\n is empty and/or fully deleted (contains no value).\n\n Platform layer can rely and use this fact for optimizing\n its implementation.\n\n @param[in]  aInstance     The OpenThread instance structure.\n @param[in]  aKey          The key associated with the setting to change.\n @param[in]  aValue        A pointer to where the new value of the setting should be read from. MUST NOT be NULL if\n                           @p aValueLength is non-zero.\n @param[in]  aValueLength  The length of the data pointed to by aValue. May be zero.\n\n @retval OT_ERROR_NONE             The given setting was changed or staged.\n @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform.\n @retval OT_ERROR_NO_BUFS          No space remaining to store the given setting."]
    pub fn otPlatSettingsSet(
        aInstance: *mut otInstance,
        aKey: u16,
        aValue: *const u8,
        aValueLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Adds a value to a setting.\n\n This function adds the value to a setting\n identified by @p aKey, without replacing any existing\n values.\n\n Note that the underlying implementation is not required\n to maintain the order of the items associated with a\n specific key. The added value may be added to the end,\n the beginning, or even somewhere in the middle. The order\n of any pre-existing values may also change.\n\n Calling this function successfully may cause unrelated\n settings with multiple values to be reordered.\n\n OpenThread stack guarantees to use `otPlatSettingsAdd()`\n method for a @p aKey that was either previously managed by\n `otPlatSettingsAdd()` (i.e., contains one or more items) or\n is empty and/or fully deleted (contains no value).\n\n Platform layer can rely and use this fact for optimizing\n its implementation.\n\n @param[in]  aInstance     The OpenThread instance structure.\n @param[in]  aKey          The key associated with the setting to change.\n @param[in]  aValue        A pointer to where the new value of the setting should be read from. MUST NOT be NULL\n                           if @p aValueLength is non-zero.\n @param[in]  aValueLength  The length of the data pointed to by @p aValue. May be zero.\n\n @retval OT_ERROR_NONE             The given setting was added or staged to be added.\n @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform.\n @retval OT_ERROR_NO_BUFS          No space remaining to store the given setting."]
    pub fn otPlatSettingsAdd(
        aInstance: *mut otInstance,
        aKey: u16,
        aValue: *const u8,
        aValueLength: u16,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes a setting from the setting store.\n\n This function deletes a specific value from the\n setting identified by aKey from the settings store.\n\n Note that the underlying implementation is not required\n to maintain the order of the items associated with a\n specific key.\n\n @param[in] aInstance  The OpenThread instance structure.\n @param[in] aKey       The key associated with the requested setting.\n @param[in] aIndex     The index of the value to be removed. If set to -1, all values for this @p aKey will be\n                       removed.\n\n @retval OT_ERROR_NONE             The given key and index was found and removed successfully.\n @retval OT_ERROR_NOT_FOUND        The given key or index was not found in the setting store.\n @retval OT_ERROR_NOT_IMPLEMENTED  This function is not implemented on this platform."]
    pub fn otPlatSettingsDelete(
        aInstance: *mut otInstance,
        aKey: u16,
        aIndex: ::std::os::raw::c_int,
    ) -> otError;
}
extern "C" {
    #[doc = " Removes all settings from the setting store.\n\n This function deletes all settings from the settings\n store, resetting it to its initial factory state.\n\n @param[in] aInstance  The OpenThread instance structure."]
    pub fn otPlatSettingsWipe(aInstance: *mut otInstance);
}
#[doc = " Indicates that a SPI transaction has completed with the given length. The data written to the slave has been written\n to the pointer indicated by the `aInputBuf` argument to the previous call to `otPlatSpiSlavePrepareTransaction()`.\n\n Once this function is called, `otPlatSpiSlavePrepareTransaction()` is invalid and must be called again for the next\n transaction to be valid.\n\n Note that this function is always called at the end of a transaction, even if `otPlatSpiSlavePrepareTransaction()`\n has not yet been called. In such cases, `aOutputBufLen` and `aInputBufLen` will be zero.\n\n This callback can be called from ISR context. The return value from this function indicates if any further\n processing is required. If `TRUE` is returned the platform spi-slave driver implementation must invoke the\n transaction process callback (`aProcessCallback` set in `otPlatSpiSlaveEnable()`) which unlike this callback must be\n called from the same OS context that any other OpenThread API/callback is called.\n\n @param[in] aContext           Context pointer passed into `otPlatSpiSlaveEnable()`.\n @param[in] aOutputBuf         Value of `aOutputBuf` from last call to `otPlatSpiSlavePrepareTransaction()`.\n @param[in] aOutputBufLen      Value of `aOutputBufLen` from last call to `otPlatSpiSlavePrepareTransaction()`.\n @param[in] aInputBuf          Value of aInputBuf from last call to `otPlatSpiSlavePrepareTransaction()`.\n @param[in] aInputBufLen       Value of aInputBufLen from last call to `otPlatSpiSlavePrepareTransaction()`\n @param[in] aTransactionLength Length of the completed transaction, in bytes.\n\n @returns  TRUE if after this call returns the platform should invoke the process callback `aProcessCallback`,\n           FALSE if there is nothing to process and no need to invoke the process callback."]
pub type otPlatSpiSlaveTransactionCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aOutputBuf: *mut u8,
        aOutputBufLen: u16,
        aInputBuf: *mut u8,
        aInputBufLen: u16,
        aTransactionLength: u16,
    ) -> bool,
>;
#[doc = " Invoked after a transaction complete callback is called and returns `TRUE` to do any further processing required.\n Unlike `otPlatSpiSlaveTransactionCompleteCallback` which can be called from any OS context (e.g., ISR), this\n callback MUST be called from the same OS context as any other OpenThread API/callback.\n\n @param[in] aContext           Context pointer passed into `otPlatSpiSlaveEnable()`.\n"]
pub type otPlatSpiSlaveTransactionProcessCallback =
    ::std::option::Option<unsafe extern "C" fn(aContext: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Initialize the SPI slave interface.\n\n Note that SPI slave is not fully ready until a transaction is prepared using `otPlatSPISlavePrepareTransaction()`.\n\n If `otPlatSPISlavePrepareTransaction() is not called before the master begins a transaction, the resulting SPI\n transaction will send all `0xFF` bytes and discard all received bytes.\n\n @param[in] aCompleteCallback  Pointer to transaction complete callback.\n @param[in] aProcessCallback   Pointer to process callback.\n @param[in] aContext           Context pointer to be passed to callbacks.\n\n @retval OT_ERROR_NONE     Successfully enabled the SPI Slave interface.\n @retval OT_ERROR_ALREADY  SPI Slave interface is already enabled.\n @retval OT_ERROR_FAILED   Failed to enable the SPI Slave interface.\n"]
    pub fn otPlatSpiSlaveEnable(
        aCompleteCallback: otPlatSpiSlaveTransactionCompleteCallback,
        aProcessCallback: otPlatSpiSlaveTransactionProcessCallback,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Shutdown and disable the SPI slave interface."]
    pub fn otPlatSpiSlaveDisable();
}
extern "C" {
    #[doc = " Prepare data for the next SPI transaction. Data pointers MUST remain valid until the transaction complete callback\n is called by the SPI slave driver, or until after the next call to `otPlatSpiSlavePrepareTransaction()`.\n\n This function may be called more than once before the SPI master initiates the transaction. Each *successful* call\n to this function will cause the previous values from earlier calls to be discarded.\n\n Not calling this function after a completed transaction is the same as if this function was previously called with\n both buffer lengths set to zero and `aRequestTransactionFlag` set to `false`.\n\n Once `aOutputBufLen` bytes of `aOutputBuf` has been clocked out, the MISO pin shall be set high until the master\n finishes the SPI transaction. This is the functional equivalent of padding the end of `aOutputBuf` with `0xFF` bytes\n out to the length of the transaction.\n\n Once `aInputBufLen` bytes of aInputBuf have been clocked in from MOSI, all subsequent values from the MOSI pin are\n ignored until the SPI master finishes the transaction.\n\n Note that even if `aInputBufLen` or `aOutputBufLen` (or both) are exhausted before the SPI master finishes a\n transaction, the ongoing size of the transaction must still be kept track of to be passed to the transaction\n complete callback. For example, if `aInputBufLen` is equal to 10 and `aOutputBufLen` equal to 20 and the SPI master\n clocks out 30 bytes, the value 30 is passed to the transaction complete callback.\n\n If a `NULL` pointer is passed in as `aOutputBuf` or `aInputBuf` it means that that buffer pointer should not change\n from its previous/current value. In this case, the corresponding length argument should be ignored. For example,\n `otPlatSpiSlavePrepareTransaction(NULL, 0, aInputBuf, aInputLen, false)` changes the input buffer pointer and its\n length but keeps the output buffer pointer same as before.\n\n Any call to this function while a transaction is in progress will cause all of the arguments to be ignored and the\n return value to be `OT_ERROR_BUSY`.\n\n @param[in] aOutputBuf              Data to be written to MISO pin\n @param[in] aOutputBufLen           Size of the output buffer, in bytes\n @param[in] aInputBuf               Data to be read from MOSI pin\n @param[in] aInputBufLen            Size of the input buffer, in bytes\n @param[in] aRequestTransactionFlag Set to true if host interrupt should be set\n\n @retval OT_ERROR_NONE           Transaction was successfully prepared.\n @retval OT_ERROR_BUSY           A transaction is currently in progress.\n @retval OT_ERROR_INVALID_STATE  otPlatSpiSlaveEnable() hasn't been called.\n"]
    pub fn otPlatSpiSlavePrepareTransaction(
        aOutputBuf: *mut u8,
        aOutputBufLen: u16,
        aInputBuf: *mut u8,
        aInputBufLen: u16,
        aRequestTransactionFlag: bool,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the current time (64bits width).\n\n @returns The current time in microseconds.\n"]
    pub fn otPlatTimeGet() -> u64;
}
extern "C" {
    #[doc = " Get the device's XTAL accuracy.\n\n @returns The device's XTAL accuracy, in ppm.\n"]
    pub fn otPlatTimeGetXtalAccuracy() -> u16;
}
extern "C" {
    #[doc = " This function initializes and enables TREL platform layer.\n\n Upon this call, the platform layer MUST perform the following:\n\n 1) TREL platform layer MUST open a UDP socket to listen for and receive TREL messages from peers. The socket is\n bound to an ephemeral port number chosen by the platform layer. The port number MUST be returned in @p aUdpPort.\n The socket is also bound to network interface(s) on which TREL is to be supported. The socket and the chosen port\n should stay valid while TREL is enabled.\n\n 2) Platform layer MUST initiate an ongoing DNS-SD browse on the service name \"_trel._udp\" within the local browsing\n domain to discover other devices supporting TREL. The ongoing browse will produce two different types of events:\n \"add\" events and \"remove\" events.  When the browse is started, it should produce an \"add\" event for every TREL peer\n currently present on the network.  Whenever a TREL peer goes offline, a \"remove\" event should be produced. \"remove\"\n events are not guaranteed, however. When a TREL service instance is discovered, a new ongoing DNS-SD query for an\n AAAA record should be started on the hostname indicated in the SRV record of the discovered instance. If multiple\n host IPv6 addressees are discovered for a peer, one with highest scope among all addresses MUST be reported (if\n there are multiple address at same scope, one must be selected randomly).\n\n TREL platform MUST signal back the discovered peer info using `otPlatTrelHandleDiscoveredPeerInfo()` callback. This\n callback MUST be invoked when a new peer is discovered, when there is a change in an existing entry (e.g., new\n TXT record or new port number or new IPv6 address), or when the peer is removed.\n\n @param[in]  aInstance  The OpenThread instance.\n @param[out] aUdpPort   A pointer to return the selected port number by platform layer.\n"]
    pub fn otPlatTrelEnable(aInstance: *mut otInstance, aUdpPort: *mut u16);
}
extern "C" {
    #[doc = " This function disables TREL platform layer.\n\n After this call, the platform layer MUST stop DNS-SD browse on the service name \"_trel._udp\", stop advertising the\n TREL DNS-SD service (from `otPlatTrelRegisterService()`) and MUST close the UDP socket used to receive TREL messages.\n\n @pram[in]  aInstance  The OpenThread instance.\n"]
    pub fn otPlatTrelDisable(aInstance: *mut otInstance);
}
#[doc = " This structure represents a TREL peer info discovered using DNS-SD browse on the service name \"_trel._udp\".\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otPlatTrelPeerInfo {
    #[doc = " This boolean flag indicates whether the entry is being removed or added.\n\n - TRUE indicates that peer is removed.\n - FALSE indicates that it is a new entry or an update to an existing entry.\n"]
    pub mRemoved: bool,
    #[doc = " The TXT record data (encoded as specified by DNS-SD) from the SRV record of the discovered TREL peer service\n instance.\n"]
    pub mTxtData: *const u8,
    #[doc = "< Number of bytes in @p mTxtData buffer."]
    pub mTxtLength: u16,
    #[doc = " The TREL peer socket address (IPv6 address and port number).\n\n The port number is determined from the SRV record of the discovered TREL peer service instance. The IPv6 address\n is determined from the DNS-SD query for AAAA records on the hostname indicated in the SRV record of the\n discovered service instance. If multiple host IPv6 addressees are discovered, one with highest scope is used.\n"]
    pub mSockAddr: otSockAddr,
}
impl Default for otPlatTrelPeerInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This is a callback function from platform layer to report a discovered TREL peer info.\n\n @note The @p aInfo structure and its content (e.g., the `mTxtData` buffer) does not need to persist after returning\n from this call. OpenThread code will make a copy of all the info it needs.\n\n @param[in] aInstance   The OpenThread instance.\n @param[in] aInfo       A pointer to the TREL peer info.\n"]
    pub fn otPlatTrelHandleDiscoveredPeerInfo(
        aInstance: *mut otInstance,
        aInfo: *const otPlatTrelPeerInfo,
    );
}
extern "C" {
    #[doc = " This function registers a new service to be advertised using DNS-SD [RFC6763].\n\n The service name is \"_trel._udp\". The platform should use its own hostname, which when combined with the service\n name and the local DNS-SD domain name will produce the full service instance name, for example\n \"example-host._trel._udp.local.\".\n\n The domain under which the service instance name appears will be 'local' for mDNS, and will be whatever domain is\n used for service registration in the case of a non-mDNS local DNS-SD service.\n\n A subsequent call to this function updates the previous service. It is used to update the TXT record data and/or the\n port number.\n\n The @p aTxtData buffer is not persisted after the return from this function. The platform layer MUST NOT keep the\n pointer and instead copy the content if needed.\n\n @param[in] aInstance   The OpenThread instance.\n @param[in] aPort       The port number to include in the SRV record of the advertised service.\n @param[in] aTxtData    A pointer to the TXT record data (encoded) to be include in the advertised service.\n @param[in] aTxtLength  The length of @p aTxtData (number of bytes).\n\n"]
    pub fn otPlatTrelRegisterService(
        aInstance: *mut otInstance,
        aPort: u16,
        aTxtData: *const u8,
        aTxtLength: u8,
    );
}
extern "C" {
    #[doc = " This function requests a TREL UDP packet to be sent to a given destination.\n\n @param[in] aInstance        The OpenThread instance structure.\n @param[in] aUdpPayload      A pointer to UDP payload.\n @param[in] aUdpPayloadLen   The payload length (number of bytes).\n @param[in] aDestSockAddr    The destination socket address.\n"]
    pub fn otPlatTrelSend(
        aInstance: *mut otInstance,
        aUdpPayload: *const u8,
        aUdpPayloadLen: u16,
        aDestSockAddr: *const otSockAddr,
    );
}
extern "C" {
    #[doc = " This function is a callback from platform to notify of a received TREL UDP packet.\n\n @note The buffer content (up to its specified length) may get changed during processing by OpenThread core (e.g.,\n decrypted in place), so the platform implementation should expect that after returning from this function the\n @p aBuffer content may have been altered.\n\n @param[in] aInstance        The OpenThread instance structure.\n @param[in] aBuffer          A buffer containing the received UDP payload.\n @param[in] aLength          UDP payload length (number of bytes).\n"]
    pub fn otPlatTrelHandleReceived(aInstance: *mut otInstance, aBuffer: *mut u8, aLength: u16);
}
#[doc = " This callback allows OpenThread to provide specific handlers for certain UDP messages.\n\n @retval  true    The message is handled by this receiver and should not be further processed.\n @retval  false   The message is not handled by this receiver.\n"]
pub type otUdpHandler = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aMessage: *const otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> bool,
>;
#[doc = " This structure represents a UDP receiver.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otUdpReceiver {
    #[doc = "< A pointer to the next UDP receiver (internal use only)."]
    pub mNext: *mut otUdpReceiver,
    #[doc = "< A function pointer to the receiver callback."]
    pub mHandler: otUdpHandler,
    #[doc = "< A pointer to application-specific context."]
    pub mContext: *mut ::std::os::raw::c_void,
}
impl Default for otUdpReceiver {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function adds a UDP receiver.\n\n @param[in]   aInstance       A pointer to an OpenThread instance.\n @param[in]   aUdpReceiver    A pointer to the UDP receiver.\n\n @retval  OT_ERROR_NONE       The receiver is successfully added.\n @retval  OT_ERROR_ALREADY    The UDP receiver was already added.\n"]
    pub fn otUdpAddReceiver(
        aInstance: *mut otInstance,
        aUdpReceiver: *mut otUdpReceiver,
    ) -> otError;
}
extern "C" {
    #[doc = " This function removes a UDP receiver.\n\n @param[in]   aInstance       A pointer to an OpenThread instance.\n @param[in]   aUdpReceiver    A pointer to the UDP receiver.\n\n @retval  OT_ERROR_NONE       The receiver is successfully removed.\n @retval  OT_ERROR_NOT_FOUND  The UDP receiver was not added.\n"]
    pub fn otUdpRemoveReceiver(
        aInstance: *mut otInstance,
        aUdpReceiver: *mut otUdpReceiver,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sends a UDP message without socket.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aMessage      A pointer to a message without UDP header.\n @param[in]  aMessageInfo  A pointer to a message info associated with @p aMessage.\n\n @retval OT_ERROR_NONE     Successfully enqueued the message into an output interface.\n @retval OT_ERROR_NO_BUFS  Insufficient available buffer to add the IPv6 headers.\n"]
    pub fn otUdpSendDatagram(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aMessageInfo: *mut otMessageInfo,
    ) -> otError;
}
#[doc = " This callback allows OpenThread to inform the application of a received UDP message.\n"]
pub type otUdpReceive = ::std::option::Option<
    unsafe extern "C" fn(
        aContext: *mut ::std::os::raw::c_void,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ),
>;
#[doc = " This structure represents a UDP socket.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otUdpSocket {
    #[doc = "< The local IPv6 socket address."]
    pub mSockName: otSockAddr,
    #[doc = "< The peer IPv6 socket address."]
    pub mPeerName: otSockAddr,
    #[doc = "< A function pointer to the application callback."]
    pub mHandler: otUdpReceive,
    #[doc = "< A pointer to application-specific context."]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< A handle to platform's UDP."]
    pub mHandle: *mut ::std::os::raw::c_void,
    #[doc = "< A pointer to the next UDP socket (internal use only)."]
    pub mNext: *mut otUdpSocket,
}
impl Default for otUdpSocket {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Unspecified network interface."]
pub const OT_NETIF_UNSPECIFIED: otNetifIdentifier = 0;
#[doc = "< The Thread interface."]
pub const OT_NETIF_THREAD: otNetifIdentifier = 1;
#[doc = "< The Backbone interface."]
pub const OT_NETIF_BACKBONE: otNetifIdentifier = 2;
#[doc = " This enumeration defines the OpenThread network interface identifiers.\n"]
pub type otNetifIdentifier = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Allocate a new message buffer for sending a UDP message.\n\n @note If @p aSettings is 'NULL', the link layer security is enabled and the message priority is set to\n OT_MESSAGE_PRIORITY_NORMAL by default.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSettings  A pointer to the message settings or NULL to use default settings.\n\n @returns A pointer to the message buffer or NULL if no message buffers are available or parameters are invalid.\n\n @sa otMessageFree\n"]
    pub fn otUdpNewMessage(
        aInstance: *mut otInstance,
        aSettings: *const otMessageSettings,
    ) -> *mut otMessage;
}
extern "C" {
    #[doc = " Open a UDP/IPv6 socket.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSocket    A pointer to a UDP socket structure.\n @param[in]  aCallback  A pointer to the application callback function.\n @param[in]  aContext   A pointer to application-specific context.\n\n @retval OT_ERROR_NONE    Successfully opened the socket.\n @retval OT_ERROR_FAILED  Failed to open the socket.\n"]
    pub fn otUdpOpen(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aCallback: otUdpReceive,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " Check if a UDP socket is open.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSocket    A pointer to a UDP socket structure.\n\n @returns Whether the UDP socket is open.\n"]
    pub fn otUdpIsOpen(aInstance: *mut otInstance, aSocket: *const otUdpSocket) -> bool;
}
extern "C" {
    #[doc = " Close a UDP/IPv6 socket.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSocket    A pointer to a UDP socket structure.\n\n @retval OT_ERROR_NONE   Successfully closed the socket.\n @retval OT_ERROR_FAILED Failed to close UDP Socket.\n"]
    pub fn otUdpClose(aInstance: *mut otInstance, aSocket: *mut otUdpSocket) -> otError;
}
extern "C" {
    #[doc = " Bind a UDP/IPv6 socket.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSocket    A pointer to a UDP socket structure.\n @param[in]  aSockName  A pointer to an IPv6 socket address structure.\n @param[in]  aNetif     The network interface to bind.\n\n @retval OT_ERROR_NONE   Bind operation was successful.\n @retval OT_ERROR_FAILED Failed to bind UDP socket.\n"]
    pub fn otUdpBind(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aSockName: *const otSockAddr,
        aNetif: otNetifIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " Connect a UDP/IPv6 socket.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aSocket    A pointer to a UDP socket structure.\n @param[in]  aSockName  A pointer to an IPv6 socket address structure.\n\n @retval OT_ERROR_NONE   Connect operation was successful.\n @retval OT_ERROR_FAILED Failed to connect UDP socket.\n"]
    pub fn otUdpConnect(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aSockName: *const otSockAddr,
    ) -> otError;
}
extern "C" {
    #[doc = " Send a UDP/IPv6 message.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aSocket       A pointer to a UDP socket structure.\n @param[in]  aMessage      A pointer to a message buffer.\n @param[in]  aMessageInfo  A pointer to a message info structure.\n\n If the return value is OT_ERROR_NONE, OpenThread takes ownership of @p aMessage, and the caller should no longer\n reference @p aMessage. If the return value is not OT_ERROR_NONE, the caller retains ownership of @p aMessage,\n including freeing @p aMessage if the message buffer is no longer needed.\n\n @retval OT_ERROR_NONE           The message is successfully scheduled for sending.\n @retval OT_ERROR_INVALID_ARGS   Invalid arguments are given.\n @retval OT_ERROR_NO_BUFS        Insufficient available buffer to add the UDP and IPv6 headers.\n"]
    pub fn otUdpSend(
        aInstance: *mut otInstance,
        aSocket: *mut otUdpSocket,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the head of linked list of UDP Sockets.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns A pointer to the head of UDP Socket linked list.\n"]
    pub fn otUdpGetSockets(aInstance: *mut otInstance) -> *mut otUdpSocket;
}
#[doc = " This function pointer delivers the UDP packet to host and host should send the packet through its own network stack.\n\n @param[in]  aMessage   A pointer to the UDP Message.\n @param[in]  aPeerPort  The destination UDP port.\n @param[in]  aPeerAddr  A pointer to the destination IPv6 address.\n @param[in]  aSockPort  The source UDP port.\n @param[in]  aContext   A pointer to application-specific context.\n"]
pub type otUdpForwarder = ::std::option::Option<
    unsafe extern "C" fn(
        aMessage: *mut otMessage,
        aPeerPort: u16,
        aPeerAddr: *mut otIp6Address,
        aSockPort: u16,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Set UDP forward callback to deliver UDP packets to host.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  aForwarder           A pointer to a function called to forward UDP packet to host.\n @param[in]  aContext             A pointer to application-specific context.\n"]
    pub fn otUdpForwardSetForwarder(
        aInstance: *mut otInstance,
        aForwarder: otUdpForwarder,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Handle a UDP packet received from host.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  aMessage             A pointer to the UDP Message.\n @param[in]  aPeerPort            The source UDP port.\n @param[in]  aPeerAddr            A pointer to the source address.\n @param[in]  aSockPort            The destination UDP port.\n\n @warning No matter the call success or fail, the message is freed.\n"]
    pub fn otUdpForwardReceive(
        aInstance: *mut otInstance,
        aMessage: *mut otMessage,
        aPeerPort: u16,
        aPeerAddr: *const otIp6Address,
        aSockPort: u16,
    );
}
extern "C" {
    #[doc = " Determines if the given UDP port is exclusively opened by OpenThread API.\n\n @param[in]  aInstance            A pointer to an OpenThread instance.\n @param[in]  port                 UDP port number to verify.\n\n @retval true    The port is being used exclusively by OpenThread.\n @retval false   The port is not used by any of the OpenThread API or is shared (e.g. is Backbone socket).\n"]
    pub fn otUdpIsPortInUse(aInstance: *mut otInstance, port: u16) -> bool;
}
extern "C" {
    #[doc = " This function initializes the UDP socket by platform.\n\n @param[in]   aUdpSocket  A pointer to the UDP socket.\n\n @retval  OT_ERROR_NONE   Successfully initialized UDP socket by platform.\n @retval  OT_ERROR_FAILED Failed to initialize UDP Socket.\n"]
    pub fn otPlatUdpSocket(aUdpSocket: *mut otUdpSocket) -> otError;
}
extern "C" {
    #[doc = " This function closes the UDP socket by platform.\n\n @param[in]   aUdpSocket  A pointer to the UDP socket.\n\n @retval  OT_ERROR_NONE   Successfully closed UDP socket by platform.\n @retval  OT_ERROR_FAILED Failed to close UDP Socket.\n"]
    pub fn otPlatUdpClose(aUdpSocket: *mut otUdpSocket) -> otError;
}
extern "C" {
    #[doc = " This function binds the UDP socket by platform.\n\n @param[in]   aUdpSocket  A pointer to the UDP socket.\n\n @retval  OT_ERROR_NONE   Successfully bound UDP socket by platform.\n @retval  OT_ERROR_FAILED Failed to bind UDP socket.\n"]
    pub fn otPlatUdpBind(aUdpSocket: *mut otUdpSocket) -> otError;
}
extern "C" {
    #[doc = " This function binds the UDP socket to a platform network interface.\n\n Note: only available when `OPENTHREAD_CONFIG_PLATFORM_UDP_ENABLE` is used.\n\n @param[in]   aUdpSocket          A pointer to the UDP socket.\n @param[in]   aNetifIdentifier    The network interface identifier.\n\n @retval  OT_ERROR_NONE   Successfully bound UDP socket.\n @retval  OT_ERROR_FAILED Failed to bind UDP.\n"]
    pub fn otPlatUdpBindToNetif(
        aUdpSocket: *mut otUdpSocket,
        aNetifIdentifier: otNetifIdentifier,
    ) -> otError;
}
extern "C" {
    #[doc = " This function connects UDP socket by platform.\n\n @param[in]   aUdpSocket  A pointer to the UDP socket.\n\n @retval  OT_ERROR_NONE   Successfully connected by platform.\n @retval  OT_ERROR_FAILED Failed to connect UDP socket.\n"]
    pub fn otPlatUdpConnect(aUdpSocket: *mut otUdpSocket) -> otError;
}
extern "C" {
    #[doc = " This function sends UDP payload by platform.\n\n @param[in]   aUdpSocket      A pointer to the UDP socket.\n @param[in]   aMessage        A pointer to the message to send.\n @param[in]   aMessageInfo    A pointer to the message info associated with @p aMessage.\n\n @retval  OT_ERROR_NONE   Successfully sent by platform, and @p aMessage is freed.\n @retval  OT_ERROR_FAILED Failed to bind UDP socket.\n"]
    pub fn otPlatUdpSend(
        aUdpSocket: *mut otUdpSocket,
        aMessage: *mut otMessage,
        aMessageInfo: *const otMessageInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function configures the UDP socket to join a UDP multicast group.\n\n Note: only available when `OPENTHREAD_CONFIG_PLATFORM_UDP_ENABLE` is used.\n\n @param[in]   aUdpSocket          A pointer to the UDP socket.\n @param[in]   aNetifIdentifier    The network interface identifier.\n @param[in]   aAddress            The UDP multicast group address.\n\n @retval  OT_ERROR_NONE   Successfully joined the multicast group.\n @retval  OT_ERROR_FAILED Failed to join the multicast group.\n"]
    pub fn otPlatUdpJoinMulticastGroup(
        aUdpSocket: *mut otUdpSocket,
        aNetifIdentifier: otNetifIdentifier,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " This function configures the UDP socket to leave a UDP multicast group.\n\n Note: only available when `OPENTHREAD_CONFIG_PLATFORM_UDP_ENABLE` is used.\n\n @param[in]   aUdpSocket          A pointer to the UDP socket.\n @param[in]   aNetifIdentifier    The network interface identifier.\n @param[in]   aAddress            The UDP multicast group address.\n\n @retval  OT_ERROR_NONE   Successfully left the multicast group.\n @retval  OT_ERROR_FAILED Failed to leave the multicast group.\n"]
    pub fn otPlatUdpLeaveMulticastGroup(
        aUdpSocket: *mut otUdpSocket,
        aNetifIdentifier: otNetifIdentifier,
        aAddress: *const otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " This function generates and returns a random `uint32_t` value.\n\n @returns    A random `uint32_t` value.\n"]
    pub fn otRandomNonCryptoGetUint32() -> u32;
}
extern "C" {
    #[doc = " This function generates and returns a random byte.\n\n @returns A random `uint8_t` value.\n"]
    pub fn otRandomNonCryptoGetUint8() -> u8;
}
extern "C" {
    #[doc = " This function generates and returns a random `uint16_t` value.\n\n @returns A random `uint16_t` value.\n"]
    pub fn otRandomNonCryptoGetUint16() -> u16;
}
extern "C" {
    #[doc = " This function generates and returns a random `uint8_t` value within a given range `[aMin, aMax)`.\n\n @param[in]  aMin  A minimum value (this value can be included in returned random result).\n @param[in]  aMax  A maximum value (this value is excluded from returned random result).\n\n @returns    A random `uint8_t` value in the given range (i.e., aMin <= random value < aMax)."]
    pub fn otRandomNonCryptoGetUint8InRange(aMin: u8, aMax: u8) -> u8;
}
extern "C" {
    #[doc = " This function generates and returns a random `uint16_t` value within a given range `[aMin, aMax)`.\n\n @note The returned random value can include the @p aMin value but excludes the @p aMax.\n\n @param[in]  aMin  A minimum value (this value can be included in returned random result).\n @param[in]  aMax  A maximum value (this value is excluded from returned random result).\n\n @returns    A random `uint16_t` value in the given range (i.e., aMin <= random value < aMax)."]
    pub fn otRandomNonCryptoGetUint16InRange(aMin: u16, aMax: u16) -> u16;
}
extern "C" {
    #[doc = " This function generates and returns a random `uint32_t` value within a given range `[aMin, aMax)`.\n\n @note The returned random value can include the @p aMin value but excludes the @p aMax.\n\n @param[in]  aMin  A minimum value (this value can be included in returned random result).\n @param[in]  aMax  A maximum value (this value is excluded from returned random result).\n\n @returns    A random `uint32_t` value in the given range (i.e., aMin <= random value < aMax).\n"]
    pub fn otRandomNonCryptoGetUint32InRange(aMin: u32, aMax: u32) -> u32;
}
extern "C" {
    #[doc = " This function fills a given buffer with random bytes.\n\n @param[out] aBuffer  A pointer to a buffer to fill with the random bytes.\n @param[in]  aSize    Size of buffer (number of bytes to fill).\n"]
    pub fn otRandomNonCryptoFillBuffer(aBuffer: *mut u8, aSize: u16);
}
extern "C" {
    #[doc = " This function adds a random jitter within a given range to a given value.\n\n @param[in]  aValue     A value to which the random jitter is added.\n @param[in]  aJitter    Maximum jitter. Random jitter is selected from the range `[-aJitter, aJitter]`.\n\n @returns    The given value with an added random jitter.\n"]
    pub fn otRandomNonCryptoAddJitter(aValue: u32, aJitter: u16) -> u32;
}
extern "C" {
    #[doc = " This method provides a full or stable copy of the local Thread Network Data.\n\n @param[in]      aInstance    A pointer to an OpenThread instance.\n @param[in]      aStable      TRUE when copying the stable version, FALSE when copying the full version.\n @param[out]     aData        A pointer to the data buffer.\n @param[in,out]  aDataLength  On entry, size of the data buffer pointed to by @p aData.\n                              On exit, number of copied bytes.\n"]
    pub fn otServerGetNetDataLocal(
        aInstance: *mut otInstance,
        aStable: bool,
        aData: *mut u8,
        aDataLength: *mut u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Add a service configuration to the local network data.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aConfig   A pointer to the service configuration.\n\n @retval OT_ERROR_NONE          Successfully added the configuration to the local network data.\n @retval OT_ERROR_INVALID_ARGS  One or more configuration parameters were invalid.\n @retval OT_ERROR_NO_BUFS       Not enough room is available to add the configuration to the local network data.\n\n @sa otServerRemoveService\n @sa otServerRegister\n"]
    pub fn otServerAddService(
        aInstance: *mut otInstance,
        aConfig: *const otServiceConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Remove a service configuration from the local network data.\n\n @param[in]  aInstance          A pointer to an OpenThread instance.\n @param[in]  aEnterpriseNumber  Enterprise Number of the service entry to be deleted.\n @param[in]  aServiceData       A pointer to an Service Data to look for during deletion.\n @param[in]  aServiceDataLength The length of @p aServiceData in bytes.\n\n @retval OT_ERROR_NONE       Successfully removed the configuration from the local network data.\n @retval OT_ERROR_NOT_FOUND  Could not find the Border Router entry.\n\n @sa otServerAddService\n @sa otServerRegister\n"]
    pub fn otServerRemoveService(
        aInstance: *mut otInstance,
        aEnterpriseNumber: u32,
        aServiceData: *const u8,
        aServiceDataLength: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the next service in the local Network Data.\n\n @param[in]      aInstance  A pointer to an OpenThread instance.\n @param[in,out]  aIterator  A pointer to the Network Data iterator context. To get the first service entry\nit should be set to OT_NETWORK_DATA_ITERATOR_INIT.\n @param[out]     aConfig    A pointer to where the service information will be placed.\n\n @retval OT_ERROR_NONE       Successfully found the next service.\n @retval OT_ERROR_NOT_FOUND  No subsequent service exists in the Thread Network Data.\n"]
    pub fn otServerGetNextService(
        aInstance: *mut otInstance,
        aIterator: *mut otNetworkDataIterator,
        aConfig: *mut otServiceConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " Immediately register the local network data with the Leader.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE  Successfully queued a Server Data Request message for delivery.\n\n @sa otServerAddService\n @sa otServerRemoveService\n"]
    pub fn otServerRegister(aInstance: *mut otInstance) -> otError;
}
#[doc = " This structure implements SNTP Query parameters.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSntpQuery {
    #[doc = "< A reference to the message info related with SNTP Server."]
    pub mMessageInfo: *const otMessageInfo,
}
impl Default for otSntpQuery {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This function pointer is called when a SNTP response is received.\n\n @param[in]  aContext   A pointer to application-specific context.\n @param[in]  aTime      Specifies the time at the server when the response left for the client, in UNIX time.\n @param[in]  aResult    A result of the SNTP transaction.\n\n @retval  OT_ERROR_NONE              A response was received successfully and time is provided\n                                     in @p aTime.\n @retval  OT_ERROR_ABORT             A SNTP transaction was aborted by stack.\n @retval  OT_ERROR_BUSY              The Kiss-o'-death packet has been received.\n @retval  OT_ERROR_RESPONSE_TIMEOUT  No SNTP response has been received within timeout.\n @retval  OT_ERROR_FAILED            A response was received but contains incorrect data.\n"]
pub type otSntpResponseHandler = ::std::option::Option<
    unsafe extern "C" fn(aContext: *mut ::std::os::raw::c_void, aTime: u64, aResult: otError),
>;
extern "C" {
    #[doc = " This function sends a SNTP query.\n\n This function is available only if feature `OPENTHREAD_CONFIG_SNTP_CLIENT_ENABLE` is enabled.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aQuery      A pointer to specify SNTP query parameters.\n @param[in]  aHandler    A function pointer that shall be called on response reception or time-out.\n @param[in]  aContext    A pointer to arbitrary context information.\n"]
    pub fn otSntpClientQuery(
        aInstance: *mut otInstance,
        aQuery: *const otSntpQuery,
        aHandler: otSntpResponseHandler,
        aContext: *mut ::std::os::raw::c_void,
    ) -> otError;
}
extern "C" {
    #[doc = " This function sets the unix era number.\n\n The default value of unix era is set to 0. The subsequent eras start after year 2106.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aUnixEra    Unix era number.\n"]
    pub fn otSntpClientSetUnixEra(aInstance: *mut otInstance, aUnixEra: u32);
}
#[doc = "< Item to be added/registered."]
pub const OT_SRP_CLIENT_ITEM_STATE_TO_ADD: otSrpClientItemState = 0;
#[doc = "< Item is being added/registered."]
pub const OT_SRP_CLIENT_ITEM_STATE_ADDING: otSrpClientItemState = 1;
#[doc = "< Item to be refreshed (re-register to renew lease)."]
pub const OT_SRP_CLIENT_ITEM_STATE_TO_REFRESH: otSrpClientItemState = 2;
#[doc = "< Item is being refreshed."]
pub const OT_SRP_CLIENT_ITEM_STATE_REFRESHING: otSrpClientItemState = 3;
#[doc = "< Item to be removed."]
pub const OT_SRP_CLIENT_ITEM_STATE_TO_REMOVE: otSrpClientItemState = 4;
#[doc = "< Item is being removed."]
pub const OT_SRP_CLIENT_ITEM_STATE_REMOVING: otSrpClientItemState = 5;
#[doc = "< Item is registered with server."]
pub const OT_SRP_CLIENT_ITEM_STATE_REGISTERED: otSrpClientItemState = 6;
#[doc = "< Item is removed."]
pub const OT_SRP_CLIENT_ITEM_STATE_REMOVED: otSrpClientItemState = 7;
#[doc = " This enumeration specifies an SRP client item (service or host info) state.\n"]
pub type otSrpClientItemState = ::std::os::raw::c_uint;
#[doc = " This structure represents an SRP client host info.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSrpClientHostInfo {
    #[doc = "< Host name (label) string (NULL if not yet set)."]
    pub mName: *const ::std::os::raw::c_char,
    #[doc = "< Array of host IPv6 addresses (NULL if not set or auto address is enabled)."]
    pub mAddresses: *const otIp6Address,
    #[doc = "< Number of IPv6 addresses in `mAddresses` array."]
    pub mNumAddresses: u8,
    #[doc = "< Indicates whether auto address mode is enabled or not."]
    pub mAutoAddress: bool,
    #[doc = "< Host info state."]
    pub mState: otSrpClientItemState,
}
impl Default for otSrpClientHostInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure represents an SRP client service.\n\n The values in this structure, including the string buffers for the names and the TXT record entries, MUST persist\n and stay constant after an instance of this structure is passed to OpenThread from `otSrpClientAddService()` or\n `otSrpClientRemoveService()`.\n\n The `mState`, `mData`, `mNext` fields are used/managed by OT core only. Their value is ignored when an instance of\n `otSrpClientService` is passed in `otSrpClientAddService()` or `otSrpClientRemoveService()` or other functions. The\n caller does not need to set these fields.\n\n The `mLease` and `mKeyLease` fields specify the desired lease and key lease intervals for this service. Zero value\n indicates that the interval is unspecified and then the default lease or key lease intervals from\n `otSrpClientGetLeaseInterval()` and `otSrpClientGetKeyLeaseInterval()` are used for this service. If the key lease\n interval (whether set explicitly or determined from the default) is shorter than the lease interval for a service,\n SRP client will re-use the lease interval value for key lease interval as well. For example, if in service `mLease`\n is explicitly set to 2 days and `mKeyLease` is set to zero and default key lease is set to 1 day, then when\n registering this service, the requested key lease for this service is also set to 2 days.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSrpClientService {
    #[doc = "< The service labels (e.g., \"_mt._udp\", not the full domain name)."]
    pub mName: *const ::std::os::raw::c_char,
    #[doc = "< The service instance name label (not the full name)."]
    pub mInstanceName: *const ::std::os::raw::c_char,
    #[doc = "< Array of sub-type labels (must end with `NULL` or can be `NULL`)."]
    pub mSubTypeLabels: *const *const ::std::os::raw::c_char,
    #[doc = "< Array of TXT entries (`mNumTxtEntries` gives num of entries)."]
    pub mTxtEntries: *const otDnsTxtEntry,
    #[doc = "< The service port number."]
    pub mPort: u16,
    #[doc = "< The service priority."]
    pub mPriority: u16,
    #[doc = "< The service weight."]
    pub mWeight: u16,
    #[doc = "< Number of entries in the `mTxtEntries` array."]
    pub mNumTxtEntries: u8,
    #[doc = "< Service state (managed by OT core)."]
    pub mState: otSrpClientItemState,
    #[doc = "< Internal data (used by OT core)."]
    pub mData: u32,
    #[doc = "< Pointer to next entry in a linked-list (managed by OT core)."]
    pub mNext: *mut otSrpClientService,
    #[doc = "< Desired lease interval in sec - zero to use default."]
    pub mLease: u32,
    #[doc = "< Desired key lease interval in sec - zero to use default."]
    pub mKeyLease: u32,
}
impl Default for otSrpClientService {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This function pointer type defines the callback used by SRP client to notify user of changes/events/errors.\n\n This callback is invoked on a successful registration of an update (i.e., add/remove of host-info and/or some\n service(s)) with the SRP server, or if there is a failure or error (e.g., server rejects a update request or client\n times out waiting for response, etc).\n\n In case of a successful reregistration of an update, `aError` parameter would be `OT_ERROR_NONE` and the host info\n and the full list of services is provided as input parameters to the callback. Note that host info and services each\n track its own state in the corresponding `mState` member variable of the related data structure (the state\n indicating whether the host-info/service is registered or removed or still being added/removed, etc).\n\n The list of removed services is passed as its own linked-list `aRemovedServices` in the callback. Note that when the\n callback is invoked, the SRP client (OpenThread implementation) is done with the removed service instances listed in\n `aRemovedServices` and no longer tracks/stores them (i.e., if from the callback we call `otSrpClientGetServices()`\n the removed services will not be present in the returned list). Providing a separate list of removed services in\n the callback helps indicate to user which items are now removed and allow user to re-claim/reuse the instances.\n\n If the server rejects an SRP update request, the DNS response code (RFC 2136) is mapped to the following errors:\n\n  - (0)  NOERROR   Success (no error condition)                    -> OT_ERROR_NONE\n  - (1)  FORMERR   Server unable to interpret due to format error  -> OT_ERROR_PARSE\n  - (2)  SERVFAIL  Server encountered an internal failure          -> OT_ERROR_FAILED\n  - (3)  NXDOMAIN  Name that ought to exist, does not exist        -> OT_ERROR_NOT_FOUND\n  - (4)  NOTIMP    Server does not support the query type (OpCode) -> OT_ERROR_NOT_IMPLEMENTED\n  - (5)  REFUSED   Server refused for policy/security reasons      -> OT_ERROR_SECURITY\n  - (6)  YXDOMAIN  Some name that ought not to exist, does exist   -> OT_ERROR_DUPLICATED\n  - (7)  YXRRSET   Some RRset that ought not to exist, does exist  -> OT_ERROR_DUPLICATED\n  - (8)  NXRRSET   Some RRset that ought to exist, does not exist  -> OT_ERROR_NOT_FOUND\n  - (9)  NOTAUTH   Service is not authoritative for zone           -> OT_ERROR_SECURITY\n  - (10) NOTZONE   A name is not in the zone                       -> OT_ERROR_PARSE\n  - (20) BADNAME   Bad name                                        -> OT_ERROR_PARSE\n  - (21) BADALG    Bad algorithm                                   -> OT_ERROR_SECURITY\n  - (22) BADTRUN   Bad truncation                                  -> OT_ERROR_PARSE\n  - Other response codes                                           -> OT_ERROR_FAILED\n\n The following errors are also possible:\n\n  - OT_ERROR_RESPONSE_TIMEOUT : Timed out waiting for response from server (client would continue to retry).\n  - OT_ERROR_INVALID_ARGS     : The provided service structure is invalid (e.g., bad service name or `otDnsTxtEntry`).\n  - OT_ERROR_NO_BUFS          : Insufficient buffer to prepare or send the update message.\n\n Note that in case of any failure, the client continues the operation, i.e. it prepares and (re)transmits the SRP\n update message to the server, after some wait interval. The retry wait interval starts from the minimum value and\n is increased by the growth factor every failure up to the max value (please see configuration parameter\n `OPENTHREAD_CONFIG_SRP_CLIENT_MIN_RETRY_WAIT_INTERVAL` and the related ones for more details).\n\n @param[in] aError            The error (see above).\n @param[in] aHostInfo         A pointer to host info.\n @param[in] aServices         The head of linked-list containing all services (excluding the ones removed). NULL if\n                              the list is empty.\n @param[in] aRemovedServices  The head of linked-list containing all removed services. NULL if the list is empty.\n @param[in] aContext          A pointer to an arbitrary context (provided when callback was registered).\n"]
pub type otSrpClientCallback = ::std::option::Option<
    unsafe extern "C" fn(
        aError: otError,
        aHostInfo: *const otSrpClientHostInfo,
        aServices: *const otSrpClientService,
        aRemovedServices: *const otSrpClientService,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " This function pointer type defines the callback used by SRP client to notify user when it is auto-started or stopped.\n\n This is only used when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled.\n\n This callback is invoked when auto-start mode is enabled and the SRP client is either automatically started or\n stopped.\n\n @param[in] aServerSockAddr   A non-NULL pointer indicates SRP server was started and pointer will give the\n                              selected server socket address. A NULL pointer indicates SRP server was stopped.\n @param[in] aContext          A pointer to an arbitrary context (provided when callback was registered).\n"]
pub type otSrpClientAutoStartCallback = ::std::option::Option<
    unsafe extern "C" fn(aServerSockAddr: *const otSockAddr, aContext: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This function starts the SRP client operation.\n\n SRP client will prepare and send \"SRP Update\" message to the SRP server once all the following conditions are met:\n\n  - The SRP client is started - `otSrpClientStart()` is called.\n  - Host name is set - `otSrpClientSetHostName()` is called.\n  - At least one host IPv6 address is set - `otSrpClientSetHostName()` is called.\n  - At least one service is added - `otSrpClientAddService()` is called.\n\n It does not matter in which order these functions are called. When all conditions are met, the SRP client will\n wait for a short delay before preparing an \"SRP Update\" message and sending it to server. This delay allows for user\n to add multiple services and/or IPv6 addresses before the first SRP Update message is sent (ensuring a single SRP\n Update is sent containing all the info). The config `OPENTHREAD_CONFIG_SRP_CLIENT_UPDATE_TX_DELAY` specifies the\n delay interval.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n @param[in] aServerSockAddr  The socket address (IPv6 address and port number) of the SRP server.\n\n @retval OT_ERROR_NONE       SRP client operation started successfully or it is already running with same server\n                             socket address and callback.\n @retval OT_ERROR_BUSY       SRP client is busy running with a different socket address.\n @retval OT_ERROR_FAILED     Failed to open/connect the client's UDP socket.\n"]
    pub fn otSrpClientStart(
        aInstance: *mut otInstance,
        aServerSockAddr: *const otSockAddr,
    ) -> otError;
}
extern "C" {
    #[doc = " This function stops the SRP client operation.\n\n This function stops any further interactions with the SRP server. Note that it does not remove or clear host info\n and/or list of services. It marks all services to be added/removed again once the client is (re)started.\n\n @param[in] aInstance       A pointer to the OpenThread instance.\n"]
    pub fn otSrpClientStop(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function indicates whether the SRP client is running or not.\n\n @param[in] aInstance       A pointer to the OpenThread instance.\n\n @returns TRUE if the SRP client is running, FALSE otherwise.\n"]
    pub fn otSrpClientIsRunning(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function gets the socket address (IPv6 address and port number) of the SRP server which is being used by SRP\n client.\n\n If the client is not running, the address is unspecified (all zero) with zero port number.\n\n @param[in] aInstance       A pointer to the OpenThread instance.\n\n @returns A pointer to the SRP server's socket address (is always non-NULL).\n"]
    pub fn otSrpClientGetServerAddress(aInstance: *mut otInstance) -> *const otSockAddr;
}
extern "C" {
    #[doc = " This function sets the callback to notify caller of events/changes from SRP client.\n\n The SRP client allows a single callback to be registered. So consecutive calls to this function will overwrite any\n previously set callback functions.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n @param[in] aCallback   The callback to notify of events and changes. Can be NULL if not needed.\n @param[in] aContext    An arbitrary context used with @p aCallback.\n"]
    pub fn otSrpClientSetCallback(
        aInstance: *mut otInstance,
        aCallback: otSrpClientCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function enables the auto-start mode.\n\n This is only available when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled.\n\n Config option `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_DEFAULT_MODE` specifies the default auto-start mode (whether\n it is enabled or disabled at the start of OT stack).\n\n When auto-start is enabled, the SRP client will monitor the Thread Network Data to discover SRP servers and select\n the preferred server and automatically start and stop the client when an SRP server is detected.\n\n There are three categories of Network Data entries indicating presence of SRP sever. They are preferred in the\n following order:\n\n   1) Preferred unicast entries where server address is included in the service data. If there are multiple options,\n      the one with numerically lowest IPv6 address is preferred.\n\n   2) Anycast entries each having a seq number. A larger sequence number in the sense specified by Serial Number\n      Arithmetic logic in RFC-1982 is considered more recent and therefore preferred. The largest seq number using\n      serial number arithmetic is preferred if it is well-defined (i.e., the seq number is larger than all other\n      seq numbers). If it is not well-defined, then the numerically largest seq number is preferred.\n\n   3) Unicast entries where the server address info is included in server data. If there are multiple options, the\n      one with numerically lowest IPv6 address is preferred.\n\n When there is a change in the Network Data entries, client will check that the currently selected server is still\n present in the Network Data and is still the preferred one. Otherwise the client will switch to the new preferred\n server or stop if there is none.\n\n When the SRP client is explicitly started through a successful call to `otSrpClientStart()`, the given SRP server\n address in `otSrpClientStart()` will continue to be used regardless of the state of auto-start mode and whether the\n same SRP server address is discovered or not in the Thread Network Data. In this case, only an explicit\n `otSrpClientStop()` call will stop the client.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n @param[in] aCallback   A callback to notify when client is auto-started/stopped. Can be NULL if not needed.\n @param[in] aContext    A context to be passed when invoking @p aCallback.\n"]
    pub fn otSrpClientEnableAutoStartMode(
        aInstance: *mut otInstance,
        aCallback: otSrpClientAutoStartCallback,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function disables the auto-start mode.\n\n This is only available when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled.\n\n Disabling the auto-start mode will not stop the client if it is already running but the client stops monitoring\n the Thread Network Data to verify that the selected SRP server is still present in it.\n\n Note that a call to `otSrpClientStop()` will also disable the auto-start mode.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n"]
    pub fn otSrpClientDisableAutoStartMode(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function indicates the current state of auto-start mode (enabled or disabled).\n\n This is only available when auto-start feature `OPENTHREAD_CONFIG_SRP_CLIENT_AUTO_START_API_ENABLE` is enabled.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n\n @returns TRUE if the auto-start mode is enabled, FALSE otherwise.\n"]
    pub fn otSrpClientIsAutoStartModeEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function gets the TTL value in every record included in SRP update requests.\n\n Note that this is the TTL requested by the SRP client. The server may choose to accept a different TTL.\n\n By default, the TTL will equal the lease interval. Passing 0 or a value larger than the lease interval via\n `otSrpClientSetTtl()` will also cause the TTL to equal the lease interval.\n\n @param[in] aInstance  A pointer to the OpenThread instance.\n\n @returns The TTL (in seconds).\n"]
    pub fn otSrpClientGetTtl(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " This function sets the TTL value in every record included in SRP update requests.\n\n Changing the TTL does not impact the TTL of already registered services/host-info.\n It only affects future SRP update messages (i.e., adding new services and/or refreshes of the existing services).\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n @param[in] aTtl        The TTL (in seconds). If value is zero or greater than lease interval, the TTL is set to the\n                        lease interval.\n"]
    pub fn otSrpClientSetTtl(aInstance: *mut otInstance, aTtl: u32);
}
extern "C" {
    #[doc = " This function gets the default lease interval used in SRP update requests.\n\n The default interval is used only for `otSrpClientService` instances with `mLease` set to zero.\n\n Note that this is the lease duration requested by the SRP client. The server may choose to accept a different lease\n interval.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n\n @returns The lease interval (in seconds).\n"]
    pub fn otSrpClientGetLeaseInterval(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " This function sets the default lease interval used in SRP update requests.\n\n The default interval is used only for `otSrpClientService` instances with `mLease` set to zero.\n\n Changing the lease interval does not impact the accepted lease interval of already registered services/host-info.\n It only affects any future SRP update messages (i.e., adding new services and/or refreshes of the existing services).\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n @param[in] aInterval   The lease interval (in seconds). If zero, the default value specified by\n                        `OPENTHREAD_CONFIG_SRP_CLIENT_DEFAULT_LEASE` would be used.\n"]
    pub fn otSrpClientSetLeaseInterval(aInstance: *mut otInstance, aInterval: u32);
}
extern "C" {
    #[doc = " This function gets the default key lease interval used in SRP update requests.\n\n The default interval is used only for `otSrpClientService` instances with `mKeyLease` set to zero.\n\n Note that this is the lease duration requested by the SRP client. The server may choose to accept a different lease\n interval.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n\n @returns The key lease interval (in seconds).\n"]
    pub fn otSrpClientGetKeyLeaseInterval(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " This function sets the default key lease interval used in SRP update requests.\n\n The default interval is used only for `otSrpClientService` instances with `mKeyLease` set to zero.\n\n Changing the lease interval does not impact the accepted lease interval of already registered services/host-info.\n It only affects any future SRP update messages (i.e., adding new services and/or refreshes of existing services).\n\n @param[in] aInstance    A pointer to the OpenThread instance.\n @param[in] aInterval    The key lease interval (in seconds). If zero, the default value specified by\n                         `OPENTHREAD_CONFIG_SRP_CLIENT_DEFAULT_KEY_LEASE` would be used.\n"]
    pub fn otSrpClientSetKeyLeaseInterval(aInstance: *mut otInstance, aInterval: u32);
}
extern "C" {
    #[doc = " This function gets the host info.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n\n @returns A pointer to host info structure.\n"]
    pub fn otSrpClientGetHostInfo(aInstance: *mut otInstance) -> *const otSrpClientHostInfo;
}
extern "C" {
    #[doc = " This function sets the host name label.\n\n After a successful call to this function, `otSrpClientCallback` will be called to report the status of host info\n registration with SRP server.\n\n The name string buffer pointed to by @p aName MUST persist and stay unchanged after returning from this function.\n OpenThread will keep the pointer to the string.\n\n The host name can be set before client is started or after start but before host info is registered with server\n (host info should be in either `STATE_TO_ADD` or `STATE_REMOVED`).\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n @param[in] aName       A pointer to host name label string (MUST NOT be NULL). Pointer to the string buffer MUST\n                        persist and remain valid and constant after return from this function.\n\n @retval OT_ERROR_NONE            The host name label was set successfully.\n @retval OT_ERROR_INVALID_ARGS    The @p aName is NULL.\n @retval OT_ERROR_INVALID_STATE   The host name is already set and registered with the server.\n"]
    pub fn otSrpClientSetHostName(
        aInstance: *mut otInstance,
        aName: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function enables auto host address mode.\n\n When enabled host IPv6 addresses are automatically set by SRP client using all the unicast addresses on Thread netif\n excluding all link-local and mesh-local addresses. If there is no valid address, then Mesh Local EID address is\n added. The SRP client will automatically re-register when/if addresses on Thread netif are updated (new addresses\n are added or existing addresses are removed).\n\n The auto host address mode can be enabled before start or during operation of SRP client except when the host info\n is being removed (client is busy handling a remove request from an call to `otSrpClientRemoveHostAndServices()` and\n host info still being in  either `STATE_TO_REMOVE` or `STATE_REMOVING` states).\n\n After auto host address mode is enabled, it can be disabled by a call to `otSrpClientSetHostAddresses()` which\n then explicitly sets the host addresses.\n\n @retval OT_ERROR_NONE            Successfully enabled auto host address mode.\n @retval OT_ERROR_INVALID_STATE   Host is being removed and therefore cannot enable auto host address mode.\n"]
    pub fn otSrpClientEnableAutoHostAddress(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " This function sets/updates the list of host IPv6 address.\n\n Host IPv6 addresses can be set/changed before start or during operation of SRP client (e.g. to add/remove or change\n a previously registered host address), except when the host info is being removed (client is busy handling a remove\n request from an earlier call to `otSrpClientRemoveHostAndServices()` and host info still being in  either\n `STATE_TO_REMOVE` or `STATE_REMOVING` states).\n\n The host IPv6 address array pointed to by @p aIp6Addresses MUST persist and remain unchanged after returning from\n this function (with `OT_ERROR_NONE`). OpenThread will save the pointer to the array.\n\n After a successful call to this function, `otSrpClientCallback` will be called to report the status of the address\n registration with SRP server.\n\n Calling this function disables auto host address mode if it was previously enabled from a successful call to\n `otSrpClientEnableAutoHostAddress()`.\n\n @param[in] aInstance           A pointer to the OpenThread instance.\n @param[in] aIp6Addresses       A pointer to the an array containing the host IPv6 addresses.\n @param[in] aNumAddresses       The number of addresses in the @p aIp6Addresses array.\n\n @retval OT_ERROR_NONE            The host IPv6 address list change started successfully. The `otSrpClientCallback`\n                                  will be called to report the status of registering addresses with server.\n @retval OT_ERROR_INVALID_ARGS    The address list is invalid (e.g., must contain at least one address).\n @retval OT_ERROR_INVALID_STATE   Host is being removed and therefore cannot change host address.\n"]
    pub fn otSrpClientSetHostAddresses(
        aInstance: *mut otInstance,
        aIp6Addresses: *const otIp6Address,
        aNumAddresses: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function adds a service to be registered with server.\n\n After a successful call to this function, `otSrpClientCallback` will be called to report the status of the service\n addition/registration with SRP server.\n\n The `otSrpClientService` instance being pointed to by @p aService MUST persist and remain unchanged after returning\n from this function (with `OT_ERROR_NONE`). OpenThread will save the pointer to the service instance.\n\n The `otSrpClientService` instance is not longer tracked by OpenThread and can be reclaimed only when\n\n  -  It is removed explicitly by a call to `otSrpClientRemoveService()` or removed along with other services by a\n     call to `otSrpClientRemoveHostAndServices() and only after the `otSrpClientCallback` is called indicating the\n     service was removed. Or,\n  -  A call to `otSrpClientClearHostAndServices()` which removes the host and all related services immediately.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n @param[in] aService         A pointer to a `otSrpClientService` instance to add.\n\n @retval OT_ERROR_NONE          The addition of service started successfully. The `otSrpClientCallback` will be\n                                called to report the status.\n @retval OT_ERROR_ALREADY       A service with the same service and instance names is already in the list.\n @retval OT_ERROR_INVALID_ARGS  The service structure is invalid (e.g., bad service name or `otDnsTxtEntry`).\n"]
    pub fn otSrpClientAddService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientService,
    ) -> otError;
}
extern "C" {
    #[doc = " This function requests a service to be unregistered with server.\n\n After a successful call to this function, `otSrpClientCallback` will be called to report the status of remove\n request with SRP server.\n\n The `otSrpClientService` instance being pointed to by @p aService MUST persist and remain unchanged after returning\n from this function (with `OT_ERROR_NONE`). OpenThread will keep the service instance during the remove process.\n Only after the `otSrpClientCallback` is called indicating the service instance is removed from SRP client\n service list and can be be freed/reused.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n @param[in] aService         A pointer to a `otSrpClientService` instance to remove.\n\n @retval OT_ERROR_NONE       The removal of service started successfully. The `otSrpClientCallback` will be called to\n                             report the status.\n @retval OT_ERROR_NOT_FOUND  The service could not be found in the list.\n"]
    pub fn otSrpClientRemoveService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientService,
    ) -> otError;
}
extern "C" {
    #[doc = " This function clears a service, immediately removing it from the client service list.\n\n Unlike `otSrpClientRemoveService()` which sends an update message to the server to remove the service, this function\n clears the service from the client's service list without any interaction with the server. On a successful call to\n this function, the `otSrpClientCallback` will NOT be called and the @p aService entry can be reclaimed and re-used\n by the caller immediately.\n\n This function can be used along with a subsequent call to `otSrpClientAddService()` (potentially reusing the same @p\n aService entry with the same service and instance names) to update some of the parameters in an existing service.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n @param[in] aService         A pointer to a `otSrpClientService` instance to delete.\n\n @retval OT_ERROR_NONE       The @p aService is deleted successfully. It can be reclaimed and re-used immediately.\n @retval OT_ERROR_NOT_FOUND  The service could not be found in the list.\n"]
    pub fn otSrpClientClearService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientService,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the list of services being managed by client.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n\n @returns A pointer to the head of linked-list of all services or NULL if the list is empty.\n"]
    pub fn otSrpClientGetServices(aInstance: *mut otInstance) -> *const otSrpClientService;
}
extern "C" {
    #[doc = " This function starts the remove process of the host info and all services.\n\n After returning from this function, `otSrpClientCallback` will be called to report the status of remove request with\n SRP server.\n\n If the host info is to be permanently removed from server, @p aRemoveKeyLease should be set to `true` which removes\n the key lease associated with host on server. Otherwise, the key lease record is kept as before, which ensures\n that the server holds the host name in reserve for when the client is once again able to provide and register its\n service(s).\n\n The @p aSendUnregToServer determines the behavior when the host info is not yet registered with the server. If\n @p aSendUnregToServer is set to `false` (which is the default/expected value) then the SRP client will immediately\n remove the host info and services without sending an update message to server (no need to update the server if\n nothing is yet registered with it). If @p aSendUnregToServer is set to `true` then the SRP client will send an\n update message to the server. Note that if the host info is registered then the value of @p aSendUnregToServer does\n not matter and the SRP client will always send an update message to server requesting removal of all info.\n\n One situation where @p aSendUnregToServer can be useful is on a device reset/reboot, caller may want to remove any\n previously registered services with the server. In this case, caller can `otSrpClientSetHostName()` and then request\n `otSrpClientRemoveHostAndServices()` with `aSendUnregToServer` as `true`.\n\n @param[in] aInstance          A pointer to the OpenThread instance.\n @param[in] aRemoveKeyLease    A boolean indicating whether or not the host key lease should also be removed.\n @param[in] aSendUnregToServer A boolean indicating whether to send update to server when host info is not registered.\n\n @retval OT_ERROR_NONE       The removal of host info and services started successfully. The `otSrpClientCallback`\n                             will be called to report the status.\n @retval OT_ERROR_ALREADY    The host info is already removed.\n"]
    pub fn otSrpClientRemoveHostAndServices(
        aInstance: *mut otInstance,
        aRemoveKeyLease: bool,
        aSendUnregToServer: bool,
    ) -> otError;
}
extern "C" {
    #[doc = " This function clears all host info and all the services.\n\n Unlike `otSrpClientRemoveHostAndServices()` which sends an update message to the server to remove all the info, this\n function clears all the info immediately without any interaction with the server.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n"]
    pub fn otSrpClientClearHostAndServices(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function gets the domain name being used by SRP client.\n\n This function requires `OPENTHREAD_CONFIG_SRP_CLIENT_DOMAIN_NAME_API_ENABLE` to be enabled.\n\n If domain name is not set, \"default.service.arpa\" will be used.\n\n @param[in] aInstance        A pointer to the OpenThread instance.\n\n @returns The domain name string.\n"]
    pub fn otSrpClientGetDomainName(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function sets the domain name to be used by SRP client.\n\n This function requires `OPENTHREAD_CONFIG_SRP_CLIENT_DOMAIN_NAME_API_ENABLE` to be enabled.\n\n If not set \"default.service.arpa\" will be used.\n\n The name string buffer pointed to by @p aName MUST persist and stay unchanged after returning from this function.\n OpenThread will keep the pointer to the string.\n\n The domain name can be set before client is started or after start but before host info is registered with server\n (host info should be in either `STATE_TO_ADD` or `STATE_TO_REMOVE`).\n\n @param[in] aInstance     A pointer to the OpenThread instance.\n @param[in] aName         A pointer to the domain name string. If NULL sets it to default \"default.service.arpa\".\n\n @retval OT_ERROR_NONE            The domain name label was set successfully.\n @retval OT_ERROR_INVALID_STATE   The host info is already registered with server.\n"]
    pub fn otSrpClientSetDomainName(
        aInstance: *mut otInstance,
        aName: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function converts a `otSrpClientItemState` to a string.\n\n @param[in] aItemState  An item state.\n\n @returns A string representation of @p aItemState.\n"]
    pub fn otSrpClientItemStateToString(
        aItemState: otSrpClientItemState,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function enables/disables \"service key record inclusion\" mode.\n\n When enabled, SRP client will include KEY record in Service Description Instructions in the SRP update messages\n that it sends.\n\n This function is available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` configuration is enabled.\n\n @note KEY record is optional in Service Description Instruction (it is required and always included in the Host\n Description Instruction). The default behavior of SRP client is to not include it. This function is intended to\n override the default behavior for testing only.\n\n @param[in] aInstance  A pointer to the OpenThread instance.\n @param[in] aEnabled   TRUE to enable, FALSE to disable the \"service key record inclusion\" mode.\n"]
    pub fn otSrpClientSetServiceKeyRecordEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " This method indicates whether the \"service key record inclusion\" mode is enabled or disabled.\n\n This function is available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` configuration is enabled.\n\n @param[in] aInstance     A pointer to the OpenThread instance.\n\n @returns TRUE if \"service key record inclusion\" mode is enabled, FALSE otherwise.\n"]
    pub fn otSrpClientIsServiceKeyRecordEnabled(aInstance: *mut otInstance) -> bool;
}
#[doc = " This struct represents a SRP client service pool entry.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSrpClientBuffersServiceEntry {
    #[doc = "< The SRP client service structure."]
    pub mService: otSrpClientService,
    #[doc = "< The SRP client TXT entry."]
    pub mTxtEntry: otDnsTxtEntry,
}
impl Default for otSrpClientBuffersServiceEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This function gets the string buffer to use for SRP client host name.\n\n @param[in]  aInstance  A pointer to the OpenThread instance.\n @param[out] aSize      Pointer to a variable to return the size (number of bytes) of the string buffer (MUST NOT be\n                        NULL).\n\n @returns A pointer to char buffer to use for SRP client host name.\n"]
    pub fn otSrpClientBuffersGetHostNameString(
        aInstance: *mut otInstance,
        aSize: *mut u16,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function gets the array of IPv6 address entries to use as SRP client host address list.\n\n @param[in]  aInstance     A pointer to the OpenThread instance.\n @param[out] aArrayLength  Pointer to a variable to return the array length i.e., number of IPv6 address entries in\n                           the array (MUST NOT be NULL).\n\n @returns A pointer to an array of `otIp6Address` entries (number of entries is returned in @p aArrayLength).\n"]
    pub fn otSrpClientBuffersGetHostAddressesArray(
        aInstance: *mut otInstance,
        aArrayLength: *mut u8,
    ) -> *mut otIp6Address;
}
extern "C" {
    #[doc = " This function allocates a new service entry from the pool.\n\n The returned service entry instance will be initialized as follows:\n\n  - `mService.mName` will point to an allocated string buffer which can be retrieved using the function\n    `otSrpClientBuffersGetServiceEntryServiceNameString()`.\n  - `mService.mInstanceName` will point to an allocated string buffer which can be retrieved using the function\n    `otSrpClientBuffersGetServiceEntryInstanceNameString()`.\n  - `mService.mSubTypeLabels` points to an array that is returned from `otSrpClientBuffersGetSubTypeLabelsArray()`.\n  - `mService.mTxtEntries` will point to `mTxtEntry`.\n  - `mService.mNumTxtEntries` will be set to one.\n  - Other `mService` fields (port, priority, weight) are set to zero.\n  - `mTxtEntry.mKey` is set to NULL (value is treated as already encoded).\n  - `mTxtEntry.mValue` will point to an allocated buffer which can be retrieved using the function\n    `otSrpClientBuffersGetServiceEntryTxtBuffer()`.\n  - `mTxtEntry.mValueLength` is set to zero.\n  - All related data/string buffers and arrays are cleared to all zero.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n\n @returns A pointer to the newly allocated service entry or NULL if not more entry available in the pool.\n"]
    pub fn otSrpClientBuffersAllocateService(
        aInstance: *mut otInstance,
    ) -> *mut otSrpClientBuffersServiceEntry;
}
extern "C" {
    #[doc = " This function frees a previously allocated service entry.\n\n The @p aService MUST be previously allocated using `otSrpClientBuffersAllocateService()` and not yet freed. Otherwise\n the behavior of this function is undefined.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n @param[in] aService    A pointer to the service entry to free (MUST NOT be NULL).\n"]
    pub fn otSrpClientBuffersFreeService(
        aInstance: *mut otInstance,
        aService: *mut otSrpClientBuffersServiceEntry,
    );
}
extern "C" {
    #[doc = " This function frees all previously allocated service entries.\n\n @param[in] aInstance   A pointer to the OpenThread instance.\n"]
    pub fn otSrpClientBuffersFreeAllServices(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " This function gets the string buffer for service name from a service entry.\n\n @param[in]  aEntry   A pointer to a previously allocated service entry (MUST NOT be NULL).\n @param[out] aSize    A pointer to a variable to return the size (number of bytes) of the string buffer (MUST NOT be\n                      NULL).\n\n @returns A pointer to the string buffer.\n"]
    pub fn otSrpClientBuffersGetServiceEntryServiceNameString(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aSize: *mut u16,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function gets the string buffer for service instance name from a service entry.\n\n @param[in]  aEntry   A pointer to a previously allocated service entry (MUST NOT be NULL).\n @param[out] aSize    A pointer to a variable to return the size (number of bytes) of the string buffer (MUST NOT be\n                      NULL).\n\n @returns A pointer to the string buffer.\n"]
    pub fn otSrpClientBuffersGetServiceEntryInstanceNameString(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aSize: *mut u16,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function gets the buffer for TXT record from a service entry.\n\n @param[in]  aEntry   A pointer to a previously allocated service entry (MUST NOT be NULL).\n @param[out] aSize    A pointer to a variable to return the size (number of bytes) of the buffer (MUST NOT be NULL).\n\n @returns A pointer to the buffer.\n"]
    pub fn otSrpClientBuffersGetServiceEntryTxtBuffer(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aSize: *mut u16,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " This function gets the array for service subtype labels from the service entry.\n\n @param[in]  aEntry          A pointer to a previously allocated service entry (MUST NOT be NULL).\n @param[out] aArrayLength    A pointer to a variable to return the array length (MUST NOT be NULL).\n\n @returns A pointer to the array.\n"]
    pub fn otSrpClientBuffersGetSubTypeLabelsArray(
        aEntry: *mut otSrpClientBuffersServiceEntry,
        aArrayLength: *mut u16,
    ) -> *mut *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSrpServerHost {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otSrpServerService {
    _unused: [u8; 0],
}
#[doc = " The ID of a SRP service update transaction on the SRP Server.\n"]
pub type otSrpServerServiceUpdateId = u32;
#[doc = " The service flag type to indicate which services to include or exclude when searching in (or iterating over) the\n list of SRP services.\n\n This is a combination of bit-flags. The specific bit-flags are defined in the enumeration `OT_SRP_SERVER_FLAG_*`.\n"]
pub type otSrpServerServiceFlags = u8;
#[doc = "< Include base services (not a sub-type)."]
pub const OT_SRP_SERVER_SERVICE_FLAG_BASE_TYPE: _bindgen_ty_13 = 1;
#[doc = "< Include sub-type services."]
pub const OT_SRP_SERVER_SERVICE_FLAG_SUB_TYPE: _bindgen_ty_13 = 2;
#[doc = "< Include active (not deleted) services."]
pub const OT_SRP_SERVER_SERVICE_FLAG_ACTIVE: _bindgen_ty_13 = 4;
#[doc = "< Include deleted services."]
pub const OT_SRP_SERVER_SERVICE_FLAG_DELETED: _bindgen_ty_13 = 8;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
#[doc = " This constant defines an `otSrpServerServiceFlags` combination accepting any service (base/sub-type,\n active/deleted).\n"]
pub const OT_SRP_SERVER_FLAGS_ANY_SERVICE: _bindgen_ty_14 = 15;
#[doc = " This constant defines an `otSrpServerServiceFlags` combination accepting base service only.\n"]
pub const OT_SRP_SERVER_FLAGS_BASE_TYPE_SERVICE_ONLY: _bindgen_ty_14 = 13;
#[doc = " This constant defines an `otSrpServerServiceFlags` combination accepting sub-type service only.\n"]
pub const OT_SRP_SERVER_FLAGS_SUB_TYPE_SERVICE_ONLY: _bindgen_ty_14 = 14;
#[doc = " This constant defines an `otSrpServerServiceFlags` combination accepting any active service (not deleted).\n"]
pub const OT_SRP_SERVER_FLAGS_ANY_TYPE_ACTIVE_SERVICE: _bindgen_ty_14 = 7;
#[doc = " This constant defines an `otSrpServerServiceFlags` combination accepting any deleted service.\n"]
pub const OT_SRP_SERVER_FLAGS_ANY_TYPE_DELETED_SERVICE: _bindgen_ty_14 = 7;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
#[doc = "< The SRP server is disabled."]
pub const OT_SRP_SERVER_STATE_DISABLED: otSrpServerState = 0;
#[doc = "< The SRP server is enabled and running."]
pub const OT_SRP_SERVER_STATE_RUNNING: otSrpServerState = 1;
#[doc = "< The SRP server is enabled but stopped."]
pub const OT_SRP_SERVER_STATE_STOPPED: otSrpServerState = 2;
#[doc = " This enumeration represents the state of the SRP server.\n"]
pub type otSrpServerState = ::std::os::raw::c_uint;
#[doc = "< Unicast address mode."]
pub const OT_SRP_SERVER_ADDRESS_MODE_UNICAST: otSrpServerAddressMode = 0;
#[doc = "< Anycast address mode."]
pub const OT_SRP_SERVER_ADDRESS_MODE_ANYCAST: otSrpServerAddressMode = 1;
#[doc = " This enumeration represents the address mode used by the SRP server.\n\n Address mode specifies how the address and port number are determined by the SRP server and how this info is\n published in the Thread Network Data.\n"]
pub type otSrpServerAddressMode = ::std::os::raw::c_uint;
#[doc = " This structure includes SRP server TTL configurations.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otSrpServerTtlConfig {
    #[doc = "< The minimum TTL in seconds."]
    pub mMinTtl: u32,
    #[doc = "< The maximum TTL in seconds."]
    pub mMaxTtl: u32,
}
#[doc = " This structure includes SRP server LEASE and KEY-LEASE configurations.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otSrpServerLeaseConfig {
    #[doc = "< The minimum LEASE interval in seconds."]
    pub mMinLease: u32,
    #[doc = "< The maximum LEASE interval in seconds."]
    pub mMaxLease: u32,
    #[doc = "< The minimum KEY-LEASE interval in seconds."]
    pub mMinKeyLease: u32,
    #[doc = "< The maximum KEY-LEASE interval in seconds."]
    pub mMaxKeyLease: u32,
}
#[doc = " This structure includes SRP server lease information of a host/service.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otSrpServerLeaseInfo {
    #[doc = "< The lease time of a host/service in milliseconds."]
    pub mLease: u32,
    #[doc = "< The key lease time of a host/service in milliseconds."]
    pub mKeyLease: u32,
    #[doc = "< The remaining lease time of the host/service in milliseconds."]
    pub mRemainingLease: u32,
    #[doc = "< The remaining key lease time of a host/service in milliseconds."]
    pub mRemainingKeyLease: u32,
}
#[doc = " This structure includes the statistics of SRP server responses.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otSrpServerResponseCounters {
    #[doc = "< The number of successful responses."]
    pub mSuccess: u32,
    #[doc = "< The number of server failure responses."]
    pub mServerFailure: u32,
    #[doc = "< The number of format error responses."]
    pub mFormatError: u32,
    #[doc = "< The number of 'name exists' responses."]
    pub mNameExists: u32,
    #[doc = "< The number of refused responses."]
    pub mRefused: u32,
    #[doc = "< The number of other responses."]
    pub mOther: u32,
}
extern "C" {
    #[doc = " This function returns the domain authorized to the SRP server.\n\n If the domain if not set by SetDomain, \"default.service.arpa.\" will be returned.\n A trailing dot is always appended even if the domain is set without it.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns A pointer to the dot-joined domain string.\n"]
    pub fn otSrpServerGetDomain(aInstance: *mut otInstance) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function sets the domain on the SRP server.\n\n A trailing dot will be appended to @p aDomain if it is not already there.\n This function should only be called before the SRP server is enabled.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aDomain    The domain to be set. MUST NOT be NULL.\n\n @retval  OT_ERROR_NONE           Successfully set the domain to @p aDomain.\n @retval  OT_ERROR_INVALID_STATE  The SRP server is already enabled and the Domain cannot be changed.\n @retval  OT_ERROR_INVALID_ARGS   The argument @p aDomain is not a valid DNS domain name.\n @retval  OT_ERROR_NO_BUFS        There is no memory to store content of @p aDomain.\n"]
    pub fn otSrpServerSetDomain(
        aInstance: *mut otInstance,
        aDomain: *const ::std::os::raw::c_char,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns the state of the SRP server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns The current state of the SRP server.\n"]
    pub fn otSrpServerGetState(aInstance: *mut otInstance) -> otSrpServerState;
}
extern "C" {
    #[doc = " This function returns the port the SRP server is listening to.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns  The port of the SRP server. It returns 0 if the server is not running.\n"]
    pub fn otSrpServerGetPort(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " This function returns the address mode being used by the SRP server.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n\n @returns The SRP server's address mode.\n"]
    pub fn otSrpServerGetAddressMode(aInstance: *mut otInstance) -> otSrpServerAddressMode;
}
extern "C" {
    #[doc = " This function sets the address mode to be used by the SRP server.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n @param[in] aMode      The address mode to use.\n\n @retval OT_ERROR_NONE           Successfully set the address mode.\n @retval OT_ERROR_INVALID_STATE  The SRP server is enabled and the address mode cannot be changed.\n"]
    pub fn otSrpServerSetAddressMode(
        aInstance: *mut otInstance,
        aMode: otSrpServerAddressMode,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns the sequence number used with anycast address mode.\n\n The sequence number is included in \"DNS/SRP Service Anycast Address\" entry published in the Network Data.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n\n @returns The anycast sequence number.\n"]
    pub fn otSrpServerGetAnycastModeSequenceNumber(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " This function sets the sequence number used with anycast address mode.\n\n @param[in] aInstance        A pointer to an OpenThread instance.\n @param[in] aSequenceNumber  The sequence number to use.\n\n @retval OT_ERROR_NONE            Successfully set the address mode.\n @retval OT_ERROR_INVALID_STATE   The SRP server is enabled and the sequence number cannot be changed.\n"]
    pub fn otSrpServerSetAnycastModeSequenceNumber(
        aInstance: *mut otInstance,
        aSequenceNumber: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function enables/disables the SRP server.\n\n On a Border Router, it is recommended to use `otSrpServerSetAutoEnableMode()` instead.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aEnabled   A boolean to enable/disable the SRP server.\n"]
    pub fn otSrpServerSetEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " This function enables/disables the auto-enable mode on SRP server.\n\n This function requires `OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE` feature.\n\n When this mode is enabled, the Border Routing Manager controls if/when to enable or disable the SRP server.\n SRP sever is auto-enabled if/when Border Routing is started and it is done with the initial prefix and route\n configurations (when the OMR and on-link prefixes are determined, advertised in emitted Router Advertisement message\n on infrastructure side and published in the Thread Network Data). The SRP server is auto-disabled if/when BR is\n stopped (e.g., if the infrastructure network interface is brought down or if BR gets detached).\n\n This mode can be disabled by a `otSrpServerSetAutoEnableMode()` call with @p aEnabled set to `false` or if the SRP\n server is explicitly enabled or disabled by a call to `otSrpServerSetEnabled()` function. Disabling auto-enable mode\n using `otSrpServerSetAutoEnableMode(false)` will not change the current state of SRP sever (e.g., if it is enabled\n it stays enabled).\n\n @param[in] aInstance   A pointer to an OpenThread instance.\n @param[in] aEnabled    A boolean to enable/disable the auto-enable mode.\n"]
    pub fn otSrpServerSetAutoEnableMode(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " This function indicates whether the auto-enable mode is enabled or disabled.\n\n This function requires `OPENTHREAD_CONFIG_BORDER_ROUTING_ENABLE` feature.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @retval TRUE   The auto-enable mode is enabled.\n @retval FALSE  The auto-enable mode is disabled.\n"]
    pub fn otSrpServerIsAutoEnableMode(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function returns SRP server TTL configuration.\n\n @param[in]   aInstance   A pointer to an OpenThread instance.\n @param[out]  aTtlConfig  A pointer to an `otSrpServerTtlConfig` instance.\n"]
    pub fn otSrpServerGetTtlConfig(
        aInstance: *mut otInstance,
        aTtlConfig: *mut otSrpServerTtlConfig,
    );
}
extern "C" {
    #[doc = " This function sets SRP server TTL configuration.\n\n The granted TTL will always be no greater than the max lease interval configured via `otSrpServerSetLeaseConfig()`,\n regardless of the minimum and maximum TTL configuration.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aTtlConfig  A pointer to an `otSrpServerTtlConfig` instance.\n\n @retval  OT_ERROR_NONE          Successfully set the TTL configuration.\n @retval  OT_ERROR_INVALID_ARGS  The TTL configuration is not valid.\n"]
    pub fn otSrpServerSetTtlConfig(
        aInstance: *mut otInstance,
        aTtlConfig: *const otSrpServerTtlConfig,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns SRP server LEASE and KEY-LEASE configurations.\n\n @param[in]   aInstance     A pointer to an OpenThread instance.\n @param[out]  aLeaseConfig  A pointer to an `otSrpServerLeaseConfig` instance.\n"]
    pub fn otSrpServerGetLeaseConfig(
        aInstance: *mut otInstance,
        aLeaseConfig: *mut otSrpServerLeaseConfig,
    );
}
extern "C" {
    #[doc = " This function sets SRP server LEASE and KEY-LEASE configurations.\n\n When a non-zero LEASE time is requested from a client, the granted value will be\n limited in range [aMinLease, aMaxLease]; and a non-zero KEY-LEASE will be granted\n in range [aMinKeyLease, aMaxKeyLease]. For zero LEASE or KEY-LEASE time, zero will\n be granted.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aLeaseConfig  A pointer to an `otSrpServerLeaseConfig` instance.\n\n @retval  OT_ERROR_NONE          Successfully set the LEASE and KEY-LEASE ranges.\n @retval  OT_ERROR_INVALID_ARGS  The LEASE or KEY-LEASE range is not valid.\n"]
    pub fn otSrpServerSetLeaseConfig(
        aInstance: *mut otInstance,
        aLeaseConfig: *const otSrpServerLeaseConfig,
    ) -> otError;
}
#[doc = " This function handles SRP service updates.\n\n This function is called by the SRP server to notify that a SRP host and possibly SRP services\n are being updated. It is important that the SRP updates are not committed until the handler\n returns the result by calling otSrpServerHandleServiceUpdateResult or times out after @p aTimeout.\n\n A SRP service observer should always call otSrpServerHandleServiceUpdateResult with error code\n OT_ERROR_NONE immediately after receiving the update events.\n\n A more generic handler may perform validations on the SRP host/services and rejects the SRP updates\n if any validation fails. For example, an Advertising Proxy should advertise (or remove) the host and\n services on a multicast-capable link and returns specific error code if any failure occurs.\n\n @param[in]  aId       The service update transaction ID. This ID must be passed back with\n                       `otSrpServerHandleServiceUpdateResult`.\n @param[in]  aHost     A pointer to the otSrpServerHost object which contains the SRP updates. The\n                       handler should publish/un-publish the host and each service points to this\n                       host with below rules:\n                         1. If the host is not deleted (indicated by `otSrpServerHostIsDeleted`),\n                            then it should be published or updated with mDNS. Otherwise, the host\n                            should be un-published (remove AAAA RRs).\n                         2. For each service points to this host, it must be un-published if the host\n                            is to be un-published. Otherwise, the handler should publish or update the\n                            service when it is not deleted (indicated by `otSrpServerServiceIsDeleted`)\n                            and un-publish it when deleted.\n @param[in]  aTimeout  The maximum time in milliseconds for the handler to process the service event.\n @param[in]  aContext  A pointer to application-specific context.\n\n @sa otSrpServerSetServiceUpdateHandler\n @sa otSrpServerHandleServiceUpdateResult\n"]
pub type otSrpServerServiceUpdateHandler = ::std::option::Option<
    unsafe extern "C" fn(
        aId: otSrpServerServiceUpdateId,
        aHost: *const otSrpServerHost,
        aTimeout: u32,
        aContext: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " This function sets the SRP service updates handler on SRP server.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aServiceHandler  A pointer to a service handler. Use NULL to remove the handler.\n @param[in]  aContext         A pointer to arbitrary context information.\n                              May be NULL if not used.\n"]
    pub fn otSrpServerSetServiceUpdateHandler(
        aInstance: *mut otInstance,
        aServiceHandler: otSrpServerServiceUpdateHandler,
        aContext: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " This function reports the result of processing a SRP update to the SRP server.\n\n The Service Update Handler should call this function to return the result of its\n processing of a SRP update.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aId        The service update transaction ID. This should be the same ID\n                        provided via `otSrpServerServiceUpdateHandler`.\n @param[in]  aError     An error to be returned to the SRP server. Use OT_ERROR_DUPLICATED\n                        to represent DNS name conflicts.\n"]
    pub fn otSrpServerHandleServiceUpdateResult(
        aInstance: *mut otInstance,
        aId: otSrpServerServiceUpdateId,
        aError: otError,
    );
}
extern "C" {
    #[doc = " This function returns the next registered host on the SRP server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aHost      A pointer to current host; use NULL to get the first host.\n\n @returns  A pointer to the registered host. NULL, if no more hosts can be found.\n"]
    pub fn otSrpServerGetNextHost(
        aInstance: *mut otInstance,
        aHost: *const otSrpServerHost,
    ) -> *const otSrpServerHost;
}
extern "C" {
    #[doc = " This function returns the response counters of the SRP server.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns  A pointer to the response counters of the SRP server.\n"]
    pub fn otSrpServerGetResponseCounters(
        aInstance: *mut otInstance,
    ) -> *const otSrpServerResponseCounters;
}
extern "C" {
    #[doc = " This function tells if the SRP service host has been deleted.\n\n A SRP service host can be deleted but retains its name for future uses.\n In this case, the host instance is not removed from the SRP server/registry.\n\n @param[in]  aHost  A pointer to the SRP service host.\n\n @returns  TRUE if the host has been deleted, FALSE if not.\n"]
    pub fn otSrpServerHostIsDeleted(aHost: *const otSrpServerHost) -> bool;
}
extern "C" {
    #[doc = " This function returns the full name of the host.\n\n @param[in]  aHost  A pointer to the SRP service host.\n\n @returns  A pointer to the null-terminated host name string.\n"]
    pub fn otSrpServerHostGetFullName(
        aHost: *const otSrpServerHost,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function returns the addresses of given host.\n\n @param[in]   aHost          A pointer to the SRP service host.\n @param[out]  aAddressesNum  A pointer to where we should output the number of the addresses to.\n\n @returns  A pointer to the array of IPv6 Address.\n"]
    pub fn otSrpServerHostGetAddresses(
        aHost: *const otSrpServerHost,
        aAddressesNum: *mut u8,
    ) -> *const otIp6Address;
}
extern "C" {
    #[doc = " This function returns the LEASE and KEY-LEASE information of a given host.\n\n @param[in]   aHost       A pointer to the SRP server host.\n @param[out]  aLeaseInfo  A pointer to where to output the LEASE and KEY-LEASE information.\n"]
    pub fn otSrpServerHostGetLeaseInfo(
        aHost: *const otSrpServerHost,
        aLeaseInfo: *mut otSrpServerLeaseInfo,
    );
}
extern "C" {
    #[doc = " This function returns the next service (excluding any sub-type services) of given host.\n\n @note This function is being deprecated and will be removed. `otSrpServerHostFindNextService()` can be used\n       instead.\n\n @param[in]  aHost     A pointer to the SRP service host.\n @param[in]  aService  A pointer to current SRP service instance; use NULL to get the first service.\n\n @returns  A pointer to the next service or NULL if there is no more services.\n"]
    pub fn otSrpServerHostGetNextService(
        aHost: *const otSrpServerHost,
        aService: *const otSrpServerService,
    ) -> *const otSrpServerService;
}
extern "C" {
    #[doc = " This function finds the next matching service on the host.\n\n The combination of flags and service and instance names enables iterating over the full list of services and/or a\n subset of them matching certain conditions, or finding a specific service.\n\n To iterate over all services of a host:\n   service = otSrpServerHostFindNextService(host, service, OT_SRP_SERVER_FLAGS_ANY_SERVICE, NULL, NULL);\n\n To iterate over base services only (exclude sub-types):\n   service = otSrpServerHostFindNextService(host, service, OT_SRP_SERVER_FLAGS_BASE_TYPE_SERVICE_ONLY, NULL, NULL);\n\n To iterate over sub-types of a specific instance name `instanceName`:\n   service = otSrpServerHostFindNextService(host, service, OT_SRP_SERVER_FLAGS_SUB_TYPE_SERVICE_ONLY, NULL,\n                                            instanceName);\n\n To find a specific service with service name `serviceName` and service instance name `instanceName`:\n   service = otSrpServerHostFindNextService(host, NULL, OT_SRP_SERVER_FLAGS_ANY_SERVICE, serviceName, instanceName);\n\n To find the base type service with a given service instance name `instanceName`:\n   service = otSrpServerHostFindNextService(host, NULL, OT_SRP_SERVER_FLAGS_BASE_TYPE_SERVICE_ONLY, NULL,\n                                            instanceName);\n\n @param[in] aHost          A pointer to the SRP service host (MUST NOT be NULL).\n @param[in] aPrevService   A pointer to the previous service or NULL to start from the beginning of the list.\n @param[in] aFlags         Flags indicating which services to include (base/sub-type, active/deleted).\n @param[in] aServiceName   The service name to match. Set to NULL to accept any name.\n @param[in] aInstanceName  The service instance name to match. Set to NULL to accept any name.\n\n @returns  A pointer to the next matching service or NULL if no matching service could be found.\n"]
    pub fn otSrpServerHostFindNextService(
        aHost: *const otSrpServerHost,
        aPrevService: *const otSrpServerService,
        aFlags: otSrpServerServiceFlags,
        aServiceName: *const ::std::os::raw::c_char,
        aInstanceName: *const ::std::os::raw::c_char,
    ) -> *const otSrpServerService;
}
extern "C" {
    #[doc = " This function indicates whether or not the SRP service has been deleted.\n\n A SRP service can be deleted but retains its name for future uses.\n In this case, the service instance is not removed from the SRP server/registry.\n It is guaranteed that all services are deleted if the host is deleted.\n\n @param[in]  aService  A pointer to the SRP service.\n\n @returns  TRUE if the service has been deleted, FALSE if not.\n"]
    pub fn otSrpServerServiceIsDeleted(aService: *const otSrpServerService) -> bool;
}
extern "C" {
    #[doc = " This function indicates whether or not the SRP service is sub-type.\n\n @param[in]  aService  A pointer to the SRP service.\n\n @returns  TRUE if the service is a sub-type, FALSE if not.\n"]
    pub fn otSrpServerServiceIsSubType(aService: *const otSrpServerService) -> bool;
}
extern "C" {
    #[doc = " This function returns the full service instance name of the service.\n\n @note This function is being deprecated and will be removed. `otSrpServerServiceGetInstanceName()` can be used\n       instead.\n\n @param[in]  aService  A pointer to the SRP service.\n\n @returns  A pointer to the null-terminated service instance name string.\n"]
    pub fn otSrpServerServiceGetFullName(
        aService: *const otSrpServerService,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function returns the full service instance name of the service.\n\n @param[in]  aService  A pointer to the SRP service.\n\n @returns  A pointer to the null-terminated service instance name string.\n"]
    pub fn otSrpServerServiceGetInstanceName(
        aService: *const otSrpServerService,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function returns the full service name of the service.\n\n @param[in]  aService  A pointer to the SRP service.\n\n @returns  A pointer to the null-terminated service name string.\n"]
    pub fn otSrpServerServiceGetServiceName(
        aService: *const otSrpServerService,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function gets the sub-type label from service name.\n\n This function is intended to be used when the @p aService is a sub-type, i.e., `otSrpServerServiceIsSubType()` for\n the service returns TRUE. If it is not a sub-type this function returns `OT_ERROR_INVALID_ARGS`.\n\n The full service name for a sub-type service follows \"<sub-label>._sub.<service-labels>.<domain>.\". This function\n copies the `<sub-label>` into the @p aLabel buffer.\n\n The @p aLabel is ensured to always be null-terminated after returning even in case of failure.\n\n @param[in]  aService           A pointer to the SRP service.\n @param[out] aLabel             A pointer to a buffer to copy the sub-type label name into.\n @param[in]  aMaxSize           Maximum size of @p aLabel buffer.\n\n @retval OT_ERROR_NONE          @p aLabel was updated successfully.\n @retval OT_ERROR_NO_BUFS       The sub-type label could not fit in @p aLabel buffer (number of chars from label\n                                that could fit are copied in @p aLabel ensuring it is null-terminated).\n @retval OT_ERROR_INVALID_ARGS  SRP service is not a sub-type.\n"]
    pub fn otSrpServerServiceGetServiceSubTypeLabel(
        aService: *const otSrpServerService,
        aLabel: *mut ::std::os::raw::c_char,
        aMaxSize: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function returns the port of the service instance.\n\n @param[in]  aService  A pointer to the SRP service.\n\n @returns  The port of the service.\n"]
    pub fn otSrpServerServiceGetPort(aService: *const otSrpServerService) -> u16;
}
extern "C" {
    #[doc = " This function returns the weight of the service instance.\n\n @param[in]  aService  A pointer to the SRP service.\n\n @returns  The weight of the service.\n"]
    pub fn otSrpServerServiceGetWeight(aService: *const otSrpServerService) -> u16;
}
extern "C" {
    #[doc = " This function returns the priority of the service instance.\n\n @param[in]  aService  A pointer to the SRP service.\n\n @returns  The priority of the service.\n"]
    pub fn otSrpServerServiceGetPriority(aService: *const otSrpServerService) -> u16;
}
extern "C" {
    #[doc = " This function returns the TTL of the service instance.\n\n @param[in]  aService  A pointer to the SRP service.\n\n @returns  The TTL of the service instance..\n"]
    pub fn otSrpServerServiceGetTtl(aService: *const otSrpServerService) -> u32;
}
extern "C" {
    #[doc = " This function returns the TXT record data of the service instance.\n\n @param[in]  aService        A pointer to the SRP service.\n @param[out] aDataLength     A pointer to return the TXT record data length. MUST NOT be NULL.\n\n @returns A pointer to the buffer containing the TXT record data (the TXT data length is returned in @p aDataLength).\n"]
    pub fn otSrpServerServiceGetTxtData(
        aService: *const otSrpServerService,
        aDataLength: *mut u16,
    ) -> *const u8;
}
extern "C" {
    #[doc = " This function returns the host which the service instance reside on.\n\n @param[in]  aService  A pointer to the SRP service.\n\n @returns  A pointer to the host instance.\n"]
    pub fn otSrpServerServiceGetHost(aService: *const otSrpServerService)
        -> *const otSrpServerHost;
}
extern "C" {
    #[doc = " This function returns the LEASE and KEY-LEASE information of a given service.\n\n @param[in]   aService    A pointer to the SRP server service.\n @param[out]  aLeaseInfo  A pointer to where to output the LEASE and KEY-LEASE information.\n"]
    pub fn otSrpServerServiceGetLeaseInfo(
        aService: *const otSrpServerService,
        aLeaseInfo: *mut otSrpServerLeaseInfo,
    );
}
extern "C" {
    #[doc = " Run all queued OpenThread tasklets at the time this is called.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n"]
    pub fn otTaskletsProcess(aInstance: *mut otInstance);
}
extern "C" {
    #[doc = " Indicates whether or not OpenThread has tasklets pending.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @retval TRUE   If there are tasklets pending.\n @retval FALSE  If there are no tasklets pending.\n"]
    pub fn otTaskletsArePending(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " OpenThread calls this function when the tasklet queue transitions from empty to non-empty.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n"]
    pub fn otTaskletsSignalPending(aInstance: *mut otInstance);
}
#[doc = " A linked buffer structure for use with TCP.\n\n A single otLinkedBuffer structure references an array of bytes in memory,\n via mData and mLength. The mNext field is used to form a chain of\n otLinkedBuffer structures.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otLinkedBuffer {
    #[doc = "< Pointer to the next linked buffer in the chain, or NULL if it is the end."]
    pub mNext: *mut otLinkedBuffer,
    #[doc = "< Pointer to data referenced by this linked buffer."]
    pub mData: *const u8,
    #[doc = "< Length of this linked buffer (number of bytes)."]
    pub mLength: usize,
}
impl Default for otLinkedBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This callback informs the application that the TCP 3-way handshake is\n complete and that the connection is now established.\n\n @param[in]  aEndpoint  The TCP endpoint whose connection is now established.\n"]
pub type otTcpEstablished =
    ::std::option::Option<unsafe extern "C" fn(aEndpoint: *mut otTcpEndpoint)>;
#[doc = " This callback informs the application that data in the provided\n @p aData have been acknowledged by the connection peer and that @p aData and\n the data it contains can be reclaimed by the application.\n\n The @p aData are guaranteed to be identical to those passed in to TCP via\n otTcpSendByReference(), including any extensions effected via\n otTcpSendByExtension().\n\n @param[in]  aEndpoint  The TCP endpoint for the connection.\n @param[in]  aData      A pointer to the otLinkedBuffer that can be reclaimed.\n"]
pub type otTcpSendDone = ::std::option::Option<
    unsafe extern "C" fn(aEndpoint: *mut otTcpEndpoint, aData: *mut otLinkedBuffer),
>;
#[doc = " This callback informs the application if forward progress has been made in\n transferring data from the send buffer to the recipient. This callback is\n not necessary for correct TCP operation. Most applications can just rely on\n the otTcpSendDone() callback to reclaim linked buffers once the TCP stack is\n done using them. The purpose of this callback is to support advanced\n applications that benefit from finer-grained information about how the\n the connection is making forward progress in transferring data to the\n connection peer.\n\n This callback's operation is closely tied to TCP's send buffer. The send\n buffer can be understood as having two regions. First, there is the\n \"in-flight\" region at the head (front) of the send buffer. It corresponds\n to data which has been sent to the recipient, but is not yet acknowledged.\n Second, there is the \"backlog\" region, which consists of all data in the\n send buffer that is not in the \"in-flight\" region. The \"backlog\" region\n corresponds to data that is queued for sending, but has not yet been sent.\n\n The callback is invoked in response to two types of events. First, the\n \"in-flight\" region of the send buffer may shrink (e.g., when the recipient\n acknowledges data that we sent earlier). Second, the \"backlog\" region of the\n send buffer may shrink (e.g., new data was sent out). These two conditions\n often occur at the same time, in response to an ACK segment from the\n connection peer, which is why they are combined in a single callback.\n\n The TCP stack only uses the @p aInSendBuffer bytes at the tail of the send\n buffer; when @p aInSendBuffer decreases by an amount x, it means that x\n additional bytes that were formerly at the head of the send buffer are no\n longer part of the send buffer and can now be reclaimed (i.e., overwritten)\n by the application. Note that the otLinkedBuffer structure itself can only\n be reclaimed once all bytes that it references are no longer part of the\n send buffer.\n\n This callback subsumes otTcpSendDone(), in the following sense: applications\n can determine when linked buffers can be reclaimed by comparing\n @p aInSendBuffer with how many bytes are in each linked buffer. However, we\n expect otTcpSendDone(), which directly conveys which otLinkedBuffers can be\n reclaimed, to be much simpler to use. If both callbacks are registered and\n are triggered by the same event (e.g., the same ACK segment received), then\n the otTcpSendDone() callback will be triggered first, followed by this\n callback.\n\n Additionally, this callback provides @p aBacklog, which indicates how many\n bytes of data in the send buffer are not yet in flight. For applications\n that only want to add data to the send buffer when there is an assurance\n that it will be sent out soon, it may be desirable to only send out data\n when @p aBacklog is suitably small (0 or close to 0). For example, an\n application may use @p aBacklog so that it can react to queue buildup by\n dropping or aggregating data to avoid creating a backlog of data.\n\n After a call to otTcpSendByReference() or otTcpSendByExtension() with a\n positive number of bytes, the otTcpForwardProgress() callback is guaranteed\n to be called, to indicate when the bytes that were added to the send buffer\n are sent out. The call to otTcpForwardProgress() may be made immediately\n after the bytes are added to the send buffer (if some of those bytes are\n immediately sent out, reducing the backlog), or sometime in the future (once\n the connection sends out some or all of the data, reducing the backlog). By\n \"immediately,\" we mean that the callback is immediately scheduled for\n execution in a tasklet; to avoid reentrancy-related complexity, the\n otTcpForwardProgress() callback is never directly called from the\n otTcpSendByReference() or otTcpSendByExtension() functions.\n\n @param[in]  aEndpoint      The TCP endpoint for the connection.\n @param[in]  aInSendBuffer  The number of bytes in the send buffer (sum of \"in-flight\" and \"backlog\" regions).\n @param[in]  aBacklog       The number of bytes that are queued for sending but have not yet been sent (the \"backlog\"\n                            region).\n"]
pub type otTcpForwardProgress = ::std::option::Option<
    unsafe extern "C" fn(aEndpoint: *mut otTcpEndpoint, aInSendBuffer: usize, aBacklog: usize),
>;
#[doc = " This callback indicates the number of bytes available for consumption from\n the receive buffer.\n\n It is called whenever bytes are added to the receive buffer and when the\n end of stream is reached. If the end of the stream has been reached (i.e.,\n if no more data will become available to read because the connection peer\n has closed their end of the connection for writing), then @p aEndOfStream is\n true. Finally, @p aBytesRemaining indicates how much capacity is left in the\n receive buffer to hold additional data that arrives.\n\n @param[in]  aEndpoint        The TCP endpoint for the connection.\n @param[in]  aBytesAvailable  The number of bytes in the connection's receive buffer.\n @param[in]  aEndOfStream     Indicates if additional data, beyond what is already in the connection's receive buffer,\n                              can be received.\n @param[in]  aBytesRemaining  The number of additional bytes that can be received before the receive buffer becomes\n                              full.\n"]
pub type otTcpReceiveAvailable = ::std::option::Option<
    unsafe extern "C" fn(
        aEndpoint: *mut otTcpEndpoint,
        aBytesAvailable: usize,
        aEndOfStream: bool,
        aBytesRemaining: usize,
    ),
>;
pub const OT_TCP_DISCONNECTED_REASON_NORMAL: otTcpDisconnectedReason = 0;
pub const OT_TCP_DISCONNECTED_REASON_REFUSED: otTcpDisconnectedReason = 1;
pub const OT_TCP_DISCONNECTED_REASON_RESET: otTcpDisconnectedReason = 2;
pub const OT_TCP_DISCONNECTED_REASON_TIME_WAIT: otTcpDisconnectedReason = 3;
pub const OT_TCP_DISCONNECTED_REASON_TIMED_OUT: otTcpDisconnectedReason = 4;
pub type otTcpDisconnectedReason = ::std::os::raw::c_uint;
#[doc = " This callback indicates that the connection was broken and should no longer\n be used, or that a connection has entered the TIME-WAIT state.\n\n It can occur if a connection establishment attempt (initiated by calling\n otTcpConnect()) fails, or any point thereafter (e.g., if the connection\n times out or an RST segment is received from the connection peer). Once this\n callback fires, all resources that the application provided for this\n connection (i.e., any `otLinkedBuffers` and memory they reference, but not\n the TCP endpoint itself or space for the receive buffers) can be reclaimed.\n In the case of a connection entering the TIME-WAIT state, this callback is\n called twice, once upon entry into the TIME-WAIT state (with\n OT_TCP_DISCONNECTED_REASON_TIME_WAIT, and again when the TIME-WAIT state\n expires (with OT_TCP_DISCONNECTED_REASON_NORMAL).\n\n @param[in]  aEndpoint  The TCP endpoint whose connection has been lost.\n @param[in]  aReason    The reason why the connection was lost.\n"]
pub type otTcpDisconnected = ::std::option::Option<
    unsafe extern "C" fn(aEndpoint: *mut otTcpEndpoint, aReason: otTcpDisconnectedReason),
>;
#[doc = " This structure represents a TCP endpoint.\n\n An TCP endpoint acts an endpoint of TCP connection. It can be used to\n initiate TCP connections, and, once a TCP connection is established, send\n data to and receive data from the connection peer.\n\n The application should not inspect the fields of this structure directly; it\n should only interact with it via the TCP API functions whose signatures are\n provided in this file.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otTcpEndpoint {
    pub mTcb: otTcpEndpoint__bindgen_ty_1,
    #[doc = "< A pointer to the next TCP endpoint (internal use only)"]
    pub mNext: *mut otTcpEndpoint,
    #[doc = "< A pointer to application-specific context"]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< \"Established\" callback function"]
    pub mEstablishedCallback: otTcpEstablished,
    #[doc = "< \"Send done\" callback function"]
    pub mSendDoneCallback: otTcpSendDone,
    #[doc = "< \"Forward progress\" callback function"]
    pub mForwardProgressCallback: otTcpForwardProgress,
    #[doc = "< \"Receive available\" callback function"]
    pub mReceiveAvailableCallback: otTcpReceiveAvailable,
    #[doc = "< \"Disconnected\" callback function"]
    pub mDisconnectedCallback: otTcpDisconnected,
    pub mTimers: [u32; 4usize],
    pub mReceiveLinks: [otLinkedBuffer; 2usize],
    pub mSockAddr: otSockAddr,
    pub mPendingCallbacks: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otTcpEndpoint__bindgen_ty_1 {
    pub mSize: [u8; 656usize],
    pub mAlign: u64,
}
impl Default for otTcpEndpoint__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otTcpEndpoint {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure contains arguments to the otTcpEndpointInitialize() function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otTcpEndpointInitializeArgs {
    #[doc = "< Pointer to application-specific context"]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< \"Established\" callback function"]
    pub mEstablishedCallback: otTcpEstablished,
    #[doc = "< \"Send done\" callback function"]
    pub mSendDoneCallback: otTcpSendDone,
    #[doc = "< \"Forward progress\" callback function"]
    pub mForwardProgressCallback: otTcpForwardProgress,
    #[doc = "< \"Receive available\" callback function"]
    pub mReceiveAvailableCallback: otTcpReceiveAvailable,
    #[doc = "< \"Disconnected\" callback function"]
    pub mDisconnectedCallback: otTcpDisconnected,
    #[doc = "< Pointer to memory provided to the system for the TCP receive buffer"]
    pub mReceiveBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< Size of memory provided to the system for the TCP receive buffer"]
    pub mReceiveBufferSize: usize,
}
impl Default for otTcpEndpointInitializeArgs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Initializes a TCP endpoint.\n\n Calling this function causes OpenThread to keep track of the TCP endpoint\n and store and retrieve TCP data inside the @p aEndpoint. The application\n should refrain from directly accessing or modifying the fields in\n @p aEndpoint. If the application needs to reclaim the memory backing\n @p aEndpoint, it should call otTcpEndpointDeinitialize().\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aEndpoint  A pointer to a TCP endpoint structure.\n @param[in]  aArgs      A pointer to a structure of arguments.\n\n @retval OT_ERROR_NONE    Successfully opened the TCP endpoint.\n @retval OT_ERROR_FAILED  Failed to open the TCP endpoint.\n"]
    pub fn otTcpEndpointInitialize(
        aInstance: *mut otInstance,
        aEndpoint: *mut otTcpEndpoint,
        aArgs: *const otTcpEndpointInitializeArgs,
    ) -> otError;
}
extern "C" {
    #[doc = " Obtains the otInstance that was associated with @p aEndpoint upon\n initialization.\n\n @param[in]  aEndpoint  The TCP endpoint whose instance to obtain.\n\n @returns  The otInstance pointer associated with @p aEndpoint.\n"]
    pub fn otTcpEndpointGetInstance(aEndpoint: *mut otTcpEndpoint) -> *mut otInstance;
}
extern "C" {
    #[doc = " Obtains the context pointer that was associated with @p aEndpoint upon\n initialization.\n\n @param[in]  aEndpoint  The TCP endpoint whose context to obtain.\n\n @returns  The context pointer associated with @p aEndpoint.\n"]
    pub fn otTcpEndpointGetContext(aEndpoint: *mut otTcpEndpoint) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Obtains a pointer to a TCP endpoint's local host and port.\n\n The contents of the host and port may be stale if this socket is not in a\n connected state and has not been bound after it was last disconnected.\n\n @param[in]  aEndpoint  The TCP endpoint whose local host and port to obtain.\n\n @returns  The local host and port of @p aEndpoint.\n"]
    pub fn otTcpGetLocalAddress(aEndpoint: *const otTcpEndpoint) -> *const otSockAddr;
}
extern "C" {
    #[doc = " Obtains a pointer to a TCP endpoint's peer's host and port.\n\n The contents of the host and port may be stale if this socket is not in a\n connected state.\n\n @param[in]  aEndpoint  The TCP endpoint whose peer's host and port to obtain.\n\n @returns  The host and port of the connection peer of @p aEndpoint.\n"]
    pub fn otTcpGetPeerAddress(aEndpoint: *const otTcpEndpoint) -> *const otSockAddr;
}
extern "C" {
    #[doc = " Binds the TCP endpoint to an IP address and port.\n\n @param[in]  aEndpoint   A pointer to the TCP endpoint structure to bind.\n @param[in]  aSockName   The address and port to which to bind this TCP endpoint.\n\n @retval OT_ERROR_NONE    Successfully bound the TCP endpoint.\n @retval OT_ERROR_FAILED  Failed to bind the TCP endpoint.\n"]
    pub fn otTcpBind(aEndpoint: *mut otTcpEndpoint, aSockName: *const otSockAddr) -> otError;
}
pub const OT_TCP_CONNECT_NO_FAST_OPEN: _bindgen_ty_15 = 1;
#[doc = " This enumeration defines flags passed to otTcpConnect().\n"]
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Records the remote host and port for this connection.\n\n Caller must wait for `otTcpEstablished` callback indicating that TCP\n connection establishment handshake is done before it can start sending data\n e.g., calling `otTcpSendByReference()`.\n\n The TCP Fast Open is not yet supported and @p aFlags is ignored.\n\n @param[in]  aEndpoint  A pointer to the TCP endpoint structure to connect.\n @param[in]  aSockName  The IP address and port of the host to which to connect.\n @param[in]  aFlags     Flags specifying options for this operation (see enumeration above).\n\n @retval OT_ERROR_NONE    Successfully completed the operation.\n @retval OT_ERROR_FAILED  Failed to complete the operation.\n"]
    pub fn otTcpConnect(
        aEndpoint: *mut otTcpEndpoint,
        aSockName: *const otSockAddr,
        aFlags: u32,
    ) -> otError;
}
pub const OT_TCP_SEND_MORE_TO_COME: _bindgen_ty_16 = 1;
#[doc = " This enumeration defines flags passed to @p otTcpSendByReference.\n"]
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Adds data referenced by the linked buffer pointed to by @p aBuffer to the\n send buffer.\n\n Upon a successful call to this function, the linked buffer and data it\n references are owned by the TCP stack; they should not be modified by the\n application until a \"send done\" callback returns ownership of those objects\n to the application. It is acceptable to call this function to add another\n linked buffer to the send queue, even if the \"send done\" callback for a\n previous invocation of this function has not yet fired.\n\n Note that @p aBuffer should not be chained; its mNext field should be\n NULL. If additional data will be added right after this call, then the\n OT_TCP_SEND_MORE_TO_COME flag should be used as a hint to the TCP\n implementation.\n\n @param[in]  aEndpoint  A pointer to the TCP endpoint structure representing the TCP endpoint on which to send data.\n @param[in]  aBuffer    A pointer to the linked buffer chain referencing data to add to the send buffer.\n @param[in]  aFlags     Flags specifying options for this operation (see enumeration above).\n\n @retval OT_ERROR_NONE    Successfully added data to the send buffer.\n @retval OT_ERROR_FAILED  Failed to add data to the send buffer.\n"]
    pub fn otTcpSendByReference(
        aEndpoint: *mut otTcpEndpoint,
        aBuffer: *mut otLinkedBuffer,
        aFlags: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " Adds data to the send buffer by extending the length of the final\n otLinkedBuffer in the send buffer by the specified amount.\n\n If the send buffer is empty, then the operation fails.\n\n @param[in]  aEndpoint  A pointer to the TCP endpoint structure representing the TCP endpoint on which to send data.\n @param[in]  aNumBytes  The number of bytes by which to extend the length of the final linked buffer.\n @param[in]  aFlags     Flags specifying options for this operation (see enumeration above).\n\n @retval OT_ERROR_NONE    Successfully added data to the send buffer.\n @retval OT_ERROR_FAILED  Failed to add data to the send buffer.\n"]
    pub fn otTcpSendByExtension(
        aEndpoint: *mut otTcpEndpoint,
        aNumBytes: usize,
        aFlags: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " Provides the application with a linked buffer chain referencing data\n currently in the TCP receive buffer.\n\n The linked buffer chain is valid until the \"receive ready\" callback is next\n invoked, or until the next call to otTcpReceiveContiguify() or\n otTcpCommitReceive().\n\n @param[in]   aEndpoint  A pointer to the TCP endpoint structure representing the TCP endpoint on which to receive\n                         data.\n @param[out]  aBuffer    A pointer to the linked buffer chain referencing data currently in the receive buffer.\n\n @retval OT_ERROR_NONE    Successfully completed the operation.\n @retval OT_ERROR_FAILED  Failed to complete the operation.\n"]
    pub fn otTcpReceiveByReference(
        aEndpoint: *mut otTcpEndpoint,
        aBuffer: *mut *const otLinkedBuffer,
    ) -> otError;
}
extern "C" {
    #[doc = " Reorganizes the receive buffer to be entirely contiguous in memory.\n\n This is optional; an application can simply traverse the linked buffer\n chain obtained by calling @p otTcpReceiveByReference. Some\n applications may wish to call this function to make the receive buffer\n contiguous to simplify their data processing, but this comes at the expense\n of CPU time to reorganize the data in the receive buffer.\n\n @param[in]   aEndpoint  A pointer to the TCP endpoint whose receive buffer to reorganize.\n\n @retval OT_ERROR_NONE    Successfully completed the operation.\n @retval OT_ERROR_FAILED  Failed to complete the operation.\n"]
    pub fn otTcpReceiveContiguify(aEndpoint: *mut otTcpEndpoint) -> otError;
}
extern "C" {
    #[doc = " Informs the TCP stack that the application has finished processing\n @p aNumBytes bytes of data at the start of the receive buffer and that the\n TCP stack need not continue maintaining those bytes in the receive buffer.\n\n @param[in]  aEndpoint  A pointer to the TCP endpoint structure representing the TCP endpoint on which to receive\n                        data.\n @param[in]  aNumBytes  The number of bytes consumed.\n @param[in]  aFlags     Flags specifying options for this operation (none yet).\n\n @retval OT_ERROR_NONE    Successfully completed the receive operation.\n @retval OT_ERROR_FAILED  Failed to complete the receive operation.\n"]
    pub fn otTcpCommitReceive(
        aEndpoint: *mut otTcpEndpoint,
        aNumBytes: usize,
        aFlags: u32,
    ) -> otError;
}
extern "C" {
    #[doc = " Informs the connection peer that this TCP endpoint will not send more data.\n\n This should be used when the application has no more data to send to the\n connection peer. For this connection, future reads on the connection peer\n will result in the \"end of stream\" condition, and future writes on this\n connection endpoint will fail.\n\n The \"end of stream\" condition only applies after any data previously\n provided to the TCP stack to send out has been received by the connection\n peer.\n\n @param[in]  aEndpoint  A pointer to the TCP endpoint structure representing the TCP endpoint to shut down.\n\n @retval OT_ERROR_NONE    Successfully queued the \"end of stream\" condition for transmission.\n @retval OT_ERROR_FAILED  Failed to queue the \"end of stream\" condition for transmission.\n"]
    pub fn otTcpSendEndOfStream(aEndpoint: *mut otTcpEndpoint) -> otError;
}
extern "C" {
    #[doc = " Forcibly ends the TCP connection associated with this TCP endpoint.\n\n This immediately makes the TCP endpoint free for use for another connection\n and empties the send and receive buffers, transferring ownership of any data\n provided by the application in otTcpSendByReference() and\n otTcpSendByExtension() calls back to the application. The TCP endpoint's\n callbacks and memory for the receive buffer remain associated with the\n TCP endpoint.\n\n @param[in]  aEndpoint  A pointer to the TCP endpoint structure representing the TCP endpoint to abort.\n\n @retval OT_ERROR_NONE    Successfully aborted the TCP endpoint's connection.\n @retval OT_ERROR_FAILED  Failed to abort the TCP endpoint's connection.\n"]
    pub fn otTcpAbort(aEndpoint: *mut otTcpEndpoint) -> otError;
}
extern "C" {
    #[doc = " Deinitializes this TCP endpoint.\n\n This means that OpenThread no longer keeps track of this TCP endpoint and\n deallocates all resources it has internally allocated for this TCP endpoint.\n The application can reuse the memory backing the TCP endpoint as it sees fit.\n\n If it corresponds to a live TCP connection, the connection is terminated\n unceremoniously (as in otTcpAbort()). All resources the application has\n provided for this TCP endpoint (linked buffers for the send buffer, memory\n for the receive buffer, the @p aEndpoint structure itself, etc.) are\n immediately returned to the application.\n\n @param[in]  aEndpoint  A pointer to the TCP endpoint structure to deinitialize.\n\n @retval OT_ERROR_NONE    Successfully deinitialized the TCP endpoint.\n @retval OT_ERROR_FAILED  Failed to deinitialize the TCP endpoint.\n"]
    pub fn otTcpEndpointDeinitialize(aEndpoint: *mut otTcpEndpoint) -> otError;
}
#[doc = "< Accept the incoming connection."]
pub const OT_TCP_INCOMING_CONNECTION_ACTION_ACCEPT: otTcpIncomingConnectionAction = 0;
#[doc = "< Defer (silently ignore) the incoming connection."]
pub const OT_TCP_INCOMING_CONNECTION_ACTION_DEFER: otTcpIncomingConnectionAction = 1;
#[doc = "< Refuse the incoming connection."]
pub const OT_TCP_INCOMING_CONNECTION_ACTION_REFUSE: otTcpIncomingConnectionAction = 2;
#[doc = " This enumeration defines incoming connection actions.\n\n This is used in otTcpAcceptReady() callback.\n"]
pub type otTcpIncomingConnectionAction = ::std::os::raw::c_uint;
#[doc = " This callback indicates that an incoming connection that matches this TCP\n listener has arrived.\n\n The typical response is for the application to accept the incoming\n connection. It does so by populating @p aAcceptInto with a pointer to the\n otTcpEndpoint into which to accept the incoming connection. This\n otTcpEndpoint must already be initialized using otTcpEndpointInitialize().\n Then, the application returns OT_TCP_INCOMING_CONNECTION_ACTION_ACCEPT.\n\n Alternatively, the application can decline to accept the incoming\n connection. There are two ways for the application to do this. First, if the\n application returns OT_TCP_INCOMING_CONNECTION_ACTION_DEFER, then OpenThread\n silently ignores the connection establishment request; the connection peer\n will likely retransmit the request, at which point the callback will be\n called again. This is valuable if resources are not presently available to\n accept the connection, but they may be available when the connection peer\n retransmits its connection establishment attempt. Second, if the application\n returns OT_TCP_INCOMING_CONNECTION_ACTION_REFUSE, then OpenThread sends a\n \"connection refused\" message to the host that attempted to establish a\n connection. If the application declines the incoming connection, it is not\n required to populate @p aAcceptInto.\n\n @param[in]   aListener    The TCP listener that matches the incoming connection.\n @param[in]   aPeer        The host and port from which the incoming connection originates.\n @param[out]  aAcceptInto  The TCP endpoint into which to accept the incoming connection.\n\n @returns  Description of how to handle the incoming connection.\n"]
pub type otTcpAcceptReady = ::std::option::Option<
    unsafe extern "C" fn(
        aListener: *mut otTcpListener,
        aPeer: *const otSockAddr,
        aAcceptInto: *mut *mut otTcpEndpoint,
    ) -> otTcpIncomingConnectionAction,
>;
#[doc = " This callback indicates that the TCP connection is now ready for two-way\n communication.\n\n In the case of TCP Fast Open, this may be before the TCP\n connection handshake has actually completed. The application is provided\n with the context pointers both for the TCP listener that accepted the\n connection and the TCP endpoint into which it was accepted. The provided\n context is the one associated with the TCP listener.\n\n @param[in]  aListener  The TCP listener that matches the incoming connection.\n @param[in]  aEndpoint  The TCP endpoint into which the incoming connection was accepted.\n @param[in]  aPeer      the host and port from which the incoming connection originated.\n"]
pub type otTcpAcceptDone = ::std::option::Option<
    unsafe extern "C" fn(
        aListener: *mut otTcpListener,
        aEndpoint: *mut otTcpEndpoint,
        aPeer: *const otSockAddr,
    ),
>;
#[doc = " This structure represents a TCP listener.\n\n A TCP listener is used to listen for and accept incoming TCP connections.\n\n The application should not inspect the fields of this structure directly; it\n should only interact with it via the TCP API functions whose signatures are\n provided in this file.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otTcpListener {
    pub mTcbListen: otTcpListener__bindgen_ty_1,
    #[doc = "< A pointer to the next TCP listener (internal use only)"]
    pub mNext: *mut otTcpListener,
    #[doc = "< A pointer to application-specific context"]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< \"Accept ready\" callback function"]
    pub mAcceptReadyCallback: otTcpAcceptReady,
    #[doc = "< \"Accept done\" callback function"]
    pub mAcceptDoneCallback: otTcpAcceptDone,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otTcpListener__bindgen_ty_1 {
    pub mSize: [u8; 40usize],
    pub mAlign: *mut ::std::os::raw::c_void,
}
impl Default for otTcpListener__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otTcpListener {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This structure contains arguments to the otTcpListenerInitialize() function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otTcpListenerInitializeArgs {
    #[doc = "< Pointer to application-specific context"]
    pub mContext: *mut ::std::os::raw::c_void,
    #[doc = "< \"Accept ready\" callback function"]
    pub mAcceptReadyCallback: otTcpAcceptReady,
    #[doc = "< \"Accept done\" callback function"]
    pub mAcceptDoneCallback: otTcpAcceptDone,
}
impl Default for otTcpListenerInitializeArgs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Initializes a TCP listener.\n\n Calling this function causes OpenThread to keep track of the TCP listener\n and store and retrieve TCP data inside @p aListener. The application should\n refrain from directly accessing or modifying the fields in @p aListener. If\n the application needs to reclaim the memory backing @p aListener, it should\n call otTcpListenerDeinitialize().\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aListener  A pointer to a TCP listener structure.\n @param[in]  aArgs      A pointer to a structure of arguments.\n\n @retval OT_ERROR_NONE    Successfully opened the TCP listener.\n @retval OT_ERROR_FAILED  Failed to open the TCP listener.\n"]
    pub fn otTcpListenerInitialize(
        aInstance: *mut otInstance,
        aListener: *mut otTcpListener,
        aArgs: *const otTcpListenerInitializeArgs,
    ) -> otError;
}
extern "C" {
    #[doc = " Obtains the otInstance that was associated with @p aListener upon\n initialization.\n\n @param[in]  aListener  The TCP listener whose instance to obtain.\n\n @returns  The otInstance pointer associated with @p aListener.\n"]
    pub fn otTcpListenerGetInstance(aListener: *mut otTcpListener) -> *mut otInstance;
}
extern "C" {
    #[doc = " Obtains the context pointer that was associated with @p aListener upon\n initialization.\n\n @param[in]  aListener  The TCP listener whose context to obtain.\n\n @returns  The context pointer associated with @p aListener.\n"]
    pub fn otTcpListenerGetContext(aListener: *mut otTcpListener) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Causes incoming TCP connections that match the specified IP address and port\n to trigger this TCP listener's callbacks.\n\n @param[in]  aListener  A pointer to the TCP listener structure that should begin listening.\n @param[in]  aSockName  The address and port on which to listen for incoming connections.\n\n @retval OT_ERROR_NONE    Successfully initiated listening on the TCP listener.\n @retval OT_ERROR_FAILED  Failed to initiate listening on the TCP listener.\n"]
    pub fn otTcpListen(aListener: *mut otTcpListener, aSockName: *const otSockAddr) -> otError;
}
extern "C" {
    #[doc = " Causes this TCP listener to stop listening for incoming connections.\n\n @param[in]  aListener  A pointer to the TCP listener structure that should stop listening.\n\n @retval OT_ERROR_NONE    Successfully stopped listening on the TCP listener.\n @retval OT_ERROR_FAILED  Failed to stop listening on the TCP listener.\n"]
    pub fn otTcpStopListening(aListener: *mut otTcpListener) -> otError;
}
extern "C" {
    #[doc = " Deinitializes this TCP listener.\n\n This means that OpenThread no longer keeps track of this TCP listener and\n deallocates all resources it has internally allocated for this TCP listener.\n The application can reuse the memory backing the TCP listener as it sees\n fit.\n\n If the TCP listener is currently listening, it stops listening.\n\n @param[in]  aListener  A pointer to the TCP listener structure to deinitialize.\n\n @retval OT_ERROR_NONE    Successfully deinitialized the TCP listener.\n @retval OT_ERROR_FAILED  Failed to deinitialize the TCP listener.\n"]
    pub fn otTcpListenerDeinitialize(aListener: *mut otTcpListener) -> otError;
}
#[doc = " This structure holds diagnostic information for a Thread Child\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct otChildInfo {
    #[doc = "< IEEE 802.15.4 Extended Address"]
    pub mExtAddress: otExtAddress,
    #[doc = "< Timeout"]
    pub mTimeout: u32,
    #[doc = "< Seconds since last heard"]
    pub mAge: u32,
    #[doc = "< Seconds since attach (requires `OPENTHREAD_CONFIG_UPTIME_ENABLE`)"]
    pub mConnectionTime: u64,
    #[doc = "< RLOC16"]
    pub mRloc16: u16,
    #[doc = "< Child ID"]
    pub mChildId: u16,
    #[doc = "< Network Data Version"]
    pub mNetworkDataVersion: u8,
    #[doc = "< Link Quality In"]
    pub mLinkQualityIn: u8,
    #[doc = "< Average RSSI"]
    pub mAverageRssi: i8,
    #[doc = "< Last observed RSSI"]
    pub mLastRssi: i8,
    #[doc = "< Frame error rate (0xffff->100%). Requires error tracking feature."]
    pub mFrameErrorRate: u16,
    #[doc = "< (IPv6) msg error rate (0xffff->100%). Requires error tracking feature."]
    pub mMessageErrorRate: u16,
    #[doc = "< Number of queued messages for the child."]
    pub mQueuedMessageCnt: u16,
    #[doc = "< Supervision interval (in seconds)."]
    pub mSupervisionInterval: u16,
    #[doc = "< MLE version"]
    pub mVersion: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl otChildInfo {
    #[inline]
    pub fn mRxOnWhenIdle(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mRxOnWhenIdle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mFullThreadDevice(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullThreadDevice(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mFullNetworkData(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mFullNetworkData(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsStateRestoring(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsStateRestoring(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsCslSynced(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsCslSynced(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mRxOnWhenIdle: bool,
        mFullThreadDevice: bool,
        mFullNetworkData: bool,
        mIsStateRestoring: bool,
        mIsCslSynced: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mRxOnWhenIdle: u8 = unsafe { ::std::mem::transmute(mRxOnWhenIdle) };
            mRxOnWhenIdle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mFullThreadDevice: u8 = unsafe { ::std::mem::transmute(mFullThreadDevice) };
            mFullThreadDevice as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mFullNetworkData: u8 = unsafe { ::std::mem::transmute(mFullNetworkData) };
            mFullNetworkData as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mIsStateRestoring: u8 = unsafe { ::std::mem::transmute(mIsStateRestoring) };
            mIsStateRestoring as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mIsCslSynced: u8 = unsafe { ::std::mem::transmute(mIsCslSynced) };
            mIsCslSynced as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type otChildIp6AddressIterator = u16;
pub const OT_CACHE_ENTRY_STATE_CACHED: otCacheEntryState = 0;
pub const OT_CACHE_ENTRY_STATE_SNOOPED: otCacheEntryState = 1;
pub const OT_CACHE_ENTRY_STATE_QUERY: otCacheEntryState = 2;
pub const OT_CACHE_ENTRY_STATE_RETRY_QUERY: otCacheEntryState = 3;
#[doc = " This enumeration defines the EID cache entry state.\n"]
pub type otCacheEntryState = ::std::os::raw::c_uint;
#[doc = " This structure represents an EID cache entry.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otCacheEntryInfo {
    #[doc = "< Target EID"]
    pub mTarget: otIp6Address,
    #[doc = "< RLOC16"]
    pub mRloc16: otShortAddress,
    #[doc = "< Entry state"]
    pub mState: otCacheEntryState,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Last transaction time (applicable in cached state)."]
    pub mLastTransTime: u32,
    #[doc = "< Mesh Local EID (applicable if entry in cached state)."]
    pub mMeshLocalEid: otIp6Address,
    #[doc = "< Timeout in seconds (applicable if in snooped/query/retry-query states)."]
    pub mTimeout: u16,
    #[doc = "< Retry delay in seconds (applicable if in query-retry state)."]
    pub mRetryDelay: u16,
}
impl Default for otCacheEntryInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otCacheEntryInfo {
    #[inline]
    pub fn mCanEvict(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mCanEvict(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mValidLastTrans(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mValidLastTrans(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mCanEvict: bool,
        mValidLastTrans: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mCanEvict: u8 = unsafe { ::std::mem::transmute(mCanEvict) };
            mCanEvict as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mValidLastTrans: u8 = unsafe { ::std::mem::transmute(mValidLastTrans) };
            mValidLastTrans as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " This type represents an iterator used for iterating through the EID cache table entries.\n\n To initialize the iterator and start from the first entry in the cache table, set all its fields in the structure to\n zero (e.g., `memset` the iterator to zero).\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otCacheEntryIterator {
    #[doc = "< Opaque data used by the core implementation. Should not be changed by user."]
    pub mData: [*const ::std::os::raw::c_void; 2usize],
}
impl Default for otCacheEntryIterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Gets the maximum number of children currently allowed.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The maximum number of children currently allowed.\n\n @sa otThreadSetMaxAllowedChildren\n"]
    pub fn otThreadGetMaxAllowedChildren(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the maximum number of children currently allowed.\n\n This parameter can only be set when Thread protocol operation has been stopped.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aMaxChildren  The maximum allowed children.\n\n @retval  OT_ERROR_NONE           Successfully set the max.\n @retval  OT_ERROR_INVALID_ARGS   If @p aMaxChildren is not in the range [1, OPENTHREAD_CONFIG_MLE_MAX_CHILDREN].\n @retval  OT_ERROR_INVALID_STATE  If Thread isn't stopped.\n\n @sa otThreadGetMaxAllowedChildren\n"]
    pub fn otThreadSetMaxAllowedChildren(aInstance: *mut otInstance, aMaxChildren: u16) -> otError;
}
extern "C" {
    #[doc = " This method indicates whether or not the device is router-eligible.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval TRUE   If device is router-eligible.\n @retval FALSE  If device is not router-eligible.\n"]
    pub fn otThreadIsRouterEligible(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function sets whether or not the device is router-eligible.\n\n If @p aEligible is false and the device is currently operating as a router, this call will cause the device to\n detach and attempt to reattach as a child.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aEligible  TRUE to configure the device as router-eligible, FALSE otherwise.\n\n @retval OT_ERROR_NONE         Successfully set the router-eligible configuration.\n @retval OT_ERROR_NOT_CAPABLE  The device is not capable of becoming a router.\n"]
    pub fn otThreadSetRouterEligible(aInstance: *mut otInstance, aEligible: bool) -> otError;
}
extern "C" {
    #[doc = " Set the preferred Router Id.\n\n Upon becoming a router/leader the node attempts to use this Router Id. If the preferred Router Id is not set or if\n it can not be used, a randomly generated router id is picked. This property can be set only when the device role is\n either detached or disabled.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n @param[in]  aRouterId    The preferred Router Id.\n\n @retval OT_ERROR_NONE          Successfully set the preferred Router Id.\n @retval OT_ERROR_INVALID_STATE Could not set (role is not detached or disabled)\n"]
    pub fn otThreadSetPreferredRouterId(aInstance: *mut otInstance, aRouterId: u8) -> otError;
}
#[doc = "< Battery powered."]
pub const OT_POWER_SUPPLY_BATTERY: otPowerSupply = 0;
#[doc = "< Externally powered (mains-powered)."]
pub const OT_POWER_SUPPLY_EXTERNAL: otPowerSupply = 1;
#[doc = "< Stable external power with a battery backup or UPS."]
pub const OT_POWER_SUPPLY_EXTERNAL_STABLE: otPowerSupply = 2;
#[doc = "< Potentially unstable ext power (e.g. light bulb powered via a switch)."]
pub const OT_POWER_SUPPLY_EXTERNAL_UNSTABLE: otPowerSupply = 3;
#[doc = " This enumeration represents the power supply property on a device.\n\n This is used as a property in `otDeviceProperties` to calculate the leader weight.\n"]
pub type otPowerSupply = ::std::os::raw::c_uint;
#[doc = " This structure represents the device properties which are used for calculating the local leader weight on a\n device.\n\n The parameters are set based on device's capability, whether acting as border router, its power supply config, etc.\n\n `mIsUnstable` indicates operational stability of device and is determined via a vendor specific mechanism. It can\n include the following cases:\n  - Device internally detects that it loses external power supply more often than usual. What is usual is\n    determined by the vendor.\n  - Device internally detects that it reboots more often than usual. What is usual is determined by the vendor.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otDeviceProperties {
    #[doc = "< Power supply config."]
    pub mPowerSupply: otPowerSupply,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Weight adjustment. Should be -16 to +16 (clamped otherwise)."]
    pub mLeaderWeightAdjustment: i8,
}
impl Default for otDeviceProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl otDeviceProperties {
    #[inline]
    pub fn mIsBorderRouter(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsBorderRouter(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mSupportsCcm(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mSupportsCcm(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mIsUnstable(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mIsUnstable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mIsBorderRouter: bool,
        mSupportsCcm: bool,
        mIsUnstable: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mIsBorderRouter: u8 = unsafe { ::std::mem::transmute(mIsBorderRouter) };
            mIsBorderRouter as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mSupportsCcm: u8 = unsafe { ::std::mem::transmute(mSupportsCcm) };
            mSupportsCcm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mIsUnstable: u8 = unsafe { ::std::mem::transmute(mIsUnstable) };
            mIsUnstable as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Get the current device properties.\n\n @returns The device properties `otDeviceProperties`.\n"]
    pub fn otThreadGetDeviceProperties(aInstance: *mut otInstance) -> *const otDeviceProperties;
}
extern "C" {
    #[doc = " Set the device properties which are then used to determine and set the Leader Weight.\n\n @param[in]  aInstance           A pointer to an OpenThread instance.\n @param[in]  aDeviceProperties   The device properties.\n"]
    pub fn otThreadSetDeviceProperties(
        aInstance: *mut otInstance,
        aDeviceProperties: *const otDeviceProperties,
    );
}
extern "C" {
    #[doc = " Gets the Thread Leader Weight used when operating in the Leader role.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Thread Leader Weight value.\n\n @sa otThreadSetLeaderWeight\n @sa otThreadSetDeviceProperties\n"]
    pub fn otThreadGetLocalLeaderWeight(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Sets the Thread Leader Weight used when operating in the Leader role.\n\n This function directly sets the Leader Weight to the new value, replacing its previous value (which may have been\n determined from the current `otDeviceProperties`).\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aWeight   The Thread Leader Weight value.\n\n @sa otThreadGetLeaderWeight\n"]
    pub fn otThreadSetLocalLeaderWeight(aInstance: *mut otInstance, aWeight: u8);
}
extern "C" {
    #[doc = " Get the preferred Thread Leader Partition Id used when operating in the Leader role.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Thread Leader Partition Id value.\n"]
    pub fn otThreadGetPreferredLeaderPartitionId(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Set the preferred Thread Leader Partition Id used when operating in the Leader role.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aPartitionId  The Thread Leader Partition Id value.\n"]
    pub fn otThreadSetPreferredLeaderPartitionId(aInstance: *mut otInstance, aPartitionId: u32);
}
extern "C" {
    #[doc = " Gets the Joiner UDP Port.\n\n @param[in] aInstance A pointer to an OpenThread instance.\n\n @returns The Joiner UDP Port number.\n\n @sa otThreadSetJoinerUdpPort\n"]
    pub fn otThreadGetJoinerUdpPort(aInstance: *mut otInstance) -> u16;
}
extern "C" {
    #[doc = " Sets the Joiner UDP Port.\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n @param[in]  aJoinerUdpPort  The Joiner UDP Port number.\n\n @retval  OT_ERROR_NONE  Successfully set the Joiner UDP Port.\n\n @sa otThreadGetJoinerUdpPort\n"]
    pub fn otThreadSetJoinerUdpPort(aInstance: *mut otInstance, aJoinerUdpPort: u16) -> otError;
}
extern "C" {
    #[doc = " Set Steering data out of band.\n\n Configuration option `OPENTHREAD_CONFIG_MLE_STEERING_DATA_SET_OOB_ENABLE` should be set to enable setting of steering\n data out of band.\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n @param[in]  aExtAddress     Address used to update the steering data.\n                             All zeros to clear the steering data (no steering data).\n                             All 0xFFs to set steering data/bloom filter to accept/allow all.\n                             A specific EUI64 which is then added to current steering data/bloom filter.\n"]
    pub fn otThreadSetSteeringData(aInstance: *mut otInstance, aExtAddress: *const otExtAddress);
}
extern "C" {
    #[doc = " Get the CONTEXT_ID_REUSE_DELAY parameter used in the Leader role.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The CONTEXT_ID_REUSE_DELAY value.\n\n @sa otThreadSetContextIdReuseDelay\n"]
    pub fn otThreadGetContextIdReuseDelay(aInstance: *mut otInstance) -> u32;
}
extern "C" {
    #[doc = " Set the CONTEXT_ID_REUSE_DELAY parameter used in the Leader role.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aDelay    The CONTEXT_ID_REUSE_DELAY value.\n\n @sa otThreadGetContextIdReuseDelay\n"]
    pub fn otThreadSetContextIdReuseDelay(aInstance: *mut otInstance, aDelay: u32);
}
extern "C" {
    #[doc = " Get the NETWORK_ID_TIMEOUT parameter used in the Router role.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The NETWORK_ID_TIMEOUT value.\n\n @sa otThreadSetNetworkIdTimeout\n"]
    pub fn otThreadGetNetworkIdTimeout(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the NETWORK_ID_TIMEOUT parameter used in the Leader role.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n @param[in]  aTimeout  The NETWORK_ID_TIMEOUT value.\n\n @sa otThreadGetNetworkIdTimeout\n"]
    pub fn otThreadSetNetworkIdTimeout(aInstance: *mut otInstance, aTimeout: u8);
}
extern "C" {
    #[doc = " Get the ROUTER_UPGRADE_THRESHOLD parameter used in the REED role.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The ROUTER_UPGRADE_THRESHOLD value.\n\n @sa otThreadSetRouterUpgradeThreshold\n"]
    pub fn otThreadGetRouterUpgradeThreshold(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the ROUTER_UPGRADE_THRESHOLD parameter used in the Leader role.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aThreshold  The ROUTER_UPGRADE_THRESHOLD value.\n\n @sa otThreadGetRouterUpgradeThreshold\n"]
    pub fn otThreadSetRouterUpgradeThreshold(aInstance: *mut otInstance, aThreshold: u8);
}
extern "C" {
    #[doc = " Get the MLE_CHILD_ROUTER_LINKS parameter used in the REED role.\n\n This parameter specifies the max number of neighboring routers with which the device (as an FED)\n  will try to establish link.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The MLE_CHILD_ROUTER_LINKS value.\n\n @sa otThreadSetChildRouterLinks\n"]
    pub fn otThreadGetChildRouterLinks(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the MLE_CHILD_ROUTER_LINKS parameter used in the REED role.\n\n @param[in]  aInstance         A pointer to an OpenThread instance.\n @param[in]  aChildRouterLinks The MLE_CHILD_ROUTER_LINKS value.\n\n @retval OT_ERROR_NONE           Successfully set the value.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n\n @sa otThreadGetChildRouterLinks\n"]
    pub fn otThreadSetChildRouterLinks(
        aInstance: *mut otInstance,
        aChildRouterLinks: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " Release a Router ID that has been allocated by the device in the Leader role.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aRouterId  The Router ID to release. Valid range is [0, 62].\n\n @retval OT_ERROR_NONE           Successfully released the router id.\n @retval OT_ERROR_INVALID_ARGS   @p aRouterId is not in the range [0, 62].\n @retval OT_ERROR_INVALID_STATE  The device is not currently operating as a leader.\n @retval OT_ERROR_NOT_FOUND      The router id is not currently allocated.\n"]
    pub fn otThreadReleaseRouterId(aInstance: *mut otInstance, aRouterId: u8) -> otError;
}
extern "C" {
    #[doc = " Attempt to become a router.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE           Successfully begin attempt to become a router.\n @retval OT_ERROR_INVALID_STATE  Thread is disabled."]
    pub fn otThreadBecomeRouter(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Become a leader and start a new partition.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @retval OT_ERROR_NONE           Successfully became a leader and started a new partition.\n @retval OT_ERROR_INVALID_STATE  Thread is disabled."]
    pub fn otThreadBecomeLeader(aInstance: *mut otInstance) -> otError;
}
extern "C" {
    #[doc = " Get the ROUTER_DOWNGRADE_THRESHOLD parameter used in the Router role.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n\n @returns The ROUTER_DOWNGRADE_THRESHOLD value.\n\n @sa otThreadSetRouterDowngradeThreshold\n"]
    pub fn otThreadGetRouterDowngradeThreshold(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the ROUTER_DOWNGRADE_THRESHOLD parameter used in the Leader role.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aThreshold  The ROUTER_DOWNGRADE_THRESHOLD value.\n\n @sa otThreadGetRouterDowngradeThreshold\n"]
    pub fn otThreadSetRouterDowngradeThreshold(aInstance: *mut otInstance, aThreshold: u8);
}
extern "C" {
    #[doc = " Get the ROUTER_SELECTION_JITTER parameter used in the REED/Router role.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n\n @returns The ROUTER_SELECTION_JITTER value.\n\n @sa otThreadSetRouterSelectionJitter\n"]
    pub fn otThreadGetRouterSelectionJitter(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Set the ROUTER_SELECTION_JITTER parameter used in the REED/Router role.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance      A pointer to an OpenThread instance.\n @param[in]  aRouterJitter  The ROUTER_SELECTION_JITTER value.\n\n @sa otThreadGetRouterSelectionJitter\n"]
    pub fn otThreadSetRouterSelectionJitter(aInstance: *mut otInstance, aRouterJitter: u8);
}
extern "C" {
    #[doc = " Gets diagnostic information for an attached Child by its Child ID or RLOC16.\n\n @param[in]   aInstance   A pointer to an OpenThread instance.\n @param[in]   aChildId    The Child ID or RLOC16 for the attached child.\n @param[out]  aChildInfo  A pointer to where the child information is placed.\n\n @retval OT_ERROR_NONE          @p aChildInfo was successfully updated with the info for the given ID.\n @retval OT_ERROR_NOT_FOUND     No valid child with this Child ID.\n @retval OT_ERROR_INVALID_ARGS  If @p aChildInfo is NULL.\n"]
    pub fn otThreadGetChildInfoById(
        aInstance: *mut otInstance,
        aChildId: u16,
        aChildInfo: *mut otChildInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " The function retains diagnostic information for an attached Child by the internal table index.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[in]   aChildIndex  The table index.\n @param[out]  aChildInfo   A pointer to where the child information is placed.\n\n @retval OT_ERROR_NONE             @p aChildInfo was successfully updated with the info for the given index.\n @retval OT_ERROR_NOT_FOUND        No valid child at this index.\n @retval OT_ERROR_INVALID_ARGS     Either @p aChildInfo is NULL, or @p aChildIndex is out of range (higher\n                                   than max table index).\n\n @sa otGetMaxAllowedChildren\n"]
    pub fn otThreadGetChildInfoByIndex(
        aInstance: *mut otInstance,
        aChildIndex: u16,
        aChildInfo: *mut otChildInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the next IPv6 address (using an iterator) for a given child.\n\n @param[in]      aInstance    A pointer to an OpenThread instance.\n @param[in]      aChildIndex  The child index.\n @param[in,out]  aIterator    A pointer to the iterator. On success the iterator will be updated to point to next\n                              entry in the list. To get the first IPv6 address the iterator should be set to\n                              OT_CHILD_IP6_ADDRESS_ITERATOR_INIT.\n @param[out]     aAddress     A pointer to an IPv6 address where the child's next address is placed (on success).\n\n @retval OT_ERROR_NONE          Successfully found the next IPv6 address (@p aAddress was successfully updated).\n @retval OT_ERROR_NOT_FOUND     The child has no subsequent IPv6 address entry.\n @retval OT_ERROR_INVALID_ARGS  @p aIterator or @p aAddress are NULL, or child at @p aChildIndex is not valid.\n\n @sa otThreadGetChildInfoByIndex\n"]
    pub fn otThreadGetChildNextIp6Address(
        aInstance: *mut otInstance,
        aChildIndex: u16,
        aIterator: *mut otChildIp6AddressIterator,
        aAddress: *mut otIp6Address,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the current Router ID Sequence.\n\n @param[in]  aInstance A pointer to an OpenThread instance.\n\n @returns The Router ID Sequence.\n"]
    pub fn otThreadGetRouterIdSequence(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " The function returns the maximum allowed router ID\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n\n @returns The maximum allowed router ID.\n"]
    pub fn otThreadGetMaxRouterId(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " The function retains diagnostic information for a given Thread Router.\n\n @param[in]   aInstance    A pointer to an OpenThread instance.\n @param[in]   aRouterId    The router ID or RLOC16 for a given router.\n @param[out]  aRouterInfo  A pointer to where the router information is placed.\n\n @retval OT_ERROR_NONE          Successfully retrieved the router info for given id.\n @retval OT_ERROR_NOT_FOUND     No router entry with the given id.\n @retval OT_ERROR_INVALID_ARGS  @p aRouterInfo is NULL.\n"]
    pub fn otThreadGetRouterInfo(
        aInstance: *mut otInstance,
        aRouterId: u16,
        aRouterInfo: *mut otRouterInfo,
    ) -> otError;
}
extern "C" {
    #[doc = " This function gets the next EID cache entry (using an iterator).\n\n @param[in]     aInstance   A pointer to an OpenThread instance.\n @param[out]    aEntryInfo  A pointer to where the EID cache entry information is placed.\n @param[in,out] aIterator   A pointer to an iterator. It will be updated to point to next entry on success. To get\n                            the first entry, initialize the iterator by setting all its fields to zero\n                            (e.g., `memset` the iterator structure to zero).\n\n @retval OT_ERROR_NONE          Successfully populated @p aEntryInfo for next EID cache entry.\n @retval OT_ERROR_NOT_FOUND     No more entries in the address cache table.\n"]
    pub fn otThreadGetNextCacheEntry(
        aInstance: *mut otInstance,
        aEntryInfo: *mut otCacheEntryInfo,
        aIterator: *mut otCacheEntryIterator,
    ) -> otError;
}
extern "C" {
    #[doc = " Get the Thread PSKc\n\n @param[in]   aInstance   A pointer to an OpenThread instance.\n @param[out]  aPskc       A pointer to an `otPskc` to return the retrieved Thread PSKc.\n\n @sa otThreadSetPskc\n"]
    pub fn otThreadGetPskc(aInstance: *mut otInstance, aPskc: *mut otPskc);
}
extern "C" {
    #[doc = " Get Key Reference to Thread PSKc stored\n\n This function requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled.\n\n @param[in]   aInstance   A pointer to an OpenThread instance.\n\n @returns Key Reference to PSKc\n\n @sa otThreadSetPskcRef\n"]
    pub fn otThreadGetPskcRef(aInstance: *mut otInstance) -> otPskcRef;
}
extern "C" {
    #[doc = " Set the Thread PSKc\n\n This function will only succeed when Thread protocols are disabled.  A successful\n call to this function will also invalidate the Active and Pending Operational Datasets in\n non-volatile memory.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aPskc       A pointer to the new Thread PSKc.\n\n @retval OT_ERROR_NONE           Successfully set the Thread PSKc.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n\n @sa otThreadGetPskc\n"]
    pub fn otThreadSetPskc(aInstance: *mut otInstance, aPskc: *const otPskc) -> otError;
}
extern "C" {
    #[doc = " Set the Thread PSKc\n\n This function requires the build-time feature `OPENTHREAD_CONFIG_PLATFORM_KEY_REFERENCES_ENABLE` to be enabled.\n\n This function will only succeed when Thread protocols are disabled.  A successful\n call to this function will also invalidate the Active and Pending Operational Datasets in\n non-volatile memory.\n\n @param[in]  aInstance   A pointer to an OpenThread instance.\n @param[in]  aKeyRef     Key Reference to the new Thread PSKc.\n\n @retval OT_ERROR_NONE           Successfully set the Thread PSKc.\n @retval OT_ERROR_INVALID_STATE  Thread protocols are enabled.\n\n @sa otThreadGetPskcRef\n"]
    pub fn otThreadSetPskcRef(aInstance: *mut otInstance, aKeyRef: otPskcRef) -> otError;
}
extern "C" {
    #[doc = " Get the assigned parent priority.\n\n @param[in]   aInstance   A pointer to an OpenThread instance.\n\n @returns The assigned parent priority value, -2 means not assigned.\n\n @sa otThreadSetParentPriority\n"]
    pub fn otThreadGetParentPriority(aInstance: *mut otInstance) -> i8;
}
extern "C" {
    #[doc = " Set the parent priority.\n\n @note This API is reserved for testing and demo purposes only. Changing settings with\n this API will render a production application non-compliant with the Thread Specification.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aParentPriority  The parent priority value.\n\n @retval OT_ERROR_NONE           Successfully set the parent priority.\n @retval OT_ERROR_INVALID_ARGS   If the parent priority value is not among 1, 0, -1 and -2.\n\n @sa otThreadGetParentPriority\n"]
    pub fn otThreadSetParentPriority(aInstance: *mut otInstance, aParentPriority: i8) -> otError;
}
extern "C" {
    #[doc = " Gets the maximum number of IP addresses that each MTD child may register with this device as parent.\n\n @param[in]  aInstance    A pointer to an OpenThread instance.\n\n @returns The maximum number of IP addresses that each MTD child may register with this device as parent.\n\n @sa otThreadSetMaxChildIpAddresses\n"]
    pub fn otThreadGetMaxChildIpAddresses(aInstance: *mut otInstance) -> u8;
}
extern "C" {
    #[doc = " Sets or restores the maximum number of IP addresses that each MTD child may register with this\n device as parent.\n\n Pass `0` to clear the setting and restore the default.\n\n Available when `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE` is enabled.\n\n @note Only used by Thread Test Harness to limit the address registrations of the reference\n parent in order to test the MTD DUT reaction.\n\n @param[in]  aInstance        A pointer to an OpenThread instance.\n @param[in]  aMaxIpAddresses  The maximum number of IP addresses that each MTD child may register with this\n                              device as parent. 0 to clear the setting and restore the default.\n\n @retval OT_ERROR_NONE           Successfully set/cleared the number.\n @retval OT_ERROR_INVALID_ARGS   If exceeds the allowed maximum number.\n\n @sa otThreadGetMaxChildIpAddresses\n"]
    pub fn otThreadSetMaxChildIpAddresses(
        aInstance: *mut otInstance,
        aMaxIpAddresses: u8,
    ) -> otError;
}
#[doc = "< A child is being added."]
pub const OT_NEIGHBOR_TABLE_EVENT_CHILD_ADDED: otNeighborTableEvent = 0;
#[doc = "< A child is being removed."]
pub const OT_NEIGHBOR_TABLE_EVENT_CHILD_REMOVED: otNeighborTableEvent = 1;
#[doc = "< An existing child's mode is changed."]
pub const OT_NEIGHBOR_TABLE_EVENT_CHILD_MODE_CHANGED: otNeighborTableEvent = 2;
#[doc = "< A router is being added."]
pub const OT_NEIGHBOR_TABLE_EVENT_ROUTER_ADDED: otNeighborTableEvent = 3;
#[doc = "< A router is being removed."]
pub const OT_NEIGHBOR_TABLE_EVENT_ROUTER_REMOVED: otNeighborTableEvent = 4;
#[doc = " This enumeration defines the constants used in `otNeighborTableCallback` to indicate changes in neighbor table.\n"]
pub type otNeighborTableEvent = ::std::os::raw::c_uint;
#[doc = " This type represent a neighbor table entry info (child or router) and is used as a parameter in the neighbor table\n callback `otNeighborTableCallback`.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otNeighborTableEntryInfo {
    #[doc = "< The OpenThread instance."]
    pub mInstance: *mut otInstance,
    pub mInfo: otNeighborTableEntryInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union otNeighborTableEntryInfo__bindgen_ty_1 {
    #[doc = "< The child neighbor info."]
    pub mChild: otChildInfo,
    #[doc = "< The router neighbor info."]
    pub mRouter: otNeighborInfo,
}
impl Default for otNeighborTableEntryInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for otNeighborTableEntryInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This function pointer is called to notify that there is a change in the neighbor table.\n\n @param[in]  aEvent      A event flag.\n @param[in]  aEntryInfo  A pointer to table entry info.\n"]
pub type otNeighborTableCallback = ::std::option::Option<
    unsafe extern "C" fn(aEvent: otNeighborTableEvent, aEntryInfo: *const otNeighborTableEntryInfo),
>;
extern "C" {
    #[doc = " This function registers a neighbor table callback function.\n\n The provided callback (if non-NULL) will be invoked when there is a change in the neighbor table (e.g., a child or a\n router neighbor entry is being added/removed or an existing child's mode is changed).\n\n Subsequent calls to this method will overwrite the previous callback.  Note that this callback in invoked while the\n neighbor/child table is being updated and always before the `otStateChangedCallback`.\n\n @param[in] aInstance  A pointer to an OpenThread instance.\n @param[in] aCallback  A pointer to callback handler function.\n"]
    pub fn otThreadRegisterNeighborTableCallback(
        aInstance: *mut otInstance,
        aCallback: otNeighborTableCallback,
    );
}
extern "C" {
    #[doc = " This function sets whether the device was commissioned using CCM.\n\n @note This API requires `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE`, and is only used by Thread Test Harness\n       to indicate whether this device was commissioned using CCM.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aEnabled   TRUE if the device was commissioned using CCM, FALSE otherwise.\n"]
    pub fn otThreadSetCcmEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " This function sets whether the Security Policy TLV version-threshold for routing (VR field) is enabled.\n\n @note This API requires `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE`, and is only used by Thread Test Harness\n       to indicate that thread protocol version check VR should be skipped.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aEnabled   TRUE to enable Security Policy TLV version-threshold for routing, FALSE otherwise.\n"]
    pub fn otThreadSetThreadVersionCheckEnabled(aInstance: *mut otInstance, aEnabled: bool);
}
extern "C" {
    #[doc = " This function gets the range of router IDs that are allowed to assign to nodes within the thread network.\n\n @note This API requires `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE`, and is only used for test purpose. All the\n router IDs in the range [aMinRouterId, aMaxRouterId] are allowed.\n\n @param[in]   aInstance     A pointer to an OpenThread instance.\n @param[out]  aMinRouterId  The minimum router ID.\n @param[out]  aMaxRouterId  The maximum router ID.\n\n @sa otThreadSetRouterIdRange\n"]
    pub fn otThreadGetRouterIdRange(
        aInstance: *mut otInstance,
        aMinRouterId: *mut u8,
        aMaxRouterId: *mut u8,
    );
}
extern "C" {
    #[doc = " This function sets the range of router IDs that are allowed to assign to nodes within the thread network.\n\n @note This API requires `OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE`, and is only used for test purpose. All the\n router IDs in the range [aMinRouterId, aMaxRouterId] are allowed.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aMinRouterId  The minimum router ID.\n @param[in]  aMaxRouterId  The maximum router ID.\n\n @retval  OT_ERROR_NONE           Successfully set the range.\n @retval  OT_ERROR_INVALID_ARGS   aMinRouterId > aMaxRouterId, or the range is not covered by [0, 62].\n\n @sa otThreadGetRouterIdRange\n"]
    pub fn otThreadSetRouterIdRange(
        aInstance: *mut otInstance,
        aMinRouterId: u8,
        aMaxRouterId: u8,
    ) -> otError;
}
extern "C" {
    #[doc = " This function indicates whether or not a Router ID is currently allocated.\n\n @param[in]  aInstance     A pointer to an OpenThread instance.\n @param[in]  aRouterId     The router ID to check.\n\n @retval TRUE  The @p aRouterId is allocated.\n @retval FALSE The @p aRouterId is not allocated.\n"]
    pub fn otThreadIsRouterIdAllocated(aInstance: *mut otInstance, aRouterId: u8) -> bool;
}
extern "C" {
    #[doc = " This function gets the next hop and path cost towards a given RLOC16 destination.\n\n This function can be used with either @p aNextHopRloc16 or @p aPathCost being NULL indicating caller does not want\n to get the value.\n\n @param[in]  aInstance       A pointer to an OpenThread instance.\n @param[in]  aDesRloct16     The RLOC16 of destination.\n @param[out] aNextHopRloc16  A pointer to return RLOC16 of next hop, 0xfffe if no next hop.\n @param[out] aPathCost       A pointer to return path cost towards destination.\n"]
    pub fn otThreadGetNextHopAndPathCost(
        aInstance: *mut otInstance,
        aDestRloc16: u16,
        aNextHopRloc16: *mut u16,
        aPathCost: *mut u8,
    );
}
#[doc = " This struct represents a TREL peer.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct otTrelPeer {
    #[doc = "< The Extended MAC Address of TREL peer."]
    pub mExtAddress: otExtAddress,
    #[doc = "< The Extended PAN Identifier of TREL peer."]
    pub mExtPanId: otExtendedPanId,
    #[doc = "< The IPv6 socket address of TREL peer."]
    pub mSockAddr: otSockAddr,
}
impl Default for otTrelPeer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This type represents an iterator for iterating over TREL peer table entries.\n"]
pub type otTrelPeerIterator = u16;
extern "C" {
    #[doc = " Enables or disables TREL operation.\n\n When @p aEnable is true, this function initiates an ongoing DNS-SD browse on the service name \"_trel._udp\" within the\n local browsing domain to discover other devices supporting TREL. Device also registers a new service to be advertised\n using DNS-SD, with the service name is \"_trel._udp\" indicating its support for TREL. Device is then ready to receive\n TREL messages from peers.\n\n When @p aEnable is false, this function stops the DNS-SD browse on the service name \"_trel._udp\", stops advertising\n TREL DNS-SD service, and clears the TREL peer table.\n\n @note By default the OpenThread stack enables the TREL operation on start.\n\n @param[in]  aInstance  A pointer to an OpenThread instance.\n @param[in]  aEnable    A boolean to enable/disable the TREL operation.\n"]
    pub fn otTrelSetEnabled(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " This function indicates whether the TREL operation is enabled.\n\n @param[in] aInstance   The OpenThread instance.\n\n @retval TRUE if the TREL operation is enabled.\n @retval FALSE if the TREL operation is disabled.\n"]
    pub fn otTrelIsEnabled(aInstance: *mut otInstance) -> bool;
}
extern "C" {
    #[doc = " This function initializes a peer table iterator.\n\n @param[in] aInstance   The OpenThread instance.\n @param[in] aIterator   The iterator to initialize.\n"]
    pub fn otTrelInitPeerIterator(aInstance: *mut otInstance, aIterator: *mut otTrelPeerIterator);
}
extern "C" {
    #[doc = " This function iterates over the peer table entries and get the next entry from the table\n\n @param[in] aInstance   The OpenThread instance.\n @param[in] aIterator   The iterator. MUST be initialized.\n\n @returns A pointer to the next `otTrelPeer` entry or `NULL` if no more entries in the table.\n"]
    pub fn otTrelGetNextPeer(
        aInstance: *mut otInstance,
        aIterator: *mut otTrelPeerIterator,
    ) -> *const otTrelPeer;
}
extern "C" {
    #[doc = " This function sets the filter mode (enables/disables filtering).\n\n When filter mode is enabled, any rx and tx traffic through TREL interface is silently dropped. This is mainly\n intended for use during testing.\n\n Unlike `otTrel{Enable/Disable}()` which fully starts/stops the TREL operation, when filter mode is enabled the\n TREL interface continues to be enabled.\n\n @param[in] aInstance   The OpenThread instance.\n @param[in] aFiltered   TRUE to enable filter mode, FALSE to disable filter mode.\n"]
    pub fn otTrelSetFilterEnabled(aInstance: *mut otInstance, aEnable: bool);
}
extern "C" {
    #[doc = " This function indicates whether or not the filter mode is enabled.\n\n @param[in] aInstance   The OpenThread instance.\n\n @retval TRUE if the TREL filter mode is enabled.\n @retval FALSE if the TREL filter mode is disabled.\n"]
    pub fn otTrelIsFilterEnabled(aInstance: *mut otInstance) -> bool;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
