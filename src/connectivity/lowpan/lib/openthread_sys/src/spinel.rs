/* automatically generated by rust-bindgen 0.63.0 */

// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

pub const SPINEL_HEADER_INCLUDED: u32 = 1;
pub const SPINEL_PROTOCOL_VERSION_THREAD_MAJOR: u32 = 4;
pub const SPINEL_PROTOCOL_VERSION_THREAD_MINOR: u32 = 3;
pub const SPINEL_RCP_API_VERSION: u32 = 9;
pub const SPINEL_MIN_HOST_SUPPORTED_RCP_API_VERSION: u32 = 4;
pub const SPINEL_FRAME_MAX_SIZE: u32 = 1300;
pub const SPINEL_FRAME_MAX_COMMAND_HEADER_SIZE: u32 = 4;
pub const SPINEL_FRAME_MAX_COMMAND_PAYLOAD_SIZE: u32 = 1296;
pub const SPINEL_ENCRYPTER_EXTRA_DATA_SIZE: u32 = 0;
pub const SPINEL_FRAME_BUFFER_SIZE: u32 = 1300;
pub const SPINEL_HEADER_FLAG: u32 = 128;
pub const SPINEL_HEADER_FLAGS_SHIFT: u32 = 6;
pub const SPINEL_HEADER_FLAGS_MASK: u32 = 192;
pub const SPINEL_HEADER_TID_SHIFT: u32 = 0;
pub const SPINEL_HEADER_TID_MASK: u32 = 15;
pub const SPINEL_HEADER_IID_SHIFT: u32 = 4;
pub const SPINEL_HEADER_IID_MASK: u32 = 48;
pub const SPINEL_HEADER_IID_0: u32 = 0;
pub const SPINEL_HEADER_IID_1: u32 = 16;
pub const SPINEL_HEADER_IID_2: u32 = 32;
pub const SPINEL_HEADER_IID_3: u32 = 48;
pub const SPINEL_BEACON_THREAD_FLAG_VERSION_SHIFT: u32 = 4;
pub const SPINEL_BEACON_THREAD_FLAG_VERSION_MASK: u32 = 240;
pub const SPINEL_BEACON_THREAD_FLAG_JOINABLE: u32 = 1;
pub const SPINEL_BEACON_THREAD_FLAG_NATIVE: u32 = 8;
pub const SPINEL_DATATYPE_NULL_S: &[u8; 1usize] = b"\0";
pub const SPINEL_DATATYPE_VOID_S: &[u8; 2usize] = b".\0";
pub const SPINEL_DATATYPE_BOOL_S: &[u8; 2usize] = b"b\0";
pub const SPINEL_DATATYPE_UINT8_S: &[u8; 2usize] = b"C\0";
pub const SPINEL_DATATYPE_INT8_S: &[u8; 2usize] = b"c\0";
pub const SPINEL_DATATYPE_UINT16_S: &[u8; 2usize] = b"S\0";
pub const SPINEL_DATATYPE_INT16_S: &[u8; 2usize] = b"s\0";
pub const SPINEL_DATATYPE_UINT32_S: &[u8; 2usize] = b"L\0";
pub const SPINEL_DATATYPE_INT32_S: &[u8; 2usize] = b"l\0";
pub const SPINEL_DATATYPE_UINT64_S: &[u8; 2usize] = b"X\0";
pub const SPINEL_DATATYPE_INT64_S: &[u8; 2usize] = b"x\0";
pub const SPINEL_DATATYPE_UINT_PACKED_S: &[u8; 2usize] = b"i\0";
pub const SPINEL_DATATYPE_IPv6ADDR_S: &[u8; 2usize] = b"6\0";
pub const SPINEL_DATATYPE_EUI64_S: &[u8; 2usize] = b"E\0";
pub const SPINEL_DATATYPE_EUI48_S: &[u8; 2usize] = b"e\0";
pub const SPINEL_DATATYPE_DATA_WLEN_S: &[u8; 2usize] = b"d\0";
pub const SPINEL_DATATYPE_DATA_S: &[u8; 2usize] = b"D\0";
pub const SPINEL_DATATYPE_UTF8_S: &[u8; 2usize] = b"U\0";
pub const SPINEL_DATATYPE_COMMAND_S: &[u8; 3usize] = b"Ci\0";
pub const SPINEL_DATATYPE_COMMAND_PROP_S: &[u8; 4usize] = b"Cii\0";
pub const SPINEL_MAX_UINT_PACKED: u32 = 2097151;
#[doc = "< Operation has completed successfully."]
pub const SPINEL_STATUS_OK: _bindgen_ty_1 = 0;
#[doc = "< Operation has failed for some undefined reason."]
pub const SPINEL_STATUS_FAILURE: _bindgen_ty_1 = 1;
#[doc = "< Given operation has not been implemented."]
pub const SPINEL_STATUS_UNIMPLEMENTED: _bindgen_ty_1 = 2;
#[doc = "< An argument to the operation is invalid."]
pub const SPINEL_STATUS_INVALID_ARGUMENT: _bindgen_ty_1 = 3;
#[doc = "< This operation is invalid for the current device state."]
pub const SPINEL_STATUS_INVALID_STATE: _bindgen_ty_1 = 4;
#[doc = "< This command is not recognized."]
pub const SPINEL_STATUS_INVALID_COMMAND: _bindgen_ty_1 = 5;
#[doc = "< This interface is not supported."]
pub const SPINEL_STATUS_INVALID_INTERFACE: _bindgen_ty_1 = 6;
#[doc = "< An internal runtime error has occurred."]
pub const SPINEL_STATUS_INTERNAL_ERROR: _bindgen_ty_1 = 7;
#[doc = "< A security/authentication error has occurred."]
pub const SPINEL_STATUS_SECURITY_ERROR: _bindgen_ty_1 = 8;
#[doc = "< A error has occurred while parsing the command."]
pub const SPINEL_STATUS_PARSE_ERROR: _bindgen_ty_1 = 9;
#[doc = "< This operation is in progress."]
pub const SPINEL_STATUS_IN_PROGRESS: _bindgen_ty_1 = 10;
#[doc = "< Operation prevented due to memory pressure."]
pub const SPINEL_STATUS_NOMEM: _bindgen_ty_1 = 11;
#[doc = "< The device is currently performing a mutually exclusive operation"]
pub const SPINEL_STATUS_BUSY: _bindgen_ty_1 = 12;
#[doc = "< The given property is not recognized."]
pub const SPINEL_STATUS_PROP_NOT_FOUND: _bindgen_ty_1 = 13;
#[doc = "< A/The packet was dropped."]
pub const SPINEL_STATUS_DROPPED: _bindgen_ty_1 = 14;
#[doc = "< The result of the operation is empty."]
pub const SPINEL_STATUS_EMPTY: _bindgen_ty_1 = 15;
#[doc = "< The command was too large to fit in the internal buffer."]
pub const SPINEL_STATUS_CMD_TOO_BIG: _bindgen_ty_1 = 16;
#[doc = "< The packet was not acknowledged."]
pub const SPINEL_STATUS_NO_ACK: _bindgen_ty_1 = 17;
#[doc = "< The packet was not sent due to a CCA failure."]
pub const SPINEL_STATUS_CCA_FAILURE: _bindgen_ty_1 = 18;
#[doc = "< The operation is already in progress."]
pub const SPINEL_STATUS_ALREADY: _bindgen_ty_1 = 19;
#[doc = "< The given item could not be found."]
pub const SPINEL_STATUS_ITEM_NOT_FOUND: _bindgen_ty_1 = 20;
#[doc = "< The given command cannot be performed on this property."]
pub const SPINEL_STATUS_INVALID_COMMAND_FOR_PROP: _bindgen_ty_1 = 21;
#[doc = "< The neighbor is unknown."]
pub const SPINEL_STATUS_UNKNOWN_NEIGHBOR: _bindgen_ty_1 = 22;
#[doc = "< The target is not capable of handling requested operation."]
pub const SPINEL_STATUS_NOT_CAPABLE: _bindgen_ty_1 = 23;
#[doc = "< No response received from remote node"]
pub const SPINEL_STATUS_RESPONSE_TIMEOUT: _bindgen_ty_1 = 24;
pub const SPINEL_STATUS_JOIN__BEGIN: _bindgen_ty_1 = 104;
#[doc = " Generic failure to associate with other peers.\n**\n*  This status error should not be used by implementors if\n*  enough information is available to determine that one of the\n*  later join failure status codes would be more accurate.\n*\n*  \\sa SPINEL_PROP_NET_REQUIRE_JOIN_EXISTING\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_JOIN_FAILURE: _bindgen_ty_1 = 104;
#[doc = " The node found other peers but was unable to decode their packets.\n**\n*  Typically this error code indicates that the network\n*  key has been set incorrectly.\n*\n*  \\sa SPINEL_PROP_NET_REQUIRE_JOIN_EXISTING\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_JOIN_SECURITY: _bindgen_ty_1 = 105;
#[doc = " The node was unable to find any other peers on the network.\n**\n*  \\sa SPINEL_PROP_NET_REQUIRE_JOIN_EXISTING\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_JOIN_NO_PEERS: _bindgen_ty_1 = 106;
#[doc = " The only potential peer nodes found are incompatible.\n**\n*  \\sa SPINEL_PROP_NET_REQUIRE_JOIN_EXISTING\n*/"]
pub const SPINEL_STATUS_JOIN_INCOMPATIBLE: _bindgen_ty_1 = 107;
#[doc = " No response in expecting time.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_JOIN_RSP_TIMEOUT: _bindgen_ty_1 = 108;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_JOIN_SUCCESS: _bindgen_ty_1 = 109;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_JOIN__END: _bindgen_ty_1 = 112;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_RESET__BEGIN: _bindgen_ty_1 = 112;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_RESET_POWER_ON: _bindgen_ty_1 = 112;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_RESET_EXTERNAL: _bindgen_ty_1 = 113;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_RESET_SOFTWARE: _bindgen_ty_1 = 114;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_RESET_FAULT: _bindgen_ty_1 = 115;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_RESET_CRASH: _bindgen_ty_1 = 116;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_RESET_ASSERT: _bindgen_ty_1 = 117;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_RESET_OTHER: _bindgen_ty_1 = 118;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_RESET_UNKNOWN: _bindgen_ty_1 = 119;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_RESET_WATCHDOG: _bindgen_ty_1 = 120;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_RESET__END: _bindgen_ty_1 = 128;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_VENDOR__BEGIN: _bindgen_ty_1 = 15360;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_VENDOR__END: _bindgen_ty_1 = 16384;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_STACK_NATIVE__BEGIN: _bindgen_ty_1 = 16384;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_STACK_NATIVE__END: _bindgen_ty_1 = 81920;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_EXPERIMENTAL__BEGIN: _bindgen_ty_1 = 2000000;
#[doc = " The node succeeds in commissioning and get the network credentials.\n**\n*  \\sa SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING\n*/"]
pub const SPINEL_STATUS_EXPERIMENTAL__END: _bindgen_ty_1 = 2097152;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const SPINEL_NET_FLAG_ON_MESH: _bindgen_ty_2 = 1;
pub const SPINEL_NET_FLAG_DEFAULT_ROUTE: _bindgen_ty_2 = 2;
pub const SPINEL_NET_FLAG_CONFIGURE: _bindgen_ty_2 = 4;
pub const SPINEL_NET_FLAG_DHCP: _bindgen_ty_2 = 8;
pub const SPINEL_NET_FLAG_SLAAC: _bindgen_ty_2 = 16;
pub const SPINEL_NET_FLAG_PREFERRED: _bindgen_ty_2 = 32;
pub const SPINEL_NET_FLAG_PREFERENCE_OFFSET: _bindgen_ty_2 = 6;
pub const SPINEL_NET_FLAG_PREFERENCE_MASK: _bindgen_ty_2 = 192;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const SPINEL_NET_FLAG_EXT_DP: _bindgen_ty_3 = 64;
pub const SPINEL_NET_FLAG_EXT_DNS: _bindgen_ty_3 = 128;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const SPINEL_ROUTE_PREFERENCE_HIGH: _bindgen_ty_4 = 64;
pub const SPINEL_ROUTE_PREFERENCE_MEDIUM: _bindgen_ty_4 = 0;
pub const SPINEL_ROUTE_PREFERENCE_LOW: _bindgen_ty_4 = 192;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const SPINEL_ROUTE_FLAG_NAT64: _bindgen_ty_5 = 32;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const SPINEL_THREAD_MODE_FULL_NETWORK_DATA: _bindgen_ty_6 = 1;
pub const SPINEL_THREAD_MODE_FULL_THREAD_DEV: _bindgen_ty_6 = 2;
pub const SPINEL_THREAD_MODE_SECURE_DATA_REQUEST: _bindgen_ty_6 = 4;
pub const SPINEL_THREAD_MODE_RX_ON_WHEN_IDLE: _bindgen_ty_6 = 8;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const SPINEL_GPIO_FLAG_DIR_INPUT: _bindgen_ty_7 = 0;
pub const SPINEL_GPIO_FLAG_DIR_OUTPUT: _bindgen_ty_7 = 128;
pub const SPINEL_GPIO_FLAG_PULL_UP: _bindgen_ty_7 = 64;
pub const SPINEL_GPIO_FLAG_PULL_DOWN: _bindgen_ty_7 = 32;
pub const SPINEL_GPIO_FLAG_OPEN_DRAIN: _bindgen_ty_7 = 32;
pub const SPINEL_GPIO_FLAG_TRIGGER_NONE: _bindgen_ty_7 = 0;
pub const SPINEL_GPIO_FLAG_TRIGGER_RISING: _bindgen_ty_7 = 16;
pub const SPINEL_GPIO_FLAG_TRIGGER_FALLING: _bindgen_ty_7 = 8;
pub const SPINEL_GPIO_FLAG_TRIGGER_ANY: _bindgen_ty_7 = 24;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const SPINEL_PROTOCOL_TYPE_BOOTLOADER: _bindgen_ty_8 = 0;
pub const SPINEL_PROTOCOL_TYPE_ZIGBEE_IP: _bindgen_ty_8 = 2;
pub const SPINEL_PROTOCOL_TYPE_THREAD: _bindgen_ty_8 = 3;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[doc = "< Normal MAC filtering is in place."]
pub const SPINEL_MAC_PROMISCUOUS_MODE_OFF: _bindgen_ty_9 = 0;
#[doc = "< All MAC packets matching network are passed up the stack."]
pub const SPINEL_MAC_PROMISCUOUS_MODE_NETWORK: _bindgen_ty_9 = 1;
#[doc = "< All decoded MAC packets are passed up the stack."]
pub const SPINEL_MAC_PROMISCUOUS_MODE_FULL: _bindgen_ty_9 = 2;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const SPINEL_NCP_LOG_LEVEL_EMERG: _bindgen_ty_10 = 0;
pub const SPINEL_NCP_LOG_LEVEL_ALERT: _bindgen_ty_10 = 1;
pub const SPINEL_NCP_LOG_LEVEL_CRIT: _bindgen_ty_10 = 2;
pub const SPINEL_NCP_LOG_LEVEL_ERR: _bindgen_ty_10 = 3;
pub const SPINEL_NCP_LOG_LEVEL_WARN: _bindgen_ty_10 = 4;
pub const SPINEL_NCP_LOG_LEVEL_NOTICE: _bindgen_ty_10 = 5;
pub const SPINEL_NCP_LOG_LEVEL_INFO: _bindgen_ty_10 = 6;
pub const SPINEL_NCP_LOG_LEVEL_DEBUG: _bindgen_ty_10 = 7;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const SPINEL_NCP_LOG_REGION_NONE: _bindgen_ty_11 = 0;
pub const SPINEL_NCP_LOG_REGION_OT_API: _bindgen_ty_11 = 1;
pub const SPINEL_NCP_LOG_REGION_OT_MLE: _bindgen_ty_11 = 2;
pub const SPINEL_NCP_LOG_REGION_OT_ARP: _bindgen_ty_11 = 3;
pub const SPINEL_NCP_LOG_REGION_OT_NET_DATA: _bindgen_ty_11 = 4;
pub const SPINEL_NCP_LOG_REGION_OT_ICMP: _bindgen_ty_11 = 5;
pub const SPINEL_NCP_LOG_REGION_OT_IP6: _bindgen_ty_11 = 6;
pub const SPINEL_NCP_LOG_REGION_OT_TCP: _bindgen_ty_11 = 7;
pub const SPINEL_NCP_LOG_REGION_OT_MAC: _bindgen_ty_11 = 8;
pub const SPINEL_NCP_LOG_REGION_OT_MEM: _bindgen_ty_11 = 9;
pub const SPINEL_NCP_LOG_REGION_OT_NCP: _bindgen_ty_11 = 10;
pub const SPINEL_NCP_LOG_REGION_OT_MESH_COP: _bindgen_ty_11 = 11;
pub const SPINEL_NCP_LOG_REGION_OT_NET_DIAG: _bindgen_ty_11 = 12;
pub const SPINEL_NCP_LOG_REGION_OT_PLATFORM: _bindgen_ty_11 = 13;
pub const SPINEL_NCP_LOG_REGION_OT_COAP: _bindgen_ty_11 = 14;
pub const SPINEL_NCP_LOG_REGION_OT_CLI: _bindgen_ty_11 = 15;
pub const SPINEL_NCP_LOG_REGION_OT_CORE: _bindgen_ty_11 = 16;
pub const SPINEL_NCP_LOG_REGION_OT_UTIL: _bindgen_ty_11 = 17;
pub const SPINEL_NCP_LOG_REGION_OT_BBR: _bindgen_ty_11 = 18;
pub const SPINEL_NCP_LOG_REGION_OT_MLR: _bindgen_ty_11 = 19;
pub const SPINEL_NCP_LOG_REGION_OT_DUA: _bindgen_ty_11 = 20;
pub const SPINEL_NCP_LOG_REGION_OT_BR: _bindgen_ty_11 = 21;
pub const SPINEL_NCP_LOG_REGION_OT_SRP: _bindgen_ty_11 = 22;
pub const SPINEL_NCP_LOG_REGION_OT_DNS: _bindgen_ty_11 = 23;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const SPINEL_MESHCOP_COMMISSIONER_STATE_DISABLED: _bindgen_ty_12 = 0;
pub const SPINEL_MESHCOP_COMMISSIONER_STATE_PETITION: _bindgen_ty_12 = 1;
pub const SPINEL_MESHCOP_COMMISSIONER_STATE_ACTIVE: _bindgen_ty_12 = 2;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const SPINEL_ADDRESS_CACHE_ENTRY_STATE_CACHED: _bindgen_ty_13 = 0;
pub const SPINEL_ADDRESS_CACHE_ENTRY_STATE_SNOOPED: _bindgen_ty_13 = 1;
pub const SPINEL_ADDRESS_CACHE_ENTRY_STATE_QUERY: _bindgen_ty_13 = 2;
pub const SPINEL_ADDRESS_CACHE_ENTRY_STATE_RETRY_QUERY: _bindgen_ty_13 = 3;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const SPINEL_RADIO_LINK_IEEE_802_15_4: _bindgen_ty_14 = 0;
pub const SPINEL_RADIO_LINK_TREL_UDP6: _bindgen_ty_14 = 1;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const SPINEL_LINK_METRICS_STATUS_SUCCESS: _bindgen_ty_15 = 0;
pub const SPINEL_LINK_METRICS_STATUS_CANNOT_SUPPORT_NEW_SERIES: _bindgen_ty_15 = 1;
pub const SPINEL_LINK_METRICS_STATUS_SERIESID_ALREADY_REGISTERED: _bindgen_ty_15 = 2;
pub const SPINEL_LINK_METRICS_STATUS_SERIESID_NOT_RECOGNIZED: _bindgen_ty_15 = 3;
pub const SPINEL_LINK_METRICS_STATUS_NO_MATCHING_FRAMES_RECEIVED: _bindgen_ty_15 = 4;
pub const SPINEL_LINK_METRICS_STATUS_OTHER_ERROR: _bindgen_ty_15 = 254;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const SPINEL_THREAD_LINK_METRIC_PDU_COUNT: _bindgen_ty_16 = 1;
pub const SPINEL_THREAD_LINK_METRIC_LQI: _bindgen_ty_16 = 2;
pub const SPINEL_THREAD_LINK_METRIC_LINK_MARGIN: _bindgen_ty_16 = 4;
pub const SPINEL_THREAD_LINK_METRIC_RSSI: _bindgen_ty_16 = 8;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const SPINEL_THREAD_FRAME_TYPE_MLE_LINK_PROBE: _bindgen_ty_17 = 1;
pub const SPINEL_THREAD_FRAME_TYPE_MAC_DATA: _bindgen_ty_17 = 2;
pub const SPINEL_THREAD_FRAME_TYPE_MAC_DATA_REQUEST: _bindgen_ty_17 = 4;
pub const SPINEL_THREAD_FRAME_TYPE_MAC_ACK: _bindgen_ty_17 = 8;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const SPINEL_THREAD_MLR_PARAMID_TIMEOUT: _bindgen_ty_18 = 0;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const SPINEL_THREAD_BACKBONE_ROUTER_STATE_DISABLED: _bindgen_ty_19 = 0;
pub const SPINEL_THREAD_BACKBONE_ROUTER_STATE_SECONDARY: _bindgen_ty_19 = 1;
pub const SPINEL_THREAD_BACKBONE_ROUTER_STATE_PRIMARY: _bindgen_ty_19 = 2;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
#[doc = "!< Packet was transmitted, not received."]
pub const SPINEL_MD_FLAG_TX: _bindgen_ty_20 = 1;
#[doc = "!< Packet was received with bad FCS"]
pub const SPINEL_MD_FLAG_BAD_FCS: _bindgen_ty_20 = 4;
#[doc = "!< Packet seems to be a duplicate"]
pub const SPINEL_MD_FLAG_DUPE: _bindgen_ty_20 = 8;
#[doc = "!< Packet was acknowledged with frame pending set"]
pub const SPINEL_MD_FLAG_ACKED_FP: _bindgen_ty_20 = 16;
#[doc = "!< Packet was acknowledged with secure enhance ACK"]
pub const SPINEL_MD_FLAG_ACKED_SEC: _bindgen_ty_20 = 32;
#[doc = "!< Flags reserved for future use."]
pub const SPINEL_MD_FLAG_RESERVED: _bindgen_ty_20 = 65474;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
pub const SPINEL_RESET_PLATFORM: _bindgen_ty_21 = 1;
pub const SPINEL_RESET_STACK: _bindgen_ty_21 = 2;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
#[doc = " No-Operation command (Host -> NCP)\n\n Encoding: Empty\n\n Induces the NCP to send a success status back to the host. This is\n primarily used for liveliness checks. The command payload for this\n command SHOULD be empty.\n\n There is no error condition for this command.\n"]
pub const SPINEL_CMD_NOOP: _bindgen_ty_22 = 0;
#[doc = " Reset NCP command (Host -> NCP)\n\n Encoding: Empty or `C`\n\n Causes the NCP to perform a software reset. Due to the nature of\n this command, the TID is ignored. The host should instead wait\n for a `CMD_PROP_VALUE_IS` command from the NCP indicating\n `PROP_LAST_STATUS` has been set to `STATUS_RESET_SOFTWARE`.\n\n The optional command payload specifies the reset type, can be\n `SPINEL_RESET_PLATFORM` or `SPINEL_RESET_STACK`. Defaults to stack\n reset if unspecified.\n\n If an error occurs, the value of `PROP_LAST_STATUS` will be emitted\n instead with the value set to the generated status code for the error.\n"]
pub const SPINEL_CMD_RESET: _bindgen_ty_22 = 1;
#[doc = " Get property value command (Host -> NCP)\n\n Encoding: `i`\n   `i` : Property Id\n\n Causes the NCP to emit a `CMD_PROP_VALUE_IS` command for the\n given property identifier.\n\n The payload for this command is the property identifier encoded\n in the packed unsigned integer format `i`.\n\n If an error occurs, the value of `PROP_LAST_STATUS` will be emitted\n instead with the value set to the generated status code for the error.\n"]
pub const SPINEL_CMD_PROP_VALUE_GET: _bindgen_ty_22 = 2;
#[doc = " Set property value command (Host -> NCP)\n\n Encoding: `iD`\n   `i` : Property Id\n   `D` : Value (encoding depends on the property)\n\n Instructs the NCP to set the given property to the specific given\n value, replacing any previous value.\n\n The payload for this command is the property identifier encoded in the\n packed unsigned integer format, followed by the property value. The\n exact format of the property value is defined by the property.\n\n On success a `CMD_PROP_VALUE_IS` command is emitted either for the\n given property identifier with the set value, or for `PROP_LAST_STATUS`\n with value `LAST_STATUS_OK`.\n\n If an error occurs, the value of `PROP_LAST_STATUS` will be emitted\n with the value set to the generated status code for the error.\n"]
pub const SPINEL_CMD_PROP_VALUE_SET: _bindgen_ty_22 = 3;
#[doc = " Insert value into property command (Host -> NCP)\n\n Encoding: `iD`\n   `i` : Property Id\n   `D` : Value (encoding depends on the property)\n\n Instructs the NCP to insert the given value into a list-oriented\n property without removing other items in the list. The resulting order\n of items in the list is defined by the individual property being\n operated on.\n\n The payload for this command is the property identifier encoded in the\n packed unsigned integer format, followed by the value to be inserted.\n The exact format of the value is defined by the property.\n\n If the type signature of the property consists of a single structure\n enclosed by an array `A(t(...))`, then the contents of value MUST\n contain the contents of the structure (`...`) rather than the\n serialization of the whole item (`t(...)`).  Specifically, the length\n of the structure MUST NOT be prepended to value. This helps to\n eliminate redundant data.\n\n On success, either a `CMD_PROP_VALUE_INSERTED` command is emitted for\n the given property, or a `CMD_PROP_VALUE_IS` command is emitted of\n property `PROP_LAST_STATUS` with value `LAST_STATUS_OK`.\n\n If an error occurs, the value of `PROP_LAST_STATUS` will be emitted\n with the value set to the generated status code for the error.\n"]
pub const SPINEL_CMD_PROP_VALUE_INSERT: _bindgen_ty_22 = 4;
#[doc = " Remove value from property command (Host -> NCP)\n\n Encoding: `iD`\n   `i` : Property Id\n   `D` : Value (encoding depends on the property)\n\n Instructs the NCP to remove the given value from a list-oriented property,\n without affecting other items in the list. The resulting order of items\n in the list is defined by the individual property being operated on.\n\n Note that this command operates by value, not by index!\n\n The payload for this command is the property identifier encoded in the\n packed unsigned integer format, followed by the value to be removed. The\n exact format of the value is defined by the property.\n\n If the type signature of the property consists of a single structure\n enclosed by an array `A(t(...))`, then the contents of value MUST contain\n the contents of the structure (`...`) rather than the serialization of the\n whole item (`t(...)`).  Specifically, the length of the structure MUST NOT\n be prepended to `VALUE`. This helps to eliminate redundant data.\n\n On success, either a `CMD_PROP_VALUE_REMOVED` command is emitted for the\n given property, or a `CMD_PROP_VALUE_IS` command is emitted of property\n `PROP_LAST_STATUS` with value `LAST_STATUS_OK`.\n\n If an error occurs, the value of `PROP_LAST_STATUS` will be emitted\n with the value set to the generated status code for the error.\n"]
pub const SPINEL_CMD_PROP_VALUE_REMOVE: _bindgen_ty_22 = 5;
#[doc = " Property value notification command (NCP -> Host)\n\n Encoding: `iD`\n   `i` : Property Id\n   `D` : Value (encoding depends on the property)\n\n This command can be sent by the NCP in response to a previous command\n from the host, or it can be sent by the NCP in an unsolicited fashion\n to notify the host of various state changes asynchronously.\n\n The payload for this command is the property identifier encoded in the\n packed unsigned integer format, followed by the current value of the\n given property.\n"]
pub const SPINEL_CMD_PROP_VALUE_IS: _bindgen_ty_22 = 6;
#[doc = " Property value insertion notification command (NCP -> Host)\n\n Encoding:`iD`\n   `i` : Property Id\n   `D` : Value (encoding depends on the property)\n\n This command can be sent by the NCP in response to the\n `CMD_PROP_VALUE_INSERT` command, or it can be sent by the NCP in an\n unsolicited fashion to notify the host of various state changes\n asynchronously.\n\n The payload for this command is the property identifier encoded in the\n packed unsigned integer format, followed by the value that was inserted\n into the given property.\n\n If the type signature of the property specified by property id consists\n of a single structure enclosed by an array (`A(t(...))`), then the\n contents of value MUST contain the contents of the structure (`...`)\n rather than the serialization of the whole item (`t(...)`). Specifically,\n the length of the structure MUST NOT be prepended to `VALUE`. This\n helps to eliminate redundant data.\n\n The resulting order of items in the list is defined by the given\n property.\n"]
pub const SPINEL_CMD_PROP_VALUE_INSERTED: _bindgen_ty_22 = 7;
#[doc = " Property value removal notification command (NCP -> Host)\n\n Encoding: `iD`\n   `i` : Property Id\n   `D` : Value (encoding depends on the property)\n\n This command can be sent by the NCP in response to the\n `CMD_PROP_VALUE_REMOVE` command, or it can be sent by the NCP in an\n unsolicited fashion to notify the host of various state changes\n asynchronously.\n\n Note that this command operates by value, not by index!\n\n The payload for this command is the property identifier encoded in the\n packed unsigned integer format described in followed by the value that\n was removed from the given property.\n\n If the type signature of the property specified by property id consists\n of a single structure enclosed by an array (`A(t(...))`), then the\n contents of value MUST contain the contents of the structure (`...`)\n rather than the serialization of the whole item (`t(...)`).  Specifically,\n the length of the structure MUST NOT be prepended to `VALUE`. This\n helps to eliminate redundant data.\n\n The resulting order of items in the list is defined by the given\n property.\n"]
pub const SPINEL_CMD_PROP_VALUE_REMOVED: _bindgen_ty_22 = 8;
#[doc = " Property value removal notification command (NCP -> Host)\n\n Encoding: `iD`\n   `i` : Property Id\n   `D` : Value (encoding depends on the property)\n\n This command can be sent by the NCP in response to the\n `CMD_PROP_VALUE_REMOVE` command, or it can be sent by the NCP in an\n unsolicited fashion to notify the host of various state changes\n asynchronously.\n\n Note that this command operates by value, not by index!\n\n The payload for this command is the property identifier encoded in the\n packed unsigned integer format described in followed by the value that\n was removed from the given property.\n\n If the type signature of the property specified by property id consists\n of a single structure enclosed by an array (`A(t(...))`), then the\n contents of value MUST contain the contents of the structure (`...`)\n rather than the serialization of the whole item (`t(...)`).  Specifically,\n the length of the structure MUST NOT be prepended to `VALUE`. This\n helps to eliminate redundant data.\n\n The resulting order of items in the list is defined by the given\n property.\n"]
pub const SPINEL_CMD_NET_SAVE: _bindgen_ty_22 = 9;
#[doc = " Clear saved network settings command (Host -> NCP)\n\n Encoding: Empty\n\n Erases all network credentials and state from non-volatile memory.\n\n This operation affects non-volatile memory only. The current network\n information stored in volatile memory is unaffected.\n\n The response to this command is always a `CMD_PROP_VALUE_IS` for\n `PROP_LAST_STATUS`, indicating the result of the operation.\n"]
pub const SPINEL_CMD_NET_CLEAR: _bindgen_ty_22 = 10;
#[doc = " Clear saved network settings command (Host -> NCP)\n\n Encoding: Empty\n\n Erases all network credentials and state from non-volatile memory.\n\n This operation affects non-volatile memory only. The current network\n information stored in volatile memory is unaffected.\n\n The response to this command is always a `CMD_PROP_VALUE_IS` for\n `PROP_LAST_STATUS`, indicating the result of the operation.\n"]
pub const SPINEL_CMD_NET_RECALL: _bindgen_ty_22 = 11;
#[doc = " Host buffer offload is an optional NCP capability that, when\n present, allows the NCP to store data buffers on the host processor\n that can be recalled at a later time.\n\n The presence of this feature can be detected by the host by\n checking for the presence of the `CAP_HBO`\n capability in `PROP_CAPS`.\n\n This feature is not currently supported on OpenThread.\n"]
pub const SPINEL_CMD_HBO_OFFLOAD: _bindgen_ty_22 = 12;
#[doc = " Host buffer offload is an optional NCP capability that, when\n present, allows the NCP to store data buffers on the host processor\n that can be recalled at a later time.\n\n The presence of this feature can be detected by the host by\n checking for the presence of the `CAP_HBO`\n capability in `PROP_CAPS`.\n\n This feature is not currently supported on OpenThread.\n"]
pub const SPINEL_CMD_HBO_RECLAIM: _bindgen_ty_22 = 13;
#[doc = " Host buffer offload is an optional NCP capability that, when\n present, allows the NCP to store data buffers on the host processor\n that can be recalled at a later time.\n\n The presence of this feature can be detected by the host by\n checking for the presence of the `CAP_HBO`\n capability in `PROP_CAPS`.\n\n This feature is not currently supported on OpenThread.\n"]
pub const SPINEL_CMD_HBO_DROP: _bindgen_ty_22 = 14;
#[doc = " Host buffer offload is an optional NCP capability that, when\n present, allows the NCP to store data buffers on the host processor\n that can be recalled at a later time.\n\n The presence of this feature can be detected by the host by\n checking for the presence of the `CAP_HBO`\n capability in `PROP_CAPS`.\n\n This feature is not currently supported on OpenThread.\n"]
pub const SPINEL_CMD_HBO_OFFLOADED: _bindgen_ty_22 = 15;
#[doc = " Host buffer offload is an optional NCP capability that, when\n present, allows the NCP to store data buffers on the host processor\n that can be recalled at a later time.\n\n The presence of this feature can be detected by the host by\n checking for the presence of the `CAP_HBO`\n capability in `PROP_CAPS`.\n\n This feature is not currently supported on OpenThread.\n"]
pub const SPINEL_CMD_HBO_RECLAIMED: _bindgen_ty_22 = 16;
#[doc = " Host buffer offload is an optional NCP capability that, when\n present, allows the NCP to store data buffers on the host processor\n that can be recalled at a later time.\n\n The presence of this feature can be detected by the host by\n checking for the presence of the `CAP_HBO`\n capability in `PROP_CAPS`.\n\n This feature is not currently supported on OpenThread.\n"]
pub const SPINEL_CMD_HBO_DROPPED: _bindgen_ty_22 = 17;
#[doc = " Peek command (Host -> NCP)\n\n Encoding: `LU`\n   `L` : The address to peek\n   `U` : Number of bytes to read\n\n This command allows the NCP to fetch values from the RAM of the NCP\n for debugging purposes. Upon success, `CMD_PEEK_RET` is sent from the\n NCP to the host. Upon failure, `PROP_LAST_STATUS` is emitted with\n the appropriate error indication.\n\n The NCP MAY prevent certain regions of memory from being accessed.\n\n This command requires the capability `CAP_PEEK_POKE` to be present.\n"]
pub const SPINEL_CMD_PEEK: _bindgen_ty_22 = 18;
#[doc = " Peek return command (NCP -> Host)\n\n Encoding: `LUD`\n   `L` : The address peeked\n   `U` : Number of bytes read\n   `D` : Memory content\n\n This command contains the contents of memory that was requested by\n a previous call to `CMD_PEEK`.\n\n This command requires the capability `CAP_PEEK_POKE` to be present.\n"]
pub const SPINEL_CMD_PEEK_RET: _bindgen_ty_22 = 19;
#[doc = " Poke command (Host -> NCP)\n\n Encoding: `LUD`\n   `L` : The address to be poked\n   `U` : Number of bytes to write\n   `D` : Content to write\n\n This command writes the bytes to the specified memory address\n for debugging purposes.\n\n This command requires the capability `CAP_PEEK_POKE` to be present.\n"]
pub const SPINEL_CMD_POKE: _bindgen_ty_22 = 20;
#[doc = " Poke command (Host -> NCP)\n\n Encoding: `LUD`\n   `L` : The address to be poked\n   `U` : Number of bytes to write\n   `D` : Content to write\n\n This command writes the bytes to the specified memory address\n for debugging purposes.\n\n This command requires the capability `CAP_PEEK_POKE` to be present.\n"]
pub const SPINEL_CMD_PROP_VALUE_MULTI_GET: _bindgen_ty_22 = 21;
#[doc = " Poke command (Host -> NCP)\n\n Encoding: `LUD`\n   `L` : The address to be poked\n   `U` : Number of bytes to write\n   `D` : Content to write\n\n This command writes the bytes to the specified memory address\n for debugging purposes.\n\n This command requires the capability `CAP_PEEK_POKE` to be present.\n"]
pub const SPINEL_CMD_PROP_VALUE_MULTI_SET: _bindgen_ty_22 = 22;
#[doc = " Poke command (Host -> NCP)\n\n Encoding: `LUD`\n   `L` : The address to be poked\n   `U` : Number of bytes to write\n   `D` : Content to write\n\n This command writes the bytes to the specified memory address\n for debugging purposes.\n\n This command requires the capability `CAP_PEEK_POKE` to be present.\n"]
pub const SPINEL_CMD_PROP_VALUES_ARE: _bindgen_ty_22 = 23;
#[doc = " Poke command (Host -> NCP)\n\n Encoding: `LUD`\n   `L` : The address to be poked\n   `U` : Number of bytes to write\n   `D` : Content to write\n\n This command writes the bytes to the specified memory address\n for debugging purposes.\n\n This command requires the capability `CAP_PEEK_POKE` to be present.\n"]
pub const SPINEL_CMD_NEST__BEGIN: _bindgen_ty_22 = 15296;
#[doc = " Poke command (Host -> NCP)\n\n Encoding: `LUD`\n   `L` : The address to be poked\n   `U` : Number of bytes to write\n   `D` : Content to write\n\n This command writes the bytes to the specified memory address\n for debugging purposes.\n\n This command requires the capability `CAP_PEEK_POKE` to be present.\n"]
pub const SPINEL_CMD_NEST__END: _bindgen_ty_22 = 15360;
#[doc = " Poke command (Host -> NCP)\n\n Encoding: `LUD`\n   `L` : The address to be poked\n   `U` : Number of bytes to write\n   `D` : Content to write\n\n This command writes the bytes to the specified memory address\n for debugging purposes.\n\n This command requires the capability `CAP_PEEK_POKE` to be present.\n"]
pub const SPINEL_CMD_VENDOR__BEGIN: _bindgen_ty_22 = 15360;
#[doc = " Poke command (Host -> NCP)\n\n Encoding: `LUD`\n   `L` : The address to be poked\n   `U` : Number of bytes to write\n   `D` : Content to write\n\n This command writes the bytes to the specified memory address\n for debugging purposes.\n\n This command requires the capability `CAP_PEEK_POKE` to be present.\n"]
pub const SPINEL_CMD_VENDOR__END: _bindgen_ty_22 = 16384;
#[doc = " Poke command (Host -> NCP)\n\n Encoding: `LUD`\n   `L` : The address to be poked\n   `U` : Number of bytes to write\n   `D` : Content to write\n\n This command writes the bytes to the specified memory address\n for debugging purposes.\n\n This command requires the capability `CAP_PEEK_POKE` to be present.\n"]
pub const SPINEL_CMD_EXPERIMENTAL__BEGIN: _bindgen_ty_22 = 2000000;
#[doc = " Poke command (Host -> NCP)\n\n Encoding: `LUD`\n   `L` : The address to be poked\n   `U` : Number of bytes to write\n   `D` : Content to write\n\n This command writes the bytes to the specified memory address\n for debugging purposes.\n\n This command requires the capability `CAP_PEEK_POKE` to be present.\n"]
pub const SPINEL_CMD_EXPERIMENTAL__END: _bindgen_ty_22 = 2097152;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub const SPINEL_CAP_LOCK: _bindgen_ty_23 = 1;
pub const SPINEL_CAP_NET_SAVE: _bindgen_ty_23 = 2;
pub const SPINEL_CAP_HBO: _bindgen_ty_23 = 3;
pub const SPINEL_CAP_POWER_SAVE: _bindgen_ty_23 = 4;
pub const SPINEL_CAP_COUNTERS: _bindgen_ty_23 = 5;
pub const SPINEL_CAP_JAM_DETECT: _bindgen_ty_23 = 6;
pub const SPINEL_CAP_PEEK_POKE: _bindgen_ty_23 = 7;
pub const SPINEL_CAP_WRITABLE_RAW_STREAM: _bindgen_ty_23 = 8;
pub const SPINEL_CAP_GPIO: _bindgen_ty_23 = 9;
pub const SPINEL_CAP_TRNG: _bindgen_ty_23 = 10;
pub const SPINEL_CAP_CMD_MULTI: _bindgen_ty_23 = 11;
pub const SPINEL_CAP_UNSOL_UPDATE_FILTER: _bindgen_ty_23 = 12;
pub const SPINEL_CAP_MCU_POWER_STATE: _bindgen_ty_23 = 13;
pub const SPINEL_CAP_PCAP: _bindgen_ty_23 = 14;
pub const SPINEL_CAP_802_15_4__BEGIN: _bindgen_ty_23 = 16;
pub const SPINEL_CAP_802_15_4_2003: _bindgen_ty_23 = 16;
pub const SPINEL_CAP_802_15_4_2006: _bindgen_ty_23 = 17;
pub const SPINEL_CAP_802_15_4_2011: _bindgen_ty_23 = 18;
pub const SPINEL_CAP_802_15_4_PIB: _bindgen_ty_23 = 21;
pub const SPINEL_CAP_802_15_4_2450MHZ_OQPSK: _bindgen_ty_23 = 24;
pub const SPINEL_CAP_802_15_4_915MHZ_OQPSK: _bindgen_ty_23 = 25;
pub const SPINEL_CAP_802_15_4_868MHZ_OQPSK: _bindgen_ty_23 = 26;
pub const SPINEL_CAP_802_15_4_915MHZ_BPSK: _bindgen_ty_23 = 27;
pub const SPINEL_CAP_802_15_4_868MHZ_BPSK: _bindgen_ty_23 = 28;
pub const SPINEL_CAP_802_15_4_915MHZ_ASK: _bindgen_ty_23 = 29;
pub const SPINEL_CAP_802_15_4_868MHZ_ASK: _bindgen_ty_23 = 30;
pub const SPINEL_CAP_802_15_4__END: _bindgen_ty_23 = 32;
pub const SPINEL_CAP_CONFIG__BEGIN: _bindgen_ty_23 = 32;
pub const SPINEL_CAP_CONFIG_FTD: _bindgen_ty_23 = 32;
pub const SPINEL_CAP_CONFIG_MTD: _bindgen_ty_23 = 33;
pub const SPINEL_CAP_CONFIG_RADIO: _bindgen_ty_23 = 34;
pub const SPINEL_CAP_CONFIG__END: _bindgen_ty_23 = 40;
pub const SPINEL_CAP_ROLE__BEGIN: _bindgen_ty_23 = 48;
pub const SPINEL_CAP_ROLE_ROUTER: _bindgen_ty_23 = 48;
pub const SPINEL_CAP_ROLE_SLEEPY: _bindgen_ty_23 = 49;
pub const SPINEL_CAP_ROLE__END: _bindgen_ty_23 = 52;
pub const SPINEL_CAP_NET__BEGIN: _bindgen_ty_23 = 52;
pub const SPINEL_CAP_NET_THREAD_1_0: _bindgen_ty_23 = 52;
pub const SPINEL_CAP_NET_THREAD_1_1: _bindgen_ty_23 = 53;
pub const SPINEL_CAP_NET_THREAD_1_2: _bindgen_ty_23 = 54;
pub const SPINEL_CAP_NET__END: _bindgen_ty_23 = 64;
pub const SPINEL_CAP_RCP__BEGIN: _bindgen_ty_23 = 64;
pub const SPINEL_CAP_RCP_API_VERSION: _bindgen_ty_23 = 64;
pub const SPINEL_CAP_RCP_MIN_HOST_API_VERSION: _bindgen_ty_23 = 65;
pub const SPINEL_CAP_RCP__END: _bindgen_ty_23 = 80;
pub const SPINEL_CAP_OPENTHREAD__BEGIN: _bindgen_ty_23 = 512;
pub const SPINEL_CAP_MAC_ALLOWLIST: _bindgen_ty_23 = 512;
pub const SPINEL_CAP_MAC_RAW: _bindgen_ty_23 = 513;
pub const SPINEL_CAP_OOB_STEERING_DATA: _bindgen_ty_23 = 514;
pub const SPINEL_CAP_CHANNEL_MONITOR: _bindgen_ty_23 = 515;
pub const SPINEL_CAP_ERROR_RATE_TRACKING: _bindgen_ty_23 = 516;
pub const SPINEL_CAP_CHANNEL_MANAGER: _bindgen_ty_23 = 517;
pub const SPINEL_CAP_OPENTHREAD_LOG_METADATA: _bindgen_ty_23 = 518;
pub const SPINEL_CAP_TIME_SYNC: _bindgen_ty_23 = 519;
pub const SPINEL_CAP_CHILD_SUPERVISION: _bindgen_ty_23 = 520;
pub const SPINEL_CAP_POSIX: _bindgen_ty_23 = 521;
pub const SPINEL_CAP_SLAAC: _bindgen_ty_23 = 522;
pub const SPINEL_CAP_RADIO_COEX: _bindgen_ty_23 = 523;
pub const SPINEL_CAP_MAC_RETRY_HISTOGRAM: _bindgen_ty_23 = 524;
pub const SPINEL_CAP_MULTI_RADIO: _bindgen_ty_23 = 525;
pub const SPINEL_CAP_SRP_CLIENT: _bindgen_ty_23 = 526;
pub const SPINEL_CAP_DUA: _bindgen_ty_23 = 527;
pub const SPINEL_CAP_REFERENCE_DEVICE: _bindgen_ty_23 = 528;
pub const SPINEL_CAP_OPENTHREAD__END: _bindgen_ty_23 = 640;
pub const SPINEL_CAP_THREAD__BEGIN: _bindgen_ty_23 = 1024;
pub const SPINEL_CAP_THREAD_COMMISSIONER: _bindgen_ty_23 = 1024;
pub const SPINEL_CAP_THREAD_TMF_PROXY: _bindgen_ty_23 = 1025;
pub const SPINEL_CAP_THREAD_UDP_FORWARD: _bindgen_ty_23 = 1026;
pub const SPINEL_CAP_THREAD_JOINER: _bindgen_ty_23 = 1027;
pub const SPINEL_CAP_THREAD_BORDER_ROUTER: _bindgen_ty_23 = 1028;
pub const SPINEL_CAP_THREAD_SERVICE: _bindgen_ty_23 = 1029;
pub const SPINEL_CAP_THREAD_CSL_RECEIVER: _bindgen_ty_23 = 1030;
pub const SPINEL_CAP_THREAD_LINK_METRICS: _bindgen_ty_23 = 1031;
pub const SPINEL_CAP_THREAD_BACKBONE_ROUTER: _bindgen_ty_23 = 1032;
pub const SPINEL_CAP_THREAD__END: _bindgen_ty_23 = 1152;
pub const SPINEL_CAP_NEST__BEGIN: _bindgen_ty_23 = 15296;
#[doc = "< deprecated"]
pub const SPINEL_CAP_NEST_LEGACY_INTERFACE: _bindgen_ty_23 = 15296;
#[doc = "< deprecated"]
pub const SPINEL_CAP_NEST_LEGACY_NET_WAKE: _bindgen_ty_23 = 15297;
pub const SPINEL_CAP_NEST_TRANSMIT_HOOK: _bindgen_ty_23 = 15298;
pub const SPINEL_CAP_NEST__END: _bindgen_ty_23 = 15360;
pub const SPINEL_CAP_VENDOR__BEGIN: _bindgen_ty_23 = 15360;
pub const SPINEL_CAP_VENDOR__END: _bindgen_ty_23 = 16384;
pub const SPINEL_CAP_EXPERIMENTAL__BEGIN: _bindgen_ty_23 = 2000000;
pub const SPINEL_CAP_EXPERIMENTAL__END: _bindgen_ty_23 = 2097152;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
#[doc = " Last Operation Status\n** Format: `i` - Read-only\n*\n* Describes the status of the last operation. Encoded as a packed\n* unsigned integer (see `SPINEL_STATUS_*` for list of values).\n*\n* This property is emitted often to indicate the result status of\n* pretty much any Host-to-NCP operation.\n*\n* It is emitted automatically at NCP startup with a value indicating\n* the reset reason. It is also emitted asynchronously on an error (\n* e.g., NCP running out of buffer).\n*\n*/"]
pub const SPINEL_PROP_LAST_STATUS: _bindgen_ty_24 = 0;
#[doc = " Protocol Version\n** Format: `ii` - Read-only\n*\n* Describes the protocol version information. This property contains\n* two fields, each encoded as a packed unsigned integer:\n*   `i`: Major Version Number\n*   `i`: Minor Version Number\n*\n* The version number is defined by `SPINEL_PROTOCOL_VERSION_THREAD_MAJOR`\n* and `SPINEL_PROTOCOL_VERSION_THREAD_MINOR`.\n*\n* This specification describes major version 4, minor version 3.\n*\n*/"]
pub const SPINEL_PROP_PROTOCOL_VERSION: _bindgen_ty_24 = 1;
#[doc = " NCP Version\n** Format: `U` - Read-only\n*\n* Contains a string which describes the firmware currently running on\n* the NCP. Encoded as a zero-terminated UTF-8 string.\n*\n*/"]
pub const SPINEL_PROP_NCP_VERSION: _bindgen_ty_24 = 2;
#[doc = " NCP Network Protocol Type\n** Format: 'i' - Read-only\n*\n* This value identifies what the network protocol for this NCP.\n* The valid protocol type values are defined by enumeration\n* `SPINEL_PROTOCOL_TYPE_*`:\n*\n*   `SPINEL_PROTOCOL_TYPE_BOOTLOADER` = 0\n*   `SPINEL_PROTOCOL_TYPE_ZIGBEE_IP`  = 2,\n*   `SPINEL_PROTOCOL_TYPE_THREAD`     = 3,\n*\n* OpenThread NCP supports only `SPINEL_PROTOCOL_TYPE_THREAD`\n*\n*/"]
pub const SPINEL_PROP_INTERFACE_TYPE: _bindgen_ty_24 = 3;
#[doc = " NCP Vendor ID\n** Format: 'i` - Read-only\n*\n* Vendor ID. Zero for unknown.\n*\n*/"]
pub const SPINEL_PROP_VENDOR_ID: _bindgen_ty_24 = 4;
#[doc = " NCP Capability List\n** Format: 'A(i)` - Read-only\n*\n* Describes the supported capabilities of this NCP. Encoded as a list of\n* packed unsigned integers.\n*\n* The capability values are specified by SPINEL_CAP_* enumeration.\n*\n*/"]
pub const SPINEL_PROP_CAPS: _bindgen_ty_24 = 5;
#[doc = " NCP Interface Count\n** Format: 'C` - Read-only\n*\n* Provides number of interfaces.\n*\n* Currently always reads as 1.\n*\n*/"]
pub const SPINEL_PROP_INTERFACE_COUNT: _bindgen_ty_24 = 6;
#[doc = "< PowerState [C] (deprecated, use `MCU_POWER_STATE` instead)."]
pub const SPINEL_PROP_POWER_STATE: _bindgen_ty_24 = 7;
#[doc = " NCP Hardware Address\n** Format: 'E` - Read-only\n*\n* The static EUI64 address of the device, used as a serial number.\n*\n*/"]
pub const SPINEL_PROP_HWADDR: _bindgen_ty_24 = 8;
#[doc = "< PropLock [b] (not supported)"]
pub const SPINEL_PROP_LOCK: _bindgen_ty_24 = 9;
#[doc = "< Max offload mem [S] (not supported)"]
pub const SPINEL_PROP_HBO_MEM_MAX: _bindgen_ty_24 = 10;
#[doc = "< Max offload block [S] (not supported)"]
pub const SPINEL_PROP_HBO_BLOCK_MAX: _bindgen_ty_24 = 11;
#[doc = " Host Power State\n** Format: 'C`\n*\n* Describes the current power state of the host. This property is used\n* by the host to inform the NCP when it has changed power states. The\n* NCP can then use this state to determine which properties need\n* asynchronous updates. Enumeration `spinel_host_power_state_t` defines\n* the valid values (`SPINEL_HOST_POWER_STATE_*`):\n*\n*   `HOST_POWER_STATE_OFFLINE`: Host is physically powered off and\n*   cannot be woken by the NCP. All asynchronous commands are\n*   squelched.\n*\n*   `HOST_POWER_STATE_DEEP_SLEEP`: The host is in a low power state\n*   where it can be woken by the NCP but will potentially require more\n*   than two seconds to become fully responsive. The NCP MUST\n*   avoid sending unnecessary property updates, such as child table\n*   updates or non-critical messages on the debug stream. If the NCP\n*   needs to wake the host for traffic, the NCP MUST first take\n*   action to wake the host. Once the NCP signals to the host that it\n*   should wake up, the NCP MUST wait for some activity from the\n*   host (indicating that it is fully awake) before sending frames.\n*\n*   `HOST_POWER_STATE_RESERVED`:  This value MUST NOT be set by the host. If\n*   received by the NCP, the NCP SHOULD consider this as a synonym\n*   of `HOST_POWER_STATE_DEEP_SLEEP`.\n*\n*   `HOST_POWER_STATE_LOW_POWER`: The host is in a low power state\n*   where it can be immediately woken by the NCP. The NCP SHOULD\n*   avoid sending unnecessary property updates, such as child table\n*   updates or non-critical messages on the debug stream.\n*\n*   `HOST_POWER_STATE_ONLINE`: The host is awake and responsive. No\n*   special filtering is performed by the NCP on asynchronous updates.\n*\n*   All other values are RESERVED. They MUST NOT be set by the\n*   host. If received by the NCP, the NCP SHOULD consider the value as\n*   a synonym of `HOST_POWER_STATE_LOW_POWER`.\n*\n* After setting this power state, any further commands from the host to\n* the NCP will cause `HOST_POWER_STATE` to automatically revert to\n* `HOST_POWER_STATE_ONLINE`.\n*\n* When the host is entering a low-power state, it should wait for the\n* response from the NCP acknowledging the command (with `CMD_VALUE_IS`).\n* Once that acknowledgment is received the host may enter the low-power\n* state.\n*\n* If the NCP has the `CAP_UNSOL_UPDATE_FILTER` capability, any unsolicited\n* property updates masked by `PROP_UNSOL_UPDATE_FILTER` should be honored\n* while the host indicates it is in a low-power state. After resuming to the\n* `HOST_POWER_STATE_ONLINE` state, the value of `PROP_UNSOL_UPDATE_FILTER`\n* MUST be unchanged from the value assigned prior to the host indicating\n* it was entering a low-power state.\n*\n*/"]
pub const SPINEL_PROP_HOST_POWER_STATE: _bindgen_ty_24 = 12;
#[doc = " NCP's MCU Power State\n** Format: 'C`\n*  Required capability: CAP_MCU_POWER_SAVE\n*\n* This property specifies the desired power state of NCP's micro-controller\n* (MCU) when the underlying platform's operating system enters idle mode (i.e.,\n* all active tasks/events are processed and the MCU can potentially enter a\n* energy-saving power state).\n*\n* The power state primarily determines how the host should interact with the NCP\n* and whether the host needs an external trigger (a \"poke\") to NCP before it can\n* communicate with the NCP or not. After a reset, the MCU power state MUST be\n* SPINEL_MCU_POWER_STATE_ON.\n*\n* Enumeration `spinel_mcu_power_state_t` defines the valid values\n* (`SPINEL_MCU_POWER_STATE_*` constants):\n*\n*   `SPINEL_MCU_POWER_STATE_ON`: NCP's MCU stays on and active all the time.\n*   When the NCP's desired power state is set to this value, host can send\n*   messages to NCP without requiring any \"poke\" or external triggers. MCU is\n*   expected to stay on and active. Note that the `ON` power state only\n*   determines the MCU's power mode and is not related to radio's state.\n*\n*   `SPINEL_MCU_POWER_STATE_LOW_POWER`: NCP's MCU can enter low-power\n*   (energy-saving) state. When the NCP's desired power state is set to\n*   `LOW_POWER`, host is expected to \"poke\" the NCP (e.g., an external trigger\n*   like an interrupt) before it can communicate with the NCP (send a message\n*   to the NCP). The \"poke\" mechanism is determined by the platform code (based\n*   on NCP's interface to the host).\n*   While power state is set to `LOW_POWER`, NCP can still (at any time) send\n*   messages to host. Note that receiving a message from the NCP does NOT\n*   indicate that the NCP's power state has changed, i.e., host is expected to\n*   continue to \"poke\" NCP when it wants to talk to the NCP until the power\n*   state is explicitly changed (by setting this property to `ON`).\n*   Note that the `LOW_POWER` power state only determines the MCU's power mode\n*   and is not related to radio's state.\n*\n*   `SPINEL_MCU_POWER_STATE_OFF`: NCP is fully powered off.\n*   An NCP hardware reset (via a RESET pin) is required to bring the NCP back\n*   to `SPINEL_MCU_POWER_STATE_ON`. RAM is not retained after reset.\n*\n*/"]
pub const SPINEL_PROP_MCU_POWER_STATE: _bindgen_ty_24 = 13;
#[doc = " NCP's MCU Power State\n** Format: 'C`\n*  Required capability: CAP_MCU_POWER_SAVE\n*\n* This property specifies the desired power state of NCP's micro-controller\n* (MCU) when the underlying platform's operating system enters idle mode (i.e.,\n* all active tasks/events are processed and the MCU can potentially enter a\n* energy-saving power state).\n*\n* The power state primarily determines how the host should interact with the NCP\n* and whether the host needs an external trigger (a \"poke\") to NCP before it can\n* communicate with the NCP or not. After a reset, the MCU power state MUST be\n* SPINEL_MCU_POWER_STATE_ON.\n*\n* Enumeration `spinel_mcu_power_state_t` defines the valid values\n* (`SPINEL_MCU_POWER_STATE_*` constants):\n*\n*   `SPINEL_MCU_POWER_STATE_ON`: NCP's MCU stays on and active all the time.\n*   When the NCP's desired power state is set to this value, host can send\n*   messages to NCP without requiring any \"poke\" or external triggers. MCU is\n*   expected to stay on and active. Note that the `ON` power state only\n*   determines the MCU's power mode and is not related to radio's state.\n*\n*   `SPINEL_MCU_POWER_STATE_LOW_POWER`: NCP's MCU can enter low-power\n*   (energy-saving) state. When the NCP's desired power state is set to\n*   `LOW_POWER`, host is expected to \"poke\" the NCP (e.g., an external trigger\n*   like an interrupt) before it can communicate with the NCP (send a message\n*   to the NCP). The \"poke\" mechanism is determined by the platform code (based\n*   on NCP's interface to the host).\n*   While power state is set to `LOW_POWER`, NCP can still (at any time) send\n*   messages to host. Note that receiving a message from the NCP does NOT\n*   indicate that the NCP's power state has changed, i.e., host is expected to\n*   continue to \"poke\" NCP when it wants to talk to the NCP until the power\n*   state is explicitly changed (by setting this property to `ON`).\n*   Note that the `LOW_POWER` power state only determines the MCU's power mode\n*   and is not related to radio's state.\n*\n*   `SPINEL_MCU_POWER_STATE_OFF`: NCP is fully powered off.\n*   An NCP hardware reset (via a RESET pin) is required to bring the NCP back\n*   to `SPINEL_MCU_POWER_STATE_ON`. RAM is not retained after reset.\n*\n*/"]
pub const SPINEL_PROP_BASE_EXT__BEGIN: _bindgen_ty_24 = 4096;
#[doc = " GPIO Configuration\n** Format: `A(CCU)`\n*  Type: Read-Only (Optionally Read-write using `CMD_PROP_VALUE_INSERT`)\n*\n* An array of structures which contain the following fields:\n*\n* *   `C`: GPIO Number\n* *   `C`: GPIO Configuration Flags\n* *   `U`: Human-readable GPIO name\n*\n* GPIOs which do not have a corresponding entry are not supported.\n*\n* The configuration parameter contains the configuration flags for the\n* GPIO:\n*\n*       0   1   2   3   4   5   6   7\n*     +---+---+---+---+---+---+---+---+\n*     |DIR|PUP|PDN|TRIGGER|  RESERVED |\n*     +---+---+---+---+---+---+---+---+\n*             |O/D|\n*             +---+\n*\n* *   `DIR`: Pin direction. Clear (0) for input, set (1) for output.\n* *   `PUP`: Pull-up enabled flag.\n* *   `PDN`/`O/D`: Flag meaning depends on pin direction:\n*     *   Input: Pull-down enabled.\n*     *   Output: Output is an open-drain.\n* *   `TRIGGER`: Enumeration describing how pin changes generate\n*     asynchronous notification commands (TBD) from the NCP to the host.\n*     *   0: Feature disabled for this pin\n*     *   1: Trigger on falling edge\n*     *   2: Trigger on rising edge\n*     *   3: Trigger on level change\n* *   `RESERVED`: Bits reserved for future use. Always cleared to zero\n*     and ignored when read.\n*\n* As an optional feature, the configuration of individual pins may be\n* modified using the `CMD_PROP_VALUE_INSERT` command. Only the GPIO\n* number and flags fields MUST be present, the GPIO name (if present)\n* would be ignored. This command can only be used to modify the\n* configuration of GPIOs which are already exposed---it cannot be used\n* by the host to add additional GPIOs.\n*/"]
pub const SPINEL_PROP_GPIO_CONFIG: _bindgen_ty_24 = 4096;
#[doc = " GPIO State Bitmask\n** Format: `D`\n*  Type: Read-Write\n*\n* Contains a bit field identifying the state of the GPIOs. The length of\n* the data associated with these properties depends on the number of\n* GPIOs. If you have 10 GPIOs, you'd have two bytes. GPIOs are numbered\n* from most significant bit to least significant bit, so 0x80 is GPIO 0,\n* 0x40 is GPIO 1, etc.\n*\n* For GPIOs configured as inputs:\n*\n* *   `CMD_PROP_VALUE_GET`: The value of the associated bit describes the\n*     logic level read from the pin.\n* *   `CMD_PROP_VALUE_SET`: The value of the associated bit is ignored\n*     for these pins.\n*\n* For GPIOs configured as outputs:\n*\n* *   `CMD_PROP_VALUE_GET`: The value of the associated bit is\n*     implementation specific.\n* *   `CMD_PROP_VALUE_SET`: The value of the associated bit determines\n*     the new logic level of the output. If this pin is configured as an\n*     open-drain, setting the associated bit to 1 will cause the pin to\n*     enter a Hi-Z state.\n*\n* For GPIOs which are not specified in `PROP_GPIO_CONFIG`:\n*\n* *   `CMD_PROP_VALUE_GET`: The value of the associated bit is\n*     implementation specific.\n* *   `CMD_PROP_VALUE_SET`: The value of the associated bit MUST be\n*     ignored by the NCP.\n*\n* When writing, unspecified bits are assumed to be zero.\n*/"]
pub const SPINEL_PROP_GPIO_STATE: _bindgen_ty_24 = 4098;
#[doc = " GPIO State Set-Only Bitmask\n** Format: `D`\n*  Type: Write-Only\n*\n* Allows for the state of various output GPIOs to be set without affecting\n* other GPIO states. Contains a bit field identifying the output GPIOs that\n* should have their state set to 1.\n*\n* When writing, unspecified bits are assumed to be zero. The value of\n* any bits for GPIOs which are not specified in `PROP_GPIO_CONFIG` MUST\n* be ignored.\n*/"]
pub const SPINEL_PROP_GPIO_STATE_SET: _bindgen_ty_24 = 4099;
#[doc = " GPIO State Clear-Only Bitmask\n** Format: `D`\n*  Type: Write-Only\n*\n* Allows for the state of various output GPIOs to be cleared without affecting\n* other GPIO states. Contains a bit field identifying the output GPIOs that\n* should have their state cleared to 0.\n*\n* When writing, unspecified bits are assumed to be zero. The value of\n* any bits for GPIOs which are not specified in `PROP_GPIO_CONFIG` MUST\n* be ignored.\n*/"]
pub const SPINEL_PROP_GPIO_STATE_CLEAR: _bindgen_ty_24 = 4100;
#[doc = " 32-bit random number from TRNG, ready-to-use."]
pub const SPINEL_PROP_TRNG_32: _bindgen_ty_24 = 4101;
#[doc = " 16 random bytes from TRNG, ready-to-use."]
pub const SPINEL_PROP_TRNG_128: _bindgen_ty_24 = 4102;
#[doc = " Raw samples from TRNG entropy source representing 32 bits of entropy."]
pub const SPINEL_PROP_TRNG_RAW_32: _bindgen_ty_24 = 4103;
#[doc = " NCP Unsolicited update filter\n** Format: `A(I)`\n*  Type: Read-Write (optional Insert-Remove)\n*  Required capability: `CAP_UNSOL_UPDATE_FILTER`\n*\n* Contains a list of properties which are excluded from generating\n* unsolicited value updates. This property is empty after reset.\n* In other words, the host may opt-out of unsolicited property updates\n* for a specific property by adding that property id to this list.\n* Hosts SHOULD NOT add properties to this list which are not\n* present in `PROP_UNSOL_UPDATE_LIST`. If such properties are added,\n* the NCP ignores the unsupported properties.\n*\n*/"]
pub const SPINEL_PROP_UNSOL_UPDATE_FILTER: _bindgen_ty_24 = 4104;
#[doc = " List of properties capable of generating unsolicited value update.\n** Format: `A(I)`\n*  Type: Read-Only\n*  Required capability: `CAP_UNSOL_UPDATE_FILTER`\n*\n* Contains a list of properties which are capable of generating\n* unsolicited value updates. This list can be used when populating\n* `PROP_UNSOL_UPDATE_FILTER` to disable all unsolicited property\n* updates.\n*\n* This property is intended to effectively behave as a constant\n* for a given NCP firmware.\n*/"]
pub const SPINEL_PROP_UNSOL_UPDATE_LIST: _bindgen_ty_24 = 4105;
#[doc = " List of properties capable of generating unsolicited value update.\n** Format: `A(I)`\n*  Type: Read-Only\n*  Required capability: `CAP_UNSOL_UPDATE_FILTER`\n*\n* Contains a list of properties which are capable of generating\n* unsolicited value updates. This list can be used when populating\n* `PROP_UNSOL_UPDATE_FILTER` to disable all unsolicited property\n* updates.\n*\n* This property is intended to effectively behave as a constant\n* for a given NCP firmware.\n*/"]
pub const SPINEL_PROP_BASE_EXT__END: _bindgen_ty_24 = 4352;
#[doc = " List of properties capable of generating unsolicited value update.\n** Format: `A(I)`\n*  Type: Read-Only\n*  Required capability: `CAP_UNSOL_UPDATE_FILTER`\n*\n* Contains a list of properties which are capable of generating\n* unsolicited value updates. This list can be used when populating\n* `PROP_UNSOL_UPDATE_FILTER` to disable all unsolicited property\n* updates.\n*\n* This property is intended to effectively behave as a constant\n* for a given NCP firmware.\n*/"]
pub const SPINEL_PROP_PHY__BEGIN: _bindgen_ty_24 = 32;
#[doc = "< [b]"]
pub const SPINEL_PROP_PHY_ENABLED: _bindgen_ty_24 = 32;
#[doc = "< [C]"]
pub const SPINEL_PROP_PHY_CHAN: _bindgen_ty_24 = 33;
#[doc = "< [A(C)]"]
pub const SPINEL_PROP_PHY_CHAN_SUPPORTED: _bindgen_ty_24 = 34;
#[doc = "< kHz [L]"]
pub const SPINEL_PROP_PHY_FREQ: _bindgen_ty_24 = 35;
#[doc = "< dBm [c]"]
pub const SPINEL_PROP_PHY_CCA_THRESHOLD: _bindgen_ty_24 = 36;
#[doc = "< [c]"]
pub const SPINEL_PROP_PHY_TX_POWER: _bindgen_ty_24 = 37;
#[doc = "< dBm [c]"]
pub const SPINEL_PROP_PHY_RSSI: _bindgen_ty_24 = 38;
#[doc = "< dBm [c]"]
pub const SPINEL_PROP_PHY_RX_SENSITIVITY: _bindgen_ty_24 = 39;
#[doc = "< [b]"]
pub const SPINEL_PROP_PHY_PCAP_ENABLED: _bindgen_ty_24 = 40;
#[doc = "< [A(C)]"]
pub const SPINEL_PROP_PHY_CHAN_PREFERRED: _bindgen_ty_24 = 41;
#[doc = "< dBm [c]"]
pub const SPINEL_PROP_PHY_FEM_LNA_GAIN: _bindgen_ty_24 = 42;
#[doc = " Signal the max power for a channel\n** Format: `Cc`\n*\n* First byte is the channel then the max transmit power, write-only.\n*/"]
pub const SPINEL_PROP_PHY_CHAN_MAX_POWER: _bindgen_ty_24 = 43;
#[doc = " Region code\n** Format: `S`\n*\n* The ascii representation of the ISO 3166 alpha-2 code.\n*\n*/"]
pub const SPINEL_PROP_PHY_REGION_CODE: _bindgen_ty_24 = 44;
#[doc = " Calibrated Power Table\n** Format: `A(Csd)` - Insert/Set\n*\n*  The `Insert` command on the property inserts a calibration power entry to the calibrated power table.\n*  The `Set` command on the property with empty payload clears the calibrated power table.\n*\n* Structure Parameters:\n*  `C`: Channel.\n*  `s`: Actual power in 0.01 dBm.\n*  `d`: Raw power setting.\n*/"]
pub const SPINEL_PROP_PHY_CALIBRATED_POWER: _bindgen_ty_24 = 45;
#[doc = " Target power for a channel\n** Format: `t(Cs)` - Write only\n*\n* Structure Parameters:\n*  `C`: Channel.\n*  `s`: Target power in 0.01 dBm.\n*/"]
pub const SPINEL_PROP_PHY_CHAN_TARGET_POWER: _bindgen_ty_24 = 46;
#[doc = " Target power for a channel\n** Format: `t(Cs)` - Write only\n*\n* Structure Parameters:\n*  `C`: Channel.\n*  `s`: Target power in 0.01 dBm.\n*/"]
pub const SPINEL_PROP_PHY__END: _bindgen_ty_24 = 48;
#[doc = " Target power for a channel\n** Format: `t(Cs)` - Write only\n*\n* Structure Parameters:\n*  `C`: Channel.\n*  `s`: Target power in 0.01 dBm.\n*/"]
pub const SPINEL_PROP_PHY_EXT__BEGIN: _bindgen_ty_24 = 4608;
#[doc = " Signal Jamming Detection Enable\n** Format: `b`\n*\n* Indicates if jamming detection is enabled or disabled. Set to true\n* to enable jamming detection.\n*/"]
pub const SPINEL_PROP_JAM_DETECT_ENABLE: _bindgen_ty_24 = 4608;
#[doc = " Signal Jamming Detected Indicator\n** Format: `b` (Read-Only)\n*\n* Set to true if radio jamming is detected. Set to false otherwise.\n*\n* When jamming detection is enabled, changes to the value of this\n* property are emitted asynchronously via `CMD_PROP_VALUE_IS`.\n*/"]
pub const SPINEL_PROP_JAM_DETECTED: _bindgen_ty_24 = 4609;
#[doc = " Jamming detection RSSI threshold\n** Format: `c`\n*  Units: dBm\n*\n* This parameter describes the threshold RSSI level (measured in\n* dBm) above which the jamming detection will consider the\n* channel blocked.\n*/"]
pub const SPINEL_PROP_JAM_DETECT_RSSI_THRESHOLD: _bindgen_ty_24 = 4610;
#[doc = " Jamming detection window size\n** Format: `C`\n*  Units: Seconds (1-63)\n*\n* This parameter describes the window period for signal jamming\n* detection.\n*/"]
pub const SPINEL_PROP_JAM_DETECT_WINDOW: _bindgen_ty_24 = 4611;
#[doc = " Jamming detection busy period\n** Format: `C`\n*  Units: Seconds (1-63)\n*\n* This parameter describes the number of aggregate seconds within\n* the detection window where the RSSI must be above\n* `PROP_JAM_DETECT_RSSI_THRESHOLD` to trigger detection.\n*\n* The behavior of the jamming detection feature when `PROP_JAM_DETECT_BUSY`\n* is larger than `PROP_JAM_DETECT_WINDOW` is undefined.\n*/"]
pub const SPINEL_PROP_JAM_DETECT_BUSY: _bindgen_ty_24 = 4612;
#[doc = " Jamming detection history bitmap (for debugging)\n** Format: `X` (read-only)\n*\n* This value provides information about current state of jamming detection\n* module for monitoring/debugging purpose. It returns a 64-bit value where\n* each bit corresponds to one second interval starting with bit 0 for the\n* most recent interval and bit 63 for the oldest intervals (63 sec earlier).\n* The bit is set to 1 if the jamming detection module observed/detected\n* high signal level during the corresponding one second interval.\n*\n*/"]
pub const SPINEL_PROP_JAM_DETECT_HISTORY_BITMAP: _bindgen_ty_24 = 4613;
#[doc = " Channel monitoring sample interval\n** Format: `L` (read-only)\n*  Units: Milliseconds\n*\n* Required capability: SPINEL_CAP_CHANNEL_MONITOR\n*\n* If channel monitoring is enabled and active, every sample interval, a\n* zero-duration Energy Scan is performed, collecting a single RSSI sample\n* per channel. The RSSI samples are compared with a pre-specified RSSI\n* threshold.\n*\n*/"]
pub const SPINEL_PROP_CHANNEL_MONITOR_SAMPLE_INTERVAL: _bindgen_ty_24 = 4614;
#[doc = " Channel monitoring RSSI threshold\n** Format: `c` (read-only)\n*  Units: dBm\n*\n* Required capability: SPINEL_CAP_CHANNEL_MONITOR\n*\n* This value specifies the threshold used by channel monitoring module.\n* Channel monitoring maintains the average rate of RSSI samples that\n* are above the threshold within (approximately) a pre-specified number\n* of samples (sample window).\n*\n*/"]
pub const SPINEL_PROP_CHANNEL_MONITOR_RSSI_THRESHOLD: _bindgen_ty_24 = 4615;
#[doc = " Channel monitoring sample window\n** Format: `L` (read-only)\n*  Units: Number of samples\n*\n* Required capability: SPINEL_CAP_CHANNEL_MONITOR\n*\n* The averaging sample window length (in units of number of channel\n* samples) used by channel monitoring module. Channel monitoring will\n* sample all channels every sample interval. It maintains the average rate\n* of RSSI samples that are above the RSSI threshold within (approximately)\n* the sample window.\n*\n*/"]
pub const SPINEL_PROP_CHANNEL_MONITOR_SAMPLE_WINDOW: _bindgen_ty_24 = 4616;
#[doc = " Channel monitoring sample count\n** Format: `L` (read-only)\n*  Units: Number of samples\n*\n* Required capability: SPINEL_CAP_CHANNEL_MONITOR\n*\n* Total number of RSSI samples (per channel) taken by the channel\n* monitoring module since its start (since Thread network interface\n* was enabled).\n*\n*/"]
pub const SPINEL_PROP_CHANNEL_MONITOR_SAMPLE_COUNT: _bindgen_ty_24 = 4617;
#[doc = " Channel monitoring channel occupancy\n** Format: `A(t(CU))` (read-only)\n*\n* Required capability: SPINEL_CAP_CHANNEL_MONITOR\n*\n* Data per item is:\n*\n*  `C`: Channel\n*  `U`: Channel occupancy indicator\n*\n* The channel occupancy value represents the average rate/percentage of\n* RSSI samples that were above RSSI threshold (\"bad\" RSSI samples) within\n* (approximately) sample window latest RSSI samples.\n*\n* Max value of `0xffff` indicates all RSSI samples were above RSSI\n* threshold (i.e. 100% of samples were \"bad\").\n*\n*/"]
pub const SPINEL_PROP_CHANNEL_MONITOR_CHANNEL_OCCUPANCY: _bindgen_ty_24 = 4618;
#[doc = " Radio caps\n** Format: `i` (read-only)\n*\n* Data per item is:\n*\n*  `i`: Radio Capabilities.\n*\n*/"]
pub const SPINEL_PROP_RADIO_CAPS: _bindgen_ty_24 = 4619;
#[doc = " All coex metrics related counters.\n** Format: t(LLLLLLLL)t(LLLLLLLLL)bL  (Read-only)\n*\n* Required capability: SPINEL_CAP_RADIO_COEX\n*\n* The contents include two structures and two common variables, first structure corresponds to\n* all transmit related coex counters, second structure provides the receive related counters.\n*\n* The transmit structure includes:\n*   'L': NumTxRequest                       (The number of tx requests).\n*   'L': NumTxGrantImmediate                (The number of tx requests while grant was active).\n*   'L': NumTxGrantWait                     (The number of tx requests while grant was inactive).\n*   'L': NumTxGrantWaitActivated            (The number of tx requests while grant was inactive that were\n*                                            ultimately granted).\n*   'L': NumTxGrantWaitTimeout              (The number of tx requests while grant was inactive that timed out).\n*   'L': NumTxGrantDeactivatedDuringRequest (The number of tx requests that were in progress when grant was\n*                                            deactivated).\n*   'L': NumTxDelayedGrant                  (The number of tx requests that were not granted within 50us).\n*   'L': AvgTxRequestToGrantTime            (The average time in usec from tx request to grant).\n*\n* The receive structure includes:\n*   'L': NumRxRequest                       (The number of rx requests).\n*   'L': NumRxGrantImmediate                (The number of rx requests while grant was active).\n*   'L': NumRxGrantWait                     (The number of rx requests while grant was inactive).\n*   'L': NumRxGrantWaitActivated            (The number of rx requests while grant was inactive that were\n*                                            ultimately granted).\n*   'L': NumRxGrantWaitTimeout              (The number of rx requests while grant was inactive that timed out).\n*   'L': NumRxGrantDeactivatedDuringRequest (The number of rx requests that were in progress when grant was\n*                                            deactivated).\n*   'L': NumRxDelayedGrant                  (The number of rx requests that were not granted within 50us).\n*   'L': AvgRxRequestToGrantTime            (The average time in usec from rx request to grant).\n*   'L': NumRxGrantNone                     (The number of rx requests that completed without receiving grant).\n*\n* Two common variables:\n*   'b': Stopped        (Stats collection stopped due to saturation).\n*   'L': NumGrantGlitch (The number of of grant glitches).\n*/"]
pub const SPINEL_PROP_RADIO_COEX_METRICS: _bindgen_ty_24 = 4620;
#[doc = " Radio Coex Enable\n** Format: `b`\n*\n* Required capability: SPINEL_CAP_RADIO_COEX\n*\n* Indicates if radio coex is enabled or disabled. Set to true to enable radio coex.\n*/"]
pub const SPINEL_PROP_RADIO_COEX_ENABLE: _bindgen_ty_24 = 4621;
#[doc = " Radio Coex Enable\n** Format: `b`\n*\n* Required capability: SPINEL_CAP_RADIO_COEX\n*\n* Indicates if radio coex is enabled or disabled. Set to true to enable radio coex.\n*/"]
pub const SPINEL_PROP_PHY_EXT__END: _bindgen_ty_24 = 4864;
#[doc = " Radio Coex Enable\n** Format: `b`\n*\n* Required capability: SPINEL_CAP_RADIO_COEX\n*\n* Indicates if radio coex is enabled or disabled. Set to true to enable radio coex.\n*/"]
pub const SPINEL_PROP_MAC__BEGIN: _bindgen_ty_24 = 48;
#[doc = " MAC Scan State\n** Format: `C`\n*\n* Possible values are from enumeration `spinel_scan_state_t`.\n*\n*   SCAN_STATE_IDLE\n*   SCAN_STATE_BEACON\n*   SCAN_STATE_ENERGY\n*   SCAN_STATE_DISCOVER\n*\n* Set to `SCAN_STATE_BEACON` to start an active scan.\n* Beacons will be emitted from `PROP_MAC_SCAN_BEACON`.\n*\n* Set to `SCAN_STATE_ENERGY` to start an energy scan.\n* Channel energy result will be reported by emissions\n* of `PROP_MAC_ENERGY_SCAN_RESULT` (per channel).\n*\n* Set to `SCAN_STATE_DISCOVER` to start a Thread MLE discovery\n* scan operation. Discovery scan result will be emitted from\n* `PROP_MAC_SCAN_BEACON`.\n*\n* Value switches to `SCAN_STATE_IDLE` when scan is complete.\n*\n*/"]
pub const SPINEL_PROP_MAC_SCAN_STATE: _bindgen_ty_24 = 48;
#[doc = " MAC Scan Channel Mask\n** Format: `A(C)`\n*\n* List of channels to scan.\n*\n*/"]
pub const SPINEL_PROP_MAC_SCAN_MASK: _bindgen_ty_24 = 49;
#[doc = " MAC Scan Channel Period\n** Format: `S`\n*  Unit: milliseconds per channel\n*\n*/"]
pub const SPINEL_PROP_MAC_SCAN_PERIOD: _bindgen_ty_24 = 50;
#[doc = " MAC Scan Beacon\n** Format `Cct(ESSc)t(iCUdd)` - Asynchronous event only\n*\n* Scan beacons have two embedded structures which contain\n* information about the MAC layer and the NET layer. Their\n* format depends on the MAC and NET layer currently in use.\n* The format below is for an 802.15.4 MAC with Thread:\n*\n*  `C`: Channel\n*  `c`: RSSI of the beacon\n*  `t`: MAC layer properties (802.15.4 layer)\n*    `E`: Long address\n*    `S`: Short address\n*    `S`: PAN-ID\n*    `c`: LQI\n*  NET layer properties\n*    `i`: Protocol Number (SPINEL_PROTOCOL_TYPE_* values)\n*    `C`: Flags (SPINEL_BEACON_THREAD_FLAG_* values)\n*    `U`: Network Name\n*    `d`: XPANID\n*    `d`: Steering data\n*\n* Extra parameters may be added to each of the structures\n* in the future, so care should be taken to read the length\n* that prepends each structure.\n*\n*/"]
pub const SPINEL_PROP_MAC_SCAN_BEACON: _bindgen_ty_24 = 51;
#[doc = " MAC Long Address\n** Format: `E`\n*\n* The 802.15.4 long address of this node.\n*\n*/"]
pub const SPINEL_PROP_MAC_15_4_LADDR: _bindgen_ty_24 = 52;
#[doc = " MAC Short Address\n** Format: `S`\n*\n* The 802.15.4 short address of this node.\n*\n*/"]
pub const SPINEL_PROP_MAC_15_4_SADDR: _bindgen_ty_24 = 53;
#[doc = " MAC PAN ID\n** Format: `S`\n*\n* The 802.15.4 PANID this node is associated with.\n*\n*/"]
pub const SPINEL_PROP_MAC_15_4_PANID: _bindgen_ty_24 = 54;
#[doc = " MAC Stream Raw Enabled\n** Format: `b`\n*\n* Set to true to enable raw MAC frames to be emitted from\n* `PROP_STREAM_RAW`.\n*\n*/"]
pub const SPINEL_PROP_MAC_RAW_STREAM_ENABLED: _bindgen_ty_24 = 55;
#[doc = " MAC Promiscuous Mode\n** Format: `C`\n*\n* Possible values are from enumeration\n* `SPINEL_MAC_PROMISCUOUS_MODE_*`:\n*\n*   `SPINEL_MAC_PROMISCUOUS_MODE_OFF`\n*        Normal MAC filtering is in place.\n*\n*   `SPINEL_MAC_PROMISCUOUS_MODE_NETWORK`\n*        All MAC packets matching network are passed up\n*        the stack.\n*\n*   `SPINEL_MAC_PROMISCUOUS_MODE_FULL`\n*        All decoded MAC packets are passed up the stack.\n*\n*/"]
pub const SPINEL_PROP_MAC_PROMISCUOUS_MODE: _bindgen_ty_24 = 56;
#[doc = " MAC Energy Scan Result\n** Format: `Cc` - Asynchronous event only\n*\n* This property is emitted during energy scan operation\n* per scanned channel with following format:\n*\n*   `C`: Channel\n*   `c`: RSSI (in dBm)\n*\n*/"]
pub const SPINEL_PROP_MAC_ENERGY_SCAN_RESULT: _bindgen_ty_24 = 57;
#[doc = " MAC Data Poll Period\n** Format: `L`\n*  Unit: millisecond\n* The (user-specified) data poll (802.15.4 MAC Data Request) period\n* in milliseconds. Value zero means there is no user-specified\n* poll period, and the network stack determines the maximum period\n* based on the MLE Child Timeout.\n*\n* If the value is non-zero, it specifies the maximum period between\n* data poll transmissions. Note that the network stack may send data\n* request transmissions more frequently when expecting a control-message\n* (e.g., when waiting for an MLE Child ID Response).\n*\n*/"]
pub const SPINEL_PROP_MAC_DATA_POLL_PERIOD: _bindgen_ty_24 = 58;
#[doc = " MAC Data Poll Period\n** Format: `L`\n*  Unit: millisecond\n* The (user-specified) data poll (802.15.4 MAC Data Request) period\n* in milliseconds. Value zero means there is no user-specified\n* poll period, and the network stack determines the maximum period\n* based on the MLE Child Timeout.\n*\n* If the value is non-zero, it specifies the maximum period between\n* data poll transmissions. Note that the network stack may send data\n* request transmissions more frequently when expecting a control-message\n* (e.g., when waiting for an MLE Child ID Response).\n*\n*/"]
pub const SPINEL_PROP_MAC__END: _bindgen_ty_24 = 64;
#[doc = " MAC Data Poll Period\n** Format: `L`\n*  Unit: millisecond\n* The (user-specified) data poll (802.15.4 MAC Data Request) period\n* in milliseconds. Value zero means there is no user-specified\n* poll period, and the network stack determines the maximum period\n* based on the MLE Child Timeout.\n*\n* If the value is non-zero, it specifies the maximum period between\n* data poll transmissions. Note that the network stack may send data\n* request transmissions more frequently when expecting a control-message\n* (e.g., when waiting for an MLE Child ID Response).\n*\n*/"]
pub const SPINEL_PROP_MAC_EXT__BEGIN: _bindgen_ty_24 = 4864;
#[doc = " MAC Allowlist\n** Format: `A(t(Ec))`\n* Required capability: `CAP_MAC_ALLOWLIST`\n*\n* Structure Parameters:\n*\n*  `E`: EUI64 address of node\n*  `c`: Optional RSSI-override value. The value 127 indicates\n*       that the RSSI-override feature is not enabled for this\n*       address. If this value is omitted when setting or\n*       inserting, it is assumed to be 127. This parameter is\n*       ignored when removing.\n*/"]
pub const SPINEL_PROP_MAC_ALLOWLIST: _bindgen_ty_24 = 4864;
#[doc = " MAC Allowlist Enabled Flag\n** Format: `b`\n* Required capability: `CAP_MAC_ALLOWLIST`\n*\n*/"]
pub const SPINEL_PROP_MAC_ALLOWLIST_ENABLED: _bindgen_ty_24 = 4865;
#[doc = " MAC Extended Address\n** Format: `E`\n*\n*  Specified by Thread. Randomly-chosen, but non-volatile EUI-64.\n*/"]
pub const SPINEL_PROP_MAC_EXTENDED_ADDR: _bindgen_ty_24 = 4866;
#[doc = " MAC Source Match Enabled Flag\n** Format: `b`\n* Required Capability: SPINEL_CAP_MAC_RAW or SPINEL_CAP_CONFIG_RADIO\n*\n* Set to true to enable radio source matching or false to disable it.\n* The source match functionality is used by radios when generating\n* ACKs. The short and extended address lists are used for setting\n* the Frame Pending bit in the ACKs.\n*\n*/"]
pub const SPINEL_PROP_MAC_SRC_MATCH_ENABLED: _bindgen_ty_24 = 4867;
#[doc = " MAC Source Match Short Address List\n** Format: `A(S)`\n* Required Capability: SPINEL_CAP_MAC_RAW or SPINEL_CAP_CONFIG_RADIO\n*\n*/"]
pub const SPINEL_PROP_MAC_SRC_MATCH_SHORT_ADDRESSES: _bindgen_ty_24 = 4868;
#[doc = " MAC Source Match Extended Address List\n** Format: `A(E)`\n*  Required Capability: SPINEL_CAP_MAC_RAW or SPINEL_CAP_CONFIG_RADIO\n*\n*/"]
pub const SPINEL_PROP_MAC_SRC_MATCH_EXTENDED_ADDRESSES: _bindgen_ty_24 = 4869;
#[doc = " MAC Denylist\n** Format: `A(t(E))`\n* Required capability: `CAP_MAC_ALLOWLIST`\n*\n* Structure Parameters:\n*\n*  `E`: EUI64 address of node\n*\n*/"]
pub const SPINEL_PROP_MAC_DENYLIST: _bindgen_ty_24 = 4870;
#[doc = " MAC Denylist Enabled Flag\n** Format: `b`\n*  Required capability: `CAP_MAC_ALLOWLIST`\n*/"]
pub const SPINEL_PROP_MAC_DENYLIST_ENABLED: _bindgen_ty_24 = 4871;
#[doc = " MAC Received Signal Strength Filter\n** Format: `A(t(Ec))`\n* Required capability: `CAP_MAC_ALLOWLIST`\n*\n* Structure Parameters:\n*\n* * `E`: Optional EUI64 address of node. Set default RSS if not included.\n* * `c`: Fixed RSS. 127 means not set.\n*/"]
pub const SPINEL_PROP_MAC_FIXED_RSS: _bindgen_ty_24 = 4872;
#[doc = " The CCA failure rate\n** Format: `S`\n*\n* This property provides the current CCA (Clear Channel Assessment) failure rate.\n*\n* Maximum value `0xffff` corresponding to 100% failure rate.\n*\n*/"]
pub const SPINEL_PROP_MAC_CCA_FAILURE_RATE: _bindgen_ty_24 = 4873;
#[doc = " MAC Max direct retry number\n** Format: `C`\n*\n* The maximum (user-specified) number of direct frame transmission retries.\n*\n*/"]
pub const SPINEL_PROP_MAC_MAX_RETRY_NUMBER_DIRECT: _bindgen_ty_24 = 4874;
#[doc = " MAC Max indirect retry number\n** Format: `C`\n* Required capability: `SPINEL_CAP_CONFIG_FTD`\n*\n* The maximum (user-specified) number of indirect frame transmission retries.\n*\n*/"]
pub const SPINEL_PROP_MAC_MAX_RETRY_NUMBER_INDIRECT: _bindgen_ty_24 = 4875;
#[doc = " MAC Max indirect retry number\n** Format: `C`\n* Required capability: `SPINEL_CAP_CONFIG_FTD`\n*\n* The maximum (user-specified) number of indirect frame transmission retries.\n*\n*/"]
pub const SPINEL_PROP_MAC_EXT__END: _bindgen_ty_24 = 5120;
#[doc = " MAC Max indirect retry number\n** Format: `C`\n* Required capability: `SPINEL_CAP_CONFIG_FTD`\n*\n* The maximum (user-specified) number of indirect frame transmission retries.\n*\n*/"]
pub const SPINEL_PROP_NET__BEGIN: _bindgen_ty_24 = 64;
#[doc = " Network Is Saved (Is Commissioned)\n** Format: `b` - Read only\n*\n* Returns true if there is a network state stored/saved.\n*\n*/"]
pub const SPINEL_PROP_NET_SAVED: _bindgen_ty_24 = 64;
#[doc = " Network Interface Status\n** Format `b` - Read-write\n*\n* Network interface up/down status. Write true to bring\n* interface up and false to bring interface down.\n*\n*/"]
pub const SPINEL_PROP_NET_IF_UP: _bindgen_ty_24 = 65;
#[doc = " Thread Stack Operational Status\n** Format `b` - Read-write\n*\n* Thread stack operational status. Write true to start\n* Thread stack and false to stop it.\n*\n*/"]
pub const SPINEL_PROP_NET_STACK_UP: _bindgen_ty_24 = 66;
#[doc = " Thread Device Role\n** Format `C` - Read-write\n*\n* Possible values are from enumeration `spinel_net_role_t`\n*\n*  SPINEL_NET_ROLE_DETACHED = 0,\n*  SPINEL_NET_ROLE_CHILD    = 1,\n*  SPINEL_NET_ROLE_ROUTER   = 2,\n*  SPINEL_NET_ROLE_LEADER   = 3,\n*\n*/"]
pub const SPINEL_PROP_NET_ROLE: _bindgen_ty_24 = 67;
#[doc = " Thread Network Name\n** Format `U` - Read-write\n*\n*/"]
pub const SPINEL_PROP_NET_NETWORK_NAME: _bindgen_ty_24 = 68;
#[doc = " Thread Network Extended PAN ID\n** Format `D` - Read-write\n*\n*/"]
pub const SPINEL_PROP_NET_XPANID: _bindgen_ty_24 = 69;
#[doc = " Thread Network Key\n** Format `D` - Read-write\n*\n*/"]
pub const SPINEL_PROP_NET_NETWORK_KEY: _bindgen_ty_24 = 70;
#[doc = " Thread Network Key Sequence Counter\n** Format `L` - Read-write\n*\n*/"]
pub const SPINEL_PROP_NET_KEY_SEQUENCE_COUNTER: _bindgen_ty_24 = 71;
#[doc = " Thread Network Partition Id\n** Format `L` - Read-write\n*\n* The partition ID of the partition that this node is a\n* member of.\n*\n*/"]
pub const SPINEL_PROP_NET_PARTITION_ID: _bindgen_ty_24 = 72;
#[doc = " Require Join Existing\n** Format: `b`\n*  Default Value: `false`\n*\n* This flag is typically used for nodes that are associating with an\n* existing network for the first time. If this is set to `true` before\n* `PROP_NET_STACK_UP` is set to `true`, the\n* creation of a new partition at association is prevented. If the node\n* cannot associate with an existing partition, `PROP_LAST_STATUS` will\n* emit a status that indicates why the association failed and\n* `PROP_NET_STACK_UP` will automatically revert to `false`.\n*\n* Once associated with an existing partition, this flag automatically\n* reverts to `false`.\n*\n* The behavior of this property being set to `true` when\n* `PROP_NET_STACK_UP` is already set to `true` is undefined.\n*\n*/"]
pub const SPINEL_PROP_NET_REQUIRE_JOIN_EXISTING: _bindgen_ty_24 = 73;
#[doc = " Thread Network Key Switch Guard Time\n** Format `L` - Read-write\n*\n*/"]
pub const SPINEL_PROP_NET_KEY_SWITCH_GUARDTIME: _bindgen_ty_24 = 74;
#[doc = " Thread Network PSKc\n** Format `D` - Read-write\n*\n*/"]
pub const SPINEL_PROP_NET_PSKC: _bindgen_ty_24 = 75;
#[doc = " Thread Network PSKc\n** Format `D` - Read-write\n*\n*/"]
pub const SPINEL_PROP_NET__END: _bindgen_ty_24 = 80;
#[doc = " Thread Network PSKc\n** Format `D` - Read-write\n*\n*/"]
pub const SPINEL_PROP_NET_EXT__BEGIN: _bindgen_ty_24 = 5120;
#[doc = " Thread Network PSKc\n** Format `D` - Read-write\n*\n*/"]
pub const SPINEL_PROP_NET_EXT__END: _bindgen_ty_24 = 5376;
#[doc = " Thread Network PSKc\n** Format `D` - Read-write\n*\n*/"]
pub const SPINEL_PROP_THREAD__BEGIN: _bindgen_ty_24 = 80;
#[doc = " Thread Leader IPv6 Address\n** Format `6` - Read only\n*\n*/"]
pub const SPINEL_PROP_THREAD_LEADER_ADDR: _bindgen_ty_24 = 80;
#[doc = " Thread Parent Info\n** Format: `ESLccCCCCC` - Read only\n*\n*  `E`: Extended address\n*  `S`: RLOC16\n*  `L`: Age (seconds since last heard from)\n*  `c`: Average RSS (in dBm)\n*  `c`: Last RSSI (in dBm)\n*  `C`: Link Quality In\n*  `C`: Link Quality Out\n*  `C`: Version\n*  `C`: CSL clock accuracy\n*  `C`: CSL uncertainty\n*\n*/"]
pub const SPINEL_PROP_THREAD_PARENT: _bindgen_ty_24 = 81;
#[doc = " Thread Child Table\n** Format: [A(t(ESLLCCcCc)] - Read only\n*\n* Data per item is:\n*\n*  `E`: Extended address\n*  `S`: RLOC16\n*  `L`: Timeout (in seconds)\n*  `L`: Age (in seconds)\n*  `L`: Network Data version\n*  `C`: Link Quality In\n*  `c`: Average RSS (in dBm)\n*  `C`: Mode (bit-flags)\n*  `c`: Last RSSI (in dBm)\n*\n*/"]
pub const SPINEL_PROP_THREAD_CHILD_TABLE: _bindgen_ty_24 = 82;
#[doc = " Thread Leader Router Id\n** Format `C` - Read only\n*\n* The router-id of the current leader.\n*\n*/"]
pub const SPINEL_PROP_THREAD_LEADER_RID: _bindgen_ty_24 = 83;
#[doc = " Thread Leader Weight\n** Format `C` - Read only\n*\n* The leader weight of the current leader.\n*\n*/"]
pub const SPINEL_PROP_THREAD_LEADER_WEIGHT: _bindgen_ty_24 = 84;
#[doc = " Thread Local Leader Weight\n** Format `C` - Read only\n*\n* The leader weight of this node.\n*\n*/"]
pub const SPINEL_PROP_THREAD_LOCAL_LEADER_WEIGHT: _bindgen_ty_24 = 85;
#[doc = " Thread Local Network Data\n** Format `D` - Read only\n*\n*/"]
pub const SPINEL_PROP_THREAD_NETWORK_DATA: _bindgen_ty_24 = 86;
#[doc = " Thread Local Network Data Version\n** Format `C` - Read only\n*\n*/"]
pub const SPINEL_PROP_THREAD_NETWORK_DATA_VERSION: _bindgen_ty_24 = 87;
#[doc = " Thread Local Stable Network Data\n** Format `D` - Read only\n*\n*/"]
pub const SPINEL_PROP_THREAD_STABLE_NETWORK_DATA: _bindgen_ty_24 = 88;
#[doc = " Thread Local Stable Network Data Version\n** Format `C` - Read only\n*\n*/"]
pub const SPINEL_PROP_THREAD_STABLE_NETWORK_DATA_VERSION: _bindgen_ty_24 = 89;
#[doc = " On-Mesh Prefixes\n** Format: `A(t(6CbCbSC))`\n*\n* Data per item is:\n*\n*  `6`: IPv6 Prefix\n*  `C`: Prefix length in bits\n*  `b`: Stable flag\n*  `C`: TLV flags (SPINEL_NET_FLAG_* definition)\n*  `b`: \"Is defined locally\" flag. Set if this network was locally\n*       defined. Assumed to be true for set, insert and replace. Clear if\n*       the on mesh network was defined by another node.\n*       This field is ignored for INSERT and REMOVE commands.\n*  `S`: The RLOC16 of the device that registered this on-mesh prefix entry.\n*       This value is not used and ignored when adding an on-mesh prefix.\n*       This field is ignored for INSERT and REMOVE commands.\n*  `C`: TLV flags extended (additional field for Thread 1.2 features).\n*\n*/"]
pub const SPINEL_PROP_THREAD_ON_MESH_NETS: _bindgen_ty_24 = 90;
#[doc = " Off-mesh routes\n** Format: [A(t(6CbCbb))]\n*\n* Data per item is:\n*\n*  `6`: Route Prefix\n*  `C`: Prefix length in bits\n*  `b`: Stable flag\n*  `C`: Route flags (SPINEL_ROUTE_FLAG_* and SPINEL_ROUTE_PREFERENCE_* definitions)\n*  `b`: \"Is defined locally\" flag. Set if this route info was locally\n*       defined as part of local network data. Assumed to be true for set,\n*       insert and replace. Clear if the route is part of partition's network\n*       data.\n*  `b`: \"Next hop is this device\" flag. Set if the next hop for the\n*       route is this device itself (i.e., route was added by this device)\n*       This value is ignored when adding an external route. For any added\n*       route the next hop is this device.\n*  `S`: The RLOC16 of the device that registered this route entry.\n*       This value is not used and ignored when adding a route.\n*\n*/"]
pub const SPINEL_PROP_THREAD_OFF_MESH_ROUTES: _bindgen_ty_24 = 91;
#[doc = " Thread Assisting Ports\n** Format `A(S)`\n*\n* Array of port numbers.\n*/"]
pub const SPINEL_PROP_THREAD_ASSISTING_PORTS: _bindgen_ty_24 = 92;
#[doc = " Thread Allow Local Network Data Change\n** Format `b` - Read-write\n*\n* Set to true before changing local net data. Set to false when finished.\n* This allows changes to be aggregated into a single event.\n*\n*/"]
pub const SPINEL_PROP_THREAD_ALLOW_LOCAL_NET_DATA_CHANGE: _bindgen_ty_24 = 93;
#[doc = " Thread Mode\n** Format: `C`\n*\n*  This property contains the value of the mode\n*  TLV for this node. The meaning of the bits in this\n*  bit-field are defined by section 4.5.2 of the Thread\n*  specification.\n*\n* The values `SPINEL_THREAD_MODE_*` defines the bit-fields\n*\n*/"]
pub const SPINEL_PROP_THREAD_MODE: _bindgen_ty_24 = 94;
#[doc = " Thread Mode\n** Format: `C`\n*\n*  This property contains the value of the mode\n*  TLV for this node. The meaning of the bits in this\n*  bit-field are defined by section 4.5.2 of the Thread\n*  specification.\n*\n* The values `SPINEL_THREAD_MODE_*` defines the bit-fields\n*\n*/"]
pub const SPINEL_PROP_THREAD__END: _bindgen_ty_24 = 96;
#[doc = " Thread Mode\n** Format: `C`\n*\n*  This property contains the value of the mode\n*  TLV for this node. The meaning of the bits in this\n*  bit-field are defined by section 4.5.2 of the Thread\n*  specification.\n*\n* The values `SPINEL_THREAD_MODE_*` defines the bit-fields\n*\n*/"]
pub const SPINEL_PROP_THREAD_EXT__BEGIN: _bindgen_ty_24 = 5376;
#[doc = " Thread Child Timeout\n** Format: `L`\n*  Unit: Seconds\n*\n*  Used when operating in the Child role.\n*/"]
pub const SPINEL_PROP_THREAD_CHILD_TIMEOUT: _bindgen_ty_24 = 5376;
#[doc = " Thread RLOC16\n** Format: `S`\n*\n*/"]
pub const SPINEL_PROP_THREAD_RLOC16: _bindgen_ty_24 = 5377;
#[doc = " Thread Router Upgrade Threshold\n** Format: `C`\n*\n*/"]
pub const SPINEL_PROP_THREAD_ROUTER_UPGRADE_THRESHOLD: _bindgen_ty_24 = 5378;
#[doc = " Thread Context Reuse Delay\n** Format: `L`\n*\n*/"]
pub const SPINEL_PROP_THREAD_CONTEXT_REUSE_DELAY: _bindgen_ty_24 = 5379;
#[doc = " Thread Network ID Timeout\n** Format: `C`\n*\n*/"]
pub const SPINEL_PROP_THREAD_NETWORK_ID_TIMEOUT: _bindgen_ty_24 = 5380;
#[doc = " List of active thread router ids\n** Format: `A(C)`\n*\n* Note that some implementations may not support CMD_GET_VALUE\n* router ids, but may support CMD_REMOVE_VALUE when the node is\n* a leader.\n*\n*/"]
pub const SPINEL_PROP_THREAD_ACTIVE_ROUTER_IDS: _bindgen_ty_24 = 5381;
#[doc = " Forward IPv6 packets that use RLOC16 addresses to HOST.\n** Format: `b`\n*\n* Allow host to directly observe all IPv6 packets received by the NCP,\n* including ones sent to the RLOC16 address.\n*\n* Default is false.\n*\n*/"]
pub const SPINEL_PROP_THREAD_RLOC16_DEBUG_PASSTHRU: _bindgen_ty_24 = 5382;
#[doc = " Router Role Enabled\n** Format `b`\n*\n* Allows host to indicate whether or not the router role is enabled.\n* If current role is a router, setting this property to `false` starts\n* a re-attach process as an end-device.\n*\n*/"]
pub const SPINEL_PROP_THREAD_ROUTER_ROLE_ENABLED: _bindgen_ty_24 = 5383;
#[doc = " Thread Router Downgrade Threshold\n** Format: `C`\n*\n*/"]
pub const SPINEL_PROP_THREAD_ROUTER_DOWNGRADE_THRESHOLD: _bindgen_ty_24 = 5384;
#[doc = " Thread Router Selection Jitter\n** Format: `C`\n*\n*/"]
pub const SPINEL_PROP_THREAD_ROUTER_SELECTION_JITTER: _bindgen_ty_24 = 5385;
#[doc = " Thread Preferred Router Id\n** Format: `C` - Write only\n*\n* Specifies the preferred Router Id. Upon becoming a router/leader the node\n* attempts to use this Router Id. If the preferred Router Id is not set or\n* if it can not be used, a randomly generated router id is picked. This\n* property can be set only when the device role is either detached or\n* disabled.\n*\n*/"]
pub const SPINEL_PROP_THREAD_PREFERRED_ROUTER_ID: _bindgen_ty_24 = 5386;
#[doc = " Thread Neighbor Table\n** Format: `A(t(ESLCcCbLLc))` - Read only\n*\n* Data per item is:\n*\n*  `E`: Extended address\n*  `S`: RLOC16\n*  `L`: Age (in seconds)\n*  `C`: Link Quality In\n*  `c`: Average RSS (in dBm)\n*  `C`: Mode (bit-flags)\n*  `b`: `true` if neighbor is a child, `false` otherwise.\n*  `L`: Link Frame Counter\n*  `L`: MLE Frame Counter\n*  `c`: The last RSSI (in dBm)\n*\n*/"]
pub const SPINEL_PROP_THREAD_NEIGHBOR_TABLE: _bindgen_ty_24 = 5387;
#[doc = " Thread Max Child Count\n** Format: `C`\n*\n* Specifies the maximum number of children currently allowed.\n* This parameter can only be set when Thread protocol operation\n* has been stopped.\n*\n*/"]
pub const SPINEL_PROP_THREAD_CHILD_COUNT_MAX: _bindgen_ty_24 = 5388;
#[doc = " Leader Network Data\n** Format: `D` - Read only\n*\n*/"]
pub const SPINEL_PROP_THREAD_LEADER_NETWORK_DATA: _bindgen_ty_24 = 5389;
#[doc = " Stable Leader Network Data\n** Format: `D` - Read only\n*\n*/"]
pub const SPINEL_PROP_THREAD_STABLE_LEADER_NETWORK_DATA: _bindgen_ty_24 = 5390;
#[doc = " Thread Joiner Data\n** Format `A(T(ULE))`\n*  PSKd, joiner timeout, eui64 (optional)\n*\n* This property is being deprecated by SPINEL_PROP_MESHCOP_COMMISSIONER_JOINERS.\n*\n*/"]
pub const SPINEL_PROP_THREAD_JOINERS: _bindgen_ty_24 = 5391;
#[doc = " Thread Commissioner Enable\n** Format `b`\n*\n* Default value is `false`.\n*\n* This property is being deprecated by SPINEL_PROP_MESHCOP_COMMISSIONER_STATE.\n*\n*/"]
pub const SPINEL_PROP_THREAD_COMMISSIONER_ENABLED: _bindgen_ty_24 = 5392;
#[doc = " Thread TMF proxy enable\n** Format `b`\n* Required capability: `SPINEL_CAP_THREAD_TMF_PROXY`\n*\n* This property is deprecated.\n*\n*/"]
pub const SPINEL_PROP_THREAD_TMF_PROXY_ENABLED: _bindgen_ty_24 = 5393;
#[doc = " Thread TMF proxy stream\n** Format `dSS`\n* Required capability: `SPINEL_CAP_THREAD_TMF_PROXY`\n*\n* This property is deprecated. Please see `SPINEL_PROP_THREAD_UDP_FORWARD_STREAM`.\n*\n*/"]
pub const SPINEL_PROP_THREAD_TMF_PROXY_STREAM: _bindgen_ty_24 = 5394;
#[doc = " Thread \"joiner\" flag used during discovery scan operation\n** Format `b`\n*\n* This property defines the Joiner Flag value in the Discovery Request TLV.\n*\n* Default value is `false`.\n*\n*/"]
pub const SPINEL_PROP_THREAD_DISCOVERY_SCAN_JOINER_FLAG: _bindgen_ty_24 = 5395;
#[doc = " Enable EUI64 filtering for discovery scan operation.\n** Format `b`\n*\n* Default value is `false`\n*\n*/"]
pub const SPINEL_PROP_THREAD_DISCOVERY_SCAN_ENABLE_FILTERING: _bindgen_ty_24 = 5396;
#[doc = " PANID used for Discovery scan operation (used for PANID filtering).\n** Format: `S`\n*\n* Default value is 0xffff (Broadcast PAN) to disable PANID filtering\n*\n*/"]
pub const SPINEL_PROP_THREAD_DISCOVERY_SCAN_PANID: _bindgen_ty_24 = 5397;
#[doc = " Thread (out of band) steering data for MLE Discovery Response.\n** Format `E` - Write only\n*\n* Required capability: SPINEL_CAP_OOB_STEERING_DATA.\n*\n* Writing to this property allows to set/update the MLE\n* Discovery Response steering data out of band.\n*\n*  - All zeros to clear the steering data (indicating that\n*    there is no steering data).\n*  - All 0xFFs to set steering data/bloom filter to\n*    accept/allow all.\n*  - A specific EUI64 which is then added to current steering\n*    data/bloom filter.\n*\n*/"]
pub const SPINEL_PROP_THREAD_STEERING_DATA: _bindgen_ty_24 = 5398;
#[doc = " Thread Router Table.\n** Format: `A(t(ESCCCCCCb)` - Read only\n*\n* Data per item is:\n*\n*  `E`: IEEE 802.15.4 Extended Address\n*  `S`: RLOC16\n*  `C`: Router ID\n*  `C`: Next hop to router\n*  `C`: Path cost to router\n*  `C`: Link Quality In\n*  `C`: Link Quality Out\n*  `C`: Age (seconds since last heard)\n*  `b`: Link established with Router ID or not.\n*\n*/"]
pub const SPINEL_PROP_THREAD_ROUTER_TABLE: _bindgen_ty_24 = 5399;
#[doc = " Thread Active Operational Dataset\n** Format: `A(t(iD))` - Read-Write\n*\n* This property provides access to current Thread Active Operational Dataset. A Thread device maintains the\n* Operational Dataset that it has stored locally and the one currently in use by the partition to which it is\n* attached. This property corresponds to the locally stored Dataset on the device.\n*\n* Operational Dataset consists of a set of supported properties (e.g., channel, network key, network name, PAN id,\n* etc). Note that not all supported properties may be present (have a value) in a Dataset.\n*\n* The Dataset value is encoded as an array of structs containing pairs of property key (as `i`) followed by the\n* property value (as `D`). The property value must follow the format associated with the corresponding property.\n*\n* On write, any unknown/unsupported property keys must be ignored.\n*\n* The following properties can be included in a Dataset list:\n*\n*   SPINEL_PROP_DATASET_ACTIVE_TIMESTAMP\n*   SPINEL_PROP_PHY_CHAN\n*   SPINEL_PROP_PHY_CHAN_SUPPORTED (Channel Mask Page 0)\n*   SPINEL_PROP_NET_NETWORK_KEY\n*   SPINEL_PROP_NET_NETWORK_NAME\n*   SPINEL_PROP_NET_XPANID\n*   SPINEL_PROP_MAC_15_4_PANID\n*   SPINEL_PROP_IPV6_ML_PREFIX\n*   SPINEL_PROP_NET_PSKC\n*   SPINEL_PROP_DATASET_SECURITY_POLICY\n*\n*/"]
pub const SPINEL_PROP_THREAD_ACTIVE_DATASET: _bindgen_ty_24 = 5400;
#[doc = " Thread Pending Operational Dataset\n** Format: `A(t(iD))` - Read-Write\n*\n* This property provide access to current locally stored Pending Operational Dataset.\n*\n* The formatting of this property follows the same rules as in SPINEL_PROP_THREAD_ACTIVE_DATASET.\n*\n* In addition supported properties in SPINEL_PROP_THREAD_ACTIVE_DATASET, the following properties can also\n* be included in the Pending Dataset:\n*\n*   SPINEL_PROP_DATASET_PENDING_TIMESTAMP\n*   SPINEL_PROP_DATASET_DELAY_TIMER\n*\n*/"]
pub const SPINEL_PROP_THREAD_PENDING_DATASET: _bindgen_ty_24 = 5401;
#[doc = " Send MGMT_SET Thread Active Operational Dataset\n** Format: `A(t(iD))` - Write only\n*\n* The formatting of this property follows the same rules as in SPINEL_PROP_THREAD_ACTIVE_DATASET.\n*\n* This is write-only property. When written, it triggers a MGMT_ACTIVE_SET meshcop command to be sent to leader\n* with the given Dataset. The spinel frame response should be a `LAST_STATUS` with the status of the transmission\n* of MGMT_ACTIVE_SET command.\n*\n* In addition to supported properties in SPINEL_PROP_THREAD_ACTIVE_DATASET, the following property can be\n* included in the Dataset (to allow for custom raw TLVs):\n*\n*    SPINEL_PROP_DATASET_RAW_TLVS\n*\n*/"]
pub const SPINEL_PROP_THREAD_MGMT_SET_ACTIVE_DATASET: _bindgen_ty_24 = 5402;
#[doc = " Send MGMT_SET Thread Pending Operational Dataset\n** Format: `A(t(iD))` - Write only\n*\n* This property is similar to SPINEL_PROP_THREAD_PENDING_DATASET and follows the same format and rules.\n*\n* In addition to supported properties in SPINEL_PROP_THREAD_PENDING_DATASET, the following property can be\n* included the Dataset (to allow for custom raw TLVs to be provided).\n*\n*    SPINEL_PROP_DATASET_RAW_TLVS\n*\n*/"]
pub const SPINEL_PROP_THREAD_MGMT_SET_PENDING_DATASET: _bindgen_ty_24 = 5403;
#[doc = " Operational Dataset Active Timestamp\n** Format: `X` - No direct read or write\n*\n* It can only be included in one of the Dataset related properties below:\n*\n*   SPINEL_PROP_THREAD_ACTIVE_DATASET\n*   SPINEL_PROP_THREAD_PENDING_DATASET\n*   SPINEL_PROP_THREAD_MGMT_SET_ACTIVE_DATASET\n*   SPINEL_PROP_THREAD_MGMT_SET_PENDING_DATASET\n*   SPINEL_PROP_THREAD_MGMT_GET_ACTIVE_DATASET\n*   SPINEL_PROP_THREAD_MGMT_GET_PENDING_DATASET\n*\n*/"]
pub const SPINEL_PROP_DATASET_ACTIVE_TIMESTAMP: _bindgen_ty_24 = 5404;
#[doc = " Operational Dataset Pending Timestamp\n** Format: `X` - No direct read or write\n*\n* It can only be included in one of the Pending Dataset properties:\n*\n*   SPINEL_PROP_THREAD_PENDING_DATASET\n*   SPINEL_PROP_THREAD_MGMT_SET_PENDING_DATASET\n*   SPINEL_PROP_THREAD_MGMT_GET_PENDING_DATASET\n*\n*/"]
pub const SPINEL_PROP_DATASET_PENDING_TIMESTAMP: _bindgen_ty_24 = 5405;
#[doc = " Operational Dataset Delay Timer\n** Format: `L` - No direct read or write\n*\n* Delay timer (in ms) specifies the time renaming until Thread devices overwrite the value in the Active\n* Operational Dataset with the corresponding values in the Pending Operational Dataset.\n*\n* It can only be included in one of the Pending Dataset properties:\n*\n*   SPINEL_PROP_THREAD_PENDING_DATASET\n*   SPINEL_PROP_THREAD_MGMT_SET_PENDING_DATASET\n*   SPINEL_PROP_THREAD_MGMT_GET_PENDING_DATASET\n*\n*/"]
pub const SPINEL_PROP_DATASET_DELAY_TIMER: _bindgen_ty_24 = 5406;
#[doc = " Operational Dataset Security Policy\n** Format: `SD` - No direct read or write\n*\n* It can only be included in one of the Dataset related properties below:\n*\n*   SPINEL_PROP_THREAD_ACTIVE_DATASET\n*   SPINEL_PROP_THREAD_PENDING_DATASET\n*   SPINEL_PROP_THREAD_MGMT_SET_ACTIVE_DATASET\n*   SPINEL_PROP_THREAD_MGMT_SET_PENDING_DATASET\n*   SPINEL_PROP_THREAD_MGMT_GET_ACTIVE_DATASET\n*   SPINEL_PROP_THREAD_MGMT_GET_PENDING_DATASET\n*\n* Content is\n*   `S` : Key Rotation Time (in units of hour)\n*   `C` : Security Policy Flags (as specified in Thread 1.1 Section 8.10.1.15)\n*   `C` : Optional Security Policy Flags extension (as specified in Thread 1.2 Section 8.10.1.15).\n*         0xf8 is used if this field is missing.\n*\n*/"]
pub const SPINEL_PROP_DATASET_SECURITY_POLICY: _bindgen_ty_24 = 5407;
#[doc = " Operational Dataset Additional Raw TLVs\n** Format: `D` - No direct read or write\n*\n* This property defines extra raw TLVs that can be added to an Operational DataSet.\n*\n* It can only be included in one of the following Dataset properties:\n*\n*   SPINEL_PROP_THREAD_MGMT_SET_ACTIVE_DATASET\n*   SPINEL_PROP_THREAD_MGMT_SET_PENDING_DATASET\n*   SPINEL_PROP_THREAD_MGMT_GET_ACTIVE_DATASET\n*   SPINEL_PROP_THREAD_MGMT_GET_PENDING_DATASET\n*\n*/"]
pub const SPINEL_PROP_DATASET_RAW_TLVS: _bindgen_ty_24 = 5408;
#[doc = " Child table addresses\n** Format: `A(t(ESA(6)))` - Read only\n*\n* This property provides the list of all addresses associated with every child\n* including any registered IPv6 addresses.\n*\n* Data per item is:\n*\n*  `E`: Extended address of the child\n*  `S`: RLOC16 of the child\n*  `A(6)`: List of IPv6 addresses registered by the child (if any)\n*\n*/"]
pub const SPINEL_PROP_THREAD_CHILD_TABLE_ADDRESSES: _bindgen_ty_24 = 5409;
#[doc = " Neighbor Table Frame and Message Error Rates\n** Format: `A(t(ESSScc))`\n*  Required capability: `CAP_ERROR_RATE_TRACKING`\n*\n* This property provides link quality related info including\n* frame and (IPv6) message error rates for all neighbors.\n*\n* With regards to message error rate, note that a larger (IPv6)\n* message can be fragmented and sent as multiple MAC frames. The\n* message transmission is considered a failure, if any of its\n* fragments fail after all MAC retry attempts.\n*\n* Data per item is:\n*\n*  `E`: Extended address of the neighbor\n*  `S`: RLOC16 of the neighbor\n*  `S`: Frame error rate (0 -> 0%, 0xffff -> 100%)\n*  `S`: Message error rate (0 -> 0%, 0xffff -> 100%)\n*  `c`: Average RSSI (in dBm)\n*  `c`: Last RSSI (in dBm)\n*\n*/"]
pub const SPINEL_PROP_THREAD_NEIGHBOR_TABLE_ERROR_RATES: _bindgen_ty_24 = 5410;
#[doc = " EID (Endpoint Identifier) IPv6 Address Cache Table\n** Format `A(t(6SCCt(bL6)t(bSS)))\n*\n* This property provides Thread EID address cache table.\n*\n* Data per item is:\n*\n*  `6` : Target IPv6 address\n*  `S` : RLOC16 of target\n*  `C` : Age (order of use, 0 indicates most recently used entry)\n*  `C` : Entry state (values are defined by enumeration `SPINEL_ADDRESS_CACHE_ENTRY_STATE_*`).\n*\n*  `t` : Info when state is `SPINEL_ADDRESS_CACHE_ENTRY_STATE_CACHED`\n*    `b` : Indicates whether last transaction time and ML-EID are valid.\n*    `L` : Last transaction time\n*    `6` : Mesh-local EID\n*\n*  `t` : Info when state is other than `SPINEL_ADDRESS_CACHE_ENTRY_STATE_CACHED`\n*    `b` : Indicates whether the entry can be evicted.\n*    `S` : Timeout in seconds\n*    `S` : Retry delay (applicable if in query-retry state).\n*\n*/"]
pub const SPINEL_PROP_THREAD_ADDRESS_CACHE_TABLE: _bindgen_ty_24 = 5411;
#[doc = " Thread UDP forward stream\n** Format `dS6S`\n* Required capability: `SPINEL_CAP_THREAD_UDP_FORWARD`\n*\n* This property helps exchange UDP packets with host.\n*\n*  `d`: UDP payload\n*  `S`: Remote UDP port\n*  `6`: Remote IPv6 address\n*  `S`: Local UDP port\n*\n*/"]
pub const SPINEL_PROP_THREAD_UDP_FORWARD_STREAM: _bindgen_ty_24 = 5412;
#[doc = " Send MGMT_GET Thread Active Operational Dataset\n** Format: `A(t(iD))` - Write only\n*\n* The formatting of this property follows the same rules as in SPINEL_PROP_THREAD_MGMT_SET_ACTIVE_DATASET. This\n* property further allows the sender to not include a value associated with properties in formatting of `t(iD)`,\n* i.e., it should accept either a `t(iD)` or a `t(i)` encoding (in both cases indicating that the associated\n* Dataset property should be requested as part of MGMT_GET command).\n*\n* This is write-only property. When written, it triggers a MGMT_ACTIVE_GET meshcop command to be sent to leader\n* requesting the Dataset related properties from the format. The spinel frame response should be a `LAST_STATUS`\n* with the status of the transmission of MGMT_ACTIVE_GET command.\n*\n* In addition to supported properties in SPINEL_PROP_THREAD_MGMT_SET_ACTIVE_DATASET, the following property can be\n* optionally included in the Dataset:\n*\n*    SPINEL_PROP_DATASET_DEST_ADDRESS\n*\n*/"]
pub const SPINEL_PROP_THREAD_MGMT_GET_ACTIVE_DATASET: _bindgen_ty_24 = 5413;
#[doc = " Send MGMT_GET Thread Pending Operational Dataset\n** Format: `A(t(iD))` - Write only\n*\n* The formatting of this property follows the same rules as in SPINEL_PROP_THREAD_MGMT_GET_ACTIVE_DATASET.\n*\n* This is write-only property. When written, it triggers a MGMT_PENDING_GET meshcop command to be sent to leader\n* with the given Dataset. The spinel frame response should be a `LAST_STATUS` with the status of the transmission\n* of MGMT_PENDING_GET command.\n*\n*/"]
pub const SPINEL_PROP_THREAD_MGMT_GET_PENDING_DATASET: _bindgen_ty_24 = 5414;
#[doc = " Operational Dataset (MGMT_GET) Destination IPv6 Address\n** Format: `6` - No direct read or write\n*\n* This property specifies the IPv6 destination when sending MGMT_GET command for either Active or Pending Dataset\n* if not provided, Leader ALOC address is used as default.\n*\n* It can only be included in one of the MGMT_GET Dataset properties:\n*\n*   SPINEL_PROP_THREAD_MGMT_GET_ACTIVE_DATASET\n*   SPINEL_PROP_THREAD_MGMT_GET_PENDING_DATASET\n*\n*/"]
pub const SPINEL_PROP_DATASET_DEST_ADDRESS: _bindgen_ty_24 = 5415;
#[doc = " Thread New Operational Dataset\n** Format: `A(t(iD))` - Read only - FTD build only\n*\n* This property allows host to request NCP to create and return a new Operation Dataset to use when forming a new\n* network.\n*\n* Operational Dataset consists of a set of supported properties (e.g., channel, network key, network name, PAN id,\n* etc). Note that not all supported properties may be present (have a value) in a Dataset.\n*\n* The Dataset value is encoded as an array of structs containing pairs of property key (as `i`) followed by the\n* property value (as `D`). The property value must follow the format associated with the corresponding property.\n*\n* The following properties can be included in a Dataset list:\n*\n*   SPINEL_PROP_DATASET_ACTIVE_TIMESTAMP\n*   SPINEL_PROP_PHY_CHAN\n*   SPINEL_PROP_PHY_CHAN_SUPPORTED (Channel Mask Page 0)\n*   SPINEL_PROP_NET_NETWORK_KEY\n*   SPINEL_PROP_NET_NETWORK_NAME\n*   SPINEL_PROP_NET_XPANID\n*   SPINEL_PROP_MAC_15_4_PANID\n*   SPINEL_PROP_IPV6_ML_PREFIX\n*   SPINEL_PROP_NET_PSKC\n*   SPINEL_PROP_DATASET_SECURITY_POLICY\n*\n*/"]
pub const SPINEL_PROP_THREAD_NEW_DATASET: _bindgen_ty_24 = 5416;
#[doc = " MAC CSL Period\n** Format: `S`\n* Required capability: `SPINEL_CAP_THREAD_CSL_RECEIVER`\n*\n* The CSL period in units of 10 symbols. Value of 0 indicates that CSL should be disabled.\n*/"]
pub const SPINEL_PROP_THREAD_CSL_PERIOD: _bindgen_ty_24 = 5417;
#[doc = " MAC CSL Timeout\n** Format: `L`\n* Required capability: `SPINEL_CAP_THREAD_CSL_RECEIVER`\n*\n* The CSL timeout in seconds.\n*/"]
pub const SPINEL_PROP_THREAD_CSL_TIMEOUT: _bindgen_ty_24 = 5418;
#[doc = " MAC CSL Channel\n** Format: `C`\n* Required capability: `SPINEL_CAP_THREAD_CSL_RECEIVER`\n*\n* The CSL channel as described in chapter 4.6.5.1.2 of the Thread v1.2.0 Specification.\n* Value of 0 means that CSL reception (if enabled) occurs on the Thread Network channel.\n* Value from range [11,26] is an alternative channel on which a CSL reception occurs.\n*/"]
pub const SPINEL_PROP_THREAD_CSL_CHANNEL: _bindgen_ty_24 = 5419;
#[doc = " Thread Domain Name\n** Format `U` - Read-write\n* Required capability: `SPINEL_CAP_NET_THREAD_1_2`\n*\n* This property is available since Thread 1.2.0.\n* Write to this property succeeds only when Thread protocols are disabled.\n*\n*/"]
pub const SPINEL_PROP_THREAD_DOMAIN_NAME: _bindgen_ty_24 = 5420;
#[doc = " Link metrics query\n** Format: `6CC` - Write-Only\n*\n* Required capability: `SPINEL_CAP_THREAD_LINK_METRICS`\n*\n* `6` : IPv6 destination address\n* `C` : Series id (0 for Single Probe)\n* `C` : List of requested metric ids encoded as bit fields in single byte\n*\n*   +---------------+----+\n*   |    Metric     | Id |\n*   +---------------+----+\n*   | Received PDUs |  0 |\n*   | LQI           |  1 |\n*   | Link margin   |  2 |\n*   | RSSI          |  3 |\n*   +---------------+----+\n*\n* If the query succeeds, the NCP will send a result to the Host using\n* @ref SPINEL_PROP_THREAD_LINK_METRICS_QUERY_RESULT.\n*\n*/"]
pub const SPINEL_PROP_THREAD_LINK_METRICS_QUERY: _bindgen_ty_24 = 5421;
#[doc = " Link metrics query result\n** Format: `6Ct(A(t(CD)))` - Unsolicited notifications only\n*\n* Required capability: `SPINEL_CAP_THREAD_LINK_METRICS`\n*\n* `6` : IPv6 destination address\n* `C` : Status\n* `t(A(t(CD)))` : Array of structs encoded as following:\n*   `C` : Metric id\n*   `D` : Metric value\n*\n*   +---------------+----+----------------+\n*   |    Metric     | Id |  Value format  |\n*   +---------------+----+----------------+\n*   | Received PDUs |  0 | `L` (uint32_t) |\n*   | LQI           |  1 | `C` (uint8_t)  |\n*   | Link margin   |  2 | `C` (uint8_t)  |\n*   | RSSI          |  3 | `c` (int8_t)   |\n*   +---------------+----+----------------+\n*\n*/"]
pub const SPINEL_PROP_THREAD_LINK_METRICS_QUERY_RESULT: _bindgen_ty_24 = 5422;
#[doc = " Link metrics probe\n** Format `6CC` - Write only\n* Required capability: `SPINEL_CAP_THREAD_LINK_METRICS`\n*\n* Send a MLE Link Probe message to the peer.\n*\n* `6` : IPv6 destination address\n* `C` : The Series ID for which this Probe message targets at\n* `C` : The length of the Probe message, valid range: [0, 64]\n*\n*/"]
pub const SPINEL_PROP_THREAD_LINK_METRICS_PROBE: _bindgen_ty_24 = 5423;
#[doc = " Link metrics Enhanced-ACK Based Probing management\n** Format: 6Cd - Write only\n*\n* Required capability: `SPINEL_CAP_THREAD_LINK_METRICS`\n*\n* `6` : IPv6 destination address\n* `C` : Indicate whether to register or clear the probing. `0` - clear, `1` - register\n* `C` : List of requested metric ids encoded as bit fields in single byte\n*\n*   +---------------+----+\n*   |    Metric     | Id |\n*   +---------------+----+\n*   | LQI           |  1 |\n*   | Link margin   |  2 |\n*   | RSSI          |  3 |\n*   +---------------+----+\n*\n* Result of configuration is reported asynchronously to the Host using the\n* @ref SPINEL_PROP_THREAD_LINK_METRICS_MGMT_RESPONSE.\n*\n* Whenever Enh-ACK IE report is received it is passed to the Host using the\n* @ref SPINEL_PROP_THREAD_LINK_METRICS_MGMT_ENH_ACK_IE property.\n*\n*/"]
pub const SPINEL_PROP_THREAD_LINK_METRICS_MGMT_ENH_ACK: _bindgen_ty_24 = 5424;
#[doc = " Link metrics Enhanced-ACK Based Probing IE report\n** Format: SEA(t(CD)) - Unsolicited notifications only\n*\n* Required capability: `SPINEL_CAP_THREAD_LINK_METRICS`\n*\n* `S` : Short address of the Probing Subject\n* `E` : Extended address of the Probing Subject\n* `t(A(t(CD)))` : Struct that contains array of structs encoded as following:\n*   `C` : Metric id\n*   `D` : Metric value\n*\n*   +---------------+----+----------------+\n*   |    Metric     | Id |  Value format  |\n*   +---------------+----+----------------+\n*   | LQI           |  1 | `C` (uint8_t)  |\n*   | Link margin   |  2 | `C` (uint8_t)  |\n*   | RSSI          |  3 | `c` (int8_t)   |\n*   +---------------+----+----------------+\n*\n*/"]
pub const SPINEL_PROP_THREAD_LINK_METRICS_MGMT_ENH_ACK_IE: _bindgen_ty_24 = 5425;
#[doc = " Link metrics Forward Tracking Series management\n** Format: 6CCC - Write only\n*\n* Required capability: `SPINEL_CAP_THREAD_LINK_METRICS`\n*\n* `6` : IPv6 destination address\n* `C` : Series id\n* `C` : Tracked frame types encoded as bit fields in single byte, if equal to zero,\n*       accounting is stopped and a series is removed\n* `C` : Requested metric ids encoded as bit fields in single byte\n*\n*   +------------------+----+\n*   |    Frame type    | Id |\n*   +------------------+----+\n*   | MLE Link Probe   |  0 |\n*   | MAC Data         |  1 |\n*   | MAC Data Request |  2 |\n*   | MAC ACK          |  3 |\n*   +------------------+----+\n*\n*   +---------------+----+\n*   |    Metric     | Id |\n*   +---------------+----+\n*   | Received PDUs |  0 |\n*   | LQI           |  1 |\n*   | Link margin   |  2 |\n*   | RSSI          |  3 |\n*   +---------------+----+\n*\n* Result of configuration is reported asynchronously to the Host using the\n* @ref SPINEL_PROP_THREAD_LINK_METRICS_MGMT_RESPONSE.\n*\n*/"]
pub const SPINEL_PROP_THREAD_LINK_METRICS_MGMT_FORWARD: _bindgen_ty_24 = 5426;
#[doc = " Link metrics management response\n** Format: 6C - Unsolicited notifications only\n*\n* Required capability: `SPINEL_CAP_THREAD_LINK_METRICS`\n*\n* `6` : IPv6 source address\n* `C` : Received status\n*\n*/"]
pub const SPINEL_PROP_THREAD_LINK_METRICS_MGMT_RESPONSE: _bindgen_ty_24 = 5427;
#[doc = " Multicast Listeners Register Request\n** Format `t(A(6))A(t(CD))` - Write-only\n* Required capability: `SPINEL_CAP_NET_THREAD_1_2`\n*\n* `t(A(6))`: Array of IPv6 multicast addresses\n* `A(t(CD))`: Array of structs holding optional parameters as follows\n*   `C`: Parameter id\n*   `D`: Parameter value\n*\n*   +----------------------------------------------------------------+\n*   | Id:   SPINEL_THREAD_MLR_PARAMID_TIMEOUT                        |\n*   | Type: `L`                                                      |\n*   | Description: Timeout in seconds. If this optional parameter is |\n*   |   omitted, the default value of the BBR will be used.          |\n*   | Special values:                                                |\n*   |   0 causes given addresses to be removed                       |\n*   |   0xFFFFFFFF is permanent and persistent registration          |\n*   +----------------------------------------------------------------+\n*\n* Write to this property initiates update of Multicast Listeners Table on the primary BBR.\n* If the write succeeded, the result of network operation will be notified later by the\n* SPINEL_PROP_THREAD_MLR_RESPONSE property. If the write fails, no MLR.req is issued and\n* notification through the SPINEL_PROP_THREAD_MLR_RESPONSE property will not occur.\n*\n*/"]
pub const SPINEL_PROP_THREAD_MLR_REQUEST: _bindgen_ty_24 = 5428;
#[doc = " Multicast Listeners Register Response\n** Format `CCt(A(6))` - Unsolicited notifications only\n* Required capability: `SPINEL_CAP_NET_THREAD_1_2`\n*\n* `C`: Status\n* `C`: MlrStatus (The Multicast Listener Registration Status)\n* `A(6)`: Array of IPv6 addresses that failed to be updated on the primary BBR\n*\n* This property is notified asynchronously when the NCP receives MLR.rsp following\n* previous write to the SPINEL_PROP_THREAD_MLR_REQUEST property.\n*/"]
pub const SPINEL_PROP_THREAD_MLR_RESPONSE: _bindgen_ty_24 = 5429;
#[doc = " Interface Identifier specified for Thread Domain Unicast Address.\n** Format: `A(C)` - Read-write\n*\n*   `A(C)`: Interface Identifier (8 bytes).\n*\n* Required capability: SPINEL_CAP_DUA\n*\n* If write to this property is performed without specified parameter\n* the Interface Identifier of the Thread Domain Unicast Address will be cleared.\n* If the DUA Interface Identifier is cleared on the NCP device,\n* the get spinel property command will be returned successfully without specified parameter.\n*\n*/"]
pub const SPINEL_PROP_THREAD_DUA_ID: _bindgen_ty_24 = 5430;
#[doc = " Thread 1.2 Primary Backbone Router information in the Thread Network.\n** Format: `SSLC` - Read-Only\n*\n* Required capability: `SPINEL_CAP_NET_THREAD_1_2`\n*\n* `S`: Server.\n* `S`: Reregistration Delay (in seconds).\n* `L`: Multicast Listener Registration Timeout (in seconds).\n* `C`: Sequence Number.\n*\n*/"]
pub const SPINEL_PROP_THREAD_BACKBONE_ROUTER_PRIMARY: _bindgen_ty_24 = 5431;
#[doc = " Thread 1.2 Backbone Router local state.\n** Format: `C` - Read-Write\n*\n* Required capability: `SPINEL_CAP_THREAD_BACKBONE_ROUTER`\n*\n* The valid values are specified by SPINEL_THREAD_BACKBONE_ROUTER_STATE_<state> enumeration.\n* Backbone functionality will be disabled if SPINEL_THREAD_BACKBONE_ROUTER_STATE_DISABLED\n* is written to this property, enabled otherwise.\n*\n*/"]
pub const SPINEL_PROP_THREAD_BACKBONE_ROUTER_LOCAL_STATE: _bindgen_ty_24 = 5432;
#[doc = " Local Thread 1.2 Backbone Router configuration.\n** Format: SLC - Read-Write\n*\n* Required capability: `SPINEL_CAP_THREAD_BACKBONE_ROUTER`\n*\n* `S`: Reregistration Delay (in seconds).\n* `L`: Multicast Listener Registration Timeout (in seconds).\n* `C`: Sequence Number.\n*\n*/"]
pub const SPINEL_PROP_THREAD_BACKBONE_ROUTER_LOCAL_CONFIG: _bindgen_ty_24 = 5433;
#[doc = " Register local Thread 1.2 Backbone Router configuration.\n** Format: Empty (Write only).\n*\n* Required capability: `SPINEL_CAP_THREAD_BACKBONE_ROUTER`\n*\n* Writing to this property (with any value) will register local Backbone Router configuration.\n*\n*/"]
pub const SPINEL_PROP_THREAD_BACKBONE_ROUTER_LOCAL_REGISTER: _bindgen_ty_24 = 5434;
#[doc = " Thread 1.2 Backbone Router registration jitter.\n** Format: `C` - Read-Write\n*\n* Required capability: `SPINEL_CAP_THREAD_BACKBONE_ROUTER`\n*\n* `C`: Backbone Router registration jitter.\n*\n*/"]
pub const SPINEL_PROP_THREAD_BACKBONE_ROUTER_LOCAL_REGISTRATION_JITTER: _bindgen_ty_24 = 5435;
#[doc = " Thread 1.2 Backbone Router registration jitter.\n** Format: `C` - Read-Write\n*\n* Required capability: `SPINEL_CAP_THREAD_BACKBONE_ROUTER`\n*\n* `C`: Backbone Router registration jitter.\n*\n*/"]
pub const SPINEL_PROP_THREAD_EXT__END: _bindgen_ty_24 = 5632;
#[doc = " Thread 1.2 Backbone Router registration jitter.\n** Format: `C` - Read-Write\n*\n* Required capability: `SPINEL_CAP_THREAD_BACKBONE_ROUTER`\n*\n* `C`: Backbone Router registration jitter.\n*\n*/"]
pub const SPINEL_PROP_IPV6__BEGIN: _bindgen_ty_24 = 96;
#[doc = "< [6]"]
pub const SPINEL_PROP_IPV6_LL_ADDR: _bindgen_ty_24 = 96;
#[doc = " Mesh Local IPv6 Address\n** Format: `6` - Read only\n*\n*/"]
pub const SPINEL_PROP_IPV6_ML_ADDR: _bindgen_ty_24 = 97;
#[doc = " Mesh Local Prefix\n** Format: `6C` - Read-write\n*\n* Provides Mesh Local Prefix\n*\n*   `6`: Mesh local prefix\n*   `C` : Prefix length (64 bit for Thread).\n*\n*/"]
pub const SPINEL_PROP_IPV6_ML_PREFIX: _bindgen_ty_24 = 98;
#[doc = " IPv6 (Unicast) Address Table\n** Format: `A(t(6CLLC))`\n*\n* This property provides all unicast addresses.\n*\n* Array of structures containing:\n*\n*  `6`: IPv6 Address\n*  `C`: Network Prefix Length (in bits)\n*  `L`: Valid Lifetime\n*  `L`: Preferred Lifetime\n*\n*/"]
pub const SPINEL_PROP_IPV6_ADDRESS_TABLE: _bindgen_ty_24 = 99;
#[doc = " IPv6 Route Table - Deprecated"]
pub const SPINEL_PROP_IPV6_ROUTE_TABLE: _bindgen_ty_24 = 100;
#[doc = " IPv6 ICMP Ping Offload\n** Format: `b`\n*\n* Allow the NCP to directly respond to ICMP ping requests. If this is\n* turned on, ping request ICMP packets will not be passed to the host.\n*\n* Default value is `false`.\n*/"]
pub const SPINEL_PROP_IPV6_ICMP_PING_OFFLOAD: _bindgen_ty_24 = 101;
#[doc = " IPv6 Multicast Address Table\n** Format: `A(t(6))`\n*\n* This property provides all multicast addresses.\n*\n*/"]
pub const SPINEL_PROP_IPV6_MULTICAST_ADDRESS_TABLE: _bindgen_ty_24 = 102;
#[doc = "< [b]"]
pub const SPINEL_PROP_IPV6_ICMP_PING_OFFLOAD_MODE: _bindgen_ty_24 = 103;
pub const SPINEL_PROP_IPV6__END: _bindgen_ty_24 = 112;
pub const SPINEL_PROP_IPV6_EXT__BEGIN: _bindgen_ty_24 = 5632;
pub const SPINEL_PROP_IPV6_EXT__END: _bindgen_ty_24 = 5888;
pub const SPINEL_PROP_STREAM__BEGIN: _bindgen_ty_24 = 112;
#[doc = " Debug Stream\n** Format: `U` (stream, read only)\n*\n* This property is a streaming property, meaning that you cannot explicitly\n* fetch the value of this property. The stream provides human-readable debugging\n* output which may be displayed in the host logs.\n*\n* The location of newline characters is not assumed by the host: it is\n* the NCP's responsibility to insert newline characters where needed,\n* just like with any other text stream.\n*\n* To receive the debugging stream, you wait for `CMD_PROP_VALUE_IS`\n* commands for this property from the NCP.\n*\n*/"]
pub const SPINEL_PROP_STREAM_DEBUG: _bindgen_ty_24 = 112;
#[doc = " Raw Stream\n** Format: `dD` (stream, read only)\n*  Required Capability: SPINEL_CAP_MAC_RAW or SPINEL_CAP_CONFIG_RADIO\n*\n* This stream provides the capability of sending and receiving raw 15.4 frames\n* to and from the radio. The exact format of the frame metadata and data is\n* dependent on the MAC and PHY being used.\n*\n* This property is a streaming property, meaning that you cannot explicitly\n* fetch the value of this property. To receive traffic, you wait for\n* `CMD_PROP_VALUE_IS` commands with this property id from the NCP.\n*\n* The general format of this property is:\n*\n*    `d` : frame data\n*    `D` : frame meta data\n*\n* The frame meta data is optional. Frame metadata MAY be empty or partially\n* specified. Partially specified metadata MUST be accepted. Default values\n* are used for all unspecified fields.\n*\n* The frame metadata field consists of the following fields:\n*\n*   `c` : Received Signal Strength (RSSI) in dBm - default is -128\n*   `c` : Noise floor in dBm - default is -128\n*   `S` : Flags (see below).\n*   `d` : PHY-specific data/struct\n*   `d` : Vendor-specific data/struct\n*\n* Flags fields are defined by the following enumeration bitfields:\n*\n*   SPINEL_MD_FLAG_TX       = 0x0001 :  Packet was transmitted, not received.\n*   SPINEL_MD_FLAG_BAD_FCS  = 0x0004 :  Packet was received with bad FCS\n*   SPINEL_MD_FLAG_DUPE     = 0x0008 :  Packet seems to be a duplicate\n*   SPINEL_MD_FLAG_RESERVED = 0xFFF2 :  Flags reserved for future use.\n*\n* The format of PHY-specific data for a Thread device contains the following\n* optional fields:\n\n*   `C` : 802.15.4 channel (Receive channel)\n*   `C` : IEEE 802.15.4 LQI\n*   `L` : The timestamp milliseconds\n*   `S` : The timestamp microseconds, offset to mMsec\n*\n* Frames written to this stream with `CMD_PROP_VALUE_SET` will be sent out\n* over the radio. This allows the caller to use the radio directly.\n*\n* The frame meta data for the `CMD_PROP_VALUE_SET` contains the following\n* fields.  Default values are used for all unspecified fields.\n*\n*  `C` : Channel (for frame tx) - MUST be included.\n*  `C` : Maximum number of backoffs attempts before declaring CCA failure\n*        (use Thread stack default if not specified)\n*  `C` : Maximum number of retries allowed after a transmission failure\n*        (use Thread stack default if not specified)\n*  `b` : Set to true to enable CSMA-CA for this packet, false otherwise.\n*        (default true).\n*  `b` : Set to true to indicate if header is updated - related to\n*        `mIsHeaderUpdated` in `otRadioFrame` (default false).\n*  `b` : Set to true to indicate it is a retransmission - related to\n*        `mIsARetx` in `otRadioFrame` (default false).\n*  `b` : Set to true to indicate security was processed on tx frame\n*        `mIsSecurityProcessed` in `otRadioFrame` (default false).\n*  `L` : TX delay interval used for CSL - related to `mTxDelay` in\n*        `otRadioFrame` (default zero).\n*  `L` : TX delay based time used for CSL - related to `mTxDelayBaseTime`\n*        in `otRadioFrame` (default zero).\n*  `C` : RX channel after TX done (default assumed to be same as\n*        channel in metadata)\n*\n*/"]
pub const SPINEL_PROP_STREAM_RAW: _bindgen_ty_24 = 113;
#[doc = " (IPv6) Network Stream\n** Format: `dD` (stream, read only)\n*\n* This stream provides the capability of sending and receiving (IPv6)\n* data packets to and from the currently attached network. The packets\n* are sent or received securely (encryption and authentication).\n*\n* This property is a streaming property, meaning that you cannot explicitly\n* fetch the value of this property. To receive traffic, you wait for\n* `CMD_PROP_VALUE_IS` commands with this property id from the NCP.\n*\n* To send network packets, you call `CMD_PROP_VALUE_SET` on this property with\n* the value of the packet.\n*\n* The general format of this property is:\n*\n*    `d` : packet data\n*    `D` : packet meta data\n*\n* The packet metadata is optional. Packet meta data MAY be empty or partially\n* specified. Partially specified metadata MUST be accepted. Default values\n* are used for all unspecified fields.\n*\n* For OpenThread the meta data is currently empty.\n*\n*/"]
pub const SPINEL_PROP_STREAM_NET: _bindgen_ty_24 = 114;
#[doc = " (IPv6) Network Stream Insecure\n** Format: `dD` (stream, read only)\n*\n* This stream provides the capability of sending and receiving unencrypted\n* and unauthenticated data packets to and from nearby devices for the\n* purposes of device commissioning.\n*\n* This property is a streaming property, meaning that you cannot explicitly\n* fetch the value of this property. To receive traffic, you wait for\n* `CMD_PROP_VALUE_IS` commands with this property id from the NCP.\n*\n* To send network packets, you call `CMD_PROP_VALUE_SET` on this property with\n* the value of the packet.\n*\n* The general format of this property is:\n*\n*    `d` : packet data\n*    `D` : packet meta data\n*\n* The packet metadata is optional. Packet meta data MAY be empty or partially\n* specified. Partially specified metadata MUST be accepted. Default values\n* are used for all unspecified fields.\n*\n* For OpenThread the meta data is currently empty.\n*\n*/"]
pub const SPINEL_PROP_STREAM_NET_INSECURE: _bindgen_ty_24 = 115;
#[doc = " Log Stream\n** Format: `UD` (stream, read only)\n*\n* This property is a read-only streaming property which provides\n* formatted log string from NCP. This property provides asynchronous\n* `CMD_PROP_VALUE_IS` updates with a new log string and includes\n* optional meta data.\n*\n*   `U`: The log string\n*   `D`: Log metadata (optional).\n*\n* Any data after the log string is considered metadata and is OPTIONAL.\n* Presence of `SPINEL_CAP_OPENTHREAD_LOG_METADATA` capability\n* indicates that OpenThread log metadata format is used as defined\n* below:\n*\n*    `C`: Log level (as per definition in enumeration\n*         `SPINEL_NCP_LOG_LEVEL_<level>`)\n*    `i`: OpenThread Log region (as per definition in enumeration\n*         `SPINEL_NCP_LOG_REGION_<region>).\n*    `X`: Log timestamp = <timestamp_base> + <current_time_ms>\n*\n*/"]
pub const SPINEL_PROP_STREAM_LOG: _bindgen_ty_24 = 116;
#[doc = " Log Stream\n** Format: `UD` (stream, read only)\n*\n* This property is a read-only streaming property which provides\n* formatted log string from NCP. This property provides asynchronous\n* `CMD_PROP_VALUE_IS` updates with a new log string and includes\n* optional meta data.\n*\n*   `U`: The log string\n*   `D`: Log metadata (optional).\n*\n* Any data after the log string is considered metadata and is OPTIONAL.\n* Presence of `SPINEL_CAP_OPENTHREAD_LOG_METADATA` capability\n* indicates that OpenThread log metadata format is used as defined\n* below:\n*\n*    `C`: Log level (as per definition in enumeration\n*         `SPINEL_NCP_LOG_LEVEL_<level>`)\n*    `i`: OpenThread Log region (as per definition in enumeration\n*         `SPINEL_NCP_LOG_REGION_<region>).\n*    `X`: Log timestamp = <timestamp_base> + <current_time_ms>\n*\n*/"]
pub const SPINEL_PROP_STREAM__END: _bindgen_ty_24 = 128;
#[doc = " Log Stream\n** Format: `UD` (stream, read only)\n*\n* This property is a read-only streaming property which provides\n* formatted log string from NCP. This property provides asynchronous\n* `CMD_PROP_VALUE_IS` updates with a new log string and includes\n* optional meta data.\n*\n*   `U`: The log string\n*   `D`: Log metadata (optional).\n*\n* Any data after the log string is considered metadata and is OPTIONAL.\n* Presence of `SPINEL_CAP_OPENTHREAD_LOG_METADATA` capability\n* indicates that OpenThread log metadata format is used as defined\n* below:\n*\n*    `C`: Log level (as per definition in enumeration\n*         `SPINEL_NCP_LOG_LEVEL_<level>`)\n*    `i`: OpenThread Log region (as per definition in enumeration\n*         `SPINEL_NCP_LOG_REGION_<region>).\n*    `X`: Log timestamp = <timestamp_base> + <current_time_ms>\n*\n*/"]
pub const SPINEL_PROP_STREAM_EXT__BEGIN: _bindgen_ty_24 = 5888;
#[doc = " Log Stream\n** Format: `UD` (stream, read only)\n*\n* This property is a read-only streaming property which provides\n* formatted log string from NCP. This property provides asynchronous\n* `CMD_PROP_VALUE_IS` updates with a new log string and includes\n* optional meta data.\n*\n*   `U`: The log string\n*   `D`: Log metadata (optional).\n*\n* Any data after the log string is considered metadata and is OPTIONAL.\n* Presence of `SPINEL_CAP_OPENTHREAD_LOG_METADATA` capability\n* indicates that OpenThread log metadata format is used as defined\n* below:\n*\n*    `C`: Log level (as per definition in enumeration\n*         `SPINEL_NCP_LOG_LEVEL_<level>`)\n*    `i`: OpenThread Log region (as per definition in enumeration\n*         `SPINEL_NCP_LOG_REGION_<region>).\n*    `X`: Log timestamp = <timestamp_base> + <current_time_ms>\n*\n*/"]
pub const SPINEL_PROP_STREAM_EXT__END: _bindgen_ty_24 = 6144;
#[doc = " Log Stream\n** Format: `UD` (stream, read only)\n*\n* This property is a read-only streaming property which provides\n* formatted log string from NCP. This property provides asynchronous\n* `CMD_PROP_VALUE_IS` updates with a new log string and includes\n* optional meta data.\n*\n*   `U`: The log string\n*   `D`: Log metadata (optional).\n*\n* Any data after the log string is considered metadata and is OPTIONAL.\n* Presence of `SPINEL_CAP_OPENTHREAD_LOG_METADATA` capability\n* indicates that OpenThread log metadata format is used as defined\n* below:\n*\n*    `C`: Log level (as per definition in enumeration\n*         `SPINEL_NCP_LOG_LEVEL_<level>`)\n*    `i`: OpenThread Log region (as per definition in enumeration\n*         `SPINEL_NCP_LOG_REGION_<region>).\n*    `X`: Log timestamp = <timestamp_base> + <current_time_ms>\n*\n*/"]
pub const SPINEL_PROP_MESHCOP__BEGIN: _bindgen_ty_24 = 128;
#[doc = "<[C]"]
pub const SPINEL_PROP_MESHCOP_JOINER_STATE: _bindgen_ty_24 = 128;
#[doc = " Thread Joiner Commissioning command and the parameters\n** Format `b` or `bU(UUUUU)` (fields in parenthesis are optional) - Write Only\n*\n* This property starts or stops Joiner's commissioning process\n*\n* Required capability: SPINEL_CAP_THREAD_JOINER\n*\n* Writing to this property starts/stops the Joiner commissioning process.\n* The immediate `VALUE_IS` response indicates success/failure of the starting/stopping\n* the Joiner commissioning process.\n*\n* After a successful start operation, the join process outcome is reported through an\n* asynchronous `VALUE_IS(LAST_STATUS)` update with one of the following error status values:\n*\n*     - SPINEL_STATUS_JOIN_SUCCESS     the join process succeeded.\n*     - SPINEL_STATUS_JOIN_SECURITY    the join process failed due to security credentials.\n*     - SPINEL_STATUS_JOIN_NO_PEERS    no joinable network was discovered.\n*     - SPINEL_STATUS_JOIN_RSP_TIMEOUT if a response timed out.\n*     - SPINEL_STATUS_JOIN_FAILURE     join failure.\n*\n* Frame format:\n*\n*  `b` : Start or stop commissioning process (true to start).\n*\n* Only if the start commissioning.\n*\n*  `U` : Joiner's PSKd.\n*\n* The next fields are all optional. If not provided, OpenThread default values would be used.\n*\n*  `U` : Provisioning URL (use empty string if not required).\n*  `U` : Vendor Name. If not specified or empty string, use OpenThread default (PACKAGE_NAME).\n*  `U` : Vendor Model. If not specified or empty string, use OpenThread default (OPENTHREAD_CONFIG_PLATFORM_INFO).\n*  `U` : Vendor Sw Version. If not specified or empty string, use OpenThread default (PACKAGE_VERSION).\n*  `U` : Vendor Data String. Will not be appended if not specified.\n*\n*/"]
pub const SPINEL_PROP_MESHCOP_JOINER_COMMISSIONING: _bindgen_ty_24 = 129;
#[doc = " Format `C`\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n\n The valid values are specified by SPINEL_MESHCOP_COMMISSIONER_STATE_<state> enumeration.\n"]
pub const SPINEL_PROP_MESHCOP_COMMISSIONER_STATE: _bindgen_ty_24 = 130;
#[doc = " Format `A(t(t(E|CX)UL))` - get, insert or remove.\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n\n Data per array entry is:\n\n  `t()` | `t(E)` | `t(CX)` : Joiner info struct (formatting varies).\n\n   -  `t()` or empty struct indicates any joiner.\n   -  `t(E)` specifies the Joiner EUI-64.\n   -  `t(CX) specifies Joiner Discerner, `C` is Discerner length (in bits), and `X` is Discerner value.\n\n The struct is followed by:\n\n  `L` : Timeout after which to remove Joiner (when written should be in seconds, when read is in milliseconds)\n  `U` : PSKd\n\n For CMD_PROP_VALUE_REMOVE the timeout and PSKd are optional.\n"]
pub const SPINEL_PROP_MESHCOP_COMMISSIONER_JOINERS: _bindgen_ty_24 = 131;
#[doc = " Format `U`\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n"]
pub const SPINEL_PROP_MESHCOP_COMMISSIONER_PROVISIONING_URL: _bindgen_ty_24 = 132;
#[doc = " Format `S` - Read only\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n"]
pub const SPINEL_PROP_MESHCOP_COMMISSIONER_SESSION_ID: _bindgen_ty_24 = 133;
#[doc = " Thread Joiner Discerner\n** Format `CX`  - Read-write\n*\n* Required capability: SPINEL_CAP_THREAD_JOINER\n*\n* This property represents a Joiner Discerner.\n*\n* The Joiner Discerner is used to calculate the Joiner ID used during commissioning/joining process.\n*\n* By default (when a discerner is not provided or cleared), Joiner ID is derived as first 64 bits of the result\n* of computing SHA-256 over factory-assigned IEEE EUI-64. Note that this is the main behavior expected by Thread\n* specification.\n*\n* Format:\n*\n*   'C' : The Joiner Discerner bit length (number of bits).\n*   `X` : The Joiner Discerner value (64-bit unsigned)  - Only present/applicable when length is non-zero.\n*\n* When writing to this property, the length can be set to zero to clear any previously set Joiner Discerner value.\n*\n* When reading this property if there is no currently set Joiner Discerner, zero is returned as the length (with\n* no value field).\n*\n*/"]
pub const SPINEL_PROP_MESHCOP_JOINER_DISCERNER: _bindgen_ty_24 = 134;
#[doc = " Thread Joiner Discerner\n** Format `CX`  - Read-write\n*\n* Required capability: SPINEL_CAP_THREAD_JOINER\n*\n* This property represents a Joiner Discerner.\n*\n* The Joiner Discerner is used to calculate the Joiner ID used during commissioning/joining process.\n*\n* By default (when a discerner is not provided or cleared), Joiner ID is derived as first 64 bits of the result\n* of computing SHA-256 over factory-assigned IEEE EUI-64. Note that this is the main behavior expected by Thread\n* specification.\n*\n* Format:\n*\n*   'C' : The Joiner Discerner bit length (number of bits).\n*   `X` : The Joiner Discerner value (64-bit unsigned)  - Only present/applicable when length is non-zero.\n*\n* When writing to this property, the length can be set to zero to clear any previously set Joiner Discerner value.\n*\n* When reading this property if there is no currently set Joiner Discerner, zero is returned as the length (with\n* no value field).\n*\n*/"]
pub const SPINEL_PROP_MESHCOP__END: _bindgen_ty_24 = 144;
#[doc = " Thread Joiner Discerner\n** Format `CX`  - Read-write\n*\n* Required capability: SPINEL_CAP_THREAD_JOINER\n*\n* This property represents a Joiner Discerner.\n*\n* The Joiner Discerner is used to calculate the Joiner ID used during commissioning/joining process.\n*\n* By default (when a discerner is not provided or cleared), Joiner ID is derived as first 64 bits of the result\n* of computing SHA-256 over factory-assigned IEEE EUI-64. Note that this is the main behavior expected by Thread\n* specification.\n*\n* Format:\n*\n*   'C' : The Joiner Discerner bit length (number of bits).\n*   `X` : The Joiner Discerner value (64-bit unsigned)  - Only present/applicable when length is non-zero.\n*\n* When writing to this property, the length can be set to zero to clear any previously set Joiner Discerner value.\n*\n* When reading this property if there is no currently set Joiner Discerner, zero is returned as the length (with\n* no value field).\n*\n*/"]
pub const SPINEL_PROP_MESHCOP_EXT__BEGIN: _bindgen_ty_24 = 6144;
#[doc = " Format `LCS6` - Write only\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n\n Writing to this property sends an Announce Begin message with the specified parameters. Response is a\n `LAST_STATUS` update with status of operation.\n\n   `L` : Channel mask\n   `C` : Number of messages per channel\n   `S` : The time between two successive MLE Announce transmissions (milliseconds)\n   `6` : IPv6 destination\n"]
pub const SPINEL_PROP_MESHCOP_COMMISSIONER_ANNOUNCE_BEGIN: _bindgen_ty_24 = 6144;
#[doc = " Format `LCSS6` - Write only\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n\n Writing to this property sends an Energy Scan Query message with the specified parameters. Response is a\n `LAST_STATUS` with status of operation. The energy scan results are emitted asynchronously through\n `SPINEL_PROP_MESHCOP_COMMISSIONER_ENERGY_SCAN_RESULT` updates.\n\n Format is:\n\n   `L` : Channel mask\n   `C` : The number of energy measurements per channel\n   `S` : The time between energy measurements (milliseconds)\n   `S` : The scan duration for each energy measurement (milliseconds)\n   `6` : IPv6 destination.\n"]
pub const SPINEL_PROP_MESHCOP_COMMISSIONER_ENERGY_SCAN: _bindgen_ty_24 = 6145;
#[doc = " Format `Ld` - Asynchronous event only\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n\n This property provides asynchronous `CMD_PROP_VALUE_INSERTED` updates to report energy scan results for a\n previously sent Energy Scan Query message (please see `SPINEL_PROP_MESHCOP_COMMISSIONER_ENERGY_SCAN`).\n\n Format is:\n\n   `L` : Channel mask\n   `d` : Energy measurement data (note that `d` encoding includes the length)\n"]
pub const SPINEL_PROP_MESHCOP_COMMISSIONER_ENERGY_SCAN_RESULT: _bindgen_ty_24 = 6146;
#[doc = " Format `SL6` - Write only\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n\n Writing to this property sends a PAN ID Query message with the specified parameters. Response is a\n `LAST_STATUS` with status of operation. The PAN ID Conflict results are emitted asynchronously through\n `SPINEL_PROP_MESHCOP_COMMISSIONER_PAN_ID_CONFLICT_RESULT` updates.\n\n Format is:\n\n   `S` : PAN ID to query\n   `L` : Channel mask\n   `6` : IPv6 destination\n"]
pub const SPINEL_PROP_MESHCOP_COMMISSIONER_PAN_ID_QUERY: _bindgen_ty_24 = 6147;
#[doc = " Format `SL` - Asynchronous event only\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n\n This property provides asynchronous `CMD_PROP_VALUE_INSERTED` updates to report PAN ID conflict results for a\n previously sent PAN ID Query message (please see `SPINEL_PROP_MESHCOP_COMMISSIONER_PAN_ID_QUERY`).\n\n Format is:\n\n   `S` : The PAN ID\n   `L` : Channel mask\n"]
pub const SPINEL_PROP_MESHCOP_COMMISSIONER_PAN_ID_CONFLICT_RESULT: _bindgen_ty_24 = 6148;
#[doc = " Format `d` - Write only\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n\n Writing to this property sends a MGMT_COMMISSIONER_GET message with the specified parameters. Response is a\n `LAST_STATUS` with status of operation.\n\n Format is:\n\n   `d` : List of TLV types to get\n"]
pub const SPINEL_PROP_MESHCOP_COMMISSIONER_MGMT_GET: _bindgen_ty_24 = 6149;
#[doc = " Format `d` - Write only\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n\n Writing to this property sends a MGMT_COMMISSIONER_SET message with the specified parameters. Response is a\n `LAST_STATUS` with status of operation.\n\n Format is:\n\n   `d` : TLV encoded data\n"]
pub const SPINEL_PROP_MESHCOP_COMMISSIONER_MGMT_SET: _bindgen_ty_24 = 6150;
#[doc = " Format: `UUd` - Write only\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n\n Writing to this property allows user to generate PSKc from a given commissioning pass-phrase, network name,\n extended PAN Id.\n\n Written value format is:\n\n   `U` : The commissioning pass-phrase.\n   `U` : Network Name.\n   `d` : Extended PAN ID.\n\n The response on success would be a `VALUE_IS` command with the PSKc with format below:\n\n   `D` : The PSKc\n\n On a failure a `LAST_STATUS` is emitted with the error status.\n"]
pub const SPINEL_PROP_MESHCOP_COMMISSIONER_GENERATE_PSKC: _bindgen_ty_24 = 6151;
#[doc = " Format: `UUd` - Write only\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n\n Writing to this property allows user to generate PSKc from a given commissioning pass-phrase, network name,\n extended PAN Id.\n\n Written value format is:\n\n   `U` : The commissioning pass-phrase.\n   `U` : Network Name.\n   `d` : Extended PAN ID.\n\n The response on success would be a `VALUE_IS` command with the PSKc with format below:\n\n   `D` : The PSKc\n\n On a failure a `LAST_STATUS` is emitted with the error status.\n"]
pub const SPINEL_PROP_MESHCOP_EXT__END: _bindgen_ty_24 = 6400;
#[doc = " Format: `UUd` - Write only\n\n Required capability: SPINEL_CAP_THREAD_COMMISSIONER\n\n Writing to this property allows user to generate PSKc from a given commissioning pass-phrase, network name,\n extended PAN Id.\n\n Written value format is:\n\n   `U` : The commissioning pass-phrase.\n   `U` : Network Name.\n   `d` : Extended PAN ID.\n\n The response on success would be a `VALUE_IS` command with the PSKc with format below:\n\n   `D` : The PSKc\n\n On a failure a `LAST_STATUS` is emitted with the error status.\n"]
pub const SPINEL_PROP_OPENTHREAD__BEGIN: _bindgen_ty_24 = 6400;
#[doc = " Channel Manager - Channel Change New Channel\n** Format: `C` (read-write)\n*\n* Required capability: SPINEL_CAP_CHANNEL_MANAGER\n*\n* Setting this property triggers the Channel Manager to start\n* a channel change process. The network switches to the given\n* channel after the specified delay (see `CHANNEL_MANAGER_DELAY`).\n*\n* A subsequent write to this property will cancel an ongoing\n* (previously requested) channel change.\n*\n*/"]
pub const SPINEL_PROP_CHANNEL_MANAGER_NEW_CHANNEL: _bindgen_ty_24 = 6400;
#[doc = " Channel Manager - Channel Change Delay\n** Format 'S'\n*  Units: seconds\n*\n* Required capability: SPINEL_CAP_CHANNEL_MANAGER\n*\n* This property specifies the delay (in seconds) to be used for\n* a channel change request.\n*\n* The delay should preferably be longer than maximum data poll\n* interval used by all sleepy-end-devices within the Thread\n* network.\n*\n*/"]
pub const SPINEL_PROP_CHANNEL_MANAGER_DELAY: _bindgen_ty_24 = 6401;
#[doc = " Channel Manager Supported Channels\n** Format 'A(C)'\n*\n* Required capability: SPINEL_CAP_CHANNEL_MANAGER\n*\n* This property specifies the list of supported channels.\n*\n*/"]
pub const SPINEL_PROP_CHANNEL_MANAGER_SUPPORTED_CHANNELS: _bindgen_ty_24 = 6402;
#[doc = " Channel Manager Favored Channels\n** Format 'A(C)'\n*\n* Required capability: SPINEL_CAP_CHANNEL_MANAGER\n*\n* This property specifies the list of favored channels (when `ChannelManager` is asked to select channel)\n*\n*/"]
pub const SPINEL_PROP_CHANNEL_MANAGER_FAVORED_CHANNELS: _bindgen_ty_24 = 6403;
#[doc = " Channel Manager Channel Select Trigger\n** Format 'b'\n*\n* Required capability: SPINEL_CAP_CHANNEL_MANAGER\n*\n* Writing to this property triggers a request on `ChannelManager` to select a new channel.\n*\n* Once a Channel Select is triggered, the Channel Manager will perform the following 3 steps:\n*\n* 1) `ChannelManager` decides if the channel change would be helpful. This check can be skipped if in the input\n*    boolean to this property is set to `true` (skipping the quality check).\n*    This step uses the collected link quality metrics on the device such as CCA failure rate, frame and message\n*    error rates per neighbor, etc. to determine if the current channel quality is at the level that justifies\n*    a channel change.\n*\n* 2) If first step passes, then `ChannelManager` selects a potentially better channel. It uses the collected\n*    channel quality data by `ChannelMonitor` module. The supported and favored channels are used at this step.\n*\n* 3) If the newly selected channel is different from the current channel, `ChannelManager` requests/starts the\n*    channel change process.\n*\n* Reading this property always yields `false`.\n*\n*/"]
pub const SPINEL_PROP_CHANNEL_MANAGER_CHANNEL_SELECT: _bindgen_ty_24 = 6404;
#[doc = " Channel Manager Auto Channel Selection Enabled\n** Format 'b'\n*\n* Required capability: SPINEL_CAP_CHANNEL_MANAGER\n*\n* This property indicates if auto-channel-selection functionality is enabled/disabled on `ChannelManager`.\n*\n* When enabled, `ChannelManager` will periodically checks and attempts to select a new channel. The period interval\n* is specified by `SPINEL_PROP_CHANNEL_MANAGER_AUTO_SELECT_INTERVAL`.\n*\n*/"]
pub const SPINEL_PROP_CHANNEL_MANAGER_AUTO_SELECT_ENABLED: _bindgen_ty_24 = 6405;
#[doc = " Channel Manager Auto Channel Selection Interval\n** Format 'L'\n*  units: seconds\n*\n* Required capability: SPINEL_CAP_CHANNEL_MANAGER\n*\n* This property specifies the auto-channel-selection check interval (in seconds).\n*\n*/"]
pub const SPINEL_PROP_CHANNEL_MANAGER_AUTO_SELECT_INTERVAL: _bindgen_ty_24 = 6406;
#[doc = " Thread network time.\n** Format: `Xc` - Read only\n*\n* Data per item is:\n*\n*  `X`: The Thread network time, in microseconds.\n*  `c`: Time synchronization status.\n*\n*/"]
pub const SPINEL_PROP_THREAD_NETWORK_TIME: _bindgen_ty_24 = 6407;
#[doc = " Thread time synchronization period\n** Format: `S` - Read-Write\n*\n* Data per item is:\n*\n*  `S`: Time synchronization period, in seconds.\n*\n*/"]
pub const SPINEL_PROP_TIME_SYNC_PERIOD: _bindgen_ty_24 = 6408;
#[doc = " Thread Time synchronization XTAL accuracy threshold for Router\n** Format: `S` - Read-Write\n*\n* Data per item is:\n*\n*  `S`: The XTAL accuracy threshold for Router, in PPM.\n*\n*/"]
pub const SPINEL_PROP_TIME_SYNC_XTAL_THRESHOLD: _bindgen_ty_24 = 6409;
#[doc = " Child Supervision Interval\n** Format: `S` - Read-Write\n*  Units: Seconds\n*\n* Required capability: `SPINEL_CAP_CHILD_SUPERVISION`\n*\n* The child supervision interval (in seconds). Zero indicates that child supervision is disabled.\n*\n* When enabled, Child supervision feature ensures that at least one message is sent to every sleepy child within\n* the given supervision interval. If there is no other message, a supervision message (a data message with empty\n* payload) is enqueued and sent to the child.\n*\n* This property is available for FTD build only.\n*\n*/"]
pub const SPINEL_PROP_CHILD_SUPERVISION_INTERVAL: _bindgen_ty_24 = 6410;
#[doc = " Child Supervision Check Timeout\n** Format: `S` - Read-Write\n*  Units: Seconds\n*\n* Required capability: `SPINEL_CAP_CHILD_SUPERVISION`\n*\n* The child supervision check timeout interval (in seconds). Zero indicates supervision check on the child is\n* disabled.\n*\n* Supervision check is only applicable on a sleepy child. When enabled, if the child does not hear from its parent\n* within the specified check timeout, it initiates a re-attach process by starting an MLE Child Update\n* Request/Response exchange with the parent.\n*\n* This property is available for FTD and MTD builds.\n*\n*/"]
pub const SPINEL_PROP_CHILD_SUPERVISION_CHECK_TIMEOUT: _bindgen_ty_24 = 6411;
#[doc = " Format `U` - Read only\n\n Required capability: SPINEL_CAP_POSIX\n\n This property gives the version string of RCP (NCP in radio mode) which is being controlled by a POSIX\n application. It is available only in \"POSIX\" platform (i.e., `OPENTHREAD_PLATFORM_POSIX` is enabled).\n"]
pub const SPINEL_PROP_RCP_VERSION: _bindgen_ty_24 = 6412;
#[doc = " Thread Parent Response info\n** Format: `ESccCCCb` - Asynchronous event only\n*\n*  `E`: Extended address\n*  `S`: RLOC16\n*  `c`: Instant RSSI\n*  'c': Parent Priority\n*  `C`: Link Quality3\n*  `C`: Link Quality2\n*  `C`: Link Quality1\n*  'b': Is the node receiving parent response frame attached\n*\n* This property sends Parent Response frame information to the Host.\n* This property is available for FTD build only.\n*\n*/"]
pub const SPINEL_PROP_PARENT_RESPONSE_INFO: _bindgen_ty_24 = 6413;
#[doc = " SLAAC enabled\n** Format `b` - Read-Write\n*  Required capability: `SPINEL_CAP_SLAAC`\n*\n* This property allows the host to enable/disable SLAAC module on NCP at run-time. When SLAAC module is enabled,\n* SLAAC addresses (based on on-mesh prefixes in Network Data) are added to the interface. When SLAAC module is\n* disabled any previously added SLAAC address is removed.\n*\n*/"]
pub const SPINEL_PROP_SLAAC_ENABLED: _bindgen_ty_24 = 6414;
#[doc = " Format `A(i)` - Read only\n\n This property returns list of supported radio links by the device itself. Enumeration `SPINEL_RADIO_LINK_{TYPE}`\n values indicate different radio link types.\n"]
pub const SPINEL_PROP_SUPPORTED_RADIO_LINKS: _bindgen_ty_24 = 6415;
#[doc = " Neighbor Table Multi Radio Link Info\n** Format: `A(t(ESA(t(iC))))` - Read only\n* Required capability: `SPINEL_CAP_MULTI_RADIO`.\n*\n* Each item represents info about a neighbor:\n*\n*  `E`: Neighbor's Extended Address\n*  `S`: Neighbor's RLOC16\n*\n*  This is then followed by an array of radio link info structures indicating which radio links are supported by\n*  the neighbor:\n*\n*    `i` : Radio link type (enumeration `SPINEL_RADIO_LINK_{TYPE}`).\n*    `C` : Preference value associated with radio link.\n*\n*/"]
pub const SPINEL_PROP_NEIGHBOR_TABLE_MULTI_RADIO_INFO: _bindgen_ty_24 = 6416;
#[doc = " SRP Client Start\n** Format: `b(6Sb)` - Write only\n* Required capability: `SPINEL_CAP_SRP_CLIENT`.\n*\n* Writing to this property allows user to start or stop the SRP client operation with a given SRP server.\n*\n* Written value format is:\n*\n*   `b` : TRUE to start the client, FALSE to stop the client.\n*\n* When used to start the SRP client, the following fields should also be included:\n*\n*   `6` : SRP server IPv6 address.\n*   `U` : SRP server port number.\n*   `b` : Boolean to indicate whether or not to emit SRP client events (using `SPINEL_PROP_SRP_CLIENT_EVENT`).\n*\n*/"]
pub const SPINEL_PROP_SRP_CLIENT_START: _bindgen_ty_24 = 6417;
#[doc = " SRP Client Lease Interval\n** Format: `L` - Read/Write\n* Required capability: `SPINEL_CAP_SRP_CLIENT`.\n*\n* The lease interval used in SRP update requests (in seconds).\n*\n*/"]
pub const SPINEL_PROP_SRP_CLIENT_LEASE_INTERVAL: _bindgen_ty_24 = 6418;
#[doc = " SRP Client Key Lease Interval\n** Format: `L` - Read/Write\n* Required capability: `SPINEL_CAP_SRP_CLIENT`.\n*\n* The key lease interval used in SRP update requests (in seconds).\n*\n*/"]
pub const SPINEL_PROP_SRP_CLIENT_KEY_LEASE_INTERVAL: _bindgen_ty_24 = 6419;
#[doc = " SRP Client Host Info\n** Format: `UCt(A(6))` - Read only\n* Required capability: `SPINEL_CAP_SRP_CLIENT`.\n*\n* Format is:\n*\n*   `U`       : The host name.\n*   `C`       : The host state (values from `spinel_srp_client_item_state_t`).\n*   `t(A(6))` : Structure containing array of host IPv6 addresses.\n*\n*/"]
pub const SPINEL_PROP_SRP_CLIENT_HOST_INFO: _bindgen_ty_24 = 6420;
#[doc = " SRP Client Host Name (label).\n** Format: `U` - Read/Write\n* Required capability: `SPINEL_CAP_SRP_CLIENT`.\n*\n*/"]
pub const SPINEL_PROP_SRP_CLIENT_HOST_NAME: _bindgen_ty_24 = 6421;
#[doc = " SRP Client Host Addresses\n** Format: `A(6)` - Read/Write\n* Required capability: `SPINEL_CAP_SRP_CLIENT`.\n*\n*/"]
pub const SPINEL_PROP_SRP_CLIENT_HOST_ADDRESSES: _bindgen_ty_24 = 6422;
#[doc = " SRP Client Services\n** Format: `A(t(UUSSSd))` - Read/Insert/Remove\n* Required capability: `SPINEL_CAP_SRP_CLIENT`.\n*\n* This property provides a list/array of services.\n*\n* Data per item for `SPINEL_CMD_PROP_VALUE_GET` and/or `SPINEL_CMD_PROP_VALUE_INSERT` operation is as follows:\n*\n*   `U` : The service name labels (e.g., \"_chip._udp\", not the full domain name.\n*   `U` : The service instance name label (not the full name).\n*   `S` : The service port number.\n*   `S` : The service priority.\n*   `S` : The service weight.\n*\n* For `SPINEL_CMD_PROP_VALUE_REMOVE` command, the following format is used:\n*\n*   `U` : The service name labels (e.g., \"_chip._udp\", not the full domain name.\n*   `U` : The service instance name label (not the full name).\n*   `b` : Indicates whether to clear the service entry (optional).\n*\n* The last boolean (`b`) field is optional. When included it indicates on `true` to clear the service (clear it\n* on client immediately with no interaction to server) and on `false` to remove the service (inform server and\n* wait for the service entry to be removed on server). If it is not included, the value is `false`.\n*\n*/"]
pub const SPINEL_PROP_SRP_CLIENT_SERVICES: _bindgen_ty_24 = 6423;
#[doc = " SRP Client Host And Services Remove\n** Format: `bb` : Write only\n* Required capability: `SPINEL_CAP_SRP_CLIENT`.\n*\n* Writing to this property with starts the remove process of the host info and all services.\n* Please see `otSrpClientRemoveHostAndServices()` for more details.\n*\n* Format is:\n*\n*    `b` : A boolean indicating whether or not the host key lease should also be cleared.\n*    `b` : A boolean indicating whether or not to send update to server when host info is not registered.\n*\n*/"]
pub const SPINEL_PROP_SRP_CLIENT_HOST_SERVICES_REMOVE: _bindgen_ty_24 = 6424;
#[doc = " SRP Client Host And Services Clear\n** Format: Empty : Write only\n* Required capability: `SPINEL_CAP_SRP_CLIENT`.\n*\n* Writing to this property clears all host info and all the services.\n* Please see `otSrpClientClearHostAndServices()` for more details.\n*\n*/"]
pub const SPINEL_PROP_SRP_CLIENT_HOST_SERVICES_CLEAR: _bindgen_ty_24 = 6425;
#[doc = " SRP Client Event\n** Format: t() : Asynchronous event only\n* Required capability: `SPINEL_CAP_SRP_CLIENT`.\n*\n* This property is asynchronously emitted when there is an event from SRP client notifying some state changes or\n* errors.\n*\n* The general format of this property is as follows:\n*\n*    `S` : Error code (see `spinel_srp_client_error_t` enumeration).\n*    `d` : Host info data.\n*    `d` : Active services.\n*    `d` : Removed services.\n*\n* The host info data contains:\n*\n*   `U`       : The host name.\n*   `C`       : The host state (values from `spinel_srp_client_item_state_t`).\n*   `t(A(6))` : Structure containing array of host IPv6 addresses.\n*\n* The active or removed services data is an array of services `A(t(UUSSSd))` with each service format:\n*\n*   `U` : The service name labels (e.g., \"_chip._udp\", not the full domain name.\n*   `U` : The service instance name label (not the full name).\n*   `S` : The service port number.\n*   `S` : The service priority.\n*   `S` : The service weight.\n*   `d` : The encoded TXT-DATA.\n*\n*/"]
pub const SPINEL_PROP_SRP_CLIENT_EVENT: _bindgen_ty_24 = 6426;
#[doc = " SRP Client Service Key Inclusion Enabled\n** Format `b` : Read-Write\n* Required capability: `SPINEL_CAP_SRP_CLIENT` & `SPINEL_CAP_REFERENCE_DEVICE`.\n*\n* This boolean property indicates whether the \"service key record inclusion\" mode is enabled or not.\n*\n* When enabled, SRP client will include KEY record in Service Description Instructions in the SRP update messages\n* that it sends.\n*\n* KEY record is optional in Service Description Instruction (it is required and always included in the Host\n* Description Instruction). The default behavior of SRP client is to not include it. This function is intended to\n* override the default behavior for testing only.\n*\n*/"]
pub const SPINEL_PROP_SRP_CLIENT_SERVICE_KEY_ENABLED: _bindgen_ty_24 = 6427;
#[doc = " SRP Client Service Key Inclusion Enabled\n** Format `b` : Read-Write\n* Required capability: `SPINEL_CAP_SRP_CLIENT` & `SPINEL_CAP_REFERENCE_DEVICE`.\n*\n* This boolean property indicates whether the \"service key record inclusion\" mode is enabled or not.\n*\n* When enabled, SRP client will include KEY record in Service Description Instructions in the SRP update messages\n* that it sends.\n*\n* KEY record is optional in Service Description Instruction (it is required and always included in the Host\n* Description Instruction). The default behavior of SRP client is to not include it. This function is intended to\n* override the default behavior for testing only.\n*\n*/"]
pub const SPINEL_PROP_OPENTHREAD__END: _bindgen_ty_24 = 8192;
#[doc = " SRP Client Service Key Inclusion Enabled\n** Format `b` : Read-Write\n* Required capability: `SPINEL_CAP_SRP_CLIENT` & `SPINEL_CAP_REFERENCE_DEVICE`.\n*\n* This boolean property indicates whether the \"service key record inclusion\" mode is enabled or not.\n*\n* When enabled, SRP client will include KEY record in Service Description Instructions in the SRP update messages\n* that it sends.\n*\n* KEY record is optional in Service Description Instruction (it is required and always included in the Host\n* Description Instruction). The default behavior of SRP client is to not include it. This function is intended to\n* override the default behavior for testing only.\n*\n*/"]
pub const SPINEL_PROP_SERVER__BEGIN: _bindgen_ty_24 = 160;
#[doc = " Server Allow Local Network Data Change\n** Format `b` - Read-write\n*\n* Required capability: SPINEL_CAP_THREAD_SERVICE\n*\n* Set to true before changing local server net data. Set to false when finished.\n* This allows changes to be aggregated into a single event.\n*\n*/"]
pub const SPINEL_PROP_SERVER_ALLOW_LOCAL_DATA_CHANGE: _bindgen_ty_24 = 160;
#[doc = " Format: `A(t(LdbdS))`\n\n This property provides all services registered on the device\n\n Required capability: SPINEL_CAP_THREAD_SERVICE\n\n Array of structures containing:\n\n  `L`: Enterprise Number\n  `d`: Service Data\n  `b`: Stable\n  `d`: Server Data\n  `S`: RLOC\n"]
pub const SPINEL_PROP_SERVER_SERVICES: _bindgen_ty_24 = 161;
#[doc = " Format: `A(t(CLdbdS))`\n\n This property provides all services registered on the leader\n\n Array of structures containing:\n\n  `C`: Service ID\n  `L`: Enterprise Number\n  `d`: Service Data\n  `b`: Stable\n  `d`: Server Data\n  `S`: RLOC\n"]
pub const SPINEL_PROP_SERVER_LEADER_SERVICES: _bindgen_ty_24 = 162;
#[doc = " Format: `A(t(CLdbdS))`\n\n This property provides all services registered on the leader\n\n Array of structures containing:\n\n  `C`: Service ID\n  `L`: Enterprise Number\n  `d`: Service Data\n  `b`: Stable\n  `d`: Server Data\n  `S`: RLOC\n"]
pub const SPINEL_PROP_SERVER__END: _bindgen_ty_24 = 176;
#[doc = " Format: `A(t(CLdbdS))`\n\n This property provides all services registered on the leader\n\n Array of structures containing:\n\n  `C`: Service ID\n  `L`: Enterprise Number\n  `d`: Service Data\n  `b`: Stable\n  `d`: Server Data\n  `S`: RLOC\n"]
pub const SPINEL_PROP_RCP__BEGIN: _bindgen_ty_24 = 176;
#[doc = " RCP API Version number\n** Format: `i` (read-only)\n*\n* Required capability: SPINEL_CAP_RADIO and SPINEL_CAP_RCP_API_VERSION.\n*\n* This property gives the RCP API Version number.\n*\n* Please see \"Spinel definition compatibility guideline\" section.\n*\n*/"]
pub const SPINEL_PROP_RCP_API_VERSION: _bindgen_ty_24 = 176;
#[doc = " Min host RCP API Version number\n** Format: `i` (read-only)\n*\n* Required capability: SPINEL_CAP_RADIO and SPINEL_CAP_RCP_MIN_HOST_API_VERSION.\n*\n* This property gives the minimum host RCP API Version number.\n*\n* Please see \"Spinel definition compatibility guideline\" section.\n*\n*/"]
pub const SPINEL_PROP_RCP_MIN_HOST_API_VERSION: _bindgen_ty_24 = 177;
#[doc = " Min host RCP API Version number\n** Format: `i` (read-only)\n*\n* Required capability: SPINEL_CAP_RADIO and SPINEL_CAP_RCP_MIN_HOST_API_VERSION.\n*\n* This property gives the minimum host RCP API Version number.\n*\n* Please see \"Spinel definition compatibility guideline\" section.\n*\n*/"]
pub const SPINEL_PROP_RCP__END: _bindgen_ty_24 = 255;
#[doc = " Min host RCP API Version number\n** Format: `i` (read-only)\n*\n* Required capability: SPINEL_CAP_RADIO and SPINEL_CAP_RCP_MIN_HOST_API_VERSION.\n*\n* This property gives the minimum host RCP API Version number.\n*\n* Please see \"Spinel definition compatibility guideline\" section.\n*\n*/"]
pub const SPINEL_PROP_INTERFACE__BEGIN: _bindgen_ty_24 = 256;
#[doc = " UART Bitrate\n** Format: `L`\n*\n*  If the NCP is using a UART to communicate with the host,\n*  this property allows the host to change the bitrate\n*  of the serial connection. The value encoding is `L`,\n*  which is a little-endian 32-bit unsigned integer.\n*  The host should not assume that all possible numeric values\n*  are supported.\n*\n*  If implemented by the NCP, this property should be persistent\n*  across software resets and forgotten upon hardware resets.\n*\n*  This property is only implemented when a UART is being\n*  used for Spinel. This property is optional.\n*\n*  When changing the bitrate, all frames will be received\n*  at the previous bitrate until the response frame to this command\n*  is received. Once a successful response frame is received by\n*  the host, all further frames will be transmitted at the new\n*  bitrate.\n*/"]
pub const SPINEL_PROP_UART_BITRATE: _bindgen_ty_24 = 256;
#[doc = " UART Software Flow Control\n** Format: `b`\n*\n*  If the NCP is using a UART to communicate with the host,\n*  this property allows the host to determine if software flow\n*  control (XON/XOFF style) should be used and (optionally) to\n*  turn it on or off.\n*\n*  This property is only implemented when a UART is being\n*  used for Spinel. This property is optional.\n*/"]
pub const SPINEL_PROP_UART_XON_XOFF: _bindgen_ty_24 = 257;
#[doc = " UART Software Flow Control\n** Format: `b`\n*\n*  If the NCP is using a UART to communicate with the host,\n*  this property allows the host to determine if software flow\n*  control (XON/XOFF style) should be used and (optionally) to\n*  turn it on or off.\n*\n*  This property is only implemented when a UART is being\n*  used for Spinel. This property is optional.\n*/"]
pub const SPINEL_PROP_INTERFACE__END: _bindgen_ty_24 = 512;
#[doc = " UART Software Flow Control\n** Format: `b`\n*\n*  If the NCP is using a UART to communicate with the host,\n*  this property allows the host to determine if software flow\n*  control (XON/XOFF style) should be used and (optionally) to\n*  turn it on or off.\n*\n*  This property is only implemented when a UART is being\n*  used for Spinel. This property is optional.\n*/"]
pub const SPINEL_PROP_15_4_PIB__BEGIN: _bindgen_ty_24 = 1024;
#[doc = "< [A(L)]"]
pub const SPINEL_PROP_15_4_PIB_PHY_CHANNELS_SUPPORTED: _bindgen_ty_24 = 1025;
#[doc = "< [b]"]
pub const SPINEL_PROP_15_4_PIB_MAC_PROMISCUOUS_MODE: _bindgen_ty_24 = 1105;
#[doc = "< [b]"]
pub const SPINEL_PROP_15_4_PIB_MAC_SECURITY_ENABLED: _bindgen_ty_24 = 1117;
pub const SPINEL_PROP_15_4_PIB__END: _bindgen_ty_24 = 1280;
pub const SPINEL_PROP_CNTR__BEGIN: _bindgen_ty_24 = 1280;
#[doc = " Counter reset\n** Format: Empty (Write only).\n*\n* Writing to this property (with any value) will reset all MAC, MLE, IP, and NCP counters to zero.\n*\n*/"]
pub const SPINEL_PROP_CNTR_RESET: _bindgen_ty_24 = 1280;
#[doc = " The total number of transmissions.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_PKT_TOTAL: _bindgen_ty_24 = 1281;
#[doc = " The number of transmissions with ack request.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_PKT_ACK_REQ: _bindgen_ty_24 = 1282;
#[doc = " The number of transmissions that were acked.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_PKT_ACKED: _bindgen_ty_24 = 1283;
#[doc = " The number of transmissions without ack request.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_PKT_NO_ACK_REQ: _bindgen_ty_24 = 1284;
#[doc = " The number of transmitted data.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_PKT_DATA: _bindgen_ty_24 = 1285;
#[doc = " The number of transmitted data poll.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_PKT_DATA_POLL: _bindgen_ty_24 = 1286;
#[doc = " The number of transmitted beacon.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_PKT_BEACON: _bindgen_ty_24 = 1287;
#[doc = " The number of transmitted beacon request.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_PKT_BEACON_REQ: _bindgen_ty_24 = 1288;
#[doc = " The number of transmitted other types of frames.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_PKT_OTHER: _bindgen_ty_24 = 1289;
#[doc = " The number of retransmission times.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_PKT_RETRY: _bindgen_ty_24 = 1290;
#[doc = " The number of CCA failure times.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_ERR_CCA: _bindgen_ty_24 = 1291;
#[doc = " The number of unicast packets transmitted.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_PKT_UNICAST: _bindgen_ty_24 = 1292;
#[doc = " The number of broadcast packets transmitted.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_PKT_BROADCAST: _bindgen_ty_24 = 1293;
#[doc = " The number of frame transmission failures due to abort error.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_ERR_ABORT: _bindgen_ty_24 = 1294;
#[doc = " The total number of received packets.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_PKT_TOTAL: _bindgen_ty_24 = 1380;
#[doc = " The number of received data.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_PKT_DATA: _bindgen_ty_24 = 1381;
#[doc = " The number of received data poll.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_PKT_DATA_POLL: _bindgen_ty_24 = 1382;
#[doc = " The number of received beacon.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_PKT_BEACON: _bindgen_ty_24 = 1383;
#[doc = " The number of received beacon request.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_PKT_BEACON_REQ: _bindgen_ty_24 = 1384;
#[doc = " The number of received other types of frames.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_PKT_OTHER: _bindgen_ty_24 = 1385;
#[doc = " The number of received packets filtered by allowlist.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_PKT_FILT_WL: _bindgen_ty_24 = 1386;
#[doc = " The number of received packets filtered by destination check.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_PKT_FILT_DA: _bindgen_ty_24 = 1387;
#[doc = " The number of received packets that are empty.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_ERR_EMPTY: _bindgen_ty_24 = 1388;
#[doc = " The number of received packets from an unknown neighbor.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_ERR_UKWN_NBR: _bindgen_ty_24 = 1389;
#[doc = " The number of received packets whose source address is invalid.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_ERR_NVLD_SADDR: _bindgen_ty_24 = 1390;
#[doc = " The number of received packets with a security error.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_ERR_SECURITY: _bindgen_ty_24 = 1391;
#[doc = " The number of received packets with a checksum error.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_ERR_BAD_FCS: _bindgen_ty_24 = 1392;
#[doc = " The number of received packets with other errors.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_ERR_OTHER: _bindgen_ty_24 = 1393;
#[doc = " The number of received duplicated.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_PKT_DUP: _bindgen_ty_24 = 1394;
#[doc = " The number of unicast packets received.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_PKT_UNICAST: _bindgen_ty_24 = 1395;
#[doc = " The number of broadcast packets received.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_PKT_BROADCAST: _bindgen_ty_24 = 1396;
#[doc = " The total number of secure transmitted IP messages.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_IP_SEC_TOTAL: _bindgen_ty_24 = 1480;
#[doc = " The total number of insecure transmitted IP messages.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_IP_INSEC_TOTAL: _bindgen_ty_24 = 1481;
#[doc = " The number of dropped (not transmitted) IP messages.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_IP_DROPPED: _bindgen_ty_24 = 1482;
#[doc = " The total number of secure received IP message.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_IP_SEC_TOTAL: _bindgen_ty_24 = 1483;
#[doc = " The total number of insecure received IP message.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_IP_INSEC_TOTAL: _bindgen_ty_24 = 1484;
#[doc = " The number of dropped received IP messages.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_IP_DROPPED: _bindgen_ty_24 = 1485;
#[doc = " The number of transmitted spinel frames.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_TX_SPINEL_TOTAL: _bindgen_ty_24 = 1580;
#[doc = " The number of received spinel frames.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_SPINEL_TOTAL: _bindgen_ty_24 = 1581;
#[doc = " The number of received spinel frames with error.\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_SPINEL_ERR: _bindgen_ty_24 = 1582;
#[doc = " Number of out of order received spinel frames (tid increase by more than 1).\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_RX_SPINEL_OUT_OF_ORDER_TID: _bindgen_ty_24 = 1583;
#[doc = " The number of successful Tx IP packets\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_IP_TX_SUCCESS: _bindgen_ty_24 = 1584;
#[doc = " The number of successful Rx IP packets\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_IP_RX_SUCCESS: _bindgen_ty_24 = 1585;
#[doc = " The number of failed Tx IP packets\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_IP_TX_FAILURE: _bindgen_ty_24 = 1586;
#[doc = " The number of failed Rx IP packets\n** Format: `L` (Read-only) */"]
pub const SPINEL_PROP_CNTR_IP_RX_FAILURE: _bindgen_ty_24 = 1587;
#[doc = " The message buffer counter info\n** Format: `SSSSSSSSSSSSSSSS` (Read-only)\n*      `S`, (TotalBuffers)           The number of buffers in the pool.\n*      `S`, (FreeBuffers)            The number of free message buffers.\n*      `S`, (6loSendMessages)        The number of messages in the 6lo send queue.\n*      `S`, (6loSendBuffers)         The number of buffers in the 6lo send queue.\n*      `S`, (6loReassemblyMessages)  The number of messages in the 6LoWPAN reassembly queue.\n*      `S`, (6loReassemblyBuffers)   The number of buffers in the 6LoWPAN reassembly queue.\n*      `S`, (Ip6Messages)            The number of messages in the IPv6 send queue.\n*      `S`, (Ip6Buffers)             The number of buffers in the IPv6 send queue.\n*      `S`, (MplMessages)            The number of messages in the MPL send queue.\n*      `S`, (MplBuffers)             The number of buffers in the MPL send queue.\n*      `S`, (MleMessages)            The number of messages in the MLE send queue.\n*      `S`, (MleBuffers)             The number of buffers in the MLE send queue.\n*      `S`, (ArpMessages)            The number of messages in the ARP send queue.\n*      `S`, (ArpBuffers)             The number of buffers in the ARP send queue.\n*      `S`, (CoapMessages)           The number of messages in the CoAP send queue.\n*      `S`, (CoapBuffers)            The number of buffers in the CoAP send queue.\n*/"]
pub const SPINEL_PROP_MSG_BUFFER_COUNTERS: _bindgen_ty_24 = 1680;
#[doc = " All MAC related counters.\n** Format: t(A(L))t(A(L))\n*\n* The contents include two structs, first one corresponds to\n* all transmit related MAC counters, second one provides the\n* receive related counters.\n*\n* The transmit structure includes:\n*\n*   'L': TxTotal                  (The total number of transmissions).\n*   'L': TxUnicast                (The total number of unicast transmissions).\n*   'L': TxBroadcast              (The total number of broadcast transmissions).\n*   'L': TxAckRequested           (The number of transmissions with ack request).\n*   'L': TxAcked                  (The number of transmissions that were acked).\n*   'L': TxNoAckRequested         (The number of transmissions without ack request).\n*   'L': TxData                   (The number of transmitted data).\n*   'L': TxDataPoll               (The number of transmitted data poll).\n*   'L': TxBeacon                 (The number of transmitted beacon).\n*   'L': TxBeaconRequest          (The number of transmitted beacon request).\n*   'L': TxOther                  (The number of transmitted other types of frames).\n*   'L': TxRetry                  (The number of retransmission times).\n*   'L': TxErrCca                 (The number of CCA failure times).\n*   'L': TxErrAbort               (The number of frame transmission failures due to abort error).\n*   'L': TxErrBusyChannel         (The number of frames that were dropped due to a busy channel).\n*   'L': TxDirectMaxRetryExpiry   (The number of expired retransmission retries for direct message).\n*   'L': TxIndirectMaxRetryExpiry (The number of expired retransmission retries for indirect message).\n*\n* The receive structure includes:\n*\n*   'L': RxTotal                  (The total number of received packets).\n*   'L': RxUnicast                (The total number of unicast packets received).\n*   'L': RxBroadcast              (The total number of broadcast packets received).\n*   'L': RxData                   (The number of received data).\n*   'L': RxDataPoll               (The number of received data poll).\n*   'L': RxBeacon                 (The number of received beacon).\n*   'L': RxBeaconRequest          (The number of received beacon request).\n*   'L': RxOther                  (The number of received other types of frames).\n*   'L': RxAddressFiltered        (The number of received packets filtered by address filter\n*                                  (allowlist or denylist)).\n*   'L': RxDestAddrFiltered       (The number of received packets filtered by destination check).\n*   'L': RxDuplicated             (The number of received duplicated packets).\n*   'L': RxErrNoFrame             (The number of received packets with no or malformed content).\n*   'L': RxErrUnknownNeighbor     (The number of received packets from unknown neighbor).\n*   'L': RxErrInvalidSrcAddr      (The number of received packets whose source address is invalid).\n*   'L': RxErrSec                 (The number of received packets with security error).\n*   'L': RxErrFcs                 (The number of received packets with FCS error).\n*   'L': RxErrOther               (The number of received packets with other error).\n*\n* Writing to this property with any value would reset all MAC counters to zero.\n*\n*/"]
pub const SPINEL_PROP_CNTR_ALL_MAC_COUNTERS: _bindgen_ty_24 = 1681;
#[doc = " Thread MLE counters.\n** Format: `SSSSSSSSS`\n*\n*   'S': DisabledRole                  (The number of times device entered OT_DEVICE_ROLE_DISABLED role).\n*   'S': DetachedRole                  (The number of times device entered OT_DEVICE_ROLE_DETACHED role).\n*   'S': ChildRole                     (The number of times device entered OT_DEVICE_ROLE_CHILD role).\n*   'S': RouterRole                    (The number of times device entered OT_DEVICE_ROLE_ROUTER role).\n*   'S': LeaderRole                    (The number of times device entered OT_DEVICE_ROLE_LEADER role).\n*   'S': AttachAttempts                (The number of attach attempts while device was detached).\n*   'S': PartitionIdChanges            (The number of changes to partition ID).\n*   'S': BetterPartitionAttachAttempts (The number of attempts to attach to a better partition).\n*   'S': ParentChanges                 (The number of times device changed its parents).\n*\n* Writing to this property with any value would reset all MLE counters to zero.\n*\n*/"]
pub const SPINEL_PROP_CNTR_MLE_COUNTERS: _bindgen_ty_24 = 1682;
#[doc = " Thread IPv6 counters.\n** Format: `t(LL)t(LL)`\n*\n* The contents include two structs, first one corresponds to\n* all transmit related MAC counters, second one provides the\n* receive related counters.\n*\n* The transmit structure includes:\n*   'L': TxSuccess (The number of IPv6 packets successfully transmitted).\n*   'L': TxFailure (The number of IPv6 packets failed to transmit).\n*\n* The receive structure includes:\n*   'L': RxSuccess (The number of IPv6 packets successfully received).\n*   'L': RxFailure (The number of IPv6 packets failed to receive).\n*\n* Writing to this property with any value would reset all IPv6 counters to zero.\n*\n*/"]
pub const SPINEL_PROP_CNTR_ALL_IP_COUNTERS: _bindgen_ty_24 = 1683;
#[doc = " MAC retry histogram.\n** Format: t(A(L))t(A(L))\n*\n* Required capability: SPINEL_CAP_MAC_RETRY_HISTOGRAM\n*\n* The contents include two structs, first one is histogram which corresponds to retransmissions number of direct\n* messages, second one provides the histogram of retransmissions for indirect messages.\n*\n* The first structure includes:\n*   'L': DirectRetry[0]                   (The number of packets after 0 retry).\n*   'L': DirectRetry[1]                   (The number of packets after 1 retry).\n*    ...\n*   'L': DirectRetry[n]                   (The number of packets after n retry).\n*\n* The size of the array is OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_MAX_SIZE_COUNT_DIRECT.\n*\n* The second structure includes:\n*   'L': IndirectRetry[0]                   (The number of packets after 0 retry).\n*   'L': IndirectRetry[1]                   (The number of packets after 1 retry).\n*    ...\n*   'L': IndirectRetry[m]                   (The number of packets after m retry).\n*\n* The size of the array is OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_MAX_SIZE_COUNT_INDIRECT.\n*\n* Writing to this property with any value would reset MAC retry histogram.\n*\n*/"]
pub const SPINEL_PROP_CNTR_MAC_RETRY_HISTOGRAM: _bindgen_ty_24 = 1684;
#[doc = " MAC retry histogram.\n** Format: t(A(L))t(A(L))\n*\n* Required capability: SPINEL_CAP_MAC_RETRY_HISTOGRAM\n*\n* The contents include two structs, first one is histogram which corresponds to retransmissions number of direct\n* messages, second one provides the histogram of retransmissions for indirect messages.\n*\n* The first structure includes:\n*   'L': DirectRetry[0]                   (The number of packets after 0 retry).\n*   'L': DirectRetry[1]                   (The number of packets after 1 retry).\n*    ...\n*   'L': DirectRetry[n]                   (The number of packets after n retry).\n*\n* The size of the array is OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_MAX_SIZE_COUNT_DIRECT.\n*\n* The second structure includes:\n*   'L': IndirectRetry[0]                   (The number of packets after 0 retry).\n*   'L': IndirectRetry[1]                   (The number of packets after 1 retry).\n*    ...\n*   'L': IndirectRetry[m]                   (The number of packets after m retry).\n*\n* The size of the array is OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_MAX_SIZE_COUNT_INDIRECT.\n*\n* Writing to this property with any value would reset MAC retry histogram.\n*\n*/"]
pub const SPINEL_PROP_CNTR__END: _bindgen_ty_24 = 2048;
#[doc = " MAC retry histogram.\n** Format: t(A(L))t(A(L))\n*\n* Required capability: SPINEL_CAP_MAC_RETRY_HISTOGRAM\n*\n* The contents include two structs, first one is histogram which corresponds to retransmissions number of direct\n* messages, second one provides the histogram of retransmissions for indirect messages.\n*\n* The first structure includes:\n*   'L': DirectRetry[0]                   (The number of packets after 0 retry).\n*   'L': DirectRetry[1]                   (The number of packets after 1 retry).\n*    ...\n*   'L': DirectRetry[n]                   (The number of packets after n retry).\n*\n* The size of the array is OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_MAX_SIZE_COUNT_DIRECT.\n*\n* The second structure includes:\n*   'L': IndirectRetry[0]                   (The number of packets after 0 retry).\n*   'L': IndirectRetry[1]                   (The number of packets after 1 retry).\n*    ...\n*   'L': IndirectRetry[m]                   (The number of packets after m retry).\n*\n* The size of the array is OPENTHREAD_CONFIG_MAC_RETRY_SUCCESS_HISTOGRAM_MAX_SIZE_COUNT_INDIRECT.\n*\n* Writing to this property with any value would reset MAC retry histogram.\n*\n*/"]
pub const SPINEL_PROP_RCP_EXT__BEGIN: _bindgen_ty_24 = 2048;
#[doc = " MAC Key\n** Format: `CCddd`.\n*\n*  `C`: MAC key ID mode\n*  `C`: MAC key ID\n*  `d`: previous MAC key material data\n*  `d`: current MAC key material data\n*  `d`: next MAC key material data\n*\n* The Spinel property is used to set/get MAC key materials to and from RCP.\n*\n*/"]
pub const SPINEL_PROP_RCP_MAC_KEY: _bindgen_ty_24 = 2048;
#[doc = " MAC Frame Counter\n** Format: `L` for read and `Lb` or `L` for write\n*\n*  `L`: MAC frame counter\n*  'b': Optional boolean used only during write. If not provided, `false` is assumed.\n*       If `true` counter is set only if the new value is larger than current value.\n*       If `false` the new value is set as frame counter independent of the current value.\n*\n* The Spinel property is used to set MAC frame counter to RCP.\n*\n*/"]
pub const SPINEL_PROP_RCP_MAC_FRAME_COUNTER: _bindgen_ty_24 = 2049;
#[doc = " Timestamps when Spinel frame is received and transmitted\n** Format: `X`.\n*\n*  `X`: Spinel frame transmit timestamp\n*\n* The Spinel property is used to get timestamp from RCP to calculate host and RCP timer difference.\n*\n*/"]
pub const SPINEL_PROP_RCP_TIMESTAMP: _bindgen_ty_24 = 2050;
#[doc = " Configure Enhanced ACK probing\n** Format: `SEC` (Write-only).\n*\n* `S`: Short address\n* `E`: Extended address\n* `C`: List of requested metric ids encoded as bit fields in single byte\n*\n*   +---------------+----+\n*   |    Metric     | Id |\n*   +---------------+----+\n*   | Received PDUs |  0 |\n*   | LQI           |  1 |\n*   | Link margin   |  2 |\n*   | RSSI          |  3 |\n*   +---------------+----+\n*\n* Enable/disable or update Enhanced-ACK Based Probing in radio for a specific Initiator.\n*\n*/"]
pub const SPINEL_PROP_RCP_ENH_ACK_PROBING: _bindgen_ty_24 = 2051;
#[doc = " CSL Accuracy\n** Format: `C`\n* Required capability: `SPINEL_CAP_NET_THREAD_1_2`\n*\n* The current CSL rx/tx scheduling drift, in units of ± ppm.\n*\n*/"]
pub const SPINEL_PROP_RCP_CSL_ACCURACY: _bindgen_ty_24 = 2052;
#[doc = " CSL Uncertainty\n** Format: `C`\n* Required capability: `SPINEL_CAP_NET_THREAD_1_2`\n*\n* The current uncertainty, in units of 10 us, of the clock used for scheduling CSL operations.\n*\n*/"]
pub const SPINEL_PROP_RCP_CSL_UNCERTAINTY: _bindgen_ty_24 = 2053;
#[doc = " CSL Uncertainty\n** Format: `C`\n* Required capability: `SPINEL_CAP_NET_THREAD_1_2`\n*\n* The current uncertainty, in units of 10 us, of the clock used for scheduling CSL operations.\n*\n*/"]
pub const SPINEL_PROP_RCP_EXT__END: _bindgen_ty_24 = 2304;
#[doc = " CSL Uncertainty\n** Format: `C`\n* Required capability: `SPINEL_CAP_NET_THREAD_1_2`\n*\n* The current uncertainty, in units of 10 us, of the clock used for scheduling CSL operations.\n*\n*/"]
pub const SPINEL_PROP_NEST__BEGIN: _bindgen_ty_24 = 15296;
#[doc = " CSL Uncertainty\n** Format: `C`\n* Required capability: `SPINEL_CAP_NET_THREAD_1_2`\n*\n* The current uncertainty, in units of 10 us, of the clock used for scheduling CSL operations.\n*\n*/"]
pub const SPINEL_PROP_NEST_STREAM_MFG: _bindgen_ty_24 = 15296;
#[doc = " The legacy network ULA prefix (8 bytes).\n** Format: 'D'\n*\n* This property is deprecated.\n*\n*/"]
pub const SPINEL_PROP_NEST_LEGACY_ULA_PREFIX: _bindgen_ty_24 = 15297;
#[doc = " The EUI64 of last node joined using legacy protocol (if none, all zero EUI64 is returned).\n** Format: 'E'\n*\n* This property is deprecated.\n*\n*/"]
pub const SPINEL_PROP_NEST_LEGACY_LAST_NODE_JOINED: _bindgen_ty_24 = 15298;
#[doc = " The EUI64 of last node joined using legacy protocol (if none, all zero EUI64 is returned).\n** Format: 'E'\n*\n* This property is deprecated.\n*\n*/"]
pub const SPINEL_PROP_NEST__END: _bindgen_ty_24 = 15360;
#[doc = " The EUI64 of last node joined using legacy protocol (if none, all zero EUI64 is returned).\n** Format: 'E'\n*\n* This property is deprecated.\n*\n*/"]
pub const SPINEL_PROP_VENDOR__BEGIN: _bindgen_ty_24 = 15360;
#[doc = " The EUI64 of last node joined using legacy protocol (if none, all zero EUI64 is returned).\n** Format: 'E'\n*\n* This property is deprecated.\n*\n*/"]
pub const SPINEL_PROP_VENDOR__END: _bindgen_ty_24 = 16384;
#[doc = " The EUI64 of last node joined using legacy protocol (if none, all zero EUI64 is returned).\n** Format: 'E'\n*\n* This property is deprecated.\n*\n*/"]
pub const SPINEL_PROP_VENDOR_ESP__BEGIN: _bindgen_ty_24 = 15360;
#[doc = " The EUI64 of last node joined using legacy protocol (if none, all zero EUI64 is returned).\n** Format: 'E'\n*\n* This property is deprecated.\n*\n*/"]
pub const SPINEL_PROP_VENDOR_ESP__END: _bindgen_ty_24 = 15488;
#[doc = " The EUI64 of last node joined using legacy protocol (if none, all zero EUI64 is returned).\n** Format: 'E'\n*\n* This property is deprecated.\n*\n*/"]
pub const SPINEL_PROP_DEBUG__BEGIN: _bindgen_ty_24 = 16384;
#[doc = " Testing platform assert\n** Format: 'b' (read-only)\n*\n* Reading this property will cause an assert on the NCP. This is intended for testing the assert functionality of\n* underlying platform/NCP. Assert should ideally cause the NCP to reset, but if this is not supported a `false`\n* boolean is returned in response.\n*\n*/"]
pub const SPINEL_PROP_DEBUG_TEST_ASSERT: _bindgen_ty_24 = 16384;
#[doc = " The NCP log level.\n** Format: `C` */"]
pub const SPINEL_PROP_DEBUG_NCP_LOG_LEVEL: _bindgen_ty_24 = 16385;
#[doc = " Testing platform watchdog\n** Format: Empty  (read-only)\n*\n* Reading this property will causes NCP to start a `while(true) ;` loop and thus triggering a watchdog.\n*\n* This is intended for testing the watchdog functionality on the underlying platform/NCP.\n*\n*/"]
pub const SPINEL_PROP_DEBUG_TEST_WATCHDOG: _bindgen_ty_24 = 16386;
#[doc = " The NCP timestamp base\n** Format: X (write-only)\n*\n* This property controls the time base value that is used for logs timestamp field calculation.\n*\n*/"]
pub const SPINEL_PROP_DEBUG_LOG_TIMESTAMP_BASE: _bindgen_ty_24 = 16387;
#[doc = " TREL Radio Link - test mode enable\n** Format `b` (read-write)\n*\n* This property is intended for testing TREL (Thread Radio Encapsulation Link) radio type only (during simulation).\n* It allows the TREL interface to be temporarily disabled and (re)enabled.  While disabled all traffic through\n* TREL interface is dropped silently (to emulate a radio/interface down scenario).\n*\n* This property is only available when the TREL radio link type is supported.\n*\n*/"]
pub const SPINEL_PROP_DEBUG_TREL_TEST_MODE_ENABLE: _bindgen_ty_24 = 16388;
#[doc = " TREL Radio Link - test mode enable\n** Format `b` (read-write)\n*\n* This property is intended for testing TREL (Thread Radio Encapsulation Link) radio type only (during simulation).\n* It allows the TREL interface to be temporarily disabled and (re)enabled.  While disabled all traffic through\n* TREL interface is dropped silently (to emulate a radio/interface down scenario).\n*\n* This property is only available when the TREL radio link type is supported.\n*\n*/"]
pub const SPINEL_PROP_DEBUG__END: _bindgen_ty_24 = 17408;
#[doc = " TREL Radio Link - test mode enable\n** Format `b` (read-write)\n*\n* This property is intended for testing TREL (Thread Radio Encapsulation Link) radio type only (during simulation).\n* It allows the TREL interface to be temporarily disabled and (re)enabled.  While disabled all traffic through\n* TREL interface is dropped silently (to emulate a radio/interface down scenario).\n*\n* This property is only available when the TREL radio link type is supported.\n*\n*/"]
pub const SPINEL_PROP_EXPERIMENTAL__BEGIN: _bindgen_ty_24 = 2000000;
#[doc = " TREL Radio Link - test mode enable\n** Format `b` (read-write)\n*\n* This property is intended for testing TREL (Thread Radio Encapsulation Link) radio type only (during simulation).\n* It allows the TREL interface to be temporarily disabled and (re)enabled.  While disabled all traffic through\n* TREL interface is dropped silently (to emulate a radio/interface down scenario).\n*\n* This property is only available when the TREL radio link type is supported.\n*\n*/"]
pub const SPINEL_PROP_EXPERIMENTAL__END: _bindgen_ty_24 = 2097152;
#[doc = " Property Keys\n\n The properties are broken up into several sections, each with a\n reserved ranges of property identifiers:\n\n    Name         | Range (Inclusive)              | Description\n    -------------|--------------------------------|------------------------\n    Core         | 0x000 - 0x01F, 0x1000 - 0x11FF | Spinel core\n    PHY          | 0x020 - 0x02F, 0x1200 - 0x12FF | Radio PHY layer\n    MAC          | 0x030 - 0x03F, 0x1300 - 0x13FF | MAC layer\n    NET          | 0x040 - 0x04F, 0x1400 - 0x14FF | Network\n    Thread       | 0x050 - 0x05F, 0x1500 - 0x15FF | Thread\n    IPv6         | 0x060 - 0x06F, 0x1600 - 0x16FF | IPv6\n    Stream       | 0x070 - 0x07F, 0x1700 - 0x17FF | Stream\n    MeshCop      | 0x080 - 0x08F, 0x1800 - 0x18FF | Thread Mesh Commissioning\n    OpenThread   |                0x1900 - 0x19FF | OpenThread specific\n    Server       | 0x0A0 - 0x0AF                  | ALOC Service Server\n    RCP          | 0x0B0 - 0x0FF                  | RCP specific\n    Interface    | 0x100 - 0x1FF                  | Interface (e.g., UART)\n    PIB          | 0x400 - 0x4FF                  | 802.15.4 PIB\n    Counter      | 0x500 - 0x7FF                  | Counters (MAC, IP, etc).\n    RCP          | 0x800 - 0x8FF                  | RCP specific property (extended)\n    Nest         |                0x3BC0 - 0x3BFF | Nest (legacy)\n    Vendor       |                0x3C00 - 0x3FFF | Vendor specific\n    Debug        |                0x4000 - 0x43FF | Debug related\n    Experimental |          2,000,000 - 2,097,151 | Experimental use only\n"]
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub const SPINEL_DATATYPE_NULL_C: _bindgen_ty_25 = 0;
pub const SPINEL_DATATYPE_VOID_C: _bindgen_ty_25 = 46;
pub const SPINEL_DATATYPE_BOOL_C: _bindgen_ty_25 = 98;
pub const SPINEL_DATATYPE_UINT8_C: _bindgen_ty_25 = 67;
pub const SPINEL_DATATYPE_INT8_C: _bindgen_ty_25 = 99;
pub const SPINEL_DATATYPE_UINT16_C: _bindgen_ty_25 = 83;
pub const SPINEL_DATATYPE_INT16_C: _bindgen_ty_25 = 115;
pub const SPINEL_DATATYPE_UINT32_C: _bindgen_ty_25 = 76;
pub const SPINEL_DATATYPE_INT32_C: _bindgen_ty_25 = 108;
pub const SPINEL_DATATYPE_UINT64_C: _bindgen_ty_25 = 88;
pub const SPINEL_DATATYPE_INT64_C: _bindgen_ty_25 = 120;
pub const SPINEL_DATATYPE_UINT_PACKED_C: _bindgen_ty_25 = 105;
pub const SPINEL_DATATYPE_IPv6ADDR_C: _bindgen_ty_25 = 54;
pub const SPINEL_DATATYPE_EUI64_C: _bindgen_ty_25 = 69;
pub const SPINEL_DATATYPE_EUI48_C: _bindgen_ty_25 = 101;
pub const SPINEL_DATATYPE_DATA_WLEN_C: _bindgen_ty_25 = 100;
pub const SPINEL_DATATYPE_DATA_C: _bindgen_ty_25 = 68;
#[doc = "!< Zero-Terminated UTF8-Encoded String"]
pub const SPINEL_DATATYPE_UTF8_C: _bindgen_ty_25 = 85;
pub const SPINEL_DATATYPE_STRUCT_C: _bindgen_ty_25 = 116;
pub const SPINEL_DATATYPE_ARRAY_C: _bindgen_ty_25 = 65;
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
