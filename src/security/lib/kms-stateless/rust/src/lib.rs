// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use {
    device_watcher::recursive_wait_and_open_node, fuchsia_async::TimeoutExt, futures::TryFutureExt,
    std::ffi::CStr,
};

/// Hardware derived key is expected to be a 128-bit AES key.
const DERIVED_KEY_SIZE: usize = 16;
const KEY_INFO_SIZE: usize = 32;
const DEV_CLASS_TEE: &'static str = "/dev/class/tee/000";

#[derive(Copy, Clone, Debug)]
pub enum TaKeysafeCommand {
    GetUserDataStorageKey = 8,
    RotateHardwareDerivedKey = 9,
}

/// Error values generated by this library
#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("tee command {0:?} failed: {1}")]
    TeeCommand(TaKeysafeCommand, u32),
    #[error("tee command {0:?} failed: not supported")]
    TeeCommandNotSupported(TaKeysafeCommand),
    #[error(
        "tee command {:?} failed: buffer with hardcoded size {} bytes was too small",
        .0,
        DERIVED_KEY_SIZE,
    )]
    TeeCommandBufferTooSmall(TaKeysafeCommand),
    #[error("failed to open dev directory")]
    DevDirectoryOpen(#[from] fuchsia_fs::node::OpenError),
    #[error("timeout waiting for tee device")]
    TeeDeviceWaitTimeout,
    #[error("failure waiting for tee device")]
    TeeDeviceWaitFailure(#[from] anyhow::Error),
}

/// The info used to identify a key.
pub struct KeyInfo {
    info: [u8; KEY_INFO_SIZE],
}

impl KeyInfo {
    /// Creates a new key info buffer using the provided string as the identifier.
    pub fn new(info: impl ToString) -> Self {
        Self::new_bytes(info.to_string().as_bytes())
    }

    /// Creates a new key info buffer using "zxcrypt" as the identifier.
    pub fn new_zxcrypt() -> Self {
        Self::new_bytes("zxcrypt".as_bytes())
    }

    fn new_bytes(info_bytes: &[u8]) -> Self {
        let mut info = [0; KEY_INFO_SIZE];
        // This will panic if the provided info is longer than 32 bytes, which is fine because
        // that's a programming error.
        info[..info_bytes.len()].copy_from_slice(info_bytes);
        Self { info }
    }
}

fn call_command(
    device: Option<&CStr>,
    op: &mut tee::TeecOperation,
    id: TaKeysafeCommand,
) -> Result<(), Error> {
    match device {
        Some(dev) => tee::call_command_on_device(dev, op, id as u32),
        None => tee::call_command(op, id as u32),
    }
    .map_err(|e| match e {
        tee::TEEC_ERROR_NOT_SUPPORTED => Error::TeeCommandNotSupported(id),
        tee::TEEC_ERROR_SHORT_BUFFER => Error::TeeCommandBufferTooSmall(id),
        e => Error::TeeCommand(id, e),
    })
}

fn get_key_from_tee_device(device: Option<&CStr>, info: KeyInfo) -> Result<Vec<u8>, Error> {
    let mut key_buf = [0u8; DERIVED_KEY_SIZE];

    let mut op = tee::create_operation(
        tee::teec_param_types(
            tee::TEEC_MEMREF_TEMP_INPUT,
            tee::TEEC_NONE,
            tee::TEEC_NONE,
            tee::TEEC_MEMREF_TEMP_OUTPUT,
        ),
        [
            tee::get_memref_input_parameter(&info.info),
            tee::get_zero_parameter(),
            tee::get_zero_parameter(),
            tee::get_memref_output_parameter(&mut key_buf),
        ],
    );

    call_command(device, &mut op, TaKeysafeCommand::GetUserDataStorageKey)?;

    Ok(key_buf.to_vec())
}

fn rotate_key_from_tee_device(device: Option<&CStr>, info: KeyInfo) -> Result<(), Error> {
    let mut op = tee::create_operation(
        tee::teec_param_types(
            tee::TEEC_MEMREF_TEMP_INPUT,
            tee::TEEC_NONE,
            tee::TEEC_NONE,
            tee::TEEC_NONE,
        ),
        [
            tee::get_memref_input_parameter(&info.info),
            tee::get_zero_parameter(),
            tee::get_zero_parameter(),
            tee::get_zero_parameter(),
        ],
    );

    call_command(device, &mut op, TaKeysafeCommand::RotateHardwareDerivedKey)
}

/// Gets a hardware derived key using the device /dev/class/tee/000. This is useful in early boot
/// when other services may not be up.
pub async fn get_hardware_derived_key(info: KeyInfo) -> Result<Vec<u8>, Error> {
    let dev =
        fuchsia_fs::directory::open_in_namespace("/dev", fuchsia_fs::OpenFlags::RIGHT_READABLE)?;
    let _ = recursive_wait_and_open_node(&dev, DEV_CLASS_TEE.strip_prefix("/dev/").unwrap())
        .map_err(Error::from)
        .on_timeout(std::time::Duration::from_secs(5), || Err(Error::TeeDeviceWaitTimeout))
        .await?;

    // Unwrap is fine because we are using a const we provide with no null bytes.
    let dev = std::ffi::CString::new(DEV_CLASS_TEE).unwrap();
    get_key_from_tee_device(Some(&dev), info)
}

/// Gets a hardware derived key using the service fuchsia.tee.Application. This should be used from
/// components.
pub async fn get_hardware_derived_key_from_service(info: KeyInfo) -> Result<Vec<u8>, Error> {
    get_key_from_tee_device(None, info)
}

/// Rotates an existing hardware derived key identified by [`info`] using the service
/// fuchsia.tee.Application. This should be used from components.
pub async fn rotate_hardware_derived_key_from_service(info: KeyInfo) -> Result<(), Error> {
    rotate_key_from_tee_device(None, info)
}
