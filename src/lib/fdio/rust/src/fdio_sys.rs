// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Generated by src/lib/fdio/rust/bindgen.sh using bindgen 0.64.0

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

pub const FDIO_MAX_FD: u32 = 1024;
pub const FDIO_CHUNK_SIZE: u32 = 8192;
pub const FDIO_MAX_FILENAME: u32 = 255;
pub const FDIO_FLAG_USE_FOR_STDIO: u32 = 32768;
pub const FDIO_EVT_READABLE: u32 = 1;
pub const FDIO_EVT_WRITABLE: u32 = 4;
pub const FDIO_EVT_ERROR: u32 = 8;
pub const FDIO_SPAWN_CLONE_JOB: u32 = 1;
pub const FDIO_SPAWN_DEFAULT_LDSVC: u32 = 2;
pub const FDIO_SPAWN_CLONE_NAMESPACE: u32 = 4;
pub const FDIO_SPAWN_CLONE_STDIO: u32 = 8;
pub const FDIO_SPAWN_CLONE_ENVIRON: u32 = 16;
pub const FDIO_SPAWN_CLONE_UTC_CLOCK: u32 = 32;
pub const FDIO_SPAWN_CLONE_ALL: u32 = 65535;
pub const FDIO_SPAWN_ACTION_CLONE_FD: u32 = 1;
pub const FDIO_SPAWN_ACTION_TRANSFER_FD: u32 = 2;
pub const FDIO_SPAWN_ACTION_ADD_NS_ENTRY: u32 = 3;
pub const FDIO_SPAWN_ACTION_ADD_HANDLE: u32 = 4;
pub const FDIO_SPAWN_ACTION_SET_NAME: u32 = 5;
pub const FDIO_SPAWN_ACTION_CLONE_DIR: u32 = 6;
pub const FDIO_SPAWN_ERR_MSG_MAX_LENGTH: u32 = 1024;
pub type zx_time_t = i64;
pub type zx_handle_t = u32;
pub type zx_status_t = i32;
pub type zx_signals_t = u32;
extern "C" {
    pub fn fdio_fd_create(handle: zx_handle_t, fd_out: *mut ::std::os::raw::c_int) -> zx_status_t;
}
extern "C" {
    pub fn fdio_cwd_clone(out_handle: *mut zx_handle_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_fd_clone(fd: ::std::os::raw::c_int, out_handle: *mut zx_handle_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_fd_transfer(fd: ::std::os::raw::c_int, out_handle: *mut zx_handle_t)
        -> zx_status_t;
}
extern "C" {
    pub fn fdio_fd_transfer_or_clone(
        fd: ::std::os::raw::c_int,
        out_handle: *mut zx_handle_t,
    ) -> zx_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdio {
    _unused: [u8; 0],
}
pub type fdio_t = fdio;
extern "C" {
    pub fn fdio_create(handle: zx_handle_t, out_io: *mut *mut fdio_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_default_create() -> *mut fdio_t;
}
extern "C" {
    pub fn fdio_null_create() -> *mut fdio_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zxio_tag {
    _unused: [u8; 0],
}
pub type zxio_t = zxio_tag;
extern "C" {
    pub fn fdio_get_zxio(io: *mut fdio_t) -> *mut zxio_t;
}
extern "C" {
    pub fn fdio_fd_create_null() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdio_bind_to_fd(
        io: *mut fdio_t,
        fd: ::std::os::raw::c_int,
        starting_fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdio_unbind_from_fd(fd: ::std::os::raw::c_int, io_out: *mut *mut fdio_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_get_service_handle(fd: ::std::os::raw::c_int, out: *mut zx_handle_t)
        -> zx_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zxio_storage {
    _unused: [u8; 0],
}
pub type zxio_storage_t = zxio_storage;
extern "C" {
    pub fn fdio_zxio_create(out_storage: *mut *mut zxio_storage_t) -> *mut fdio_t;
}
extern "C" {
    pub fn fdio_service_connect(
        path: *const ::std::os::raw::c_char,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_service_connect_at(
        directory: zx_handle_t,
        path: *const ::std::os::raw::c_char,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_service_connect_by_name(
        name: *const ::std::os::raw::c_char,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_open(
        path: *const ::std::os::raw::c_char,
        flags: u32,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_open_at(
        directory: zx_handle_t,
        path: *const ::std::os::raw::c_char,
        flags: u32,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_open_fd(
        path: *const ::std::os::raw::c_char,
        flags: u32,
        out_fd: *mut ::std::os::raw::c_int,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_open_fd_at(
        dir_fd: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        flags: u32,
        out_fd: *mut ::std::os::raw::c_int,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_service_clone(node: zx_handle_t) -> zx_handle_t;
}
extern "C" {
    pub fn fdio_service_clone_to(node: zx_handle_t, request: zx_handle_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_wait_fd(
        fd: ::std::os::raw::c_int,
        events: u32,
        pending: *mut u32,
        deadline: zx_time_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_handle_fd(
        h: zx_handle_t,
        signals_in: zx_signals_t,
        signals_out: zx_signals_t,
        shared_handle: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdio_pipe_half(
        out_fd: *mut ::std::os::raw::c_int,
        out_handle: *mut zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_get_vmo_copy(fd: ::std::os::raw::c_int, out_vmo: *mut zx_handle_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_get_vmo_clone(fd: ::std::os::raw::c_int, out_vmo: *mut zx_handle_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_get_vmo_exact(fd: ::std::os::raw::c_int, out_vmo: *mut zx_handle_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_get_vmo_exec(fd: ::std::os::raw::c_int, out_vmo: *mut zx_handle_t) -> zx_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdio_namespace {
    _unused: [u8; 0],
}
pub type fdio_ns_t = fdio_namespace;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zxio_ops {
    _unused: [u8; 0],
}
pub type zxio_ops_t = zxio_ops;
extern "C" {
    pub fn fdio_ns_create(out: *mut *mut fdio_ns_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_destroy(ns: *mut fdio_ns_t) -> zx_status_t;
}
pub type fdio_open_local_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut zxio_storage_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut *const zxio_ops_t,
    ) -> zx_status_t,
>;
extern "C" {
    pub fn fdio_ns_bind_local(
        ns: *mut fdio_ns_t,
        path: *const ::std::os::raw::c_char,
        on_open: fdio_open_local_func_t,
        context: *mut ::std::os::raw::c_void,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_bind(
        ns: *mut fdio_ns_t,
        path: *const ::std::os::raw::c_char,
        h: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_unbind(ns: *mut fdio_ns_t, path: *const ::std::os::raw::c_char) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_is_bound(ns: *mut fdio_ns_t, path: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn fdio_ns_bind_fd(
        ns: *mut fdio_ns_t,
        path: *const ::std::os::raw::c_char,
        fd: ::std::os::raw::c_int,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_opendir(ns: *mut fdio_ns_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdio_ns_chdir(ns: *mut fdio_ns_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_get_installed(ns: *mut *mut fdio_ns_t) -> zx_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdio_flat_namespace {
    pub count: usize,
    pub handle: *mut zx_handle_t,
    pub path: *const *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_fdio_flat_namespace() {
    const UNINIT: ::std::mem::MaybeUninit<fdio_flat_namespace> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fdio_flat_namespace>(),
        24usize,
        concat!("Size of: ", stringify!(fdio_flat_namespace))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_flat_namespace>(),
        8usize,
        concat!("Alignment of ", stringify!(fdio_flat_namespace))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(fdio_flat_namespace), "::", stringify!(count))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(fdio_flat_namespace), "::", stringify!(handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(fdio_flat_namespace), "::", stringify!(path))
    );
}
impl Default for fdio_flat_namespace {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type fdio_flat_namespace_t = fdio_flat_namespace;
extern "C" {
    pub fn fdio_ns_export(ns: *mut fdio_ns_t, out: *mut *mut fdio_flat_namespace_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_export_root(out: *mut *mut fdio_flat_namespace_t) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_connect(
        ns: *mut fdio_ns_t,
        path: *const ::std::os::raw::c_char,
        flags: u32,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_open(
        ns: *mut fdio_ns_t,
        path: *const ::std::os::raw::c_char,
        flags: u32,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_service_connect(
        ns: *mut fdio_ns_t,
        path: *const ::std::os::raw::c_char,
        request: zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_ns_free_flat_ns(ns: *mut fdio_flat_namespace_t);
}
extern "C" {
    pub fn fdio_spawn(
        job: zx_handle_t,
        flags: u32,
        path: *const ::std::os::raw::c_char,
        argv: *const *const ::std::os::raw::c_char,
        process_out: *mut zx_handle_t,
    ) -> zx_status_t;
}
pub type fdio_spawn_action_t = fdio_spawn_action;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fdio_spawn_action {
    pub action: u32,
    pub __bindgen_anon_1: fdio_spawn_action__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fdio_spawn_action__bindgen_ty_1 {
    pub fd: fdio_spawn_action__bindgen_ty_1__bindgen_ty_1,
    pub ns: fdio_spawn_action__bindgen_ty_1__bindgen_ty_2,
    pub h: fdio_spawn_action__bindgen_ty_1__bindgen_ty_3,
    pub name: fdio_spawn_action__bindgen_ty_1__bindgen_ty_4,
    pub dir: fdio_spawn_action__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fdio_spawn_action__bindgen_ty_1__bindgen_ty_1 {
    pub local_fd: ::std::os::raw::c_int,
    pub target_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fdio_spawn_action__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<fdio_spawn_action__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(local_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_fd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(target_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdio_spawn_action__bindgen_ty_1__bindgen_ty_2 {
    pub prefix: *const ::std::os::raw::c_char,
    pub handle: zx_handle_t,
}
#[test]
fn bindgen_test_layout_fdio_spawn_action__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<fdio_spawn_action__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(handle)
        )
    );
}
impl Default for fdio_spawn_action__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fdio_spawn_action__bindgen_ty_1__bindgen_ty_3 {
    pub id: u32,
    pub handle: zx_handle_t,
}
#[test]
fn bindgen_test_layout_fdio_spawn_action__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<fdio_spawn_action__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdio_spawn_action__bindgen_ty_1__bindgen_ty_4 {
    pub data: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_fdio_spawn_action__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<fdio_spawn_action__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(data)
        )
    );
}
impl Default for fdio_spawn_action__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdio_spawn_action__bindgen_ty_1__bindgen_ty_5 {
    pub prefix: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_fdio_spawn_action__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<fdio_spawn_action__bindgen_ty_1__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!("Size of: ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fdio_spawn_action__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(prefix)
        )
    );
}
impl Default for fdio_spawn_action__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_fdio_spawn_action__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<fdio_spawn_action__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(fdio_spawn_action__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fdio_spawn_action__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fdio_spawn_action__bindgen_ty_1),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fdio_spawn_action__bindgen_ty_1),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fdio_spawn_action__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fdio_spawn_action__bindgen_ty_1),
            "::",
            stringify!(dir)
        )
    );
}
impl Default for fdio_spawn_action__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for fdio_spawn_action__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "fdio_spawn_action__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_fdio_spawn_action() {
    const UNINIT: ::std::mem::MaybeUninit<fdio_spawn_action> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fdio_spawn_action>(),
        24usize,
        concat!("Size of: ", stringify!(fdio_spawn_action))
    );
    assert_eq!(
        ::std::mem::align_of::<fdio_spawn_action>(),
        8usize,
        concat!("Alignment of ", stringify!(fdio_spawn_action))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(fdio_spawn_action), "::", stringify!(action))
    );
}
impl Default for fdio_spawn_action {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for fdio_spawn_action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "fdio_spawn_action {{ __bindgen_anon_1: {:?} }}", self.__bindgen_anon_1)
    }
}
extern "C" {
    pub fn fdio_spawn_etc(
        job: zx_handle_t,
        flags: u32,
        path: *const ::std::os::raw::c_char,
        argv: *const *const ::std::os::raw::c_char,
        environ: *const *const ::std::os::raw::c_char,
        action_count: usize,
        actions: *const fdio_spawn_action_t,
        process_out: *mut zx_handle_t,
        err_msg_out: *mut ::std::os::raw::c_char,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_spawn_vmo(
        job: zx_handle_t,
        flags: u32,
        executable_vmo: zx_handle_t,
        argv: *const *const ::std::os::raw::c_char,
        environ: *const *const ::std::os::raw::c_char,
        action_count: usize,
        actions: *const fdio_spawn_action_t,
        process_out: *mut zx_handle_t,
        err_msg_out: *mut ::std::os::raw::c_char,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdio_unsafe_fd_to_io(fd: ::std::os::raw::c_int) -> *mut fdio_t;
}
extern "C" {
    pub fn fdio_unsafe_borrow_channel(io: *mut fdio_t) -> zx_handle_t;
}
extern "C" {
    pub fn fdio_unsafe_release(io: *mut fdio_t);
}
extern "C" {
    pub fn fdio_unsafe_wait_begin(
        io: *mut fdio_t,
        events: u32,
        handle_out: *mut zx_handle_t,
        signals_out: *mut zx_signals_t,
    );
}
extern "C" {
    pub fn fdio_unsafe_wait_end(io: *mut fdio_t, signals: zx_signals_t, events_out: *mut u32);
}
pub type watchdir_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        dirfd: ::std::os::raw::c_int,
        event: ::std::os::raw::c_int,
        fn_: *const ::std::os::raw::c_char,
        cookie: *mut ::std::os::raw::c_void,
    ) -> zx_status_t,
>;
extern "C" {
    pub fn fdio_watch_directory(
        dirfd: ::std::os::raw::c_int,
        cb: watchdir_func_t,
        deadline: zx_time_t,
        cookie: *mut ::std::os::raw::c_void,
    ) -> zx_status_t;
}
