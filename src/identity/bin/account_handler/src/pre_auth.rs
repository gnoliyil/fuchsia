// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//! This file contains a data type for pre-authentication state, which is
//! mutable per-account data that is readable when an account is locked.

use {
    account_common::AccountId,
    aes_gcm::{
        aead::{
            generic_array::{
                typenum::{U12, U32},
                GenericArray,
            },
            Aead, NewAead,
        },
        Aes256Gcm, Nonce,
    },
    fidl_fuchsia_identity_account::Error as ApiError,
    fidl_fuchsia_identity_authentication::Mechanism,
    lazy_static::lazy_static,
    rand::{thread_rng, Rng},
    serde::{Deserialize, Deserializer, Serialize, Serializer},
    tracing::{error, warn},
};

lazy_static! {
    static ref NULL_KEY: GenericArray<u8, U32> = *GenericArray::from_slice(&[0_u8; 32]);
}

/// The current (latest) version of the Pre-auth state
const PRE_AUTH_STATE_VERSION: u32 = 1;

/// The pre-authentication state for an account.
#[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
pub struct State {
    /// The version of the preauth state.
    ///
    /// Defining a version now lets us change fields over time (for example by deserializing into
    /// different structs based on the version) but currently we only support a single version
    /// and don't enforce any checks on that version.
    version: u32,

    /// The Account ID.
    account_id: AccountId,

    /// The enrollment state for this account.
    pub enrollment_state: EnrollmentState,
}

impl TryFrom<Vec<u8>> for State {
    type Error = ApiError;
    fn try_from(data: Vec<u8>) -> Result<Self, Self::Error> {
        bincode::deserialize(&data).map_err(|err| {
            warn!("Failed to deserialize Pre-auth state: {:?}", err);
            ApiError::InvalidRequest
        })
    }
}

impl<'a> TryInto<Vec<u8>> for &'a State {
    type Error = ApiError;

    fn try_into(self) -> Result<Vec<u8>, Self::Error> {
        bincode::serialize(self).map_err(|err| {
            warn!("Failed to serialize Pre-auth state: {:?}", err);
            ApiError::Internal
        })
    }
}

impl State {
    /// Constructs a new preauth state.
    pub fn new(account_id: AccountId, enrollment_state: EnrollmentState) -> Self {
        Self { version: PRE_AUTH_STATE_VERSION, account_id, enrollment_state }
    }

    /// Returns the account that this preauth state applies to.
    pub fn account_id(&self) -> &AccountId {
        &self.account_id
    }
}

/// State of the Enrollment associated with a system account.
#[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
pub enum EnrollmentState {
    /// No authentication mechanism enrollments.
    NoEnrollments,

    /// A single enrollment of an authentication mechanism,
    /// containing:
    SingleEnrollment {
        /// the ID of the authentication mechanism,
        auth_mechanism_id: String,
        #[serde(
            deserialize_with = "deserialize_mechanism",
            serialize_with = "serialize_mechanism"
        )]
        /// the mechanism used for authentication challenges.
        mechanism: Mechanism,
        /// the enrollment data for that authentication mechanism,
        data: Vec<u8>,
        /// both the volume encryption key and the null key (a key of all
        /// zeroes), wrapped with the authenticator prekey material.
        wrapped_key_material: WrappedKeySet,
    },
}

fn deserialize_mechanism<'de, D>(deserializer: D) -> Result<Mechanism, D::Error>
where
    D: Deserializer<'de>,
{
    let primitive = u32::deserialize(deserializer)?;
    Ok(Mechanism::from_primitive_allow_unknown(primitive))
}

fn serialize_mechanism<S>(mechanism: &Mechanism, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    serializer.serialize_u32(mechanism.into_primitive())
}

// Generates a random 256-bit array and returns it as a generic array of 32 u8s.
fn make_random_256_bit_generic_array() -> GenericArray<u8, U32> {
    let mut bits = [0_u8; 32];
    thread_rng().fill(&mut bits[..]);
    *GenericArray::from_slice(&bits)
}

// Generates a random 96-bit array and returns it as a generic array of 12 u8s.
fn make_random_96_bit_generic_array() -> GenericArray<u8, U12> {
    let mut bits = [0_u8; 12];
    thread_rng().fill(&mut bits[..]);
    *GenericArray::from_slice(&bits)
}

#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
// WrappedKey holds the ciphertext and nonce of an AES-256-GCM encryption for
// some plaintext, where the nonce is a 96-bit random number.
//
// The ciphertext was generated by encrypting some plaintext with a key derived
// from the authenticator prekey material:
//
// ```
// cipher = new_cipher(prekey)
// (ciphertext+tag) = cipher.encrypt(plaintext, nonce)
// plaintext = cipher.decrypt((ciphertext+tag), nonce)
// ```
//
// It can be decrypted by an Aes256Gcm object constructed from that same key.
//
// Since the plaintext is 256 and the tag is 128 bits, the ciphertext vector
// here will be 384 bytes.
pub struct WrappedKey {
    // The underlying data, wrapped via AES-256-GCM with some key, not stored here.
    ciphertext_and_tag: Vec<u8>,

    // A random 96-bit number.
    nonce: [u8; 12],
}
impl WrappedKey {
    fn make_from(cipher: &Aes256Gcm, plaintext: &GenericArray<u8, U32>) -> Option<WrappedKey> {
        let nonce: Nonce<U12> = *Nonce::from_slice(&make_random_96_bit_generic_array());
        let ciphertext = cipher.encrypt(&nonce, &**plaintext).ok()?;
        Some(WrappedKey { ciphertext_and_tag: ciphertext.to_vec(), nonce: nonce.into() })
    }
    fn unwrap_key(&self, cipher: &mut Aes256Gcm) -> Result<[u8; 32], ApiError> {
        cipher
            .decrypt((&self.nonce).into(), self.ciphertext_and_tag.as_ref())
            .map_err(|_e| {
                warn!(
                    "Failed to unwrap AES-256-GCM ciphertext. Was the wrong prekey material \
                    provided?"
                );
                ApiError::FailedAuthentication
            })?
            .try_into()
            .map_err(|_| {
                warn!(
                    "Unwrapped AES-256-GCM ciphertext given prekey material, but the resultant \
                    plaintext was of the wrong length -- expected [u8; 32]."
                );
                ApiError::Internal
            })
    }
}

#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
// WrappedKeySet holds:
//
// - a real key (in this case, the encryption key for some storage volume)
//   wrapped via AES-256-GCM with some prekey material.
//
// - a null key (i.e. 256 bytes of all zeroes) wrapped via AES-256-GCM with that
//   same prekey material. We store this in order to attempt to decode it first,
//   in order to know whether or not a key used to attempt decryption is valid
//   without needing to try to use it to unlock a volume.
//
// Both keys are stored in (ciphertext+tag, nonce) form (see WrappedKey), and
// both are wrapped with the same prekey material.
pub struct WrappedKeySet {
    wrapped_real_key: WrappedKey,
    wrapped_null_key: WrappedKey,
}

impl WrappedKeySet {
    // First unwraps the null key and ensures that it unwraps to the expected
    // NULL_KEY value. Then unwraps the real key and returns it.
    //
    // If the call to self.wrapped_null_key.unwrap_key() does not produce
    // NULL_KEY, it means that the wrong prekey_material was supplied, and we
    // return ApiError::FailedPrecondition.
    //
    // If the internal unwrap_key calls fail, we return ApiError::Internal.
    pub fn unwrap_real_key(&self, prekey_material: &[u8]) -> Result<[u8; 32], ApiError> {
        let mut cipher = Aes256Gcm::new(GenericArray::from_slice(prekey_material));

        match self.wrapped_null_key.unwrap_key(&mut cipher) {
            Err(ApiError::FailedAuthentication) => {
                warn!(
                    "Failed to unwrap the encrypted null key using AES-256-GCM. This probably \
                    means that the prekey material did not match that supplied during creation."
                );
                Err(ApiError::FailedAuthentication)
            }
            Err(e) => Err(e),
            Ok(decrypted_null_key) if decrypted_null_key == NULL_KEY.as_slice() => {
                // If the unwrapped encrypted null key is equal to the NULL_KEY,
                // then the provided prekey material is correct -- proceed to unwrap the real key.
                self.wrapped_real_key.unwrap_key(&mut cipher)
            }
            Ok(_) => {
                warn!(
                    "Unwrapped the encrypted null key using AES-256-GCM, but the resultant value \
                    was not actually the null key. This probably means that the prekey material \
                    did not match that supplied during creation."
                );
                Err(ApiError::FailedAuthentication)
            }
        }
    }
}

// Given prekey material, this function:
// - instantiates a new Aes256Gcm cipher,
// - generates a new random volume encryption key, and
// - wraps both the volume // encryption key and a 256-bit null key with two
//   different random nonces.
//
// Both the wrapped volume encryption key and the wrapped null key are returned
// so that they can be stored in the EnrollmentState struct above.
fn produce_wrapped_keys(prekey_material: Vec<u8>) -> Result<WrappedKeySet, ApiError> {
    let cipher = Aes256Gcm::new(GenericArray::from_slice(&prekey_material));

    let real_key: GenericArray<u8, U32> = make_random_256_bit_generic_array();

    let wrapped_real_key = WrappedKey::make_from(&cipher, &real_key).ok_or_else(|| {
        error!("Could not compute E(volume_encryption_key).");
        ApiError::Internal
    })?;

    let wrapped_null_key = WrappedKey::make_from(&cipher, &NULL_KEY).ok_or_else(|| {
        error!("Could not compute E(null_key).");
        ApiError::Internal
    })?;

    Ok(WrappedKeySet { wrapped_real_key, wrapped_null_key })
}

pub fn produce_single_enrollment(
    auth_mechanism_id: String,
    mechanism: Mechanism,
    data: Vec<u8>,
    prekey_material: Vec<u8>,
) -> Result<EnrollmentState, ApiError> {
    Ok(EnrollmentState::SingleEnrollment {
        auth_mechanism_id,
        mechanism,
        data,
        wrapped_key_material: produce_wrapped_keys(prekey_material)?,
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use assert_matches::assert_matches;
    use fuchsia_async as fasync;
    use lazy_static::lazy_static;

    lazy_static! {
        static ref TEST_ENROLLMENT_STATE: EnrollmentState = EnrollmentState::SingleEnrollment {
            auth_mechanism_id: String::from("test_id"),
            mechanism: Mechanism::Test,
            data: vec![1, 2, 3],
            wrapped_key_material: WrappedKeySet {
                wrapped_real_key: WrappedKey {
                    ciphertext_and_tag: vec![4, 5, 6],
                    nonce: [0_u8; 12]
                },
                wrapped_null_key: WrappedKey {
                    ciphertext_and_tag: vec![7, 8, 9],
                    nonce: [0_u8; 12]
                },
            }
        };
        static ref TEST_ACCOUNT_ID_1: AccountId = AccountId::new(1);
        static ref TEST_STATE: State =
            State::new(*TEST_ACCOUNT_ID_1, TEST_ENROLLMENT_STATE.clone(),);
        static ref TEST_STATE_BYTES: Vec<u8> = vec![
            1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 116, 101, 115,
            116, 95, 105, 100, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 0, 0, 0, 0, 0, 0, 0,
            4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 7, 8, 9, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0
        ];
    }

    #[fasync::run_until_stalled(test)]
    async fn convert_to_bytes_and_back() {
        let state_bytes: Vec<u8> = (&*TEST_STATE).try_into().unwrap();
        let state_from_bytes: State = state_bytes.try_into().unwrap();
        assert_eq!(&*TEST_STATE, &state_from_bytes);
    }

    #[fasync::run_until_stalled(test)]
    async fn convert_from_empty_bytes() {
        assert_eq!(State::try_from(vec![]), Err(ApiError::InvalidRequest));
    }

    #[fasync::run_until_stalled(test)]
    async fn check_golden() {
        let state_bytes: Vec<u8> = (&*TEST_STATE).try_into().unwrap();
        assert_eq!(state_bytes, *TEST_STATE_BYTES);
    }

    fn make_random_256_bit_array() -> [u8; 32] {
        let mut bits = [0_u8; 32];
        thread_rng().fill(&mut bits[..]);
        bits
    }

    #[test]
    fn test_wrapped_keys_are_different() {
        let prekey_material = make_random_256_bit_array().to_vec();
        let wk = assert_matches!(produce_wrapped_keys(prekey_material), Ok(m) => m);
        assert_ne!(wk.wrapped_real_key, wk.wrapped_null_key);
    }

    #[test]
    fn test_wrapped_keys_have_correct_length() {
        let prekey_material = make_random_256_bit_array().to_vec();
        let wk = assert_matches!(produce_wrapped_keys(prekey_material), Ok(m) => m);
        // Expected to be more than 32 because it includes the tag.
        assert_eq!(wk.wrapped_real_key.ciphertext_and_tag.len(), 48);
        assert_eq!(wk.wrapped_null_key.ciphertext_and_tag.len(), 48);
    }

    #[test]
    fn test_wrapped_keys_not_hermetic() {
        // Should have different output with the same input.
        let prekey_material = make_random_256_bit_array().to_vec();
        let wrapped_keys_1 =
            assert_matches!(produce_wrapped_keys(prekey_material.clone()), Ok(m) => m);
        let wrapped_keys_2 = assert_matches!(produce_wrapped_keys(prekey_material), Ok(m) => m);
        assert_ne!(wrapped_keys_1.wrapped_real_key, wrapped_keys_2.wrapped_real_key,);
        assert_ne!(wrapped_keys_1.wrapped_null_key, wrapped_keys_2.wrapped_null_key,);
    }

    #[test]
    fn test_wrapped_keys_null_key_decrypts_to_null() {
        let prekey_material = make_random_256_bit_array().to_vec();
        let wk = assert_matches!(produce_wrapped_keys(prekey_material.clone()), Ok(m) => m);

        let cipher = Aes256Gcm::new(GenericArray::from_slice(&prekey_material));

        let actual_plaintext = assert_matches!(
            cipher.decrypt(
                (&wk.wrapped_null_key.nonce).into(),
                wk.wrapped_null_key.ciphertext_and_tag.as_ref(),
            ),
            Ok(p) => p
        );

        assert_eq!(actual_plaintext, NULL_KEY.to_vec());
    }

    #[test]
    fn test_wrapped_keys_volume_key_can_be_decrypted() {
        let prekey_material = make_random_256_bit_array().to_vec();

        let wk = assert_matches!(produce_wrapped_keys(prekey_material.clone()), Ok(m) => m);

        let cipher = Aes256Gcm::new(GenericArray::from_slice(&prekey_material));

        assert_matches!(
            cipher.decrypt(
                (&wk.wrapped_real_key.nonce).into(),
                wk.wrapped_real_key.ciphertext_and_tag.as_ref(),
            ),
            Ok(_)
        );
    }

    #[test]
    fn test_wrapped_keys_unwrap_helper_fn() {
        let prekey_material = make_random_256_bit_array().to_vec();

        let wk = assert_matches!(produce_wrapped_keys(prekey_material.clone()), Ok(m) => m);

        // That this returns proves that:
        //  - the codepath to decrypt_wrapped_key(.., wrapped_null_key) succeeds,
        //  - the decrypted null key is null, and
        //  - the codepath to decrypt_wrapped_key(.., wrapped_real_key) succeeds.
        let _actual_real_key: [u8; 32] = assert_matches!(
            wk.unwrap_real_key(&prekey_material),
            Ok(plaintext) => plaintext
        );
    }

    #[test]
    fn test_wrapped_keys_wrong_prekey() {
        let prekey_material = make_random_256_bit_array().to_vec();
        let wk = assert_matches!(produce_wrapped_keys(prekey_material), Ok(m) => m);

        let other_prekey_material = make_random_256_bit_array().to_vec();
        assert_matches!(
            wk.unwrap_real_key(&other_prekey_material),
            Err(ApiError::FailedAuthentication)
        );
    }
}
