# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/compiled_action.gni")
import("//build/config/fuchsia/platform_version.gni")
import("//build/packages/package_metadata.gni")

# Generate a package from a manifest.
#
# Parameters
#
#   manifest (required)
#     [label] A generate_manifest() target defined earlier in the same file.
#     This provides the contents for the package.
#
#   The following two items are only required in order to produce metadata about
#   the package sets, and may be removed in the future:
#
#   package_name (default: the target name)
#     [string] Name of the package (should match what is in meta/package)
#
#   package_api_level (default: the current fuchsia api level)
#     [unsigned integer] API level of the package
#
#   repository (default: "fuchsia.com")
#     [string] The repository host name part of the package URL.
#     See https://fuchsia.dev/fuchsia-src/concepts/packages/package_url#repository
#     for more details.
#
#   package_out_dir (default: "$target_out_dir/$target_name")
#     [path] The directory into which package artifacts should be placed.
#
#   meta_subpackages (optional)
#     [label] A generate_meta_subpackages() target defined earlier in the same
#     file. The file contains a JSON list of subpackage metadata, for the
#     subpackages declared for the target package. Each subpackage entry
#     includes either an explicit name or a path to a file containing the
#     default package name for the subpackage, and a path to the subpackage's
#     merkle.
#
#   deps (optional)
#   test (optional)
#   visibility (optional)
#     Same as for any GN `action()` target.
template("package_tool_package_build") {
  forward_variables_from(invoker,
                         [
                           "package_api_level",
                           "package_name",
                           "package_out_dir",
                           "repository",
                         ])
  if (!defined(package_api_level)) {
    package_api_level = platform_version.in_development_api_level
  }

  if (!defined(package_name)) {
    package_name = target_name
  }

  if (!defined(repository)) {
    repository = "fuchsia.com"
  }

  if (!defined(package_out_dir)) {
    package_out_dir = "$target_out_dir/$target_name"
  }
  pkg_output_manifest = "$package_out_dir/package_manifest.json"

  metadata_target_name = "${target_name}_metadata"
  define_package_metadata(metadata_target_name) {
    package_name = package_name
    snapshot_entry = "$package_name/0=" +
                     rebase_path("$package_out_dir/blobs.json", root_build_dir)
    blob_manifest = "$package_out_dir/blobs.manifest"
    meta_far_merkle_index_entry =
        "$package_name/0=" +
        rebase_path("$package_out_dir/meta.far.merkle", root_build_dir)
    package_output_manifest = pkg_output_manifest
  }

  compiled_action(target_name) {
    tool = "//src/sys/pkg/bin/package-tool"
    tool_output_name = "package-tool"
    forward_variables_from(invoker,
                           [
                             "data_deps",
                             "deps",
                             "public_deps",
                             "testonly",
                             "visibility",
                           ])
    if (!defined(deps)) {
      deps = []
    }
    pkg_manifest_outputs = get_target_outputs(invoker.manifest)
    pkg_manifest_file = pkg_manifest_outputs[0]
    deps += [ invoker.manifest ]
    inputs = [ pkg_manifest_file ]
    if (defined(invoker.meta_subpackages)) {
      meta_subpackages_outputs = get_target_outputs(invoker.meta_subpackages)
      meta_subpackages_file = meta_subpackages_outputs[0]
      deps += [ invoker.meta_subpackages ]
      inputs += [ meta_subpackages_file ]
    }

    depfile = "$package_out_dir/meta.far.d"

    metadata = {
      if (defined(invoker.metadata)) {
        forward_variables_from(invoker.metadata, "*")
      }
      package_barrier = [ ":$metadata_target_name" ]
    }
    deps += [ ":$metadata_target_name" ]

    outputs = [
      # produced by seal, must be listed first because of depfile rules.
      "$package_out_dir/meta.far",

      # seal
      "$package_out_dir/meta.far.merkle",

      # package blob json manifest
      "$package_out_dir/blobs.json",

      # package blob manifest
      "$package_out_dir/blobs.manifest",

      # package output manifest
      pkg_output_manifest,
    ]

    args = [
      "package",
      "build",
      "-o",
      rebase_path(package_out_dir, root_build_dir),
      "--repository",
      repository,
      "--api-level",
      "$package_api_level",
    ]

    if (defined(meta_subpackages_file)) {
      args += [
        "--subpackages-build-manifest-path",
        rebase_path(meta_subpackages_file, root_build_dir),
      ]
    }

    args += [
      "--depfile",
      "--meta-far-merkle",
      "--blobs-json",
      "--blobs-manifest",
      rebase_path(pkg_manifest_file, root_build_dir),
    ]

    # Due to the content-based nature of these outputs, timestamps of these
    # outputs will not be freshened when their contents do not change in
    # incremental builds, which allows for early termination of downstream
    # build actions.
  }
}

declare_args() {
  # Controls which mode to use when copying blobs into the repository.
  # Supported modes are:
  #
  # * `copy`: copy the blob if the blob does not already exist in the
  #   repository. This will use copy-on-write to efficiently copy the blob on
  #   file systems that support it.
  #
  # * `copy-overwrite`: always copy the blob, overwriting any blob that
  #   exists in the blob repository. This will use copy-on-write to efficiently
  #   copy the blob on file systems that support it.
  #
  # * `hard-link`: hard link the blob into the repository, or copy if we cannot
  #   create a hard link between the blob and the blob repository. Note that it
  #   is possible to modify the blob through the hard link, which would result
  #   in the blob not matching the blob's merkle.
  repository_publish_blob_copy_mode = "copy"

  # Controls what type of delivery blob to generate in the repository.
  # Supported types can be found in //src/storage/blobfs/delivery_blob.h
  repository_publish_delivery_blob_type = -1
}

# Publish package manifests to a repository.
#
# Parameters
#
#   output_repository_dir (required)
#     A publish packages to this directory path.
#
#   package_list_manifests (required)
#     A list of package list manifest paths.
#
#   initial_trusted_root_metadata (optional)
#     Initialize TUF trust with this root metadata. Defaults to
#     ${repository_dir}/repository/1.root.json if unspecified.
template("package_tool_repository_publish") {
  assert(defined(invoker.output_repository_dir) &&
             invoker.output_repository_dir != "",
         "output_repository_dir must be defined")

  assert(
      repository_publish_blob_copy_mode == "copy" ||
          repository_publish_blob_copy_mode == "copy-overwrite" ||
          repository_publish_blob_copy_mode == "hard-link",
      "`repository_publish_blob_copy_mode` can only be `copy`, `copy-overwrite`, or `hard-link`")

  _output_repository_dir = invoker.output_repository_dir

  assert(defined(invoker.package_list_manifests),
         "package_list_manifests must be defined")

  compiled_action(target_name) {
    tool = "//src/sys/pkg/bin/package-tool"
    tool_output_name = "package-tool"
    forward_variables_from(invoker,
                           [
                             "deps",
                             "data_deps",
                             "inputs",
                             "testonly",
                             "visibility",
                             "metadata",
                           ])

    # The contents of these folders is dynamic, and managed entirely by this action.
    hermetic_action_ignored_prefixes =
        [ "${_output_repository_dir}/repository" ]

    sources = invoker.package_list_manifests

    depfile = "${target_out_dir}/${target_name}.d"

    outputs = [
      # Note: the first output is the one that appears in the depfile.
      "${_output_repository_dir}/repository/targets.json",
      "${_output_repository_dir}/repository/snapshot.json",
      "${_output_repository_dir}/repository/timestamp.json",
    ]

    args = [
      "repository",
      "publish",
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--clean",
      "--time-versioning",
      "--copy-mode",
      repository_publish_blob_copy_mode,
    ]

    if (defined(invoker.initial_trusted_root_metadata)) {
      assert(invoker.initial_trusted_root_metadata != "",
             "initial_trusted_root_metadata cannot be empty")
      args += [
        "--trusted-root",
        rebase_path(invoker.initial_trusted_root_metadata, root_build_dir),
      ]
    }

    if (repository_publish_delivery_blob_type != -1) {
      args += [
        "--delivery-blob-type",
        "${repository_publish_delivery_blob_type}",
      ]
    }

    if (defined(sources)) {
      foreach(package_list, invoker.package_list_manifests) {
        args += [
          "--package-list",
          rebase_path(package_list, root_build_dir),
        ]
      }
    }

    args += [ rebase_path(_output_repository_dir, root_build_dir) ]
  }
}
