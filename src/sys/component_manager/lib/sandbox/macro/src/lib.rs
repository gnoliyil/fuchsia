// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use darling::FromDeriveInput;
use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, GenericParam, Lifetime, LifetimeDef};

/// Lifetime used in trait impls generated by the [Capability] macro.
static CAPABILITY_LIFETIME_NAME: &str = "'capability";

/// Attributes for the [Capability] derive macro.
#[derive(FromDeriveInput, Default)]
#[darling(default, attributes(capability))]
struct CapabilityAttributes {}

/// Derive macro that implements [Capability] and its super traits.
///
/// # Example
///
/// ```
/// #[derive(Capability, Debug)]
/// struct MyCapability;
/// ```
///
/// # `TryFrom<AnyCapability>`
///
/// The derived Capability implements `TryFrom<AnyCapability>`, and by extension,
/// `TryInto<T> for AnyCapability`, for convenient downcasting and conversion to a concrete type.
///
/// ```
/// let cap = MyCapability {};
/// let any: AnyCapability = Box::new(cap);
/// let downcast: MyCapability = any.try_into()?;
/// ```
///
/// # `TryFrom<&dyn ErasedCapability>`, `TryFrom<&AnyCapability>`, and `&mut` references
///
/// The derived Capability also implements conversion from a (mutable) reference to a type-erased
/// capability. This is used to downcast a reference to a reference to the concrete type:
///
/// ```
/// let cap = MyCapability {};
/// let any: AnyCapability = Box::new(cap);
///
/// let ref_any: &AnyCapability = &any;
/// let downcast_ref: &MyCapability = ref_any.try_into()?;
///
/// let mut_ref_any: &mut AnyCapability = &mut any;
/// let downcast_mut_ref: &mut MyCapability = mut_ref_any.try_into()?;
/// ```
///
#[proc_macro_derive(Capability, attributes(capability))]
pub fn derive_capability(input: TokenStream) -> TokenStream {
    let input: DeriveInput = parse_macro_input!(input);
    let name = &input.ident;

    // Create a `capability lifetime, used in impls that operate on references.
    let lifetime = LifetimeDef::new(Lifetime::new(CAPABILITY_LIFETIME_NAME, Span::call_site()));

    let mut lifetime_with_bounds = lifetime.clone();
    for param in input.generics.params.iter() {
        if let GenericParam::Lifetime(lifetime_def) = param {
            lifetime_with_bounds.bounds.push(lifetime_def.lifetime.clone());
        }
    }

    // Add the `capability lifetime to generics, and split it to get a piece suitable
    // for an `impl` declaration.
    //
    // For example, if the input type is `Foo<T>`, `impl_generics_with_lifetime`
    // is `<'capability, T>`, used as `impl<'capability, T> ...`
    let mut generics_with_lifetime = input.generics.clone();
    generics_with_lifetime.params.push(lifetime_with_bounds.into());
    let (impl_generics_with_lifetime, _, _) = generics_with_lifetime.split_for_impl();

    // Split the generics into pieces used in the trait impl declaration.
    //
    // For example, for the input type `Foo<T> where T: Bar`:
    //   * `impl_generics` is `<T>`, used as `impl<T>`
    //   * `ty_generics` is `<T>`, used as `Foo<T>`
    //   * `where_clause` is `where T: Bar`
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();
    // The name of the type with generic parameters, e.g. `Open`, or `Data<T>`
    let typename = quote! { #name #ty_generics };

    TokenStream::from(quote! {
        impl #impl_generics TryFrom<::sandbox::AnyCapability> for #typename #where_clause {
            type Error = ::sandbox::ConversionError;

            fn try_from(value: ::sandbox::AnyCapability) -> Result<Self, Self::Error> {
                use ::sandbox::AnyCast;
                if (&*value).as_any().is::<Self>() {
                    Ok(*value.into_any().downcast::<Self>().unwrap())
                } else {
                    Err(::sandbox::ConversionError::NotSupported)
                }
            }
        }

        impl #impl_generics_with_lifetime TryFrom<&#lifetime dyn ::sandbox::ErasedCapability> for &#lifetime #typename #where_clause {
            type Error = ::sandbox::ConversionError;

            fn try_from(value: &dyn ::sandbox::ErasedCapability) -> Result<&#typename, Self::Error> {
                value.as_any().downcast_ref::<#typename>().ok_or(::sandbox::ConversionError::NotSupported)
            }
        }

        impl #impl_generics_with_lifetime TryFrom<&#lifetime mut dyn ::sandbox::ErasedCapability> for &#lifetime mut #typename #where_clause {
            type Error = ::sandbox::ConversionError;

            fn try_from(value: &mut dyn ::sandbox::ErasedCapability) -> Result<&mut #typename, Self::Error> {
                value.as_any_mut().downcast_mut::<#typename>().ok_or(::sandbox::ConversionError::NotSupported)
            }
        }

        impl #impl_generics_with_lifetime TryFrom<&#lifetime ::sandbox::AnyCapability> for &#lifetime #typename #where_clause {
            type Error = ::sandbox::ConversionError;

            fn try_from(value: &::sandbox::AnyCapability) -> Result<&#typename, Self::Error> {
                value.as_ref().try_into()
            }
        }

        impl #impl_generics_with_lifetime TryFrom<&#lifetime mut ::sandbox::AnyCapability> for &#lifetime mut #typename #where_clause {
            type Error = ::sandbox::ConversionError;

            fn try_from(value: &mut ::sandbox::AnyCapability) -> Result<&mut #typename, Self::Error> {
                let borrowed: &mut dyn ::sandbox::ErasedCapability = <::sandbox::AnyCapability as ::std::borrow::BorrowMut<dyn ::sandbox::ErasedCapability>>::borrow_mut(value);
                borrowed.try_into()
            }
        }
    })
}
