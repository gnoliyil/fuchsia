// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use std::io::Cursor;

use anyhow::Error;
use appkit::*;
use either::Either;
use fidl_fuchsia_element as felement;
use fidl_fuchsia_math as fmath;
use fidl_fuchsia_ui_composition as ui_comp;
use fidl_fuchsia_ui_input3::KeyEventStatus;
use fidl_fuchsia_ui_shortcut2 as ui_shortcut2;
use fidl_fuchsia_ui_views as ui_views;
use futures::{
    channel::mpsc::{UnboundedReceiver, UnboundedSender},
    Stream, StreamExt,
};
use indexmap::IndexMap;
use num::FromPrimitive;
use tracing::{debug, error, warn};

use crate::shortcuts::{all_shortcuts, ShortcutAction};

// Background color: Fuchsia Green 04 [Opacity 0.3].
const BACKGROUND_COLOR: ui_comp::ColorRgba =
    ui_comp::ColorRgba { red: 0.075, green: 0.698, blue: 0.58, alpha: 0.3 };

// The annotation namespace used by the window manager.
pub(crate) const WM_ANNOTATION_NS: &str = "wm_ns";

// The name of the annotation key for the name of the shell view.
pub(crate) const WM_ANNOTATION_SHELLVIEW_NAME: &str = "wm_shellview_name";

// The name of the application launcher shell view.
// Note: This should match the name of the child component in window manager's .CML file.
pub(crate) const WM_SHELLVIEW_APP_LAUNCHER: &str = "app_launcher";

// The list of shell views used in the window manager.
pub(crate) const WM_SHELLVIEWS: &'static [&'static str] = &[WM_SHELLVIEW_APP_LAUNCHER];

// LINT.IfChange
// Height of the app launcher used to subtract from fullscreen height for child views.
// Note: This value should match the APP_LAUNCHER_HEIGHT value in app_launcher package.
const APP_LAUNCHER_HEIGHT: u32 = 32;
// LINT.ThenChange(../../app_launcher/src/main.rs)

// Dimensions of keyboard shortcuts image.
const SHORTCUTS_IMAGE_WIDTH: u32 = 400;
const SHORTCUTS_IMAGE_HEIGHT: u32 = 300;

/// Defines an enumeration of all shell view types.
#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
pub enum ShellViewKind {
    AppLauncher,
}

/// Defines an enumeration of all notifications generated by the window manager.
///
/// This is used in tests to verify correctness and in production to log to inspect.
#[derive(Debug, PartialEq)]
pub(crate) enum Notification {
    // A shell view was added to the window manager.
    AddedShellView { id: ChildViewId, kind: ShellViewKind },
    // A child view was added to the window manager.
    AddedChildView { id: ChildViewId },
    // A child view was removed from the window manager.
    RemovedChildView { id: ChildViewId },
    // Focus moved to either window manager's window or a child view's window.
    FocusChanged { target: Either<WindowId, ChildViewId> },
}

/// Defines a type for holding the state of the window manager.
///
/// The window manager holds child views from applications provided to it by GraphicalPresenter and
/// shell views from components launched by itself. It places them in a certain display order:
///
///              Bottom layer: -----window manager background-----
///
///              Middle layer: -----     child views         -----
///
///              Top layer:    -----     shell views         -----
///
pub(crate) struct WindowManager {
    // The event sender used to route events.
    event_sender: EventSender,
    // The [Notification] sender used to report notifications generated by the window manager.
    notification_sender: UnboundedSender<Notification>,
    // The main application [Window] of the Window Manager.
    window: Window,
    // The map of all launched [ChildView] views by their [ChildViewId].
    child_views: IndexMap<ChildViewId, ChildView>,
    // The map of all shell views by their [ChildViewId].
    shell_views: IndexMap<ChildViewId, (ChildView, ShellViewKind)>,
    // The map of all incoming [ChildView]s views by their [ChildViewId] that are not assigned a
    // flatland transform yet.
    pending_child_views: IndexMap<ChildViewId, ChildView>,
    // The flatland transforms that hold the [ChildView]'s content. The transforms always stay in
    // back-to-front order, so when child_views gets rearranged, the child-to-transform mapping
    // changes.
    child_view_transforms: Vec<ui_comp::TransformId>,
    // The flatland content id for background color on the root transform.
    background_content: ui_comp::ContentId,
    // The layer (parent transform) for holding all child views.
    child_views_layer: ui_comp::TransformId,
    // The layer (parent transform) for holding all shell component views.
    shell_views_layer: ui_comp::TransformId,
    // The child transform to hold the image for keyboard shortcuts.
    shortcuts_image_transform: ui_comp::TransformId,
    // The current width of the application window.
    width: u32,
    // The current height of the application window.
    height: u32,
    // The flag to indicate that WindowManager is ready after receiving the first resize event.
    is_ready: bool,
    // The view specs to present ChildViews that arrived before the main window is created.
    pending_child_view_present_specs: Vec<ViewSpecHolder>,
}

impl WindowManager {
    pub fn new(
        event_sender: EventSender,
        notification_sender: UnboundedSender<Notification>,
        view_creation_token: ui_views::ViewCreationToken,
        pending_child_view_present_specs: Vec<ViewSpecHolder>,
        protocol_connector: Box<dyn ProtocolConnector>,
    ) -> Result<WindowManager, Error> {
        let mut window = Window::new(event_sender.clone())
            .with_view_creation_token(view_creation_token)
            .with_protocol_connector(protocol_connector.box_clone())
            .use_focus_chain_listener(true);
        window.create_view()?;

        let flatland = window.get_flatland();
        let mut background = window.next_content_id();
        flatland.create_filled_rect(&mut background)?;
        let mut root_transform_id = window.get_root_transform_id();
        flatland.set_content(&mut root_transform_id, &mut background)?;

        let mut shortcuts_image_transform = window.next_transform_id();
        flatland.create_transform(&mut shortcuts_image_transform)?;
        flatland.add_child(&mut root_transform_id, &mut shortcuts_image_transform)?;

        let mut child_views_layer = window.next_transform_id();
        flatland.create_transform(&mut child_views_layer)?;
        flatland.add_child(&mut root_transform_id, &mut child_views_layer)?;

        let mut shell_views_layer = window.next_transform_id();
        flatland.create_transform(&mut shell_views_layer)?;
        flatland.add_child(&mut root_transform_id, &mut shell_views_layer)?;

        Ok(WindowManager {
            event_sender,
            notification_sender,
            window,
            child_views: IndexMap::new(),
            shell_views: IndexMap::new(),
            pending_child_views: IndexMap::new(),
            child_view_transforms: vec![],
            background_content: background,
            child_views_layer,
            shell_views_layer,
            shortcuts_image_transform,
            width: 0,
            height: 0,
            is_ready: false,
            pending_child_view_present_specs,
        })
    }

    // Closes the window of the window manager and initiates shutdown.
    fn close(&mut self) -> Result<(), Error> {
        self.pending_child_view_present_specs.clear();
        self.pending_child_views.clear();
        self.child_views.clear();
        self.shell_views.clear();

        // Calling close() on window manager's window releases its Flatland resources and
        // eventually generates a WindowEvent::Closed event, which exits the event loop.
        self.window.close()
    }

    pub async fn run(
        &mut self,
        mut receiver: impl Stream<Item = Event> + std::marker::Unpin,
    ) -> Result<(), Error> {
        self.window.register_shortcuts(all_shortcuts()).await?;

        // Load the keyboard shortcuts image.
        self.load_shortcuts_image().await?;

        while let Some(event) = receiver.next().await {
            debug!("{:?}", event);
            match event {
                Event::SystemEvent { event } => match event {
                    // Ignore subsequent ViewProvider::CreateView requests. We only allow one
                    // instance of WindowManager to exist.
                    SystemEvent::ViewCreationToken { .. } => {
                        warn!("Received another ViewProvider::CreateView2 request. Ignoring.");
                    }

                    // Create a [ChildView] from GraphicalPresenter's ViewSpec.
                    SystemEvent::PresentViewSpec { view_spec_holder } => {
                        if self.is_ready {
                            let shell_view_kind = shell_view_kind_from_view_spec(
                                &view_spec_holder.view_spec.annotations,
                            );

                            let height = match shell_view_kind {
                                Some(_) => APP_LAUNCHER_HEIGHT,
                                _ => self.height - APP_LAUNCHER_HEIGHT,
                            };
                            let child_view = self.window.create_child_view(
                                view_spec_holder,
                                self.width,
                                height,
                                self.event_sender.clone(),
                            )?;
                            self.window.redraw();

                            match shell_view_kind {
                                Some(shell_view_kind) => {
                                    self.add_shell_view(child_view, shell_view_kind)?;
                                }
                                None => {
                                    // Save child_view to pending_child_views until it's component
                                    // has finished loading and rendered a frame. The child view can
                                    // then be attached to the display tree in
                                    // [ChildViewEvent::Available].
                                    self.pending_child_views.insert(child_view.id(), child_view);
                                }
                            }
                        } else {
                            self.pending_child_view_present_specs.push(view_spec_holder);
                        }
                    }
                },

                Event::WindowEvent { window_id, event: window_event, .. } => {
                    match window_event {
                        WindowEvent::Closed => break,

                        WindowEvent::Resized { width, height, .. } => {
                            self.resize(width, height)?;
                            self.window.redraw();

                            self.is_ready = true;
                            // Handle any pending childview specs.
                            for view_spec_holder in self.pending_child_view_present_specs.drain(..)
                            {
                                self.event_sender.send(Event::SystemEvent {
                                    event: SystemEvent::PresentViewSpec { view_spec_holder },
                                });
                            }
                        }

                        WindowEvent::Focused { focused } => {
                            if focused {
                                self.notify(Notification::FocusChanged {
                                    target: Either::Left(window_id),
                                })?;
                            }
                        }

                        WindowEvent::Keyboard { responder, .. } => {
                            // Keep keyboard channel happy by always responding.
                            responder.send(KeyEventStatus::NotHandled)?;
                        }

                        WindowEvent::Shortcut { id, responder } => {
                            // Active window is always on top and last in display list. Next
                            // window will be at index 0, whereas previous window will be the
                            // second to last index. Switching to those window will make them
                            // the top window of the display list.
                            if let Some(action) = ShortcutAction::from_u32(id) {
                                match action {
                                    ShortcutAction::FocusNext => {
                                        self.focus_next()?;
                                        self.layout()?;
                                        self.refocus()?;
                                    }

                                    ShortcutAction::FocusPrev => {
                                        self.focus_previous()?;
                                        self.layout()?;
                                        self.refocus()?;
                                    }

                                    ShortcutAction::Close => {
                                        if let Some((child_view_id, _)) = self.child_views.last() {
                                            self.remove_child_view(*child_view_id)?;
                                            self.layout()?;
                                            self.refocus()?;
                                        }
                                    }

                                    ShortcutAction::Logout => {
                                        self.event_sender.send(Event::Exit);
                                    }
                                }

                                self.window.redraw();
                            } else {
                                error!("Received unknown shortcut invocation: {:?}", id);
                            }

                            responder.send(ui_shortcut2::Handled::Handled)?;
                        }
                        WindowEvent::ChildViewFocused { view_ref, .. } => {
                            // Get the child view with view_ref.
                            for (child_view_id, child_view) in &self.child_views {
                                let child_view_ref = child_view
                                    .get_view_ref()
                                    .expect("Failed to get child view ref");
                                if view_ref_is_same(&child_view_ref, &view_ref) {
                                    self.notify(Notification::FocusChanged {
                                        target: Either::Right(*child_view_id),
                                    })?;
                                    break;
                                }
                            }
                        }
                        WindowEvent::NeedsRedraw { .. } | WindowEvent::Pointer { .. } => {}
                    }
                }

                Event::ChildViewEvent { child_view_id, event, .. } => match event {
                    ChildViewEvent::Available => {
                        self.add_child_view(child_view_id)?;
                        self.window.redraw();
                    }

                    ChildViewEvent::Attached { view_ref } => {
                        if let Some(child_view) = self.child_views.get_mut(&child_view_id) {
                            child_view.set_view_ref(view_ref);
                            self.refocus()?;
                        } else if let Some((_, kind)) = self.shell_views.get(&child_view_id) {
                            self.notify(Notification::AddedShellView {
                                id: child_view_id,
                                kind: *kind,
                            })?;
                        }
                    }

                    ChildViewEvent::Detached | ChildViewEvent::Dismissed => {
                        self.remove_child_view(child_view_id)?;
                        self.layout()?;
                        self.refocus()?;
                        self.window.redraw();
                    }
                },

                Event::Exit => {
                    self.close()?;
                }

                Event::Init | Event::DeviceEvent | Event::UserEvent(..) => {}
            }
        }

        Ok(())
    }

    async fn load_shortcuts_image(&mut self) -> Result<(), Error> {
        static IMAGE_DATA: &'static [u8] = include_bytes!("../shortcuts.png");
        let (bytes, width, height) = load_png(Cursor::new(IMAGE_DATA)).expect("Failed to load png");
        let shortcuts_image = self.window.create_image_from_bytes(&bytes, width, height).await?;

        let flatland = self.window.get_flatland();
        flatland.set_image_blending_function(
            &mut shortcuts_image.get_content_id(),
            ui_comp::BlendMode::SrcOver,
        )?;

        self.window
            .set_content(self.shortcuts_image_transform, shortcuts_image.get_content_id())?;
        Ok(())
    }

    // Resizes the background color and child view contents.
    fn resize(&mut self, width: u32, height: u32) -> Result<(), Error> {
        self.width = width;
        self.height = height;

        // Resize the background.
        let flatland = self.window.get_flatland();
        flatland.set_solid_fill(
            &mut self.background_content,
            &mut BACKGROUND_COLOR.clone(),
            // TODO(fxbug.dev/110653): Mysteriously, Scenic blows up when
            // you make a rectangle the size of the viewport, under very
            // specific circumstances. When that bug is fixed, change this
            // to just width and height.
            &mut fmath::SizeU {
                width: width.saturating_sub(1).clamp(1, u32::MAX),
                height: height.saturating_sub(1).clamp(1, u32::MAX) - APP_LAUNCHER_HEIGHT,
            },
        )?;

        // Position shortcuts image to bottom-right of the screen, above app launcher.
        flatland.set_translation(
            &mut self.shortcuts_image_transform,
            &mut fmath::Vec_ {
                x: (width - SHORTCUTS_IMAGE_WIDTH) as i32,
                y: (height - SHORTCUTS_IMAGE_HEIGHT - APP_LAUNCHER_HEIGHT) as i32,
            },
        )?;

        // Resize child views.
        for child_view in self.child_views.values_mut() {
            child_view.set_size(width, height - APP_LAUNCHER_HEIGHT)?;
        }

        Ok(())
    }

    // Layout all child view transforms and set their content to a child view.
    //
    // The application holds a list of flatland transforms equal to the number of child views. Since
    // Flatland does not provide an API to change the order of transforms, we instead set their
    // contents in a display order, back-to-front to a child_view in [child_views].
    fn layout(&mut self) -> Result<(), Error> {
        assert_eq!(self.child_views.len(), self.child_view_transforms.len());

        for ((_, child_view), child_view_transform) in
            self.child_views.iter().zip(self.child_view_transforms.iter())
        {
            self.window.set_content(child_view_transform.clone(), child_view.get_content_id())?;
        }

        Ok(())
    }

    // Requests focus to the top-most child view.
    fn refocus(&self) -> Result<(), Error> {
        if let Some((_, child_view)) = self.child_views.last() {
            if let Some(view_ref) = child_view.get_view_ref() {
                let focuser = self.window.get_focuser().expect("Failed to retrieve window focuser");
                set_focus(focuser, view_ref);
            }
        }

        Ok(())
    }

    // Add the child_view as a shell view to shell_view layer.
    fn add_shell_view(&mut self, shell_view: ChildView, kind: ShellViewKind) -> Result<(), Error> {
        let shell_view_id = shell_view.id();
        let mut shell_view_content_id = shell_view.get_content_id();

        let flatland = self.window.get_flatland();
        let mut shell_view_transform = self.window.next_transform_id();

        flatland.create_transform(&mut shell_view_transform)?;
        flatland.set_translation(
            &mut shell_view_transform,
            &mut fmath::Vec_ { x: 0, y: self.height as i32 - APP_LAUNCHER_HEIGHT as i32 },
        )?;

        flatland.add_child(&mut self.shell_views_layer, &mut shell_view_transform)?;
        flatland.set_content(&mut shell_view_transform, &mut shell_view_content_id)?;

        self.shell_views.insert(shell_view_id, (shell_view, kind));

        Ok(())
    }

    // Move the child_view from pending_child_views to child_views and create a transform to hold
    // it's content.
    fn add_child_view(&mut self, child_view_id: ChildViewId) -> Result<(), Error> {
        if let Some(child_view) = self.pending_child_views.remove(&child_view_id) {
            let content_id = child_view.get_content_id();
            let child_view_transform = self.create_child_view_transform(content_id)?;
            self.child_views.insert(child_view_id, child_view);
            self.child_view_transforms.push(child_view_transform);

            self.notify(Notification::AddedChildView { id: child_view_id })?;
        }

        Ok(())
    }

    // Removes a child_view from [child_views] and a transform from [child_view_transforms] to keep
    // their 1-1 association.
    fn remove_child_view(&mut self, child_view_id: ChildViewId) -> Result<(), Error> {
        if self.child_views.contains_key(&child_view_id) {
            assert!(self.child_views.len() == self.child_view_transforms.len());
            // We pop a transform [child_view_transforms] to keep them in sync with [child_views].
            // It does not matter where we remove it from. We re-associate child views to transform
            // in [layout].
            let mut child_view_transform =
                self.child_view_transforms.pop().expect("Failed to find child_view_transform");

            let flatland = self.window.get_flatland();
            flatland.remove_child(&mut self.child_views_layer, &mut child_view_transform)?;
            flatland.release_transform(&mut child_view_transform)?;

            self.child_views.remove(&child_view_id);

            self.notify(Notification::RemovedChildView { id: child_view_id })?;
        } else if self.pending_child_views.contains_key(&child_view_id) {
            self.pending_child_views.remove(&child_view_id);
        }

        Ok(())
    }

    // Creates a transform to hold the child view's content. We maintain a 1-1 association of a
    // child view's content to a transform. The transform is added to the [child_views_layer].
    fn create_child_view_transform(
        &mut self,
        mut content_id: ui_comp::ContentId,
    ) -> Result<ui_comp::TransformId, Error> {
        let flatland = self.window.get_flatland();
        let mut child_view_transform = self.window.next_transform_id();
        flatland.create_transform(&mut child_view_transform)?;
        flatland.add_child(&mut self.child_views_layer, &mut child_view_transform)?;
        flatland.set_content(&mut child_view_transform, &mut content_id)?;

        Ok(child_view_transform)
    }

    // Moves a child view to the top of the display list. This can also be used to implement
    // "Focus Next", where the next view to a top view is the view at index 0.
    fn bring_to_top(&mut self, index: usize) -> Result<(), Error> {
        if self.child_view_transforms.len() <= 1 || index >= self.child_view_transforms.len() {
            return Ok(());
        }

        // Move the view at index to the top.
        self.child_views.move_index(index, self.child_views.len() - 1);

        self.refocus()?;

        Ok(())
    }

    /// Focus to the next-from-last child view, which is at index 0, in the display list.
    fn focus_next(&mut self) -> Result<(), Error> {
        self.bring_to_top(0)
    }

    /// Focus to the second-to-last child view in the display list.
    fn focus_previous(&mut self) -> Result<(), Error> {
        if self.child_view_transforms.len() <= 1 {
            return Ok(());
        }

        // Move the top-most view to the bottom, thereby making the previous view top-most.
        self.child_views.move_index(self.child_views.len() - 1, 0);

        self.refocus()?;

        Ok(())
    }

    /// Send a notification for changes to window manager state.
    fn notify(&self, notification: Notification) -> Result<(), Error> {
        self.notification_sender.unbounded_send(notification)?;
        Ok(())
    }
}

fn set_focus(focuser: ui_views::FocuserProxy, mut view_ref: ui_views::ViewRef) {
    spawn_async_on_err(focuser.request_focus(&mut view_ref), |error| {
        error!("Failed to request_focus: {:?}", error)
    });
}

/// Returns the first ViewCreationToken received by ViewProvider service and all requests to
/// present a view to the GraphicalPresenter service, while consuming all other events.
pub async fn get_first_view_creation_token(
    receiver: &mut UnboundedReceiver<Event>,
) -> (ui_views::ViewCreationToken, Vec<ViewSpecHolder>) {
    let mut view_spec_holders = vec![];
    while let Some(event) = receiver.next().await {
        match event {
            Event::Init => continue,
            Event::SystemEvent { event } => match event {
                SystemEvent::ViewCreationToken { token } => {
                    return (token, view_spec_holders);
                }
                SystemEvent::PresentViewSpec { view_spec_holder } => {
                    view_spec_holders.push(view_spec_holder);
                }
            },
            _ => {
                warn!("Ignoring {:?} while waiting for ViewProvider::CreateView2 request", event)
            }
        }
    }
    unreachable!()
}

fn shell_view_kind_from_view_spec(
    annotations: &Option<Vec<felement::Annotation>>,
) -> Option<ShellViewKind> {
    let shell_view_name_key = felement::AnnotationKey {
        namespace: WM_ANNOTATION_NS.to_string(),
        value: WM_ANNOTATION_SHELLVIEW_NAME.to_string(),
    };
    if let Some(annotations) = annotations {
        for annotation in annotations {
            if annotation.key == shell_view_name_key {
                if let felement::AnnotationValue::Text(shell_view_name) = &annotation.value {
                    if shell_view_name == WM_SHELLVIEW_APP_LAUNCHER {
                        return Some(ShellViewKind::AppLauncher);
                    }
                }
                break;
            }
        }
    }
    None
}

pub(crate) fn shell_view_name_annotation(name: &str) -> felement::Annotation {
    felement::Annotation {
        key: felement::AnnotationKey {
            namespace: WM_ANNOTATION_NS.to_string(),
            value: WM_ANNOTATION_SHELLVIEW_NAME.to_string(),
        },
        value: felement::AnnotationValue::Text(name.to_string()),
    }
}
