// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use std::io::Cursor;

use anyhow::Error;
use appkit::*;
use either::Either;
use fidl_fuchsia_element as felement;
use fidl_fuchsia_math as fmath;
use fidl_fuchsia_ui_composition as ui_comp;
use fidl_fuchsia_ui_input3::KeyEventStatus;
use fidl_fuchsia_ui_shortcut2 as ui_shortcut2;
use fidl_fuchsia_ui_views as ui_views;
use futures::{
    channel::mpsc::{UnboundedReceiver, UnboundedSender},
    Stream, StreamExt,
};
use indexmap::IndexMap;
use layout::{FloatingLayout, Frame, FrameState, Layout, LayoutChange, Pointer, SetActiveFrame};
use lazy_static::lazy_static;
use num::FromPrimitive;
use tracing::{debug, error, warn};

use crate::{
    frame::WindowFrame,
    shortcuts::{all_shortcuts, ShortcutAction},
};

lazy_static! {
    static ref BACKGROUND_COLOR: ui_comp::ColorRgba = srgb_to_linear(0x263338FF);
}

// The annotation namespace used by the window manager.
pub(crate) const WM_ANNOTATION_NS: &str = "wm_ns";

// The name of the annotation key for the name of the shell view.
pub(crate) const WM_ANNOTATION_SHELLVIEW_NAME: &str = "wm_shellview_name";

// The name of the application launcher shell view.
// Note: This should match the name of the child component in window manager's .CML file.
pub(crate) const WM_SHELLVIEW_APP_LAUNCHER: &str = "app_launcher";

// The list of shell views used in the window manager.
pub(crate) const WM_SHELLVIEWS: &'static [&'static str] = &[WM_SHELLVIEW_APP_LAUNCHER];

// LINT.IfChange
// Height of the app launcher used to subtract from fullscreen height for child views.
// Note: This value should match the APP_LAUNCHER_HEIGHT value in app_launcher package.
const APP_LAUNCHER_HEIGHT: u32 = 32;
// LINT.ThenChange(../../app_launcher/src/main.rs)

// Dimensions of keyboard shortcuts image.
const SHORTCUTS_IMAGE_WIDTH: u32 = 400;
const SHORTCUTS_IMAGE_HEIGHT: u32 = 300;

/// Defines an enumeration of all view types.
#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
pub enum ViewKind {
    ChildView,
    ShellView(ShellViewKind),
}

/// Defines an enumeration of all shell view types.
#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
pub enum ShellViewKind {
    AppLauncher,
}

/// Defines an enumeration of all notifications generated by the window manager.
///
/// This is used in tests to verify correctness and in production to log to inspect.
#[derive(Debug, PartialEq)]
pub(crate) enum Notification {
    // A shell view was added to the window manager.
    AddedShellView { id: ChildViewId, kind: ShellViewKind },
    // A child view was added to the window manager.
    AddedChildView { id: ChildViewId },
    // A child view was removed from the window manager.
    RemovedChildView { id: ChildViewId },
    // Focus moved to either window manager's window or a child view's window.
    FocusChanged { target: Either<WindowId, ChildViewId> },
}

/// Defines a type for holding the state of the window manager.
///
/// The window manager holds child views from applications provided to it by GraphicalPresenter and
/// shell views from components launched by itself. It places them in a certain display order:
///
///                     ----- Bottom -----
///
///              -----window manager background-----
///
///              -----     child views         -----
///
///              -----     shell views         -----
///
///              -----     fullscreen view     -----
///
///                     ----- top -----
///
pub(crate) struct WindowManager {
    // The event sender used to route events.
    event_sender: EventSender,
    // The [Notification] sender used to report notifications generated by the window manager.
    notification_sender: UnboundedSender<Notification>,
    // The main application [Window] of the Window Manager.
    window: Window,
    // The layout manager used to layout all application child views.
    layout: Box<dyn Layout<ChildViewId, WindowFrame>>,
    // The map of all shell views by their [ChildViewId].
    shell_views: IndexMap<ChildViewId, (ChildView, ShellViewKind)>,
    // The flatland content id for background color on the root transform.
    background_content: ui_comp::ContentId,
    // The layer (parent transform) for holding all child views.
    child_views_layer: ui_comp::TransformId,
    // The layer (parent transform) for holding all shell component views.
    shell_views_layer: ui_comp::TransformId,
    // The layer (parent transform) for holding a child view in fullscreen.
    fullscreen_view_layer: ui_comp::TransformId,
    // The child transform to hold the image for keyboard shortcuts.
    shortcuts_image_transform: ui_comp::TransformId,
    // The current width of the application window.
    width: u32,
    // The current height of the application window.
    height: u32,
    // The flag to indicate that WindowManager is ready after receiving the first resize event.
    is_ready: bool,
    // The view specs to present ChildViews that arrived before the main window is created.
    pending_child_view_present_specs: Vec<ViewSpecHolder>,
}

impl WindowManager {
    pub fn new(
        event_sender: EventSender,
        notification_sender: UnboundedSender<Notification>,
        view_creation_token: ui_views::ViewCreationToken,
        pending_child_view_present_specs: Vec<ViewSpecHolder>,
        protocol_connector: Box<dyn ProtocolConnector>,
    ) -> Result<WindowManager, Error> {
        let mut window = Window::new(event_sender.clone())
            .with_view_creation_token(view_creation_token)
            .with_protocol_connector(protocol_connector.box_clone())
            .use_focus_chain_listener(true);
        window.create_view()?;

        let flatland = window.get_flatland();
        let background = window.next_content_id();
        flatland.create_filled_rect(&background)?;
        let mut root_transform_id = window.get_root_transform_id();
        flatland.set_content(&root_transform_id, &background)?;

        let shortcuts_image_transform = window.create_transform(Some(&mut root_transform_id))?;
        let child_views_layer = window.create_transform(Some(&mut root_transform_id))?;
        let shell_views_layer = window.create_transform(Some(&mut root_transform_id))?;
        let fullscreen_view_layer = window.create_transform(Some(&mut root_transform_id))?;

        let layout = Box::new(FloatingLayout::new());

        Ok(WindowManager {
            event_sender,
            notification_sender,
            window,
            layout,
            shell_views: IndexMap::new(),
            background_content: background,
            child_views_layer,
            shell_views_layer,
            fullscreen_view_layer,
            shortcuts_image_transform,
            width: 0,
            height: 0,
            is_ready: false,
            pending_child_view_present_specs,
        })
    }

    // Closes the window of the window manager and initiates shutdown.
    fn close(&mut self) -> Result<(), Error> {
        self.pending_child_view_present_specs.clear();
        self.layout.clear();
        self.shell_views.clear();

        // Calling close() on window manager's window releases its Flatland resources and
        // eventually generates a WindowEvent::Closed event, which exits the event loop.
        self.window.close()
    }

    pub async fn run(
        &mut self,
        mut receiver: impl Stream<Item = Event> + std::marker::Unpin,
    ) -> Result<(), Error> {
        self.window.register_shortcuts(all_shortcuts()).await?;

        // Load the keyboard shortcuts image.
        self.load_shortcuts_image().await?;

        while let Some(event) = receiver.next().await {
            debug!("{:?}", event);
            match event {
                Event::SystemEvent { event } => match event {
                    // Ignore subsequent ViewProvider::CreateView requests. We only allow one
                    // instance of WindowManager to exist.
                    SystemEvent::ViewCreationToken { .. } => {
                        warn!("Received another ViewProvider::CreateView2 request. Ignoring.");
                    }

                    // Create a [ChildView] from GraphicalPresenter's ViewSpec.
                    SystemEvent::PresentViewSpec { view_spec_holder } => {
                        if self.is_ready {
                            let view_kind =
                                view_kind_from_view_spec(&view_spec_holder.view_spec.annotations);

                            match view_kind {
                                ViewKind::ChildView => self.add_child_view(view_spec_holder)?,
                                ViewKind::ShellView(shell_view_kind) => {
                                    self.add_shell_view(view_spec_holder, shell_view_kind)?
                                }
                            }
                            self.window.redraw();
                        } else {
                            self.pending_child_view_present_specs.push(view_spec_holder);
                        }
                    }
                },

                Event::WindowEvent { window_id, event: window_event, .. } => {
                    match window_event {
                        WindowEvent::Closed => break,

                        WindowEvent::Resized { width, height, .. } => {
                            self.resize(width, height)?;
                            self.window.redraw();

                            self.is_ready = true;
                            // Handle any pending childview specs.
                            for view_spec_holder in self.pending_child_view_present_specs.drain(..)
                            {
                                self.event_sender.send(Event::SystemEvent {
                                    event: SystemEvent::PresentViewSpec { view_spec_holder },
                                });
                            }
                        }

                        WindowEvent::Focused { focused } => {
                            if focused {
                                self.notify(Notification::FocusChanged {
                                    target: Either::Left(window_id),
                                })?;
                            }
                        }

                        WindowEvent::Keyboard { responder, .. } => {
                            // Keep keyboard channel happy by always responding.
                            responder.send(KeyEventStatus::NotHandled)?;
                        }

                        WindowEvent::Shortcut { id, responder } => {
                            // Active window is always on top and last in display list. Next
                            // window will be at index 0, whereas previous window will be the
                            // second to last index. Switching to those window will make them
                            // the top window of the display list.
                            if let Some(action) = ShortcutAction::from_u32(id) {
                                match action {
                                    ShortcutAction::FocusNext => {
                                        self.focus_next()?;
                                    }

                                    ShortcutAction::FocusPrev => {
                                        self.focus_previous()?;
                                    }

                                    ShortcutAction::ToggleFullscreen => {
                                        self.toggle_fullscreen()?;
                                    }

                                    ShortcutAction::Close => {
                                        if let Some(child_view_id) = self.layout.get_active() {
                                            self.remove_child_view(child_view_id)?;
                                        }
                                    }

                                    ShortcutAction::Logout => {
                                        self.event_sender.send(Event::Exit);
                                    }
                                }

                                self.window.redraw();
                            } else {
                                error!("Received unknown shortcut invocation: {:?}", id);
                            }

                            responder.send(ui_shortcut2::Handled::Handled)?;
                        }
                        WindowEvent::ChildViewFocused { view_ref, .. } => {
                            // Get the child view with view_ref.
                            for child_view_frame in self.layout.iter() {
                                let child_view_ref = child_view_frame
                                    .get_child_view()
                                    .and_then(|child_view| child_view.get_view_ref())
                                    .expect("Failed to get child view ref");
                                if view_ref_is_same(&child_view_ref, &view_ref) {
                                    self.notify(Notification::FocusChanged {
                                        target: Either::Right(child_view_frame.get_id()),
                                    })?;
                                    break;
                                }
                            }
                        }
                        WindowEvent::Pointer { event } => {
                            let point = fmath::PointF { x: event.logical_x, y: event.logical_y };
                            let delta = fmath::PointF {
                                x: event.logical_delta_x,
                                y: event.logical_delta_y,
                            };
                            let pointer = match event.phase {
                                Phase::Hover => Pointer::Hover { point },
                                Phase::Down => Pointer::Down { point },
                                Phase::Move => Pointer::Move { point, delta },
                                Phase::Up => Pointer::Up { point },
                                Phase::Cancel | Phase::Remove => Pointer::Cancel,
                                Phase::Add => continue,
                            };

                            match self.layout.on_pointer(pointer) {
                                Ok(LayoutChange::DisplayOrder) => self.layout()?,
                                Ok(_) => {}
                                Err(_) => continue,
                            }
                            self.window.redraw();
                        }
                        WindowEvent::NeedsRedraw { .. } => {}
                    }
                }

                Event::ChildViewEvent { child_view_id, event, .. } => match event {
                    ChildViewEvent::Available => {
                        // TODO(sanjayc): Dismiss loading indicator on the frame.
                    }

                    ChildViewEvent::Attached { view_ref } => {
                        if let Some(child_view_frame) = self.layout.get_frame_mut(child_view_id) {
                            child_view_frame
                                .get_child_view_mut()
                                .map(|child_view| child_view.set_view_ref(view_ref));
                            self.refocus()?;
                        } else if let Some((_, kind)) = self.shell_views.get(&child_view_id) {
                            self.notify(Notification::AddedShellView {
                                id: child_view_id,
                                kind: *kind,
                            })?;
                        }
                    }

                    ChildViewEvent::Detached | ChildViewEvent::Dismissed => {
                        self.remove_child_view(child_view_id)?;
                        self.window.redraw();
                    }
                },

                Event::Exit => {
                    self.close()?;
                }

                Event::Init | Event::DeviceEvent | Event::UserEvent(..) => {}
            }
        }

        Ok(())
    }

    async fn load_shortcuts_image(&mut self) -> Result<(), Error> {
        static IMAGE_DATA: &'static [u8] = include_bytes!("../shortcuts.png");
        let (bytes, width, height) = load_png(Cursor::new(IMAGE_DATA)).expect("Failed to load png");
        let shortcuts_image = self.window.create_image_from_bytes(&bytes, width, height).await?;

        let flatland = self.window.get_flatland();
        flatland.set_image_blending_function(
            &shortcuts_image.get_content_id(),
            ui_comp::BlendMode::SrcOver,
        )?;

        self.window
            .set_content(self.shortcuts_image_transform, shortcuts_image.get_content_id())?;
        Ok(())
    }

    // Resizes the background color and child view contents.
    fn resize(&mut self, width: u32, height: u32) -> Result<(), Error> {
        self.width = width;
        self.height = height;

        // Resize the background.
        let flatland = self.window.get_flatland();
        flatland.set_solid_fill(
            &self.background_content,
            &BACKGROUND_COLOR,
            // TODO(fxbug.dev/110653): Mysteriously, Scenic blows up when
            // you make a rectangle the size of the viewport, under very
            // specific circumstances. When that bug is fixed, change this
            // to just width and height.
            &fmath::SizeU {
                width: width.saturating_sub(1).clamp(1, u32::MAX),
                height: height.saturating_sub(1).clamp(1, u32::MAX),
            },
        )?;

        // Position shortcuts image to bottom-right of the screen, above app launcher.
        flatland.set_translation(
            &self.shortcuts_image_transform,
            &fmath::Vec_ {
                x: (width - SHORTCUTS_IMAGE_WIDTH) as i32,
                y: (height - SHORTCUTS_IMAGE_HEIGHT) as i32,
            },
        )?;

        self.layout.set_rect(fmath::Rect {
            x: 0,
            y: 0,
            width: width as i32,
            height: (height - APP_LAUNCHER_HEIGHT) as i32,
        })?;

        self.layout()?;

        Ok(())
    }

    // Layout all child view transforms based on the display order in the layout.
    //
    // The `layout` holds a list of `Frame` object with a flatland transform per frame. Since
    // Flatland does not provide an API to change the order of transforms, we instead set their
    // contents in a display order, back-to-front for each Frame in the layout.
    fn layout(&mut self) -> Result<(), Error> {
        let flatland = self.window.get_flatland();
        for child_view_frame in self.layout.iter() {
            let child_view_transform = child_view_frame.get_frame_transform();
            flatland.remove_child(&self.child_views_layer, &child_view_transform)?;
            flatland.add_child(&self.child_views_layer, &child_view_transform)?;
        }
        self.refocus()?;

        Ok(())
    }

    // Requests focus to the top-most child view.
    fn refocus(&self) -> Result<(), Error> {
        if let Some(child_view_frame) = self.layout.iter().last() {
            if let Some(view_ref) =
                child_view_frame.get_child_view().and_then(|child_view| child_view.get_view_ref())
            {
                let focuser = self.window.get_focuser().expect("Failed to retrieve window focuser");
                set_focus(focuser, view_ref);
            }
        }

        Ok(())
    }

    // Add the child_view as a shell view to shell_view layer.
    fn add_shell_view(
        &mut self,
        view_spec_holder: ViewSpecHolder,
        kind: ShellViewKind,
    ) -> Result<(), Error> {
        let shell_view = self.window.create_child_view(
            view_spec_holder,
            self.width,
            APP_LAUNCHER_HEIGHT,
            self.event_sender.clone(),
        )?;

        let shell_view_id = shell_view.id();
        let shell_view_content_id = shell_view.get_content_id();

        let flatland = self.window.get_flatland();
        let shell_view_transform = self.window.next_transform_id();

        flatland.create_transform(&shell_view_transform)?;
        flatland.set_translation(
            &shell_view_transform,
            &fmath::Vec_ { x: 16, y: self.height as i32 - APP_LAUNCHER_HEIGHT as i32 - 16 },
        )?;

        flatland.add_child(&self.shell_views_layer, &shell_view_transform)?;
        flatland.set_content(&shell_view_transform, &shell_view_content_id)?;

        self.shell_views.insert(shell_view_id, (shell_view, kind));

        Ok(())
    }

    /// Creates a child view from `view_spec_holder` and adds it to the layout.
    fn add_child_view(&mut self, view_spec_holder: ViewSpecHolder) -> Result<(), Error> {
        if let Some(token) = view_spec_holder.view_spec.viewport_creation_token.as_ref() {
            let child_view_id = ChildViewId::from_viewport_creation_token(token);

            // Create a window frame to hold the child view and add it to the layout. We do this
            // before creating the actual child view, because Flatland wants the size information
            // to be supplied before creation.
            let child_view_frame = WindowFrame::new(child_view_id, &mut self.window)?;
            self.layout.add(child_view_frame)?;

            // Get the window frame from the layout to get its size.
            let child_view_frame =
                self.layout.get_frame_mut(child_view_id).expect("Failed to get child view frame");
            let rect = child_view_frame.get_rect()?;

            // Create the child view given it's view_spec, width and height and set it on the frame.
            let child_view = self.window.create_child_view(
                view_spec_holder,
                rect.width as u32,
                rect.height as u32,
                self.event_sender.clone(),
            )?;
            assert_eq!(child_view_id, child_view.id());
            child_view_frame.set_child_view(child_view)?;

            // Add the frame's transform to the window manager's `child_views_layer`.
            let flatland = self.window.get_flatland();
            let child_view_transform = child_view_frame.get_frame_transform();
            flatland.add_child(&self.child_views_layer, &child_view_transform)?;

            self.notify(Notification::AddedChildView { id: child_view_id })?;
        }

        Ok(())
    }

    // Removes a child_view from from the layout.
    fn remove_child_view(&mut self, child_view_id: ChildViewId) -> Result<(), Error> {
        if let Some(child_view_frame) = self.layout.get_frame(child_view_id) {
            // Remove the frame's transform from the window manager's `child_views_layer`.
            let flatland = self.window.get_flatland();
            let child_view_transform = child_view_frame.get_frame_transform();

            flatland.remove_child(&self.child_views_layer, &child_view_transform)?;
            flatland.release_transform(&child_view_transform)?;

            // Remove the child view, by it's id from the layout and update the wm's layout.
            self.layout.remove(child_view_id)?;
            self.layout()?;

            self.notify(Notification::RemovedChildView { id: child_view_id })?;
        }

        Ok(())
    }

    /// Focus to the next-from-last child view, which is at index 0, in the display list.
    fn focus_next(&mut self) -> Result<(), Error> {
        if let Ok(LayoutChange::DisplayOrder) = self.layout.set_active(SetActiveFrame::NextFrame) {
            self.layout()
        } else {
            Ok(())
        }
    }

    /// Focus to the second-to-last child view in the display list.
    fn focus_previous(&mut self) -> Result<(), Error> {
        if let Ok(LayoutChange::DisplayOrder) = self.layout.set_active(SetActiveFrame::PrevFrame) {
            self.layout()
        } else {
            Ok(())
        }
    }

    /// Toggle fullscreen on the currently active child view.
    fn toggle_fullscreen(&mut self) -> Result<(), Error> {
        if let Some(frame_id) = self.layout.get_active() {
            if let Some(state) = self.layout.get_state(frame_id) {
                if state == FrameState::Fullscreen {
                    // Restore back to normal state.
                    self.layout.set_state(frame_id, FrameState::Normal)?;

                    // Reset content of the fullscreen layer.
                    self.window
                        .set_content(self.fullscreen_view_layer, ui_comp::ContentId { value: 0 })?;
                } else {
                    // Set the frame state to fullscreen.
                    self.layout.set_state(frame_id, FrameState::Fullscreen)?;

                    // Set the fullscreen layer content to the child view of the frame.
                    if let Some(child_view) = self
                        .layout
                        .get_frame_mut(frame_id)
                        .and_then(|frame| frame.get_child_view_mut())
                    {
                        self.window
                            .set_content(self.fullscreen_view_layer, child_view.get_content_id())?;
                        child_view.set_size(self.width, self.height)?;
                    }
                }
            }
        }
        Ok(())
    }

    /// Send a notification for changes to window manager state.
    fn notify(&self, notification: Notification) -> Result<(), Error> {
        self.notification_sender.unbounded_send(notification)?;
        Ok(())
    }
}

fn set_focus(focuser: ui_views::FocuserProxy, view_ref: ui_views::ViewRef) {
    spawn_async_on_err(focuser.request_focus(view_ref), |error| {
        error!("Failed to request_focus: {:?}", error)
    });
}

/// Returns the first ViewCreationToken received by ViewProvider service and all requests to
/// present a view to the GraphicalPresenter service, while consuming all other events.
pub async fn get_first_view_creation_token(
    receiver: &mut UnboundedReceiver<Event>,
) -> (ui_views::ViewCreationToken, Vec<ViewSpecHolder>) {
    let mut view_spec_holders = vec![];
    while let Some(event) = receiver.next().await {
        match event {
            Event::Init => continue,
            Event::SystemEvent { event } => match event {
                SystemEvent::ViewCreationToken { token } => {
                    return (token, view_spec_holders);
                }
                SystemEvent::PresentViewSpec { view_spec_holder } => {
                    view_spec_holders.push(view_spec_holder);
                }
            },
            _ => {
                warn!("Ignoring {:?} while waiting for ViewProvider::CreateView2 request", event)
            }
        }
    }
    unreachable!()
}

fn view_kind_from_view_spec(annotations: &Option<Vec<felement::Annotation>>) -> ViewKind {
    let shell_view_name_key = felement::AnnotationKey {
        namespace: WM_ANNOTATION_NS.to_string(),
        value: WM_ANNOTATION_SHELLVIEW_NAME.to_string(),
    };
    // Check annotations for shell view metadata.
    if let Some(annotations) = annotations {
        for annotation in annotations {
            if annotation.key == shell_view_name_key {
                if let felement::AnnotationValue::Text(shell_view_name) = &annotation.value {
                    if shell_view_name == WM_SHELLVIEW_APP_LAUNCHER {
                        return ViewKind::ShellView(ShellViewKind::AppLauncher);
                    }
                }
                break;
            }
        }
    }
    // This is a child view.
    ViewKind::ChildView
}

pub(crate) fn shell_view_name_annotation(name: &str) -> felement::Annotation {
    felement::Annotation {
        key: felement::AnnotationKey {
            namespace: WM_ANNOTATION_NS.to_string(),
            value: WM_ANNOTATION_SHELLVIEW_NAME.to_string(),
        },
        value: felement::AnnotationValue::Text(name.to_string()),
    }
}
