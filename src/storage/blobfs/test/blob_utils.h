// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_STORAGE_BLOBFS_TEST_BLOB_UTILS_H_
#define SRC_STORAGE_BLOBFS_TEST_BLOB_UTILS_H_

#include <lib/fdio/io.h>

#include <cstring>
#include <functional>
#include <memory>
#include <string>

#include <fbl/unique_fd.h>

#include "src/lib/digest/digest.h"
#include "src/storage/blobfs/blob_layout.h"

namespace blobfs {

using BlobSrcFunction = std::function<void(uint8_t* data, size_t length)>;

// An in-memory representation of a blob.
struct BlobInfo {
  char path[PATH_MAX] = {0};
  std::unique_ptr<uint8_t[]> data;
  size_t size_data = 0;

  bool DataEquals(const uint8_t* in_data, size_t in_size) const {
    if (!data || !in_data || in_size != size_data)
      return false;
    return memcmp(data.get(), in_data, in_size) == 0;
  }
};

template <typename T, typename U>
int StreamAll(T func, int fd, U* buf, size_t max) {
  size_t n = 0;
  while (n != max) {
    ssize_t d = func(fd, &buf[n], max - n);
    if (d < 0) {
      return -1;
    }
    n += d;
  }
  return 0;
}

// Fills the provided buffer with a single character |C|.
template <char C>
void CharFill(uint8_t* data, size_t length) {
  memset(data, C, length);
}

// Fills the provided buffer with random data. The contents of the buffer are
// repeatable for any iteration of the test, provided that srand() is seeded with
// the test framework's seed.
void RandomFill(uint8_t* data, size_t length);

// Generates a blob with data generated by a user-provided function.
std::unique_ptr<BlobInfo> GenerateBlob(const BlobSrcFunction& data_generator,
                                       const std::string& mount_path, size_t data_size);

// Generates a blob with random data.
std::unique_ptr<BlobInfo> GenerateRandomBlob(const std::string& mount_path, size_t data_size);

// Generates a blob with realistic data (derived from, for example, an ELF binary).
// This is suitable for test cases which aim to exercise compression, since the blob will compress
// a realistic amount.
std::unique_ptr<BlobInfo> GenerateRealisticBlob(const std::string& mount_path, size_t data_size);

// Verifies that a file contains the data in the provided buffer.
void VerifyContents(int fd, const uint8_t* data, size_t data_size);

// Creates an open blob with the provided Data, and reads back to verify the data.
// Asserts (via ASSERT_* in gtest) that the write and read succeeded.
// TODO(jfsulliv): Return a status, or change the name to indicate that this will assert on failure.
void MakeBlob(const BlobInfo& info, fbl::unique_fd* fd);

// Returns the name of |format| for use in parameterized tests.
std::string GetBlobLayoutFormatNameForTests(BlobLayoutFormat format);

// An in-memory representation of a Merkle tree.
struct MerkleTreeInfo {
  std::unique_ptr<uint8_t[]> merkle_tree;
  uint64_t merkle_tree_size;
  Digest root;
};

// Constructs a Merkle tree for |data|.
std::unique_ptr<MerkleTreeInfo> CreateMerkleTree(const uint8_t* data, uint64_t data_size,
                                                 bool use_compact_format);

}  // namespace blobfs

#endif  // SRC_STORAGE_BLOBFS_TEST_BLOB_UTILS_H_
