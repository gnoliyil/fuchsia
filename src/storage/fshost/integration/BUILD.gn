# Copyright 2021 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/components.gni")
import("//build/rust/rustc_library.gni")
import("//build/rust/rustc_test.gni")
import("//src/storage/fshost/fshost.gni")
import("//src/storage/fshost/generated_fshost_config.gni")
import("//src/storage/testing/driver_test_realm.gni")
import("//tools/cmc/build/cmc.gni")

rustc_library("fshost_test_fixture") {
  edition = "2021"
  testonly = true
  sources = [
    "src/disk_builder.rs",
    "src/fshost_builder.rs",
    "src/lib.rs",
    "src/mocks.rs",
  ]
  deps = [
    "//sdk/fidl/fuchsia.boot:fuchsia.boot_rust",
    "//sdk/fidl/fuchsia.device:fuchsia.device_rust",
    "//sdk/fidl/fuchsia.feedback:fuchsia.feedback_rust",
    "//sdk/fidl/fuchsia.fshost:fuchsia.fshost_rust",
    "//sdk/fidl/fuchsia.hardware.block:fuchsia.hardware.block_rust",
    "//sdk/fidl/fuchsia.io:fuchsia.io_rust",
    "//sdk/fidl/fuchsia.logger:fuchsia.logger_rust",
    "//sdk/fidl/fuchsia.process:fuchsia.process_rust",
    "//sdk/lib/device-watcher/rust",
    "//src/lib/fidl/rust/fidl",
    "//src/lib/fuchsia-component",
    "//src/lib/fuchsia-component-test",
    "//src/lib/fuchsia-fs",
    "//src/lib/fuchsia-runtime",
    "//src/lib/storage/block_client/rust:remote-block-device",
    "//src/lib/storage/fs_management/rust:fs_management",
    "//src/lib/storage/key-bag",
    "//src/lib/storage/ramdevice_client/rust",
    "//src/lib/storage/vfs/rust:vfs",
    "//src/lib/zircon/rust:fuchsia-zircon",
    "//src/storage/bin/blobfs:blobfs-component",
    "//src/storage/bin/minfs:minfs-component",
    "//src/storage/fxfs:fuchsia.fxfs_rust",
    "//src/storage/fxfs:fxfs_component",
    "//src/storage/fxfs-crypt",
    "//src/storage/testing/rust:storage-isolated-driver-manager",
    "//src/sys/lib/cm_rust",
    "//src/sys/pkg/fidl/fuchsia.update.verify:fuchsia.update.verify_rust",
    "//src/sys/pkg/lib/fuchsia-hash",
    "//src/sys/pkg/lib/fuchsia-merkle",
    "//third_party/rust_crates:anyhow",
    "//third_party/rust_crates:futures",
    "//third_party/rust_crates:gpt",
    "//third_party/rust_crates:tracing",
    "//third_party/rust_crates:uuid",
    "//third_party/rust_crates:zerocopy",
    "//third_party/rust_crates:zstd",
    "//third_party/zstd",
  ]
}

# Generates an fshost integration test component. Includes the fshost component on which the test
# is exectuted.
#
#   extra_deps (optional)
#     [array] A list of extra deps
#
#   options.data_filesystem_format (required)
#     [string] The format of the data partition fshost exports. One of "fxfs", "minfs", or "f2fs".
#              The options scope can also contain additional fshost options if required.
#
#   data_filesystem_variant (optional)
#     [string] A variant string passed to the integration test harness. Defaults to the
#              data_filesystem_format.
#
template("fshost_integration_test") {
  assert(defined(invoker.options), "fshost options not specified")
  fshost_options = invoker.options
  if (!defined(invoker.data_filesystem_variant)) {
    invoker.data_filesystem_variant = fshost_options.data_filesystem_format
  }

  _fshost_target = "test-fshost-${target_name}"
  fshost_component_and_config(_fshost_target) {
    testonly = true
    options = invoker.options
    if (!defined(options.use_disk_migration)) {
      options.use_disk_migration = true
    }
  }

  _fshost_component_name = get_label_info(_fshost_target, "name")
  _test_bin = string_replace(target_name, "-", "_")
  _test_bin = "${_test_bin}_bin"
  rustc_test(_test_bin) {
    edition = "2021"
    source_root = "tests/fshost_integration_test.rs"
    sources = [
      "tests/fshost_integration_test.rs",
      "tests/migration.rs",
      "tests/wipe_storage.rs",
      "tests/write_data_file.rs",
    ]
    rustenv = [
      "FSHOST_COMPONENT_NAME=${_fshost_component_name}",
      "DATA_FILESYSTEM_FORMAT=${fshost_options.data_filesystem_format}",
      "DATA_FILESYSTEM_VARIANT=${invoker.data_filesystem_variant}",
    ]
    features = [
      fshost_options.data_filesystem_format,
      invoker.data_filesystem_variant,
    ]
    deps = [
      ":fshost_test_fixture",
      "//sdk/fidl/fuchsia.fshost:fuchsia.fshost_rust",
      "//sdk/fidl/fuchsia.hardware.block:fuchsia.hardware.block_rust",
      "//sdk/fidl/fuchsia.hardware.block.partition:fuchsia.hardware.block.partition_rust",
      "//sdk/fidl/fuchsia.hardware.block.volume:fuchsia.hardware.block.volume_rust",
      "//sdk/fidl/fuchsia.io:fuchsia.io_rust",
      "//sdk/lib/device-watcher/rust",
      "//src/lib/fidl/rust/fidl",
      "//src/lib/fuchsia",
      "//src/lib/fuchsia-async",
      "//src/lib/fuchsia-component",
      "//src/lib/fuchsia-fs",
      "//src/lib/storage/block_client/rust:remote-block-device",
      "//src/lib/storage/fs_management/rust:fs_management",
      "//src/lib/zircon/rust:fuchsia-zircon",
      "//third_party/rust_crates:assert_matches",
      "//third_party/rust_crates:futures",
      "//third_party/rust_crates:tracing",
    ]
    if (defined(invoker.extra_deps)) {
      deps += invoker.extra_deps
    }
  }

  _shard_target = "${target_name}-shard"
  generated_file(_shard_target) {
    testonly = true
    contents = {
      program = {
        binary = "bin/${_test_bin}"
      }
    }
    outputs = [ "${target_out_dir}/${_shard_target}.cml" ]
    output_conversion = "json"
    visibility = [ ":*" ]
  }
  _shard = get_target_outputs(":$_shard_target")
  _shard = _shard[0]

  _manifest_target = "${target_name}-manifest.cml"
  cmc_merge("$_manifest_target") {
    testonly = true
    sources = [
      "meta/fshost_integration_test.cml",
      _shard,
    ]
    deps = [ ":$_shard_target" ]
  }
  _manifest = get_target_outputs(":$_manifest_target")
  _manifest = _manifest[0]

  fuchsia_test_component(target_name) {
    manifest = _manifest
    deps = [
      ":$_fshost_target",
      ":$_manifest_target",
      ":$_test_bin",
    ]
  }
}

fshost_integration_test("fshost_integration_tests_fxfs") {
  options = {
    data_filesystem_format = "fxfs"
  }
}

fshost_integration_test("fshost_integration_tests_f2fs") {
  options = {
    data_filesystem_format = "f2fs"
  }
}

fshost_integration_test("fshost_integration_tests_minfs") {
  options = {
    data_filesystem_format = "minfs"
  }
}

fshost_integration_test("fshost_integration_tests_fxfs_fxblob") {
  data_filesystem_variant = "fxblob"
  options = {
    fxfs_blob = true
    data_filesystem_format = "fxfs"
    use_disk_migration = false
  }
  extra_deps =
      [ "//src/sys/pkg/fidl/fuchsia.update.verify:fuchsia.update.verify_rust" ]
}

fshost_integration_test("fshost_integration_tests_f2fs_no_zxcrypt") {
  data_filesystem_variant = "f2fs-no-zxcrypt"
  options = {
    no_zxcrypt = true
    data_filesystem_format = "f2fs"
  }
}

fshost_integration_test("fshost_integration_tests_minfs_no_zxcrypt") {
  data_filesystem_variant = "minfs-no-zxcrypt"
  options = {
    no_zxcrypt = true
    data_filesystem_format = "minfs"
  }
}

fuchsia_test_package("fshost_integration_tests") {
  # Currently required because the data_formatted test causes Fxfs to log:
  #   ERROR: ... handle_start failed error=Journal replay failed
  test_specs = {
    log_settings = {
      max_severity = "ERROR"
    }
  }
  test_components = [
    ":fshost_integration_tests_fxfs",
    ":fshost_integration_tests_f2fs",
    ":fshost_integration_tests_minfs",
    ":fshost_integration_tests_f2fs_no_zxcrypt",
    ":fshost_integration_tests_minfs_no_zxcrypt",
    ":fshost_integration_tests_fxfs_fxblob",
  ]
  deps = [ "//src/storage/testing:storage_driver_test_realm" ]
}

group("tests") {
  testonly = true
  deps = [ ":fshost_integration_tests" ]
}
