# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/components.gni")
import("//build/rust/rustc_binary.gni")
import("//src/starnix/kernel/starnix.gni")

# Declare an inferior with a default manifest.
template("inferior") {
  _target_name = target_name
  _target_bin = target_name + "_bin"
  _target_manifest = target_name + "_manifest"

  _type = "executable"
  if (defined(invoker.type)) {
    _type = invoker.type
  }

  target(_type, _target_bin) {
    output_name = _target_name
    forward_variables_from(invoker, "*")
  }

  generated_file(_target_manifest) {
    outputs = [ "$target_gen_dir/$_target_manifest.cml" ]
    output_conversion = "json"
    contents = {
      include = [ "syslog/client.shard.cml" ]
      program = {
        runner = "elf"
        binary = "bin/$_target_name"
      }
    }
  }

  fuchsia_component(_target_name) {
    manifest = "$target_gen_dir/$_target_manifest.cml"
    deps = [
      ":$_target_bin",
      ":$_target_manifest",
    ]
  }
}

inferior("step_plt") {
  sources = [ "step_plt.cc" ]
  cflags = [ "-finline-functions" ]  # inline std::make_shared.
}

inferior("wait_for_debugger") {
  sources = [ "wait_for_debugger.cc" ]
  deps = [ "//src/lib/debug" ]
}

inferior("inlined_crasher") {
  sources = [ "inlined_crasher.cc" ]
}

inferior("bitfield") {
  sources = [ "bitfield.cc" ]
}

inferior("loop") {
  sources = [ "loop.cc" ]

  # Ensure std::ostream << doesn't get inlined.
  cflags = [ "-fno-inline-functions" ]
}

inferior("async_rust") {
  type = "rustc_binary"
  edition = "2021"
  sources = [ "async_rust.rs" ]
  source_root = "async_rust.rs"
  deps = [
    "//src/lib/fuchsia-async",
    "//third_party/rust_crates:futures",
  ]
}

inferior("simplified_templates") {
  sources = [ "simplified_templates.cc" ]
  deps = [ "//src/lib/debug" ]

  # Never optimize this since we are relying on the variables to be present.
  cflags = [
    "-gsimple-template-names",
    "-fno-inline-functions",
  ]
}

inferior("template_functions") {
  sources = [ "template_functions.cc" ]
  deps = [ "//src/lib/debug" ]
}

inferior("cpp_functions") {
  sources = [ "cpp_functions.cc" ]

  cflags = [ "-fno-inline-functions" ]
}

inferior("pretty_types") {
  sources = [ "pretty_types.cc" ]
}

inferior("rust_functions") {
  type = "rustc_binary"
  edition = "2021"
  sources = [ "rust_functions.rs" ]
  source_root = "rust_functions.rs"
}

## Starnix

if (is_linux) {
  executable("hello_starnix_bin") {
    output_name = "hello_starnix"
    sources = [ "hello_starnix.cc" ]
  }
}

# By default, executables in another toolchain will not be included in the package.
resource("hello_starnix_resource") {
  out_dir = get_label_info(":hello_starnix_bin($target_linux_toolchain)",
                           "root_out_dir")
  sources = [ "${out_dir}/hello_starnix" ]

  # Cannot be in /bin because it's not a Fuchsia executable.
  outputs = [ "data/bin/hello_starnix" ]
  deps = [ ":hello_starnix_bin($target_linux_toolchain)" ]
}

fuchsia_component("hello_starnix") {
  deps = [ ":hello_starnix_resource" ]
  manifest = "hello_starnix.cml"
}

fuchsia_package("zxdb_e2e_inferiors") {
  deps = [
    ":async_rust",
    ":bitfield",
    ":cpp_functions",
    ":inlined_crasher",
    ":loop",
    ":pretty_types",
    ":rust_functions",
    ":simplified_templates",
    ":step_plt",
    ":template_functions",
    ":wait_for_debugger",
  ]

  # Starnix
  deps += [
    ":hello_starnix",
    "//src/starnix/containers:data_tmp_target",
    "//src/starnix/containers:default_init",
    "//src/starnix/containers/debian:system_image",
  ]
  subpackages = [ "//src/starnix/kernel:starnix_kernel_package" ]
}
