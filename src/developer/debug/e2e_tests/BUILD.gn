# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/compiler.gni")
import("//build/host.gni")
import("//build/test.gni")
import("//build/testing/environments.gni")
import("//build/testing/host_test_data.gni")
import("//build/zircon/c_utils.gni")
import("//src/developer/ffx/config.gni")
import("//zircon/system/ulib/c/libc_toolchain.gni")

if (is_host) {
  # Directory to store debug symbols, which are required for the e2e test to run.
  # The path is relative to the $root_out_dir, where zxdb_e2e_tests binary lives.
  symbol_dir = "test_data/zxdb_e2e_tests/build-id"

  test("zxdb_e2e_tests") {
    sources = [
      "e2e_test.cc",
      "e2e_test.h",
      "ffx_debug_agent_bridge.cc",
      "ffx_debug_agent_bridge.h",
      "fuzzy_matcher.cc",
      "fuzzy_matcher.h",
      "main.cc",
      "script_test.cc",
      "script_test.h",
      "test_run_failing_test_component.cc",
    ]

    deps = [
      # In variant builds the variant version of the test executable will be run. However, the test
      # will expect it can still run the host_x64 default variant of ffx, which is still built
      # regardless of build variant. But a simple dependency here would try to build an ASAN variant
      # of ffx, which creates a conflict because then there are two ffx binaries in the path of the
      # existing tooling, which causes the infra builds (and local attempts to invoke ffx) to fail
      # horribly. ${toolchain_variant.base} specifies specifically to depend on the normal
      # non-variant version of ffx that's built all the time so we don't create a second copy, and
      # can expect the path to be consistent and predictable.
      ":zxdb_e2e_test_data(${toolchain_variant.base})",
      "//src/developer/debug/shared",
      "//src/developer/debug/zxdb/client",
      "//src/developer/debug/zxdb/common:test_support",
      "//src/developer/debug/zxdb/console:test_support",
      "//src/developer/debug/zxdb/symbols:test_support",
      "//src/developer/ffx:test_data",
      "//src/developer/ffx/plugins/debug:ffx_debug_plugin_tool_test_data",
      "//src/lib/fxl/test:test_settings",
      "//third_party/googletest:gtest",
    ]

    # The location of ffx binary and metadata (including ffx and the ffx-debug
    # subtool) test data directory for the test to be able to find them.
    _ffx_test_data_path = rebase_path(ffx_test_host_tools_out_dir, root_out_dir)

    _is_lto = select_variant + [ "lto" ] - [ "lto" ] != select_variant

    defines = [
      "ZXDB_E2E_TESTS_BUILD_TYPE=\"optimize=$optimize:target_cpu=$target_cpu:is_lto=$_is_lto\"",
      "ZXDB_E2E_TESTS_SYMBOL_DIR=\"${symbol_dir}\"",
      "ZXDB_E2E_TESTS_SCRIPTS_DIR=\"" + rebase_path("scripts", root_out_dir) +
          "\"",
      "ZXDB_E2E_TESTS_FFX_TEST_DATA=\"" + _ffx_test_data_path + "\"",
    ]

    environments = all_fuchsia_envs

    # TODO(fxbug.dev/108369): Disable this test for sherlock and vim3 because we're seeing higher
    # flake rates than in any other environments due to the FFX bug.
    environments -= [
      sherlock_env,
      vim3_env,
    ]

    # TODO(fxbug.dev/64897): The arm64 emulator is run from an arm64 host but we only support
    # running tests on x64 hosts.
    if (target_cpu == "arm64") {
      environments -= [ emu_env ]
    }
  }

  host_test_data("zxdb_e2e_test_data") {
    sources = [
      # This directory will be generated by the "copy_symbols" action below.
      "$root_out_dir/$symbol_dir",

      # Test scripts.
      "scripts",
    ]

    deps = [ ":copy_unstripped_binaries" ]
  }

  unstripped_binaries_list_file = "$target_gen_dir/unstripped_binaries.list"

  # This action takes the output of the link_output_rspfile target and copies them into the
  # $symbol_dir directory.
  action("copy_unstripped_binaries") {
    testonly = true
    script = "copy_unstripped_binaries.py"

    inputs = [ unstripped_binaries_list_file ]
    deps = [ ":unstripped_binaries_list" ]

    outputs = [ "$root_out_dir/$symbol_dir" ]

    # depfile lists the copied files so the action is hermetic.
    depfile = "$target_out_dir/copy_unstripped_binaries.d"

    args = []
    foreach(path, inputs + outputs) {
      args += [ rebase_path(path, root_build_dir) ]
    }
    args += [ rebase_path(depfile, root_build_dir) ]

    # To also copy libc.so.debug, we should be able to add |sysroot_libc_target| to the deps of
    # link_output_rspfile below and reuse the same logic. However, that target is not visible to us.
    # As a workaround, we can tell the copy_unstripped_binaries.py script where the unstripped libc
    # is and the script could create the dependency in its depfile.
    args += [ rebase_path(sysroot_libc_unstripped, root_build_dir) ]
  }

  # This action generates a file that contains a list of all unstripped binaries (symbol files)
  # that get linked in its dependency.
  link_output_rspfile("unstripped_binaries_list") {
    testonly = true
    outputs = [ unstripped_binaries_list_file ]

    deps = [
      "inferiors:zxdb_e2e_inferiors($target_toolchain)",
      "//src/developer/forensics/crasher:crasher($target_toolchain)",
      "//src/developer/forensics/crasher:crasher_test($target_toolchain)",
    ]
  }
}

group("tests") {
  testonly = true

  deps = [ ":zxdb_e2e_tests($host_toolchain)" ]
}
