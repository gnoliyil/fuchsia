// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use base64::display::Base64Display;
use ffx_config::{api::ConfigError, query};
use ring::{
    rand::{self, SystemRandom},
    signature::{Ed25519KeyPair, KeyPair},
};
use serde::Serialize;
use std::{
    error::Error,
    fmt,
    fs::{self, DirBuilder, File, OpenOptions},
    io::{BufRead, BufReader, Cursor, Read, Write},
    os::unix::fs::{DirBuilderExt, OpenOptionsExt, PermissionsExt},
    path::PathBuf,
    str,
};

#[derive(Debug, Clone, Eq, PartialEq, Serialize)]
pub enum SshKeyErrorKind {
    BadKeyType,
    BadBase64Encoding,
    BadConfiguration,
    BadFilePermission,
    BadKeyFormat,
    BadUTFEncoding,
    GenerationError,
    IOError,
    KeyMismatch,
    FileNotFound,
}

impl fmt::Display for SshKeyErrorKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{self:?}")
    }
}

#[derive(Debug, Clone)]
struct SshKeyInternalError {
    pub kind: SshKeyErrorKind,
    pub message: String,
}

#[derive(Debug, Clone)]
pub struct SshKeyError {
    pub kind: SshKeyErrorKind,
    pub message: String,
}
impl fmt::Display for SshKeyInternalError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:{}", self.kind, self.message)
    }
}
impl fmt::Display for SshKeyError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:{}", self.kind, self.message)
    }
}

impl Error for SshKeyError {}

impl From<std::io::Error> for SshKeyInternalError {
    fn from(value: std::io::Error) -> Self {
        SshKeyInternalError { kind: SshKeyErrorKind::IOError, message: format!("{value:?}") }
    }
}

impl From<str::Utf8Error> for SshKeyInternalError {
    fn from(value: str::Utf8Error) -> Self {
        SshKeyInternalError { kind: SshKeyErrorKind::BadUTFEncoding, message: format!("{value:?}") }
    }
}

impl From<base64::DecodeError> for SshKeyInternalError {
    fn from(value: base64::DecodeError) -> Self {
        SshKeyInternalError {
            kind: SshKeyErrorKind::BadBase64Encoding,
            message: format!("{value:?}"),
        }
    }
}

impl From<ConfigError> for SshKeyError {
    fn from(value: ConfigError) -> Self {
        SshKeyError { kind: SshKeyErrorKind::BadConfiguration, message: format!("{value:?}") }
    }
}

impl From<SshKeyInternalError> for SshKeyError {
    fn from(value: SshKeyInternalError) -> Self {
        let kind = match value.kind {
            SshKeyErrorKind::BadBase64Encoding | SshKeyErrorKind::BadUTFEncoding => {
                SshKeyErrorKind::BadKeyFormat
            }
            _ => value.kind,
        };
        SshKeyError { kind: kind, message: value.message }
    }
}

/// Paths to the private and public SSH keys that are used by ffx.
/// These can be loaded from the configuration keys `ssh.pub`
/// and `ssh.priv` by using SshKeyFiles::load().
/// Typical usage is to load from the configuration and then create the keys
/// if they are missing when initializing a device via flashing/paving
///  or starting an emulator instance.
///
/// let ssh_keys = SshKeyFiles::load().await?;
/// ssh_keys.create_keys_if_needed()?;
///
/// This is preferred since generating the private key when attempting to access
/// a device already initialized is pointless.
///
///
#[derive(Debug, Default)]
pub struct SshKeyFiles {
    pub authorized_keys: PathBuf,
    pub private_key: PathBuf,
}

const KEYTYPE_STR: &str = "ssh-ed25519";
const KEYTYPE: &[u8] = b"ssh-ed25519";
const COMMENT: &str = "Generated by ffx for Fuchsia";
const AUTH_MAGIC: &[u8] = b"openssh-key-v1\0";

impl SshKeyFiles {
    /// loads the file paths from the config properties `ssh.pub` and `ssh.priv`.
    /// If none of the paths configured are to files that exist, the paths will
    ///  be set to the default locations, which is the first element in the config settings.
    pub async fn load() -> Result<Self, SshKeyError> {
        // initialize to the first path in the list, then iterate through the list to select
        // the first file that exists.
        let authorized_keys_files: Vec<PathBuf> = query("ssh.pub").get().await?;
        if authorized_keys_files.is_empty() {
            return Err(SshKeyError {
                kind: SshKeyErrorKind::BadConfiguration,
                message: "No paths configured for `ssh.pub`.".into(),
            });
        }
        let mut authorized_keys = authorized_keys_files[0].to_path_buf();
        for path in &authorized_keys_files {
            if path.exists() {
                authorized_keys = path.to_path_buf();
                break;
            }
        }

        let key_files: Vec<PathBuf> = query("ssh.priv").get().await?;
        if key_files.is_empty() {
            return Err(SshKeyError {
                kind: SshKeyErrorKind::BadConfiguration,
                message: format!("No paths configured for `ssh.priv`."),
            });
        }
        let mut private_key = key_files[0].to_path_buf();
        for path in &key_files {
            if path.exists() {
                private_key = path.to_path_buf();
                break;
            }
        }
        Ok(SshKeyFiles { authorized_keys, private_key })
    }

    /// Generates the ed25519 key pair and saves openssh authorized_keys and private key file,
    /// if the paths point to files that do not exist.
    pub fn create_keys_if_needed(&self) -> Result<(), SshKeyError> {
        let mut public_key: Vec<u8> = vec![];
        let mut do_write_public_key = false;

        // Validate the paths are non-empty
        if self.private_key.display().to_string().is_empty() {
            return Err(SshKeyError {
                kind: SshKeyErrorKind::BadConfiguration,
                message: "private key path cannot be empty".into(),
            });
        }
        if self.authorized_keys.display().to_string().is_empty() {
            return Err(SshKeyError {
                kind: SshKeyErrorKind::BadConfiguration,
                message: "authorized keys path cannot be empty".into(),
            });
        }

        if !self.private_key.exists() {
            // There is no private key, so generate a new key pair
            // resulting in a byte array .der encoded.
            eprintln!("Creating SSH key pair: {}", self.private_key.display());
            let rng = SystemRandom::new();
            let bytes = Ed25519KeyPair::generate_pkcs8(&rng).map_err(|m| SshKeyError {
                kind: SshKeyErrorKind::GenerationError,
                message: format!("could not generate pkcs8 document: {:?}", m),
            })?;
            let key_pair = Ed25519KeyPair::from_pkcs8(bytes.as_ref()).map_err(|m| SshKeyError {
                kind: SshKeyErrorKind::GenerationError,
                message: format!("could not get keypair from pkcs8 document: {:?}", m),
            })?;

            write_private_key(&self.private_key, &key_pair, bytes.as_ref(), &rng)?;
            public_key = key_pair.public_key().as_ref().to_vec();
            do_write_public_key = true;
        } else if !self.authorized_keys.exists() {
            // If we get here we need to get the public key from the private key.
            // If reading fails, the file is corrupted or it is not the format expected.
            // The easiest corrective action would be for the user to delete the file or generate authorized keys using ssh-keygen.
            // Since there is no way to know if the key is being used, an error is returned since   there is no safe way to continue
            // and make sure the keys are valid.
            let key_type: String;
            (key_type, public_key) = read_public_key_from_private(&self.private_key)?;

            //write out the public key, only if the key type is OK
            // ffx by default uses ed25519 keys. If the private key is something else (for example rsa), print
            // bail giving instructions on how to generate the public key.
            if key_type != KEYTYPE_STR {
                return Err(SshKeyError {
                    kind: SshKeyErrorKind::BadKeyType,
                    message: format!("The private key in {priv} is type {key_type}. This program can only verify ed25529 keys.\
            \n To re-add the public key to {auth}, run\
            \n ssh-keygen -y -f {priv} >> {auth}", priv=self.private_key.to_string_lossy(), auth=self.authorized_keys.to_string_lossy()),
                });
            }
            do_write_public_key = true;
        }

        if do_write_public_key {
            // check to write the authorized keys file for when the private existed, and when it was generated.
            write_public_key(&self.authorized_keys, &public_key).map_err(|e| SshKeyError {
                kind: SshKeyErrorKind::IOError,
                message: format!("{e}"),
            })?;
        }

        Ok(())
    }

    pub fn check_keys(&self, repair_if_needed: bool) -> Result<String, SshKeyError> {
        let mut message: String = String::from("");
        let mut del_priv_key = false;
        let mut recreate_keys = false;

        match self.analyze_check_keys() {
            Ok(_) => {
                tracing::info!("SSH Public/Private keys match");
                return Ok("SSH Public/Private keys match".into());
            }
            Err(e) => {
                if !repair_if_needed {
                    return Err(e);
                }
                match e.kind {
                    SshKeyErrorKind::BadKeyType => return Err(e),
                    SshKeyErrorKind::BadKeyFormat => {
                        recreate_keys = true;
                        del_priv_key = true;
                        message = format!("{}. Regenerating a private key.", e.message)
                    }
                    SshKeyErrorKind::BadFilePermission => {
                        let meta = self.private_key.metadata().map_err(|e| SshKeyError {
                            kind: SshKeyErrorKind::IOError,
                            message: format!("{e}"),
                        })?;
                        let mut permissions = meta.permissions();
                        permissions.set_mode(0o600);
                        fs::set_permissions(&self.private_key, permissions).map_err(|e| {
                            SshKeyError { kind: SshKeyErrorKind::IOError, message: format!("{e}") }
                        })?;
                    }
                    _ => recreate_keys = true,
                };
            }
        };

        if recreate_keys {
            if del_priv_key && self.private_key.exists() {
                fs::remove_file(&self.private_key).map_err(|e| SshKeyError {
                    kind: SshKeyErrorKind::IOError,
                    message: format!("Cannot delete {:?}: {e}", self.private_key),
                })?;
            }
            match self.create_keys_if_needed() {
                Ok(_) => message = format!("{message}\nKeys repaired."),
                Err(e) => {
                    // If there was an error, print it, delete the keys,
                    // and recreate.
                    tracing::error!("Error repairing SSH keys {e:?}. Please check configuration and/or delete existing key files and retry.");

                    return Err(e);
                }
            };
        }

        Ok(message)
    }

    /// Checks that the corresponding public key from the private key file
    /// is listed in the authorized keys file.
    fn analyze_check_keys(&self) -> Result<(), SshKeyError> {
        if !self.private_key.exists() {
            return Err(SshKeyError {
                kind: SshKeyErrorKind::FileNotFound,
                message: format!(
                    "Private key {} does not exist",
                    self.private_key.to_string_lossy()
                ),
            });
        } else {
            let meta = self.private_key.metadata().map_err(|e| SshKeyError {
                kind: SshKeyErrorKind::IOError,
                message: format!("{e}"),
            })?;
            let mode = meta.permissions().mode();
            if mode != 0o100600 {
                return Err(SshKeyError { kind: SshKeyErrorKind::BadFilePermission,
                    message:format!("Private key {} has the wrong file permissions. SSH requires 0o600, found {mode:#o}",self.private_key.display())});
            }
        }
        if !self.authorized_keys.exists() {
            return Err(SshKeyError {
                kind: SshKeyErrorKind::FileNotFound,
                message: format!(
                    "Authorized key file {} does not exist",
                    self.authorized_keys.to_string_lossy()
                ),
            });
        }

        let (key_type, public_key) = match read_public_key_from_private(&self.private_key) {
            Ok((key_type, public_key)) => (key_type, public_key),
            Err(e) => {
                tracing::debug!("Internal error for read_public_key_from_private: {e:?}");
                return Err(SshKeyError {
                    kind: SshKeyErrorKind::BadKeyFormat,
                    message: format!(
                        "Could not read data from private key {}",
                        self.private_key.display()
                    ),
                });
            }
        };
        let entry = build_public_key_entry(&key_type, &public_key).map_err(|e| SshKeyError {
            kind: SshKeyErrorKind::BadKeyFormat,
            message: format!("{e}"),
        })?;

        // ffx by default uses ed25519 keys. If the private key is something else (for example rsa), print
        // bail giving instructions on how to generate the public key.
        if key_type != KEYTYPE_STR {
            return Err(SshKeyError {
                kind: SshKeyErrorKind::BadKeyType,
                message: format!("The private key in {priv} is type {key_type}. This program can only verify ed25529 keys.\
            \n To re-add the public key to {auth}, run\
            \n ssh-keygen -y -f {priv} >> {auth}", priv=self.private_key.to_string_lossy(), auth=self.authorized_keys.to_string_lossy()),
            });
        }

        let file = File::open(&self.authorized_keys)
            .map_err(|e| SshKeyError { kind: SshKeyErrorKind::IOError, message: format!("{e}") })?;
        // Read the file line by line, and return an iterator of the lines of the file.
        // Note: This check is only for the keys that could be generated by ad-hoc or by ffx directly and used
        // on the target Fuchsia device to secure the ssh connection to the device.
        // Specifically, we're loooking for a ssh-ed25519 key type that is not part of a key ring. Optional
        // fields before the key type are not expected.
        if !BufReader::new(file)
            .lines()
            .into_iter()
            .map(|l| l.unwrap())
            .any(|l| l.starts_with(&entry))
        {
            return Err(SshKeyError {
                kind: SshKeyErrorKind::KeyMismatch,
                message: format!(
                    "Could not find matching public key for the private key {}",
                    self.private_key.to_string_lossy()
                ),
            });
        }
        Ok(())
    }
}

/// Formats the key data for the authorized_keys file.
fn get_public_key_data(pubkey: &[u8]) -> Result<Vec<u8>, std::io::Error> {
    let mut out_bytes: Vec<u8> = vec![];

    // public key is 2 "cstrings", which are strings with no null terminator preceded by the
    // length.
    write_cstring(&mut out_bytes, KEYTYPE)?;
    write_cstring(&mut out_bytes, pubkey)?;

    Ok(out_bytes)
}

/// Builds the authorized_keys entry for the given public key.
fn build_public_key_entry(key_type: &str, public_key: &[u8]) -> Result<String, std::io::Error> {
    let public_key_data = get_public_key_data(public_key)?;
    let pubkey_b64 = Base64Display::with_config(&public_key_data, base64::STANDARD);
    Ok(format!("{} {}", key_type, pubkey_b64))
}

/// Appends the public key information to the authorized_keys file.
fn write_public_key(path: &PathBuf, public_key: &[u8]) -> Result<(), SshKeyInternalError> {
    eprintln!("Writing authorized_keys file: {}", path.display());

    let mut w = if !path.exists() {
        if let Some(parent) = path.parent() {
            DirBuilder::new().recursive(true).mode(0o700).create(parent)?;
        };
        OpenOptions::new().write(true).read(true).create_new(true).mode(0o600).open(&path)?
    } else {
        // append to the file.
        OpenOptions::new().write(true).append(true).open(&path)?
    };
    writeln!(
        &mut w,
        "{} {}",
        build_public_key_entry(str::from_utf8(KEYTYPE)?, public_key)?,
        COMMENT
    )?;
    // File is closed when it goes out of scope.
    Ok(())
}

/// Writes the private key file.
fn write_private_key(
    path: &PathBuf,
    key_pair: &Ed25519KeyPair,
    document: &[u8],
    rng: &SystemRandom,
) -> Result<(), SshKeyInternalError> {
    // private key file
    let none = b"none";

    // magic pattern to identify this data, null terminated.
    let mut priv_out_bytes: Vec<u8> = vec![];
    priv_out_bytes.write_all(AUTH_MAGIC)?;

    // ciphername
    write_cstring(&mut priv_out_bytes, none)?;

    // kdfname (none), and length 0
    write_cstring(&mut priv_out_bytes, none)?;
    priv_out_bytes.write_all(&[0, 0, 0, 0])?;

    // number of keys, always 1.
    priv_out_bytes.write_all(&[0, 0, 0, 1])?;

    // public key - this is the same contents as appears in the authorized_keys file.
    let public_key_data = get_public_key_data(key_pair.public_key().as_ref())?;
    write_cstring(&mut priv_out_bytes, &public_key_data)?;

    // private key.
    let mut key_bytes: Vec<u8> = vec![];

    // random u32 checkbytes, write it 2 times.
    let rand_bytes: [u8; 4] = rand::generate(rng).unwrap().expose();
    key_bytes.write_all(&rand_bytes)?;
    key_bytes.write_all(&rand_bytes)?;

    // The type of key.
    write_cstring(&mut key_bytes, KEYTYPE)?;

    // Extract the secret part of the key from the pkcs8 document.
    // the first 16 bytes are the version and algorithm oid. The private
    // key data starts at 16, and is 32 bytes
    // secret key, should be 32 bytes.
    let secret = &document[16..48];

    // pub key 32 bytes.
    write_cstring(&mut key_bytes, key_pair.public_key().as_ref())?;

    // the private key is the secret with the public appended for a
    // total of 64 bytes.
    let mut private_key_data: Vec<u8> = Vec::from(secret);
    private_key_data.extend_from_slice(key_pair.public_key().as_ref());
    write_cstring(&mut key_bytes, &private_key_data)?;

    // add the comment.
    write_cstring(&mut key_bytes, COMMENT.as_bytes())?;

    // padding
    let mut i: u8 = 0;
    while key_bytes.len() % 8 != 0 {
        i += 1;
        key_bytes.write_all(&[i])?;
    }

    write_cstring(&mut priv_out_bytes, &key_bytes)?;

    let begin = "-----BEGIN OPENSSH PRIVATE KEY-----\n";
    let end = "-----END OPENSSH PRIVATE KEY-----\n";

    if let Some(parent) = path.parent() {
        DirBuilder::new().recursive(true).mode(0o700).create(parent)?;
    };
    let mut w =
        OpenOptions::new().write(true).read(true).create_new(true).mode(0o600).open(&path)?;
    writeln!(&mut w, "{}", begin)?;
    writeln!(&mut w, "{}", Base64Display::with_config(&priv_out_bytes, base64::STANDARD))?;
    writeln!(&mut w, "{}", end)?;
    // File is closed when it goes out of scope.
    Ok(())
}

/// Reads the public key from the private key file.
fn read_public_key_from_private(path: &PathBuf) -> Result<(String, Vec<u8>), SshKeyInternalError> {
    let mut started = false;
    let mut encoded: String = String::from("");
    let priv_key_file = File::open(path)?;
    for line_result in BufReader::new(priv_key_file).lines() {
        let line = line_result?;
        if line.starts_with("----") && line.contains("BEGIN OPENSSH PRIVATE KEY") {
            started = true;
            continue;
        }
        if line.starts_with("----") && line.contains("END OPENSSH PRIVATE KEY") {
            //done
            break;
        }
        if started {
            // append all lines be between begin and end, trimming whitespace.
            encoded.push_str(line.trim());
        }
    }
    // decode the base64 string into bytes.
    let data = base64::decode(&encoded)?;
    let mut buf = Cursor::new(data);

    let mut element: Vec<u8> = vec![];

    // read the magic, it is null terminated.
    buf.read_until(0, &mut element)?;
    if element != AUTH_MAGIC {
        return Err(SshKeyInternalError {
            kind: SshKeyErrorKind::BadKeyFormat,
            message: format!("Invalid private key header {:?}", &element),
        });
    }

    // read cipher and kdf settings, both none.
    element = read_cstring(&mut buf)?;
    if "none" != str::from_utf8(&element)? {
        return Err(SshKeyInternalError {
            kind: SshKeyErrorKind::BadKeyFormat,
            message: format!("Invalid private key header, expected 'none' {:?}", &element),
        });
    }
    element = read_cstring(&mut buf)?;
    if "none" != str::from_utf8(&element)? {
        return Err(SshKeyInternalError {
            kind: SshKeyErrorKind::BadKeyFormat,
            message: format!("Invalid private key header, expected 'none' {:?}", &element),
        });
    }
    let mut u32_bytes = [0u8; 4];
    buf.read_exact(&mut u32_bytes)?;
    if u32::from_be_bytes(u32_bytes) != 0 {
        return Err(SshKeyInternalError {
            kind: SshKeyErrorKind::BadKeyFormat,
            message: format!("Invalid private key header, expected 0, got {:?}", &u32_bytes),
        });
    }

    // read number of keys, should only be 1.
    buf.read_exact(&mut u32_bytes)?;
    if u32::from_be_bytes(u32_bytes) != 1 {
        return Err(SshKeyInternalError {
            kind: SshKeyErrorKind::BadKeyFormat,
            message: format!("Invalid private key count, expected 1, got {:?}", &u32_bytes),
        });
    }

    // read the public key data
    element = read_cstring(&mut buf)?;

    // this is keytype|key. Read the type, then return the key
    let mut keydata = Cursor::new(&element);
    let key_type = read_cstring(&mut keydata)?;
    let pubkey = read_cstring(&mut keydata)?;

    Ok((str::from_utf8(&key_type)?.to_string(), pubkey))
}

fn write_cstring(buf: &mut dyn Write, bytes: &[u8]) -> Result<(), std::io::Error> {
    let len: u32 = bytes.len().try_into().expect("usize cast to u32");
    buf.write_all(&len.to_be_bytes())?;
    buf.write_all(bytes)?;
    Ok(())
}

fn read_cstring(buf: &mut dyn Read) -> Result<Vec<u8>, std::io::Error> {
    let mut size = [0u8; 4];
    buf.read_exact(&mut size)?;
    let len = u32::from_be_bytes(size);
    if len > 0 {
        let sz: usize = len.try_into().unwrap();
        let mut ret: Vec<u8> = vec![0; sz];
        buf.read_exact(&mut ret)?;
        return Ok(ret);
    }
    Ok(vec![])
}

#[cfg(test)]
mod test {
    use super::*;
    use ffx_config::{test_init, ConfigLevel};
    use serde_json::json;
    use std::{
        fs::{self, File},
        io::Write,
    };
    use tempfile::TempDir;

    #[fuchsia_async::run_singlethreaded(test)]
    async fn test_load() {
        // Set up the test environment and set the ssh key paths
        let env = test_init().await.expect("test env init");
        env.context
            .query("ssh.pub")
            .level(Some(ConfigLevel::User))
            .set(json!(["$ENV_PATH_THAT_IS_NOT_SET", "/expected/default", "someother"]))
            .await
            .expect("set ssh.pub");
        env.context
            .query("ssh.priv")
            .level(Some(ConfigLevel::User))
            .set(json!([
                "$ENV_PATH_THAT_IS_NOT_SET_2",
                "/expected/default/private",
                "someother/place"
            ]))
            .await
            .expect("set ssh.priv");

        // set the config

        let ssh_files = match SshKeyFiles::load().await {
            Ok(ssh) => ssh,
            Err(e) => panic!("load failed: {e:?}"),
        };
        assert!(&ssh_files.authorized_keys.display().to_string() == "/expected/default");
        assert!(&ssh_files.private_key.display().to_string() == "/expected/default/private");
    }

    #[test]
    fn test_enum_display() {
        let v = SshKeyErrorKind::BadKeyFormat;
        assert_eq!(format!("{v}"), "BadKeyFormat")
    }
    #[test]
    fn test_create_with_existing() {
        let tmp_dir = TempDir::new().expect("create temp dir");

        let auth_key_path = tmp_dir.path().join("authorized_keys");
        let private_path = tmp_dir.path().join("privatekey");

        // scope to force the file to close.
        {
            let mut tmp_file = File::create(&auth_key_path).expect("create authorized ");
            let test_private_key = include_str!("../testdata/test1_ed25519");
            tmp_file.write_all(b"unchanged\n").expect("write authorized keys bytes");
            let mut priv_file = File::create(&private_path).expect("create private key path");
            priv_file.write_all(test_private_key.as_bytes()).expect("write private key bytes");
        }

        let ssh_files = SshKeyFiles { authorized_keys: auth_key_path, private_key: private_path };
        if let Err(e) = ssh_files.create_keys_if_needed() {
            panic!("create_keys_if_needed failed: {e:?}");
        }

        let contents = fs::read_to_string(ssh_files.authorized_keys).expect("read authorized keys");
        let lines: Vec<&str> = contents.lines().collect();

        // existing keys should not be modified by create_keys_if_needed.
        assert_eq!(lines.len(), 1);
        assert_eq!(lines[0], "unchanged");
    }

    #[test]
    fn test_create_with_missing_auth_keys() {
        let tmp_dir = TempDir::new().expect("create temp dir");

        let auth_key_path = tmp_dir.path().join("authorized_keys");
        let private_path = tmp_dir.path().join("privatekey");

        // scope to force the file to close.
        {
            let test_private_key = include_str!("../testdata/test1_ed25519");
            let mut priv_file = File::create(&private_path).expect("Create priv key path");
            priv_file.write_all(test_private_key.as_bytes()).expect("write contents of priv key");
        }

        let ssh_files = SshKeyFiles { authorized_keys: auth_key_path, private_key: private_path };
        if let Err(e) = ssh_files.create_keys_if_needed() {
            panic!("create_keys_if_needed failed: {e:?}");
        }

        let contents =
            fs::read_to_string(ssh_files.authorized_keys).expect("read authorized_keys contents");
        let expected_contents = include_str!("../testdata/test1_authorized_keys");

        assert!(contents == expected_contents);
    }

    #[test]
    fn test_create_with_missing_keys() {
        let tmp_dir = TempDir::new().expect("create temp dir");

        let auth_key_path = tmp_dir.path().join("authorized_keys");
        let private_path = tmp_dir.path().join("privatekey");

        assert!(!&auth_key_path.exists());
        assert!(!&private_path.exists());

        let ssh_files = SshKeyFiles { authorized_keys: auth_key_path, private_key: private_path };
        if let Err(e) = ssh_files.create_keys_if_needed() {
            panic!("create_keys_if_needed failed: {e:?}");
        }

        assert!(&ssh_files.authorized_keys.exists());
        assert!(&ssh_files.private_key.exists());
    }

    #[test]
    fn test_write_cstring() {
        let mut data = vec![];
        let mut expected_data: Vec<u8> = vec![0, 0, 0, 5];
        expected_data.extend_from_slice("hello".as_bytes());
        if let Err(e) = write_cstring(&mut data, "hello".as_bytes()) {
            panic!("write_cstring failed: {e:?}");
        }

        assert!(data == expected_data);

        let mut input = Cursor::new(data);
        let read_data = match read_cstring(&mut input) {
            Ok(d) => d,
            Err(e) => panic!("read_cstring failed: {e:?}"),
        };
        assert!(read_data == "hello".as_bytes());
    }

    #[test]
    fn test_create_with_missing_directory_for_keys() {
        let tmp_dir = TempDir::new().expect("creating temp dir");

        let new_dir_path = tmp_dir.path().join("new-dir");
        let auth_key_path = new_dir_path.join("authorized_keys");
        let private_path = new_dir_path.join("privatekey");

        assert!(!&auth_key_path.exists());
        assert!(!&private_path.exists());

        let ssh_files = SshKeyFiles { authorized_keys: auth_key_path, private_key: private_path };
        match ssh_files.create_keys_if_needed() {
            Ok(_) => (),
            Err(e) => panic!("create keys if needed error: {e:?}"),
        };

        assert!(&ssh_files.authorized_keys.exists());
        assert!(&ssh_files.private_key.exists());
    }

    #[test]
    fn test_check_keys() {
        let tmp_dir = TempDir::new().expect("creating temp dir");

        let new_dir_path = tmp_dir.path().join("new-dir");
        let auth_key_path = new_dir_path.join("authorized_keys");
        let private_path = new_dir_path.join("privatekey");

        assert!(!&auth_key_path.exists());
        assert!(!&private_path.exists());

        let ssh_files = SshKeyFiles { authorized_keys: auth_key_path, private_key: private_path };
        ssh_files.create_keys_if_needed().expect("creating test keys");

        match ssh_files.check_keys(false) {
            Ok(_) => (),
            Err(e) => panic!("create keys if needed error: {e:?}"),
        };
    }

    #[test]
    fn test_check_keys_missing() {
        let tmp_dir = TempDir::new().expect("creating temp dir");

        let new_dir_path = tmp_dir.path().join("new-dir");
        let auth_key_path = new_dir_path.join("authorized_keys");
        let private_path = new_dir_path.join("privatekey");

        assert!(!&auth_key_path.exists());
        assert!(!&private_path.exists());

        let ssh_files = SshKeyFiles { authorized_keys: auth_key_path, private_key: private_path };

        match ssh_files.check_keys(false) {
            Ok(_) => panic!("missing keys should fail"),
            Err(e) => assert_eq!(e.kind, SshKeyErrorKind::FileNotFound, "{e:?}"),
        }
    }

    #[test]
    fn test_check_keys_mismatch() {
        let tmp_dir = TempDir::new().expect("create temp dir");

        let new_dir_path = tmp_dir.path().join("new-dir");
        let auth_key_path = new_dir_path.join("authorized_keys");
        let private_path = new_dir_path.join("privatekey");
        let other_auth_key_path = new_dir_path.join("other_authorized_keys");
        let other_private_path = new_dir_path.join("other_privatekey");

        assert!(!&auth_key_path.exists());
        assert!(!&private_path.exists());

        let ssh_files =
            SshKeyFiles { authorized_keys: auth_key_path.clone(), private_key: private_path };
        match ssh_files.create_keys_if_needed() {
            Ok(_) => (),
            Err(e) => panic!("create keys if needed error: {e:?}"),
        };

        let other_ssh_files = SshKeyFiles {
            authorized_keys: other_auth_key_path,
            private_key: other_private_path.clone(),
        };
        match other_ssh_files.create_keys_if_needed() {
            Ok(_) => (),
            Err(e) => panic!("create keys if needed error: {e:?}"),
        };

        let mismatched =
            SshKeyFiles { authorized_keys: auth_key_path, private_key: other_private_path };

        match mismatched.check_keys(false) {
            Ok(_) => panic!("mismatched keys should fail"),
            Err(e) => assert_eq!(e.kind, SshKeyErrorKind::KeyMismatch, "{e:?}"),
        };
    }
}
