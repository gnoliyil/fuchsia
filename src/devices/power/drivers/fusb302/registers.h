// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_DEVICES_POWER_DRIVERS_FUSB302_REGISTERS_H_
#define SRC_DEVICES_POWER_DRIVERS_FUSB302_REGISTERS_H_

// The comments in this file reference the datasheet from onsemi titled
// "FUSB302B Programmable USB Type‚ÄêC Controller w/PD", order number FUSB302B/D,
// downloadable at https://www.onsemi.com/pdf/datasheet/fusb302b-d.pdf
//
// The section and page numbers reference Revision 5, published August 2021.

#include <fidl/fuchsia.hardware.i2c/cpp/wire.h>
#include <lib/ddk/debug.h>
#include <lib/zx/result.h>
#include <zircon/assert.h>
#include <zircon/types.h>

#include <cstdint>

#include <hwreg/bitfields.h>
#include <hwreg/i2c.h>

#include "src/devices/power/drivers/fusb302/usb-pd-defs.h"

// We reason about the FUSB302B behavior using the functional breakdown
// described here. Some of the functional units here are outlined in the Rev 5
// datasheet (Figure 3 page 2), and the rest are inferred.
//
// The analog front-end has the following functional units.
//
// * CC (USB Type C Configuration Channel) pin termination: two pull-down
//   resistors (Pd) and two programmable current sources (alternate
//   implementation of Pu)
// * BMC (Bi-phase Mark Encoding) PHY (Physical Layer): Tx (transmitter) and Rx
//   (receiver) blocks that implement the Physical Layer in the USB PD spec;
//   illustrated in Figure 12 page 11 of the Rev 5 datasheet
// * Measure block: four voltage comparators compare the measure block's input
//   against reference voltages; three comparators use fixed references that can
//   determine Sink termination (Ra, or Rd with Default / 1.5A / 3.0A Type C
//   power delivery), and the fourth comparator uses a variable voltage
//   generated by an MDAC (mutliplying DAC) with programmable input
// * CC (Configuration Channel) switches: can connect the CC1 and CC2 pins to
//   USB PD termination (Rd or current source), to the measure block, to the
//   BMC PHY, and/or to the VCONN (cable power source) pin (Figure 6 page 6 of
//   the Rev 5 datasheet)
//
// The FUSB302B also has the following digital functional units.
//
// * Power role detector - implements a subset of the state machines in Section
//   4.5 "Configuration Channel (CC)" of the USB Type C spec; these should not
//   be confused with the USB PD state machines, which must be implemented in
//   the driver
// * PD (USB Type C Power Delivery) Protocol Layer - implements a subset of the
//   state machines described in Section 6.12.2.2 "Protocol Layer Message
//   Transmission" of the USB PD spec
// * Interrupt block - functional units signal specific conditions by asserting
//   interrupts; the interrupt block tracks asserted interrupts (in the
//   Interrupt/InterruptA/InterruptB registers) until software acknowledges
//   them, and implements interrupt propagation; each interrupt has an
//   individual mask bit (in the Mask/MaskA/MaskB register), and there is also a
//   primary mask bit that suppresses all interrupts; interrupt signals are
//   propagated through masks to the INT_N pin

#define DEVICE_ID_ADDR 0x01
#define SWITCHES0_ADDR 0x02
#define SWITCHES1_ADDR 0x03
#define MEASURE_ADDR 0x04
#define SLICE_ADDR 0x05
#define CONTROL0_ADDR 0x06
#define CONTROL1_ADDR 0x07
#define CONTROL2_ADDR 0x08
#define CONTROL3_ADDR 0x09
#define MASK_ADDR 0x0A
#define POWER_ADDR 0x0B
#define RESET_ADDR 0x0C
#define OCP_REG_ADDR 0x0D
#define MASK_A_ADDR 0x0E
#define MASK_B_ADDR 0x0F
#define CONTROL4_ADDR 0x10
#define STATUS0_A_ADDR 0x3C
#define STATUS1_A_ADDR 0x3D
#define INTERRUPT_A_ADDR 0x3E
#define INTERRUPT_B_ADDR 0x3F
#define STATUS0_ADDR 0x40
#define STATUS1_ADDR 0x41
#define INTERRUPT_ADDR 0x42
#define FIFOS_ADDR 0x43

constexpr float kVbusMeasureVoltageStep = 0.42f;
constexpr float kCcMeasureVoltageStep = 0.042f;

namespace fusb302 {

enum Polarity : bool {
  CC1 = false,
  CC2 = true,
};
enum PowerRole : bool {
  sink = false,
  source = true,
};
enum DataRole : uint8_t {
  DFP,
  UFP,
  DRP,
  ASS,
};

template <class RegType>
class Fusb302Register : public hwreg::I2cRegisterBase<RegType, uint8_t, 1> {
 public:
  static RegType ReadFrom(const fidl::ClientEnd<fuchsia_hardware_i2c::Device>& i2c) {
    auto reg = RegType::Get().FromValue(0);
    ZX_ASSERT(reg.I2cRegisterBase::ReadFrom(i2c) == ZX_OK);
    return reg;
  }

  // Only writes to the register if the mutation changes the value.
  //
  // Usage:
  //     zx::result<> result = Control0Reg::ReadModifyWrite(
  //           i2c_, [&](Control0Reg& control0) {
  //       control0.set_flush_transmitter_fifo(true);
  //     });
  //     if (result.is_ok()) {
  //        ...
  //     }
  template <typename F>
  static zx::result<> ReadModifyWrite(fidl::ClientEnd<fuchsia_hardware_i2c::Device>& i2c,
                                      F modify_function) {
    auto reg = RegType::Get().FromValue(0);
    const zx_status_t read_status = reg.I2cRegisterBase::ReadFrom(i2c);
    if (read_status != ZX_OK) {
      return zx::error_result(read_status);
    }

    const uint8_t old_value = reg.reg_value();
    modify_function(reg);
    if (reg.reg_value() == old_value) {
      return zx::ok();
    }

    const zx_status_t write_status = reg.WriteTo(i2c);
    if (write_status != ZX_OK) {
      zxlogf(ERROR, "Failed to write register 0x%02x over I2C: %s", reg.reg_addr(),
             zx_status_get_string(write_status));
      return zx::error_result(write_status);
    }
    return zx::ok();
  }
};

// DEVICE ID - Identifies the chip.
//
// Rev 5 datasheet: Table 17 on page 19
class DeviceIdReg : public Fusb302Register<DeviceIdReg> {
 public:
  DEF_FIELD(7, 4, version_id);
  DEF_FIELD(3, 2, product_id);
  DEF_FIELD(1, 0, revision_id);

  // The product name is "F302", suffixed by the return value character.
  //
  // Returns "?" if the version ID is invalid.
  char VersionCharacter() const;

  // The revision is the returned character.
  char RevisionCharacter() const;

  // Returns a C-style string that contains the expanded product ID.
  const char* ProductString() const;

  static auto Get() { return hwreg::I2cRegisterAddr<DeviceIdReg>(0x01); }
};

// Mutually exclusive configurations of the switch blocks attached to CC pins.
//
// Rev 5 datasheet: Figure 6 "Configuration Channel Switch Functionality" on
// page 6, Figure 3 "Functional Block Diagram" on page 3, Table 10 "Type-C CC
// Switch" on page 15.
enum class SwitchBlockConfig : int8_t {
  // The CC pin is floating.
  kOpen,

  // The CC pin is connected to a <= 2.18V (VUFPDB) current source.
  //
  // The current source is used to advertise the power source capability,
  // following typec2.2 4.5.1.2.1 "Detecting a Valid Source-to-Sink Connection".
  //
  // The current source is configured by the HOST_CUR field in the
  // `Control0Reg` register.
  kPullUp,

  // The CC pin is connected to the ground via a 5.1 Ohm (RDEVICE) resistor.
  //
  // The pull-down resistor value follows Table 4-27 "Sink CC Termination (Rd)
  // Requirements" in typec2.2 4.11.1 "Termination Parameters".
  kPullDown,

  // The CC pin is connected to the VCONN source. Powers cable electronics.
  kConnectorVoltage,
};

// Descriptor for logging and debugging.
const char* SwitchBlockConfigToString(SwitchBlockConfig config);

// SWITCHES0 - Controls most CC (Configuration Channel) circuit switches.
//
// After reset, both CC pins will be connected to pull-down resistors, and none
// of them will be connected to the measure block.
//
// Rev 5 datasheet: Table 18 on page 20
class Switches0Reg : public Fusb302Register<Switches0Reg> {
 public:
  // Read/written by {Set}SwitchBlockConfigFor() and {Set}MeasureConfigChannelPinSwitch().
  DEF_BIT(7, pu_en2);
  DEF_BIT(6, pu_en1);
  DEF_BIT(5, vconn_cc2);
  DEF_BIT(4, vconn_cc1);
  DEF_BIT(3, meas_cc2);
  DEF_BIT(2, meas_cc1);
  DEF_BIT(1, pdwn2);
  DEF_BIT(0, pdwn1);

  SwitchBlockConfig SwitchBlockConfigFor(usb_pd::ConfigChannelPinId cc_pin_id) const;
  Switches0Reg& SetSwitchBlockConfig(usb_pd::ConfigChannelPinId cc_pin_id,
                                     SwitchBlockConfig connection);

  usb_pd::ConfigChannelPinSwitch MeasureBlockInput() const;
  Switches0Reg& SetMeasureBlockInput(usb_pd::ConfigChannelPinSwitch input);

  static auto Get() { return hwreg::I2cRegisterAddr<Switches0Reg>(0x02); }
};

// SWITCHES1 - Configures the BMC PHY.
//
// This register has reserved/undocumented bits. It can only be safely updated
// via read/modify/write operations.
//
// After reset, the GoodCRC header bits will be set to (Sink, PD Rev 2.0, UFP).
//
// Rev 5 datasheet: Table 19 on page 20, Figure 12 "USB BMC Power Delivery
// Blocks" on page 11, Figure 3 "Functional Block Diagram" on page 3
class Switches1Reg : public Fusb302Register<Switches1Reg> {
 public:
  // The "Port Power Role" bit in the header of auto-generated GoodCRC messages.
  //
  // The datasheet values match the values in usbpd3.1 6.2.1.1.4 "Port Power
  // Role".
  DEF_ENUM_FIELD(usb_pd::PowerRole, 7, 7, power_role);

  // The "Spec Revision" bits in the header of auto-generated GoodCRC messages.
  //
  // The datasheet values match the values in usbpd3.1 6.2.1.1.5 "Specification
  // Revision". While the Rev 5 datasheet marks 0b10 (Revision 3.0) as "Do Not
  // Use", experiments with a FUSB302BMPX did not encounter any issue using the
  // Revision 3.0 value.
  DEF_ENUM_FIELD(usb_pd::SpecRevision, 6, 5, spec_rev);

  // The "Port Data Role" bit in the header of auto-generated GoodCRC messages.
  //
  // The datasheet values are intended to match the values in usbpd3.1 6.2.1.1.6
  // "Port Data Role". The datasheet conflates the power roles Sink/Source with
  // the data roles UFP/DFP.
  DEF_ENUM_FIELD(usb_pd::DataRole, 4, 4, data_role);

  // If true, the PD Protocol Layer generates and sends GoodCRC messages.
  //
  // This bit enables the hardware implementation of usbpd3.1 6.3.1 "GoodCRC
  // Message".
  //
  // Delegating GoodCRC generation to the hardware relieves the application
  // processor from having to react to every USB PD message in 195 us (tTransmit
  // in usbpd3.1). On the flip side, having the PD Protocol Layer acknowledge
  // all received messages leads to tighter timing requirements in some cases.
  // For example, a Sink has 5 seconds (tNoResponse) to generate a Request in
  // response to a Source_Capabilities, but that time is cut down to 30
  // milliseconds (tSenderResponse) after the Sink sends GoodCRC.
  DEF_BIT(2, auto_crc);

  // Read/written by {Set}BmcPhyConnection().
  DEF_BIT(1, txcc2);
  DEF_BIT(0, txcc1);

  usb_pd::ConfigChannelPinSwitch BmcPhyConnection() const;
  Switches1Reg& SetBmcPhyConnection(usb_pd::ConfigChannelPinSwitch connection);

  static auto Get() { return hwreg::I2cRegisterAddr<Switches1Reg>(0x03); }
};

class MeasureReg : public Fusb302Register<MeasureReg> {
 public:
  DEF_BIT(6, meas_vbus);
  DEF_FIELD(5, 0, mdac);

  static auto Get() { return hwreg::I2cRegisterAddr<MeasureReg>(MEASURE_ADDR); }
};

class SliceReg : public Fusb302Register<SliceReg> {
 public:
  DEF_FIELD(7, 6, sdac_hys);
  DEF_FIELD(5, 0, sdac);

  static auto Get() { return hwreg::I2cRegisterAddr<SliceReg>(SLICE_ADDR); }
};

class Control0Reg : public Fusb302Register<Control0Reg> {
 public:
  DEF_BIT(6, tx_flush);
  DEF_BIT(5, int_mask);
  enum HostCur {
    NO_CURRENT = 0b00,
    DEFAULT = 0b01,
    MEDIUM_1A5 = 0b10,
    HIGH_3A0 = 0b11,
  };
  DEF_ENUM_FIELD(HostCur, 3, 2, host_cur);
  DEF_BIT(1, auto_pre);
  DEF_BIT(0, tx_start);

  static auto Get() { return hwreg::I2cRegisterAddr<Control0Reg>(CONTROL0_ADDR); }
};

class Control1Reg : public Fusb302Register<Control1Reg> {
 public:
  DEF_BIT(6, ensop2db);
  DEF_BIT(5, ensop1db);
  DEF_BIT(4, bist_mode2);
  DEF_BIT(2, rx_flush);
  DEF_BIT(1, ensop2);
  DEF_BIT(0, ensop1);

  static auto Get() { return hwreg::I2cRegisterAddr<Control1Reg>(CONTROL1_ADDR); }
};

class Control2Reg : public Fusb302Register<Control2Reg> {
 public:
  DEF_FIELD(7, 6, tog_save_pwr);
  DEF_BIT(5, tog_rd_only);
  DEF_BIT(3, wake_en);
  enum ToggleMode {
    ENABLE_DRP = 0b01,
    ENABLE_SNK = 0b10,
    ENABLE_SRC = 0b11,
  };
  DEF_ENUM_FIELD(ToggleMode, 2, 1, mode);
  DEF_BIT(0, toggle);

  static auto Get() { return hwreg::I2cRegisterAddr<Control2Reg>(CONTROL2_ADDR); }
};

class Control3Reg : public Fusb302Register<Control3Reg> {
 public:
  DEF_BIT(6, send_hard_reset);
  DEF_BIT(5, bist_tmode);
  DEF_BIT(4, auto_hardreset);
  DEF_BIT(3, auto_softreset);
  DEF_FIELD(2, 1, n_retries);
  DEF_BIT(0, auto_retry);

  static auto Get() { return hwreg::I2cRegisterAddr<Control3Reg>(CONTROL3_ADDR); }
};

class MaskReg : public Fusb302Register<MaskReg> {
 public:
  DEF_BIT(7, m_vbusok);
  DEF_BIT(6, m_activity);
  DEF_BIT(5, m_comp_chng);
  DEF_BIT(4, m_crc_chk);
  DEF_BIT(3, m_alert);
  DEF_BIT(2, m_wake);
  DEF_BIT(1, m_collision);
  DEF_BIT(0, m_bc_lvl);

  static auto Get() { return hwreg::I2cRegisterAddr<MaskReg>(MASK_ADDR); }
};

class PowerReg : public Fusb302Register<PowerReg> {
 public:
  DEF_BIT(3, pwr3);
  DEF_BIT(2, pwr2);
  DEF_BIT(1, pwr1);
  DEF_BIT(0, pwr0);

  static auto Get() { return hwreg::I2cRegisterAddr<PowerReg>(POWER_ADDR); }
};

class ResetReg : public Fusb302Register<ResetReg> {
 public:
  DEF_BIT(1, pd_reset);
  DEF_BIT(0, sw_res);

  static auto Get() { return hwreg::I2cRegisterAddr<ResetReg>(RESET_ADDR); }
};

class OcpReg : public Fusb302Register<OcpReg> {
 public:
  DEF_BIT(3, ocp_range);
  DEF_FIELD(2, 0, ocp_cur);

  static auto Get() { return hwreg::I2cRegisterAddr<OcpReg>(OCP_REG_ADDR); }
};

class MaskAReg : public Fusb302Register<MaskAReg> {
 public:
  DEF_BIT(7, m_ocp_temp);
  DEF_BIT(6, m_togdone);
  DEF_BIT(5, m_softfail);
  DEF_BIT(4, m_retryfail);
  DEF_BIT(3, m_hardsent);
  DEF_BIT(2, m_txsent);
  DEF_BIT(1, m_softrst);
  DEF_BIT(0, m_hardrst);

  static auto Get() { return hwreg::I2cRegisterAddr<MaskAReg>(MASK_A_ADDR); }
};

class MaskBReg : public Fusb302Register<MaskBReg> {
 public:
  DEF_BIT(0, m_gcrcsent);

  static auto Get() { return hwreg::I2cRegisterAddr<MaskBReg>(MASK_B_ADDR); }
};

class Control4Reg : public Fusb302Register<Control4Reg> {
 public:
  DEF_BIT(0, tog_exit_aud);

  static auto Get() { return hwreg::I2cRegisterAddr<Control4Reg>(CONTROL4_ADDR); }
};

class Status0AReg : public Fusb302Register<Status0AReg> {
 public:
  DEF_BIT(5, softfail);
  DEF_BIT(4, retryfail);
  DEF_FIELD(3, 2, power);
  DEF_BIT(1, softrst);
  DEF_BIT(0, hardrst);

  static auto Get() { return hwreg::I2cRegisterAddr<Status0AReg>(STATUS0_A_ADDR); }
};

class Status1AReg : public Fusb302Register<Status1AReg> {
 public:
  enum TogSS {
    toggle_running = 0b000,   // TOGGLE = 1
    stop_src1 = 0b001,        // SRCon CC1 (STOP_SRC1)
    stop_src2 = 0b010,        // SRCon CC2 (STOP_SRC2)
    stop_snk1 = 0b101,        // SNKon CC1 (STOP_SNK1)
    stop_snk2 = 0b110,        // SNKon CC2 (STOP_SNK2)
    audio_accessory = 0b111,  // AudioAccessory with vRa on both CC1 and CC2 (STOP_SRC1)
  };
  DEF_ENUM_FIELD(TogSS, 5, 3, togss);
  DEF_BIT(2, rxsop2db);
  DEF_BIT(1, rxsop1db);
  DEF_BIT(0, rxsop);

  static auto Get() { return hwreg::I2cRegisterAddr<Status1AReg>(STATUS1_A_ADDR); }
  static Polarity GetPolarity(TogSS val) { return (val & 0x01) ? CC1 : CC2; }
  static PowerRole GetPowerRole(TogSS val) { return (val & 0x04) ? sink : source; }
};

class InterruptAReg : public Fusb302Register<InterruptAReg> {
 public:
  DEF_BIT(7, i_ocp_temp);
  DEF_BIT(6, i_togdone);
  DEF_BIT(5, i_softfail);
  DEF_BIT(4, i_retryfail);
  DEF_BIT(3, i_hardsent);
  DEF_BIT(2, i_txsent);
  DEF_BIT(1, i_softrst);
  DEF_BIT(0, i_hardrst);

  static auto Get() { return hwreg::I2cRegisterAddr<InterruptAReg>(INTERRUPT_A_ADDR); }
};

class InterruptBReg : public Fusb302Register<InterruptBReg> {
 public:
  DEF_BIT(0, i_gcrcsent);

  static auto Get() { return hwreg::I2cRegisterAddr<InterruptBReg>(INTERRUPT_B_ADDR); }
};

class Status0Reg : public Fusb302Register<Status0Reg> {
 public:
  DEF_BIT(7, vbusok);
  DEF_BIT(6, activity);
  DEF_BIT(5, comp);
  DEF_BIT(4, crc_chk);
  DEF_BIT(3, alert);
  DEF_BIT(2, wake);
  DEF_FIELD(1, 0, bc_lvl);

  static auto Get() { return hwreg::I2cRegisterAddr<Status0Reg>(STATUS0_ADDR); }
};

class Status1Reg : public Fusb302Register<Status1Reg> {
 public:
  DEF_BIT(7, rxsop2);
  DEF_BIT(6, rxsop1);
  DEF_BIT(5, rx_empty);
  DEF_BIT(4, rx_full);
  DEF_BIT(3, tx_empty);
  DEF_BIT(2, tx_full);
  DEF_BIT(1, ovrtemp);
  DEF_BIT(0, ocp);

  static auto Get() { return hwreg::I2cRegisterAddr<Status1Reg>(STATUS1_ADDR); }
};

class InterruptReg : public Fusb302Register<InterruptReg> {
 public:
  DEF_BIT(7, i_vbusok);
  DEF_BIT(6, i_activity);
  DEF_BIT(5, i_comp_chng);
  DEF_BIT(4, i_crc_chk);
  DEF_BIT(3, i_alert);
  DEF_BIT(2, i_wake);
  DEF_BIT(1, i_collision);
  DEF_BIT(0, i_bc_lvl);

  static auto Get() { return hwreg::I2cRegisterAddr<InterruptReg>(INTERRUPT_ADDR); }
};

class FifosReg : public Fusb302Register<FifosReg> {
 public:
  DEF_FIELD(7, 0, tx_rx_token);

  static auto Get() { return hwreg::I2cRegisterAddr<FifosReg>(FIFOS_ADDR); }
};

inline char DeviceIdReg::VersionCharacter() const {
  if (version_id() < 0b1000) {
    return '?';  // Invalid version.
  }
  // `version_id()` is a 4-bit field, so the cast result will be between 'A' and
  // 'P'. No overflow / UB will occur.
  return static_cast<char>('A' + (version_id() - 8));
}

inline char DeviceIdReg::RevisionCharacter() const {
  // `revision_id()` is a 4-bit field, so the cast result will be between 'A' and
  // 'D'. No overflow / UB will occur.
  return static_cast<char>('A' + revision_id());
}

inline const char* DeviceIdReg::ProductString() const {
  if (version_id() != 0b1001) {
    static constexpr char kUnknownProduct[] = "Unknown product";
    return kUnknownProduct;
  }

  static constexpr const char* kVersionBProductIds[] = {
      "FUSB302BMPX",
      "FUSB302B01MPX",
      "FUSB302B10MPX",
      "FUSB302B11MPX",
  };
  return kVersionBProductIds[product_id()];
}

inline SwitchBlockConfig Switches0Reg::SwitchBlockConfigFor(
    usb_pd::ConfigChannelPinId cc_pin_id) const {
  switch (cc_pin_id) {
    case usb_pd::ConfigChannelPinId::kCc1: {
      if (pdwn1()) {
        return SwitchBlockConfig::kPullDown;
      }
      if (vconn_cc1()) {
        return SwitchBlockConfig::kConnectorVoltage;
      }
      if (pu_en1()) {
        return SwitchBlockConfig::kPullUp;
      }
      return SwitchBlockConfig::kOpen;
    };
    case usb_pd::ConfigChannelPinId::kCc2: {
      if (pdwn2()) {
        return SwitchBlockConfig::kPullDown;
      }
      if (vconn_cc2()) {
        return SwitchBlockConfig::kConnectorVoltage;
      }
      if (pu_en2()) {
        return SwitchBlockConfig::kPullUp;
      }
      return SwitchBlockConfig::kOpen;
    };
  }
  ZX_DEBUG_ASSERT_MSG(false, "Invalid CC pin ID: %" PRIu8, cc_pin_id);
}

inline Switches0Reg& Switches0Reg::SetSwitchBlockConfig(usb_pd::ConfigChannelPinId cc_pin_id,
                                                        SwitchBlockConfig connection) {
  switch (cc_pin_id) {
    case usb_pd::ConfigChannelPinId::kCc1: {
      return set_pdwn1(connection == SwitchBlockConfig::kPullDown)
          .set_vconn_cc1(connection == SwitchBlockConfig::kConnectorVoltage)
          .set_pu_en1(connection == SwitchBlockConfig::kPullUp);
    };
    case usb_pd::ConfigChannelPinId::kCc2: {
      return set_pdwn2(connection == SwitchBlockConfig::kPullDown)
          .set_vconn_cc2(connection == SwitchBlockConfig::kConnectorVoltage)
          .set_pu_en2(connection == SwitchBlockConfig::kPullUp);
      break;
    };
  }
  ZX_DEBUG_ASSERT_MSG(false, "Invalid CC pin ID: %" PRIu8, cc_pin_id);
  return *this;
}

inline usb_pd::ConfigChannelPinSwitch Switches0Reg::MeasureBlockInput() const {
  if (meas_cc1()) {
    return usb_pd::ConfigChannelPinSwitch::kCc1;
  }
  if (meas_cc2()) {
    return usb_pd::ConfigChannelPinSwitch::kCc2;
  }
  return usb_pd::ConfigChannelPinSwitch::kNone;
}

inline Switches0Reg& Switches0Reg::SetMeasureBlockInput(usb_pd::ConfigChannelPinSwitch input) {
  return set_meas_cc1(input == usb_pd::ConfigChannelPinSwitch::kCc1)
      .set_meas_cc2(input == usb_pd::ConfigChannelPinSwitch::kCc2);
}

inline usb_pd::ConfigChannelPinSwitch Switches1Reg::BmcPhyConnection() const {
  if (txcc1()) {
    return usb_pd::ConfigChannelPinSwitch::kCc1;
  }
  if (txcc2()) {
    return usb_pd::ConfigChannelPinSwitch::kCc2;
  }
  return usb_pd::ConfigChannelPinSwitch::kNone;
}

inline Switches1Reg& Switches1Reg::SetBmcPhyConnection(usb_pd::ConfigChannelPinSwitch connection) {
  return set_txcc1(connection == usb_pd::ConfigChannelPinSwitch::kCc1)
      .set_txcc2(connection == usb_pd::ConfigChannelPinSwitch::kCc2);
}

}  // namespace fusb302

#endif  // SRC_DEVICES_POWER_DRIVERS_FUSB302_REGISTERS_H_
