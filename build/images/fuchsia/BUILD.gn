# Copyright 2021 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/assembly/assembled_system.gni")
import("//build/assembly/generated_assembly_inputs.gni")
import("//build/assembly/legacy_image_metadata_overrides.gni")
import("//build/assembly/update_package.gni")
import("//build/board.gni")
import("//build/images/args.gni")
import("//build/images/filesystem_limits.gni")
import("//build/images/vboot/vboot.gni")
import("//build/product.gni")
import("//build/sdk/product_bundle.gni")
import("//build/security.gni")
import("//build/security/policies.gni")
import("//build/security/policies_swd.gni")
import("//build/testing/host_test_data.gni")
import("//src/security/bin/scrutiny_x_smoke_test/scrutiny_x_smoke_test.gni")
import("//src/sys/core/build/core.gni")

declare_args() {
  # Create the package and archive for the legacy assembly input bundle.  This
  # can be a time-consuming operation, which due to limits in GN and groups,
  # ends up being a blocking step in the build, so only enable this if we know
  # that we want the legacy AIB packaged and archived for a given product:
  create_legacy_aib_archive = false
}

if (is_host) {
  host_test_data("fuchsia_zbi_for_host_tests") {
    sources = [ "$root_build_dir/fuchsia.zbi" ]
    # This dep cannot be specified, because it creates a dependency cycle.  It
    # could be added if all tests using this were not in any package set (and
    # were just in host_labels)
    #deps = [ ":fuchsia($default_toolchain)" ]
  }
}

# The assembly operation should only be defined in the default (fuchsia)
# toolchain.
if (is_fuchsia) {
  assert(current_toolchain == default_toolchain,
         "//build/images/* are only valid in the Fuchsia toolchain")

  # This catches inadvertent dependencies on the "fucshia" assembly implementation
  # in bringup-only configurations.
  assert(
      !use_bringup_assembly,
      "The bringup product config cannot rely on the fuchsia assembly.  Bringup has it's own in //build/images/bringup")

  assert(fuchsia_product_assembly_config_label != false,
         "fuchsia_product_assembly_config_label must be defined for the build")

  ##################################################
  # Shared parameters across assemblies in this file
  ##################################################

  files = {
    assembly_inputs = "$target_out_dir/fuchsia/assembly_inputs.json"
    platform_aib_dir = get_label_info("//bundles/assembly", "target_out_dir")

    # Outputs of assembly.
    outdir = target_out_dir + "/fuchsia"
    images_config = "${outdir}.images_config.json"
    zbi = "${outdir}/fuchsia.zbi"
    zbi_signed = "${outdir}/fuchsia.zbi.signed"
    vbmeta = "${outdir}/fuchsia.vbmeta"
    blobfs = "${outdir}/blob.blk"
    fvm = "${outdir}/fvm.blk"
    fvm_sparse = "${outdir}/fvm.sparse.blk"
    fvm_blob_sparse = "${outdir}/fvm.blob.sparse.blk"
    fvm_fastboot = "${outdir}/fvm.fastboot.blk"
    fxfs = "${outdir}/fxfs.blk"
    packages_json = "${outdir}/packages.json"
    images_json = "${outdir}/images.json"

    product_assembly_config_file =
        get_label_info(fuchsia_product_assembly_config_label,
                       "target_out_dir") + "/" +
        get_label_info(fuchsia_product_assembly_config_label, "name") +
        "/product_assembly_config.json"

    # Recovery currently should use the bootable user config.
    recovery_product_assembly_config_file =
        get_label_info("//build/assembly:bootable_product_config",
                       "target_out_dir") +
        "/bootable_product_config/product_assembly_config.json"

    # Outputs of prime assembly.
    outdir_prime = target_out_dir + "/fuchsia_prime_assembly"
    images_prime_json = "${outdir_prime}/images.json"
    packages_prime_json = "${outdir_prime}/packages.json"

    # Outputs of recovery.
    recovery_name = get_label_info(recovery_label, "name")
    recovery_outdir =
        get_label_info(recovery_label, "target_out_dir") + "/" + recovery_name
    recovery_images_config = "${recovery_outdir}.images_config.json"
    recovery_zbi = "${recovery_outdir}/${recovery_name}.zbi"
    recovery_zbi_signed = "${recovery_outdir}/${recovery_name}.zbi.signed"
    recovery_vbmeta = "${recovery_outdir}/${recovery_name}.vbmeta"
    recovery_blobfs = "${recovery_outdir}/blob.blk"
    recovery_fvm = "${recovery_outdir}/fvm.blk"
    recovery_fvm_sparse = "${recovery_outdir}/fvm.sparse.blk"
    recovery_fvm_blob_sparse = "${recovery_outdir}/fvm.blob.sparse.blk"
    recovery_fvm_fastboot = "${recovery_outdir}/fvm.fastboot.blk"
    recovery_fxfs = "${recovery_outdir}/fxfs.blk"
    recovery_images_json = "${recovery_outdir}/images.json"

    esp_image_path = "${root_build_dir}/fuchsia.esp.blk"

    if (target_cpu == "x64") {
      qemu_kernel = "$root_build_dir/multiboot.bin"
    } else {
      qemu_kernel = "$root_build_dir/qemu-boot-shim.bin"
    }
  }

  # A scope of dependencies that serves to transition deps from the
  # legacy_assembly_input_bundle.gni mechanism to the new platform
  # assembly_input_bundle.gni.
  #
  # This is used to do a metadata walk on the list of dependencies we intend to
  # delete from the legacy AIB after a successful transition, because the
  # assembly_input_bundle.gni template does not use a metadata walk to gather
  # transitive dependencies, and thus the set of declared targets in the
  # assembly_input_bundle invocation will often contain more explicit targets
  # than those being removed from the legacy_assembly_input_bundle invocation.
  # This makes it otherwise difficult to validate that the list of resultant
  # dependencies in the build does not change.

  must_exist = {
    base_packages = []
    cache_packages = []
    bootfs_labels = []
    bootfs_package_labels = []
    extra_base_deps = []
    boot_args = []
    cmdline = []
    cmdline_deps = []
  }

  fuchsia_base = {
    testonly = fuchsia_zbi_testonly
    generate_fvm = !fxfs_blob
    generate_fxfs = fxfs_blob
    board_name = board_name

    check_production_tag = check_production_eligibility

    # In non-prod builds, allow use of the eng and userdebug platform bundles.
    allow_eng_platform_bundle_use = !check_production_eligibility
    allow_userdebug_platform_bundle_use = !check_production_eligibility

    include_component_id_index = true

    # Use the GN arg for including shell commands.
    include_shell_commands = include_shell_commands_package

    # Use the GN arg for skipping the fshost configuration in GN
    use_assembly_fshost = assembly_fshost
    if (!assembly_fshost) {
      fshost_config = board_fshost_config
    }

    if (images_config_label != false) {
      assembly_images_config_label = images_config_label
    }

    product_assembly_config_label = fuchsia_product_assembly_config_label

    cmdline_deps = [ "//build/input:bootfs" ]

    base_packages = [
      "//:developer_base_driver_packages",
      "//:developer_base_packages",
      "//:legacy_base_packages",
    ]

    core_realm_definition = ":core_realm"

    # Include the product-defined meta package labels.
    meta_packages = meta_package_labels

    # Add the base package labels for the selected SWD policy.
    if (defined(policy_labels.swd)) {
      foreach(policy, policies_swd) {
        if (policy.name == policy_labels.swd) {
          base_packages += policy.base_package_deps
        }
      }
    }

    # Add the base package labels for the selected SWD policy.
    extra_core_realm_shards = []
    if (defined(policy_labels.update_checker)) {
      foreach(policy, policies_update_checker) {
        if (policy.name == policy_labels.update_checker) {
          # TODO(fxbug.dev/93695) Remove the need for
          # `if_board_supports_update_configurator` and
          # `board_supports_update_configurator`, replacing them with an
          # optional capability route when that feature is available.
          if (board_supports_update_configurator) {
            inner = policy.if_board_supports_update_configurator

            extra_core_realm_shards += inner.core_realm_shards
          }
        }
      }
    }

    base_driver_packages = [
      "//:developer_base_driver_packages",
      "//:legacy_base_driver_packages",
    ]
    cache_packages = [
      "//:developer_cache_packages",
      "//:legacy_cache_packages",
    ]
    system_image_deps = [ "//build/input:system_image" ]
    universe_packages = [
      "//:developer_universe_packages",
      "//:legacy_universe_packages",
    ]
    bootfs_labels = [ "//build/input:bootfs" ]
    bootfs_package_labels = product_bootfs_packages

    # blobfs arguments
    assembly_blob_layout_format = blob_layout_format
    if (blobfs_product_minimum_inodes != false) {
      blobfs_minimum_inodes = blobfs_product_minimum_inodes
    } else if (blobfs_board_minimum_inodes != false) {
      blobfs_minimum_inodes = blobfs_board_minimum_inodes
    }
    if (blobfs_product_minimum_data_bytes != false) {
      blobfs_minimum_data_bytes = blobfs_product_minimum_data_bytes
    } else if (blobfs_board_minimum_data_bytes != false) {
      blobfs_minimum_data_bytes = blobfs_board_minimum_data_bytes
    }
    if (blobfs_product_maximum_bytes != false) {
      blobfs_maximum_bytes = blobfs_product_maximum_bytes
    } else if (blobfs_board_maximum_bytes != false) {
      blobfs_maximum_bytes = blobfs_board_maximum_bytes
    }
    if (max_blob_contents_size != false) {
      blobfs_maximum_contents_size = max_blob_contents_size
    }

    # fvm arguments
    assembly_include_account_in_fvm = include_account_in_fvm
    assembly_fvm_slice_size = fvm_slice_size

    # zbi arguments
    if (custom_signing_script != "") {
      zbi_signing_script = custom_signing_script
      zbi_signing_script_deps = [ "//build/images/custom_signing:deps" ]
      inputs = custom_signing_script_inputs
    } else if (use_vboot) {
      zbi_signing_script = vboot_action.script
      zbi_signing_args = vboot_action.args
      zbi_signing_script_deps = vboot_action.deps
      inputs = vboot_action.inputs
    }
  }

  core_realm_definition("core_realm") {
    deps = core_realm_shards + board_core_realm_shards +
           fuchsia_base.extra_core_realm_shards
  }

  ##################################################
  # Fuchsia
  ##################################################

  # Copy the fvm.blob.sparse.blk to the old location for assembled images.
  # TODO(fxbug.dev/82077): Delete this once clients do not depend on the old path.

  if (!fxfs_blob) {
    copy("copy_fvm_blob_sparse") {
      testonly = fuchsia_zbi_testonly
      sources = [ "${target_out_dir}/fuchsia/fvm.blob.sparse.blk" ]
      outputs = [ old_fvm_blob_sparse_path ]
      deps = [ ":fuchsia_assembly" ]
    }
  }

  # The `:fuchsia` target assembles the main Fuchsia image, for all non-bringup
  # product definitions.
  #
  # This group only provides GN metadata about the update package(s), none of
  # packages that are included in the assembled image are present in GN metadata
  # walks of this target.
  #
  # To get the list of packages in this assembly, use the
  # `package_list_from_assembly()` GN template.
  group("fuchsia") {
    testonly = fuchsia_zbi_testonly
    public_deps = [
      ":assembly_inputs",
      ":fuchsia_assembly",
      ":product_bundle",
      ":scrutiny_x_smoke_test",
      ":update",
    ]

    if (!fxfs_blob && include_fvm_blob_sparse) {
      public_deps += [ ":copy_fvm_blob_sparse" ]
    }

    metadata = {
      # Only include the update package(s) manifest(s) in metadata collection.
      # To get a file containing a list of the base & cache packages, use the
      # `package_list_from_assembly()` GN template.
      package_barrier = [ ":update" ]
      assembly_inputs = [
        {
          path = rebase_path(files.assembly_inputs, root_build_dir)
        },
      ]
    }
  }

  assembled_system("fuchsia_assembly") {
    forward_variables_from(fuchsia_base, "*")
    output_dir = root_build_dir
    image_name = "fuchsia"

    create_legacy_aib_package = create_legacy_aib_archive
    create_legacy_aib_archive = create_legacy_aib_archive

    image_metadata_overrides = legacy_fuchsia_image_metadata_overrides
    must_exist_deps = must_exist
  }

  if (has_board) {
    assert(partitions_config_label != false,
           "Need to define partitions_config_label")
  } else {
    partitions_config_label = "//boards/partitions:default"
  }
  _partitions_config_file =
      get_label_info(partitions_config_label, "target_out_dir") + "/" +
      get_label_info(partitions_config_label, "name") + ".json"

  update_epoch = update_platform_epoch + update_product_epoch
  update_package("update") {
    testonly = fuchsia_zbi_testonly
    deps = [
      ":fuchsia_assembly",
      "//build/info:latest-commit-date",
      partitions_config_label,
      recovery_label,
    ]
    partitions = _partitions_config_file
    system_a = files.images_json
    system_r = files.recovery_images_json
    board_name = board_name
    version_file = build_info_files.version
    epoch = "${update_epoch}"
  }

  product_bundle_label = "product_bundle"
  product_bundle(product_bundle_label) {
    testonly = fuchsia_zbi_testonly
    deps = [
      ":fuchsia_assembly",
      "//build/info:latest-commit-date",
      partitions_config_label,
      recovery_label,
    ]

    update = {
      version_file = build_info_files.version
      epoch = "${update_epoch}"
    }

    partitions = _partitions_config_file
    system_a = files.images_json
    system_r = files.recovery_images_json

    # Add the virtual devices.
    if (board_is_emu) {
      virtual_devices = [
        "$root_build_dir/virtual_device_recommended.json",
        "$root_build_dir/virtual_device_min.json",
        "$root_build_dir/virtual_device_large.json",
      ]
      deps += [
        "//build/images/flash:virtual_device_specification_large",
        "//build/images/flash:virtual_device_specification_min",
        "//build/images/flash:virtual_device_specification_recommended",
      ]
      default_virtual_device = "virtual_device_recommended"
    }

    # Create lists of the files that are referenced by the assembly manifests.
    _assembly_contents = [ files.qemu_kernel ]
    if (fxfs_blob) {
      _assembly_contents += [ files.fxfs ]
    } else {
      _assembly_contents += [
        files.blobfs,
        files.fvm,
        files.fvm_sparse,
        files.fvm_blob_sparse,
      ]
    }
    _recovery_contents = [ files.qemu_kernel ]
    if (files.recovery_name != "zedboot") {
      if (fxfs_blob) {
        _recovery_contents += [ files.recovery_fxfs ]
      } else {
        _recovery_contents += [
          files.blobfs,
          files.fvm,
          files.fvm_sparse,
          files.fvm_blob_sparse,
        ]
      }
    }
    if (!fxfs_blob && (fvm_emmc_partition_size != false ||
                       fvm_ftl_nand_block_count != false)) {
      _assembly_contents += [ files.fvm_fastboot ]
      if (files.recovery_name != "zedboot") {
        _recovery_contents += [ files.recovery_fvm_fastboot ]
      }
    }
    if (custom_signing_script != "" || use_vboot) {
      _assembly_contents += [ files.zbi_signed ]
      _recovery_contents += [ files.recovery_zbi_signed ]
    } else {
      _assembly_contents += [ files.zbi ]
      _recovery_contents += [ files.recovery_zbi ]
    }
    if (use_vbmeta) {
      _assembly_contents += [ files.vbmeta ]
      _recovery_contents += [ files.recovery_vbmeta ]
    }

    # List the contents of each input so that the outputs can be calculated.
    partitions_contents = partitions_config_contents
    system_a_contents = _assembly_contents
    system_r_contents = _recovery_contents

    # Skip scrutiny on slot R.
    skip_scrutiny_recovery = true

    # Skip scrutiny on slot A for particular cases.
    if (is_coverage || custom_signing_script != "" || !run_scrutiny_verifiers) {
      skip_scrutiny = true
    } else {
      scrutiny_args = {
        assembly_image_name = "fuchsia"
        route_sources_config = fuchsia_route_sources_config
        static_pkgs_goldens = fuchsia_static_pkgs_goldens
        structured_config_policy = fuchsia_structured_config_policy
        verify_component_resolvers_allowlist =
            fuchsia_verify_component_resolvers_allowlist
        verify_routes_component_tree_config =
            fuchsia_verify_routes_component_tree_config
        verify_routes_exceptions_allowlist =
            fuchsia_verify_routes_exceptions_allowlist
        verify_routes_exceptions_allowlist_product =
            fuchsia_verify_routes_exceptions_allowlist_product
        zbi_bootfs_filelist_goldens = fuchsia_zbi_bootfs_filelist_goldens
        zbi_bootfs_packages_goldens = fuchsia_zbi_bootfs_packages_goldens
        zbi_kernel_cmdline_goldens = fuchsia_zbi_kernel_cmdline_goldens
        product_assembly_config_label =
            fuchsia_base.product_assembly_config_label
      }
    }

    if (delivery_blob_type != false) {
      delivery_blob_type = delivery_blob_type
    }
  }
  product_bundle_out_dir =
      get_label_info(":${product_bundle_label}", "target_out_dir") + "/" +
      product_bundle_label

  scrutiny_x_smoke_test("scrutiny_x_smoke_test") {
    testonly = fuchsia_zbi_testonly
    product_bundle_target = ":${product_bundle_label}"
    product_bundle_path = product_bundle_out_dir
  }

  generated_assembly_inputs("assembly_inputs") {
    testonly = fuchsia_zbi_testonly
    partitions_config = _partitions_config_file
    output_path = files.assembly_inputs

    # Add the images configs and their dependencies.
    images_configs = [
      files.images_config,
      files.recovery_images_config,
    ]

    # Add the legacy AIB for the assemblies. The platform AIBs are added
    # automatically from the build_api_module("assembly_input_archives")
    sources = [
      "${files.outdir}/legacy",
      "${files.recovery_outdir}/legacy",
    ]

    deps = [
      ":fuchsia_assembly",
      partitions_config_label,
    ]

    # Add the product configs and their dependencies.
    product_configs = [
      files.product_assembly_config_file,
      files.recovery_product_assembly_config_file,
    ]
    deps += [
      "//build/assembly:bootable_product_config",
      fuchsia_product_assembly_config_label,
      recovery_label,
    ]

    # Add the security configs and goldens.
    sources += fuchsia_static_pkgs_goldens
    sources += fuchsia_verify_routes_exceptions_allowlist_product
    sources += fuchsia_zbi_bootfs_filelist_goldens
    sources += fuchsia_zbi_bootfs_packages_goldens
    sources += fuchsia_zbi_kernel_cmdline_goldens
    sources += recovery_static_pkgs_goldens
    sources += recovery_verify_routes_exceptions_allowlist_product
    sources += recovery_zbi_bootfs_filelist_goldens
    sources += recovery_zbi_bootfs_packages_goldens
    sources += recovery_zbi_kernel_cmdline_goldens
    _optional_files = [
      fuchsia_route_sources_config,
      fuchsia_structured_config_policy,
      fuchsia_verify_component_resolvers_allowlist,
      fuchsia_verify_routes_component_tree_config,
      fuchsia_verify_routes_exceptions_allowlist,
      recovery_route_sources_config,
      recovery_structured_config_policy,
      recovery_verify_component_resolvers_allowlist,
      recovery_verify_routes_component_tree_config,
      recovery_verify_routes_exceptions_allowlist,
    ]
    foreach(file, _optional_files) {
      if (file != "") {
        sources += [ file ]
      }
    }
  }

  ##################################################
  # Netboot
  ##################################################

  # This rolls the primary ZBI together with a compressed RAMDISK image of
  # fvm.blk into a fat ZBI that boots the full system without using any real
  # storage.  The system decompresses the fvm.blk image into memory and then
  # sees that RAM disk just as if it were a real disk on the device.
  assembled_system("netboot") {
    image_name = "fuchsia"
    namespace = "netboot"
    forward_variables_from(fuchsia_base, "*")
    ramdisk_in_zbi = true

    image_metadata_overrides = {
      zbi = {
        name = "netboot"
        archive = enable_netboot
        bootserver_netboot = [ "--boot" ]
      }
    }
  }
}
