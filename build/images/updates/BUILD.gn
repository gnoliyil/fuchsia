# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/assembly/cache_packages_from_product_assembler.gni")
import("//build/assembly/package_list.gni")
import("//build/bazel/bazel_workspace.gni")
import("//build/images/args.gni")
import("//build/packages/package_metadata.gni")
import("//build/product.gni")
import("//build/security.gni")
import("//src/sys/pkg/bin/package-tool/package-tool.gni")
import("//src/sys/pkg/bin/system-updater/epoch/generate_epoch.gni")
import("//src/sys/pkg/repositories/devhost/devhost.gni")

assert(current_toolchain == default_toolchain,
       "//build/images/* are only valid in the Fuchsia toolchain")

if (use_bringup_assembly) {
  # These don't have any meaning in a bringup assembly, so leave them as empty
  # placeholder targets.
  group("updates") {
  }
  group("packages") {
  }
  group("publish") {
  }

  # This file doesn't exist for bringup, as bringup does not have packages to
  # upload blobs for.
  group("all_package_manifests.list") {
  }
} else {
  group("updates") {
    testonly = true
    deps = [
      ":package_lists",
      ":publish",
    ]
  }

  # Use the common `labels` and `files` vars
  import("//build/images/paths.gni")

  #####
  # These are the package groups that are used to build the system

  group("universe_packages") {
    testonly = fuchsia_zbi_testonly
    visibility = [ ":*" ]
    public_deps = [
      "//:developer_universe_packages",
      "//:legacy_universe_packages",
    ]
  }

  #####
  # This label is used by //BUILD.gn's 'build_api_module()s' to perform metadata
  # walks over "all the software built for the target", both the universe and
  # that which is part of the assembled images (bootfs, base pkgs, cache pkgs,
  # etc.)
  #
  # To get a list of all packages built, use the following file:
  #   `$root_build_dir/all_package_manifests.list`
  # which is generated by:
  #   `//build/images/updates:all_package_manifests.list`
  #
  # This label defined here (`:packages`) IS NOT usable to perform a GN metadata
  # walk for a list of "all the packages built".  That list cannot be gathered by
  # GN metadata alone.
  #
  # Because the list would be incomplete, this label ACTIVELY BLOCKS the ability
  # to use it to gather ANY package manifest metadata.
  #
  group("packages") {
    testonly = true
    deps = [
      # The universe package set
      ":universe_packages",

      # Everything else in the main image
      labels.images,

      # The recovery image
      recovery_label,
    ]

    # Restrict usages to //BUILD.gn targets only (build_api_module()s, for the
    # most part)
    visibility = [ "//:*" ]

    metadata = {
      # Block the package_manifest_output gathering, because this target cannot
      # provide a correct list via that mechanism.
      package_barrier = []
    }
  }

  #####
  # These are lists of the packages in the above groups

  if (use_bazel_images_only) {
    # TODO(https://fxbug.dev/123120): Figure out how to provide the following
    # information when only Bazel assembly is used.
    write_file(files.base_package_names, "")
    write_file(files.cache_package_names, "")
    group("base_packages.list") {
    }
    group("cache_packages.list") {
    }
  } else {
    package_list_from_assembly("base_packages.list") {
      testonly = true
      system_label = labels.images
      package_set = "base"
      contents = "name"
      outputs = [ files.base_package_names ]
    }

    package_list_from_assembly("cache_packages.list") {
      testonly = true
      system_label = labels.images
      package_set = "cache"
      contents = "name"
      outputs = [ files.cache_package_names ]
    }
  }

  generate_package_metadata("universe_packages.list") {
    testonly = true
    visibility = [ ":*" ]
    data_keys = [ "package_names" ]
    outputs = [ files.universe_package_names ]
    deps = [ ":universe_packages" ]
  }

  group("package_lists") {
    testonly = true
    visibility = [ ":*" ]

    deps = [
      ":all_package_manifests.list",
      ":assembly_cache_packages.list",
      ":base_packages.list",
      ":cache_packages.list",
      ":universe_packages.list",
    ]
  }

  ###
  ### Amber updates.
  ###

  recovery_images_list = root_build_dir + "/recovery_images_list"
  generated_file("recovery_images_list") {
    testonly = true
    outputs = [ recovery_images_list ]
    output_conversion = "list lines"
    data_keys = [ "update_target" ]
    deps = [ recovery_label ]
  }

  generate_epoch("epoch.json") {
    output_file = "${target_out_dir}/${target_name}"
  }

  # This output is a manifest of manifests that is usable as an input to `pm
  # publish -lp`, a tool for publishing a set of packages from a build produced
  # list of package manifests.
  all_package_manifests_list = root_build_dir + "/all_package_manifests.list"
  generate_package_metadata("package_manifests_from_metadata.list") {
    testonly = true
    outputs = [ files.manifests_from_metadata ]
    data_keys = [ "package_output_manifests" ]
    rebase = root_build_dir
    deps = [
      # Universe
      ":universe_packages",

      # The update packages for the main image
      labels.images,
    ]
  }

  if (use_bazel_images_only) {
    # TODO(https://fxbug.dev/123120): Figure out how to provide the following
    # information when only Bazel assembly is used.
    generated_file("base_package_manifests.list") {
      outputs = [ files.base_package_manifests ]
      contents = ""
    }
    generated_file("cache_package_manifests.list") {
      outputs = [ files.cache_package_manifests ]
      contents = ""
    }
  } else {
    package_list_from_assembly("base_package_manifests.list") {
      testonly = true
      system_label = labels.images
      package_set = "base"
      contents = "manifest"
      outputs = [ files.base_package_manifests ]
    }

    package_list_from_assembly("cache_package_manifests.list") {
      testonly = true
      system_label = labels.images
      package_set = "cache"
      contents = "manifest"
      outputs = [ files.cache_package_manifests ]
    }
  }

  # Generate a list of cache packages from product assembly for the `fx publish`
  # tool.
  cache_packages_from_product_assembler("assembly_cache_packages.list") {
    assembly_label = labels.images
    outputs = [ "$root_build_dir/assembly_cache_packages.list" ]
    testonly = true
  }

  action("universe_package_manifests.list") {
    testonly = true
    script = "create-universe-package-manifests-list.py"
    depfile = "$root_build_dir/$target_name.d"
    outputs = [ files.universe_package_manifests ]
    deps = [
      ":base_package_manifests.list",
      ":cache_package_manifests.list",
      ":package_manifests_from_metadata.list",
    ]

    inputs = [
      files.base_package_manifests,
      files.cache_package_manifests,
      files.manifests_from_metadata,
    ]

    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "-o",
      rebase_path(outputs[0], root_build_dir),
    ]
    foreach(input, inputs) {
      args += [ rebase_path(input, root_build_dir) ]
    }
  }

  action("all_package_manifests.list") {
    testonly = true
    script = "create-all-package-manifests-list.py"
    outputs = [ all_package_manifests_list ]
    deps = []
    args = rebase_path(outputs, root_build_dir)
    sources = []

    _manifest_deps = [ ":universe_package_manifests.list" ]

    # TODO(https://fxbug.dev/123120): Figure out how to provide the following
    # information when only Bazel assembly is used.
    if (use_bazel_images_only) {
      deps += [ labels.bazel_package_manifests_list ]

      args +=
          [ rebase_path(files.bazel_package_manifests_list, root_build_dir) ]
      sources += [ files.bazel_package_manifests_list ]
    } else {
      _manifest_deps += [
        ":base_package_manifests.list",
        ":cache_package_manifests.list",
      ]
    }

    foreach(_dep, _manifest_deps) {
      deps += [ _dep ]
      _dep_outputs = []  # tell gn its ok to rewrite each iteration
      _dep_outputs = get_target_outputs(_dep)
      args += [ rebase_path(_dep_outputs[0], root_build_dir) ]
      sources += [ _dep_outputs[0] ]
    }
  }

  _output_repository_dir = "${root_build_dir}/amber-files"

  # Publish all packages to the package repository.
  devhost_repository_publish("publish") {
    testonly = true

    output_repository_dir = _output_repository_dir

    deps = [ ":all_package_manifests.list" ]
    package_list_manifests = [ all_package_manifests_list ]

    output_blob_manifest_path = root_build_dir + "/all_blobs.json"

    metadata = {
      package_repository = [
        {
          path = rebase_path("${_output_repository_dir}/repository",
                             root_build_dir)
          targets =
              rebase_path("${_output_repository_dir}/repository/targets.json",
                          root_build_dir)
          blobs = rebase_path("${_output_repository_dir}/repository/blobs",
                              root_build_dir)
        },
      ]
    }
  }

  # Allow the incremental publisher to stage the repository keys and root metadata so it can publish
  # without needing to do a full build.
  group("prepare_publish") {
    testonly = true
    deps = [ ":publish_repo_deps" ]
  }
}
