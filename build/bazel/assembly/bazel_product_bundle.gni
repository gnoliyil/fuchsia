# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/bazel/bazel_action.gni")
import("//build/images/args.gni")
import("//build/sdk/product_bundle_transfer_manifest.gni")
import("//bundles/assembly/platform_aibs.gni")
import("//src/sys/pkg/bin/package-tool/package-tool.gni")

# A GN wrapper for a Bazel product bundle target. From GN's perspective, the
# output product bundle is opaque (only a manifest file containing paths to the
# Bazel output base). This template only useful if you have a downstream target
# in GN that is capable of consuming a product bundle built by Bazel in its
# entirety.
#
# Parameters
#
#  bazel_product_bundle_target (required)
#    The Bazel product bundle target to build.
#    Type: label (from BUILD.bazel)
#
#  bazel_inputs_from_gn (required)
#    The Bazel input targets (defined by bazel_input_xxx GN templates) used to
#    plumb outputs from GN/Ninja to Bazel. This list should include all GN
#    targets producing outputs used in the Bazel product bundle. This is usually
#    legacy images configurations, legacy AIBs, prebuilt packages from GN, etc.
#
#    For example:
#
#      * //build/images/fuchsia:fuchsia.bazel_images_config_inputs
#      * //build/images/fuchsia:fuchsia.legacy_aib_bazel_inputs
#
#    Type: list(label)
#
#  allow_eng_platform_bundle_use (optional; default=false)
#    If true, allow the 'eng' platform bundles to be used by the assembled
#    system. (This is only a check made by GN, assembly itself may still access
#    them)
#    Type: bool
#    Default: false
#
#  deps
#  metadata
#  testonly
#  visibility
#
template("bazel_product_bundle") {
  assert(defined(invoker.bazel_product_bundle_target),
         "bazel_product_bundle_target is required")
  assert(defined(invoker.bazel_inputs_from_gn),
         "bazel_inputs_from_gn is required")

  _bazel_action_target = "${target_name}_bazel_action"
  bazel_action(_bazel_action_target) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                             "deps",
                           ])

    no_output_dir_leaks = false

    command = "build"
    bazel_targets = [ invoker.bazel_product_bundle_target ]

    bazel_inputs = invoker.bazel_inputs_from_gn

    # Make sure AIBs are built before Bazel assembly.
    if (defined(invoker.allow_eng_platform_bundle_use) &&
        invoker.allow_eng_platform_bundle_use) {
      _aibs_to_use = eng_platform_aib_labels
      not_needed(invoker, [ "allow_userdebug_platform_bundle_use" ])
    } else {
      if (defined(invoker.allow_userdebug_platform_bundle_use) &&
          invoker.allow_userdebug_platform_bundle_use) {
        _aibs_to_use = userdebug_platform_aib_labels
      } else {
        _aibs_to_use = user_platform_aib_labels
      }
    }
    foreach(_aib, _aibs_to_use) {
      bazel_inputs += [ "${_aib}_bazel_inputs" ]
    }

    # Directory outputs are OK because `product_bundle.json` correctly
    # represents the freshness of all outputs.
    allow_directory_in_outputs = true
    copy_outputs = [
      {
        bazel = "{{BAZEL_TARGET_OUT_DIR}}/{{BAZEL_TARGET_NAME}}_out"
        ninja = "product_bundle"
      },
      {
        bazel = "{{BAZEL_TARGET_OUT_DIR}}/pave.sh"
        ninja = "pave.sh"
      },
    ]
    directory_timestamp_outputs = [
      "product_bundle/product_bundle.json",
      "product_bundle/system_a/fuchsia.zbi",
      "product_bundle/system_a/fvm.blk",
    ]

    # Populate metadata when Bazel image is not used will pollute GN assembly.
    if (use_bazel_images_only) {
      _label_dir = get_label_info(":${target_name}", "dir")
      _full_label = "${_label_dir}:${target_name}($current_toolchain)"
      _system_a_root =
          rebase_path(target_gen_dir, root_out_dir) + "/product_bundle/system_a"

      # TODO(https://fxbug.dev/123576): Figure out how to handle conditional
      # outputs (e.g. vbmeta).
      metadata = {
        images = [
          {
            name = "zircon-a"
            type = "zbi"
            cpu = current_cpu
            label = _full_label
            path = "${_system_a_root}/fuchsia.zbi"

            archive = true
            bootserver_pave = []
            if (!sign_zbi) {
              bootserver_pave += [ "--zircona" ]
              fastboot_flash = []
              if (zircon_a_partition != "") {
                fastboot_flash += [ zircon_a_partition ]
              }
              if (zircon_b_partition != "") {
                fastboot_flash += [ zircon_b_partition ]
              }
            }
          },
          {
            name = "blob"
            type = "blk"
            cpu = current_cpu
            label = _full_label
            path = "${_system_a_root}/blob.blk"
          },
          {
            name = "storage-full"
            cpu = current_cpu
            type = "blk"
            label = _full_label
            path = "${_system_a_root}/fvm.blk"
            archive = add_qemu_to_build_archives
          },
          {
            name = "storage-sparse"
            cpu = current_cpu
            type = "blk"
            label = _full_label
            path = "${_system_a_root}/fvm.sparse.blk"
            archive = true
            bootserver_pave = [ "--fvm" ]
          },
          {
            name = "fvm.blob.sparse"
            cpu = current_cpu
            type = "blk"
            label = _full_label
            path = "${_system_a_root}/fvm.blob.sparse.blk"

            # Hack: Infra expects bootserver_pave to be present
            # in the GN graph for this image to be built.
            bootserver_pave = []
          },
        ]

        product_bundles = [
          {
            label = get_label_info(":$target_name", "label_with_toolchain")
            path = rebase_path("$target_gen_dir/product_bundle", root_build_dir)
            transfer_manifest_path =
                rebase_path("$target_gen_dir/transfer.json", root_build_dir)
            transfer_manifest_url = "file://" + transfer_manifest_path
          },
        ]
      }
    }
  }

  _package_manifests_list_target = "${target_name}_package_manifests_list"

  package_tool_package_manifest_list_create(_package_manifests_list_target) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    product_bundle = target_gen_dir + "/product_bundle"
    manifests_dir = "${target_out_dir}/manifests"

    deps = [ ":${_bazel_action_target}" ]
  }

  _transfer_manifest_target = "${target_name}_transfer_manifest"

  product_bundle_transfer_manifest(_transfer_manifest_target) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    product_bundle_target = ":${_bazel_action_target}"
    product_bundle_dir = target_gen_dir + "/product_bundle"
    output_dir = target_gen_dir
  }

  # A convenience group for easy `fx build` invocation.
  group(target_name) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    deps = [
      ":${_bazel_action_target}",
      ":${_package_manifests_list_target}",
      ":${_transfer_manifest_target}",
    ]
  }
}
