# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/bazel/bazel_action.gni")
import("//build/images/args.gni")
import("//bundles/assembly/platform_aibs.gni")

# A GN wrapper for a Bazel product bundle target. From GN's perspective, the
# output product bundle is opaque (only a manifest file containing paths to the
# Bazel output base). This template only useful if you have a downstream target
# in GN that is capable of consuming a product bundle built by Bazel in its
# entirety.
#
# Parameters
#
#  bazel_product_bundle_target (required)
#    The Bazel product bundle target to build.
#    Type: label (from BUILD.bazel)
#
#  bazel_inputs_from_gn (required)
#    The Bazel input targets (defined by bazel_input_xxx GN templates) used to
#    plumb outputs from GN/Ninja to Bazel. This list should include all GN
#    targets producing outputs used in the Bazel product bundle. This is usually
#    legacy images configurations, legacy AIBs, prebuilt packages from GN, etc.
#
#    For example:
#
#      * //build/images/fuchsia:fuchsia.bazel_images_config_inputs
#      * //build/images/fuchsia:fuchsia.legacy_aib_bazel_inputs
#
#    Type: list(label)
#
#  allow_eng_platform_bundle_use (optional; default=false)
#    If true, allow the 'eng' platform bundles to be used by the assembled
#    system. (This is only a check made by GN, assembly itself may still access
#    them)
#    Type: bool
#    Default: false
#
#  deps
#  metadata
#  testonly
#  visibility
#
template("bazel_product_bundle") {
  assert(defined(invoker.bazel_product_bundle_target),
         "bazel_product_bundle_target is required")
  assert(defined(invoker.bazel_inputs_from_gn),
         "bazel_inputs_from_gn is required")

  _bazel_action_target = "${target_name}_bazel_action"
  bazel_action(_bazel_action_target) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                             "deps",
                           ])

    no_output_dir_leaks = false

    command = "build"
    bazel_targets = [ invoker.bazel_product_bundle_target ]

    bazel_inputs = invoker.bazel_inputs_from_gn

    # Make sure AIBs are built before Bazel assembly.
    if (defined(invoker.allow_eng_platform_bundle_use) &&
        invoker.allow_eng_platform_bundle_use) {
      _aibs_to_use = eng_platform_aib_labels
    } else {
      _aibs_to_use = platform_aib_labels
    }
    foreach(_aib, _aibs_to_use) {
      bazel_inputs += [ "${_aib}_bazel_inputs" ]
    }

    _product_bundle_name =
        get_label_info(invoker.bazel_product_bundle_target, "name")
    _bazel_product_bundle_out_dir =
        rebase_path(get_label_info(invoker.bazel_product_bundle_target, "dir"),
                    "//")
    _bazel_product_bundle_out_dir += "/" + _product_bundle_name + "_out"

    # Directory outputs are OK because `product_bundle.json` correctly
    # represents the freshness of all outputs.
    allow_directory_in_outputs = true
    bazel_outputs = [
      "bazel-bin/${_bazel_product_bundle_out_dir}/product_bundle.json",
      "bazel-bin/${_bazel_product_bundle_out_dir}/system_a",
      "bazel-bin/${_bazel_product_bundle_out_dir}/repository",
      "bazel-bin/" + get_path_info(_bazel_product_bundle_out_dir, "dir") +
          "/pave.sh",
    ]
    ninja_outputs = [
      "product_bundle/product_bundle.json",
      "product_bundle/system_a",
      "product_bundle/repository",
      "pave.sh",
    ]

    # Populate metadata when Bazel image is not used will pollute GN assembly.
    if (use_bazel_images_only) {
      _label_dir = get_label_info(":${target_name}", "dir")
      _full_label = "${_label_dir}:${target_name}($current_toolchain)"
      _system_a_root =
          rebase_path(target_gen_dir, root_out_dir) + "/product_bundle/system_a"

      # TODO(https://fxbug.dev/123576): Figure out how to handle conditional
      # outputs (e.g. vbmeta).
      metadata = {
        images = [
          {
            name = "zircon-a"
            type = "zbi"
            cpu = current_cpu
            label = _full_label
            path = "${_system_a_root}/fuchsia.zbi"

            archive = true
            bootserver_pave = []
            if (!sign_zbi) {
              bootserver_pave += [ "--zircona" ]
              fastboot_flash = []
              if (zircon_a_partition != "") {
                fastboot_flash += [ zircon_a_partition ]
              }
              if (zircon_b_partition != "") {
                fastboot_flash += [ zircon_b_partition ]
              }
            }
          },
          {
            name = "blob"
            type = "blk"
            cpu = current_cpu
            label = _full_label
            path = "${_system_a_root}/blob.blk"
          },
          {
            name = "storage-full"
            cpu = current_cpu
            type = "blk"
            label = _full_label
            path = "${_system_a_root}/fvm.blk"
            archive = add_qemu_to_build_archives
          },
          {
            name = "storage-sparse"
            cpu = current_cpu
            type = "blk"
            label = _full_label
            path = "${_system_a_root}/fvm.sparse.blk"
            archive = true
            bootserver_pave = [ "--fvm" ]
          },
          {
            name = "fvm.blob.sparse"
            cpu = current_cpu
            type = "blk"
            label = _full_label
            path = "${_system_a_root}/fvm.blob.sparse.blk"

            # Hack: Infra expects bootserver_pave to be present
            # in the GN graph for this image to be built.
            bootserver_pave = []
          },
        ]
      }
    }
  }

  # A convenience group for easy `fx build` invocation.
  group(target_name) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    deps = [ ":${_bazel_action_target}" ]
  }
}
