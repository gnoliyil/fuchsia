# Copyright 2021 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/assembly/package_manifests_list.gni")
import("//build/component/component_id_index.gni")
import("//build/config.gni")
import("//build/dist/distribution_manifest.gni")
import("//build/dist/resource.gni")
import("//build/images/args.gni")
import("//build/info/info.gni")
import("//build/zbi/kernel_cmdline.gni")

# Generates an Image Assembly Config to be consumed by the Image Assembler.
#
# Arguments
#   kernel_image (required)
#     [label] Kernel to add to the ZBI.
#
#   kernel_image_name (required)
#     [string] Key used to identify the zbi image to use.
#
#   base_packages (optional)
#     [list of labels] The packages to include in the base package set.
#
#   cache_packages (optional)
#     [list of labels] The packages to cache in the images.
#
#   bootfs_labels (optional)
#     [list of labels] The objects installed on the bootfs partition of the
#     generated ZBI.
#
#   bootfs_package_labels (optional)
#     [list of labels] The packages installed on the bootfs partition of the
#     generated ZBI as meta.fars and content-id'd blobs.
#
#   extra_base_deps (optional)
#     [list of labels] The packages whose files should be added to the Base
#     Package.
#
#   boot_args (optional)
#     [list of strings] Boot arguments to add to the additional_boot_args.
#
#   cmdline (optional)
#     [list of strings] Kernel command line arguments to add to the ZBI.
#
#   cmdline_deps (optional)
#     [list of labels] Dependencies with metadata including additional kernel
#     command arguments to add to the ZBI.
#
#   include_component_id_index (default: false)
#     [bool] Collect and merges a component id index from the base
#     package set.
#
#   include_config_data (default: true)
#     [bool] Whether to create a config_data package for the assembly or not.

template("generated_image_assembly_config") {
  assert(
      current_toolchain == default_toolchain,
      "The image assembly config can only be created in the default toolchain")
  assert(defined(invoker.kernel_image), "Need to define kernel_image")
  output_path = "${target_out_dir}/${target_name}.json"

  # Set the defaults for several arguments.
  base_packages = []
  if (defined(invoker.base_packages)) {
    base_packages += invoker.base_packages
  }

  cache_packages = []
  if (defined(invoker.cache_packages)) {
    cache_packages += invoker.cache_packages
  }

  bootfs_labels = []
  if (defined(invoker.bootfs_labels)) {
    bootfs_labels += invoker.bootfs_labels
  }

  bootfs_package_labels = []
  if (defined(invoker.bootfs_package_labels)) {
    bootfs_package_labels += invoker.bootfs_package_labels
  }

  extra_base_deps = []
  if (defined(invoker.extra_base_deps)) {
    extra_base_deps += invoker.extra_base_deps
  }

  boot_args = []
  if (defined(invoker.boot_args)) {
    boot_args += invoker.boot_args
  }

  config_data_packages = []
  if (defined(invoker.config_data_packages)) {
    config_data_packages += invoker.config_data_packages
  }

  kernel_image_name = invoker.kernel_image_name

  # Labels used in this file.
  labels = {
    base_package_list = "${target_name}_package_manifest_list.base"
    cache_package_list = "${target_name}_package_manifest_list.cache"
    bootfs_package_list = "${target_name}_bootfs_package_list"
    extra_base_list = "${target_name}_package_manifest_list.extra_base"
    extra_base_deps_list =
        "${target_name}_package_manifest_list.extra_base_deps"
    kernel_image_metadata = "${target_name}_kernel_image_metadata"
    kernel_cmdline_args = "${target_name}_kernel_cmdline_args"
    bootfs_entries_metadata = "${target_name}_bootfs_entries_metadata"
    boot_args = "${target_name}_boot_args"
    config_data = "${target_name}.config-data"
  }

  # Files produced by targets in this file.
  files = {
    base_package_list = "$target_out_dir/package_lists/${target_name}_base"
    cache_package_list = "$target_out_dir/package_lists/${target_name}_cache"
    extra_base_list = "$target_out_dir/package_lists/${target_name}_extra_base"
    bootfs_package_list = "$target_out_dir/package_lists/${target_name}_bootfs"
    extra_base_deps_list =
        "$target_out_dir/package_lists/${target_name}_extra_base_deps"
    kernel_image_metadata =
        "$target_out_dir/${target_name}_kernel_image.gn_meta.json"
    kernel_cmdline_args =
        "$target_out_dir/${target_name}_kernel_cmdline_args.json"
    bootfs_entries_metadata =
        "$target_out_dir/${target_name}_bootfs_entries.gn_meta.json"
    boot_args = "$target_out_dir/${target_name}_boot_args"
  }

  component_id_index_dep = []
  component_id_index_config_data_dep = []
  include_component_index = defined(invoker.include_component_id_index) &&
                            invoker.include_component_id_index

  if (include_component_index) {
    # For details, see //docs/development/components/component_id_index.md#system-assembly
    component_id_index_config("${target_name}.component_id_index_config") {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])

      # collect and merge component ID indices from the base set.
      deps = base_packages

      metadata = {
        package_barrier = []
      }
    }

    component_id_index_dep = [ ":${target_name}.component_id_index_config" ]
    component_id_index_config_data_dep =
        [ ":${target_name}.component_id_index_config-config-data" ]
  } else {
    not_needed([ "component_id_index_config_data_dep" ])
  }

  include_config_data = true
  if (defined(invoker.include_config_data)) {
    include_config_data = invoker.include_config_data
  }
  if (include_config_data) {
    config_package(labels.config_data) {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
      package_name = "config-data"
      deps = config_data_packages + component_id_index_config_data_dep
    }
  }

  bootfs_labels += component_id_index_dep

  # Construct a list of Base packages to add to the image assembly config.
  package_manifests_list(labels.base_package_list) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    filename = files.base_package_list

    # Don't include driver packages
    additional_walk_keys = [ "driver_package_barrier" ]
    deps = base_packages
  }

  # Construct a list of Cache packages to add to the image assembly config.
  package_manifests_list(labels.cache_package_list) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    filename = files.cache_package_list
    deps = cache_packages
  }

  # Construct a list of extra packages whose files should be added to the Base Package.
  package_manifests_list(labels.extra_base_list) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    filename = files.extra_base_list
    deps = extra_base_deps
  }

  # Find all the extra system dependencies in the Base packages list.
  # This list mentions several extra packages to add to the Base Package.
  generated_file(labels.extra_base_deps_list) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])

    data_keys = [ "system_image_extra_package_manifest" ]
    walk_keys = [ "system_image_extra_package_manifest_barrier" ]
    outputs = [ files.extra_base_deps_list ]
    output_conversion = "json"
    deps = base_packages
  }

  # Create a list of boot arguments to add to additional_boot_args.
  generated_file(labels.boot_args) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])

    outputs = [ files.boot_args ]
    output_conversion = "json"
    contents = boot_args
  }

  # Find the kernel image metadata, which includes the location of the assembled kernel ZBI.
  generated_file(labels.kernel_image_metadata) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])

    data_keys = [ "images" ]
    outputs = [ files.kernel_image_metadata ]
    output_conversion = "json"
    deps = [ invoker.kernel_image ]
  }

  # Accumulate the list of cmdline dependencies by first taking the
  # directly-specified arguments, creating a new metadata target, and adding it
  # to the list of all metadata targets, then second walking the metadata to
  # construct the final list.
  cmdline_deps = []
  if (defined(invoker.cmdline)) {
    kernel_cmdline("${target_name}_extra_cmdline") {
      args = invoker.cmdline
    }
    cmdline_deps += [ ":${target_name}_extra_cmdline" ]
  }
  if (defined(invoker.cmdline_deps)) {
    cmdline_deps += invoker.cmdline_deps
  }

  generated_file(labels.kernel_cmdline_args) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])

    data_keys = [ "zbi_config_entry" ]
    walk_keys = [ "zbi_input_barrier" ]
    outputs = [ files.kernel_cmdline_args ]
    output_conversion = "json"
    deps = cmdline_deps
  }

  # Find all the files to add to BootFS.
  distribution_manifest(labels.bootfs_entries_metadata) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])

    outputs = [ files.bootfs_entries_metadata ]
    deps = bootfs_labels
  }

  # Construct a list of bootfs packages to add to the image assembly config.
  # Ignores any fuchsia_driver_packages and fuchsia_shell_packages
  package_manifests_list(labels.bootfs_package_list) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    filename = files.bootfs_package_list
    deps = bootfs_package_labels
  }

  action(target_name) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    script = "//build/assembly/scripts/generated_image_assembly_config.py"

    outputs = [ output_path ]
    inputs = [
      build_info_files.minimum_utc_stamp,
      files.base_package_list,
      files.cache_package_list,
      files.extra_base_list,
      files.extra_base_deps_list,
      files.kernel_image_metadata,
      files.kernel_cmdline_args,
      files.boot_args,
      files.bootfs_entries_metadata,
      files.bootfs_package_list,
    ]

    deps = [
      ":${labels.base_package_list}",
      ":${labels.boot_args}",
      ":${labels.bootfs_entries_metadata}",
      ":${labels.bootfs_package_list}",
      ":${labels.cache_package_list}",
      ":${labels.extra_base_deps_list}",
      ":${labels.extra_base_list}",
      ":${labels.kernel_cmdline_args}",
      ":${labels.kernel_image_metadata}",
      "//build/info:latest-commit-date",
    ]

    args = [
      "--base-packages-list",
      rebase_path(files.base_package_list, root_build_dir),
      "--cache-packages-list",
      rebase_path(files.cache_package_list, root_build_dir),
      "--extra-files-packages-list",
      rebase_path(files.extra_base_list, root_build_dir),
      "--extra-deps-files-packages-list",
      rebase_path(files.extra_base_deps_list, root_build_dir),
      "--kernel-image-metadata",
      rebase_path(files.kernel_image_metadata, root_build_dir),
      "--kernel-image-name",
      kernel_image_name,
      "--kernel-cmdline",
      rebase_path(files.kernel_cmdline_args, root_build_dir),
      "--kernel-clock-backstop",
      rebase_path(build_info_files.minimum_utc_stamp, root_build_dir),
      "--boot-args",
      rebase_path(files.boot_args, root_build_dir),
      "--bootfs-entries",
      rebase_path(files.bootfs_entries_metadata, root_build_dir),
      "--bootfs-packages-list",
      rebase_path(files.bootfs_package_list, root_build_dir),
      "--output",
      rebase_path(output_path, root_build_dir),
    ]

    metadata = {
      # We insert these barriers to prevent the dependencies from including
      # files "higher up" in the dependency chain.
      package_barrier = []
      config_package_barrier = []
      distribution_entries_barrier = []
    }
  }
}
