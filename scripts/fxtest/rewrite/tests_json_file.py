# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Data model and associated methods for tests.json files.

tests.json is generated by the GN build for Fuchsia, and it contains
descriptions of all test targets included in a build.

It is typically stored at the root of the output directory for the
Fuchsia build, and it is the main entrypoint to learn about what
tests are available and how to rebuild them.

"""

from dataclasses import dataclass
import json
import typing

from dataparse import dataparse


@dataparse
@dataclass
class TestSection:
    """Provides details for a specific test in tests.json."""

    # The name of the test. This is unique within the file.
    name: str

    # The build label for the test.
    label: str

    # The build label for the component being tested in this test.
    component_label: typing.Optional[str] = None

    # The build label for the package containing the test.
    package_label: typing.Optional[str] = None

    # If the test runs on the device, this is the URL of the test to execute.
    package_url: typing.Optional[str] = None

    # If the test runs on the host, this is the path of the binary to execute.
    path: typing.Optional[str] = None


class TestFileError(Exception):
    """There was an error processing the contents of the tests.json file."""


Self = typing.TypeVar("Self", bound="TestEntry")


@dataparse
@dataclass
class TestEntry:
    """tests.json consists of a single list of TestEntity."""

    # The "test" field for a specific entry in the file.
    test: TestSection

    @staticmethod
    def from_file(file: str) -> typing.List[Self]:
        """Parse the file at the given path into a list of TestEntry.

        This returns a list of entries because the ordering of the
        tests.json file is the default order in which tests are
        executed.

        Args:
            file (os.PathLike): Path to the file to parse.

        Raises:
            IOError: If reading the file fails.
            JSONDecodeError: If the file is not valid JSON.
            TestFileError: If the tests.json file was found to be invalid.

        Returns:
            typing.List[TestEntry]: List of test entries contained in the file.
        """
        with open(file, "r") as f:
            vals = json.load(f)
            if not isinstance(vals, list):
                raise TestFileError(
                    "Expected a list at top-level of tests.json, found "
                    + str(type(vals))
                )
            ret: typing.List[Self] = list(
                map(TestEntry.from_dict, vals)  # type:ignore
            )
            names: typing.Set[str] = set()
            for v in ret:
                if v.test.name in names:
                    raise TestFileError(
                        f"Expected all names to be unique in tests.json, but found {v.test.name} twice."
                    )
                names.add(v.test.name)

            return ret
