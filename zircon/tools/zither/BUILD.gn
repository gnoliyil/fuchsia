# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/fidl/fidl.gni")
import("//build/go/go_binary.gni")
import("//build/go/go_library.gni")
import("//build/toolchain/ifs_shared_library.gni")
import("//tools/fidl/lib/fidlgentest/fidlgentest_go_test.gni")
import("zither_golden_files.gni")
import("zither_library.gni")

group("tests") {
  testonly = true

  deps = [
    # basic unit tests
    ":unittests($host_toolchain)",

    # golden testing
    ":aliases",
    ":bits",
    ":constants",
    ":enums",
    ":experimental_zx_types",
    ":multifile",
    ":resources",
    ":structs",
    ":zx.test",
  ]

  # TODO(fxbug.dev/110295): These dependencies constitute build-time checks
  # that the library remains intelligible to zither. Keep these here as an
  # aide during the deprecation of kazoo and the migration of its duties over
  # to zither.
  foreach(backend, supported_zither_backends) {
    deps += [ "//zircon/vdso:zx_zither.$backend" ]
  }
}

if (is_host) {
  go_binary("zither") {
    library = ":main"
  }

  go_library("main") {
    visibility = [ ":*" ]
    source_dir = "cmd"
    sources = [ "main.go" ]
    deps = [
      ":common",
      "asm",
      "c",
      "golang",
      "kernel",
      "zircon_ifs",
      "//tools/fidl/lib/fidlgen",
      "//tools/lib/color",
      "//tools/lib/flagmisc",
      "//tools/lib/logger",
    ]
  }

  go_library("common") {
    visibility = [ "./*" ]
    deps = [
      "//tools/fidl/lib/fidlgen",
      "//tools/fidl/lib/fidlgen_cpp",
    ]
    sources = [
      "c_family.go",
      "names.go",
      "zither_ir.go",
      "zither_ir_test.go",
    ]
  }

  fidlgentest_go_test("unittests") {
    library = ":common"
    output_name = "zither-unittests"
    deps = [
      "//third_party/golibs:github.com/google/go-cmp",
      "//tools/fidl/lib/fidlgen",
      "//tools/fidl/lib/fidlgentest",
    ]
  }
}

#
# Build-time golden tests
#

# zither_golden_test() defines a suite of build-time golden tests for zither
# backends: a FIDL library and its expected bindings are supplied, and the diff
# checks are made as build actions. Further, a check is made that the bindings
# give valid, compilable code.
#
# `target_name` is assumed to be the associated test case name, as is formally
# defined by the subdirectory names in testdata/ (see testdata/README.md).
# This template further assumes the following properties of the directory's
# organizational structure:
#   * FIDL sources are found in testdata/${case_name}/, at the root of the
#     'case data directory';
#   * Goldens, for a given backend, are found in
#     testdata/${case_name}/goldens/${backend}, the 'backend's case golden
#     directory'
#
# Parameters:
#
#  * sources
#    - Required: FIDL files comprising a single library, from which bindings
#      will be generated, relative to the case FIDL directory. The name of this
#      library is assumed to be `"zither." + string_replace(case_name, "_", ".")`.
#      We derive the FIDL library name with character replacement since
#      underscores are not a permitted as library name characters and a period
#      is the defined separator. One exception to this is "zx.test": if that is
#      the target name, then the library is expected to be called "zx", which
#      permits the testing of things that FIDL currently requires to be defined
#      in a library of that name.
#    - Type: list of relative paths
#
#  * cases
#    - Required: A list of test cases.
#    - Type: list(scope)
#
#    Each scope contains:
#      * backend:
#        - Required: The backend with which to generate bindings. Must be one
#          of `zither_supported_backends` (see zither_library.gni).
#        - Type: string
#      * files
#        - Required: The list of names for the files to be generated by the
#          backend. This list should be in one-to-one correspondence with the
#          the goldens found in the backend's case golden directory.
#        - Type: list(string)
#
template("zither_golden_test") {
  assert(defined(invoker.sources), "no sources given")
  assert(defined(invoker.cases) && invoker.cases != [], "no test cases defined")

  main_target = target_name
  if (target_name == "zx.test") {
    library_target = "zx"
  } else {
    library_target = "zither." + string_replace(target_name, "_", ".")
  }

  case_name = target_name
  case_data_dir = "testdata/${case_name}"

  fidl(library_target) {
    forward_variables_from(invoker, [ "experimental_flags" ])
    sources = []
    foreach(source, invoker.sources) {
      sources += [ "${case_data_dir}/$source" ]
    }
  }

  case_deps = []
  foreach(case, invoker.cases) {
    assert(defined(case.backend), "`${case}` must provide `backend`")
    assert(defined(case.files) && case.files != [],
           "`${case}` must provide `files`")

    backend_label = ":${library_target}_zither.${case.backend}"

    goldens_target =
        "_zither_golden_test.${target_name}-${case.backend}.zither_golden_files"
    compilation_check_target =
        "_zither_golden_test.${target_name}-${case.backend}.compilation_check"

    zither_golden_files(goldens_target) {
      fidl = ":$library_target"
      backend = case.backend

      goldens = []
      foreach(file, case.files) {
        goldens += [ "${case_data_dir}/goldens/${case.backend}/${file}" ]
      }
    }
    case_deps += [ ":$goldens_target" ]

    # Clear from previous iteration.
    backend_info = {
    }
    output_subdir_info = {
    }

    # Reconstruct the output subdirectory per `zither_library()` documentation.
    backend_info = supported_zither_backend_info[case.backend]
    output_subdir_info = {
      prefix_parts = []
      suffix_parts = []
      forward_variables_from(backend_info.output_subdir, "*")
      parts = prefix_parts
      if (defined(library_name_separator)) {
        parts += [ string_replace(library_target, ".", library_name_separator) ]
      }
      parts += suffix_parts
      path = string_join("/", parts)
    }
    if (output_subdir_info.path != "") {
      output_subdir = output_subdir_info.path
    }

    # A per (backend, case) output directory for use below, if needed.
    # Not related to the zither output directory.
    case_output_dir = "$target_gen_dir/${target_name}-${case.backend}"

    # Now verify that the bindings give valid code.
    if (case.backend == "c" || case.backend == "asm") {
      create_source_target = "${compilation_check_target}.create_source"

      if (case.backend == "c") {
        suffix = "c"
      } else if (case.backend == "asm") {
        suffix = "S"
      } else {
        suffix = "cc"
      }
      source = "$case_output_dir/compile-check.$suffix"
      action(create_source_target) {
        visibility = [ ":*" ]
        testonly = true
        script = "testing/create-file-with-includes.py"
        args = [
          "--comment",
          "Generated by //" + rebase_path(script, "//"),
          "--output",
          rebase_path(source, root_build_dir),
        ]
        foreach(file, case.files) {
          args += [ "${output_subdir}/${file}" ]
        }
        outputs = [ source ]
      }

      # loadable_module() over source_set() to pass `-z defs` muster.
      loadable_module(compilation_check_target) {
        visibility = [ ":*" ]
        testonly = true
        sources = [ source ]
        deps = [
          ":$create_source_target",
          backend_label,
        ]
      }
    } else if (case.backend == "go") {
      # We create a simple main file that imports the generated package, which
      # will feed into our compilation check. There is unfortunately no real
      # equivalent of `source_set()` in our go build.
      create_main_target = "${compilation_check_target}.create_main"
      main_file = "$case_output_dir/main.go"
      generated_file(create_main_target) {
        visibility = [ ":*" ]
        testonly = true

        contents = [
          "package main",
          "",
          "import (",
          "  _ \"${output_subdir}\"",  # `_` to avoid usage complaints
          "  _ \"syscall/zx\"",  # Required by fuchsia support quirks.
          ")",
          "",
          "func main() {}",
          "",
        ]
        outputs = [ main_file ]
      }

      # The generated main file now needs to be declared in a package/library.
      main_library_target = "${compilation_check_target}.main_library"
      main_pkg_name = rebase_path(case_output_dir, root_build_dir)
      go_library(main_library_target) {
        visibility = [ ":*" ]
        testonly = true

        name = main_pkg_name
        source_dir = case_output_dir
        sources = [ rebase_path(main_file, source_dir) ]
        deps = [ backend_label ]
        non_go_deps = [ ":$create_main_target" ]
      }

      go_binary(compilation_check_target) {
        library = ":$main_library_target"
        visibility = [ ":*" ]
        testonly = true
      }
    } else if (case.backend == "zircon_ifs") {
      if (current_toolchain == default_toolchain) {
        backend_outputs = get_target_outputs("${backend_label}.gen")
        ifs = ""
        foreach(output, backend_outputs) {
          if (get_path_info(output, "extension") == "ifs") {
            ifs = output
          }
        }
        ifs_shared_library(compilation_check_target) {
          abi = ifs
          deps = [ backend_label ]
        }
      } else {
        group(compilation_check_target) {
          testonly = true
          deps = [ ":$compilation_check_target($default_toolchain)" ]
        }
      }
      not_needed([
                   "backend_label",
                   "case_output_dir",
                   "output_subdir",
                 ])
    } else if (case.backend == "kernel") {
      # The kernel backend generates sources that rely on a number of other
      # kernel and vDSO-specific definitions. Given that and the fact the
      # singular use-case for these sources will be exercised in any default
      # build invocation, it is neither worthwhile nor all that practical to do
      # a compilation check here.
      group(compilation_check_target) {
        visibility = [ ":*" ]
        testonly = true
        deps = [ backend_label ]
      }
      not_needed([
                   "case_output_dir",
                   "output_subdir",
                 ])
    }

    case_deps += [ ":$compilation_check_target" ]
  }

  group(main_target) {
    testonly = true
    visibility = [ ":*" ]
    deps = case_deps
  }
}

# FIDL: testdata/constants/
# Goldens: testdata/constants/goldens/${backend}/
zither_golden_test("constants") {
  sources = [ "constants.test.fidl" ]

  cases = [
    {
      backend = "c"
      files = [ "constants.h" ]
    },
    {
      backend = "asm"
      files = [ "constants.h" ]
    },
    {
      backend = "go"
      files = [
        "constants.go",
        "pkg_name.txt",
      ]
    },
  ]
}

# FIDL: testdata/enums/
# Goldens: testdata/enums/goldens/${backend}/
zither_golden_test("enums") {
  sources = [ "enums.test.fidl" ]

  cases = [
    {
      backend = "c"
      files = [ "enums.h" ]
    },
    {
      backend = "asm"
      files = [ "enums.h" ]
    },
    {
      backend = "go"
      files = [
        "enums.go",
        "pkg_name.txt",
      ]
    },
  ]
}

# FIDL: testdata/bits/
# Goldens: testdata/bits/goldens/${backend}/
zither_golden_test("bits") {
  sources = [ "bits.test.fidl" ]

  cases = [
    {
      backend = "c"
      files = [ "bits.h" ]
    },
    {
      backend = "asm"
      files = [ "bits.h" ]
    },
    {
      backend = "go"
      files = [
        "bits.go",
        "pkg_name.txt",
      ]
    },
  ]
}

# FIDL: testdata/structs/
# Goldens: testdata/structs/goldens/${backend}/
zither_golden_test("structs") {
  sources = [ "structs.test.fidl" ]

  cases = [
    {
      backend = "c"
      files = [ "structs.h" ]
    },
    {
      backend = "asm"
      files = [ "structs.h" ]
    },
    {
      backend = "go"
      files = [
        "pkg_name.txt",
        "structs.go",
      ]
    },
  ]
}

# FIDL: testdata/multifile/
# Goldens: testdata/multifile/goldens/${backend}/
zither_golden_test("multifile") {
  sources = [
    "a.test.fidl",
    "b.test.fidl",
    "c.test.fidl",
  ]

  cases = [
    {
      backend = "c"
      files = [
        "a.h",
        "b.h",
        "c.h",
      ]
    },
    {
      backend = "asm"
      files = [
        "a.h",
        "b.h",
        "c.h",
      ]
    },
    {
      backend = "go"
      files = [
        "a.go",
        "b.go",
        "c.go",
        "pkg_name.txt",
      ]
    },
  ]
}

# FIDL: testdata/aliases/
# Goldens: testdata/aliases/goldens/${backend}/
zither_golden_test("aliases") {
  sources = [ "aliases.test.fidl" ]

  cases = [
    {
      backend = "c"
      files = [ "aliases.h" ]
    },
    {
      backend = "go"
      files = [
        "aliases.go",
        "pkg_name.txt",
      ]
    },
  ]
}

# FIDL: testdata/zx/
# Goldens: testdata/zx/goldens/${backend}/
zither_golden_test("zx.test") {
  experimental_flags = [ "zx_c_types" ]
  sources = [ "zx.test.fidl" ]

  cases = [
    {
      backend = "zircon_ifs"
      files = [ "zircon.ifs" ]
    },
    {
      backend = "kernel"
      files = [
        "category.inc",
        "kernel.inc",
        "syscalls.inc",
        "zx-syscall-numbers.h",
      ]
    },
  ]
}

# TODO(fxbug.dev/110021): These tests reference some experimental built-in
# types introduced in the context of this bug.
zither_golden_test("experimental_zx_types") {
  experimental_flags = [ "zx_c_types" ]

  sources = [ "experimental_zx_types.test.fidl" ]

  cases = [
    {
      backend = "c"
      files = [ "experimental_zx_types.h" ]
    },
    {
      backend = "go"
      files = [ "experimental_zx_types.go" ]
    },
  ]
}

# FIDL: testdata/resources/
# Goldens: testdata/resources/goldens/${backend}/
zither_golden_test("resources") {
  sources = [ "resources.test.fidl" ]
  cases = [
    {
      backend = "c"
      files = [ "resources.h" ]
    },
    {
      backend = "go"
      files = [ "resources.go" ]
    },
  ]
}
