// Copyright 2023 The Fuchsia Authors
//
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT

#ifndef ZIRCON_KERNEL_LIB_ARCH_INCLUDE_LIB_ARCH_X86_INTERRUPT_H_
#define ZIRCON_KERNEL_LIB_ARCH_INCLUDE_LIB_ARCH_X86_INTERRUPT_H_

#include <stdint.h>

namespace arch {

// [intel/vol3]: 6.15 Exception and Interrupt Reference
enum class X86Interrupt : uint8_t {
  kDivideError = 0,
  kDebug = 1,
  kNmi = 2,
  kBreakpoint = 3,
  kOverflow = 4,
  kBoundRangeExceeded = 5,
  kInvalidOpcode = 6,
  kDeviceNotAvailable = 7,
  kDoubleFault = 8,
  kCoprocessorSegmentOverrun = 9,
  kInvalidTss = 10,
  kSegmentNotPresent = 11,
  kStackFaultException = 12,
  kGeneralProtection = 13,
  kPageFault = 14,
  kX87FloatingPoint = 16,
  kAlignmentCheck = 17,
  kMachineCheck = 18,
  kSimdFloatingPoint = 19,
  kVirtualizatoin = 20,
  kControlProtection = 21,

  // 22..31 are reserved for hardware, but not yet specified by Intel.

  // 32..255 are only generated by `INT $n` instructions or APIC programming,
  // not by the CPU directly.
  kFirstUserDefined = 32,
  kLastUserDefined = 255,
};

// [intel/vol3]: 6.15 sections for each interrupt document whether it uses the
// error code.  Most do not, so that's the presumption for the reserved slots.
constexpr bool X86InterruptHasErrorCode(arch::X86Interrupt vector) {
  switch (vector) {
    case arch::X86Interrupt::kDoubleFault:
    case arch::X86Interrupt::kInvalidTss:
    case arch::X86Interrupt::kSegmentNotPresent:
    case arch::X86Interrupt::kStackFaultException:
    case arch::X86Interrupt::kGeneralProtection:
    case arch::X86Interrupt::kPageFault:
    case arch::X86Interrupt::kAlignmentCheck:
    case arch::X86Interrupt::kControlProtection:
      return true;
    default:
      return false;
  }
}

// [intel/vol3]: 6.14.2 64-Bit Mode Stack Frame
// [intel/vol3]: 6.14.3 IRET in IA-32e Mode
//
// This is what's pushed on the stack by the hardware by interrupt and trap
// gates, and popped by the IRET instruction.
struct X86InterruptFrame {
  uint64_t rip;
  uint64_t cs;
  uint64_t rflags;
  uint64_t rsp;
  uint64_t ss;
};

// [intel/vol3]: 6.15 defines the two-letter "#" names for most of these.
constexpr const char* X86InterruptName(arch::X86Interrupt vector) {
  switch (vector) {
    case arch::X86Interrupt::kDivideError:
      return "#DE";
    case arch::X86Interrupt::kDebug:
      return "#DB";
    case arch::X86Interrupt::kNmi:
      return "NMI";
    case arch::X86Interrupt::kBreakpoint:
      return "#BP";
    case arch::X86Interrupt::kOverflow:
      return "#OF";
    case arch::X86Interrupt::kBoundRangeExceeded:
      return "#BR";
    case arch::X86Interrupt::kInvalidOpcode:
      return "#UD";
    case arch::X86Interrupt::kDeviceNotAvailable:
      return "#NM";
    case arch::X86Interrupt::kCoprocessorSegmentOverrun:
      return "#CO";
    case arch::X86Interrupt::kDoubleFault:
      return "#DF";
    case arch::X86Interrupt::kInvalidTss:
      return "#TS";
    case arch::X86Interrupt::kSegmentNotPresent:
      return "#NP";
    case arch::X86Interrupt::kStackFaultException:
      return "#SS";
    case arch::X86Interrupt::kGeneralProtection:
      return "#GP";
    case arch::X86Interrupt::kPageFault:
      return "#PF";
    case arch::X86Interrupt::kX87FloatingPoint:
      return "#MF";
    case arch::X86Interrupt::kAlignmentCheck:
      return "#AC";
    case arch::X86Interrupt::kMachineCheck:
      return "#MC";
    case arch::X86Interrupt::kSimdFloatingPoint:
      return "#XM";
    case arch::X86Interrupt::kVirtualizatoin:
      return "#VE";
    case arch::X86Interrupt::kControlProtection:
      return "#CP";

      // Not making this a `default:` gets the compiler's -Wswitch to warn
      // about any missing entries from the enum.
    case arch::X86Interrupt::kFirstUserDefined... arch::X86Interrupt::kLastUserDefined:
      break;
  }
  return "???";
}

}  // namespace arch

#endif  // ZIRCON_KERNEL_LIB_ARCH_INCLUDE_LIB_ARCH_X86_INTERRUPT_H_
