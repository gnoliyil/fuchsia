# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/components/fuchsia_unittest_package.gni")
import("//build/cpp/library_headers.gni")
import("//build/cpp/verify_public_symbols.gni")
import("//build/test.gni")
import("//build/toolchain/ifs_extract.gni")
import("//build/toolchain/ifs_shared_library.gni")

# TODO(fxbug.dev/121817): This will be used for the static library of support
# code.  It provides access to additional <lib/ld/...> headers for support code
# that isn't itself part of of the passive ABI.
library_headers("headers") {
  headers = []

  public_deps = [ ":abi-headers" ]
}

# This is the linkable target for using the passive ABI.
# It gives access to the passive ABI dynamic linkage symbols
# and to the header files declaring the `ld::abi` namespace.
ifs_shared_library("ld") {
  abi = "ld.ifs"
  public_deps = [ ":abi-headers" ]
}

library_headers("abi-headers") {
  headers = [
    "lib/ld/abi.h",
    "lib/ld/module.h",
  ]

  public_deps = [
    "//sdk/lib/stdcompat",
    "//src/lib/elfldltl:headers",
  ]
}

# This is the SONAME reflecting the passive ABI defined here.
# It has to match what's in ld.ifs and in ld::abi::kSoname (<lib/ld/abi.h>).
config("abi-soname") {
  ldflags = [ "-Wl,-soname=ld.so.1" ]
}

# `verify_ld_abi(ld) {}` defines "$ld.verify-abi" to check that the
# shared_library(ld) or loadable_module(ld) matches the passive ABI.
template("verify_ld_abi") {
  ld_target = target_name
  extract_target = "$ld_target.ifs"
  verify_target = "$ld_target.verify-abi"
  ifs_file = "$target_out_dir/$extract_target"

  ifs_extract(extract_target) {
    visibility = [ ":*" ]
    forward_variables_from(invoker, [ "testonly" ])
    outputs = [ ifs_file ]
    deps = [ ":$ld_target" ]
  }

  verify_public_symbols(verify_target) {
    visibility = [ ":*" ]
    forward_variables_from(invoker, [ "testonly" ])
    deps = [ ":$extract_target" ]
    current = ifs_file
    reference = "ld.ifs"
    library_name = get_label_info(":$ld_target", "label_with_toolchain")
  }
}

# There's no real difference between a shared library and a loadable module
# with a SONAME, but loadable_module() does its own variant selection.  Since
# the stub ld.so is really just a data ABI image, there's no meaningful sense
# in which it could be in the same variant as its users.
loadable_module("stub-ld") {
  configs += [
    "//build/config/fuchsia:no_cpp_standard_library",
    "//build/config/zircon:nolibc",
    ":abi-soname",
  ]
  deps = [ ":abi" ]

  # Since it has no C++ code (only a data definition), it doesn't really matter
  # for this to use the user.basic build environment as the startup dynamic
  # linker must.  But we don't want it to have any instrumentation hair that
  # might be generated even with no C++ functions.
  exclude_toolchain_tags = [ "instrumented" ]
}

verify_ld_abi("stub-ld") {
}

source_set("abi") {
  visibility = [ ":*" ]

  public = [ "mutable-abi.h" ]
  sources = [ "mutable-abi.cc" ]
  deps = [ ":headers" ]
}

test("ld-unittests") {
  sources = [ "abi-tests.cc" ]
  deps = [
    ":headers",
    "//src/lib/fxl/test:gtest_main",
  ]
}

fuchsia_unittest_package("ld-tests") {
  deps = [ ":ld-unittests" ]
}

group("tests") {
  testonly = true

  deps = [
    ":ld-tests",
    ":ld-unittests($host_toolchain)",
    ":stub-ld.verify-abi",
  ]
}
