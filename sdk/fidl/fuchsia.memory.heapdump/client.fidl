// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
library fuchsia.memory.heapdump.client;

using zx;

const MAX_BUILD_ID_LENGTH uint32 = 32;

/// The reason why a method failed.
type CollectorError = flexible enum {
    /// The given ProcessSelector value is not supported.
    PROCESS_SELECTOR_UNSUPPORTED = 1;

    /// The given ProcessSelector value does not match any process.
    PROCESS_SELECTOR_NO_MATCH = 2;

    /// The given ProcessSelector value matches more than one process but the requested operation
    /// needs a unique match.
    PROCESS_SELECTOR_AMBIGUOUS = 3;

    /// Failed to take a live snapshot.
    LIVE_SNAPSHOT_FAILED = 4;
};

/// Filter to restrict an operation to a subset of the available processes.
type ProcessSelector = flexible union {
    /// Matches any process with the given ZX_PROP_NAME.
    1: by_name string:zx.MAX_NAME_LEN;

    /// Matches the process with the given koid.
    2: by_koid zx.Koid;
};

/// An allocated memory block.
type Allocation = table {
    /// The address of the memory block.
    1: address uint64;

    /// Block size, in bytes.
    2: size uint64;

    /// The stack trace of the allocation site.
    3: stack_trace_key uint64;

    /// Allocation timestamp.
    4: timestamp zx.Time;
};

/// A stack trace.
///
/// In order to avoid exceeding the channel's maximum message size, stack traces can be split in
/// multiple chunks. Receivers should be prepared to handle multiple StackTrace elements with the
/// same key and reassemble them by concatenating their program addresses.
type StackTrace = table {
    /// A number that uniquely identifies this stack trace within the parent snapshot.
    1: stack_trace_key uint64;

    /// The program counters corresponding to stack each frame.
    ///
    /// Entries are listed in reverse call order: the first entry refers to the leaf frame, and the
    /// last entry refers to the frame at the root of the call stack.
    2: program_addresses vector<uint64>:MAX;
};

/// An ELF build ID.
type BuildId = struct {
    value vector<uint8>:MAX_BUILD_ID_LENGTH;
};

/// A memory region containing code loaded from an ELF file.
type ExecutableRegion = table {
    /// The address of the memory region.
    1: address uint64;

    /// Region size, in bytes.
    2: size uint64;

    /// The file offset corresponding to the first byte within the region.
    3: file_offset uint64;

    /// The build ID of the ELF file.
    4: build_id BuildId;
};

/// The contents of an allocated memory block.
///
/// In order to avoid exceeding the channel's maximum message size, bigger blocks can be split in
/// chunks. Receivers should be prepared to handle multiple BlockContents with the same address and
/// reassemble them by concatenating their payloads. Each block's reassembled size always matches
/// the size field of the corresponding Allocation.
type BlockContents = table {
    /// The address of the corresponding memory block.
    1: address uint64;

    /// The payload.
    2: contents vector<byte>:MAX;
};

/// An element that is part of a snapshot.
type SnapshotElement = flexible union {
    1: allocation Allocation;
    2: stack_trace StackTrace;
    3: executable_region ExecutableRegion;
    4: block_contents BlockContents;
};

/// Protocol to transmit a snapshot as a stream of elements.
protocol SnapshotReceiver {
    /// Delivers a batch of snapshot elements.
    ///
    /// It will be called repeatedly until no elements are left, and then one final time with an
    /// empty vector to signal the end of the stream.
    Batch(struct {
        batch vector<SnapshotElement>:MAX;
    }) -> ();
};

/// Protocol to request and retrieve memory profiles.
@discoverable
protocol Collector {
    /// Obtains a snapshot of the current live allocations in an instrumented process.
    TakeLiveSnapshot(table {
        /// The instrumented process to operate on.
        ///
        /// Required.
        1: process_selector ProcessSelector;

        /// Whether the snapshot should include the contents of each memory block.
        ///
        /// If not set, false is assumed.
        2: with_contents bool;
    }) -> (resource struct {
        receiver server_end:SnapshotReceiver;
    }) error CollectorError;
};
