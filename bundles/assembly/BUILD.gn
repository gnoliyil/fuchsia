# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/assembly/assembly_input_bundle.gni")
import("//build/info/info.gni")

assert(is_fuchsia,
       "Assembly Input Bundles can only be in the Fuchsia toolchain")

# All of the platform assembly input bundles.
group("assembly") {
  testonly = true
  deps = [
    ###
    # The common platform bundles

    # bringup feature-set-level:
    ":common_bringup",

    # minimal feature-set-level:
    ":common_minimal",
    ":common_minimal_eng",
    ":common_minimal_userdebug",

    # Emulator Support
    ":emulator_support",

    ###
    # Feature-level / Subsystem-level bundles

    # SWD (Software Delivery)
    ":system-update-checker",
    ":omaha-client",

    # Kernel args
    ":kernel_args_eng",
    ":kernel_args_user",
    ":kernel_args_userdebug",
  ]
}

# This group is temporarily used to publish the non-eng assembly bundles to the
# generated_assembly_inputs() template.
group("prod_only") {
  testonly = false
  deps = [
    ":common_bringup",
    ":common_minimal",
    ":emulator_support",
    ":kernel_args_user",
  ]
}

# The most-common, most-basic, Assembly Input Bundle that is included by all
# products.  No product can function without these.
#
# This corresponds to a subset the "bringup" platform configuration, the
# most-basic configuration that can boot.
#
# WARNING:  The only way to remove items from this AIB for a given product is to
# move them to other AIBs that are included by all other products.
#
assembly_input_bundle("common_bringup") {
  bootfs_packages = [ "//src/bringup/bin/svchost:pkg" ]
  kernel_cmdline = [ "blobfs.cache-eviction-policy=NEVER_EVICT" ]

  bootfs_files = [
    {
      # This file is generated by GN
      source = build_info_files.minimum_utc_stamp
      destination = "config/build_info/minimum_utc_stamp"
      label = "//build/info:latest-commit-date"
    },
  ]
}

# All eng build type products will include this Assembly Input Bundle.
# These kernel args should be refactored so that the AIBs have logical names.
assembly_input_bundle("kernel_args_eng") {
  kernel_cmdline = [
    "console.shell=true",
    "kernel.enable-debugging-syscalls=true",
    "kernel.enable-serial-syscalls=true",
    "netsvc.all-features=true",
    "netsvc.disable=false",
  ]
}

# All userdebug build type products will include this Assembly Input Bundle.
# These kernel args should be refactored so that the AIBs have logical names.
assembly_input_bundle("kernel_args_userdebug") {
  kernel_cmdline = [
    "console.shell=false",
    "kernel.enable-debugging-syscalls=false",
    "kernel.enable-serial-syscalls=output-only",
    "netsvc.disable=true",
  ]
}

# All user build type products will include this Assembly Input Bundle.
#
# These are all the default values, so this AIB can be safely removed, but we
# are keeping it around for now so that we can assert that nothing changed
# during refactor.
#
# These kernel args should be refactored so that the AIBs have logical names.
assembly_input_bundle("kernel_args_user") {
  kernel_cmdline = [
    "console.shell=false",
    "kernel.enable-debugging-syscalls=false",
    "kernel.enable-serial-syscalls=false",
    "netsvc.disable=true",
  ]
}

# The most-common, most-basic, Assembly Input Bundle that is included by all
# products that have an FVM (and therefore have base packages).
#
# This corresponds to the "minimal" platform configuration, the most-basic
# configuration that has pkg_resolver and pkg_cache, and can OTA itself.
#
# WARNING:  The only way to remove items from this AIB for a given product is to
# move them to other AIBs that are included by all other products.
#
assembly_input_bundle("common_minimal") {
  base_packages = [
    # The required SWD stack artifacts to enable packages in an FVM.
    "//src/sys/pkg/bin/pkg-cache",
    "//src/sys/pkg/bin/pkg-resolver",

    # The SWD stack artifacts that enable OTAs
    "//src/sys/pkg/bin/system-update-committer",
    "//src/sys/pkg/bin/system-updater",

    # Build-Information
    "//src/developer/build_info:build-info-service",

    # Hardware Information
    "//src/hwinfo:hwinfo",

    # Diagnostics
    "//src/cobalt/bin/app:cobalt",
    "//src/cobalt/bin/system-metrics:cobalt_system_metrics",
    "//src/diagnostics/log-stats:package",
    "//src/diagnostics/persistence:diagnostics-persistence",
    "//src/diagnostics/kcounter:diagnostics-kcounter",

    # Other
    "//src/sys/stash:pkg",

    "//src/sys/time/timekeeper",
    "//src/sys/time/httpsdate_time_source:httpsdate-time-source",

    # Security
    "//src/security/bin/root_ssl_certificates",

    # Activity
    "//src/sys/activity",

    # Developer
    "//src/developer/forensics:pkg",
    "//src/developer/memory/monitor",
  ]

  bootfs_files = [
    {
      source = "//src/sys/core/config/core.profiles"
      destination = "config/profiles/core.profiles"
    },
  ]

  config_data = [
    {
      package_name = "system-update-committer"
      files = [
        {
          # This file is generated by GN, but its contents are always the same
          # (the template which generates it is basically a macro, and has no
          # product-controlled GN arguments or metadata).
          source = "$root_build_dir/gen/src/sys/pkg/bin/system-update-committer/system_update_committer_config_enable_reboot_on_verification_failure.json"
          destination = "config.json"
          label = "//src/sys/pkg/bin/system-update-committer:enable_reboot_on_verification_failure"
        },
      ]
    },
    {
      package_name = "triage-detect"
      files = [
        {
          source =
              "//src/diagnostics/config/triage/detect/session-detect.triage"
          destination = "session-detect.triage"
        },
        {
          source = "//src/diagnostics/config/triage/detect/sysmem-detect.triage"
          destination = "sysmem-detect.triage"
        },
        {
          source = "//src/diagnostics/config/triage/detect/wlan-detect.triage"
          destination = "wlan-detect.triage"
        },
      ]
    },
    {
      package_name = "diagnostics-persistence"
      files = [
        {
          source = "//src/diagnostics/config/persistence/netstack.persist"
          destination = "netstack.persist"
        },
        {
          source = "//src/diagnostics/config/persistence/wlan.persist"
          destination = "wlan.persist"
        },
      ]
    },
  ]
}

# This is common across all eng-mode products, at the minimal or higher service
# level.
#
assembly_input_bundle("common_minimal_eng") {
  testonly = true
  base_packages = [
    # Empty placeholder for now, this is setting up the pattern, before actually
    # moving packages into it (the next CL)

    # Dash launcher should be available in every engineering-mode product.
    "//src/sys/tools/debug-dash-launcher",
  ]
}

# This is common across all eng-mode and user-debug products, at the minimal or
# higher service level.
#
assembly_input_bundle("common_minimal_userdebug") {
  base_packages = [ "//src/diagnostics/detect:triage-detect" ]
}

# This is the "emulator support" bundle, which provides the kernel that can be
# booted by an emulator, and which knows how to then boot the Fuchsia kernel
# itself (Zircon).
assembly_input_bundle("emulator_support") {
  # Which label and file the qemu kernel is at is dependent on the arch of the
  # target we are compiling for.
  if (target_cpu == "x64") {
    _qemu_kernel_file = "$root_build_dir/multiboot.bin"
    _qemu_kernel_target =
        "//zircon/kernel/arch/x86/phys/boot-shim:multiboot-shim"
  } else if (target_cpu == "arm64") {
    _qemu_kernel_file = "$root_build_dir/qemu-boot-shim.bin"
    _qemu_kernel_target = "//zircon/kernel/target/arm64/boot-shim:qemu"
  } else {
    assert(false, "Unsupported target cpu: $target_cpu")
  }

  qemu_kernel = _qemu_kernel_file
  deps = [ _qemu_kernel_target ]
}

assembly_input_bundle("system-update-checker") {
  testonly = true
}

assembly_input_bundle("omaha-client") {
}
