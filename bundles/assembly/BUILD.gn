# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# NOTE:  This is the only file that can be imported in this BUILD.gn file.  No
# other files are to be imported.
import("//build/assembly/assembly_input_bundle.gni")
import("//bundles/assembly/platform_aibs.gni")

########
# Guaranteed Invariants
#
#
# Invariants that are guaranteed by these platform-defined Assembly Input
# Bundles (AIBs):
#
# 1) Their contents are bitwise identical for all boards and products, for a
#    given architecture and "debug" vs. "release".  They could be built once-
#    each for the following, and then used as prebuilts if the build supported
#    that:
#      - x64-release
#      - x64-debug
#      - arm64-release
#      - arm64-debug
#    This is not currently possible given the state of the in-tree build, but it
#    is a contract that we have for using these with our OOT product assembly
#    environments.
#
# 2) Each AIB directly lists files that it includes, or the label to the exact
#    GN target that it includes.  They do not include group() targets.
#
# 3) Any single artifact is only included in one AIB.

########
# Maintenance Guidelines
#
# DO:  Prefer verboseness and clarity over abstractions and delegation.
#
# The template used in this file requires the direct listing of the package,
# config_data, and bootfs labels or entries.
#
# DO NOT: import a file that defines, for example, a list of labels or a set of
# config_data entries, that are added to an AIB using a GN variable.
#
# Importing other files which define variables used to provide the contents for
# an AIB reduces the clarity of how an artifact gets included first in AIBs, and
# later the assembled image.  This makes it harder to reason about how and when
# the artifacts are included within the assembled product.

assert(is_fuchsia,
       "Assembly Input Bundles can only be in the Fuchsia toolchain")

# All of the platform assembly input bundles.
group("assembly") {
  testonly = true

  # eng_platform_aib_labels come from //bundles/assembly/platform_aibs.gni.
  deps = eng_platform_aib_labels
}

########
#
# The /bootstrap realm AIBs
#
# The most-common, most-basic, Assembly Input Bundles that are included by all
# assembled systems.  No system can function without these.
#
# These provide the `/bootstrap` realm and its children that are always present
# in each of the build-types.
#

# The most-common, most-basic, AIB that is included in all assembled systems,
# regardless of build-type.
#
# WARNING:  The only way to remove items from this AIB for a given product is to
# move them to other AIBs that are included by all other products.
#
assembly_input_bundle("bootstrap") {
  bootfs_files_labels = [
    "//src/bringup:bootfs",
    "//src/bringup/bin/debuglog:bootfs",
    "//src/bringup/bin/dlog:bootfs",
    "//src/bringup/bin/waitfor:bootfs",
    "//src/power/power-manager:bootfs",
    "//src/sys/bootstrap:bootfs",
    "//src/sys/component_manager:bootfs",
  ]
  bootfs_packages = [
    "//src/bringup/bin/svchost:pkg",
    "//src/bringup/bin/console:package",
    "//src/bringup/bin/console-launcher:package",
    "//src/bringup/bin/device-name-provider:package",
    "//src/bringup/bin/miscsvc:package",
    "//src/bringup/bin/netsvc:package",
    "//src/bringup/bin/ptysvc:package",
    "//src/bringup/bin/pwrbtn-monitor:package",
    "//src/bringup/bin/sysinfo:package",
    "//src/devices/bin/devfs:package",
    "//src/devices/bin/driver-index:package",
    "//src/devices/bin/driver_manager:package",
    "//src/power/shutdown-shim:package",
  ]
  kernel_cmdline = [ "blobfs.cache-eviction-policy=NEVER_EVICT" ]

  bootfs_files = [
    {
      # The CFv2 topology root
      label = "//src/sys/root"
      source = get_label_info(label, "target_out_dir") +
               "/root_component_manifest/root.cm"
      destination = "meta/root.cm"
    },
    {
      # This file is generated by GN
      source = "$root_build_dir/minimum-utc-stamp.txt"
      destination = "config/build_info/minimum_utc_stamp"
      label = "//build/info:latest-commit-date"
    },
  ]
}

# The virtcon AIB is included by all eng and userdebug products, and can be
# optionally included by user products.
#
assembly_input_bundle("virtcon") {
  bootfs_files_labels = [
    "//src/bringup/bin/virtcon:bootfs",

    # TODO(120776) The boot animation is configured via a global GN arg, which
    # needs to be migrated to a path provided by the product to assembly, which
    # then places it in the appropriate path in bootfs.
    #
    # As such, this isn't something that should be added to a platform bundle,
    # but the migration with the products that use that GN arg is sufficiently
    # complicated that this is clearer that trying to do a removal of the
    # default boot animation in those products that shouldn't include it (if
    # it's included by default via `//products/common/bringup.gni`).
    "//src/bringup/bin/virtcon:boot_animation",
  ]
}

# All eng build type products will include this Assembly Input Bundle.
# These kernel args should be refactored so that the AIBs have logical names.
#
assembly_input_bundle("kernel_args_eng") {
  kernel_cmdline = [
    "console.shell=true",
    "kernel.enable-debugging-syscalls=true",
    "kernel.enable-serial-syscalls=true",
    "netsvc.all-features=true",
    "netsvc.disable=false",
  ]
}

# All userdebug build type products will include this Assembly Input Bundle.
# These kernel args should be refactored so that the AIBs have logical names.
#
assembly_input_bundle("kernel_args_userdebug") {
  kernel_cmdline = [
    "console.shell=false",
    "kernel.enable-debugging-syscalls=false",
    "kernel.enable-serial-syscalls=output-only",
    "netsvc.disable=true",
  ]
}

# All user build type products will include this Assembly Input Bundle.
#
# These are all the default values, so this AIB can be safely removed, but we
# are keeping it around for now so that we can assert that nothing changed
# during refactor.
#
# These kernel args should be refactored so that the AIBs have logical names.
assembly_input_bundle("kernel_args_user") {
  kernel_cmdline = [
    "console.shell=false",
    "kernel.enable-debugging-syscalls=false",
    "kernel.enable-serial-syscalls=false",
    "netsvc.disable=true",
  ]
}

########
#
# The /core realm AIBs
#
# These are the Assembly Input Bundles that are included by all assembled
# systems that include the `/core` realm.

# core_realm
#
# This AIB adds the `/core` realm itself, and it's mandatory children.  The
# other AIBs in this group add shards and optional children of `/core`.
#
# This is "less than minimal".  "utility" systems include this to get a `/core`
# realm, but do not include the `common_minimal` AIB as that brings in too much
# functionality for these specialized systems.
#
assembly_input_bundle("core_realm") {
  base_packages = [
    # The required SWD stack artifacts to enable packages in an FVM.
    "//src/sys/pkg/bin/pkg-cache",
    "//src/sys/pkg/bin/pkg-resolver",

    # This is a required dependency of pkg-cache
    "//src/sys/pkg/bin/system-update-committer",

    # Build-Information
    "//src/developer/build_info:build-info-service",

    # Hardware Information
    "//src/hwinfo:hwinfo",

    # System Time
    "//src/sys/time/timekeeper",
    "//src/sys/time/httpsdate_time_source:httpsdate-time-source",

    # Other
    "//src/sys/stash:pkg",
  ]

  compiled_packages = [
    {
      name = "core"
      component_shards = {
        core = [
          # TODO:  These shards should be folded into the `core.cml` file itself
          # as they are never omitted from that file.

          # All paths must be rebased since this is passed directly to the AIB
          # config.
          rebase_path(
              "//src/developer/build_info/meta/build_info.core_shard.cml",
              root_build_dir),
        ]
      }
    },
  ]
}

# This corresponds to the "minimal" platform configuration, the most-basic
# configuration that has pkg_resolver and pkg_cache, and can OTA itself.
#
# WARNING:  The only way to remove items from this AIB for a given product is to
# move them to other AIBs that are included by all other products.
#
assembly_input_bundle("common_minimal") {
  base_packages = [
    # The SWD stack artifacts that enable OTAs
    "//src/sys/pkg/bin/system-updater",

    # Diagnostics
    "//src/cobalt/bin/app:cobalt",
    "//src/cobalt/bin/system-metrics:cobalt_system_metrics",
    "//src/diagnostics/log-stats:package",
    "//src/diagnostics/persistence:diagnostics-persistence",
    "//src/diagnostics/kcounter:diagnostics-kcounter",
    "//src/diagnostics/sampler",

    # Security
    "//src/security/bin/root_ssl_certificates",

    # Activity
    "//src/sys/activity",

    # Developer
    "//src/developer/forensics:pkg",
    "//src/developer/memory/monitor",
  ]

  bootfs_files = [
    {
      source = "//src/sys/core/config/core.profiles"
      destination = "config/profiles/core.profiles"
    },
  ]

  config_data = [
    {
      package_name = "system-update-committer"
      files = [
        {
          # This file is generated by GN, but its contents are always the same
          # (the template which generates it is basically a macro, and has no
          # product-controlled GN arguments or metadata).
          source = "$root_build_dir/gen/src/sys/pkg/bin/system-update-committer/system_update_committer_config_enable_reboot_on_verification_failure.json"
          destination = "config.json"
          label = "//src/sys/pkg/bin/system-update-committer:enable_reboot_on_verification_failure"
        },
      ]
    },
    {
      package_name = "triage-detect"
      files = [
        {
          source =
              "//src/diagnostics/config/triage/detect/session-detect.triage"
          destination = "session-detect.triage"
        },
        {
          source = "//src/diagnostics/config/triage/detect/sysmem-detect.triage"
          destination = "sysmem-detect.triage"
        },
        {
          source = "//src/diagnostics/config/triage/detect/wlan-detect.triage"
          destination = "wlan-detect.triage"
        },
      ]
    },
    {
      package_name = "diagnostics-persistence"
      files = [
        {
          source = "//src/diagnostics/config/persistence/netstack.persist"
          destination = "netstack.persist"
        },
        {
          source = "//src/diagnostics/config/persistence/wlan.persist"
          destination = "wlan.persist"
        },
      ]
    },
  ]

  config_data_labels = [
    "//src/diagnostics/config/sampler:sampler_config_internal",
    "//src/diagnostics/config/fire:fire_config_component_list",
    "//src/diagnostics/config/fire/projects:fire_config_projects",
  ]

  compiled_packages = [
    {
      name = "core"
      component_shards = {
        core = [
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          rebase_path(
              "//src/sys/process-resolver/meta/process_resolver.core_shard.cml",
              root_build_dir),
          rebase_path(
              "//src/diagnostics/kcounter/meta/diagnostics-kcounter.core_shard.cml",
              root_build_dir),
          rebase_path(
              "//src/diagnostics/log-stats/meta/log-stats.core_shard.cml",
              root_build_dir),
          rebase_path("//src/diagnostics/realm/meta/diagnostics.core_shard.cml",
                      root_build_dir),
          rebase_path(
              "//src/diagnostics/persistence/meta/diagnostics-persistence.core_shard_new.cml",
              root_build_dir),

          rebase_path("//src/diagnostics/sampler/meta/sampler.core_shard.cml",
                      root_build_dir),
          rebase_path(
              "//src/connectivity/network/meta/persistence.core_shard.cml",
              root_build_dir),
        ]
      }
    },
    {
      name = "diagnostics"
      components = {
        diagnostics =
            [ rebase_path("//src/diagnostics/realm/meta/diagnostics_realm.cml",
                          root_build_dir) ]
      }
    },
  ]
}

# This is common across all eng-mode products, at the minimal or higher service
# level.
#
assembly_input_bundle("common_minimal_eng") {
  testonly = true
  base_packages = [
    # Empty placeholder for now, this is setting up the pattern, before actually
    # moving packages into it (the next CL)

    # Dash launcher should be available in every engineering-mode product.
    "//src/sys/tools/debug-dash-launcher",

    # The fs_realm component should be available in every engineering-mode product.
    "//src/storage/fs_realm",
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = {
        core = [
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          rebase_path(
              "//src/sys/tools/debug-dash-launcher/meta/debug_dash_launcher.core_shard.cml",
              root_build_dir),
          rebase_path("//src/storage/fs_realm/meta/fs_realm.core_shard.cml",
                      root_build_dir),
        ]
      }
    },
  ]
}

# This is common across all eng-mode and user-debug products, at the minimal or
# higher service level.
#
assembly_input_bundle("common_minimal_userdebug") {
  base_packages = [ "//src/diagnostics/detect:triage-detect" ]
  compiled_packages = [
    {
      name = "diagnostics"
      component_shards = {
        diagnostics = [ rebase_path(
                "//src/diagnostics/detect/meta/detect.realm_shard.cml",
                root_build_dir) ]
      }
    },
    {
      name = "core"
      component_shards = {
        core = [ rebase_path(
                "//src/diagnostics/detect/meta/detect.core_shard_new.cml",
                root_build_dir) ]
      }
    },
  ]
}

# Core starnix support.
assembly_input_bundle("starnix_support") {
  base_packages = [ "//src/proc/bin/starnix_manager:starnix_package" ]
  if (target_cpu == "x64") {
    base_packages += [ "//src/proc/bin/starnix:starnix_kernel_package" ]
  }
  compiled_packages = [
    {
      name = "core"
      component_shards = {
        core = [ rebase_path(
                "//src/proc/bin/starnix_manager/meta/starnix_manager.core_shard.cml",
                root_build_dir) ]
      }
    },
  ]
}

# This is the "emulator support" bundle, which provides the kernel that can be
# booted by an emulator, and which knows how to then boot the Fuchsia kernel
# itself (Zircon).
assembly_input_bundle("emulator_support") {
  # Which label and file the qemu kernel is at is dependent on the arch of the
  # target we are compiling for.
  if (target_cpu == "x64") {
    _qemu_kernel_file = "$root_build_dir/multiboot.bin"
    _qemu_kernel_target =
        "//zircon/kernel/arch/x86/phys/boot-shim:multiboot-shim"
  } else if (target_cpu == "arm64") {
    _qemu_kernel_file = "$root_build_dir/qemu-boot-shim.bin"
    _qemu_kernel_target = "//zircon/kernel/target/arm64/boot-shim:qemu"
  } else {
    assert(false, "Unsupported target cpu: $target_cpu")
  }

  qemu_kernel = _qemu_kernel_file
  deps = [ _qemu_kernel_target ]
}

assembly_input_bundle("system_update_checker") {
  testonly = true
}

assembly_input_bundle("omaha_client") {
}

# AIB to enable virtualization support.
assembly_input_bundle("virtualization_support") {
  base_packages = [ "//src/virtualization/bin/vmm_launcher" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = {
        core = [ rebase_path(
                "//src/virtualization/bin/vmm_launcher/meta/vmm_launcher.core_shard.cml",
                root_build_dir) ]
      }
    },
  ]
}

assembly_input_bundle("wlan_base") {
  base_packages = [
    "//src/connectivity/location/regulatory_region",
    "//src/connectivity/wlan/wlancfg",
  ]
}

assembly_input_bundle("wlan_legacy_privacy_support") {
  base_packages = []
}

assembly_input_bundle("wlan_contemporary_privacy_only_support") {
  base_packages = []
}

assembly_input_bundle("wlan_fullmac_support") {
  base_packages = [
    # This is temporarily placed here while USME migration is ongoing.
    # TODO(fxbug.dev/66772): Move this to "wlan_legacy_privacy_support" AIB once USME
    #                        migration is done.
    "//src/connectivity/wlan/wlandevicemonitor:wlandevicemonitor-legacy-privacy",
  ]
  base_driver_packages = [
    {
      package_target = "//src/connectivity/wlan/drivers/wlanif"
      driver_components = [ "meta/wlanif.cm" ]
    },
  ]
}

assembly_input_bundle("wlan_softmac_support") {
  base_packages = [
    # This is temporarily placed here while USME migration is ongoing.
    # TODO(fxbug.dev/66772): Move the below package(s) to "wlan_contemporary_privacy_only_support"
    #                        AIB once USME migration is done.
    "//src/connectivity/wlan/wlandevicemonitor:wlandevicemonitor-legacy-wlanstack",
    "//src/connectivity/wlan/wlanstack",
  ]
  base_driver_packages = [
    {
      package_target = "//src/connectivity/wlan/drivers/wlansoftmac"
      driver_components = [ "meta/wlansoftmac.cm" ]
    },
  ]
}

assembly_input_bundle("live_usb") {
  bootfs_packages = [ "//src/sys/live_usb:package" ]

  kernel_cmdline = [ "live_usb.is_system=true" ]
}

assembly_input_bundle("empty_live_usb") {
  bootfs_packages = [ "//src/sys/live_usb:empty_package" ]
}

# Example assembly input bundle for testing
assembly_input_bundle("example_assembly_bundle") {
  testonly = true
  compiled_packages = [
    # Main definition for another package
    {
      name = "foo"

      # Test that multiple components work
      components = {
        bar = [ rebase_path(
                "//src/tests/assembly/assemble_image/compiled_package/meta/test.cml",
                root_build_dir) ]
        baz = [ rebase_path(
                "//src/tests/assembly/assemble_image/compiled_package/meta/test.cml",
                root_build_dir) ]
      }
    },

    # Add a shard to the `core` package which should have a main definition
    # in the legacy bundle
    {
      name = "core"
      component_shards = {
        core = [
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          rebase_path(
              "//src/tests/assembly/assemble_image/compiled_package/meta/test.core_shard.cml",
              root_build_dir),
        ]
      }
    },
  ]
}

# AIB containing the default variant of fshost with fxfs enabled
assembly_input_bundle("fshost_fxfs") {
  bootfs_files_labels = [
    "//src/storage/fshost-rust:fshost_rust_fxfs_bootfs",
    "//src/storage/bin/blobfs:bootfs",
  ]
}
