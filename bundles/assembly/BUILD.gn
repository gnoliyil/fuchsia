# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# NOTE:  This is the only file that can be imported in this BUILD.gn file.  No
# other files are to be imported.
import("//build/assembly/assembly_input_bundle.gni")
import("//bundles/assembly/platform_aibs.gni")

########
# Guaranteed Invariants
#
#
# Invariants that are guaranteed by these platform-defined Assembly Input
# Bundles (AIBs):
#
# 1) Their contents are bitwise identical for all boards and products, for a
#    given architecture and "debug" vs. "release".  They could be built once-
#    each for the following, and then used as prebuilts if the build supported
#    that:
#      - x64-release
#      - x64-debug
#      - arm64-release
#      - arm64-debug
#    This is not currently possible given the state of the in-tree build, but it
#    is a contract that we have for using these with our OOT product assembly
#    environments.
#
# 2) Each AIB directly lists files that it includes, or the label to the exact
#    GN target that it includes.  They do not include group() targets.
#
# 3) Any single artifact is only included in one AIB.

########
# Maintenance Guidelines
#
# DO:  Prefer verboseness and clarity over abstractions and delegation.
#
# The template used in this file requires the direct listing of the package,
# config_data, and bootfs labels or entries.
#
# DO NOT: import a file that defines, for example, a list of labels or a set of
# config_data entries, that are added to an AIB using a GN variable.
#
# Importing other files which define variables used to provide the contents for
# an AIB reduces the clarity of how an artifact gets included first in AIBs, and
# later the assembled image.  This makes it harder to reason about how and when
# the artifacts are included within the assembled product.

assert(is_fuchsia,
       "Assembly Input Bundles can only be in the Fuchsia toolchain")

# All of the platform assembly input bundles.
group("assembly") {
  testonly = true

  # eng_platform_aib_labels come from //bundles/assembly/platform_aibs.gni.
  deps = eng_platform_aib_labels
}

# The most-common, most-basic, Assembly Input Bundle that is included by all
# products.  No product can function without these.
#
# This corresponds to a subset the "bringup" platform configuration, the
# most-basic configuration that can boot.
#
# WARNING:  The only way to remove items from this AIB for a given product is to
# move them to other AIBs that are included by all other products.
#
assembly_input_bundle("common_bringup") {
  bootfs_files_labels = [
    "//src/bringup:bootfs",
    "//src/bringup/bin/console:bootfs",
    "//src/bringup/bin/console-launcher:bootfs",
    "//src/bringup/bin/debuglog:bootfs",
    "//src/bringup/bin/device-name-provider:bootfs",
    "//src/bringup/bin/dlog:bootfs",
    "//src/bringup/bin/netsvc:bootfs",
    "//src/bringup/bin/waitfor:bootfs",
    "//src/devices/bin/driver_host:bootfs",
    "//src/devices/bin/driver_manager:bootfs",
    "//src/power/power-manager:bootfs",
    "//src/power/shutdown-shim:bootfs",
    "//src/sys/bootstrap:bootfs",
    "//src/sys/component_manager:bootfs",
    "//src/sys/live_usb:bootfs",
  ]
  bootfs_packages = [
    "//src/bringup/bin/svchost:pkg",
    "//src/bringup/bin/miscsvc:package",
    "//src/bringup/bin/ptysvc:package",
    "//src/bringup/bin/pwrbtn-monitor:package",
    "//src/bringup/bin/sysinfo:package",
    "//src/devices/bin/devfs:package",
    "//src/devices/bin/driver-index:package",
  ]
  kernel_cmdline = [ "blobfs.cache-eviction-policy=NEVER_EVICT" ]

  bootfs_files = [
    {
      # The CFv2 topology root
      label = "//src/sys/root"
      source = get_label_info(label, "target_out_dir") +
               "/root_component_manifest/root.cm"
      destination = "meta/root.cm"
    },
    {
      # This file is generated by GN
      source = "$root_build_dir/minimum-utc-stamp.txt"
      destination = "config/build_info/minimum_utc_stamp"
      label = "//build/info:latest-commit-date"
    },
  ]
}

# All eng build type products will include this Assembly Input Bundle.
# These kernel args should be refactored so that the AIBs have logical names.
assembly_input_bundle("kernel_args_eng") {
  kernel_cmdline = [
    "console.shell=true",
    "kernel.enable-debugging-syscalls=true",
    "kernel.enable-serial-syscalls=true",
    "netsvc.all-features=true",
    "netsvc.disable=false",
  ]
}

# All userdebug build type products will include this Assembly Input Bundle.
# These kernel args should be refactored so that the AIBs have logical names.
assembly_input_bundle("kernel_args_userdebug") {
  kernel_cmdline = [
    "console.shell=false",
    "kernel.enable-debugging-syscalls=false",
    "kernel.enable-serial-syscalls=output-only",
    "netsvc.disable=true",
  ]
}

# All user build type products will include this Assembly Input Bundle.
#
# These are all the default values, so this AIB can be safely removed, but we
# are keeping it around for now so that we can assert that nothing changed
# during refactor.
#
# These kernel args should be refactored so that the AIBs have logical names.
assembly_input_bundle("kernel_args_user") {
  kernel_cmdline = [
    "console.shell=false",
    "kernel.enable-debugging-syscalls=false",
    "kernel.enable-serial-syscalls=false",
    "netsvc.disable=true",
  ]
}

# The most-common, most-basic, Assembly Input Bundle that is included by all
# products that have an FVM (and therefore have base packages).
#
# This corresponds to the "minimal" platform configuration, the most-basic
# configuration that has pkg_resolver and pkg_cache, and can OTA itself.
#
# WARNING:  The only way to remove items from this AIB for a given product is to
# move them to other AIBs that are included by all other products.
#
assembly_input_bundle("common_minimal") {
  base_packages = [
    # The required SWD stack artifacts to enable packages in an FVM.
    "//src/sys/pkg/bin/pkg-cache",
    "//src/sys/pkg/bin/pkg-resolver",

    # The SWD stack artifacts that enable OTAs
    "//src/sys/pkg/bin/system-update-committer",
    "//src/sys/pkg/bin/system-updater",

    # Build-Information
    "//src/developer/build_info:build-info-service",

    # Hardware Information
    "//src/hwinfo:hwinfo",

    # Diagnostics
    "//src/cobalt/bin/app:cobalt",
    "//src/cobalt/bin/system-metrics:cobalt_system_metrics",
    "//src/diagnostics/log-stats:package",
    "//src/diagnostics/persistence:diagnostics-persistence",
    "//src/diagnostics/kcounter:diagnostics-kcounter",
    "//src/diagnostics/sampler",

    # Other
    "//src/sys/stash:pkg",

    "//src/sys/time/timekeeper",
    "//src/sys/time/httpsdate_time_source:httpsdate-time-source",

    # Security
    "//src/security/bin/root_ssl_certificates",

    # Activity
    "//src/sys/activity",

    # Developer
    "//src/developer/forensics:pkg",
    "//src/developer/memory/monitor",
  ]

  bootfs_files = [
    {
      source = "//src/sys/core/config/core.profiles"
      destination = "config/profiles/core.profiles"
    },
  ]

  config_data = [
    {
      package_name = "system-update-committer"
      files = [
        {
          # This file is generated by GN, but its contents are always the same
          # (the template which generates it is basically a macro, and has no
          # product-controlled GN arguments or metadata).
          source = "$root_build_dir/gen/src/sys/pkg/bin/system-update-committer/system_update_committer_config_enable_reboot_on_verification_failure.json"
          destination = "config.json"
          label = "//src/sys/pkg/bin/system-update-committer:enable_reboot_on_verification_failure"
        },
      ]
    },
    {
      package_name = "triage-detect"
      files = [
        {
          source =
              "//src/diagnostics/config/triage/detect/session-detect.triage"
          destination = "session-detect.triage"
        },
        {
          source = "//src/diagnostics/config/triage/detect/sysmem-detect.triage"
          destination = "sysmem-detect.triage"
        },
        {
          source = "//src/diagnostics/config/triage/detect/wlan-detect.triage"
          destination = "wlan-detect.triage"
        },
      ]
    },
    {
      package_name = "diagnostics-persistence"
      files = [
        {
          source = "//src/diagnostics/config/persistence/netstack.persist"
          destination = "netstack.persist"
        },
        {
          source = "//src/diagnostics/config/persistence/wlan.persist"
          destination = "wlan.persist"
        },
      ]
    },
  ]

  config_data_labels = [
    "//src/diagnostics/config/sampler:sampler_config_internal",
    "//src/diagnostics/config/fire:fire_config_component_list",
    "//src/diagnostics/config/fire/projects:fire_config_projects",
  ]

  compiled_packages = [
    {
      name = "core"
      component_shards = {
        core = [
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          rebase_path(
              "//src/sys/process-resolver/meta/process_resolver.core_shard.cml",
              root_build_dir),
        ]
      }
    },
  ]
}

# This is common across all eng-mode products, at the minimal or higher service
# level.
#
assembly_input_bundle("common_minimal_eng") {
  testonly = true
  base_packages = [
    # Empty placeholder for now, this is setting up the pattern, before actually
    # moving packages into it (the next CL)

    # Dash launcher should be available in every engineering-mode product.
    "//src/sys/tools/debug-dash-launcher",
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = {
        core = [
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          rebase_path(
              "//src/sys/tools/debug-dash-launcher/meta/debug_dash_launcher.core_shard.cml",
              root_build_dir),
        ]
      }
    },
  ]
}

# This is common across all eng-mode and user-debug products, at the minimal or
# higher service level.
#
assembly_input_bundle("common_minimal_userdebug") {
  base_packages = [ "//src/diagnostics/detect:triage-detect" ]
}

# This is the "emulator support" bundle, which provides the kernel that can be
# booted by an emulator, and which knows how to then boot the Fuchsia kernel
# itself (Zircon).
assembly_input_bundle("emulator_support") {
  # Which label and file the qemu kernel is at is dependent on the arch of the
  # target we are compiling for.
  if (target_cpu == "x64") {
    _qemu_kernel_file = "$root_build_dir/multiboot.bin"
    _qemu_kernel_target =
        "//zircon/kernel/arch/x86/phys/boot-shim:multiboot-shim"
  } else if (target_cpu == "arm64") {
    _qemu_kernel_file = "$root_build_dir/qemu-boot-shim.bin"
    _qemu_kernel_target = "//zircon/kernel/target/arm64/boot-shim:qemu"
  } else {
    assert(false, "Unsupported target cpu: $target_cpu")
  }

  qemu_kernel = _qemu_kernel_file
  deps = [ _qemu_kernel_target ]
}

assembly_input_bundle("system-update-checker") {
  testonly = true
}

assembly_input_bundle("omaha-client") {
}

assembly_input_bundle("archivist-no-detect-service") {
  bootfs_files_labels =
      [ "//src/diagnostics/archivist:no-detect-service-config-for-assembly" ]
}

assembly_input_bundle("archivist-no-service") {
  bootfs_files_labels =
      [ "//src/diagnostics/archivist:no-service-config-for-assembly" ]
}

assembly_input_bundle("archivist-bringup") {
  bootfs_files_labels =
      [ "//src/diagnostics/archivist:bringup-config-for-assembly" ]
}

assembly_input_bundle("archivist-minimal") {
  bootfs_files_labels =
      [ "//src/diagnostics/archivist:default-service-config-for-assembly" ]
}

assembly_input_bundle("wlan_base") {
  base_packages = [
    "//src/connectivity/location/regulatory_region",
    "//src/connectivity/wlan/wlancfg",
  ]
}

assembly_input_bundle("wlan_legacy_privacy_support") {
  base_packages = []
}

assembly_input_bundle("wlan_contemporary_privacy_only_support") {
  base_packages = []
}

assembly_input_bundle("wlan_fullmac_support") {
  base_packages = [
    # This is temporarily placed here while USME migration is ongoing.
    # TODO(fxbug.dev/66772): Move this to "wlan_legacy_privacy_support" AIB once USME
    #                        migration is done.
    "//src/connectivity/wlan/wlandevicemonitor:wlandevicemonitor-legacy-privacy",
  ]
  base_driver_packages = [
    {
      package_target = "//src/connectivity/wlan/drivers/wlanif"
      driver_components = [ "meta/wlanif.cm" ]
    },
  ]
}

assembly_input_bundle("wlan_softmac_support") {
  base_packages = [
    # This is temporarily placed here while USME migration is ongoing.
    # TODO(fxbug.dev/66772): Move the below package(s) to "wlan_contemporary_privacy_only_support"
    #                        AIB once USME migration is done.
    "//src/connectivity/wlan/wlandevicemonitor:wlandevicemonitor-legacy-wlanstack",
    "//src/connectivity/wlan/wlanstack",
  ]
  base_driver_packages = [
    {
      package_target = "//src/connectivity/wlan/drivers/wlansoftmac"
      driver_components = [ "meta/wlansoftmac.cm" ]
    },
  ]
}
