# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/assembly/assembly_input_bundle.gni")
import("//build/icu/icu_assembly_input_bundle.gni")
import("//bundles/assembly/platform_aibs.gni")
import("//zircon/kernel/phys/qemu.gni")

########
# Guaranteed Invariants
#
#
# Invariants that are guaranteed by these platform-defined Assembly Input
# Bundles (AIBs):
#
# 1) Their contents are bitwise identical for all boards and products, for a
#    given architecture and "debug" vs. "release".  They could be built once-
#    each for the following, and then used as prebuilts if the build supported
#    that:
#      - x64-release
#      - x64-debug
#      - arm64-release
#      - arm64-debug
#    This is not currently possible given the state of the in-tree build, but it
#    is a contract that we have for using these with our OOT product assembly
#    environments.
#
# 2) Each AIB directly lists files that it includes, or the label to the exact
#    GN target that it includes.  They do not include group() targets.
#
# 3) Any single artifact is only included in one AIB.

########
# Maintenance Guidelines
#
# DO:  Prefer verboseness and clarity over abstractions and delegation.
#
# The template used in this file requires the direct listing of the package,
# config_data, and bootfs labels or entries.
#
# DO NOT: import a file that defines, for example, a list of labels or a set of
# config_data entries, that are added to an AIB using a GN variable.
#
# Importing other files which define variables used to provide the contents for
# an AIB reduces the clarity of how an artifact gets included first in AIBs, and
# later the assembled image.  This makes it harder to reason about how and when
# the artifacts are included within the assembled product.

assert(is_fuchsia,
       "Assembly Input Bundles can only be in the Fuchsia toolchain")

# All of the platform assembly input bundles.
group("assembly") {
  testonly = true

  # eng_platform_aib_labels come from //bundles/assembly/platform_aibs.gni.
  deps = eng_platform_aib_labels
}

########
#
# The /bootstrap realm AIBs
#
# The most-common, most-basic, Assembly Input Bundles that are included by all
# assembled systems.  No system can function without these.
#
# These provide the `/bootstrap` realm and its children that are always present
# in each of the build-types.
#

# The most-common, most-basic, AIB that is included in all assembled systems,
# regardless of build-type.
#
# WARNING:  The only way to remove items from this AIB for a given product is to
# move them to other AIBs that are included by all other products.
#
assembly_input_bundle("bootstrap") {
  bootfs_files_labels = [
    "//src/bringup:bootfs",
    "//src/bringup/bin/debuglog:bootfs",
    "//src/bringup/bin/dlog:bootfs",
    "//src/bringup/bin/waitfor:bootfs",
    "//src/sys/bootstrap:bootfs",
    "//src/sys/component_manager:bootfs",
  ]
  bootfs_packages = [
    "//src/bringup/bin/svchost:pkg",
    "//src/bringup/bin/console:package",
    "//src/bringup/bin/console-launcher:package",
    "//src/bringup/bin/device-name-provider:package",
    "//src/bringup/bin/miscsvc:package",
    "//src/bringup/bin/netsvc:package",
    "//src/bringup/bin/ptysvc:package",
    "//src/bringup/bin/pwrbtn-monitor:package",
    "//src/bringup/bin/sysinfo:package",
    "//src/devices/bin/devfs:package",
    "//src/devices/bin/driver-index:package",
    "//src/diagnostics/archivist:package",
    "//src/power/power-manager:package",
    "//src/power/shutdown-shim:package",
  ]
  kernel_cmdline = [ "blobfs.cache-eviction-policy=NEVER_EVICT" ]

  bootfs_files = [
    {
      # The CFv2 topology root
      label = "//src/sys/root"
      source = get_label_info(label, "target_out_dir") +
               "/root_component_manifest/root.cm"
      destination = "meta/root.cm"
    },
    {
      # This file is generated by GN
      source = "$root_build_dir/minimum-utc-stamp.txt"
      destination = "config/build_info/minimum_utc_stamp"
      label = "//build/info:latest-commit-date"
    },
  ]
}

# The virtcon AIB is included by all eng and userdebug products, and can be
# optionally included by user products.
#
assembly_input_bundle("virtcon") {
  bootfs_files_labels = [
    # TODO(120776) The boot animation is configured via a global GN arg, which
    # needs to be migrated to a path provided by the product to assembly, which
    # then places it in the appropriate path in bootfs.
    #
    # As such, this isn't something that should be added to a platform bundle,
    # but the migration with the products that use that GN arg is sufficiently
    # complicated that this is clearer that trying to do a removal of the
    # default boot animation in those products that shouldn't include it (if
    # it's included by default via `//products/common/bringup.gni`).
    "//src/bringup/bin/virtcon:boot_animation",
  ]

  bootfs_packages = [ "//src/bringup/bin/virtcon:package" ]
}

# All eng build type products will include this Assembly Input Bundle.
# These kernel args should be refactored so that the AIBs have logical names.
#
assembly_input_bundle("kernel_args_eng") {
  kernel_cmdline = [
    "console.shell=true",
    "kernel.enable-debugging-syscalls=true",
    "kernel.enable-serial-syscalls=true",
    "netsvc.all-features=true",
    "netsvc.disable=false",
  ]
}

# All userdebug build type products will include this Assembly Input Bundle.
# These kernel args should be refactored so that the AIBs have logical names.
#
assembly_input_bundle("kernel_args_userdebug") {
  kernel_cmdline = [
    "console.shell=false",
    "kernel.enable-debugging-syscalls=false",
    "kernel.enable-serial-syscalls=output-only",
    "netsvc.disable=true",
  ]
}

# All user build type products will include this Assembly Input Bundle.
#
# These are all the default values, so this AIB can be safely removed, but we
# are keeping it around for now so that we can assert that nothing changed
# during refactor.
#
# These kernel args should be refactored so that the AIBs have logical names.
assembly_input_bundle("kernel_args_user") {
  kernel_cmdline = [
    "console.shell=false",
    "kernel.enable-debugging-syscalls=false",
    "kernel.enable-serial-syscalls=false",
    "netsvc.disable=true",
  ]
}

########
#
# The /core realm AIBs
#
# These are the Assembly Input Bundles that are included by all assembled
# systems that include the `/core` realm.

# core_realm
#
# This AIB adds the `/core` realm itself, and it's mandatory children.  The
# other AIBs in this group add shards and optional children of `/core`.
#
# This is "less than minimal".  "utility" systems include this to get a `/core`
# realm, but do not include the `common_minimal` AIB as that brings in too much
# functionality for these specialized systems.
#
assembly_input_bundle("core_realm") {
  base_packages = [
    # The required SWD stack artifacts to enable packages in an FVM.
    "//src/sys/pkg/bin/pkg-cache",

    # This is a required dependency of pkg-cache
    "//src/sys/pkg/bin/system-update-committer",

    # This is the update realm which will contain system-update-committer
    "//src/sys/pkg:system-update-realm",

    # Build-Information
    "//src/developer/build_info:build-info-service",

    # Driver system memory connector
    "//src/devices/sysmem/bin/sysmem_connector:pkg",
  ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.

          # TODO:  These shards should be folded into the `core.cml` file itself
          # as they are never omitted from that file.

          component_name = "core"
          shards = rebase_path(
                  [ "//src/developer/build_info/meta/build_info.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# core_realm_networking
#
# This AIB adds all the children of `/core` that are expected to be present if
# networking is enabled.
#
# It does _not_ include either the `network` or `netstack` packages themselves,
# as which specific variant of those is added is controllable by the product, so
# they are in separate AIBs.
#
# "Utility" systems get this in the 'user' build-type only if they request that
# networking is added.  All other build-types (and all "minimal" systems) get
# this AIB by mandatory inclusion.
assembly_input_bundle("core_realm_networking") {
  base_packages = [
    # Hardware Information
    "//src/hwinfo",

    # System Time
    "//src/sys/time/timekeeper",
    "//src/sys/time/httpsdate_time_source:httpsdate-time-source",
    "//src/sys/time/httpsdate_time_source:httpsdate-time-source-pull",

    # Other
    "//src/sys/stash:pkg",
  ]
}

# This is common across all eng-mode products that include the core realm.
#
# This is mutually-exclusive with the `core_realm_user_and_userdebug` AIB.
#
assembly_input_bundle("core_realm_eng") {
  testonly = true
  base_packages = [
    "//src/sys/pkg/bin/pkg-resolver:pkg-resolver-eng",

    # Dash launcher should be available in every engineering-mode product.
    "//src/sys/tools/debug-dash-launcher",

    # The fs_realm component should be available in every engineering-mode product.
    "//src/storage/fs_realm",
    "//src/storage/bin:fs_realm_tools",
  ]
  bootfs_files_labels = [
    # NOTE: this might belong to a currently not-existing bootstrap_eng AIB.
    "//src/diagnostics/iquery:bootfs",
  ]
  shell_commands = [
    {
      package = "fs_realm_tools"
      components = [
        "mkfs",
        "fsck",
        "mount",
        "umount",
      ]
    },
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [
                    # The process_resolver core shard (either the base-resolver or
                    # pkg-resolver variant) should only be present in
                    # the `core_realm_development_access` AIB, but it's required
                    # here until optional exposes are available, as the
                    # `fuchsia.process.Resolver` capability is routed to the
                    # `/bootstrap/console-launcher` component which is currently
                    # present on all build-types (but is not needed on user, as
                    # there is no reachable console there).
                    # Note that the `process-resolver` component itself is not
                    # present except when the `core_realm_development_access` is
                    # added to the system.
                    #
                    # eng uses the pkg-resolver, as opposed to the base-resolver,
                    # to support ephemeral resolution of shell packages.
                    "//src/sys/process-resolver/meta/process_resolver.pkg-resolver.core_shard.cml",

                    "//src/sys/core/meta/core-env-full-resolver.core_shard.cml",
                    "//src/sys/core/meta/unrestricted-storage.core_shard.cml",
                    "//src/sys/tools/debug-dash-launcher/meta/debug_dash_launcher.core_shard.cml",
                    "//src/storage/fs_realm/meta/fs_realm.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# This is common across all user and userdebug products that include the core
# realm.
#
# This is mutually-exclusive with the `core_realm_eng` AIB.
#
assembly_input_bundle("core_realm_user_and_userdebug") {
  base_packages = [ "//src/sys/pkg/bin/pkg-resolver" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [
                    # user and userdebug only have the base resolver, not the full
                    # resolver.
                    "//src/sys/core/meta/core-env-base-resolver.core_shard.cml",

                    # The process_resolver core shard (either the base-resolver or
                    # pkg-resolver variant) should only be present in
                    # the `core_realm_development_access` AIB, but it's required
                    # here until optional exposes are available, as the
                    # `fuchsia.process.Resolver` capability is routed to the
                    # `/bootstrap/console-launcher` component which is currently
                    # present on all build-types (but is not needed on user, as
                    # there is no reachable console there).
                    # Note that the `process-resolver` component itself is not
                    # present except when the `core_realm_development_access` is
                    # added to the system.
                    #
                    # user and userdebug only have the base-resolver, not the
                    # pkg-resolver.
                    "//src/sys/process-resolver/meta/process_resolver.base-resolver.core_shard.cml",

                    # user and userdebug restrict access to the Storage capability
                    # to registered component ids.
                    "//src/sys/core/meta/restricted-storage.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# This is the AIB that adds the services necessary for developers to access a
# target running Fuchsia from their development host using tools like `ffx`.
#
# This is included with all eng and userdebug build-type systems.
#
assembly_input_bundle("core_realm_development_access") {
  base_packages = [
    # SSH is necessary for remote access for development
    "//src/developer/sshd-host",

    # Process resolver enables cli commands to be resolved to components.
    "//src/sys/process-resolver",

    # ffx's remote-control (remote access) components:
    "//src/developer/remote-control:remote-control-package",
    "//src/developer/remote-control:pkg-diagnostics-bridge",
    "//src/connectivity/overnet/overnetstack",

    # The developer snapshot tool.
    "//src/developer/forensics/snapshot:pkg",
  ]
  config_data_labels = [ "//src/developer/remote-control:maps" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [
                    "//src/developer/sshd-host/meta/sshd-host.core_shard.cml",
                    "//src/developer/remote-control/meta/remote-control-base.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
  shell_commands = [
    {
      package = "remote-control"
      components = [
        "remote_control_runner",
        "remote_control_bin",
      ]
    },
    {
      package = "snapshot"
      components = [ "snapshot" ]
    },
  ]
}

assembly_input_bundle("core_realm_development_access_rcs_usb") {
  base_driver_packages = [
    {
      package_target = "//src/connectivity/overnet/usb:overnet-usb-package"
      driver_components = [ "meta/overnet-usb.cm" ]
    },
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [ "//src/developer/remote-control/meta/remote-control-with-usb.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("core_realm_development_access_rcs_no_usb") {
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [ "//src/developer/remote-control/meta/remote-control.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("radar_proxy_with_injector") {
  base_packages =
      [ "//src/devices/radar/bin/radar-proxy:radar-proxy-with-injector" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/devices/radar/bin/radar-proxy/meta/radar-proxy.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("radar_proxy_without_injector") {
  base_packages =
      [ "//src/devices/radar/bin/radar-proxy:radar-proxy-without-injector" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/devices/radar/bin/radar-proxy/meta/radar-proxy.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

########
#
# The "minimal" AIBs
#
# These correspond to the use of "minimal.gni" as a platform configuration.  Its
# contents are being moved into the `core_realm` and feature- or subsystem-
# specific AIBs that are are included in various different combinations of the
# feature_set_level and the build-type.
#
# TODO(http://fxbug.dev/113922) Move the contents of common_minimal to the right
# feature- or subsystem-specific AIBs (if not to the core realm AIBs).
#
# WARNING:  The only way to remove items from this AIB for a given product is to
# move them to other AIBs that are included by all other products.
#
assembly_input_bundle("common_minimal") {
  base_packages = [
    # The SWD stack artifacts that enable OTAs
    "//src/sys/pkg/bin/system-updater",

    # Diagnostics
    "//src/cobalt/bin/app:cobalt",
    "//src/cobalt/bin/system-metrics:cobalt_system_metrics",
    "//src/diagnostics/persistence:diagnostics-persistence",
    "//src/diagnostics/kcounter:diagnostics-kcounter",
    "//src/diagnostics/sampler",

    # Internationalization
    "//src/intl/tzdata_provider",

    # Security
    "//src/security/bin/root_ssl_certificates",

    # Activity
    "//src/sys/activity",

    # Developer
    "//src/developer/forensics:pkg",
    "//src/developer/memory/monitor",
  ]

  bootfs_files = [
    {
      source = "//src/sys/core/config/core.profiles"
      destination = "config/profiles/core.profiles"
    },
  ]

  config_data = [
    {
      package_name = "system-update-committer"
      files = [
        {
          # This file is generated by GN, but its contents are always the same
          # (the template which generates it is basically a macro, and has no
          # product-controlled GN arguments or metadata).
          source = "$root_build_dir/gen/src/sys/pkg/bin/system-update-committer/system_update_committer_config_enable_reboot_on_verification_failure.json"
          destination = "config.json"
          label = "//src/sys/pkg/bin/system-update-committer:enable_reboot_on_verification_failure"
        },
      ]
    },
    {
      package_name = "triage-detect"
      files = [
        {
          source =
              "//src/diagnostics/config/triage/detect/session-detect.triage"
          destination = "session-detect.triage"
        },
        {
          source = "//src/diagnostics/config/triage/detect/sysmem-detect.triage"
          destination = "sysmem-detect.triage"
        },
        {
          source = "//src/diagnostics/config/triage/detect/wlan-detect.triage"
          destination = "wlan-detect.triage"
        },
      ]
    },
    {
      package_name = "diagnostics-persistence"
      files = [
        {
          source = "//src/diagnostics/config/persistence/netstack.persist"
          destination = "netstack.persist"
        },
        {
          source = "//src/diagnostics/config/persistence/wlan.persist"
          destination = "wlan.persist"
        },
      ]
    },
  ]

  config_data_labels = [
    "//src/diagnostics/config/sampler:sampler_config_internal",
    "//src/diagnostics/config/fire:fire_config_component_list",
    "//src/diagnostics/config/fire/projects:fire_config_projects",
  ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [
                    "//src/diagnostics/kcounter/meta/diagnostics-kcounter.core_shard.cml",
                    "//src/diagnostics/realm/meta/diagnostics.core_shard.cml",
                    "//src/diagnostics/persistence/meta/diagnostics-persistence.core_shard.cml",
                    "//src/diagnostics/sampler/meta/sampler.core_shard.cml",
                    "//src/connectivity/network/meta/persistence.core_shard.cml",
                    "//src/intl/tzdata_provider/meta/tzdata_provider.core_shard.cml",
                    "//src/sys/cache_manager/meta/cache_manager.core_shard.cml",

                    # TODO(fxbug.dev/112433): The trace manager core shard should only
                    # appear in eng builds, however, many components do not properly
                    # declare their route dependencies on it as optional causing scrutiny
                    # to fail route checking. Once the all of the component routes are
                    # properly declared optional, this shard should be removed from here
                    # and added in "common_minimal_eng" instead.
                    "//src/performance/trace_manager/meta/trace_manager.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
    {
      name = "diagnostics"
      components = [
        {
          component_name = "diagnostics"
          shards =
              rebase_path("//src/diagnostics/realm/meta/diagnostics_realm.cml",
                          root_build_dir)
        },
      ]
    },
    {
      name = "diagnostics"
      component_shards = [
        {
          component_name = "diagnostics"
          shards = rebase_path(
                  [ "//src/diagnostics/kcounter/meta/diagnostics-kcounter.realm_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# This is common across all eng-mode products, at the minimal or higher service
# level.
#
assembly_input_bundle("common_minimal_eng") {
  testonly = true
  base_packages = []
  cache_packages = [ "//src/devices/bin/driver_playground:pkg" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/devices/bin/driver_playground/meta/driver_playground.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# This is common across all eng-mode and user-debug products, at the minimal or
# higher service level.
#
assembly_input_bundle("common_minimal_userdebug") {
  base_packages = [ "//src/diagnostics/detect:triage-detect" ]
  compiled_packages = [
    {
      name = "diagnostics"
      component_shards = [
        {
          component_name = "diagnostics"
          shards = rebase_path(
                  [ "//src/diagnostics/detect/meta/detect.realm_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/diagnostics/detect/meta/detect.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

########
#
# Feature- and Subsystem-specific AIBs
#
# These are optionally present in all products that include the `/core` realm
# (via the `:core_realm` AIB).  Each should list which feature_set_level and
# build type that it is valid for.

# Driver Framework V1 support
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("driver_framework_v1") {
  bootfs_packages = [ "//src/devices/bin/driver_manager:dfv1_package" ]
}

# Driver Framework V2 support
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("driver_framework_v2") {
  bootfs_packages = [
    "//src/devices/bin/driver_host2:package",
    "//src/devices/bin/driver_manager:dfv2_package",
  ]
}

# Core starnix support.
#
# optional: product must specify its inclusion
# valid feature_set_levels: minimal
# valid build-types: all
#
assembly_input_bundle("starnix_support") {
  cache_packages = [
    "//src/starnix/runner:starnix_package",
    "//src/starnix/kernel:starnix_kernel_package",
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/starnix/runner/meta/starnix_runner.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# This AIB enables testing support, and is meant to be used with either the
# `common_minimal_eng` and `common_minimal_userdebug` AIBs.
#
# This includes testing support in the platform `base` package set, not just
# via `universe`
assembly_input_bundle("testing_support") {
  testonly = true
  base_packages = [ "//src/performance/trace_manager" ]
  cache_packages = [
    # test-manager and all of its runners:
    "//src/sys/test_manager:pkg",
    "//src/sys/test_runners/dart_wrapper:dart-aot-wrapper-runner",
    "//src/sys/test_runners/dart_wrapper:dart-jit-wrapper-runner",
    "//src/sys/test_runners/elf:elf-test-runner",
    "//src/sys/test_runners/elf:elf-test-ambient-exec-runner",
    "//src/sys/test_runners/elf:elf-test-create-raw-processes-runner",
    "//src/sys/test_runners/elf:elf-test-create-raw-processes-ambient-exec-runner",
    "//src/sys/test_runners/fuzz:fuzz-test-runner",
    "//src/sys/test_runners/gotests:go-test-runner",
    "//src/sys/test_runners/gtest:gtest-runner",
    "//src/sys/test_runners/gunit:gunit-runner",
    "//src/sys/test_runners/inspect:inspect-test-runner",
    "//src/sys/test_runners/legacy_test:legacy-test-runner",
    "//src/sys/test_runners/lib_loader_cache:lib_loader_runner_cache",
    "//src/sys/test_runners/rust:rust-test-next-vdso-runner",
    "//src/sys/test_runners/rust:rust-test-runner",
    "//src/sys/test_runners/starnix:starnix-test-runners",
    "//src/sys/test_runners/stress_test:stress-test-runner",
    "//src/connectivity/network/testing/netemul/runner:package",

    # required dependencies of test-manager
    "//src/sys/testing:testing",  # The test_realm component's package
    "//src/lib/fuchsia-component-test/realm_builder_server:pkg",
    "//src/sys/fuzzing:fuzz-manager",
    "//src/sys/fuzzing:fuzz-registry",
    "//src/sys/fuzzing/fuzzctl",
    "//src/sys/run_test_suite",
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [
                    # These should only be added by this AIB, because their
                    # packages are only added by this AIB, however due to many
                    # routing issues, they are included in a wider set of
                    # assemblies than just those that include "testing_support"
                    #
                    # "//src/sys/test_manager/meta/test_manager.core_shard.cml",
                    # "//src/sys/fuzzing/meta/fuzzing.core-shard.cml",
                    # "//src/sys/testing/meta/test_realm.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
  shell_commands = [
    {
      package = "run_test_suite"
      components = [ "run-test-suite" ]
    },
    {
      package = "fuzzctl"
      components = [ "fuzz_ctl" ]
    },
  ]
}

# AIB containing bootfs resources needed by all fshost variants
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
#
assembly_input_bundle("fshost_common") {
  compiled_packages = [
    {
      bootfs_unpackaged = true
      name = "fshost"
      components = [
        {
          component_name = "fshost"
          shards = rebase_path("//src/storage/fshost/meta/base_fshost.cml",
                               root_build_dir)
        },
      ]
      component_includes = [
        {
          source =
              rebase_path("//sdk/lib/inspect/client.shard.cml", root_build_dir)
          destination = "inspect/client.shard.cml"
        },
        {
          source =
              rebase_path("//sdk/lib/syslog/client.shard.cml", root_build_dir)
          destination = "syslog/client.shard.cml"
        },
        {
          source =
              rebase_path("//sdk/lib/syslog/offer.shard.cml", root_build_dir)
          destination = "syslog/offer.shard.cml"
        },
        {
          source = rebase_path("//sdk/lib/syslog/use.shard.cml", root_build_dir)
          destination = "syslog/use.shard.cml"
        },
      ]
    },
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards =
              rebase_path([
                            "//src/lib/storage/fs_management/client.shard.cml",
                            "//src/storage/fshost/meta/config.cml",
                          ],
                          root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels = [ "//src/storage/fshost:assembly_bundle_fshost_common" ]
}

# AIB adding support for storage, needed by all fshost variants that use anything more than bootfs
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
#
assembly_input_bundle("fshost_storage") {
  compiled_packages = [
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards = rebase_path([ "//src/storage/fshost/meta/core_fshost.cml" ],
                               root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels = [
    "//src/storage/fshost:assembly_bundle_fshost_storage_common",
    "//src/storage/bin/blobfs:bootfs",
    "//src/lib/trace/rust:bootfs",
  ]
}

# AIB containing fshost with fxfs enabled, but not fxblob
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
#
assembly_input_bundle("fshost_fxfs") {
  compiled_packages = [
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards = rebase_path([
                                 "//src/storage/fshost/meta/blobfs_fshost.cml",
                                 "//src/storage/fshost/meta/fxfs_fshost.cml",
                               ],
                               root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels = [ "//src/storage/fshost:assembly_bundle_fshost_fxfs" ]
}

# AIB containing the fshost with fxfs and fxblob enabled
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
#
assembly_input_bundle("fshost_fxfs_fxblob") {
  compiled_packages = [
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards =
              rebase_path([ "//src/storage/fshost/meta/fxfs_blob_fshost.cml" ],
                          root_build_dir)
        },
      ]
    },
  ]
}

# AIB containing fshost support for minfs-to-fxfs migration.
# Should be included with fshost_fxfs_fxblob or fshost_fxfs when migration
# is necessary.
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
# requires: one of fshost_fxfs*
#
assembly_input_bundle("fshost_fxfs_minfs_migration") {
  compiled_packages = [
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards = rebase_path([ "//src/storage/fshost/meta/minfs_fshost.cml" ],
                               root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels = [ "//src/storage/fshost:assembly_bundle_fshost_minfs" ]
}

# AIB containing fshost support for minfs. Not compatible with fxfs.
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
#
assembly_input_bundle("fshost_minfs") {
  compiled_packages = [
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards =
              rebase_path([
                            "//src/storage/fshost/meta/blobfs_fshost.cml",
                            "//src/storage/fshost/meta/minfs_fshost.cml",
                            "//src/storage/fshost/meta/non_fxfs_fshost.cml",
                          ],
                          root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels = [ "//src/storage/fshost:assembly_bundle_fshost_minfs" ]
}

# AIB containing fshost support for f2fs
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
#
assembly_input_bundle("fshost_f2fs") {
  compiled_packages = [
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards =
              rebase_path([
                            "//src/storage/fshost/meta/blobfs_fshost.cml",
                            "//src/storage/fshost/meta/f2fs_fshost.cml",
                            "//src/storage/fshost/meta/non_fxfs_fshost.cml",
                          ],
                          root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels = [ "//src/storage/fshost:assembly_bundle_fshost_f2fs" ]
}

assembly_input_bundle("system_update_checker") {
  testonly = true
}

assembly_input_bundle("omaha_client") {
}

# AIB to enable virtualization support.
#
# optional: product must specify its inclusion
# valid feature_set_levels: minimal
# valid build-types: all
#
assembly_input_bundle("virtualization_support") {
  base_packages = [ "//src/virtualization/bin/vmm_launcher" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [
                    "//src/virtualization/bin/vmm_launcher/meta/vmm_launcher.core_shard.cml",
                    "//src/virtualization/bin/guest_manager/meta/debian_guest_manager.core_shard.cml",
                    "//src/virtualization/bin/guest_manager/meta/termina_guest_manager.core_shard.cml",
                    "//src/virtualization/bin/guest_manager/meta/zircon_guest_manager.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# AIB to include Netstack2 as the netstack for use by base networking.
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("netstack2") {
  base_packages = [ "//src/connectivity/network:netstack2" ]
}

# AIB to include Netstack3 as the netstack for use by base networking.
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("netstack3") {
  base_packages = [ "//src/connectivity/network:netstack3" ]
}

# WLAN base support
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("wlan_base") {
  base_packages = [
    "//src/connectivity/location/regulatory_region",
    "//src/connectivity/wlan/wlancfg",
  ]
}

# WLAN support for WEP and WPA
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("wlan_legacy_privacy_support") {
  base_packages = [ "//src/connectivity/wlan/wlandevicemonitor:wlandevicemonitor-legacy-privacy" ]
}

# WLAN support for WPA2 and later
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("wlan_contemporary_privacy_only_support") {
  base_packages =
      [ "//src/connectivity/wlan/wlandevicemonitor:wlandevicemonitor" ]
}

# WLAN support for drivers that provide their own MAC
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("wlan_fullmac_support") {
  base_driver_packages = [
    {
      package_target = "//src/connectivity/wlan/drivers/wlanif"
      driver_components = [ "meta/wlanif.cm" ]
    },
  ]
}

# WLAN support for drivers that utilize a software MAC
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("wlan_softmac_support") {
  base_driver_packages = [
    {
      package_target = "//src/connectivity/wlan/drivers/wlansoftmac"
      driver_components = [ "meta/wlansoftmac.cm" ]
    },
  ]
}

# Support for interactive debugging/development of platform audio
#
# feature_set_levels: minimal
# build-types: eng
#
assembly_input_bundle("audio_dev_support") {
  base_driver_packages = [
    {
      package_target = "//src/media/audio/drivers/virtual_audio"
      driver_components = [ "meta/virtual_audio_driver.cm" ]
    },
  ]
}

assembly_input_bundle("live_usb") {
  bootfs_packages = [ "//src/sys/live_usb:package" ]

  kernel_cmdline = [ "live_usb.is_system=true" ]
}

assembly_input_bundle("empty_live_usb") {
  bootfs_packages = [ "//src/sys/live_usb:empty_package" ]
}

# Session manager support
#
# feature_set_levels: minimal
# build-types: all
assembly_input_bundle("session_manager") {
  base_packages = [ "//src/session/bin/session_manager" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [ "//src/session/bin/session_manager/meta/minimal.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Legacy Base UI support
# TODO(fxbug.dev/124273): Delete legacy support once it is consolidated with
# non-legacy.
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("ui_legacy") {
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards =
              rebase_path([ "//src/ui/meta/ui.core_shard.cml" ], root_build_dir)
        },
      ]
    },
  ]
}

# UI support
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("ui") {
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path([ "//src/ui/meta/ui_minimal.core_shard.cml" ],
                               root_build_dir)
        },
      ]
    },
  ]
}

# UI support for eng build types
#
# feature_set_levels: minimal
# build-types: eng
#
assembly_input_bundle("ui_eng") {
  cache_packages = [
    "//src/ui/a11y/bin/a11y_manager:a11y-manager",
    "//src/ui/bin/text:text_manager",
    "//src/ui/scenic:scenic_pkg",
    "//src/ui/bin/root_presenter:virtual_keyboard_manager",
    "//src/ui/bin/scene_manager",
  ]
}

# UI support for user and userdebug build types
#
# feature_set_levels: minimal
# build-types: user, userdebug
#
assembly_input_bundle("ui_user_and_userdebug") {
  base_packages = [
    "//src/ui/a11y/bin/a11y_manager:a11y-manager",
    "//src/ui/bin/text:text_manager",
    "//src/ui/scenic:scenic_pkg",
    "//src/ui/bin/root_presenter:virtual_keyboard_manager",
    "//src/ui/bin/scene_manager",
  ]
}

# Legacy UI support for eng build types
# TODO(fxbug.dev/124273): Delete the legacy support once it is consolidated with
# non-legacy.
#
# feature_set_levels: minimal
# build-types: eng
#
assembly_input_bundle("ui_legacy_package_eng") {
  cache_packages = [ "//src/ui:ui_package" ]
}

# Legacy UI support for user and userdebug build types
# TODO(fxbug.dev/124273): Delete the legacy support once it is consolidated with
# non-legacy.
#
# feature_set_levels: minimal
# build-types: user, userdebug
#
assembly_input_bundle("ui_legacy_package_user_and_userdebug") {
  base_packages = [ "//src/ui:ui_package" ]
}

# UI support for eng build types
#
# feature_set_levels: minimal
# build-types: eng
#
assembly_input_bundle("ui_package_eng") {
  cache_packages = [ "//src/ui:ui_minimal_package" ]
}

# UI support for user and userdebug build types
#
# feature_set_levels: minimal
# build-types: user, userdebug
#
assembly_input_bundle("ui_package_user_and_userdebug") {
  base_packages = [ "//src/ui:ui_minimal_package" ]
}

# Example assembly input bundle for testing
#
# Restricted for testing assembly itself (and to provide example code)
#
assembly_input_bundle("example_assembly_bundle") {
  testonly = true
  compiled_packages = [
    # Main definition for another package
    {
      name = "foo"

      # Test that multiple components work
      components = [
        {
          component_name = "bar"
          shards = rebase_path(
                  "//src/tests/assembly/assemble_image/compiled_package/meta/test.cml",
                  root_build_dir)
        },
        {
          component_name = "baz"
          shards = rebase_path(
                  "//src/tests/assembly/assemble_image/compiled_package/meta/test.cml",
                  root_build_dir)
        },
      ]

      # Test that component includes for bootfs packages work
      component_includes = [
        {
          source = rebase_path(
                  "//src/tests/assembly/assemble_image/compiled_package/meta/test.include.cml",
                  root_build_dir)
          destination = "test/include.cml"
        },
      ]
    },

    {
      name = "qux"
      components = [
        {
          component_name = "qux"
          shards = rebase_path(
                  "//src/tests/assembly/assemble_image/compiled_package/meta/test.cml",
                  root_build_dir)
        },
      ]

      # Test that component includes for bootfs packages work
      component_includes = [
        {
          source = rebase_path(
                  "//src/tests/assembly/assemble_image/compiled_package/meta/test.include.cml",
                  root_build_dir)
          destination = "test/include.cml"
        },
      ]

      # Test that bootfs packages work
      bootfs_unpackaged = true
    },

    # Add a shard to the `core` package which should have a main definition
    # in the legacy bundle
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [ "//src/tests/assembly/assemble_image/compiled_package/meta/test.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

########
#
# Hardware Support AIBs
#
# These are used to provide support for specific hardware

# Emulator Support
#
# This is the "emulator support" bundle, which provides the kernel that can be
# booted by an emulator, and which knows how to then boot the Fuchsia kernel
# itself (Zircon).
#
assembly_input_bundle("emulator_support") {
  qemu_kernel = qemu_boot_shim.path
  deps = qemu_boot_shim.deps
}

# Enabling a soft-transition, remove when complete
# TODO(122864) Remove transitional labels
group("third_party_sbase_for_transition") {
  public_deps = [ "//third_party/sbase" ]
}

icu_assembly_input_bundle("intl_services") {
  icu_base_packages = [ "//src/intl/intl_services:pkg" ]
}

assembly_input_bundle("fonts") {
  base_packages = [ "//src/fonts:pkg" ]
}
